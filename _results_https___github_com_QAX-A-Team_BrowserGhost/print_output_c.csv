        db, ""type='trigger' AND name='%q'"", zName ), P4_DYNAMIC"
      ""unable to use function %s in the requested context"", zName );"
    StrAccum pAccum,             /* Accumulate results here */"
""sqlite3_get_table() called with two or more incompatible queries"""
"Printf(
"Printf( ""  constraint[%d]: col=%d termid=%d op=%d usabled=%d\n"","
"Printf( ""  estimatedCost=%g\n"", p.estimatedCost );"
"Printf( ""  idxNum=%d\n"", p.idxNum );"
"Printf( ""  idxStr=%s\n"", p.idxStr );"
"Printf( ""  orderByConsumed=%d\n"", p.orderByConsumed );"
"Printf( ""  orderby[%d]: col=%d desc=%d\n"","
"Printf( ""  usage[%d]: argvIdx=%d omit=%d\n"","
"Printf( "" "" );"
"Printf( "" AS %s"", pItem.zAlias );"
"Printf( ""%*s "", indent + 6, zPrefix );"
"Printf( ""%*s GROUP BY "", indent, """" );"
"Printf( ""%*s HAVING "", indent, """" );"
"Printf( ""%*s ORDER BY "", indent, """" );"
"Printf( ""%*s WHERE "", indent, """" );"
"Printf( ""%*s)"", indent + 8, """" );"
"Printf( ""%*sSELECT(%p) "", indent, """", p );"
"Printf( ""%s"", pItem.zName );"
"Printf( ""(%d"", p.op );"
"Printf( ""(%s"", p.u.zToken );"
"Printf( ""(\n"" );"
"Printf( ""(table: %s)"", pItem.pTab.zName );"
"Printf( "")"" );"
"Printf( "", "" );"
"Printf( "","" );"
"Printf( ""SQL-trace: %s\n"", zTrace );"
"Printf( ""\n"" );"
"Printf( T, ap ); }"
"Printf( X, Y ); }"
"Printf( X, Y, Z ); }"
"Printf( X, Y, Z, A ); }"
"Printf( X, Y, Z, A, B ); }"
"Printf( X, Y, Z, A, B, C ); }"
"Printf( X, Y, Z, A, B, C, D ); }"
"Printf( X, ap ); }"
"Printf( acc, 0, zFormat, ap );"
"Printf( acc, 1, zFormat, ap );"
"Printf( db, ""%.*s\""%w\""%s"", zLoc, zSql.Substring( 0, zLoc ),"
"Printf( db, ""%s OR name=%Q"", zWhere, pTrig.name );"
"Printf( db, ""%s"", pColExpr.u.zToken );"
"Printf( db, ""%s"", pEList.a[i].zSpan );"
"Printf( db, ""%s"","
"Printf( db, ""%s-mj%08X"", zMainFile, iRandom & 0x7fffffff );"
"Printf( db, ""%s.%s"", pTab.zName, zCol );"
"Printf( db, ""%s.%s"", zTabName, zName );"
"Printf( db, ""%s:%d"", zName.Substring( 0, nName ), ++cnt );"
"Printf( db, ""*** in database %s ***\n"", db.aDb[i].zName ),"
"Printf( db, ""-%T"", pValue );"
"Printf( db, ""-- TRIGGER %s"", p.name ),"
"Printf( db, ""CREATE%s INDEX %.*s"","
"Printf( db, ""SELECT idx, stat FROM %Q.sqlite_stat1"","
"Printf( db, ""TABLE %s"", pItem.zName );"
"Printf( db, ""cannot ATTACH database within transaction"" );"
"Printf( db, ""database %s is already in use"", zName );"
"Printf( db, ""database is already attached"" );"
"Printf( db, ""name=%Q"", pTrig.name );"
"Printf( db, ""name='%q'"", pIndex.zName ), P4_DYNAMIC );"
"Printf( db, ""out of memory"" );"
"Printf( db, ""sqlite_altertab_%s"", pTab.zName );"
"Printf( db, ""sqlite_autoindex_%s_%d"", pTab.zName, n );"
"Printf( db, ""sqlite_subquery_%p_"", pTab );"
"Printf( db, ""tbl_name='%q'"", p.zName ), P4_DYNAMIC );"
"Printf( db, ""too many attached databases - max %d"","
"Printf( db, ""unable to open database: %s"", zFile );"
"Printf( db, ""unrecognized token: \""%T\"""","
"Printf( db, zFormat, ap );"
"Printf( db,"
"Printf( p.db, zFormat, ap );"
"Printf( pParse.db, ""%s.%s may not be NULL"","
"Printf( pParse.db, ""tbl_name=%Q"", zName );"
"Printf( sqlite3 db, string zFormat, params va_list[] ap )"
"Printf( string zFormat, params va_list[] ap )"
"Printf(""""); */"
"Printf(), but call //sqlite3DbFree() on zStr after formatting"
"Printf(StrAccum*, int, const char*, va_list);"
"Printf(const char*, ...);"
"Printf(db, ""%s"", pTab->zName);"
"Printf(db, ""%s"", zErr);"
"Printf(db, ""CREATE VIRTUAL TABLE %T"", &pParse->sNameToken);"
"Printf(db, ""cannot open value of type %s"","
"Printf(db, ""name='%q'"", pTab->zName);"
"Printf(db, ""no such column: \""%s\"""", zColumn);"
"Printf(db, ""no such module: %s"", zMod);"
"Printf(db, ""no such rowid: %lld"", iRow);"
"Printf(db, ""no such table column: %s.%s"", zTableName,"
"Printf(db, ""vtable constructor failed: %s"", zModuleName);"
"Printf(db, sqlite3_errmsg(db));"
"Printf(db, x, ""prefix %s suffix"", x);"
"Printf(db, zFormat, pTab->zName);"
"Printf(db,"
"Printf(pCheck.errMsg, 1, zFormat, ap);"
"Printf(sqlite3*,const char*, ...);"
"Printf(sqlite3*,const char*, va_list);"
"fprintf( TextWriter tw, string zFormat, params object[] ap ) { tw.Write( sqlite3_mprintf( zFormat, ap ) ); }"
"fprintf( _out, "" "" );"
"fprintf( _out, "" (rowset)"" );"
"fprintf( _out, "" NULL"" );"
"fprintf( _out, "" i:%lld"", p.u.i );"
"fprintf( _out, "" r:%g"", p.r );"
"fprintf( _out, "" si:%lld"", p.u.i );"
"fprintf( _out, ""%s"", zBuf );"
"fprintf( _out, ""\n"" );"
"fprintf( _out, ""reg[%d] = "", iReg );"
"fprintf( p.trace, ""rc=%d\n"", rc );"
"fprintf(out, ""%02x"", p.aOp[i].opcode);"
"fprintf(out, ""%6d %10lld %8lld "","
"fprintf(out, ""---- "");"
"fprintf(out, ""\n"");"
"fprintf(stderr, ""INPUT:  %s\n"", zBuf);"
"fprintf(stderr, ""OUTPUT: %s\n"", zBuf);"
"fprintf(stdout, ""%10llu "", elapsed);"
"fprintf(yyTraceFILE, "" %s"", yyTokenName[yypParser.yystack[i].major]);"
"fprintf(yyTraceFILE, ""%sAccept!\n"", yyTracePrompt);"
"fprintf(yyTraceFILE, ""%sFALLBACK %s => %s\n"","
"fprintf(yyTraceFILE, ""%sFail!\n"", yyTracePrompt);"
"fprintf(yyTraceFILE, ""%sInput %s\n"", yyTracePrompt, yyTokenName[yymajor]);"
"fprintf(yyTraceFILE, ""%sPopping %s\n"","
"fprintf(yyTraceFILE, ""%sReduce [%s].\n"", yyTracePrompt,"
"fprintf(yyTraceFILE, ""%sShift %d\n"", yyTracePrompt, yyNewState);"
"fprintf(yyTraceFILE, ""%sStack Overflow!\n"", yyTracePrompt);"
"fprintf(yyTraceFILE, ""%sStack:"", yyTracePrompt);"
"fprintf(yyTraceFILE, ""%sSyntax Error!\n"", yyTracePrompt);"
"fprintf(yyTraceFILE, ""%sWILDCARD %s => %s\n"","
"fprintf(yyTraceFILE, ""\n"");"
"fprintf(yyTraceFILE,""%sDiscard input token %s\n"","
"fprintf(yyTraceFILE,""%sStack grows to %d entries!\n"","
"printf(
"printf( ""%.*f"", n, r );"
"printf( ""VDBE Execution Trace:\n"" );"
"printf( ""not authorized"" );"
"printf( 100, ref  zCsr, ""%d["", pMem.n );"
"printf( 100, ref zBuf, ""%02d:%02d:%02d"", x.h, x.m, (int)x.s );"
"printf( 100, ref zBuf, ""%04d-%02d-%02d %02d:%02d:%02d"","
"printf( 100, ref zBuf, ""%04d-%02d-%02d"", x.Y, x.M, x.D );"
"printf( 100, ref zCsr, ""%02X"", ( (int)pMem.zBLOB[i] & 0xFF ) );"
"printf( 100, ref zCsr, ""%c"", c );"
"printf( 100, ref zCsr, ""%d"", pMem.n );//zBuf[k], ""%d"", pMem.n );"
"printf( 100, ref zCsr, ""+%dz"", pMem.u.nZero );"
"printf( 100, ref zCsr, ""]%s"", encnames[pMem.enc] );"
"printf( 100, ref zCsr, encnames[pMem.enc] );//& zBuf[k], encnames[pMem.enc] );"
"printf( 1000, ref  z, ""%s"", pOp.p4.z );"
"printf( 20, ref zTemp, ""%.16g"", x.iJD / 86400000.0 ); z.Append( zTemp );"
"printf( 200, ref zErr, ""cannot detach database %s"", zName );"
"printf( 200, ref zErr, ""database %s is locked"", zName );"
"printf( 200, ref zErr, ""no such database: %s"", zName );"
"printf( 200, ref zErr,"
"printf( 3, pMem.z, ""%.2x"", pOp.p5 );   /* P5 */"
"printf( 3, ref zTemp, ""%02d"", ( nDay + 7 - wd ) / 7 ); z.Append( zTemp );"
"printf( 3, ref zTemp, ""%02d"", (int)x.s ); z.Append( zTemp ); j += 2; break;"
"printf( 3, ref zTemp, ""%02d"", x.D ); z.Append( zTemp ); j += 2; break;"
"printf( 3, ref zTemp, ""%02d"", x.M ); z.Append( zTemp ); j += 2; break;"
"printf( 3, ref zTemp, ""%02d"", x.h ); z.Append( zTemp ); j += 2; break;"
"printf( 3, ref zTemp, ""%02d"", x.m ); z.Append( zTemp ); j += 2; break;"
"printf( 30, ref zTemp, ""%lld"","
"printf( 4, ref zTemp, ""%03d"", nDay + 1 ); z.Append( zTemp );"
"printf( 5, ref zTemp, ""%04d"", x.Y ); z.Append( zTemp ); j = sqlite3Strlen30( z );"
"printf( 7, ref zTemp, ""%06.3f"", s ); z.Append( zTemp );"
"printf( 999, ref zOut, zFormat1, pc,"
"printf( X, ap ); } }"
"printf( int n, ref StringBuilder zBuf, string zFormat, params va_list[] ap )"
"printf( int n, ref string zBuf, string zFormat, params va_list[] ap )"
"printf( nBuf, ref zBuf, ""OsError 0x%x (%u)"", error, error );"
"printf( nMsg, ref zErrmsg,"
"printf( nTemp, ref zTemp, ""%.16g"", pMem.r );"
"printf( nTemp, ref zTemp, ""%.16g"", pOp.p4.pReal );"
"printf( nTemp, ref zTemp, ""%d"", pOp.p4.i );"
"printf( nTemp, ref zTemp, ""%lld"", pMem.u.i );"
"printf( nTemp, ref zTemp, ""%lld"", pOp.p4.pI64 );"
"printf( nTemp, ref zTemp, ""%s(%d)"", pDef.zName, pDef.nArg );"
"printf( nTemp, ref zTemp, ""collseq(%.20s)"", ( pColl != null ? pColl.zName : ""null"" ) );"
"printf( nTemp, ref zTemp, ""intarray"" );"
"printf( nTemp, ref zTemp, ""keyinfo(%d"", pKeyInfo.nField );"
"printf( string zFormat, params  va_list[] ap )"
"printf( string zFormat, params object[] ap ) { Console.Out.Write( sqlite3_mprintf( zFormat, ap ) ); }"
"printf( string zFormat, params va_list[] ap )"
"printf( zFormat, ap );"
"printf(""%.78'-"")  prints 78 minus"
"printf(""%.78c"",'-')."
"printf(""%s"", colv[i]);"
"printf(""%s"",res.zErrMsg);"
"printf(""INSERT INTO table VALUES(%Q)"", zText);"
"printf(""INSERT INTO table VALUES('%q')"", zText);"
"printf(""error during initialization: %s"", zErrmsg);"
"printf() formatting options apply.  In addition, there"
"printf() routine is similar to ""snprintf()"" from"
"printf()"" family of functions"
"printf(200, ref zContext, ""Page %d: "", iPage);"
"printf(200, ref zContext,"
"printf(MAX_PATH-30, zTempPath, ""%s"", sqlite3_temp_directory);"
"printf(MAX_PATH-30, zTempPath, ""%s"", zMulti);"
"printf(MAX_PATH-30, zTempPath, ""%s"", zUtf8);"
"printf(X, ap); }"
"printf(const char*, va_list);"
"printf(const char*,...);"
"printf(int,char*,const char*, ...);"
"printf(n, zStmt,""CREATE TABLE "");"
"printf(n-k, zStmt[k], ""%s"", zEnd);"
"printf(n-k, zStmt[k], zSep);"
"printf(nBuf, zBuf, ""OsError 0x%x (%u)"", error, error);"
"printf(nBuf-30, zBuf,"
"printf(nByte, pMem.z, ""%!.15g"", pMem->r);"
"printf(nByte, pMem.z, ""%lld"", pMem->u.i);"
"printf(nMsg, zErrmsg,"
"printf(nTemp, ref zTemp, ""vtab:%p:%p"", pVtab, pVtab.pModule);"
"printf(pVfs.mxPathname, zFull, ""%s"", zOut);"
"printf(pVfs.mxPathname, zFull, ""%s"", zRelative);"
"printf(sizeof(zErr), zErr, ""%s"", sParse.zErrMsg);"
PUTS( sqlite3_index_info p )
PUTS(A)
PUTS(p);
Printf( X ); }
printf()
printf() */
printf() and sqlite3_vmprintf() routines write their
printf() built into some versions of windows does not understand %lld
printf() could do UTF-16.
printf() that understands %lld.  Used for debugging.
printf() to produce the UTF-8
printf() works like snprintf() except that it ignores the
printf().
printf().  Blob values are unchanged and
printf().  Converting a BLOB to a string
printf().  This is an
printf()] is used internally to perform the
printf()] to convert that value to a UTF-8 string and returns
printf()] to zErrMsg.  The method should
