"(   '%',  0, 0, etPERCENT,    0,  0 "
"(   'E',  0, 1, etEXP,        14, 0 "
"(   'G',  0, 1, etGENERIC,    14, 0 "
"(   'Q',  0, 4, etSQLESCAPE2, 0,  0 "
"(   'S',  0, 2, etSRCLIST,    0,  0 "
"(   'T',  0, 2, etTOKEN,      0,  0 "
"(   'X', 16, 0, etRADIX,      0,  4 "
"(   'c',  0, 0, etCHARX,      0,  0 "
"(   'e',  0, 1, etEXP,        30, 0 "
"(   'f',  0, 1, etFLOAT,      0,  0 "
"(   'g',  0, 1, etGENERIC,    30, 0 "
"(   'i', 10, 1, etRADIX,      0,  0 "
"(   'n',  0, 0, etSIZE,       0,  0 "
"(   'o',  8, 0, etRADIX,      0,  2 "
"(   'p', 16, 0, etPOINTER,    0,  1 "
"(   'q',  0, 4, etSQLESCAPE,  0,  0 "
"(   'r', 10, 3, etORDINAL,    0,  0 "
"(   's',  0, 4, etSTRING,     0,  0 "
"(   'u', 10, 0, etRADIX,      0,  0 "
"(   'w',  0, 4, etSQLESCAPE3, 0,  0 "
"(   'x', 16, 0, etRADIX,      16, 1 "
"(   'z',  0, 4, etDYNSTRING,  0,  0 "
"(  ""reverse_unordered_selects"", SQLITE_ReverseOrder  "
"(  'd', 10, 1, etRADIX,      0,  0 "
"(  OP_Halt,        0,  0,  0"
"(  OP_IfPos,       1,  0,  0"
"(  int index, string bText "
"(  zLeft,  offsetLeft,  zRight,  N "
"( !DbHasProperty( db, idx, DB_UnresetViews "
"( !Double.TryParse( z.Substring( 0, zDx "
"( !ExprHasAnyProperty( p, EP_TokenOnly "
"( !ExprHasAnyProperty( p, EP_TokenOnly | EP_Reduced "
"( !ExprHasAnyProperty( pA, EP_TokenOnly | EP_Reduced "
"( !ExprHasAnyProperty( pB, EP_TokenOnly | EP_Reduced "
"( !ExprHasAnyProperty( pE, EP_TokenOnly | EP_Reduced "
"( !ExprHasAnyProperty( pExpr, EP_IntValue | EP_Reduced | EP_TokenOnly "
"( !ExprHasAnyProperty( pExpr, EP_TokenOnly | EP_Reduced "
"( !ExprHasAnyProperty( pExpr, EP_VarSelect "
"( !ExprHasProperty( p, EP_FromJoin "
"( !ExprHasProperty( p, EP_IntValue "
"( !ExprHasProperty( p, EP_Reduced "
"( !ExprHasProperty( p, EP_Static "
"( !ExprHasProperty( p.pEList.a[0].pExpr, EP_xIsSelect "
"( !ExprHasProperty( pB, EP_IntValue "
"( !ExprHasProperty( pColExpr, EP_IntValue "
"( !ExprHasProperty( pE, EP_xIsSelect "
"( !ExprHasProperty( pE.pLeft, EP_IntValue "
"( !ExprHasProperty( pExpr, EP_IntValue "
"( !ExprHasProperty( pExpr, EP_xIsSelect "
"( !ExprHasProperty( pF.pExpr, EP_xIsSelect "
"( !ExprHasProperty( pNew, EP_xIsSelect "
"( !ExprHasProperty( sAggInfo.aFunc[i].pExpr, EP_xIsSelect "
"( !hasReadConflicts(pBtree, iRoot"
"( !hasReadConflicts(pCsr.pBtree, pCsr.pgnoRoot"
"( !isCompound && resolveOrderGroupBy( sNC, p, p.pOrderBy, ""ORDER"" "
"( !isMemDb && sqlite3BtreeSetPageSize( pTemp, db.nextPagesize, nRes, 0 "
"( !isVirtual && sqlite3AuthCheck(pParse, code, zName, 0, zDb"
"( !sqlite3ExprCompare( pA.pLeft, pB.pLeft "
"( !sqlite3ExprCompare( pA.pRight, pB.pRight "
"( !sqlite3ExprCompare( pExprA, pExprB "
"( !sqlite3IndexAffinityOk( pX, idxaff "
"( !sqlite3IsLikeFunction( db, pExpr, ref pnoCase, wc "
"( !xferCompatibleCollation( pDest.aCol[i].zColl, pSrc.aCol[i].zColl "
"( !xferCompatibleCollation( pSrc.azColl[i], pDest.azColl[i] "
"( ""  estimatedCost=%g\n"", p.estimatedCost "
"( ""  idxNum=%d\n"", p.idxNum "
"( ""  idxStr=%s\n"", p.idxStr "
"( ""  orderByConsumed=%d\n"", p.orderByConsumed "
"( "" "" "
"( "" AS %s"", pItem.zAlias "
"( """
"( """" == ""Invalid flags argument"" "
"( ""%*s "", indent + 6, zPrefix "
"( ""%*s GROUP BY "", indent, """" "
"( ""%*s HAVING "", indent, """" "
"( ""%*s ORDER BY "", indent, """" "
"( ""%*s WHERE "", indent, """" "
"( ""%*s"
"( ""%*sSELECT(%p"
"( ""%.*f"", n, r "
"( ""%s"", pItem.zName "
"( ""'"" "
"( ""(%d"", p.op "
"( ""(%s"", p.u.zToken "
"( ""(\n"" "
"( ""(table: %s"
"( ""* "" "
"( ""*** Optimizer Finished ***\n"" "
"( ""*** Optimizer Start ***\n"" "
"( "", "" "
"( "","" "
"( "",..."" "
"( "",nil"" "
"( ""-"" "
"( ""-"" + zNum, out pNum "
"( ""."" "
"( ""... best is rowid\n"" "
"( ""... index %s:\n"", pProbe.zName "
"( ""... multi-index OR cost=%.9g nrow=%.9g\n"", rTotal, nRow "
"( ""... rowid IN cost: %.9g\n"", pCost.rCost "
"( ""... rowid range reduces cost to %.9g\n"", cost "
"( ""... sorting increases OR cost to %.9g\n"", rTotal "
"( ""... sorting increases cost to %.9g\n"", cost "
"( ""... table scan _base cost: %.9g\n"", cost "
"( ""...... idx-only reduces cost to %.9g\n"", cost "
"( ""...... orderby increases cost to %.9g\n"", cost "
"( ""1"", 1 "
"( ""3.6.17.1"" "
"( "";"", "" "" "
"( ""CKVERS %p %d\n"", pPager, dbFileVers.Length "
"( ""CLEAN %p %d\n"", pPager, pPg.pgno "
"( ""CLOSE %d (%s"
"( ""CLOSE %d\n"", PAGERID( pPager "
"( ""CLOSE %p\n"", pPager "
"( ""COMMIT %d\n"", PAGERID( pPager "
"( ""CREATE TABLE "" "
"( ""DBHDR %p 0 %d\n"", pPager, N "
"( ""DBSYNC %p\n"", pPager "
"( ""DELETE \""%s\""\n"", zFilename "
"( ""DONT_WRITE page %d of %d\n"", pPg.pgno, PAGERID( pPager "
"( ""Error with executing non-query: \"""" + query + ""\""!\n"" + CSSQLite.sqlite3_errmsg( db "
"( ""Error with opening database "" + DatabaseName + ""!"" "
"( ""FETCH %d page %d hash(%08x"
"( ""IOERR\n"" "
"( ""JHDR %p %lld %d\n"", pPager, pPager.journalHdr, nHeader "
"( ""JHDR %p %lld\n"", pPager, pPager.journalHdr "
"( ""JOURNAL %d page %d needSync=%d hash(%08x"
"( ""JSYNC %p\n"", pPager "
"( ""JZEROHDR %p\n"", pPager "
"( ""Kernel32.dll"" "
"( ""LOCK %d %d was %d(%d"
"( ""LOCK %p %d\n"", pPager, locktype "
"( ""LOCK FAILED %d trying for %d but got %d\n"", pFile.fs.GetHashCode("
"( ""MOVE %d page %d (needSync=%d"
"( ""MOVE %p %d %d\n"", pPager, pPg.pgno, pgno "
"( ""NOSTORE %d page %d\n"", PAGERID( pPager "
"( ""OPEN %d %s\n"", FILEHANDLEID( pPager.fd "
"( ""OPEN %d (%s"
"( ""OPEN %p %s\n"", pPager, pPager.zFilename "
"( ""PGIN %p %d\n"", pPager, pgno "
"( ""PGOUT %p %d\n"", pPager, pgno "
"( ""PLAYBACK %d page %d hash(%08x"
"( ""READ %d lock=%d\n"", pFile.fs.GetHashCode("
"( ""ROLLBACK %d\n"", PAGERID( pPager "
"( ""SQL %s\n"", z.Trim("
"( ""SQL-trace: %s\n"", zTrace "
"( ""SQL: [%s]\n"", z "
"( ""STMT-JOURNAL %d page %d\n"", PAGERID( pPager "
"( ""STORE %d page %d hash(%08x"
"( ""STRESS %d page %d\n"", PAGERID( pPager "
"( ""SYNC %d lock=%d\n"", pFile.fs.GetHashCode("
"( ""SYNC journal of %d\n"", PAGERID( pPager "
"( ""TEMP FILENAME: %s\n"", zBuf.ToString("
"( ""TEST WR-LOCK %d %d (local"
"( ""TEST WR-LOCK %d %d (remote"
"( ""TRANSACTION %d\n"", PAGERID( pPager "
"( ""TRUNCATE %d %lld\n"", id.fs.Name, nByte "
"( ""UNLOCK %d to %d was %d(%d"
"( ""UNLOCK %p\n"", pPager "
"( ""UTF-16"",   0                  "
"( ""UTF-16be"", SQLITE_UTF16BE     "
"( ""UTF-16le"", SQLITE_UTF16LE     "
"( ""UTF-8"",    SQLITE_UTF8        "
"( ""UTF16"",    0                  "
"( ""UTF16be"",  SQLITE_UTF16BE     "
"( ""UTF16le"",  SQLITE_UTF16LE     "
"( ""UTF8"",     SQLITE_UTF8        "
"( ""VDBE Execution Trace:\n"" "
"( ""VDBE Program Listing:\n"" "
"( ""WRITE %d lock=%d\n"", id.fs.GetHashCode("
"( ""X'"" "
"( ""ZERO %p %d\n"", pPager, pgno "
"( ""\n"" "
"( ""bestIndex: tbl=%s notReady=%llx\n"", pSrc.pTab.zName, notReady "
"( ""clob"" "
"( ""could not get a PENDING lock. cnt=%d\n"", cnt "
"( ""count_changes"",            SQLITE_CountRows     "
"( ""empty_result_callbacks"",   SQLITE_NullCallback  "
"( ""error-code = %d\n"", error "
"( ""floa"" "
"( ""full_column_names"",        SQLITE_FullColNames  "
"( ""fullfsync"",                SQLITE_FullFSync     "
"( ""ignore_check_constraints"", SQLITE_IgnoreChecks  "
"( ""kernel32.dll"" "
"( ""legacy_file_format"",       SQLITE_LegacyFileFmt "
"( ""not authorized"" "
"( ""omit_readlock"",            SQLITE_NoReadlock    "
"( ""read_uncommitted"",         SQLITE_ReadUncommitted "
"( ""real"" "
"( ""resultTable"" "
"( ""select * from Win32_DiskDrive where SystemName = '"" + moLogDisk[""SystemName""] + ""'"" "
"( ""select * from Win32_LogicalDisk where DeviceID = '"" + diskPath.ToString("
"( ""short_column_names"",       SQLITE_ShortColNames "
"( ""sql_trace"",                SQLITE_SqlTrace      "
"( ""text"" "
"( ""unreadlock = %d\n"", res "
"( ""vdbe_listing"",             SQLITE_VdbeListing   "
"( ""vdbe_trace"",               SQLITE_VdbeTrace     "
"( ""weekday "" "
"( ""writable_schema"",          SQLITE_WriteSchema|SQLITE_RecoveryMode "
"( ""x"" "
"( ""x2"" "
"( ""{0,"" + N + ""}"", """" "
"( ""{} "" "
"( ""{}"" "
"( &buf[pMem.n], 0, len - pMem.n "
"( &p.endpoint.pChunk.zChunk[iChunkOffset], zWrite, iSpace "
"( &p.zText[p.nChar], z, N "
"( &pOut.z[pIn2.n], pIn1.z, pIn1.n "
"( &sqlite3_query_plan[nQPlan], ""{} "", 3 "
"( &sqlite3_query_plan[nQPlan], ""{}"", 2 "
"( &sqlite3_query_plan[nQPlan], z, n "
"( &v, pMem.r, v "
"( &y, x, 8 "
"( &zAlloc[nSize], 0, EXPR_FULLSIZE - nSize "
"( &zStmt[k], zType, len "
"( &zTemp[i], "",..."", 4 "
"( &zTemp[i], "",nil"", 4 "
"( &zTemp[i], pColl.zName, n + 1 "
"( '%', '_', '\0', false "
"( '%', '_', '\0', true "
"( '*', '?', '[', false "
"( ( 0 != ( rc = write32bits( pPager.jfd, iHdrOff, (u32"
"( ( LastResult = CSSQLite.sqlite3_bind_int64( vm, index, bLong "
"( ( LastResult = CSSQLite.sqlite3_bind_text( vm, index, bText ,-1,null"
"( ( TESTBIT( pV, i "
"( ( c = sqlite3Utf8Read( zPattern, ref zPattern "
"( ( c2 = sqlite3Utf8Read( zString, ref zString "
"( ( chngToIN & getMask( pMaskSet, pOrTerm.leftCursor "
"( ( columnCount = ReadColumnNames( vm, table "
"( ( exprTableUsage( pMaskSet, pList.a[iFirst++].pExpr "
"( ( notReady & getMask( pMaskSet, pTabList.a[bestJ].iCursor "
"( ( pPage = pager_lookup( pPager, pg "
"( ( pStat = sqlite3FindTable( db, ""sqlite_stat1"", pDb.zName "
"( ( pTab = isSimpleCount( p, sAggInfo "
"( ( rc = sqlite3PagerAcquire( pPager, (u32"
"( ( sqlite3MemCompare( argv[iBest], argv[i], pColl "
"( ( zWhere = whereTempTriggers( pParse, pTab "
"( (!pPage && (rc = btreeGetPage(pBt, iPage, ref pPage, 0"
"( (0==sqlite3StrNICmp("" hidden"", &zType[i], 7"
"( (LastResult = CSSQLite.sqlite3_bind_int( vm, index, bInteger "
"( (pStmt = sqlite3_next_stmt(db, 0"
"( /* db.mallocFailed != 0 || */ sqlite3ResolveExprNames( sNC, ref whenExpr "
"( /* db.mallocFailed != 0 || */ sqliteProcessJoin( pParse, p "
"( 0 != ( rc = sqlite3OsFileSize( pPager.fd, ref n "
"( 0 != ( rc = sqlite3OsWrite( pPager.jfd, Encoding.UTF8.GetBytes( zMaster "
"( 0 != ( rc = sqlite3OsWrite( pPager.jfd, aJournalMagic, 8, iHdrOff + 4 + nMaster + 8 "
"( 0 != ( rc = write32bits( pPager.jfd, iHdrOff + 4 + nMaster + 4, cksum "
"( 0 != ( rc = write32bits( pPager.jfd, iHdrOff + 4 + nMaster, (u32"
"( 0 == db.init.busy && sqlite3LocateCollSeq( pParse, zColl "
"( 0 == isSavepnt && pager_cksum( pPager, aData "
"( 0 == pNC.allowAgg && ExprHasProperty( pOrig, EP_Agg "
"( 0 == sqlite3BitvecTest( pPager.pInJournal, i "
"( 0 == sqlite3StrICmp( z, ""exclusive"" "
"( 0 == sqlite3StrICmp( z, ""full"" "
"( 0 == sqlite3StrICmp( z, ""incremental"" "
"( 0 == sqlite3StrICmp( z, ""none"" "
"( 0 == sqlite3StrICmp( z, ""normal"" "
"( 0 == sqlite3StrICmp( z, p.aCol[i].zName "
"( 0 == sqlite3StrICmp( z, zColl "
"( 0 == sqlite3StrICmp( zRight, encnames[iEnc].zName "
"( 0,  7, JT_NATURAL                "
"( 0, 9 "
"( 0, n "
"( 0, nBytes "
"( 0, nName "
"( 0, nPattern "
"( 0, nPattern - 1 "
"( 0, nToken "
"( 0, null "
"( 0, null, 0, null, null, 0, null, null "
"( 0, pAll.n "
"( 0, pColDef.n "
"( 0, pIn1.n "
"( 0, pIn2.n "
"( 0, pMem.n "
"( 0, pName.n "
"( 0, pSpan.zStart.Length - pSpan.zEnd.Length "
"( 0, pSpan.zStart.Length <= pSpan.zEnd.Length ? pSpan.zStart.Length : pSpan.zStart.Length - pSpan.zEnd.Length "
"( 0, pTo.n "
"( 0, pToken.n "
"( 0, rc "
"( 0, zErrmsg "
"( 0,SQLITE_UTF8,SQLITE_FUNC_COUNT,null,null,null,countStep,countFinalize,""count"",null"
"( 0==sqlite3StrICmp(pCol.zName, zColumnName"
"( 0==strcmp(zFullPathname, sqlite3PagerFilename(pBt.pPager"
"( 1, ref iRandom "
"( 10, 5, JT_OUTER                  "
"( 100, ref  zCsr, ""%d["", pMem.n "
"( 100, ref zBuf, ""%02d:%02d:%02d"", x.h, x.m, (int"
"( 100, ref zBuf, ""%04d-%02d-%02d"", x.Y, x.M, x.D "
"( 100, ref zCsr, ""%02X"", ( (int"
"( 100, ref zCsr, ""%c"", c "
"( 100, ref zCsr, ""%d"", pMem.n "
"( 100, ref zCsr, ""+%dz"", pMem.u.nZero "
"( 100, ref zCsr, ""]%s"", encnames[pMem.enc] "
"( 100, ref zCsr, encnames[pMem.enc] "
"( 1000, ref  z, ""%s"", pOp.p4.z "
"( 14, 5, JT_RIGHT|JT_OUTER         "
"( 142, 1 "
"( 143, 1 "
"( 143, 2 "
"( 144, 1 "
"( 144, 3 "
"( 145, 0 "
"( 145, 1 "
"( 145, 3 "
"( 146, 1 "
"( 147, 1 "
"( 147, 11 "
"( 147, 2 "
"( 147, 3 "
"( 147, 4 "
"( 147, 5 "
"( 147, 6 "
"( 147, 7 "
"( 147, 8 "
"( 148, 0 "
"( 148, 1 "
"( 149, 0 "
"( 149, 1 "
"( 149, 2 "
"( 150, 1 "
"( 151, 0 "
"( 151, 1 "
"( 152, 6 "
"( 153, 2 "
"( 153, 4 "
"( 154, 1 "
"( 155, 0 "
"( 155, 1 "
"( 156, 0 "
"( 156, 3 "
"( 157, 0 "
"( 157, 2 "
"( 158, 1 "
"( 158, 3 "
"( 159, 0 "
"( 159, 2 "
"( 160, 1 "
"( 160, 3 "
"( 161, 3 "
"( 162, 1 "
"( 163, 0 "
"( 163, 1 "
"( 164, 0 "
"( 164, 2 "
"( 165, 1 "
"( 166, 1 "
"( 167, 1 "
"( 167, 4 "
"( 167, 6 "
"( 168, 1 "
"( 168, 2 "
"( 169, 1 "
"( 170, 2 "
"( 171, 2 "
"( 172, 1 "
"( 172, 3 "
"( 173, 1 "
"( 173, 2 "
"( 173, 3 "
"( 173, 4 "
"( 173, 5 "
"( 174, 1 "
"( 175, 1 "
"( 175, 2 "
"( 175, 3 "
"( 175, 4 "
"( 175, 5 "
"( 175, 6 "
"( 176, 0 "
"( 176, 3 "
"( 177, 0 "
"( 177, 1 "
"( 178, 0 "
"( 178, 1 "
"( 179, 0 "
"( 179, 3 "
"( 180, 0 "
"( 180, 2 "
"( 181, 2 "
"( 181, 3 "
"( 182, 2 "
"( 182, 3 "
"( 183, 1 "
"( 183, 2 "
"( 184, 0 "
"( 184, 2 "
"( 185, 1 "
"( 185, 2 "
"( 185, 3 "
"( 186, 10 "
"( 186, 2 "
"( 186, 5 "
"( 186, 7 "
"( 187, 3 "
"( 187, 5 "
"( 188, 0 "
"( 188, 1 "
"( 189, 0 "
"( 189, 2 "
"( 19, 4, JT_LEFT|JT_RIGHT|JT_OUTER "
"( 190, 1 "
"( 191, 1 "
"( 192, 0 "
"( 192, 2 "
"( 193, 2 "
"( 194, 9 "
"( 195, 1 "
"( 195, 2 "
"( 196, 0 "
"( 196, 1 "
"( 197, 2 "
"( 197, 3 "
"( 197, 4 "
"( 1970, 1, 1, 0, 0, 0, 0 "
"( 198, 0 "
"( 198, 2 "
"( 199, 0 "
"( 199, 2 "
"( 20, ref zTemp, ""%.16g"", x.iJD / 86400000.0 "
"( 200, 0 "
"( 200, 3 "
"( 200, ref zErr, ""cannot detach database %s"", zName "
"( 200, ref zErr, ""database %s is locked"", zName "
"( 200, ref zErr, ""no such database: %s"", zName "
"( 201, 0 "
"( 201, 2 "
"( 202, 0 "
"( 202, 3 "
"( 203, 0 "
"( 203, 2 "
"( 203, 4 "
"( 204, 0 "
"( 204, 2 "
"( 205, 0 "
"( 205, 1 "
"( 205, 2 "
"( 206, 7 "
"( 207, 0 "
"( 207, 2 "
"( 208, 1 "
"( 208, 2 "
"( 208, 3 "
"( 208, 4 "
"( 209, 0 "
"( 209, 2 "
"( 209, 3 "
"( 210, 0 "
"( 210, 2 "
"( 211, 0 "
"( 211, 4 "
"( 213, 1 "
"( 213, 3 "
"( 214, 2 "
"( 214, 4 "
"( 215, 1 "
"( 216, 1 "
"( 216, 3 "
"( 217, 3 "
"( 217, 5 "
"( 218, 1 "
"( 218, 2 "
"( 219, 0 "
"( 219, 3 "
"( 220, 1 "
"( 220, 3 "
"( 221, 0 "
"( 221, 1 "
"( 222, 1 "
"( 222, 2 "
"( 223, 0 "
"( 223, 2 "
"( 224, 1 "
"( 224, 2 "
"( 225, 1 "
"( 225, 2 "
"( 226, 0 "
"( 226, 1 "
"( 227, 4 "
"( 227, 5 "
"( 228, 0 "
"( 228, 2 "
"( 229, 0 "
"( 229, 1 "
"( 23, 5, JT_INNER                  "
"( 230, 0 "
"( 230, 2 "
"( 231, 1 "
"( 232, 0 "
"( 232, 1 "
"( 233, 1 "
"( 234, 11 "
"( 235, 2 "
"( 235, 3 "
"( 236, 0 "
"( 236, 1 "
"( 236, 2 "
"( 237, 1 "
"( 237, 3 "
"( 238, 0 "
"( 238, 3 "
"( 239, 0 "
"( 239, 2 "
"( 240, 1 "
"( 240, 5 "
"( 240, 7 "
"( 240, 8 "
"( 241, 1 "
"( 241, 3 "
"( 242, 0 "
"( 242, 2 "
"( 242, 3 "
"( 243, 0 "
"( 243, 1 "
"( 244, 0 "
"( 244, 2 "
"( 245, 1 "
"( 246, 0 "
"( 246, 1 "
"( 247, 7 "
"( 248, 1 "
"( 248, 3 "
"( 249, 0 "
"( 249, 2 "
"( 250, 1 "
"( 250, 3 "
"( 251, 1 "
"( 252, 0 "
"( 252, 2 "
"( 252, 4 "
"( 256, zTmpname "
"( 28, 5, JT_INNER|JT_CROSS         "
"( 3, pMem.z, ""%.2x"", pOp.p5 "
"( 3, ref zTemp, ""%02d"", ( nDay + 7 - wd "
"( 3, ref zTemp, ""%02d"", (int"
"( 3, ref zTemp, ""%02d"", x.D "
"( 3, ref zTemp, ""%02d"", x.M "
"( 3, ref zTemp, ""%02d"", x.h "
"( 3, ref zTemp, ""%02d"", x.m "
"( 4, ref zTemp, ""%03d"", nDay + 1 "
"( 5, ref zTemp, ""%04d"", x.Y "
"( 6,  4, JT_LEFT|JT_OUTER          "
"( 7, ref zTemp, ""%06.3f"", s "
"( ; b != 0 ; b = b >> 1, n++ "
"( A, 0, val "
"( A, B "
"( Bitvec p, u32 i "
"( Bitvec p, u32 i, u32[] pBuf "
"( BtCursor pCur, ref int pAmt, ref int outOffset "
"( BtShared pBt, Pgno pgno "
"( BtShared pBt, u32 pgno "
"( Btree pTo, Btree pFrom "
"( Btree* pBtree, int iTab, u8 isWriteLock "
"( BtreeMutexArray X, Btree Y "
"( CSSQLite.sqlite3_open( DatabaseName, ref db "
"( Console.Out, ""parser: "" "
"( Console.Out, i, p.aOp[i] "
"( D, N "
"( D, P "
"( Db pDb, int iFrom, int iTo "
"( DbHasProperty( db, i, DB_SchemaLoaded "
"( Expr E, int P "
"( Expr p, int flags "
"( Expr p, int iTable "
"( Expr p, int initFlag "
"( Expr p, ref int pValue "
"( Expr p, ref int pnHeight "
"( Expr pA, Expr pB "
"( Expr pDerived, Expr pBase "
"( Expr pExpr, char aff2 "
"( Expr pExpr, char idx_affinity "
"( Expr pExpr1, Expr pExpr2, int jumpIfNull "
"( ExprHasAnyProperty( p, EP_Reduced | EP_TokenOnly "
"( ExprHasAnyProperty( pExpr, EP_Resolved "
"( ExprHasAnyProperty( pExpr, EP_TokenOnly "
"( ExprHasAnyProperty( pNew, EP_Reduced | EP_TokenOnly "
"( ExprHasProperty( p, EP_Reduced "
"( ExprHasProperty( p, EP_TokenOnly "
"( ExprHasProperty( p, EP_xIsSelect "
"( ExprHasProperty( pA, EP_IntValue "
"( ExprHasProperty( pA, EP_xIsSelect "
"( ExprHasProperty( pB, EP_IntValue "
"( ExprHasProperty( pExpr, EP_FromJoin "
"( ExprHasProperty( pExpr, EP_IntValue "
"( ExprHasProperty( pExpr, EP_Reduced "
"( ExprHasProperty( pExpr, EP_TokenOnly "
"( ExprHasProperty( pExpr, EP_xIsSelect "
"( ExprHasProperty( pNew, EP_Reduced "
"( ExprHasProperty( pOrig, EP_IntValue "
"( ExprHasProperty( pX, EP_xIsSelect "
"( ExprList p, ref int pnHeight "
"( FILE _out, Mem p "
"( FILE _out, int iReg, Mem p "
"( FILE pOut, int pc, Op pOp "
"( FORMAT, TIMESTRING, MOD, MOD, ..."
"( FuncDef p, int nArg, int enc "
"( FuncDef, aBuiltinFunc "
"( FuncDef, aDateTimeFuncs "
"( FuncDefHash, sqlite3GlobalFunctions "
"( GLOBAL(BtShared*,sqlite3SharedCacheList"
"( Hash pH, string pKey, int nKey "
"( IdList pIdList, ExprList pEList "
"( IdList pList, string zName "
"( Index pDest, Index pSrc "
"( Int32.TryParse( inStr.Substring( 0, i "
"( InterlockedCompareExchange(winMutex_lock, 0, 1"
"( InterlockedCompareExchange(winMutex_lock, 1, 0"
"( LayoutKind.Explicit, Size = 16, CharSet = CharSet.Ansi "
"( MAX_PATH + 1, zTmpname "
"( Mem A, int B "
"( Mem p, int f "
"( Mem pMem, FuncDef pFunc "
"( Mem pMem, StringBuilder zBuf "
"( Mem pMem, double val "
"( Mem pMem, i64 val "
"( Mem pMem, int desiredEnc "
"( Mem pMem, int enc "
"( Mem pMem, int file_format "
"( Mem pMem, int n "
"( Mem pMem, int n, int preserve "
"( Mem pMem1, Mem pMem2, CollSeq pColl "
"( Mem pTo, Mem pFrom "
"( Mem pTo, Mem pFrom, int srcType "
"( MemPage pPage, int iCell, ref CellInfo pInfo "
"( Mem[] p, int N "
"( NEVER( ExprHasProperty( pExpr, EP_xIsSelect "
"( NameContext pArg, ref Expr pExpr "
"( NameContext pNC, ExprList pList "
"( NameContext pNC, ref  Expr pExpr "
"( NameContext pName, Expr pExpr "
"( NotUsed, NotUsed2 "
"( NotUsed, argc "
"( OP_AddImm,       1, -1,  0"
"( OP_AddImm,       3,  1,  0"
"( OP_AddImm,      1, -1,  0"
"( OP_AddImm,      1, 0,        0"
"( OP_Column,     0, 0,        2"
"( OP_Column,     0, 1,        2"
"( OP_Concat,       3,  2,  2"
"( OP_Concat,      4,  3,  3"
"( OP_Concat,      5,  3,  3"
"( OP_Concat,      6,  3,  3"
"( OP_Delete,     0, 0,        0"
"( OP_Eq,           2,  0,  3"
"( OP_Halt,           SQLITE_OK,       OE_Abort, 0"
"( OP_If,             1,               0,        0"
"( OP_IfNeg,       1, 0,        0"
"( OP_IfPos,       1, 7,        0"
"( OP_Integer,        0,               1,        0"
"( OP_Integer,        0,  1,  0"
"( OP_Integer,      0,  3,  0"
"( OP_Integer,     0, 1,        0"
"( OP_Integer,     0, 2,        0"
"( OP_Ne,         2, ADDR(8"
"( OP_Next,         0,  0,  0"
"( OP_Next,       0, ADDR(1"
"( OP_ReadCookie,      0,  1,  0"
"( OP_ReadCookie,     0,               1,        BTREE_LARGEST_ROOT_PAGE"
"( OP_ReadCookie,  0, 1,        BTREE_DEFAULT_CACHE_SIZE"
"( OP_ResultRow,       1,  1,  0"
"( OP_ResultRow,    2,  1,  0"
"( OP_ResultRow,   1, 1,        0"
"( OP_ResultRow,   3,  1,  0"
"( OP_ResultRow,   3, 1,        0"
"( OP_Rewind,       0,  0,  0"
"( OP_Rewind,     0, ADDR(9"
"( OP_Rowid,       1,  4,  0"
"( OP_SetCookie,      0,               BTREE_INCR_VACUUM, 1"
"( OP_SetCookie,      0,  0,  1"
"( OP_String8,      0,  2,  0"
"( OP_String8,      0,  3,  0"
"( OP_String8,     0,  3,  0"
"( OP_String8,     0,  5,  0"
"( OP_String8,     0,  6,  0"
"( OP_String8,     0, 3,        0"
"( OP_String8,    0, 1,        0"
"( OP_Subtract,    1, 2,        1"
"( OP_Transaction,     0,  0,  0"
"( OP_Transaction,    0,               1,        0"
"( OP_Transaction,    0,  1,  0"
"( OP_Transaction, 0, 0,        0"
"( Op pOp, string zBuffer, int nTemp "
"( P->xCodec && P->xCodec(P->pCodec,D,N,X"
"( PCache pCache, dxIter xIter "
"( PCache pCache, int mxPage "
"( PCache pCache, int szPage "
"( PCache pCache, u32 pgno "
"( PCache1 c, PgHdr p "
"( PENDING_BYTE + nDestPagesize, iSize "
"( PGHDR1_TO_PAGE(PAGE_TO_PGHDR1(pCache, X"
"( Pager P, byte[] D, uint N, int X, int E, ref byte[] O "
"( Pager pPager, DbPage pPg, u32 pgno, int isCommit "
"( Pager pPager, PagerSavepoint pSavepoint "
"( Pager pPager, bool exFlag, int subjInMemory "
"( Pager pPager, bool isDirectMode "
"( Pager pPager, byte[] aData "
"( Pager pPager, i64 iLimit "
"( Pager pPager, int N, byte[] pDest "
"( Pager pPager, int doTruncate "
"( Pager pPager, int eMode "
"( Pager pPager, int hasMaster "
"( Pager pPager, int isHot "
"( Pager pPager, int level, bool bFullFsync "
"( Pager pPager, int locktype "
"( Pager pPager, int mxPage "
"( Pager pPager, int nSavepoint "
"( Pager pPager, int op, int iSavepoint "
"( Pager pPager, int rc "
"( Pager pPager, ref int pExists "
"( Pager pPager, ref int pnPage "
"( Pager pPager, ref u16 pPageSize, int nReserve "
"( Pager pPager, string zMaster "
"( Pager pPager, u32 nPage "
"( Pager pPager, u32 pgno "
"( Parse P, T t "
"( Parse a, Expr b, Schema c, SrcList d "
"( Parse a, int b, string c, byte[] d, byte[] e "
"( Parse p, Token t "
"( Parse p, Token t1, Token t2, Token t3 "
"( Parse p, int iDb "
"( Parse p, int p1, int p2, u8 p3, byte[] p4 "
"( Parse p, int p1, int p2, u8 p3, string p4 "
"( Parse pParse, AggInfo pAggInfo "
"( Parse pParse, CollSeq pColl "
"( Parse pParse, Expr p "
"( Parse pParse, Expr p, Expr pDbname, Expr pKey "
"( Parse pParse, Expr pDbname "
"( Parse pParse, Expr pExpr "
"( Parse pParse, Expr pExpr, Token pCollName "
"( Parse pParse, Expr pExpr, int dest, int jumpIfNull "
"( Parse pParse, Expr pExpr, int target "
"( Parse pParse, Expr pExpr, ref int pReg "
"( Parse pParse, Expr pX, ref int prNotFound "
"( Parse pParse, ExprList pList "
"( Parse pParse, ExprList pList, Token pToken "
"( Parse pParse, ExprList pList, int null_3 "
"( Parse pParse, ExprSpan pSpan "
"( Parse pParse, Index pIdx "
"( Parse pParse, Index pIndex, int memRootPage "
"( Parse pParse, Select p "
"( Parse pParse, Select p, int iBreak "
"( Parse pParse, Select p, int iCol "
"( Parse pParse, Select pSelect "
"( Parse pParse, SrcList p, Token pIndexedBy "
"( Parse pParse, SrcList p, Token pTable, Token pDatabase, Token pAlias, int null_6, Expr pOn, IdList pUsing "
"( Parse pParse, SrcList p, int null_3, int null_4, Token pAlias, Select pSubquery, Expr pOn, IdList pUsing "
"( Parse pParse, SrcList pList "
"( Parse pParse, SrcList pName, int ifExists "
"( Parse pParse, SrcList pName, int isView, int noErr "
"( Parse pParse, SrcList pName, int noErr "
"( Parse pParse, SrcList pSrc "
"( Parse pParse, SrcList pTabList, ExprList pList, int null_4, IdList pColumn, int onError "
"( Parse pParse, SrcList pTabList, int null_3, Select pSelect, IdList pColumn, int onError "
"( Parse pParse, SrcList pTabList, int null_3, int null_4, IdList pColumn, int onError "
"( Parse pParse, SrcList_item pFrom "
"( Parse pParse, Table pTab "
"( Parse pParse, Table pTab, int viewOk "
"( Parse pParse, Table pTab, string zColl "
"( Parse pParse, Table pTab, string zName "
"( Parse pParse, Table pTable "
"( Parse pParse, Token pA, Token pB, Token pC "
"( Parse pParse, Token pA, Token pB, int null_4 "
"( Parse pParse, Token pA, int null_3, int null_4 "
"( Parse pParse, Token pColDef "
"( Parse pParse, Token pCons, Token pEnd, int null_4 "
"( Parse pParse, Token pId1, Token pId2, int null_4, int minusFlag "
"( Parse pParse, Token pName "
"( Parse pParse, Token pName1, Token pName2 "
"( Parse pParse, Token pToken "
"( Parse pParse, Token pType "
"( Parse pParse, Trigger pTrigger "
"( Parse pParse, int N "
"( Parse pParse, int _base, int n, Index pIdx "
"( Parse pParse, int explainFlag "
"( Parse pParse, int iAlias, Expr pExpr, int target "
"( Parse pParse, int iDb "
"( Parse pParse, int iDb, int minFormat "
"( Parse pParse, int iFrom, int iTo "
"( Parse pParse, int iFrom, int iTo, int nReg "
"( Parse pParse, int iReg "
"( Parse pParse, int iReg, int nReg "
"( Parse pParse, int iStart, int iCount "
"( Parse pParse, int iTab, int iCol, int iReg "
"( Parse pParse, int iTable, int iDb "
"( Parse pParse, int isDeferred "
"( Parse pParse, int memId, int regRowid "
"( Parse pParse, int nHeight "
"( Parse pParse, int nReg "
"( Parse pParse, int null_2, Expr pExpr "
"( Parse pParse, int null_2, SrcList pSrc, int null_4, int null_5, int null_6, int null_7, int isDistinct, int null_9, int null_10 "
"( Parse pParse, int null_2, Token pTo, ExprList pToCol, int flags "
"( Parse pParse, int null_2, Token pToken "
"( Parse pParse, int null_2, int null_3 "
"( Parse pParse, int null_2, int null_3, Select pSelect "
"( Parse pParse, int null_2, int null_3, int null_4, ExprList pList, int onError, int null_7, int null_8, int sortOrder, int ifNotExist "
"( Parse pParse, int null_2, int null_3, int null_4, int null_5, int onError, int null_7, int null_8, int sortOrder, int ifNotExist "
"( Parse pParse, int null_2, int onError, int autoInc, int sortOrder "
"( Parse pParse, int onError "
"( Parse pParse, int op, Expr pLeft, Expr pRight, int null_5 "
"( Parse pParse, int op, Expr pLeft, int null_4, Token pToken "
"( Parse pParse, int op, Expr pLeft, int null_4, int null_5 "
"( Parse pParse, int op, Token pName "
"( Parse pParse, int op, int null_3, int null_4, Token pToken "
"( Parse pParse, int op, int null_3, int null_4, int null_5 "
"( Parse pParse, int setStatement, int iDb "
"( Parse pParse, int type "
"( Parse pParse, string zColl "
"( Parse pParse, string zFormat, params object[] ap "
"( Parse pParse, string zLabel, i64 value "
"( Parse pParse, string zLeft, string zRight "
"( Parse pParse, string zName "
"( Parse pParse, string zSql, ref string pzErrMsg "
"( Parse pParse, string zStorageType "
"( Parse pParse, yColCache p "
"( PgHdr p, Pgno newPgno "
"( PgHdr pA, PgHdr pB "
"( RowSet p, i64 rowid "
"( RowSet p, ref i64 pRowid "
"( RowSet pRowSet, u8 iBatch, sqlite3_int64 iRowid "
"( SHARED_FIRST + pFile.sharedLockByte, 0, 1, 0"
"( SQLITE_CONFIG_MALLOC, defaultMethods "
"( SQLITE_CONFIG_PCACHE, defaultMethods "
"( SQLITE_NOMEM == sqlite3ApiExit( p.db, p.rc "
"( SQLITE_NOMEM == sqlite3BtreeSetPageSize( pBt, db.nextPagesize, -1, 0 "
"( SQLITE_OK != ( rc = read32bits( pPager.jfd, iHdrOff + 20, ref iSectorSize "
"( SQLITE_OK != ( rc = read32bits( pPager.jfd, iHdrOff + 8, ref pNRec "
"( SQLITE_OK != ( rc = sqlite3OsFileSize( pJrnl, ref szJ "
"( SQLITE_OK != sqlite3CheckObjectName( pParse, zName "
"( SQLITE_OK != sqlite3_prepare( db, zSql, -1, ref pStmt, ref Dummy "
"( SQLITE_OK == ( rc = sqlite3OsFileSize( pPager.jfd, ref jrnlSize "
"( SQLITE_OK == ( rc = sqlite3PagerCommitPhaseOne( pDestPager, null, true "
"( SQLITE_OK == ( rc = sqlite3PagerGet( pDestPager, iDest, ref pDestPg "
"( SQLITE_OK == ( rc = sqlite3VdbeMemGrow( pMem, amt + 2, 0 "
"( SQLITE_OK == sqlite3ValueFromExpr( db, pExpr.pLeft, enc, affinity, ref pVal "
"( SQLITE_OK == sqlite3VdbeMemGrow( pMem, nByte, 0 "
"( SQLITE_OK!=sqlite3VdbeChangeEncoding(pOut, encoding"
"( SQLITE_OK==querySharedCacheTableLock(p, iTable, eLock"
"( SQLITE_STATUS_MALLOC_SIZE, n "
"( SQLITE_STATUS_MALLOC_SIZE, nBytes "
"( SQLITE_STATUS_MEMORY_USED, -sqlite3MallocSize( p "
"( SQLITE_STATUS_MEMORY_USED, nFull "
"( SQLITE_STATUS_MEMORY_USED, nNew - nOld "
"( SQLITE_STATUS_MEMORY_USED, ref n, ref mx, 0 "
"( SQLITE_STATUS_PAGECACHE_OVERFLOW, -iSize "
"( SQLITE_STATUS_PAGECACHE_OVERFLOW, sz "
"( SQLITE_STATUS_PAGECACHE_SIZE, nByte "
"( SQLITE_STATUS_PAGECACHE_USED, -1 "
"( SQLITE_STATUS_PAGECACHE_USED, 1 "
"( SQLITE_STATUS_SCRATCH_OVERFLOW, n "
"( SQLITE_STATUS_SCRATCH_SIZE, n "
"( SQLiteDatabase db, String query "
"( Select p, AggInfo pAggInfo "
"( Select p, int indent "
"( Select p, ref int pnHeight "
"( SelectDest pDest, int eDest, int iParm "
"( StrAccum p, StringBuilder zBase, int n, int mx "
"( StrAccum p, string z, int N "
"( StrAccum pAccum, int N "
"( String.Compare( pExpr.u.zToken, ""max"", true "
"( String.Compare( pExpr.u.zToken, ""min"", true "
"( StringBuilder z, ref int pIdx, string zSignedIdent "
"( T, ap "
"( T1 x, T2 y "
"( TIMESTRING, MOD, MOD, ..."
"( Table pTab, string zCol "
"( TextWriter tw, string zFormat, params object[] ap "
"( Vdbe p, FILE trace "
"( Vdbe p, VdbeCursor pCx "
"( Vdbe p, int R, Mem M "
"( Vdbe p, int addr "
"( Vdbe p, int addr, CollSeq pColl, int n "
"( Vdbe p, int addr, FuncDef pFunc, int n "
"( Vdbe p, int addr, KeyInfo pKeyInfo, int n "
"( Vdbe p, int addr, Mem m, int n "
"( Vdbe p, int addr, char c, int n "
"( Vdbe p, int addr, int N "
"( Vdbe p, int addr, int i32n, int n "
"( Vdbe p, int addr, int val "
"( Vdbe p, int addr, string z, dxDel P4_Type "
"( Vdbe p, int addr, string z, int n "
"( Vdbe p, int addr, union_p4 _p4, int n "
"( Vdbe p, int eOp "
"( Vdbe p, int i "
"( Vdbe p, int nOp, VdbeOpList[] aOp "
"( Vdbe p, int nResColumn "
"( Vdbe p, int op "
"( Vdbe p, int op, int p1 "
"( Vdbe p, int op, int p1, bool b2 "
"( Vdbe p, int op, int p1, int p2 "
"( Vdbe p, int op, int p1, int p2, int p3 "
"( Vdbe p, int op, int p1, int p2, int p3, CollSeq pP4, int p4type "
"( Vdbe p, int op, int p1, int p2, int p3, FuncDef pP4, int p4type "
"( Vdbe p, int op, int p1, int p2, int p3, KeyInfo pP4, int p4type "
"( Vdbe p, int op, int p1, int p2, int p3, byte[] pP4, int p4type "
"( Vdbe p, int op, int p1, int p2, int p3, char pP4, int p4type "
"( Vdbe p, int op, int p1, int p2, int p3, double pP4, int p4type "
"( Vdbe p, int op, int p1, int p2, int p3, i32 pP4, int p4type "
"( Vdbe p, int op, int p1, int p2, int p3, i64 pP4, int p4type "
"( Vdbe p, int op, int p1, int p2, int p3, int[] pP4, int p4type "
"( Vdbe p, int op, int p1, int p2, int p3, string pP4, int p4type "
"( Vdbe p, int x "
"( Vdbe p, ref int pMaxFuncArgs "
"( Vdbe p, string z, int n, int isPrepareV2 "
"( Vdbe p, string zFormat, params object[] ap "
"( Vdbe p, u8 val "
"( Vdbe pA, Vdbe pB "
"( Vdbe v, Expr pExpr, bool negFlag, int iMem "
"( Vdbe v, Index pIdx "
"( Vdbe v, Table pTab "
"( Vdbe v, Table pTab, int i, int iReg "
"( Vdbe v, string z, bool negateFlag, int iMem "
"( Vdbe v, string zFormat, params object[] ap "
"( Vdbe vm, DataTable table "
"( VdbeFunc pVdbeFunc, int mask "
"( Walker NotUsed, ref Expr NotUsed2 "
"( Walker pWalker, ExprList p "
"( Walker pWalker, Select NotUsed "
"( Walker pWalker, Select p "
"( Walker pWalker, Select pSelect "
"( Walker pWalker, ref Expr pExpr "
"( WhereClause pWC, Expr p, u8 wtFlags "
"( WhereClause pWC, Expr pExpr, int op "
"( WhereLevel pLevel, WhereTerm pTerm "
"( WhereMaskSet pMaskSet, Expr p "
"( WhereMaskSet pMaskSet, ExprList pList "
"( WhereMaskSet pMaskSet, Select pS "
"( WhereMaskSet pMaskSet, int iCursor "
"( X, Y "
"( X, Y, Z "
"( X, Y, Z, A "
"( X, Y, Z, A, B "
"( X, Y, Z, A, B, C "
"( X, Y, Z, A, B, C, D "
"( X, ap "
"( _buf, 0, buf, bufpt, _buf.Length "
"( _out, "" "" "
"( _out, "" (rowset"
"( _out, "" NULL"" "
"( _out, "" i:%lld"", p.u.i "
"( _out, "" r:%g"", p.r "
"( _out, "" si:%lld"", p.u.i "
"( _out, ""%s"", zBuf "
"( _out, ""\n"" "
"( _out, ""reg[%d] = "", iReg "
"( _out, p "
"( _v, 0, COLNAME_NAME, ""page_count"", SQLITE_STATIC "
"( _v, 1 "
"( _v, OP_Pagecount, iDb, iReg "
"( _v, OP_ResultRow, iReg, 1 "
"( aBucket[i], pEntry "
"( aData, 0, cp.aData, 0, aData.Length "
"( aData, 0, pData, 0, pPager.pageSize "
"( aData, 4, k - 1 "
"( aData[8 + closest * 4], ref aData[4 + k * 4], 4 "
"( aHardLimit, 0, db.aLimit, 0, aHardLimit.Length * sizeof( int "
"( aKey + idx, serial_type "
"( aKey, 0, ref szHdr "
"( aKey, d, serial_type, pMem "
"( aKey, idx, ref serial_type "
"( aKey, szHdr "
"( aKey1 + idx1, serial_type1 "
"( aKey1, 0, ref szHdr1 "
"( aKey1, d1, serial_type1, mem1 "
"( aKey1, idx1, ref serial_type1 "
"( aKey1, szHdr1 "
"( aMagic, aJournalMagic, 8 "
"( aWc, pDef.pUserData, 3 "
"( a[i], p "
"( ac, 0U, val "
"( ac, offset, (u32"
"( ac, offset, val "
"( ac, val "
"( acc, 0, zFormat, ap "
"( acc, 1, zFormat, ap "
"( acc, zBase, n, 0 "
"( acc, zBase, zBase.Capacity, //zBase"
"( acc, zBase, zBase.Length, SQLITE_PRINT_BUF_SIZE "
"( acc, zBuf, zBuf.Capacity, 0 "
"( ap, """" "
"( ap, ""MemPage"" "
"( ap, ""SrcList"" "
"( ap, ""Token"" "
"( ap, ""byte[]"" "
"( ap, ""char"" "
"( ap, ""char*"" "
"( ap, ""double"" "
"( ap, ""i64"" "
"( ap, ""int"" "
"( ap, ""int[]"" "
"( ap, ""long int"" "
"( ap, ""long"" "
"( ap, ""longlong int"" "
"( ap, ""op"" "
"( ap, ""sqlite3_mem_methods"" "
"( ap, ""sqlite3_mutex_methods"" "
"( ap, ""string"" "
"( ap, ""u32"" "
"( ap, ""void_function"" "
"( ap, null "
"( ap, zDate "
"( ap, zFormat "
"( apCell[nCell], ref pOld.aData[8], 4 "
"( apNew[nNew - 1].aData[8], zChild, 4 "
"( argv[0] == null || argv[0] == """" "
"( azVals[i] == null && sqlite3_column_type( pStmt, i "
"( b, 0x7FFFFFFF "
"( buf, 0, len "
"( buf, offset + pMem.n, (int"
"( buf, offset, (int"
"( buf, offset, pMem.zBLOB, 0, (int"
"( buf, pMem.z, len "
"( byte[] V, int I "
"( byte[] a, int Offset, byte[] b, int Limit "
"( byte[] a, int Offset, string b, int Limit "
"( byte[] ac, int offset, int val "
"( byte[] ac, int offset, u32 val "
"( byte[] ac, u32 val "
"( byte[] bA, byte[] bB, int Limit "
"( byte[] bA, string B, int Limit "
"( byte[] buf, int offset, int nBuf, Mem pMem, int file_format "
"( byte[] p, int offset "
"( byte[] p, int offset, int v "
"( byte[] p, int offset, ref i64 v "
"( byte[] p, int offset, ref int v "
"( byte[] p, int offset, ref u32 v "
"( byte[] p, int offset, ref u64 v "
"( byte[] p, int offset, u64 v "
"( byte[] p, int v "
"( byte[] p, ref int v "
"( byte[] p, ref u32 v "
"( byte[] p, u32 offset, ref u32 v "
"( byte[] p, u32 offset, u32 v "
"( byte[] p, u64 v "
"( byte[] pData, int Offset, int v "
"( byte[] pData, int Offset, u32 v "
"( byte[] pOld, int nBytes "
"( c == '""' "
"( c == matchOne && sqlite3Utf8Read( zString, ref zString "
"( c1, pMem1, MEM_Ephem "
"( c2, pMem2, MEM_Ephem "
"( char matchAll, char matchOne, char matchSet, bool noCase "
"( checkForMultiColumnSelectError( pParse, pDest, pEList.nExpr "
"( chngToIN == getMask( pMaskSet, iCursor "
"( cnt == 0 && zTab == null && ExprHasProperty( pExpr, EP_DblQuoted "
"( columnIndex( pLeftTab, zName "
"( columnIndex( pRightTab, zName "
"( columnMem( pStmt, i "
"( columnMem(pStmt,i"
"( columnName, Type.GetType( ""System.Double"" "
"( columnName, Type.GetType( ""System.Int64"" "
"( columnName, Type.GetType( ""System.String"" "
"( columnName, typeof(byte[]"
"( columnName, typeof(string"
"( context, ""LIKE or GLOB pattern too complex"", -1 "
"( context, ""NULL"", 4, SQLITE_STATIC "
"( context, ""integer overflow"", -1 "
"( context, ""value of "" + v + "" handed to x_count"", -1 "
"( context, ""x_count totals to 42"", -1 "
"( context, (int"
"( context, -1 "
"( context, 0 "
"( context, 0, null "
"( context, argc - 1, argv1, ref x "
"( context, argv[0] "
"( context, argv[iBest] "
"( context, argv[i] "
"( context, iVal "
"( context, len "
"( context, n "
"( context, new string( p "
"( context, p != null ? p.n : 0 "
"( context, p != null ? p.rSum : (double"
"( context, p "
"( context, p.iSum "
"( context, p.rSum "
"( context, p.rSum / (double"
"( context, pRes "
"( context, patternCompare( zB, zA, pInfo, escape "
"( context, r "
"( context, rVal "
"( context, rc "
"( context, sb.ToString("
"( context, sqlite3StrAccumFinish( pAccum "
"( context, sqlite3_changes( db "
"( context, sqlite3_last_insert_rowid( db "
"( context, sqlite3_total_changes( db "
"( context, sqlite3_value_bytes( argv[0] "
"( context, sqlite3_version, -1, SQLITE_STATIC "
"( context, x.iJD / 86400000.0 "
"( context, z, -1, SQLITE_STATIC "
"( context, z, ref p "
"( context, z.Length == 0 || p1 > z.Length ? """" : z.Substring( p1, p2 "
"( context, z.ToString("
"( context, zBuf, -1, SQLITE_TRANSIENT "
"( context, zErr, -1 "
"( context, zErrDyn, -1 "
"( context, zErrMsg, -1 "
"( context, zRet, -1, SQLITE_DYNAMIC "
"( context, zText.ToString("
"( cp.a, 0 "
"( ct.aCounter, 0 "
"( ctx, n, apVal "
"( ctx.pVdbeFunc, pOp.p1 "
"( ctx.s, MEM_Null "
"( ctx.s, encoding "
"( ctx.s, pOut "
"( data, hdr + 3, pPage.nCell "
"( data[addr], ref data[pc], 2 "
"( data[cellbody], apCell[i], aSize[i] "
"( data[hdr + 1], ref data[pbegin], 2 "
"( data[idx + nSkip], pCell + nSkip, sz - nSkip "
"( db, ""%.*s\""%w\""%s"", zLoc, zSql.Substring( 0, zLoc "
"( db, ""%s OR name=%Q"", zWhere, pTrig.name "
"( db, ""%s"", pColExpr.u.zToken "
"( db, ""%s"", pEList.a[i].zSpan "
"( db, ""%s-mj%08X"", zMainFile, iRandom & 0x7fffffff "
"( db, ""%s.%s"", pTab.zName, zCol "
"( db, ""%s.%s"", zTabName, zName "
"( db, ""%s:%d"", zName.Substring( 0, nName "
"( db, ""*** in database %s ***\n"", db.aDb[i].zName "
"( db, ""-%T"", pValue "
"( db, ""-- TRIGGER %s"", p.name "
"( db, ""BEGIN EXCLUSIVE;"" "
"( db, ""BINARY"", SQLITE_UTF16BE, 0, (dxCompare"
"( db, ""BINARY"", SQLITE_UTF16LE, 0, (dxCompare"
"( db, ""BINARY"", SQLITE_UTF8, 0, (dxCompare"
"( db, ""MATCH"", 2 "
"( db, ""NOCASE"", SQLITE_UTF8, 0, nocaseCollatingFunc, null "
"( db, ""PRAGMA vacuum_db.synchronous=OFF"" "
"( db, ""RTRIM"", SQLITE_UTF8, 1, (dxCompare"
"( db, ""TABLE %s"", pItem.zName "
"( db, ""cannot ATTACH database within transaction"" "
"( db, ""database %s is already in use"", zName "
"( db, ""database is already attached"" "
"( db, ""glob"", SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE "
"( db, ""like"", 2, SQLITE_ANY, pInfo, (dxFunc"
"( db, ""like"", 3, SQLITE_ANY, pInfo, (dxFunc"
"( db, ""name=%Q"", pTrig.name "
"( db, ""name='%q'"", pIndex.zName "
"( db, ""out of memory"" "
"( db, ""sqlite_altertab_%s"", pTab.zName "
"( db, ""sqlite_autoindex_%s_%d"", pTab.zName, n "
"( db, ""sqlite_subquery_%p_"", pTab "
"( db, ""tbl_name='%q'"", p.zName "
"( db, ""unable to open database: %s"", zFile "
"( db, ""vdbe_explain"" "
"( db, (FuncDef"
"( db, (char*"
"( db, (int"
"( db, (u8"
"( db, 0 "
"( db, 1 "
"( db, 1, DB_SchemaLoaded "
"( db, 1, ref pzErrMsg "
"( db, 5 "
"( db, 64 "
"( db, ENC( db "
"( db, SQLITE_ABORT, 0 "
"( db, SQLITE_NOMEM, """" "
"( db, SQLITE_OK "
"( db, SQLITE_OK, 0 "
"( db, SQLITE_TOOBIG "
"( db, SQLITE_TOOBIG, ""statement too long"" "
"( db, SQLITE_UTF8, ""BINARY"", 0 "
"( db, SQLITE_UTF8, ""NOCASE"", 0 "
"( db, TK_AND, null, 0 "
"( db, TK_DELETE, pTableName "
"( db, TK_FUNCTION, pToken, 1 "
"( db, TK_ID, zName "
"( db, TK_ID, zTabName "
"( db, TK_INSERT, pTableName "
"( db, TK_INTEGER, null "
"( db, TK_STRING, pRight.u.zToken "
"( db, TK_UPDATE, pTableName "
"( db, a.u.pAndInfo "
"( db, a.u.pOrInfo "
"( db, aCol "
"( db, aCol[j].zName "
"( db, aEnc[i], z, 0 "
"( db, aNew.pBt "
"( db, argv[0], db.aDb[iDb].zName "
"( db, argv[2], null, null, ref zErr "
"( db, columnType( sNC, p, 0, 0, 0 "
"( db, db.aDb[0].pBt "
"( db, db.aDb[iDb].zName "
"( db, enc, zName, initbusy "
"( db, err_code, err_code == 0 ?null :"""""
"( db, getBoolean( zRight "
"( db, i "
"( db, i, ref pzErrMsg "
"( db, iDb "
"( db, iDb, DB_Empty "
"( db, iDb, DB_SchemaLoaded "
"( db, idx, DB_UnresetViews "
"( db, m.z "
"( db, n "
"( db, n, _p4 "
"( db, nByte "
"( db, null "
"( db, null, null "
"( db, null, null, null "
"( db, null, pTable, null "
"( db, null, pTable, pDatabase "
"( db, null, pToken "
"( db, op, x, 0 "
"( db, p "
"( db, p, 0 "
"( db, p, flags, ref ExprDummy "
"( db, p, pTable, pDatabase "
"( db, p.nChange "
"( db, p.pEList, 0 "
"( db, p.pEList, flags "
"( db, p.pEList, iTable, pEList "
"( db, p.pEList.a[0].pExpr.x.pList, 0 "
"( db, p.pGroupBy, flags "
"( db, p.pGroupBy, iTable, pEList "
"( db, p.pHaving, flags "
"( db, p.pHaving, iTable, pEList "
"( db, p.pLeft, 0 "
"( db, p.pLeft, EXPRDUP_REDUCE, ref zAlloc "
"( db, p.pLimit, flags "
"( db, p.pOffset, flags "
"( db, p.pOrderBy, flags "
"( db, p.pOrderBy, iTable, pEList "
"( db, p.pPrior, flags "
"( db, p.pPrior, iTable, pEList "
"( db, p.pRight, 0 "
"( db, p.pRight, EXPRDUP_REDUCE, ref zAlloc "
"( db, p.pSchema "
"( db, p.pSrc, flags "
"( db, p.pWhen, 0 "
"( db, p.pWhere, flags "
"( db, p.pWhere, iTable, pEList "
"( db, p.rc, 0 "
"( db, p.x.pList, isReduced ? 1 : 0 "
"( db, p.x.pSelect, isReduced ? 1 : 0 "
"( db, p.zErrMsg "
"( db, pAlias "
"( db, pBuf, sz, cnt "
"( db, pCol.zDflt "
"( db, pCol.zName "
"( db, pColl, zName "
"( db, pColl.zName "
"( db, pCollName "
"( db, pColumns "
"( db, pCrsr, ref rowid "
"( db, pDatabase "
"( db, pDef, nFarg, pFarg.a[0].pExpr "
"( db, pDef, nFarg, pFarg.a[1].pExpr "
"( db, pE, 0 "
"( db, pEList, EXPRDUP_REDUCE "
"( db, pEList.a[pExpr.iColumn].pExpr, 0 "
"( db, pExpr "
"( db, pExpr, 0 "
"( db, pExpr.pLeft, 0 "
"( db, pExpr.pLeft, iTable, pEList "
"( db, pExpr.pRight, iTable, pEList "
"( db, pExpr.u.zToken "
"( db, pExpr.u.zToken, sqlite3Strlen30( pExpr.u.zToken "
"( db, pExpr.x.pList, iTable, pEList "
"( db, pExpr.x.pSelect, iTable, pEList "
"( db, pId "
"( db, pIdx.pSchema "
"( db, pIndex.pSchema "
"( db, pInfo "
"( db, pItem.pSelect, iTable, pEList "
"( db, pItem.zSpan "
"( db, pLeft, 0 "
"( db, pLevel.u._in.aInLoop "
"( db, pList, 1, pList.nSrc "
"( db, pList.a[i].pExpr, 0 "
"( db, pList.a[i].pExpr, iTable, pEList "
"( db, pMem.zMalloc "
"( db, pName "
"( db, pName.a[0].zName, pName.a[0].zDatabase "
"( db, pName1 "
"( db, pNew "
"( db, pNew, pLeft, pRight "
"( db, pNew.pSchema "
"( db, pObjName "
"( db, pOldExpr, flags "
"( db, pOldItem.pOn, flags "
"( db, pOldItem.pSelect, flags "
"( db, pOldItem.pUsing "
"( db, pOldItem.zIndex "
"( db, pOldItem.zSpan "
"( db, pOp.p1 "
"( db, pOp.p1, pOp.p4.z "
"( db, pOp.p4type, pOp.p4.p "
"( db, pOp.p4type, pOp.p4type == P4_VDBEFUNC ? pOp.p4.pVdbeFunc : pOp.p4.pFunc "
"( db, pOrTerm.pExpr.pRight, 0 "
"( db, pOrig, 0 "
"( db, pParent.pEList, iParent, pSub.pEList "
"( db, pParent.pGroupBy, iParent, pSub.pEList "
"( db, pParent.pHaving, iParent, pSub.pEList "
"( db, pParent.pOrderBy, iParent, pSub.pEList "
"( db, pParent.pWhere, iParent, pSub.pEList "
"( db, pParent.pWhere, pWhere "
"( db, pParse "
"( db, pSavepoint "
"( db, pSelect, EXPRDUP_REDUCE "
"( db, pSpan.pExpr, EXPRDUP_REDUCE "
"( db, pSrc, nSubSrc - 1, iFrom + 1 "
"( db, pStr1, 0 "
"( db, pSub.pGroupBy, 0 "
"( db, pSub.pHaving, 0 "
"( db, pSub.pWhere, 0 "
"( db, pTab.pCheck, pCheckExpr "
"( db, pTab.pSchema "
"( db, pTab.pSelect, 0 "
"( db, pTable "
"( db, pTable.pSelect, 0 "
"( db, pTableName "
"( db, pTableName, pColumn, null, null, orconf "
"( db, pTableName, pColumn, null, pSelect, orconf "
"( db, pTableName, pColumn, pEList, null, orconf "
"( db, pTableName.a[0].zName "
"( db, pTmp "
"( db, pToken "
"( db, pTriggerStep.pExprList, 0 "
"( db, pTriggerStep.pIdList "
"( db, pTriggerStep.pSelect, 0 "
"( db, pTriggerStep.pWhere, 0 "
"( db, pValue "
"( db, pVdbeFunc.pFunc "
"( db, pView.pSelect, 0 "
"( db, pView.zName "
"( db, pWInfo "
"( db, pWhen, EXPRDUP_REDUCE "
"( db, pWhere, 0 "
"( db, pWhere, EXPRDUP_REDUCE "
"( db, query, 0, 0, 0 "
"( db, rc "
"( db, rc, ""%s"", zErrMsg "
"( db, rc, ""database schema is locked: %s"", zDb "
"( db, rc, ""no such vfs: %s"", zVfs "
"( db, rc, 0 "
"( db, ref  aRegIdx "
"( db, ref  aXRef "
"( db, ref  azCols "
"( db, ref  p "
"( db, ref  p.pFree "
"( db, ref  pDef "
"( db, ref  zErrMsg "
"( db, ref  zExternal "
"( db, ref  zSql "
"( db, ref a.pExpr "
"( db, ref aRegIdx "
"( db, ref aRoot "
"( db, ref db.aDb[1].pSchema "
"( db, ref db.aExtension "
"( db, ref p "
"( db, ref p.aColName "
"( db, ref p.aLabel "
"( db, ref p.aOp "
"( db, ref p.contextStack "
"( db, ref p.pEList "
"( db, ref p.pGroupBy "
"( db, ref p.pHaving "
"( db, ref p.pLeft "
"( db, ref p.pLimit "
"( db, ref p.pOffset "
"( db, ref p.pOrderBy "
"( db, ref p.pPrior "
"( db, ref p.pRight "
"( db, ref p.pSrc "
"( db, ref p.pWhere "
"( db, ref p.u._zToken "
"( db, ref p.u.zToken "
"( db, ref p.x.pList "
"( db, ref p.x.pSelect "
"( db, ref p.zColAff "
"( db, ref p.zErrMsg "
"( db, ref p.zSql "
"( db, ref p4 "
"( db, ref pC.pData "
"( db, ref pChanges "
"( db, ref pCheckExpr "
"( db, ref pCol.pDflt "
"( db, ref pCol.zColl "
"( db, ref pCol.zDflt "
"( db, ref pCol.zName "
"( db, ref pCol.zType "
"( db, ref pColl "
"( db, ref pColumn "
"( db, ref pColumns "
"( db, ref pDb.zName "
"( db, ref pDbname "
"( db, ref pDel "
"( db, ref pDelete "
"( db, ref pDup "
"( db, ref pE "
"( db, ref pEList "
"( db, ref pEnd.zMalloc "
"( db, ref pExpr "
"( db, ref pExpr.pLeft "
"( db, ref pExpr.pRight "
"( db, ref pFKey "
"( db, ref pFilename "
"( db, ref pFromCol "
"( db, ref pIndex "
"( db, ref pItem.pExpr "
"( db, ref pItem.pOn "
"( db, ref pItem.pSelect "
"( db, ref pItem.pUsing "
"( db, ref pItem.zAlias "
"( db, ref pItem.zDatabase "
"( db, ref pItem.zIndex "
"( db, ref pItem.zName "
"( db, ref pItem.zSpan "
"( db, ref pKey "
"( db, ref pKeyInfo "
"( db, ref pLeft "
"( db, ref pList "
"( db, ref pList.a "
"( db, ref pList.a[i].zName "
"( db, ref pName "
"( db, ref pNew "
"( db, ref pOn "
"( db, ref pOp.zComment "
"( db, ref pParse.aAlias "
"( db, ref pParse.aTableLock "
"( db, ref pParse.apVarExpr "
"( db, ref pParse.pNewTrigger "
"( db, ref pParse.zErrMsg "
"( db, ref pRight "
"( db, ref pSel "
"( db, ref pSelect "
"( db, ref pSpan.pExpr "
"( db, ref pSrc "
"( db, ref pSrc.a[i + iFrom].pUsing "
"( db, ref pStepList "
"( db, ref pSub "
"( db, ref pSub1 "
"( db, ref pSubitem.zAlias "
"( db, ref pSubitem.zDatabase "
"( db, ref pSubitem.zName "
"( db, ref pSubquery "
"( db, ref pTabList "
"( db, ref pTable "
"( db, ref pTable.aCol "
"( db, ref pTable.pCheck "
"( db, ref pTable.pSelect "
"( db, ref pTable.zColAff "
"( db, ref pTable.zName "
"( db, ref pTableName "
"( db, ref pTblName "
"( db, ref pTmp "
"( db, ref pTmp.pExprList "
"( db, ref pTmp.pIdList "
"( db, ref pTmp.pSelect "
"( db, ref pTmp.pWhere "
"( db, ref pToCol "
"( db, ref pTrig "
"( db, ref pTrigger "
"( db, ref pTrigger.pColumns "
"( db, ref pTrigger.pWhen "
"( db, ref pTrigger.step_list "
"( db, ref pTrigger.table "
"( db, ref pUsing "
"( db, ref pVdbeFunc "
"( db, ref pWC.a "
"( db, ref pWhen "
"( db, ref pWhere "
"( db, ref pz "
"( db, ref pzErrMsg "
"( db, ref sAggInfo.aCol "
"( db, ref sAggInfo.aFunc "
"( db, ref ss "
"( db, ref tmp "
"( db, ref v.zErrMsg "
"( db, ref whenExpr "
"( db, ref z "
"( db, ref zCol "
"( db, ref zColl "
"( db, ref zErr "
"( db, ref zErrDyn "
"( db, ref zErrMsg "
"( db, ref zErrmsg "
"( db, ref zLeft "
"( db, ref zMaster "
"( db, ref zName "
"( db, ref zRight "
"( db, ref zSql "
"( db, ref zSqlCopy "
"( db, ref zStmt "
"( db, ref zVal "
"( db, ref zWhere "
"( db, sizeof( int "
"( db, sizeof(Column"
"( db, sizeof(Table"
"( db, sizeof(Trigger "
"( db, sqlite3_column_text( pStmt, 0 "
"( db, sqliteDefaultBusyCallback, db "
"( db, z, zDb "
"( db, zErrDyn "
"( db, zErrmsg "
"( db, zFile, zProc, ref pzErrMsg "
"( db, zFormat, ap "
"( db, zFunctionName, nArg, enc, p, xFunc, xStep, xFinal "
"( db, zFunctionName, nName, nArg, enc, 0 "
"( db, zFunctionName, nName, nArg, enc, 1 "
"( db, zMasterName, db.aDb[iDb].zName "
"( db, zMsg, ""%s AS %s"", zMsg, pItem.zAlias "
"( db, zMsg, ""%s ORDER BY"", zMsg "
"( db, zMsg, ""%s USING PRIMARY KEY"", zMsg "
"( db, zMsg, ""%s VIA MULTI-INDEX UNION"", zMsg "
"( db, zName "
"( db, zName, create "
"( db, zName, db.aDb[iDb].zName "
"( db, zName, enc, pCtx, xCompare, null "
"( db, zName, enc, pCtx, xCompare, xDel "
"( db, zName, sqlite3Strlen30( zName "
"( db, zName, zDb "
"( db, zRight, zDb "
"( db, zSpan "
"( db, zSql "
"( db, zSql, (dxCallback"
"( db, zSql, -1, 1, ref pNew, ref dummy "
"( db, zSql, -1, ref pStmt, ref Dummy "
"( db, zSql, -1, ref pStmt, ref zLeftover "
"( db, zSql, nBytes, 0, ref  ppStmt, ref pzTail "
"( db, zSql, nBytes, 1, ref  ppStmt, ref pzTail "
"( db, zSql, nBytes, saveSqlFlag, ref ppStmt, ref  pzTail "
"( db, zSql, nBytes, saveSqlFlag, ref ppStmt, ref pzTail "
"( db, zSql, null, null, ref Errors "
"( db, zSql, xCallback, pArg, ref Errors "
"( db, zStr "
"( db, zTab, zDb "
"( db, zToFree "
"( db, zToken "
"( db.aCollSeq, zName, nName "
"( db.aDb, db.aDbStatic, 2 "
"( db.aDbStatic, db.aDb, db.aDbStatic.Length "
"( db.aDb[db.nDb - 1].zName == ""vacuum_db"" "
"( db.aDb[iDb], iMoved, pOp.p1 "
"( db.aDb[iDb].pBt, iCookie, ref iMeta "
"( db.aDb[iDb].pBt,pOp.p1, ref iMoved "
"( db.aDb[ii].pBt, p1, iSavepoint "
"( db.aDb[j].pSchema.tblHash, zName, nName "
"( db.aDb[p1].pBt, pOp.p2, isWriteLock "
"( db.aDb[pOp.p2].pBt, pOp.p1, ref iDummy0 "
"( db.aDb[pOp.p2].pBt, pOp.p1, ref nChange "
"( db.aFunc, h, zName, nName "
"( db.aFunc, pBest "
"( db.pCollNeededArg, db, db.aDbStatic[0].pSchema.enc, zExternal "
"( db.pCollNeededArg, db, db.aDb[0].pSchema.enc, zExternal "
"( db.pErr, -1, p.zErrMsg == null ? """" : p.zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT "
"( db.pErr, -1, p.zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT "
"( db.pErr, -1, z, SQLITE_UTF8, (dxDel"
"( db.pErr, 0, null, SQLITE_UTF8, SQLITE_STATIC "
"( db.pProfileArg, p.zSql, elapseTime "
"( db.pTraceArg, zTrace "
"( db.pUpdateArg, SQLITE_DELETE, zDb, zTbl, iKey "
"( db.pUpdateArg, op, zDb, zTbl, iKey "
"( db.pVfs, (HANDLE"
"( db.pVfs, 1000000 "
"( db.pVfs, delay * 1000 "
"( db.pVfs, ref r "
"( db.pVfs, ref rNow "
"( db.pVfs, zFile, SQLITE_ACCESS_EXISTS, ref res "
"( db.pVfs, zRight, SQLITE_ACCESS_READWRITE, ref res "
"( delim == '""' "
"( dest, 0, ++pParse.nMem "
"( dest, SRT_Coroutine, ++pParse.nMem "
"( dest, SRT_Discard, 0 "
"( dest, SRT_EphemTab, iCur "
"( dest, SRT_EphemTab, pItem.iCursor "
"( dest, SRT_Set, pExpr.iTable "
"( dest, SRT_Table, 1 "
"( destA, SRT_Coroutine, regAddrA "
"( destB, SRT_Coroutine, regAddrB "
"( diskPath.Length - 1, 1 "
"( e2++ ; e2 < 0 ; precision--, e2++ "
"( eMode >= 0 && String.Compare( zRight, azModeName[eMode], true "
"( elem = pH.first, pH.first = null ; elem != null ; elem = next_elem "
"( elem.nKey == nKey && sqlite3StrNICmp( elem.pKey, pKey, nKey "
"( elem.pKey, elem.nKey "
"( errMsg, new StringBuilder( 200 "
"( errMsg, zCol, -1 "
"( errMsg, zSep, -1 "
"( errMsg.db, zErr "
"( escarg == """" || escarg == ""NULL\0"" "
"( et_getdigit( ref realvalue, ref nsd "
"( fd, (int"
"( fd, (u32"
"( fd, ac, 4, offset "
"( fd, ac, ac.Length, offset "
"( fd, offset, ref u32_pRes "
"( fileExists( db, ""vdbe_sqltrace"" "
"( fileExists( db, ""vdbe_trace"" "
"( filename, ref ppDb, flags, zVfs "
"( findTerm( pWC, iCur, -1, notReady, WO_GT | WO_GE, null "
"( findTerm( pWC, iCur, -1, notReady, WO_LT | WO_LE, null "
"( findTerm( pWC, iCur, j, notReady, WO_GT | WO_GE, pProbe "
"( findTerm( pWC, iCur, j, notReady, WO_LT | WO_LE, pProbe "
"( flag == WHERE_ORDERBY_MIN ? ""min"" : ""max"" "
"( flagPragma( pParse, zLeft, zRight "
"( flattenSubquery( pParse, p, i, isAgg, isAggSub "
"( getDigits( zDate, 2, 0, 24, ':', ref  h, 2, 0, 59, '\0', ref  m "
"( hasSharedCacheTableLock(pBtree, iRoot, 0, WRITE_LOCK"
"( hasSharedCacheTableLock(pCsr.pBtree, pCsr.pgnoRoot, 0, 2"
"( i = 0, j = 1 ; i < zArg.Length && zArg[i] != 0 ; i++ "
"( i = 0, j = n - 1 ; j >= 0 ; j--, i++ "
"( i = 0, n = 0 ; i < zArg.Length ; i++ "
"( i = 0, n = 1 ; i < zFmt.Length ; i++, n++ "
"( i = 0, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, i++ "
"( i = 0, pMem = p->aMem ; i < p->nField ; i++, pMem++ "
"( i = 1, c = (byte"
"( i = 1, pIdx = pTab.pIndex ; pIdx != null ; i++, pIdx = pIdx.pNext "
"( i = 1, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, i++ "
"( i = 3, c = (byte"
"( i = idx + 1 ; i < pPage.nCell ; i++, ptr += 2 "
"( i16 nArg, u8 iPrefEnc, u8 iflags, object pUserData, FuncDef pNext, dxFunc xFunc, dxStep xStep, dxFinal xFinalize, string zName, FuncDef pHash "
"( iColumn < 0 && !referencesOtherTables( pOrderBy, pMaskSet, j, _base "
"( iCur = 0, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, iCur++ "
"( iDb = 0, mask = 1 ; iDb < db.nDb ; mask <<= 1, iDb++ "
"( iDb == sqlite3SchemaToIndex( pParse.db, pIdx.pSchema "
"( iOffset, n "
"( id, (int"
"( id, flags "
"( id, lockType "
"( id, pBuf, amt, offset "
"( id, ref pResOut "
"( id, ref pSize "
"( id, size "
"( idx = 1, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, idx++ "
"( idx = precision, rounder = 0.5 ; idx > 0 ; idx--, rounder *= 0.1 "
"( initData, 3, azArg, null "
"( int N, ref i64 pBuf "
"( int X, byte[] Y "
"( int index, long bLong "
"( int n, ref StringBuilder zBuf, string zFormat, params va_list[] ap "
"( int n, ref byte[] pp "
"( int n, ref string zBuf, string zFormat, params va_list[] ap "
"( int nBuf, StringBuilder zBuf "
"( int nBuf, ref string zBuf "
"( int nExt, dxInit[] aExt "
"( int nScratchFree, int nPageFree, sqlite3_mutex mutex, sqlite3_int64 alarmThreshold, dxalarmCallback alarmCallback, object alarmArg, int alarmBusy, int[] aScratchFree, int[] aPageFree "
"( int op,  sqlite3_mutex_methods ap "
"( int op, int N "
"( int op, int X "
"( int op, params object[] ap "
"( int op, ref int pCurrent, ref int pHighwater, int resetFlag "
"( int op, ref sqlite3_mem_methods ap "
"( int op, ref sqlite3_mutex_methods ap "
"( int op, ref sqlite3_pcache_methods ap "
"( int op, sqlite3_mem_methods ap "
"( int op, sqlite3_pcache_methods ap "
"( int opcode, int mask "
"( int szPage, int bPurgeable "
"( int x, int y "
"( int x, u32 y "
"( int zero, int rc "
"( intersectdest, SRT_Union, tab1 "
"( isCompound && resolveCompoundOrderBy( pParse, pLeftmost "
"( isDate( context, argc, argv, ref x "
"( isLikeOrGlob( pParse, pExpr, ref nPattern, ref isComplete, ref noCase "
"( isLookaside( db, p "
"( isLookaside(db, p"
"( isMainJrnl != 0 ? ""main-journal"" : ""sub-journal"" "
"( j = 0, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, j++ "
"( jfd, ( pOffset "
"( jfd, aData, pPager.pageSize, ( pOffset "
"( jfd, pOffset, ref pgno "
"( k = addAggInfoColumn( pParse.db, pAggInfo "
"( len <= nIn && memcmp( zBlob, izIn + nIn - len, azChar[i], len "
"( len <= nIn && memcmp( zBlob, izIn, azChar[i], len "
"( m.n, m.zBLOB, pUnpacked "
"( m.zBLOB, (int"
"( m.zBLOB, 0, ref szHdr "
"( m.zBLOB, szHdr - 1, ref typeRowid "
"( mem1, pPKey2.aMem[i], i < nField ? pKeyInfo.aColl[i] : null "
"( memcmp( aMagic, aJournalMagic, aMagic.Length "
"( memcmp( pE.u.zToken, z, n "
"( moPDisk[""BytesPerSector""].ToString("
"( n, ref p "
"( nBuf, ref zBuf "
"( nBuf, ref zBuf, ""OsError 0x%x (%u"
"( nByte, pCache.bPurgeable ? 1 : 0 "
"( nCell, (void*"
"( nId == 3 && sqlite3StrNICmp( zSql, zIdx, ""end"", 3 "
"( nId == 4 && sqlite3StrNICmp( zSql, zIdx, ""temp"", 4 "
"( nId == 6 && sqlite3StrNICmp( zSql, zIdx, ""create"", 6 "
"( nId == 7 && sqlite3StrNICmp( zSql, zIdx, ""explain"", 7 "
"( nId == 7 && sqlite3StrNICmp( zSql, zIdx, ""trigger"", 7 "
"( nId == 9 && sqlite3StrNICmp( zSql, zIdx, ""temporary"", 9 "
"( nIdx = 0, pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext, nIdx++ "
"( nKey1, pKey1, 0, pPKey2 "
"( nRead, ( JOURNAL_CHUNKSIZE - iChunkOffset "
"( nReg <= n && usedAsColumnCache( pParse, i, i + n - 1 "
"( nSrcPgsz, nDestPgsz "
"( nTemp, ref zTemp, ""%.16g"", pMem.r "
"( nTemp, ref zTemp, ""%.16g"", pOp.p4.pReal "
"( nTemp, ref zTemp, ""%d"", pOp.p4.i "
"( nTemp, ref zTemp, ""%lld"", pMem.u.i "
"( nTemp, ref zTemp, ""%lld"", pOp.p4.pI64 "
"( nTemp, ref zTemp, ""%s(%d"
"( nTemp, ref zTemp, ""collseq(%.20s"
"( nTemp, ref zTemp, ""intarray"" "
"( nTemp, ref zTemp, ""keyinfo(%d"", pKeyInfo.nField "
"( nWrite, JOURNAL_CHUNKSIZE - iChunkOffset "
"( negFlag ? ""-"" + z : z, ref value "
"( new string( '0', width - ( ( prefix != '\0' "
"( null, """" "
"( null, (u32"
"( null, 0 "
"( null, 1, pTmpSpace "
"( null, aiValues "
"( null, i + addr, p.aOp[i + addr] "
"( null, i, p.aOp[i] "
"( null, null "
"( null, null, 0 "
"( null, null, null, null, null, null, null, null, null "
"( null, ref pTrigger "
"( object p, PgHdr pPg "
"( object pArg, Expr pExpr "
"( object pArg, dxPC_Init xInit, dxPC_Shutdown xShutdown, dxPC_Create xCreate, dxPC_Cachesize xCachesize, dxPC_Pagecount xPagecount, dxPC_Fetch xFetch, dxPC_Unpin xUnpin, dxPC_Rekey xRekey, dxPC_Truncate xTruncate, dxPC_Destroy xDestroy "
"( object pArg, i64 nCol, object Oargv, object Ocolv "
"( object pAuthArg, int b, string c, string d, string e, string f "
"( object pBtShared, int iValue "
"( object pBuf, int sz, int n "
"( object pCallbackArg, sqlite3_int64 argc, object p2, object p3 "
"( object pCollNeededArg, sqlite3 db, int eTextRep, string collationName "
"( object pCompareArg, int size1, string Key1, int size2, string Key2 "
"( object pData, sqlite3_int64 argc, object Oargv, object NotUsed "
"( object pInit, sqlite3_int64 argc, object p2, object NotUsed "
"( object pOld, int n "
"( object pProfileArg, string msg, u64 time "
"( object pTraceArg, string msg "
"( object pUpdateArg, int b, string c, string d, sqlite3_int64 e "
"( object[] ap, string sysType "
"( object[] ap, string zFormat "
"( offset + pFile.sharedLockByte, 1 "
"( offset, SeekOrigin.Begin "
"( offset, length "
"( p != null && p.xCmp == null && synthCollSeq( db, p "
"( p, (int"
"( p, 0, ref u32_v "
"( p, 0, ref u64_v "
"( p, 0, ref v "
"( p, 0, sizeof( sqlite3_backup "
"( p, 0, sqlite3MemJournalSize("
"( p, 0, v "
"( p, 1 "
"( p, 2 "
"( p, 3 "
"( p, EP_FromJoin "
"( p, OP_Noop "
"( p, SAVEPOINT_RELEASE "
"( p, SQLITE_ABORT "
"( p, a[i] "
"( p, addr, _p4, P4_DYNAMIC "
"( p, addr, _p4, n "
"( p, addr, _p4, p4type "
"( p, addr, p.nOp "
"( p, aiValues[j] "
"( p, eStatementOp "
"( p, flags "
"( p, i "
"( p, i, (i64"
"( p, iDb, MASTER_ROOT, 1, SCHEMA_TABLE( iDb "
"( p, iDb, pTab.tnum, ( opcode == OP_OpenWrite "
"( p, iPage, aData "
"( p, iSrcPg, sqlite3PagerGetData( pSrcPg "
"( p, nArg, enc "
"( p, offset, (u64"
"( p, offset, ref u32_v "
"( p, offset, ref u64_v "
"( p, offset, ref v "
"( p, offset, ref v64 "
"( p, offset, v "
"( p, op, 0, 0, 0 "
"( p, op, p1, (int"
"( p, op, p1, 0, 0 "
"( p, op, p1, p2, 0 "
"( p, op, p1, p2, p3 "
"( p, p.apCsr[iCur] "
"( p, p.apCsr[pOp.p1] "
"( p, p.u.pDef "
"( p, p1 + idx, p.aMem[p1 + idx] "
"( p, p2 + idx, p.aMem[p2 + idx] "
"( p, p2++, pOut "
"( p, pC "
"( p, pCache.nMax "
"( p, pOp.p1 + i, p.pResultSet[i] "
"( p, pOp.p1, nField, iDb, 1 "
"( p, pOp.p1, pIn1 "
"( p, pOp.p1, pOp.p2, -1, 1 "
"( p, pOp.p1, pOp.p3, -1, 0 "
"( p, pOp.p2, pArg "
"( p, pOp.p2, pData "
"( p, pOp.p2, pIn2 "
"( p, pOp.p2, pOut "
"( p, pOp.p3, pDest "
"( p, pOp.p3, pIn3 "
"( p, pOp.p3, pKey "
"( p, pOp.p3, pMem "
"( p, pOp.p3, pOut "
"( p, ref nArg "
"( p, ref nHeight "
"( p, zBuf "
"( p.aColName, p.nResColumn * COLNAME_N "
"( p.aMem, p.nMem "
"( p.aMem[p1 + idx], p.aMem[p2 + idx], pColl "
"( p.aMutex, p.db.aDb[i].pBt "
"( p.aVar, p.nVar "
"( p.aVar[i - 1], iValue "
"( p.aVar[i - 1], n "
"( p.aVar[i - 1], rValue "
"( p.a[i].pExpr, ref pnHeight "
"( p.azResult, sizeof(char*"
"( p.db, SQLITE_MISUSE, 0 "
"( p.db, SQLITE_OK, 0 "
"( p.db, SQLITE_RANGE, 0 "
"( p.db, p.aOp, nNew * sizeof( Op "
"( p.db, p.rc "
"( p.db, rc "
"( p.db, rc, 0 "
"( p.db, ref p.aLabel "
"( p.db, ref p.zText "
"( p.db, ref pChunk "
"( p.db, ref pCx.pData "
"( p.db, zFormat, ap "
"( p.isPrepareV2 ? p.zSql : """" "
"( p.nOrig >= pgno && 0 == sqlite3BitvecTest( p.pInSavepoint, pgno "
"( p.op == op && checkColumnOverlap( p.pColumns, pChanges "
"( p.pArg, p.nBusy "
"( p.pColumns, pChanges "
"( p.pCursor, null, p.movetoTarget, 0, ref res "
"( p.pCursor, ref hasMoved "
"( p.pCursor, ref res "
"( p.pDest, BTREE_SCHEMA_VERSION, ref p.iDestSchema "
"( p.pDestDb, 0 "
"( p.pDestDb, rc, 0 "
"( p.pEList, ref pnHeight "
"( p.pEList.a[0].pExpr, pDest.affinity "
"( p.pEntry, pHead "
"( p.pGroupBy, ref pnHeight "
"( p.pHaving, ref  pnHeight "
"( p.pInSavepoint, pgno "
"( p.pKeyInfo.db, ref p "
"( p.pLeft, flags "
"( p.pLeft, iTable "
"( p.pLeft, ref  pValue "
"( p.pLeft, ref nHeight "
"( p.pLimit, ref  pnHeight "
"( p.pOffset, ref  pnHeight "
"( p.pOrderBy, ref  pnHeight "
"( p.pPrior, ref  pnHeight "
"( p.pResultSet, p.nMem "
"( p.pResultSet[i], encoding "
"( p.pRight == null || ExprHasProperty( p.pRight, EP_IntValue "
"( p.pRight, flags "
"( p.pRight, ref nHeight "
"( p.pSrc, """" "
"( p.pSrc, 0 "
"( p.pTree, ref  pHead, ref  pTail "
"( p.pWhere, ref  pnHeight "
"( p.trace, ""rc=%d\n"", rc "
"( p.trace, R, M "
"( p.trace, pOp.p2, pOut "
"( p.trace, pOp.p3, pOut "
"( p.trace, pc, pOp "
"( p.u.aHash, 0, aiValues, 0, aiValues.Length * ( sizeof( u32 "
"( p.u.aHash, aiValues, p.u.aHash.Length "
"( p.u.zToken, ref pValue "
"( p.x.pList, ref nHeight "
"( p.x.pSelect, ref nHeight "
"( p.zSql == """" "
"( p1 == SAVEPOINT_ROLLBACK ? ""rollback"" : ""release"" "
"( p2 < 0 && sqlite3VdbeOpcodeHasProperty( pOut.opcode, OPFLG_JUMP "
"( pAccum, ""%"", 1 "
"( pAccum, ""."", 1 "
"( pAccum, fmt.Substring( bufpt, amt "
"( pAccum, new string( buf, bufpt, length "
"( pAccum, nspace "
"( pAccum, pItem.zDatabase, -1 "
"( pAccum, pItem.zName, -1 "
"( pAccum, pToken.z.ToString("
"( pAccum, zSep, nSep "
"( pAccum, zVal, nVal "
"( pAndWC, pOrTerm.pExpr, TK_AND "
"( pAndWC, pWC.pParse, pMaskSet "
"( pArg, encoding "
"( pB, EP_xIsSelect "
"( pBest, pArg "
"( pBest, pArg, pColl "
"( pBitvec, (u32"
"( pBitvec, 0 "
"( pBitvec, sz + 1 "
"( pBt, -1, (dxFreeSchema"
"( pBt, 0 "
"( pBt, BTREE_SCHEMA_VERSION, ref cookie "
"( pBt, BTREE_SCHEMA_VERSION, ref iMeta "
"( pBt, SAVEPOINT_RELEASE, iSavepoint "
"( pBt, SAVEPOINT_ROLLBACK, iSavepoint "
"( pBt, eAuto "
"( pBt, newMax "
"( pBt, null "
"( pBt, p.iStatement "
"( pBt, pOp.p2 "
"( pBt, pgno "
"( pBt, zMaster "
"( pBuf, (int"
"( pBuf, 0, amt "
"( pC, r, ref res "
"( pC.pCursor, 0 "
"( pC.pCursor, 0, (int"
"( pC.pCursor, null, iKey, 0, ref res "
"( pC.pCursor, null, v, 0, ref res "
"( pC.pCursor, pIdxKey, 0, 0, ref res "
"( pC.pCursor, r, 0, 0, ref res "
"( pC.pCursor, ref res "
"( pC.pCursor, ref v "
"( pC.pCursor, v < MAX_ROWID ? v + 1 : 0 "
"( pCache, 0 "
"( pCache, iLimit "
"( pCache, pPg "
"( pCache.pCache, mxPage "
"( pCache.pCache, p, 0 "
"( pCache.pCache, p, 1 "
"( pCache.pCache, p, p.pgno, newPgno "
"( pCache.pCache, pgno + 1 "
"( pCache.pCache, pgno, 2 "
"( pCache.pCache, pgno, eCreate "
"( pCache.pPage1.pData, 0, pCache.szPage "
"( pCache.pStress, pPg "
"( pCell, 0, cp.pCell, 0, pCell.Length "
"( pCell, 4, (u64"
"( pCell[nHeader], *(u64*"
"( pCell[nHeader], nData + nZero "
"( pChunk.zChunk, iChunkOffset, zOut, izOut, nCopy "
"( pColName, zName, -1, SQLITE_UTF8, xDel "
"( pColl != null && sqlite3StrICmp( pColl.zName, pIdx.azColl[j] "
"( pColl != null ? pColl.zName : ""null"" "
"( pColl.pUser, n1, v1, n2, v2 "
"( pColl.pUser, pMem1.n, pMem1.z, pMem2.n, pMem2.z "
"( pColumn == null && xferOptimization( pParse, pTab, pSelect, onError, iDb "
"( pCrsr, (int"
"( pCrsr, 0, (u32"
"( pCrsr, 0, len, pC.isIndex, sMem "
"( pCrsr, 0, n, pOut.zBLOB "
"( pCrsr, null, (long"
"( pCrsr, r, 0, 0, ref pCx.seekResult "
"( pCrsr, r, 0, 0, ref res "
"( pCrsr, ref avail, ref pC.aRow "
"( pCrsr, ref n "
"( pCrsr, ref n64 "
"( pCrsr, ref nEntry "
"( pCrsr, ref payloadSize64 "
"( pCrsr, ref res "
"( pCrsr, zKey, nKey, new byte[1], 0, 0, (pOp.p3 != 0"
"( pCrsr.info.pCell, pC.aRow, zRec, 0, (int"
"( pCtx, sqlite3ErrStr( errCode "
"( pCtx, z, n, 0, xDel "
"( pCtx, z, n, SQLITE_UTF8, SQLITE_TRANSIENT "
"( pCtx, z, n, SQLITE_UTF8, xDel "
"( pCtx.s, (i64"
"( pCtx.s, iVal "
"( pCtx.s, n "
"( pCtx.s, pValue "
"( pCtx.s, rVal "
"( pCtx.s.db, pVdbeFunc, nMalloc "
"( pCur, (u32"
"( pCur, 0, (int"
"( pCur, ref available, ref outOffset "
"( pCur, ref nCellKey "
"( pCur, ref pAmt, ref outOffset, false "
"( pCur, ref pAmt, ref outOffset, true "
"( pCur.apPage[iPage], pCur.aiIdx[iPage], ref pCur.info "
"( pCur.info.pCell, outOffset, aPayload, 0, (int"
"( pCur.info.pCell, outOffset, aPayload, 0, pCur.info.nSize - pCur.info.nHeader "
"( pCx.pBt, 1 "
"( pCx.pBt, MASTER_ROOT, 1, null, pCx.pCursor "
"( pCx.pBt, ref pgno, BTREE_ZERODATA "
"( pData, 24, pPager.dbFileVers, 0, pPager.dbFileVers.Length "
"( pData, argv[0], """" "
"( pData, argv[0], ""invalid rootpage"" "
"( pData, argv[0], zErr "
"( pData, null, null "
"( pData.zBLOB, 0, pC.pData, 0, pC.nData "
"( pDb, zDb "
"( pDb.pBt, 0 "
"( pDb.pBt, i + 1, ref meta[i] "
"( pDb.pBt, pDb.pSchema.cache_size "
"( pDb.pBt, pOp.p2, (u32"
"( pDb.pBt, ref pgno, flags "
"( pDb.zName, zName "
"( pDest, 0, N "
"( pDest, MEM_Null "
"( pDest, pOp.p4.pMem, MEM_Static "
"( pDest.pCheck != null && !sqlite3ExprCompare( pSrc.pCheck, pDest.pCheck "
"( pDestDb, SQLITE_NOMEM, 0 "
"( pDestDb, pDestDb, zDestDb "
"( pDestDb, pSrcDb, zSrcDb "
"( pDestPager, (u32"
"( pDestPager, null, false "
"( pDone != null && ( rc = sqlite3BitvecSet( pDone, pgno "
"( pE, EP_FromJoin "
"( pEList.a[0].pExpr, pDest.affinity "
"( pEngine, 0, pParse.sLastToken, pParse "
"( pEngine, TK_SEMI, pParse.sLastToken, pParse "
"( pEngine, tokenType, pParse.sLastToken, pParse "
"( pEntry, aBucket[i] "
"( pErrorDb, SQLITE_ERROR, ""unknown database %s"", zDb "
"( pErrorDb, SQLITE_NOMEM, ""out of memory"" "
"( pErrorDb, pParse "
"( pErrorDb, pParse.rc, ""%s"", pParse.zErrMsg "
"( pExpr, EP_Agg "
"( pExpr, EP_Error "
"( pExpr, EP_Resolved "
"( pExpr, EP_TokenOnly "
"( pExpr, EP_VarSelect "
"( pExpr.iColumn != iColumn || sqlite3StrICmp( pColl.zName, zColl "
"( pExpr.pRight, aff "
"( pExpr.x.pSelect.pEList.a[0].pExpr, aff "
"( pExpr1, (char"
"( pFd, eLock "
"( pFile, PENDING_BYTE, 1 "
"( pFile, RESERVED_BYTE, 1 "
"( pFile, SHARED_FIRST, SHARED_SIZE "
"( pFile, iSize "
"( pFile, ref iCurrent "
"( pFile, zData, nSrcPagesize, iOff "
"( pFile->h, lowerBits, &upperBits, FILE_BEGIN "
"( pFile.fs.Handle, LOCKFILE_FAIL_IMMEDIATELY, 0, (uint"
"( pFix.pParse.db, zDb "
"( pFromStmt, pToStmt "
"( pH, new_ht[h], elem "
"( pH, null, new_elem "
"( pH, pH.ht[h], new_elem "
"( pH, pKey, nKey, h "
"( pH, ref elem, h "
"( pHash, 0, sizeof( sqlite3GlobalFunctions "
"( pHash, aFunc[i] "
"( pHash, h, pDef.zName, nName "
"( pHash, h, zName, nName "
"( pI64, &value, sizeof( value "
"( pIdx.u.pRowSet, pVal.u.i "
"( pIdx.u.pRowSet, ref val "
"( pIdx.zName, zIndex "
"( pIn.pLeft, ref  ppFirst, ref  p "
"( pIn.pRight, ref  pIn.pRight, ref   ppLast "
"( pIn1, MEM_Blob "
"( pIn1, MEM_Int "
"( pIn1, SQLITE_AFF_NUMERIC, encoding "
"( pIn1, SQLITE_AFF_TEXT, encoding "
"( pIn1, affinity, encoding "
"( pIn1, encoding "
"( pIn1.u.pRowSet, pIn3.u.i "
"( pIn1.zBLOB, 0, pOut.zBLOB, pIn2.n, pIn1.n "
"( pIn2, encoding "
"( pIn2.zBLOB, 0, pOut.zBLOB, 0, pIn2.n "
"( pIn3, affinity, encoding "
"( pIn3, pIn1, pOp.p4.pColl "
"( pIndex.zName, zName, nName + 1 "
"( pInfo.db, argv[0], pInfo.zDatabase "
"( pItem.pSelect, indent + 10 "
"( pIter, ref nSize "
"( pJfd, 0 "
"( pJournal, zMasterPtr, nMasterPtr "
"( pKey, nKey "
"( pKey1, n, nKey1 - n "
"( pKey1, offset, aKey1, 0, aKey1.Length "
"( pKey1, pKey2, ( nKey1 < nKey2 "
"( pKey1, pKey2, n "
"( pKey2, n, nKey2 - n "
"( pLeft, pRight, jumpIfNull "
"( pLeft.pTab, zName "
"( pLevel, &pWC.a[iTerm] "
"( pLevel, pEnd "
"( pLevel, pOther "
"( pLevel, pRangeEnd "
"( pLevel, pRangeStart "
"( pLevel, pStart "
"( pLevel, pTerm "
"( pLevel.iLeftJoin == 0 || ExprHasProperty( pTerm.pExpr, EP_FromJoin "
"( pLink.pTabSchema.tblHash, pLink.table, n "
"( pLoop = p ; pLoop != null ; pLoop = pLoop.pPrior, cnt++ "
"( pLoop = pTab.pIndex, n = 1 ; pLoop != null ; pLoop = pLoop.pNext, n++ "
"( pMain, aCopy[i], ref meta "
"( pMain, pTemp "
"( pMain, sqlite3BtreeGetAutoVacuum( pTemp "
"( pMain, sqlite3BtreeGetPageSize( pTemp "
"( pMaskSet, iBase "
"( pMaskSet, p.iTable "
"( pMaskSet, p.pLeft "
"( pMaskSet, p.pRight "
"( pMaskSet, p.x.pList "
"( pMaskSet, p.x.pSelect "
"( pMaskSet, pAndTerm.leftCursor "
"( pMaskSet, pExpr "
"( pMaskSet, pExpr.iRightJoinTable "
"( pMaskSet, pExpr.pLeft "
"( pMaskSet, pExpr.pRight "
"( pMaskSet, pExpr.x.pList "
"( pMaskSet, pExpr.x.pSelect "
"( pMaskSet, pLeft "
"( pMaskSet, pList.a[i].pExpr "
"( pMaskSet, pOrTerm.leftCursor "
"( pMaskSet, pOther.leftCursor "
"( pMaskSet, pRight "
"( pMaskSet, pS.pEList "
"( pMaskSet, pS.pGroupBy "
"( pMaskSet, pS.pHaving "
"( pMaskSet, pS.pOrderBy "
"( pMaskSet, pS.pWhere "
"( pMaskSet, pTabItem.iCursor "
"( pMaskSet, pTabList.a[bestJ].iCursor "
"( pMaskSet, pTabList.a[i].iCursor "
"( pMaster, &nMasterJournal "
"( pMaster, Encoding.UTF8.GetBytes( zFile "
"( pMaster, zMasterJournal, (int"
"( pMem, 0 "
"( pMem, MEM_Int "
"( pMem, MEM_Null "
"( pMem, MEM_Real "
"( pMem, enc "
"( pMem, encoding "
"( pMem, file_format "
"( pMem, nByte, 0 "
"( pMem, pOp.p4.pFunc "
"( pMem, z, -1, SQLITE_UTF8, null "
"( pMem.db, n "
"( pMem.db, pMem.z, n "
"( pMem.n != 0 && sqlite3VdbeMemGrow( pMem, pMem.n + 2, 1 "
"( pMem.z, 0, 1,b01,0 "
"( pMem.z, 0, nByte "
"( pMem.z, ref val "
"( pMem.z, ref value "
"( pMem.zBLOB, 0 "
"( pMem.zBLOB, 0, buf, offset, (int"
"( pMem1.z, pMem2.z, ( pMem1.n > pMem2.n "
"( pMem1.z, pMem2.zBLOB, ( pMem1.n > pMem2.n "
"( pMem1.zBLOB, pMem2.zBLOB, ( pMem1.n > pMem2.n "
"( pNC, ref pItem.pExpr "
"( pNC.pParse.db, pTab.pSchema "
"( pName, ref pExpr "
"( pName.pParse, ""invalid name: \""%s\"""", pExpr.u.zToken "
"( pNew, (sqlite3_stmt"
"( pNew, apCell[j], ref info "
"( pNew, pExpr "
"( pNew.aCol, pTab.aCol, sizeof(Column"
"( pNew.aData[8], pCell, 4 "
"( pNewTrunk.aData[8], ref pTrunk.aData[12], ( k - 1 "
"( pOld, apCell, nCell "
"( pOld, j "
"( pOn != null ? ""ON"" : ""USING"" "
"( pOp = sqlite3VdbeGetOp( v, -1 "
"( pOp, pMem.z, 32 "
"( pOp, zPtr, 50 "
"( pOp.p2 != 0 || DbHasProperty( db, iDb, DB_SchemaLoaded "
"( pOrWc, pExpr, TK_OR "
"( pOrWc, pWC.pParse, pMaskSet "
"( pOrderBy == null || !sortableByRowid( iCur, pOrderBy, pWC.pMaskSet, ref rev "
"( pOrderBy, pMaskSet, 1, _base "
"( pOrderBy, pMaskSet, j, _base "
"( pOut, MEM_Blob "
"( pOut, MEM_Int "
"( pOut, MEM_Null "
"( pOut, MEM_Real "
"( pOut, MEM_Str "
"( pOut, ctx.s "
"( pOut, pIn1 "
"( pOut, pIn1, MEM_Ephem "
"( pOut, pOp.p4.z, pOp.p1, 0, null "
"( pOut, pVar, MEM_Static "
"( pOut, sqlite3VdbeIntValue( pIn1 "
"( pOut, val "
"( pOut, ~sqlite3VdbeIntValue( pIn1 "
"( pOut.z, pIn2.z, pIn2.n "
"( pPage, 0, sizeof( PgHdr "
"( pPage, i "
"( pPage, iCell, ref info "
"( pPage, iCell, ref pInfo "
"( pPage, iCellIdx, pCell - 4, nCell + 4, pTmp, n, ref rc "
"( pPage, pCell, 0, ref pInfo "
"( pPage, pCell, info "
"( pPage, pCell, ref info "
"( pPage, pCellBody, ref pCur.info "
"( pPage, pPage.nCell - 1 "
"( pPage, pTemp, ref info "
"( pPage1.aData[32], ref pTrunk.aData[0], 4 "
"( pPager, (u32"
"( pPager, 0 "
"( pPager, 0, (int"
"( pPager, 0, 0, ref offset, 1, pDone "
"( pPager, 1 "
"( pPager, 1, 0, ref pPager.journalOff, 1, pDone "
"( pPager, 1, isUnsync, ref pPager.journalOff, 0, null "
"( pPager, 1, ref pPgHdr "
"( pPager, EXCLUSIVE_LOCK "
"( pPager, Encoding.UTF8.GetString( zMaster "
"( pPager, SHARED_LOCK "
"( pPager, aData, pgno, 0, rc = SQLITE_NOMEM "
"( pPager, aData, pgno, 3, rc = SQLITE_NOMEM "
"( pPager, db.dfltJournalMode "
"( pPager, db.dfltLockMode "
"( pPager, eMode "
"( pPager, false "
"( pPager, false, pPager.subjInMemory "
"( pPager, hasMaster "
"( pPager, i, ref pPage "
"( pPager, iLimit "
"( pPager, isHot, szJ, ref nRec, ref mxPg "
"( pPager, mxPg "
"( pPager, nNew "
"( pPager, needSyncPgno, ref pPgHdr "
"( pPager, origPgno, ref pNew, 1 "
"( pPager, pData, pPg.pgno, 7, SQLITE_NOMEM, ref pData2 "
"( pPager, pData2 "
"( pPager, pList.pData, pgno, 6, SQLITE_NOMEM, ref pData "
"( pPager, pPager.setMaster "
"( pPager, pPg.pgno "
"( pPager, pSavepoint "
"( pPager, pg, ref pPage "
"( pPager, pgno "
"( pPager, pgno, ref ppPage, 0 "
"( pPager, rc "
"( pPager, ref  idummy "
"( pPager, ref  pPager.fd, (int"
"( pPager, ref iPageSize16, -1 "
"( pPager, ref idummy "
"( pPager, ref isHotJournal "
"( pPager, ref nMax "
"( pPager, ref nPage "
"( pPager, ref nPageCount "
"( pPager, ref pPager.sjfd, SQLITE_OPEN_SUBJOURNAL "
"( pPager, ref szPageDflt, -1 "
"( pPager, zMaster "
"( pPager, zMaster[0] != '\0' ? 1 : 0 "
"( pPager.fd, EXCLUSIVE_LOCK "
"( pPager.fd, NO_LOCK "
"( pPager.fd, RESERVED_LOCK "
"( pPager.fd, SHARED_LOCK "
"( pPager.fd, SQLITE_FCNTL_DB_UNCHANGED, ref iDummy "
"( pPager.fd, aData, pPager.pageSize, ofst "
"( pPager.fd, dbFileVers, dbFileVers.Length, 24 "
"( pPager.fd, locktype "
"( pPager.fd, new byte[1], 1, newSize - 1 "
"( pPager.fd, newSize "
"( pPager.fd, pData, pPager.pageSize, offset "
"( pPager.fd, pDest, N, 0 "
"( pPager.fd, pPager.sync_flags "
"( pPager.fd, pPg.pData, pPager.pageSize, iOffset "
"( pPager.fd, ref currentSize "
"( pPager.fd, ref locked "
"( pPager.fd, zBuf, pPager.pageSize, 0 "
"( pPager.jfd, (int"
"( pPager.jfd, 0 "
"( pPager.jfd, SQLITE_SYNC_DATAONLY | pPager.sync_flags "
"( pPager.jfd, aMagic, 8, iNextHdrOffset "
"( pPager.jfd, aMagic, aMagic.Length, iHdrOff "
"( pPager.jfd, first, 1, 0 "
"( pPager.jfd, pPager.journalOff "
"( pPager.jfd, pPager.journalOff, (u32"
"( pPager.jfd, pPager.sync_flags "
"( pPager.jfd, ref sz "
"( pPager.jfd, ref szJ "
"( pPager.jfd, zHeader, (int"
"( pPager.jfd, zMaster, (u32"
"( pPager.jfd, zeroHdr, zeroHdr.Length, 0 "
"( pPager.jfd, zerobyte, 1, iNextHdrOffset "
"( pPager.pBackup, pgno, aData "
"( pPager.pBackup, pgno, pList.pData "
"( pPager.pInJournal, needSyncPgno, pTemp "
"( pPager.pInJournal, pPg.pgno "
"( pPager.pInJournal, pgno "
"( pPager.pPCache, assertTruncateConstraintCb "
"( pPager.pPCache, mxPage "
"( pPager.pPCache, pPager.dbSize "
"( pPager.pPCache, pageSize "
"( pPager.pPCache, pgno, 0, ref p "
"( pPager.pPCache, pgno, 0, ref pPg "
"( pPager.pVfs, null, pFile, vfsFlags, ref dummy "
"( pPager.pVfs, pPager.zJournal, 0 "
"( pPager.pageSize, aData "
"( pPager.sjfd, 0 "
"( pPager.sjfd, offset, pPg.pgno "
"( pPager.sjfd, pData2, pPager.pageSize, offset + 4 "
"( pParent = p ; pParent != null ; pParent = pParent.pPrior, pSub = pSub.pPrior "
"( pParse, ""%d values for %d columns"", nColumn, pColumn.nId "
"( pParse, ""%s: %s"", zErr, zCol "
"( pParse, ""%s: %s"", zMsg, zName "
"( pParse, ""%s: %s.%s"", zErr, zTab, zCol "
"( pParse, ""%s: %s.%s"", zMsg, zDbase, zName "
"( pParse, ""%s: %s.%s.%s"", zErr, zDb, zTab, zCol "
"( pParse, ""Cannot add a PRIMARY KEY column"" "
"( pParse, ""Cannot add a UNIQUE column"" "
"( pParse, ""Cannot add a column to a view"" "
"( pParse, ""Cannot add a column with non-constant default"" "
"( pParse, ""ORDER"", i + 1, pEList.nExpr "
"( pParse, ""a GROUP BY clause is required before HAVING"" "
"( pParse, ""at most %d tables in a join"", BMS "
"( pParse, ""auto_vacuum"", auto_vacuum "
"( pParse, ""cache_size"", pDb.pSchema.cache_size "
"( pParse, ""cannot create trigger on system table"" "
"( pParse, ""cannot create triggers on virtual tables"" "
"( pParse, ""cannot modify %s because it is a view"", pTab.zName "
"( pParse, ""cannot use index: %s"", pIdx.zName "
"( pParse, ""corrupt database"" "
"( pParse, ""duplicate column name: %s"", z "
"( pParse, ""failed to set lock proxy file"" "
"( pParse, ""index %s already exists"", zName "
"( pParse, ""interrupt"" "
"( pParse, ""journal_size_limit"", iLimit "
"( pParse, ""max_page_count"", newMax "
"( pParse, ""misuse of aggregate function %.*s("
"( pParse, ""misuse of aggregate: %s("
"( pParse, ""misuse of aliased aggregate %s"", zAs "
"( pParse, ""near \""%T\"": syntax error"", pToken "
"( pParse, ""no such collation sequence: %s"", zName "
"( pParse, ""no such column: %s"", pChanges.a[i].zName "
"( pParse, ""no such function: %.*s"", nId, zId "
"( pParse, ""no such index: %S"", pName, 0 "
"( pParse, ""no such index: %s"", zIndex "
"( pParse, ""no such table: %s"", zTName "
"( pParse, ""no such trigger: %S"", pName, 0 "
"( pParse, ""no tables specified"" "
"( pParse, ""not a writable directory"" "
"( pParse, ""object name reserved for internal use: %s"", zName "
"( pParse, ""page_size"", size "
"( pParse, ""parameters are not allowed in views"" "
"( pParse, ""parameters prohibited in CHECK constraints"" "
"( pParse, ""subqueries prohibited in CHECK constraints"" "
"( pParse, ""synchronous"", pDb.safety_level - 1 "
"( pParse, ""table %T already exists"", pName "
"( pParse, ""table %s may not be altered"", pTab.zName "
"( pParse, ""table %s may not be dropped"", pTab.zName "
"( pParse, ""table %s may not be indexed"", pTab.zName "
"( pParse, ""table %s may not be modified"", pTab.zName "
"( pParse, ""temp_store"", db.temp_store "
"( pParse, ""temporary table name must be unqualified"" "
"( pParse, ""temporary trigger may not have qualified name"" "
"( pParse, ""there is already a table named %s"", zName "
"( pParse, ""there is already an index named %s"", zName "
"( pParse, ""too many SQL variables"" "
"( pParse, ""too many columns in %s"", zObject "
"( pParse, ""too many columns on %s"", p.zName "
"( pParse, ""too many terms in compound SELECT"" "
"( pParse, ""trigger %T already exists"", pName "
"( pParse, ""unable to identify the object to be reindexed"" "
"( pParse, ""unknown database %T"", pName1 "
"( pParse, ""unsupported encoding: %s"", zRight "
"( pParse, ""use DROP TABLE to delete table %s"", pTab.zName "
"( pParse, ""use DROP VIEW to delete view %s"", pTab.zName "
"( pParse, ""view %s is circularly defined"", pTable.zName "
"( pParse, ""view %s may not be altered"", pTab.zName "
"( pParse, ""views may not be indexed"" "
"( pParse, ""virtual tables may not be altered"" "
"( pParse, ""virtual tables may not be indexed"" "
"( pParse, ""wrong number of arguments to function %.*s("
"( pParse, ( pSelect != null || pTrigger != null "
"( pParse, -1 "
"( pParse, 0, iDb "
"( pParse, 0, p.iDb, pDb.pSchema.pSeqTab, OP_OpenRead "
"( pParse, 0, p.iDb, pDb.pSchema.pSeqTab, OP_OpenWrite "
"( pParse, 0, pFrom.zName, pFrom.zDatabase "
"( pParse, 0, pItem.zName, pItem.zDatabase "
"( pParse, 0, pSrc.a[0].zName, pSrc.a[0].zDatabase "
"( pParse, 0, z, null "
"( pParse, 0, z, zDb "
"( pParse, 1 "
"( pParse, 1, iDb "
"( pParse, 4 "
"( pParse, SQLITE_ATTACH, attach_func, p, p, pDbname, pKey "
"( pParse, SQLITE_DETACH, detach_func, pDbname, null, null, pDbname "
"( pParse, SQLITE_SELECT, null, null, null "
"( pParse, TK_AS, pDup, null, null "
"( pParse, TK_DOT, pE1b, pE1a, null "
"( pParse, TK_DOT, pE2b, pE2a, null "
"( pParse, TK_DOT, pLeft, pRight, 0 "
"( pParse, TK_EQ, pE1c, pE2c, null "
"( pParse, TK_GE, sqlite3ExprDup( db, pLeft, 0 "
"( pParse, TK_IN, pDup, null, null "
"( pParse, TK_IN, pWhereRowid, null, null "
"( pParse, TK_INTEGER, null, null, one "
"( pParse, TK_LT, sqlite3ExprDup( db, pLeft, 0 "
"( pParse, TK_NULL, null, null, null "
"( pParse, TK_REGISTER, null, null, pToken "
"( pParse, TK_ROW, null, null, null "
"( pParse, _base, n "
"( pParse, aListelem[i + 1].pExpr, target "
"( pParse, baseCur, iDb, pTab, op "
"( pParse, distinct, iContinue, nColumn, regResult "
"( pParse, exprAnd, dest, jumpIfNull "
"( pParse, exprX, ref regFree1 "
"( pParse, i "
"( pParse, iBMem, iAMem, pGroupBy.nExpr "
"( pParse, iCur, -1, iRowidReg "
"( pParse, iCur, iDb, pTab, OP_OpenWrite "
"( pParse, iDb "
"( pParse, iDb, iRootPage, 1, ""sqlite_stat1"" "
"( pParse, iDb, iStatCur, null "
"( pParse, iDb, iStatCur, pTab.zName "
"( pParse, iDb, pDflt != null ? 3 : 2 "
"( pParse, iDb, pTab "
"( pParse, iDb, pTab.tnum, 0, pTab.zName "
"( pParse, iDb, pTab.tnum, 1, pTab.zName "
"( pParse, iDbDest, pDest "
"( pParse, iDbSrc "
"( pParse, iDest, iDbDest, pDest, OP_OpenWrite "
"( pParse, iLargest, iDb "
"( pParse, iRec "
"( pParse, iReg, nConstraint + 2 "
"( pParse, iReleaseReg "
"( pParse, iSrc, iDbSrc, pSrc, OP_OpenRead "
"( pParse, iTab, iDb, pTab, OP_OpenRead "
"( pParse, iTable, iColumn, iReg "
"( pParse, in1, 1 "
"( pParse, in2, 1 "
"( pParse, inReg, 1 "
"( pParse, nArg "
"( pParse, nCol "
"( pParse, nCol + 1 "
"( pParse, nConstraint + 2 "
"( pParse, nExpr + 1 "
"( pParse, nExpr + 2 "
"( pParse, nFarg "
"( pParse, null "
"( pParse, null, null "
"( pParse, null, null, null, null, onError, null, null, sortOrder, ifNotExist "
"( pParse, null, null, null, pList, onError, null, null, sortOrder, 0 "
"( pParse, null, null, null, pList, onError, null, null, sortOrder, ifNotExist "
"( pParse, null, null, pExpr.u.zToken, pNC, pExpr "
"( pParse, null, null, pSelect "
"( pParse, null, onError, autoInc, sortOrder "
"( pParse, null, pExpr "
"( pParse, null, pFirst.pEList "
"( pParse, null, pFrom, pWhere, null, null, null, 0, null, null "
"( pParse, null, pSelectRowid"
"( pParse, null, pSrc, null, null, null, null, isDistinct, null, null "
"( pParse, null, pTo, pToCol, flags "
"( pParse, null, pToken "
"( pParse, null, sEnd, null "
"( pParse, null, sqlite3Expr( db, TK_ALL, null "
"( pParse, op, null, null, null "
"( pParse, op, null, null, pToken "
"( pParse, op, pLeft, null, null "
"( pParse, op, pLeft, null, pToken "
"( pParse, op, pLeft, pRight, null "
"( pParse, p "
"( pParse, p, aPermute[i] "
"( pParse, p, i "
"( pParse, p, iBreak "
"( pParse, p, iEnd "
"( pParse, p, labelEnd "
"( pParse, p, null "
"( pParse, p, null, null, pAlias, pSubquery, pOn, pUsing "
"( pParse, p, p.pOrderBy, ""ORDER"" "
"( pParse, p, pDest "
"( pParse, p, pOuterNC "
"( pParse, p, pTable, pDatabase, pAlias, null, pOn, pUsing "
"( pParse, p, ref  uniondest "
"( pParse, p, ref dest "
"( pParse, p, ref destB "
"( pParse, p, ref intersectdest "
"( pParse, p, v, pEList.nExpr, pDest "
"( pParse, p.iReg "
"( pParse, p.nHeight "
"( pParse, p.pEList "
"( pParse, p.pEList.a[iCol].pExpr "
"( pParse, p.pLimit, iLimit "
"( pParse, p.pOffset, iOffset "
"( pParse, p.pPrior, iCol "
"( pParse, p.step_list, orconf "
"( pParse, p.zName, ( ( db.flags & p.mask "
"( pParse, pA, null, null "
"( pParse, pA, pB, null "
"( pParse, pAndWC, pSrc, notReady, null, ref sTermCost "
"( pParse, pBest "
"( pParse, pC.pExpr, pC.iMem "
"( pParse, pChanges.a[j].pExpr, regCols + i "
"( pParse, pChanges.a[j].pExpr, regData + i "
"( pParse, pCons, pEnd, null "
"( pParse, pDbname, regArgs + 1 "
"( pParse, pDest.iMem, nColumn "
"( pParse, pDestIdx "
"( pParse, pDup "
"( pParse, pDup, ref dest "
"( pParse, pE, addrCont, SQLITE_JUMPIFNULL "
"( pParse, pE.x.pList "
"( pParse, pE2, r1 "
"( pParse, pEList, j, pExpr, """" "
"( pParse, pEList, pE "
"( pParse, pEList, pItem.iCol - 1, pItem.pExpr, zType "
"( pParse, pEList, regResult, eDest == SRT_Output "
"( pParse, pExpr "
"( pParse, pExpr, 0, false "
"( pParse, pExpr, iReg "
"( pParse, pExpr, pSchema, pNC.pSrcList "
"( pParse, pExpr, r1 "
"( pParse, pExpr, ref rMayHaveNull "
"( pParse, pExpr, ref regFree1 "
"( pParse, pExpr, target "
"( pParse, pExpr.iTable, pExpr.pLeft, target "
"( pParse, pExpr.pLeft "
"( pParse, pExpr.pLeft, d2, jumpIfNull ^ SQLITE_JUMPIFNULL "
"( pParse, pExpr.pLeft, dest, jumpIfNull "
"( pParse, pExpr.pLeft, ref regFree1 "
"( pParse, pExpr.pLeft, ref regFree2 "
"( pParse, pExpr.pLeft, target "
"( pParse, pExpr.pRight "
"( pParse, pExpr.pRight, dest, jumpIfNull "
"( pParse, pExpr.pRight, ref regFree2 "
"( pParse, pExpr.pRight, target "
"( pParse, pF.iDistinct, addrNext, 1, regAgg "
"( pParse, pFarg, r1, true "
"( pParse, pFarg.a[i].pExpr "
"( pParse, pFilename, regArgs "
"( pParse, pGroupBy "
"( pParse, pGroupBy, regBase, false "
"( pParse, pGroupBy.a[j].pExpr, iBMem + j "
"( pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL "
"( pParse, pHaving, addrOutputRow + 1, SQLITE_JUMPIFNULL "
"( pParse, pId1, pId2, null, minusFlag "
"( pParse, pId1, pId2, ref pId "
"( pParse, pIdx "
"( pParse, pIdx, 1, 3, true "
"( pParse, pIdx, iCur, 0, false "
"( pParse, pIdx.nColumn + 1 "
"( pParse, pIdx.tnum, iDb "
"( pParse, pIn.iMem, 1 "
"( pParse, pIn.iMem, pDest.iMem, pDest.nMem "
"( pParse, pIn.iMem, pDest.iParm, 1 "
"( pParse, pIn.iMem, pIn.nMem "
"( pParse, pIn.iMem, regPrev + 1, pIn.nMem "
"( pParse, pIn.nMem "
"( pParse, pIndex "
"( pParse, pIndex, -1 "
"( pParse, pIndex, iMem "
"( pParse, pIndex, iTab, regRecord, true "
"( pParse, pIndex.tnum, iDb "
"( pParse, pItem.iAlias, pItem.pExpr, target + i "
"( pParse, pItem.pExpr "
"( pParse, pItem.pExpr, target + i "
"( pParse, pItem.pSelect, pOuterNC "
"( pParse, pItem.pSelect.pSrc "
"( pParse, pIx "
"( pParse, pKey, regArgs + 2 "
"( pParse, pLeft "
"( pParse, pLeft, pRight "
"( pParse, pLeft, pRight, OP_Le, r1, r2, r4, SQLITE_STOREP2 "
"( pParse, pLeft, ref pFreeLeft "
"( pParse, pLevel, pWC, notReady, nExtraReg "
"( pParse, pList, null "
"( pParse, pList, nullId, 0 "
"( pParse, pList, regAgg, false "
"( pParse, pList.a[j].pExpr, iRegStore "
"( pParse, pList.a[j].pExpr, regCols + i "
"( pParse, pList.a[keyColumn].pExpr, regRowid "
"( pParse, pList.a[keyColumn].pExpr, regTrigRowid "
"( pParse, pName1, pName2, isTemp, 1, 0, noErr "
"( pParse, pName1, pName2, ref  pName "
"( pParse, pName1, pName2, ref  pTableName "
"( pParse, pName1, pName2, ref pName "
"( pParse, pName1, pName2, ref pObjName "
"( pParse, pNew "
"( pParse, pNew, a[k].pExpr "
"( pParse, pNew, pExpr "
"( pParse, pNew, sColname, 0 "
"( pParse, pOrderBy "
"( pParse, pOrderBy, p, r1 "
"( pParse, pOrderBy, p, regResult "
"( pParse, pOrderBy, pNew "
"( pParse, pOrderBy, regBase, false "
"( pParse, pPrior, pPrior.pOrderBy, ""ORDER"" "
"( pParse, pPrior, ref dest "
"( pParse, pPrior, ref destA "
"( pParse, pPrior, ref intersectdest "
"( pParse, pPrior, ref uniondest "
"( pParse, pRangeEnd.pExpr.pRight, regBase + nEq "
"( pParse, pRangeStart.pExpr.pRight, regBase + nEq "
"( pParse, pRight "
"( pParse, pRight, ref pFreeRight "
"( pParse, pRight, ref regFree2 "
"( pParse, pRowidExpr, regNewRowid "
"( pParse, pRowidExpr, regRowid "
"( pParse, pSel "
"( pParse, pSel.pEList, ref pTab.nCol, ref pTab.aCol "
"( pParse, pSel.pSrc "
"( pParse, pSelect "
"( pParse, pSelect, null "
"( pParse, pSelect, pDup "
"( pParse, pSelect, pOrderBy, zType "
"( pParse, pSelect, ref  dest "
"( pParse, pSelect, ref dest "
"( pParse, pSelect.pEList, pE "
"( pParse, pSelect.pEList, ref pTab.nCol, ref pTab.aCol "
"( pParse, pSrcIdx "
"( pParse, pSub, ref dest "
"( pParse, pTab "
"( pParse, pTab, -1, iCur, iRowid, false "
"( pParse, pTab, 1, OP_OpenRead "
"( pParse, pTab, TK_DELETE, null, ref iDummy "
"( pParse, pTab, TK_INSERT, null, ref tmask "
"( pParse, pTab, TK_UPDATE, pChanges, ref iDummy "
"( pParse, pTab, baseCur, 0 "
"( pParse, pTab, baseCur, OP_OpenWrite "
"( pParse, pTab, baseCur, regR, 0 "
"( pParse, pTab, iCur, 0 "
"( pParse, pTab, iCur, OP_OpenWrite "
"( pParse, pTab, iCur, aRegIdx "
"( pParse, pTab, iCur, iRowid, pParse.nested == 0 ? 1 : 0 "
"( pParse, pTab, iStatCur, iMem "
"( pParse, pTab, iStatCur, pParse.nMem + 1 "
"( pParse, pTab, null "
"( pParse, pTab, pTab.zName "
"( pParse, pTab, pWhere, iCur "
"( pParse, pTab, zColl "
"( pParse, pTab, zName "
"( pParse, pTab.aCol[i].pDflt, iRegStore "
"( pParse, pTab.aCol[i].pDflt, regCols + i "
"( pParse, pTab.aCol[i].pDflt, regData + i "
"( pParse, pTab.nCol "
"( pParse, pTab.nCol, pTab.aCol, pSel "
"( pParse, pTab.nCol, pTab.aCol, pSelect "
"( pParse, pTab.pCheck, allOk, SQLITE_JUMPIFNULL "
"( pParse, pTab.tnum, iDb "
"( pParse, pTabItem.iCursor, iDb, pTab, op "
"( pParse, pTabList "
"( pParse, pTabList, null, null, pColumn, onError "
"( pParse, pTabList, null, pSelect, pColumn, onError "
"( pParse, pTabList, pEList "
"( pParse, pTabList, pList, null, pColumn, onError "
"( pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef, pWhere "
"( pParse, pTabList, pWhere, ref NullOrderby, WHERE_ONEPASS_DESIRED "
"( pParse, pTabList, pWhere, ref elDummy, WHERE_DUPLICATES_OK "
"( pParse, pTabList, pWhere, ref pGroupBy, 0 "
"( pParse, pTabList, pWhere, ref pMinMax, (byte"
"( pParse, pTabList, pWhere, ref pOrderBy, 0 "
"( pParse, pTableName "
"( pParse, pTblName "
"( pParse, pTerm, pLevel, iReleaseReg "
"( pParse, pTerm, pLevel, regBase + j "
"( pParse, pTerm.pExpr, addrCont, SQLITE_JUMPIFNULL "
"( pParse, pTest, nextCase, SQLITE_JUMPIFNULL "
"( pParse, pTrigger != null ? 1 : 0, iDb "
"( pParse, pTrigger "
"( pParse, pTriggerStep "
"( pParse, pVTab != null ? 1 : 0, iDb "
"( pParse, pWC, pSrc, notReady, pOrderBy, pCost "
"( pParse, pWC, pSrc, notReady, pOrderBy, ref pCost "
"( pParse, pWC, pTabItem, notReady, pOrderBy, ref sCost "
"( pParse, pWC.a[iTerm].pExpr.pRight, iReg + j + 1 "
"( pParse, pWC.pMaskSet, pProbe, iCur, pOrderBy, nEq, ref rev "
"( pParse, pWhere "
"( pParse, pWhere, pWInfo.iBreak, SQLITE_JUMPIFNULL "
"( pParse, pX, rMayHaveNull, eType == IN_INDEX_ROWID "
"( pParse, pX, ref iDummy "
"( pParse, pX, ref regFree1 "
"( pParse, pX.pLeft, pExpr "
"( pParse, pX.pLeft, pX.pRight "
"( pParse, pX.pRight, iTarget "
"( pParse, pX.pRight, memEndValue "
"( pParse, pX.pRight, ref rTemp "
"( pParse, r1 "
"( pParse, r1, 1 "
"( pParse, r1, nFarg "
"( pParse, r2 "
"( pParse, r3 "
"( pParse, r3, 1 "
"( pParse, r4 "
"( pParse, rTemp "
"( pParse, regAgg, nArg "
"( pParse, regAutoinc, regRowid "
"( pParse, regBase "
"( pParse, regBase + nEq "
"( pParse, regBase, nCol "
"( pParse, regBase, nCol + 1 "
"( pParse, regBase, nConstraint, pIdx "
"( pParse, regBase, nEq + 1, pIdx "
"( pParse, regBase, nExpr + 2 "
"( pParse, regCols, pTab.nCol "
"( pParse, regData "
"( pParse, regData, pTab.nCol "
"( pParse, regData, regBase + nExpr + 1, 1 "
"( pParse, regFree1 "
"( pParse, regFree2 "
"( pParse, regIdx, pIdx.nColumn + 1 "
"( pParse, regPrev, nOrderBy + 1 "
"( pParse, regR "
"( pParse, regRec "
"( pParse, regRecord "
"( pParse, regResult, 1 "
"( pParse, regResult, iParm, 1 "
"( pParse, regResult, nColumn "
"( pParse, regRow "
"( pParse, regRow, 1 "
"( pParse, regRow, iParm, 1 "
"( pParse, regRowid "
"( pParse, regTempRowid "
"( pParse, regTrigRowid "
"( pParse, sAggInfo "
"( pParse, sContext, p.name "
"( pParse, ss, ref dest "
"( pParse, target, n "
"( pParse, tempWC, pSrc, notReady, null, ref sTermCost "
"( pParse, whenExpr, endTrigger, SQLITE_JUMPIFNULL "
"( pParse, zAlias1 "
"( pParse, zAlias2 "
"( pParse, zCol "
"( pParse, zColl "
"( pParse, zDb, zTable, zColumn, pNC, pExpr "
"( pParse, zRight "
"( pParse, zSql, ref zErrMsg "
"( pParse, zSqlCopy, ref zErrMsg "
"( pParse, zType, i + 1, nResult "
"( pParse, zType, i + 1, pEList.nExpr "
"( pParse->db, sizeof( value "
"( pParse.db, ""tbl_name=%Q"", zName "
"( pParse.db, 0, pStep.target, 0 "
"( pParse.db, TK_ID, zName "
"( pParse.db, op, pToken, 1 "
"( pParse.db, p, pLeft, pRight "
"( pParse.db, p.pWhere, pRight.pOn "
"( pParse.db, pAggInfo "
"( pParse.db, pColl, zName "
"( pParse.db, pIndexedBy "
"( pParse.db, pName "
"( pParse.db, pName1 "
"( pParse.db, pOrderBy, 0 "
"( pParse.db, pParse.aTableLock, nBytes "
"( pParse.db, pSrc.pSchema "
"( pParse.db, pStep.pTrig.pSchema "
"( pParse.db, pTab "
"( pParse.db, pTab.pSchema "
"( pParse.db, pTrig.pSchema "
"( pParse.db, pTrigger.pSchema "
"( pParse.db, pType "
"( pParse.db, ppExpr, pE "
"( pParse.db, ref  pParse.zErrMsg "
"( pParse.db, ref pList "
"( pParse.db, ref pSel.pLimit "
"( pParse.db, zId, nId, -1, enc, 0 "
"( pParse.db, zId, nId, n, enc, 0 "
"( pParse.db, zId, nId, nFarg, enc, 0 "
"( pParse.db, zName "
"( pParse.db, zName, zDbase "
"( pParse.nested == 0 && zName == ""sqlite_sequence"" "
"( pParse.pVdbe, (u8"
"( pParse.pVdbe, 3 "
"( pParse.pVdbe, 8 "
"( pParse.pVdbe, OP_Copy, iFrom + i, iTo + i "
"( pParse.pVdbe, OP_IdxDelete, iCur + i, r1, pIdx.nColumn + 1 "
"( pParse.pVdbe, OP_MemMax, memId, regRowid "
"( pParse.pVdbe, OP_Move, iFrom, iTo, nReg "
"( pParse.pVdbe, OP_SCopy, inReg, target "
"( pParse.pVdbe, OP_Statement, iDb "
"( pParse.pVdbe, endTrigger "
"( pParse.rc != SQLITE_OK && pParse.rc != SQLITE_DONE && pParse.zErrMsg == """" "
"( pPayload, pBuf, nByte "
"( pPg, origPgno "
"( pPg, pgno "
"( pPg.pData, 0, pPager.pageSize "
"( pPg.pData, 24, pPager.dbFileVers, 0, pPager.dbFileVers.Length "
"( pPg.pPager.pInJournal, pPg.pgno "
"( pPgHdr.pData, 24, change_counter "
"( pRec, (char"
"( pRec, MEM_Int "
"( pRec, SQLITE_UTF8 "
"( pRec, enc "
"( pRec, encoding "
"( pRec, file_format "
"( pRec.z, ref realnum, pRec.enc "
"( pRight.pOn, pRight.iCursor "
"( pRightTab, zName "
"( pSavepoint.zName, zName "
"( pSchema.idxHash, zName, nName "
"( pSrc, pAndWC "
"( pSrc, pOrWc "
"( pSrc, pWC, idxNew "
"( pSrc, pWC, idxNew1 "
"( pSrc, pWC, idxNew2 "
"( pSrc, pWC, idxTerm "
"( pSrcPager, (u32"
"( pSrcPager, iSrcPg, ref pSrcPg "
"( pSrcPager, ref nSrcPage "
"( pStmt, i "
"( pStmt, i, pValue.r "
"( pStmt, i, pValue.u.i "
"( pStmt, i, pValue.u.nZero "
"( pStmt, i, pValue.z, pValue.n, SQLITE_TRANSIENT "
"( pStmt, i, zData, nData, xDel, 0 "
"( pStmt, i, zData, nData, xDel, SQLITE_UTF8 "
"( pTab.zName, ""sqlite_"", 7 "
"( pTab.zName, 7, ""altertab_"", 9 "
"( pTabList, pWC "
"( pTabList, pWC, i "
"( pTemp, aCopy[i], (u32"
"( pTemp, apDiv[i], sz "
"( pTo.aVar[i], pFrom.aVar[i] "
"( pTrig = sqlite3TriggerList( pParse, pTab "
"( pTrig.table, pTab.zName "
"( pTrigger != null || readsTable( pParse, addrSelect, iDb, pTab "
"( pTrigger.pTabSchema.tblHash, pTrigger.table, n "
"( pTriggerStack.newIdx != -1 && sqlite3StrICmp( ""new"", zTab "
"( pTriggerStack.oldIdx != -1 && sqlite3StrICmp( ""old"", zTab "
"( pV, ( i + 1 "
"( pV, 0, ( sz + 7 "
"( pV, 0, (int"
"( pVal, (i64"
"( pVal, -1, zVal, SQLITE_UTF8, SQLITE_DYNAMIC "
"( pVal, Encoding.UTF8.GetString( sqlite3HexToBlob( db, zVal, nVal "
"( pVal, SQLITE_AFF_NUMERIC, SQLITE_UTF8 "
"( pVal, SQLITE_UTF16NATIVE "
"( pVal, SQLITE_UTF8 "
"( pVal, affinity, SQLITE_UTF8 "
"( pVal, enc "
"( pVal, enc & ~SQLITE_UTF16_ALIGNED "
"( pVar, ENC( p.db "
"( pVar, zData, nData, encoding, xDel "
"( pVdbe, zSql, (int"
"( pVdbeFunc, 0 "
"( pVfs, Encoding.UTF8.GetString( zMaster "
"( pVfs, handle, ref  zProc "
"( pVfs, nByte, ref zBufOut "
"( pVfs, nMicro "
"( pVfs, nMsg - 1, ref zErrmsg "
"( pVfs, pHandle "
"( pVfs, pHdle, zSym "
"( pVfs, pPager.zFilename, pPager.fd, vfsFlags, ref fout "
"( pVfs, pPager.zJournal, 0 "
"( pVfs, pPager.zJournal, SQLITE_ACCESS_EXISTS, ref exists "
"( pVfs, pPager.zJournal, SQLITE_ACCESS_EXISTS, ref res "
"( pVfs, pPager.zJournal, pPager.jfd, f, ref f "
"( pVfs, pPager.zJournal, pPager.jfd, f, ref fout "
"( pVfs, pPager.zJournal, pPager.jfd, flags, ref int0 "
"( pVfs, ref pTimeOut "
"( pVfs, zFile "
"( pVfs, zFile, pFile, flags, ref pOutFlags "
"( pVfs, zFilename, nPathname, zPathname "
"( pVfs, zJournal, SQLITE_ACCESS_EXISTS, &exists "
"( pVfs, zJournal, pJournal, flags, 0 "
"( pVfs, zMaster, 0 "
"( pVfs, zMaster, 1 "
"( pVfs, zMaster, SQLITE_ACCESS_EXISTS, ref res "
"( pVfs, zMaster, pMaster, flags, ref  iDummy "
"( pVfs, zPath "
"( pVfs, zPath, dirSync "
"( pVfs, zPath, flags, ref pResOut "
"( pVfs, zPath, nPathOut, zPathOut "
"( pVfs, zPath, pFile, flags, ref pFlagsOut "
"( pVfs, zRelative, MAX_PATH, zFullpath "
"( pVfs, zUtf8Name "
"( pVm.db, SQLITE_RANGE, 0 "
"( pWC, iCur, -1, 0, WO_EQ | WO_IN | WO_LT | WO_LE | WO_GT | WO_GE, null "
"( pWC, iCur, -1, notReady, WO_EQ | WO_IN, null "
"( pWC, iCur, -1, notReady, WO_GT | WO_GE, null "
"( pWC, iCur, -1, notReady, WO_LT | WO_LE | WO_GT | WO_GE, null "
"( pWC, iCur, -1, notReady, WO_LT | WO_LE, null "
"( pWC, iCur, j, notReady, (uint"
"( pWC, iCur, j, notReady, WO_LT | WO_LE | WO_GT | WO_GE, pProbe "
"( pWC, iCur, k, notReady, ( WO_GT | WO_GE "
"( pWC, iCur, k, notReady, ( WO_LT | WO_LE "
"( pWC, iCur, k, notReady, pLevel.plan.wsFlags, pIdx "
"( pWC, pDup, TERM_VIRTUAL | TERM_DYNAMIC "
"( pWC, pExpr, 0 "
"( pWC, pExpr.pLeft, op "
"( pWC, pExpr.pRight, op "
"( pWC, pNew, TERM_VIRTUAL | TERM_DYNAMIC "
"( pWC, pNewExpr, TERM_VIRTUAL | TERM_DYNAMIC "
"( pWC, pNewExpr1, TERM_VIRTUAL | TERM_DYNAMIC "
"( pWC, pNewExpr2, TERM_VIRTUAL | TERM_DYNAMIC "
"( pWC, pParse, pMaskSet "
"( pWC, pWhere, TK_AND "
"( pWC.pMaskSet, iCur "
"( pWC.pParse, pList, pDup "
"( pWInfo, i, wctrlFlags, notReady "
"( pWalker, p "
"( pWalker, pExpr.x.pSelect "
"( pWalker, pFrom.pSelect "
"( pWalker, pList "
"( pWalker, pSel "
"( pWalker, pSelect "
"( pWalker, ref pExpr "
"( pWalker.u.i == 3 && ExprHasAnyProperty( pExpr, EP_FromJoin "
"( pX, p2, wrFlag, pKeyInfo, pCur.pCursor "
"( pX.pLeft.iColumn < 0 && !ExprHasAnyProperty( pX, EP_xIsSelect "
"( parseHhMmSs( zDate, p "
"( parseYyyyMmDd( zDate, p "
"( patternCompare( zPattern, zString, pInfo, esc "
"( pg == pPg.pgno || sqlite3BitvecTest( pPager.pInJournal, pg "
"( pgno > pPager.dbSize || sqlite3BitvecTest( pDone, pgno "
"( pp = pCache.apHash[h] ; pp != pPage ; pPrev = pp, pp = pp.pNext "
"( ppBtree, nCache "
"( pzErrMsg != """" "
"( rc != SQLITE_OK || zErr == """" "
"( rc = backupTruncateFile( pFile, (int"
"( rc = read32bits( pJrnl, szJ - 12, ref cksum "
"( rc = read32bits( pJrnl, szJ - 16, ref len "
"( rc = read32bits( pPager.jfd, iHdrOff + 12, ref pPager.cksumInit "
"( rc = read32bits( pPager.jfd, iHdrOff + 16, ref pDbSize "
"( rc = read32bits( pPager.jfd, iHdrOff + 24, ref iPageSize "
"( rc = resolveAttachExpr( sName, pDbname "
"( rc = resolveAttachExpr( sName, pFilename "
"( rc = resolveAttachExpr( sName, pKey "
"( rc = sqlite3BtreeBeginTrans( p.pDest, 2 "
"( rc = sqlite3BtreeUpdateMeta( p.pDest, 1, p.iDestSchema + 1 "
"( rc = sqlite3OsRead( pJrnl, aMagic, 8, szJ - 8 "
"( rc = sqlite3OsRead( pJrnl, zMaster, len, szJ - 16 - len "
"( rc = sqlite3OsSync( pMaster, SQLITE_SYNC_NORMAL "
"( rc == SQLITE_OK && 0 == memcmp( aMagic, aJournalMagic, 8 "
"( rc == SQLITE_OK && null == sqlite3BtreeSchema( ppBtree, 0, null "
"( rc==SQLITE_OK && !DbHasProperty(*ppDb, 0, DB_SchemaLoaded"
"( rc==SQLITE_OK && ALWAYS(sqlite3GetVTable(db, pTab"
"( realnum == 0 && sqlite3Atoi64( pRec.z, ref value "
"( ref Hash pH, string pKey, int nKey, object data "
"( ref Hash pH, u32 new_size "
"( ref LONGDOUBLE_TYPE val, ref int cnt "
"( ref T A, ref T B "
"( ref byte[] pOld, int nSize "
"( ref byte[] pPrior, int nByte "
"( ref byte[] pz, sqlite3 db, string zFormat, params string[] ap "
"( ref db.aCollSeq, pColl[0].zName, nName, pColl "
"( ref db.aDb, db.nDb + 1 "
"( ref int pArg, Expr pExpr "
"( ref p.aCol, p.nCol + 8 "
"( ref p.aLabel, n "
"( ref p.aOp, nNew "
"( ref p.contextStack, i + 1 "
"( ref p.zErrMsg, db "
"( ref p.zErrMsg, db, ""%s"", pOp.p4.z "
"( ref p.zErrMsg, db, ""%s"", sqlite3ErrStr( rc "
"( ref p.zErrMsg, db, ""database table is locked: "", z "
"( ref p.zErrMsg, db, ""no such savepoint: %s"", zName "
"( ref p.zErrMsg, db, ""out of memory"" "
"( ref p.zErrMsg, db, ""string or blob too big"" "
"( ref p.zErrMsg, db, sqlite3ErrStr( p.rc "
"( ref p.zErrMsg, db, sqlite3ErrStr( rc "
"( ref p.zErrMsg, db, sqlite3_value_text( ctx.s "
"( ref p.zErrMsg, db, sqlite3_value_text( pMem "
"( ref pArray, newSize "
"( ref pExpr.pRight, ref pExpr.pLeft "
"( ref pExpr.pRight.pColl, ref pExpr.pLeft.pColl "
"( ref pHash, zIdxName, len, null "
"( ref pHash, zName, sqlite3Strlen30( zName "
"( ref pLevel.u._in.aInLoop, pLevel.u._in.nIn "
"( ref pList, iDepth "
"( ref pList.a, n "
"( ref pPager.aSavepoint, nSavepoint "
"( ref pParse.aTableLock, pParse.nTableLock + 1 "
"( ref pParse.zErrMsg, db, sqlite3ErrStr( pParse.rc "
"( ref pPrior, nByte "
"( ref pRangeEnd, ref pRangeStart "
"( ref pSrc.a, nAlloc "
"( ref pWC.a, pWC.nSlot * 2 "
"( ref ppList, iDepth - 1 "
"( ref pz, db, zFormat, Encoding.UTF8.GetString( ap "
"( ref pzErrMsg, db, ""%s"", sqlite3ErrStr( rc "
"( ref pzErrMsg, db, ""cannot VACUUM from within a transaction"" "
"( ref pzErrMsg, db, ""unsupported file format"" "
"( ref string pz, sqlite3 db, string zFormat, byte[] ap "
"( ref string pz, sqlite3 db, string zFormat, params string[] ap "
"( ref string pzErrMsg, sqlite3 db "
"( ref sz, db, zFormat, ap "
"( ref wsdAutoext.aExt, wsdAutoext.nExt + 1 "
"( rehash( ref  pH, pH.count * 2 "
"( res.azResult, sizeof(char*"
"( res.zErrMsg !="""""
"( resolveOrderGroupBy( sNC, p, pGroupBy, ""GROUP"" "
"( s, cp.s, s.Length "
"( sFix, pSelect "
"( sFix, pTableName "
"( sFix, pTblName "
"( sFix, pTrig.step_list "
"( sMem, pDest "
"( sNC, p, ref bDummy, ref bDummy, ref bDummy "
"( sNC, p, ref sDummy, ref sDummy, ref sDummy "
"( sNC, p, ref zOriginDb, ref zOriginTab, ref zOriginCol "
"( sNC, pEList "
"( sNC, pOrderBy "
"( sNC, ref p.pHaving "
"( sNC, ref p.pOffset "
"( sNC, ref pHaving "
"( sNC, sAggInfo.aFunc[i].pExpr.x.pList "
"( sortableByRowid( iCur, pOrderBy, pWC.pMaskSet, ref rev "
"( sqlite3 D, int I, ushort P "
"( sqlite3 D, int N "
"( sqlite3 D, object P "
"( sqlite3 X, string Y "
"( sqlite3 db, AggInfo pInfo "
"( sqlite3 db, BtCursor pCur, ref i64 rowid "
"( sqlite3 db, Btree pBt "
"( sqlite3 db, CollSeq pColl "
"( sqlite3 db, Expr p "
"( sqlite3 db, Expr p, int flags "
"( sqlite3 db, Expr p, int flags, ref Expr pzBuffer "
"( sqlite3 db, Expr pExpr, ref bool pIsNocase, char[] aWc "
"( sqlite3 db, Expr pLeft, Expr pRight "
"( sqlite3 db, ExprList p, int flags "
"( sqlite3 db, FuncDef pDef "
"( sqlite3 db, IdList p "
"( sqlite3 db, IdList pList, Token pToken "
"( sqlite3 db, Schema pSchema "
"( sqlite3 db, Select p "
"( sqlite3 db, Select p, int flags "
"( sqlite3 db, Select pSelect "
"( sqlite3 db, SrcList p, int flags "
"( sqlite3 db, Table p "
"( sqlite3 db, Token pName "
"( sqlite3 db, Token pTableName, IdList pColumn, ExprList pEList, int null_5, u8 orconf "
"( sqlite3 db, Token pTableName, IdList pColumn, int null_4, Select pSelect, u8 orconf "
"( sqlite3 db, Token pTableName, IdList pColumn, int null_4, int null_5, u8 orconf "
"( sqlite3 db, Vdbe p "
"( sqlite3 db, WhereAndInfo p "
"( sqlite3 db, WhereInfo pWInfo "
"( sqlite3 db, WhereOrInfo p "
"( sqlite3 db, bool onoff "
"( sqlite3 db, byte[] p "
"( sqlite3 db, byte[] pBuf, int sz, int cnt "
"( sqlite3 db, dxTrace xTrace, object pArg "
"( sqlite3 db, int N "
"( sqlite3 db, int caseSensitive "
"( sqlite3 db, int err_code, int noString "
"( sqlite3 db, int err_code, string zFormat, params object[] ap "
"( sqlite3 db, int iDb "
"( sqlite3 db, int iDb, ref string pzErrMsg "
"( sqlite3 db, int iDb, string zIdxName "
"( sqlite3 db, int iDb, string zName "
"( sqlite3 db, int iDb, string zTabName "
"( sqlite3 db, int idx "
"( sqlite3 db, int limitId, int newLimit "
"( sqlite3 db, int ms "
"( sqlite3 db, int n "
"( sqlite3 db, int nChange "
"( sqlite3 db, int null_2, Token pTable, Token pDatabase "
"( sqlite3 db, int null_2, Token pTable, int null_4 "
"( sqlite3 db, int null_2, Token pToken "
"( sqlite3 db, int onoff "
"( sqlite3 db, int op, params object[] ap "
"( sqlite3 db, int p4type, object p4 "
"( sqlite3 db, int rc "
"( sqlite3 db, object p "
"( sqlite3 db, object p, int n "
"( sqlite3 db, object pAux, int argc, string constargv, ref sqlite3_vtab ppVTab, ref string pError "
"( sqlite3 db, object pSpace, u32 N "
"( sqlite3 db, ref Expr p "
"( sqlite3 db, ref ExprList pList "
"( sqlite3 db, ref IdList pList "
"( sqlite3 db, ref Select p "
"( sqlite3 db, ref SrcList pList "
"( sqlite3 db, ref StringBuilder x "
"( sqlite3 db, ref T p "
"( sqlite3 db, ref Trigger pTrigger "
"( sqlite3 db, ref TriggerStep pTriggerStep "
"( sqlite3 db, ref byte[] x "
"( sqlite3 db, ref int[] x "
"( sqlite3 db, ref string pzErrMsg "
"( sqlite3 db, ref string x "
"( sqlite3 db, ref string zMessage, sqlite3_api_routines sar "
"( sqlite3 db, string z, int n "
"( sqlite3 db, string zDbName, int op, ref int pArg "
"( sqlite3 db, string zFile "
"( sqlite3 db, string zFormat, params va_list[] ap "
"( sqlite3 db, string zName "
"( sqlite3 db, string zName, int flagVal "
"( sqlite3 db, string zName, string zDatabase "
"( sqlite3 db, string zName, string zDb "
"( sqlite3 db, string zSql "
"( sqlite3 db, string zStr, string zFormat, params  va_list[] ap "
"( sqlite3 pDb, sqlite3_stmt pStmt "
"( sqlite3 pErrorDb, sqlite3 pDb, string zDb "
"( sqlite3 x, sqlite3 y "
"( sqlite3AuthCheck( pParse, SQLITE_PRAGMA, zLeft, zRight, zDb "
"( sqlite3AuthCheck( pParse, SQLITE_TRANSACTION, ""BEGIN"", null, null "
"( sqlite3AuthCheck( pParse, SQLITE_TRANSACTION, ""COMMIT"", null, null "
"( sqlite3AuthCheck( pParse, SQLITE_TRANSACTION, ""ROLLBACK"", null, null "
"( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab.zName, 0"
"( sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab.zName, 0, zDb"
"( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb"
"( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iDb"
"( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iTabDb"
"( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(isTemp"
"( sqlite3AuthCheck(pParse, SQLITE_INSERT, pTab.zName, 0, zDb"
"( sqlite3AuthCheck(pParse, code, pIndex.zName, pTab.zName, zDb"
"( sqlite3AuthCheck(pParse, code, pTab.zName, zArg2, zDb"
"( sqlite3AuthCheck(pParse, code, pTrigger.name, pTable.zName, zDb"
"( sqlite3AuthCheck(pParse, code, zName, pTab.zName, zDbTrig"
"( sqlite3AuthCheck(pParse, i, zName, pTab.zName, zDb"
"( sqlite3BitvecSet( pBitvec, (u32"
"( sqlite3BtreeSetPageSize( pTemp, sqlite3BtreeGetPageSize( pMain "
"( sqlite3CheckCollSeq( pParse, pColl "
"( sqlite3DbMallocSize(pMem->db, pMem.zMalloc"
"( sqlite3ExprCheckHeight(pParse, pExpr.nHeight+pNC.pParse.nHeight"
"( sqlite3ExprCompare( pEList.a[i].pExpr, pE "
"( sqlite3ExprCompare( pItem.pExpr, pExpr "
"( sqlite3ExprIsInteger( p.pLeft, ref v "
"( sqlite3ExprIsInteger( pE, ref i "
"( sqlite3ExprIsInteger( pE, ref iCol "
"( sqlite3FindCollSeq( db, ENC( db "
"( sqlite3FindFunction( db, zName, nName, nArg, SQLITE_UTF8, 0 "
"( sqlite3FindIndex( db, zName, null "
"( sqlite3FindIndex( db, zName, pDb.zName "
"( sqlite3FindTable( db, ""sqlite_sequence"", zDb "
"( sqlite3FindTable( db, ""sqlite_stat1"", db.aDb[iDb].zName "
"( sqlite3FindTable( db, ""sqlite_stat1"", sInfo.zDatabase "
"( sqlite3FindTable( db, zName, null "
"( sqlite3FindTable( db, zName, zDb "
"( sqlite3FitsIn64Bits( z, negFlag "
"( sqlite3FixExpr( pFix, pExpr.pRight "
"( sqlite3FixExpr( pFix, pItem.pExpr "
"( sqlite3FixExpr( pFix, pItem.pOn "
"( sqlite3FixExpr( pFix, pSelect.pHaving "
"( sqlite3FixExpr( pFix, pSelect.pWhere "
"( sqlite3FixExpr( pFix, pStep.pWhere "
"( sqlite3FixExprList( pFix, pExpr.x.pList "
"( sqlite3FixExprList( pFix, pSelect.pEList "
"( sqlite3FixExprList( pFix, pStep.pExprList "
"( sqlite3FixInit( sFix, pParse, iDb, ""index"", pName "
"( sqlite3FixInit( sFix, pParse, iDb, ""trigger"", nameToken "
"( sqlite3FixInit( sFix, pParse, iDb, ""trigger"", pName "
"( sqlite3FixInit( sFix, pParse, iDb, ""view"", pName "
"( sqlite3FixSelect( pFix, pExpr.x.pSelect "
"( sqlite3FixSelect( pFix, pItem.pSelect "
"( sqlite3FixSelect( pFix, pStep.pSelect "
"( sqlite3FixSrcList( pFix, pSelect.pSrc "
"( sqlite3GetInt32( argv[1], ref pIndex.tnum "
"( sqlite3GetVTable(pParse.db, pTab"
"( sqlite3IdListIndex( pIdList, pEList.a[e].zName "
"( sqlite3IdListIndex( pTabList.a[i].pUsing, zName "
"( sqlite3IndexedByLookup( pParse, pFrom "
"( sqlite3IndexedByLookup( pParse, pItem "
"( sqlite3IsNumber( zDate, ref isRealNum, SQLITE_UTF8 "
"( sqlite3IsReadOnly( pParse, pTab, ( pTrigger != null ? 1 : 0 "
"( sqlite3IsReadOnly( pParse, pTab, tmask "
"( sqlite3LocateCollSeq( pParse, zColl "
"( sqlite3MemCompare( argv[0], argv[1], pColl "
"( sqlite3OsLock( pPager.fd, RESERVED_LOCK "
"( sqlite3OsSleep( pVfs, 1000 * ms "
"( sqlite3ResolveExprNames( nc, ref pE "
"( sqlite3ResolveExprNames( pNC, ref pE "
"( sqlite3ResolveExprNames( sNC, ref p.pCheck "
"( sqlite3ResolveExprNames( sNC, ref p.pLimit "
"( sqlite3ResolveExprNames( sNC, ref p.pWhere "
"( sqlite3ResolveExprNames( sNC, ref pChanges.a[i].pExpr "
"( sqlite3ResolveExprNames( sNC, ref pList.a[i].pExpr "
"( sqlite3ResolveExprNames( sNC, ref pWhere "
"( sqlite3ResolveExprNames( sNC, ref pX "
"( sqlite3Select( pParse, pExpr.x.pSelect, ref dest "
"( sqlite3Select( pParse, pSel, ref dest "
"( sqlite3StrICmp( aCol[j].zName, zName "
"( sqlite3StrICmp( p.aCol[j].zName, pFromCol.a[i].zName "
"( sqlite3StrICmp( pA.u.zToken, pB.u.zToken "
"( sqlite3StrICmp( pCol.zName, zCol "
"( sqlite3StrICmp( pColumn.a[i].zName, pTab.aCol[j].zName "
"( sqlite3StrICmp( pDb.zName, zName "
"( sqlite3StrICmp( pItem.zDatabase, zDb "
"( sqlite3StrICmp( pList.a[i].zName, pTab.aCol[iCol].zName "
"( sqlite3StrICmp( pList.a[i].zName, zName "
"( sqlite3StrICmp( pTab.aCol[i].zName, zCol "
"( sqlite3StrICmp( pTab.aCol[j].zName, pChanges.a[i].zName "
"( sqlite3StrICmp( pUsing.a[k].zName, zCol "
"( sqlite3StrICmp( z, ""OID"" "
"( sqlite3StrICmp( z, ""ROWID"" "
"( sqlite3StrICmp( z, ""_ROWID_"" "
"( sqlite3StrICmp( z, ""file"" "
"( sqlite3StrICmp( z, ""memory"" "
"( sqlite3StrICmp( z, zName "
"( sqlite3StrICmp( zColName, pTabCol.zName "
"( sqlite3StrICmp( zDate, ""now"" "
"( sqlite3StrICmp( zLeft, ""auto_vacuum"" "
"( sqlite3StrICmp( zLeft, ""cache_size"" "
"( sqlite3StrICmp( zLeft, ""case_sensitive_like"" "
"( sqlite3StrICmp( zLeft, ""collation_list"" "
"( sqlite3StrICmp( zLeft, ""database_list"" "
"( sqlite3StrICmp( zLeft, ""default_cache_size"" "
"( sqlite3StrICmp( zLeft, ""encoding"" "
"( sqlite3StrICmp( zLeft, ""file_format"" "
"( sqlite3StrICmp( zLeft, ""foreign_key_list"" "
"( sqlite3StrICmp( zLeft, ""incremental_vacuum"" "
"( sqlite3StrICmp( zLeft, ""index_info"" "
"( sqlite3StrICmp( zLeft, ""index_list"" "
"( sqlite3StrICmp( zLeft, ""integrity_check"" "
"( sqlite3StrICmp( zLeft, ""journal_size_limit"" "
"( sqlite3StrICmp( zLeft, ""lock_proxy_file"" "
"( sqlite3StrICmp( zLeft, ""lock_status"" "
"( sqlite3StrICmp( zLeft, ""locking_mode"" "
"( sqlite3StrICmp( zLeft, ""max_page_count"" "
"( sqlite3StrICmp( zLeft, ""page_count"" "
"( sqlite3StrICmp( zLeft, ""page_size"" "
"( sqlite3StrICmp( zLeft, ""parser_trace"" "
"( sqlite3StrICmp( zLeft, ""reload_schema"" "
"( sqlite3StrICmp( zLeft, ""schema_version"" "
"( sqlite3StrICmp( zLeft, ""synchronous"" "
"( sqlite3StrICmp( zLeft, ""table_info"" "
"( sqlite3StrICmp( zLeft, ""temp_store"" "
"( sqlite3StrICmp( zLeft, ""temp_store_directory"" "
"( sqlite3StrICmp( zLeft, p.zName "
"( sqlite3StrICmp( zTabName, zTab "
"( sqlite3StrICmp(pTab.aCol[iCol].zName, zColumn"
"( sqlite3StrICmp(zLeft, ""activate_extensions"""
"( sqlite3StrICmp(zLeft, ""key"""
"( sqlite3StrICmp(zLeft, ""rekey"""
"( sqlite3StrNICmp( p.zName, zFunc, nFunc "
"( sqlite3StrNICmp( pTab.zName, ""sqlite_"", 7 "
"( sqlite3StrNICmp(""hidden"", zType, 6"
"( sqlite3StrNICmp(zRight, ""cerod-"", 6"
"( sqlite3StrNICmp(zRight, ""see-"", 4"
"( sqlite3TriggerList( pParse, pDest "
"( sqlite3Utf8CharLen( zEsc, -1 "
"( sqlite3Utf8Read( zString, ref zString "
"( sqlite3ValueFromExpr( db, pDflt, SQLITE_UTF8, SQLITE_AFF_NONE, ref pVal "
"( sqlite3VdbeChangeEncoding( pMem, SQLITE_UTF8 "
"( sqlite3VdbeMemGrow( pMem, (int"
"( sqlite3VdbeMemGrow( pMem, 32, 0 "
"( sqlite3VdbeMemGrow( pMem, 4, 0 "
"( sqlite3VdbeMemGrow( pMem, nByte, 0 "
"( sqlite3VdbeMemGrow( pMem, pMem.n + 2, 1 "
"( sqlite3VdbeMemGrow( pOut, (int"
"( sqlite3VdbeMemSetStr( pCtx.s, z, n, enc, xDel "
"( sqlite3VdbeOpcodeHasProperty( opcode, OPFLG_JUMP "
"( sqlite3ViewGetColumnNames( pParse, pTab "
"( sqlite3VtabCallConnect( pParse, pTable "
"( sqlite3WalkExpr( pWalker, ref p.pHaving "
"( sqlite3WalkExpr( pWalker, ref p.pLimit "
"( sqlite3WalkExpr( pWalker, ref p.pOffset "
"( sqlite3WalkExpr( pWalker, ref p.pWhere "
"( sqlite3WalkExpr( pWalker, ref pExpr.pLeft "
"( sqlite3WalkExpr( pWalker, ref pExpr.pRight "
"( sqlite3WalkExpr( pWalker, ref pItem.pExpr "
"( sqlite3WalkExprList( pWalker, p.pEList "
"( sqlite3WalkExprList( pWalker, p.pGroupBy "
"( sqlite3WalkExprList( pWalker, p.pOrderBy "
"( sqlite3WalkExprList( pWalker, pExpr.x.pList "
"( sqlite3WalkSelect( pWalker, pExpr.x.pSelect "
"( sqlite3WalkSelect( pWalker, pItem.pSelect "
"( sqlite3WalkSelectExpr( pWalker, p "
"( sqlite3WalkSelectFrom( pWalker, p "
"( sqlite3_backup p, Pgno iSrcPg, byte[] zSrcData "
"( sqlite3_backup p, int nPage "
"( sqlite3_backup pBackup, Pgno iPage, byte[] aData "
"( sqlite3_context context, DateTime p "
"( sqlite3_context ctx, int intValue, sqlite3_value[] value "
"( sqlite3_context p, int nByte "
"( sqlite3_context pCtx, double rVal "
"( sqlite3_context pCtx, i64 iVal "
"( sqlite3_context pCtx, int errCode "
"( sqlite3_context pCtx, int iArg "
"( sqlite3_context pCtx, int iVal "
"( sqlite3_context pCtx, int n "
"( sqlite3_context pCtx, sqlite3_value pValue "
"( sqlite3_context pCtx, string z, int n "
"( sqlite3_context pCtx, string z, int n, dxDel xDel "
"( sqlite3_context* context, i64 nByte "
"( sqlite3_file File_ID, byte[] buffer, int amount, sqlite3_int64 offset "
"( sqlite3_file File_ID, int flags "
"( sqlite3_file File_ID, int locktype "
"( sqlite3_file File_ID, int op, ref int pArgs "
"( sqlite3_file File_ID, ref int pRes"
"( sqlite3_file File_ID, ref int size "
"( sqlite3_file File_ID, sqlite3_int64 size "
"( sqlite3_file NotUsed, int NotUsed2 "
"( sqlite3_file fd, i64 offset, ref u32 pRes "
"( sqlite3_file fd, i64 offset, u32 val "
"( sqlite3_file fd, int offset, ref int pRes "
"( sqlite3_file fd, int offset, ref u32 pRes "
"( sqlite3_file id, byte[] pBuf, int amt, i64 offset "
"( sqlite3_file id, i64 size "
"( sqlite3_file id, int flags "
"( sqlite3_file id, int lockType "
"( sqlite3_file id, int locktype "
"( sqlite3_file id, int op, ref int pArg "
"( sqlite3_file id, ref int pResOut "
"( sqlite3_file id, ref int pSize "
"( sqlite3_file id, sqlite3_int64 nByte "
"( sqlite3_file id, u32 op, ref int pArg "
"( sqlite3_file pFd, int eLock "
"( sqlite3_file pFile, int iSize "
"( sqlite3_file pFile, long offset, long length "
"( sqlite3_file pJfd, ref int pSize "
"( sqlite3_file pJfd, sqlite3_int64 size "
"( sqlite3_file pJrnl, byte[] zMaster, u32 nMaster "
"( sqlite3_mprintf( zFormat, ap "
"( sqlite3_pcache p, PgHdr pPg, int reuseUnlikely "
"( sqlite3_pcache p, int nMax "
"( sqlite3_pcache p, u32 iKey, int createFlag "
"( sqlite3_pcache p, u32 iLimit "
"( sqlite3_pcache pCache, PgHdr p2, int discard "
"( sqlite3_pcache pCache, PgHdr p2, u32 oldKey, u32 newKey "
"( sqlite3_pcache pCache, u32 iLimit "
"( sqlite3_pcache pCache, u32 key, int createFlag "
"( sqlite3_stmt p, int i, int iValue "
"( sqlite3_stmt pFromStmt, sqlite3_stmt pToStmt "
"( sqlite3_stmt pStmt, int N "
"( sqlite3_stmt pStmt, int i "
"( sqlite3_stmt pStmt, int i, double rValue "
"( sqlite3_stmt pStmt, int i, int n "
"( sqlite3_stmt pStmt, int i, sqlite3_value pValue "
"( sqlite3_stmt pStmt, int i, sqlite_int64 iValue "
"( sqlite3_stmt pStmt, int op, int resetFlag "
"( sqlite3_stmt pStmt, string zName "
"( sqlite3_temp_directory != """" "
"( sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, 2"
"( sqlite3_test_control(SQLITE_TESTCTRL_ASSERT, 1"
"( sqlite3_value pVal, int enc "
"( sqlite3_vfs pVfs, HANDLE pHandle "
"( sqlite3_vfs pVfs, HANDLE pHdle, ref string zSym "
"( sqlite3_vfs pVfs, int makeDflt "
"( sqlite3_vfs pVfs, int microsec "
"( sqlite3_vfs pVfs, int nBuf, ref byte[] zBuf "
"( sqlite3_vfs pVfs, int nBuf, ref string zBuf "
"( sqlite3_vfs pVfs, int nByte, ref byte[] zBufOut "
"( sqlite3_vfs pVfs, int nByte, ref string zBufOut "
"( sqlite3_vfs pVfs, int nMicro "
"( sqlite3_vfs pVfs, ref double pTimeOut "
"( sqlite3_vfs pVfs, ref double prNow "
"( sqlite3_vfs pVfs, string zPath "
"( sqlite3_vfs pVfs, string zPath, int dirSync "
"( sqlite3_vfs pVfs, string zPath, int flags, ref int pResOut "
"( sqlite3_vfs vfs, HANDLE data "
"( sqlite3_vfs vfs, HANDLE data, string zSymbol "
"( sqlite3_vfs vfs, int microseconds "
"( sqlite3_vfs vfs, int nByte, ref byte[] buffer "
"( sqlite3_vfs vfs, int nByte, ref string zErrMsg "
"( sqlite3_vfs vfs, ref double currenttime "
"( sqlite3_vfs vfs, string zFilename "
"( sqlite3_vfs vfs, string zName, int flags, ref int pResOut "
"( sqlite3_vfs vfs, string zName, int nOut, StringBuilder zOut "
"( sqlite3_vfs vfs, string zName, int syncDir "
"( sqlite3_vfs vfs, string zName, sqlite3_file db, int flags, ref int pOutFlags "
"( sqlite3_vfs_find( """" "
"( sqlite3_vtab pVTab, int p1, sqlite3_value[] p2, sqlite3_int64 p3 "
"( sqlite3_vtab pVTab, ref sqlite3_index_info pIndex "
"( sqlite3_vtab pVTab, ref sqlite3_vtab_cursor ppCursor "
"( sqlite3_vtab pVtab, int nArg, string zName, object pxFunc, ref sqlite3_value[] ppArg "
"( sqlite3_vtab pVtab, string zNew "
"( sqlite3_vtab_cursor pCursor, int idxNum, string idxStr, int argc, sqlite3_value[] argv "
"( sqlite3_vtab_cursor pCursor, sqlite3_context p2, int p3 "
"( sqlite3_vtab_cursor pCursor, sqlite3_int64 pRowid "
"( strcmp(zFilename,"":memory:"""
"( string A, byte[] bB, int Limit "
"( string A, string B, int Limit "
"( string F, params object[] ap "
"( string Key1, int size1, string Key2, int size2 "
"( string T, params object[] ap "
"( string X, object Y "
"( string X, object Y, object Z "
"( string X, object Y, object Z, object A "
"( string X, object Y, object Z, object A, object B "
"( string X, object Y, object Z, object A, object B, object C "
"( string X, object Y, object Z, object A, object B, object C, object D "
"( string X, params object[] ap "
"( string a, int Offset, byte[] b, int Limit "
"( string ac, int offset, int val "
"( string s, u32 offset, ref int v "
"( string s, u32 offset, ref u32 v "
"( string z, Int32 n "
"( string z, int iOffset, int n "
"( string z, int iOffset, ref int tokenType "
"( string z, int iStart, int n "
"( string z, int n "
"( string z, int nKey "
"( string z, ref double pResult "
"( string z, ref int realnum, int enc "
"( string z1, string z2 "
"( string zColl, Index pIndex "
"( string zDate, DateTime p "
"( string zDate, int N, int min, int max, char nextC, ref int pVal "
"( string zDate, int N0, int min0, int max0, char nextC0, ref int pVal0, int N1, int min1, int max1, char nextC1, ref int pVal1 "
"( string zDate, int N0, int min0, int max0, char nextC0, ref int pVal0, int N1, int min1, int max1, char nextC1, ref int pVal1, int N2, int min2, int max2, char nextC2, ref int pVal2 "
"( string zFormat, params  va_list[] ap "
"( string zFormat, params object[] ap "
"( string zFormat, params va_list[] ap "
"( string zIn, int nByte "
"( string zIn, ref int iz "
"( string zLeft, int offsetLeft, string zRight, int N "
"( string zLeft, string zRight "
"( string zLeft, string zRight, int N "
"( string zMod, DateTime p "
"( string zName, i16 nArg, int arg, u8 nc, dxStep xStep, dxFinal xFinal "
"( string zName, i16 nArg, int iArg, u8 bNC, dxFunc xFunc "
"( string zName, i16 nArg, object arg, u8 flags "
"( string zName, int mask "
"( string zName, sbyte nArg, u8 argType, u8 eTextRep, u8 needCollSeq, dxFunc xFunc "
"( string zName, sbyte nArg, u8 argType, u8 needCollSeq, dxStep xStep, dxFinal xFinalize "
"( string zName, u8 enc "
"( string zName, u8 iPrefEnc, i16 nArg, int iArg, u8 iflags, dxFunc xFunc "
"( string zName, u8 iPrefEnc, i16 nArg, int iArg, u8 iflags, dxStep xStep, dxFinal xFinal "
"( string zName, u8 iPrefEnc, i16 nArg, object arg, dxFunc xFunc, u8 flags "
"( string zNum, bool negFlag "
"( string zNum, ref i64 pNum "
"( string zNum, ref int pValue "
"( string.Compare( zNum.Substring( 0, 18 "
"( temp[cbrk], ref data[cbrk], usableSize - cbrk "
"( u32 pgptrmap, u32 pgno "
"( u32 sz, int[] aOp "
"( u8 eDest, char affinity, int iParm "
"( u8 eDest, char affinity, int iParm, int iMem, int nMem "
"( u8 i, u8 nChar, u8 code "
"( u8 opcode, int p1, int p2, int p3 "
"( u8[] p, int offset "
"( u8[] p, int p_offset, int offset "
"( u8[] p, u32 offset "
"( uniondest, priorOp, unionTab "
"( usedAsColumnCache( pParse, inReg, inReg "
"( v, ""%s"", pDestIdx.zName "
"( v, ""%s"", pIdx.zName "
"( v, ""%s"", pIx.zName "
"( v, ""%s"", pSrcIdx.zName "
"( v, ""%s"", pTab.zName "
"( v, ""%s("
"( v, ""%s.%s"", pTab.zName, pCol.zName "
"( v, ""A-eq-B subroutine"" "
"( v, ""A-gt-B subroutine"" "
"( v, ""A-lt-B subroutine"" "
"( v, ""Begin coroutine for left SELECT"" "
"( v, ""Begin coroutine for right SELECT"" "
"( v, ""End coroutine for left SELECT"" "
"( v, ""End coroutine for right SELECT"" "
"( v, ""End of SELECT coroutine"" "
"( v, ""GROUP BY sort"" "
"( v, ""Groupby result generator entry point"" "
"( v, ""Init EXISTS result"" "
"( v, ""Init subquery result"" "
"( v, ""Jump ahead if LIMIT reached"" "
"( v, ""Jump over SELECT coroutine"" "
"( v, ""LIMIT counter"" "
"( v, ""LIMIT+OFFSET"" "
"( v, ""OFFSET counter"" "
"( v, ""Output routine for A"" "
"( v, ""Output routine for B"" "
"( v, ""SELECT eof flag"" "
"( v, ""begin IN expr r%d"", target "
"( v, ""begin trigger %s"", pStepList.pTrig.name "
"( v, ""check abort flag"" "
"( v, ""clear abort flag"" "
"( v, ""end IN expr r%d"", target "
"( v, ""end groupby result generator"" "
"( v, ""end trigger %s"", pStepList.pTrig.name "
"( v, ""eof-A subroutine"" "
"( v, ""eof-B subroutine"" "
"( v, ""indicate accumulator empty"" "
"( v, ""indicate data in accumulator"" "
"( v, ""init LEFT JOIN no-match flag"" "
"( v, ""output final row"" "
"( v, ""output one row"" "
"( v, ""pk"" "
"( v, ""raise(IGNORE"
"( v, ""record LEFT JOIN hit"" "
"( v, ""reset accumulator"" "
"( v, ""set abort flag"" "
"( v, ""skip OFFSET records"" "
"( v, (char*"
"( v, (u8"
"( v, -1 "
"( v, -1, ( pTab.nCol "
"( v, -1, (int"
"( v, -1, 0, 0, 0 "
"( v, -1, encnames[ENC( pParse.db "
"( v, -1, pDest.zName, 0 "
"( v, -1, pExpr.u.zToken, 0 "
"( v, -1, pFunc, P4_FUNCDEF "
"( v, -1, pIdx.zColAff, 0 "
"( v, -1, pKeyInfo, P4_KEYINFO_HANDOFF "
"( v, -1, pTab.zColAff, 0 "
"( v, -1, pTab.zName, P4_STATIC "
"( v, -1, pValue, P4_MEM "
"( v, -1, zMsg, P4_DYNAMIC "
"( v, 0, COLNAME_NAME, ""cache_size"", SQLITE_STATIC "
"( v, 0, COLNAME_NAME, ""cid"", SQLITE_STATIC "
"( v, 0, COLNAME_NAME, ""database"", SQLITE_STATIC "
"( v, 0, COLNAME_NAME, ""encoding"", SQLITE_STATIC "
"( v, 0, COLNAME_NAME, ""id"", SQLITE_STATIC "
"( v, 0, COLNAME_NAME, ""integrity_check"", SQLITE_STATIC "
"( v, 0, COLNAME_NAME, ""journal_mode"", SQLITE_STATIC "
"( v, 0, COLNAME_NAME, ""locking_mode"", SQLITE_STATIC "
"( v, 0, COLNAME_NAME, ""page_count"", SQLITE_STATIC "
"( v, 0, COLNAME_NAME, ""rows deleted"", SQLITE_STATIC "
"( v, 0, COLNAME_NAME, ""rows inserted"", SQLITE_STATIC "
"( v, 0, COLNAME_NAME, ""rows updated"", SQLITE_STATIC "
"( v, 0, COLNAME_NAME, ""seq"", SQLITE_STATIC "
"( v, 0, COLNAME_NAME, ""seqno"", SQLITE_STATIC "
"( v, 0, COLNAME_NAME, zLabel, SQLITE_STATIC "
"( v, 0, COLNAME_NAME, zLeft, SQLITE_TRANSIENT "
"( v, 1 "
"( v, 1, COLNAME_NAME, ""cid"", SQLITE_STATIC "
"( v, 1, COLNAME_NAME, ""name"", SQLITE_STATIC "
"( v, 1, COLNAME_NAME, ""seq"", SQLITE_STATIC "
"( v, 1, COLNAME_NAME, ""status"", SQLITE_STATIC "
"( v, 2 "
"( v, 2, COLNAME_NAME, ""file"", SQLITE_STATIC "
"( v, 2, COLNAME_NAME, ""name"", SQLITE_STATIC "
"( v, 2, COLNAME_NAME, ""table"", SQLITE_STATIC "
"( v, 2, COLNAME_NAME, ""type"", SQLITE_STATIC "
"( v, 2, COLNAME_NAME, ""unique"", SQLITE_STATIC "
"( v, 3 "
"( v, 3, COLNAME_NAME, ""from"", SQLITE_STATIC "
"( v, 3, COLNAME_NAME, ""notnull"", SQLITE_STATIC "
"( v, 4, COLNAME_NAME, ""dflt_value"", SQLITE_STATIC "
"( v, 4, COLNAME_NAME, ""to"", SQLITE_STATIC "
"( v, 5, COLNAME_NAME, ""on_update"", SQLITE_STATIC "
"( v, 5, COLNAME_NAME, ""pk"", SQLITE_STATIC "
"( v, 6 "
"( v, 6, COLNAME_NAME, ""on_delete"", SQLITE_STATIC "
"( v, 7, COLNAME_NAME, ""match"", SQLITE_STATIC "
"( v, 8 "
"( v, ArraySize( cntIdx "
"( v, ArraySize( endCode "
"( v, ArraySize( idxErr "
"( v, ArraySize( setCookie "
"( v, ArraySize( setMeta6 "
"( v, OPFLAG_APPEND "
"( v, OPFLAG_NCHANGE | OPFLAG_LASTROWID | OPFLAG_APPEND "
"( v, OPFLAG_USESEEKRESULT "
"( v, OP_Add, iLimit, iOffset, iOffset + 1 "
"( v, OP_Add, iMem, iMem + i + 1, regTemp "
"( v, OP_AddImm, 1, -1 "
"( v, OP_AddImm, 2, 1 "
"( v, OP_AddImm, iLimit, -1 "
"( v, OP_AddImm, iMem + i + 1, 1 "
"( v, OP_AddImm, iMem, 1 "
"( v, OP_AddImm, memCnt, 1 "
"( v, OP_AddImm, p.iLimit, -1 "
"( v, OP_AddImm, p.iOffset, -1 "
"( v, OP_AddImm, regRowCount, 1 "
"( v, OP_AddImm, regTemp, -1 "
"( v, OP_AddImm, target, -1 "
"( v, OP_Affinity, _base, n "
"( v, OP_And, r3, r4, target "
"( v, OP_AutoCommit, 0, 0 "
"( v, OP_AutoCommit, 1, 0 "
"( v, OP_AutoCommit, 1, 1 "
"( v, OP_Blob, n / 2, target, 0, zBlob, P4_DYNAMIC "
"( v, OP_Clear, pIdx.tnum, iDb "
"( v, OP_Clear, pStat.tnum, iDb "
"( v, OP_Clear, tnum, iDb "
"( v, OP_Close "
"( v, OP_Close, 0 "
"( v, OP_Close, 0, 0 "
"( v, OP_Close, 1 "
"( v, OP_Close, baseCur "
"( v, OP_Close, iCsr "
"( v, OP_Close, iCur "
"( v, OP_Close, iCur + i + 1, 0 "
"( v, OP_Close, iCur + i, pIdx.tnum "
"( v, OP_Close, iCur, 0 "
"( v, OP_Close, iDest, 0 "
"( v, OP_Close, iIdx "
"( v, OP_Close, iIdxCur "
"( v, OP_Close, iSrc, 0 "
"( v, OP_Close, iTab "
"( v, OP_Close, idx + baseCur "
"( v, OP_Close, newIdx, 0 "
"( v, OP_Close, oldIdx, 0 "
"( v, OP_Close, pLevel.iIdxCur "
"( v, OP_Close, pTabItem.iCursor "
"( v, OP_Close, pseudoTab, 0 "
"( v, OP_Close, srcTab "
"( v, OP_Close, tab1, 0 "
"( v, OP_Close, tab2, 0 "
"( v, OP_Close, unionTab, 0 "
"( v, OP_CollSeq, 0, 0, 0, pColl, P4_COLLSEQ "
"( v, OP_Column, 0, 0, iRec "
"( v, OP_Column, 0, 0, memId "
"( v, OP_Column, 0, 1, memId "
"( v, OP_Column, iCur, i, regCols + i "
"( v, OP_Column, iCur, i, regData + i "
"( v, OP_Column, iCur, idx, regBase + j "
"( v, OP_Column, iIdxCur, i, iMem + nCol + i + 1 "
"( v, OP_Column, iIdxCur, i, regCol "
"( v, OP_Column, iIdxCur, nEq, r1 "
"( v, OP_Column, iTab, 0, iReg "
"( v, OP_Column, iTab, pOrderBy.nExpr + 1, regRow "
"( v, OP_Column, pseudoTab, i, pDest.iMem + i "
"( v, OP_Column, sAggInfo.sortingIdx, j, iBMem + j "
"( v, OP_Column, srcTab, i, regResult + i "
"( v, OP_Column, srcTab, j, iRegStore "
"( v, OP_Column, srcTab, j, regCols + i "
"( v, OP_Column, srcTab, keyColumn, regRowid "
"( v, OP_Column, srcTab, keyColumn, regTrigRowid "
"( v, OP_Concat, 4, 3, 2 "
"( v, OP_Concat, regTemp, regF2, regF2 "
"( v, OP_ContextPop, 0, 0 "
"( v, OP_ContextPush, 0, 0 "
"( v, OP_Copy, ( p.iOffset != 0 "
"( v, OP_Copy, inReg, iMem "
"( v, OP_Copy, rNotFound, target "
"( v, OP_Copy, regLimitA, regLimitB "
"( v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem "
"( v, OP_CreateIndex, iDb, iMem "
"( v, OP_CreateTable, iDb, reg2 "
"( v, OP_Delete, iCur, ( count > 0 ? (int"
"( v, OP_Delete, iCur, 0 "
"( v, OP_Delete, pOrderBy.iECursor "
"( v, OP_Destroy, iTable, r1, iDb "
"( v, OP_Divide, iMem + i + 1, regTemp, regTemp "
"( v, OP_DropIndex, iDb, 0, 0, pIndex.zName, 0 "
"( v, OP_DropTable, iDb, 0, 0, pTab.zName, 0 "
"( v, OP_DropTrigger, iDb, 0, 0, pTrigger.name, 0 "
"( v, OP_DropTrigger, iTrigDb, 0, 0, pTrig.name, 0 "
"( v, OP_Eq, memId - 1, 0, iRec "
"( v, OP_Eq, regRowid, 0, regRowid - 1 "
"( v, OP_Expire, ( type == SQLITE_ATTACH "
"( v, OP_Expire, 0 "
"( v, OP_Expire, 0, 0 "
"( v, OP_Expire, 1, 0 "
"( v, OP_Explain, i, pLevel.iFrom, 0, zMsg, P4_DYNAMIC "
"( v, OP_Found, iTab, addrRepeat, r1 "
"( v, OP_Found, j + 2, 0, 3 "
"( v, OP_Found, pExpr.iTable, 0, r2 "
"( v, OP_Found, pExpr.iTable, 0, rMayHaveNull "
"( v, OP_Function, 0, regArgs + 3 - pFunc.nArg, regArgs + 3 "
"( v, OP_Ge, r2, 0, r1 "
"( v, OP_Gosub, pLevel.p1, pLevel.addrFirst "
"( v, OP_Gosub, regAddrA, addrSelectA "
"( v, OP_Gosub, regAddrB, addrSelectB "
"( v, OP_Gosub, regOutA, addrOutA "
"( v, OP_Gosub, regOutB, addrOutB "
"( v, OP_Gosub, regOutputRow, addrOutputRow "
"( v, OP_Gosub, regReset, addrReset "
"( v, OP_Gosub, regReturn, iLoopBody "
"( v, OP_Goto "
"( v, OP_Goto, 0, 0 "
"( v, OP_Goto, 0, addr "
"( v, OP_Goto, 0, addr + 9 "
"( v, OP_Goto, 0, addrCont "
"( v, OP_Goto, 0, addrEnd "
"( v, OP_Goto, 0, addrEofA "
"( v, OP_Goto, 0, addrEofB "
"( v, OP_Goto, 0, addrTop "
"( v, OP_Goto, 0, endLabel "
"( v, OP_Goto, 0, endOfLoop "
"( v, OP_Goto, 0, iBeginAfterTrigger "
"( v, OP_Goto, 0, iBeginBeforeTrigger "
"( v, OP_Goto, 0, iContinue "
"( v, OP_Goto, 0, ignoreDest "
"( v, OP_Goto, 0, labelCmpr "
"( v, OP_Goto, 0, labelEnd "
"( v, OP_Goto, 0, pLevel.addrBrk "
"( v, OP_Goto, 0, pLevel.addrFirst "
"( v, OP_Goto, 0, pParse.cookieGoto "
"( v, OP_Goto, 0, pParse.trigStack.ignoreJump "
"( v, OP_Goto, 0, pWInfo.iBreak "
"( v, OP_Halt "
"( v, OP_Halt, 0, 0 "
"( v, OP_Halt, SQLITE_CONSTRAINT, onError "
"( v, OP_Halt, SQLITE_CONSTRAINT, onError, 0, zErr, 0 "
"( v, OP_Halt, SQLITE_INTERNAL, OE_Abort "
"( v, OP_Halt, SQLITE_OK, 0 "
"( v, OP_IdxDelete, iParm, regResult, nColumn "
"( v, OP_IdxInsert, baseCur + i + 1, aRegIdx[i] "
"( v, OP_IdxInsert, iDest, regData, 1 "
"( v, OP_IdxInsert, iIdx, regRecord "
"( v, OP_IdxInsert, iParm, r1 "
"( v, OP_IdxInsert, iParm, regRowid "
"( v, OP_IdxInsert, iTab, r1 "
"( v, OP_IdxInsert, pDest.iParm, r1 "
"( v, OP_IdxInsert, pExpr.iTable, r2 "
"( v, OP_IdxInsert, pOrderBy.iECursor, regRecord "
"( v, OP_IdxInsert, sAggInfo.sortingIdx, regRecord "
"( v, OP_IdxRowid, iIdxCur, iRowidReg "
"( v, OP_If, iMem "
"( v, OP_If, mem "
"( v, OP_If, r1, dest, jumpIfNull != 0 ? 1 : 0 "
"( v, OP_If, reg3 "
"( v, OP_If, regEof "
"( v, OP_If, regEofA, addrEofA "
"( v, OP_If, regEofA, labelEnd "
"( v, OP_If, regEofB, addrEofB "
"( v, OP_If, regEofB, labelEnd "
"( v, OP_IfNeg, p.iOffset "
"( v, OP_IfNot, iMem "
"( v, OP_IfNot, r1, dest, jumpIfNull != 0 ? 1 : 0 "
"( v, OP_IfNot, regPrev "
"( v, OP_IfPos, 1 "
"( v, OP_IfPos, 1, addr "
"( v, OP_IfPos, 2, 0 "
"( v, OP_IfPos, iAbortFlag, addrEnd "
"( v, OP_IfPos, iLimit "
"( v, OP_IfPos, iOffset "
"( v, OP_IfPos, iUseFlag, addrOutputRow + 2 "
"( v, OP_IfPos, pLevel.iLeftJoin "
"( v, OP_IfZero, iLimit "
"( v, OP_IfZero, iLimit, iBreak "
"( v, OP_IfZero, p.iLimit "
"( v, OP_IfZero, p.iLimit, iBreak "
"( v, OP_IncrVacuum, iDb "
"( v, OP_Insert, 0, iRec, memId + 1 "
"( v, OP_Insert, 0, reg3, reg1 "
"( v, OP_Insert, baseCur, regRec, regRowid "
"( v, OP_Insert, iDest, regData, regRowid "
"( v, OP_Insert, iParm, r1, r2 "
"( v, OP_Insert, iParm, regRow, regRowid "
"( v, OP_Insert, iStatCur, regRec, regRowid "
"( v, OP_Insert, newIdx, regRec, regRowid "
"( v, OP_Insert, newIdx, regRec, regTrigRowid "
"( v, OP_Insert, newIdx, regRow, regRowid "
"( v, OP_Insert, oldIdx, iData, iRowid "
"( v, OP_Insert, oldIdx, regRow, regRowid "
"( v, OP_Insert, pDest.iParm, r1, r2 "
"( v, OP_Insert, pExpr.iTable, r2, r3 "
"( v, OP_Insert, pseudoTab, regRow, regRowid "
"( v, OP_Insert, srcTab, regRec, regTempRowid "
"( v, OP_Int64, 0, iMem, 0, value, P4_INT64 "
"( v, OP_Int64, 0, iMem, 0, zV, P4_INT64 "
"( v, OP_Int64, 0, mem, 0, (char*"
"( v, OP_Int64, 0, mem, 0, value, P4_INT64 "
"( v, OP_Integer, ( pCol.notNull != 0 ? 1 : 0 "
"( v, OP_Integer, ( pIdx.onError != OE_None "
"( v, OP_Integer, -1, iOffset + 1 "
"( v, OP_Integer, -1, regTrigRowid "
"( v, OP_Integer, -size, 1 "
"( v, OP_Integer, 0, 2 "
"( v, OP_Integer, 0, dest.iParm "
"( v, OP_Integer, 0, iAbortFlag "
"( v, OP_Integer, 0, iMem + i "
"( v, OP_Integer, 0, iOffset "
"( v, OP_Integer, 0, iUseFlag "
"( v, OP_Integer, 0, memCnt "
"( v, OP_Integer, 0, memId "
"( v, OP_Integer, 0, pLevel.iLeftJoin "
"( v, OP_Integer, 0, r1 "
"( v, OP_Integer, 0, rNotFound "
"( v, OP_Integer, 0, reg2 "
"( v, OP_Integer, 0, regEof "
"( v, OP_Integer, 0, regEofA "
"( v, OP_Integer, 0, regEofB "
"( v, OP_Integer, 0, regPrev "
"( v, OP_Integer, 0, regReturn "
"( v, OP_Integer, 0, regRowCount "
"( v, OP_Integer, 0, target "
"( v, OP_Integer, 1, iAbortFlag "
"( v, OP_Integer, 1, iMem "
"( v, OP_Integer, 1, iParm "
"( v, OP_Integer, 1, iUseFlag "
"( v, OP_Integer, 1, mem "
"( v, OP_Integer, 1, pLevel.iLeftJoin "
"( v, OP_Integer, 1, regEof "
"( v, OP_Integer, 1, regEofA "
"( v, OP_Integer, 1, regEofB "
"( v, OP_Integer, 1, regPrev "
"( v, OP_Integer, 1, regRowid "
"( v, OP_Integer, 1, target "
"( v, OP_Integer, ENC( db "
"( v, OP_Integer, addrSelect - 1, dest.iParm "
"( v, OP_Integer, cnum, 2 "
"( v, OP_Integer, db.aDb[iDb].pSchema.schema_cookie + 1, r1 "
"( v, OP_Integer, fileFormat, reg3 "
"( v, OP_Integer, i - nHidden, 1 "
"( v, OP_Integer, i++, 1 "
"( v, OP_Integer, i, 1 "
"( v, OP_Integer, i, iMem "
"( v, OP_Integer, iLimit, 1 "
"( v, OP_Integer, j - 1, iReg + 1 "
"( v, OP_Integer, j, 2 "
"( v, OP_Integer, minFormat, r2 "
"( v, OP_Integer, mxErr, 1 "
"( v, OP_Integer, pCol.isPrimKey != 0 ? 1 : 0, 6 "
"( v, OP_Integer, pIdx.tnum, 2 + cnt "
"( v, OP_Integer, pTab.tnum, 2 + cnt "
"( v, OP_Integer, pVtabIdx.idxNum, iReg "
"( v, OP_Integer, size, 1 "
"( v, OP_IntegrityCk, 2, cnt, 1 "
"( v, OP_IsNull, 2 "
"( v, OP_IsNull, iReg "
"( v, OP_IsNull, r1, addrCont "
"( v, OP_IsNull, regBase + j, pLevel.addrBrk "
"( v, OP_IsNull, regBase + nEq, addrNxt "
"( v, OP_IsNull, regData + i, ignoreDest "
"( v, OP_IsNull, regRowid, j1 + 2 "
"( v, OP_IsNull, target "
"( v, OP_IsUnique, iIdx, j2, regRowid, pRegKey, P4_INT32 "
"( v, OP_Jump, addrAltB, addrAeqB, addrAgtB "
"( v, OP_Jump, j1 + 1, 0, j1 + 1 "
"( v, OP_Jump, j2 + 2, iContinue, j2 + 2 "
"( v, OP_Last, pOrderBy.iECursor "
"( v, OP_LoadAnalysis, iDb "
"( v, OP_MakeRecord, iMem, N, r1 "
"( v, OP_MakeRecord, memId - 1, 2, iRec "
"( v, OP_MakeRecord, pIn.iMem, 1, r1, p.affinity, 1 "
"( v, OP_MakeRecord, pIn.iMem, pIn.nMem, r1 "
"( v, OP_MakeRecord, r3, 1, r2, affinity, 1 "
"( v, OP_MakeRecord, regBase, nCol + 1, regOut "
"( v, OP_MakeRecord, regBase, nCol, regRecord "
"( v, OP_MakeRecord, regBase, nExpr + 2, regRecord "
"( v, OP_MakeRecord, regCols, pTab.nCol, regRec "
"( v, OP_MakeRecord, regCols, pTab.nCol, regRow "
"( v, OP_MakeRecord, regData, pTab.nCol, regRec "
"( v, OP_MakeRecord, regFields, 3, regRec, new byte[] { (byte"
"( v, OP_MakeRecord, regFromSelect, nColumn, regRec "
"( v, OP_MakeRecord, regIdx, pIdx.nColumn + 1, aRegIdx[iCur] "
"( v, OP_MakeRecord, regResult, 1, r1, p.affinity, 1 "
"( v, OP_MakeRecord, regResult, nColumn, r1 "
"( v, OP_MakeRecord, regRow, 1, regRowid, p.affinity, 1 "
"( v, OP_MakeRecord, target, 1, r2, affinity, 1 "
"( v, OP_Move, 2, 4, 1 "
"( v, OP_MustBeInt, iLimit "
"( v, OP_MustBeInt, iOffset "
"( v, OP_MustBeInt, iRowidReg, addrNxt "
"( v, OP_MustBeInt, r3, sqlite3VdbeCurrentAddr( v "
"( v, OP_MustBeInt, regNewRowid "
"( v, OP_MustBeInt, regRowid "
"( v, OP_MustBeInt, regTrigRowid "
"( v, OP_MustBeInt, target "
"( v, OP_Ne, memId - 1, addr + 7, memId "
"( v, OP_Ne, regCol, 0, iMem + nCol + i + 1 "
"( v, OP_NewRowid, 0, memId + 1 "
"( v, OP_NewRowid, 0, reg1 "
"( v, OP_NewRowid, baseCur, regRowid, regAutoinc "
"( v, OP_NewRowid, iDest, regRowid "
"( v, OP_NewRowid, iParm, r2 "
"( v, OP_NewRowid, iParm, regRowid "
"( v, OP_NewRowid, iStatCur, regRowid "
"( v, OP_NewRowid, pDest.iParm, r2 "
"( v, OP_NewRowid, srcTab, regTempRowid "
"( v, OP_Next, 0, addr + 2 "
"( v, OP_Next, 0, j3 "
"( v, OP_Next, 1, loopTop + 1 "
"( v, OP_Next, iIdxCur, topOfLoop "
"( v, OP_Next, iSrc, addr1 "
"( v, OP_Next, iSrc, addr1 + 1 "
"( v, OP_Next, iTab, addr "
"( v, OP_Next, iTab, addr1 + 1 "
"( v, OP_Next, pIn.iCur, pIn.addrInTop "
"( v, OP_Next, sAggInfo.sortingIdx, addrTopOfLoop "
"( v, OP_Next, srcTab, addrCont "
"( v, OP_Next, tab1, iStart "
"( v, OP_Next, unionTab, iStart "
"( v, OP_NotExists, baseCur, 0, regRowid "
"( v, OP_NotExists, iCur, 0, iRowid "
"( v, OP_NotExists, iCur, 0, regOldRowid "
"( v, OP_NotExists, iCur, addr, iRowid "
"( v, OP_NotExists, iCur, addr, regOldRowid "
"( v, OP_NotExists, iCur, addrNxt, iRowidReg "
"( v, OP_NotExists, iDest, 0, regRowid "
"( v, OP_NotExists, pExpr.iTable, 0, target "
"( v, OP_NotFound, tab2, iCont, r1 "
"( v, OP_NotNull, memId + 1 "
"( v, OP_NotNull, rMayHaveNull "
"( v, OP_NotNull, regData + i "
"( v, OP_NotNull, regOldRowid "
"( v, OP_NotNull, regRowid "
"( v, OP_NotNull, regTrigRowid "
"( v, OP_Null, 0, 5 "
"( v, OP_Null, 0, dest.iParm "
"( v, OP_Null, 0, iData "
"( v, OP_Null, 0, iMem "
"( v, OP_Null, 0, iMem + nCol + i + 1 "
"( v, OP_Null, 0, iReg "
"( v, OP_Null, 0, iRegStore "
"( v, OP_Null, 0, iRowSet "
"( v, OP_Null, 0, pAggInfo.aCol[i].iMem "
"( v, OP_Null, 0, pFunc.iMem "
"( v, OP_Null, 0, r2 "
"( v, OP_Null, 0, rMayHaveNull "
"( v, OP_Null, 0, rNotFound "
"( v, OP_Null, 0, reg3 "
"( v, OP_Null, 0, regBase + nEq "
"( v, OP_Null, 0, regCols + i "
"( v, OP_Null, 0, regData + i "
"( v, OP_Null, 0, regIns "
"( v, OP_Null, 0, regOldRowid "
"( v, OP_Null, 0, regRow "
"( v, OP_Null, 0, regRowid "
"( v, OP_Null, 0, regRowset "
"( v, OP_Null, 0, target "
"( v, OP_NullRow, pLevel.iIdxCur "
"( v, OP_NullRow, pTabList.a[i].iCursor "
"( v, OP_OpenEphemeral, (int"
"( v, OP_OpenEphemeral, dest.iParm, p.pEList.nExpr "
"( v, OP_OpenEphemeral, pDest.iParm, pEList.nExpr "
"( v, OP_OpenEphemeral, srcTab, nColumn "
"( v, OP_OpenEphemeral, tab1, 0 "
"( v, OP_OpenEphemeral, tab2, 0 "
"( v, OP_OpenEphemeral, unionTab, 0 "
"( v, OP_OpenPseudo, newIdx, 0, pTab.nCol "
"( v, OP_OpenPseudo, oldIdx, 0, pTab.nCol "
"( v, OP_OpenPseudo, pseudoTab, eDest == SRT_Output ? 1 : 0, nColumn "
"( v, OP_OpenRead, iCsr, iRoot, iDb "
"( v, OP_OpenWrite, 0, MASTER_ROOT, iDb "
"( v, OP_OpenWrite, 1, pParse.regRoot, iDb "
"( v, OP_OpenWrite, iStatCur, iRootPage, iDb "
"( v, OP_Pagecount, iDb, iReg "
"( v, OP_ParseSchema, 1, 0, 0, zWhere, P4_DYNAMIC "
"( v, OP_ParseSchema, iDb, 0, 0, zWhere, P4_DYNAMIC "
"( v, OP_Permutation, 0, 0, 0, aPermute, P4_INTARRAY "
"( v, OP_ReadCookie, iDb, 2, BTREE_DEFAULT_CACHE_SIZE "
"( v, OP_ReadCookie, iDb, r1, BTREE_FILE_FORMAT "
"( v, OP_ReadCookie, iDb, reg3, BTREE_FILE_FORMAT "
"( v, OP_Real, 0, iMem, 0, value, P4_REAL "
"( v, OP_RealAffinity, iReg "
"( v, OP_ResetCount, 0, 0 "
"( v, OP_ResetCount, 1, 0 "
"( v, OP_ResultRow, 1 "
"( v, OP_ResultRow, 1, 1 "
"( v, OP_ResultRow, 1, 2 "
"( v, OP_ResultRow, 1, 3 "
"( v, OP_ResultRow, 1, 6 "
"( v, OP_ResultRow, 1, 8 "
"( v, OP_ResultRow, 2, 1 "
"( v, OP_ResultRow, iReg, 1 "
"( v, OP_ResultRow, mem, 1 "
"( v, OP_ResultRow, memCnt, 1 "
"( v, OP_ResultRow, pDest.iMem, nColumn "
"( v, OP_ResultRow, pIn.iMem, pIn.nMem "
"( v, OP_ResultRow, regResult, nColumn "
"( v, OP_ResultRow, regRowCount, 1 "
"( v, OP_Return, regOutputRow "
"( v, OP_Return, regReset "
"( v, OP_Return, regReturn "
"( v, OP_Rewind "
"( v, OP_Rewind, 0, addr + 9 "
"( v, OP_Rewind, 1, 0 "
"( v, OP_Rewind, iDest, 0 "
"( v, OP_Rewind, iIdxCur, endOfLoop "
"( v, OP_Rewind, iSrc, 0 "
"( v, OP_Rewind, iTab, 0 "
"( v, OP_Rewind, srcTab "
"( v, OP_Rewind, tab1, iBreak "
"( v, OP_Rewind, unionTab, iBreak "
"( v, OP_RowData, iCur, iData "
"( v, OP_RowData, iCur, regRow "
"( v, OP_RowData, iSrc, regData "
"( v, OP_RowKey, iSrc, regData "
"( v, OP_RowKey, tab1, r1 "
"( v, OP_RowSetAdd, iRowSet, regRowid "
"( v, OP_RowSetAdd, regRowSet, regOldRowid "
"( v, OP_RowSetRead, iRowSet, end, iRowid "
"( v, OP_RowSetRead, regRowSet, 0, regOldRowid "
"( v, OP_Rowid, 0, memId + 1 "
"( v, OP_Rowid, iCur, iRowidReg "
"( v, OP_Rowid, iCur, regBase + nCol "
"( v, OP_Rowid, iCur, regOldRowid "
"( v, OP_Rowid, iCur, regRowid "
"( v, OP_Rowid, iSrc, regRowid "
"( v, OP_Rowid, iTab, iReg "
"( v, OP_Rowid, iTable, iReg "
"( v, OP_SCopy, iMem, regF2 "
"( v, OP_SCopy, iReg, target + i "
"( v, OP_SCopy, inReg, target "
"( v, OP_SCopy, r1, regBase + j "
"( v, OP_SCopy, r2, r1 "
"( v, OP_SCopy, regBase + nCol, regBase + j "
"( v, OP_SCopy, regData + idx, regIdx + i "
"( v, OP_SCopy, regFromSelect + j, iRegStore "
"( v, OP_SCopy, regFromSelect + keyColumn, regRowid "
"( v, OP_SCopy, regRowid - ( hasTwoRowids ? 1 : 0 "
"( v, OP_SCopy, regRowid, regIdx + i "
"( v, OP_Savepoint, op, 0, 0, zName, P4_DYNAMIC "
"( v, OP_Seek, iCur, iRowidReg "
"( v, OP_Sequence, pOrderBy.iECursor, regBase + nExpr "
"( v, OP_Sequence, sAggInfo.sortingIdx, regBase + nGroupBy "
"( v, OP_SetCookie, iDb, BTREE_DEFAULT_CACHE_SIZE, 1 "
"( v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, r2 "
"( v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, reg3 "
"( v, OP_SetCookie, iDb, BTREE_SCHEMA_VERSION, r1 "
"( v, OP_SetCookie, iDb, BTREE_TEXT_ENCODING, reg3 "
"( v, OP_Sort, iTab, addrBreak "
"( v, OP_Sort, sAggInfo.sortingIdx, addrEnd "
"( v, OP_String8, 0, 1 "
"( v, OP_String8, 0, 1, 0, db.aDb[i].zName, P4_STATIC "
"( v, OP_String8, 0, 1, 0, proxy_file_path, 0 "
"( v, OP_String8, 0, 1, 0, sqlite3_temp_directory, 0 "
"( v, OP_String8, 0, 1, 0, zRet, 0 "
"( v, OP_String8, 0, 2, 0, db.aDb[i].zName, 0 "
"( v, OP_String8, 0, 2, 0, pCol.zName, 0 "
"( v, OP_String8, 0, 2, 0, pColl.zName, 0 "
"( v, OP_String8, 0, 2, 0, pIdx.zName, 0 "
"( v, OP_String8, 0, 2, 0, zState, P4_STATIC "
"( v, OP_String8, 0, 3, 0, pFK.zTo, 0 "
"( v, OP_String8, 0, 3, 0, pTab.aCol[cnum].zName, 0 "
"( v, OP_String8, 0, 5, 0, pCol.zDflt, 0 "
"( v, OP_String8, 0, 6, 0, zOnUpdate, 0 "
"( v, OP_String8, 0, 7, 0, zOnDelete, 0 "
"( v, OP_String8, 0, 8, 0, ""NONE"", 0 "
"( v, OP_String8, 0, i, 0, zName, 0 "
"( v, OP_String8, 0, memId - 1, 0, p.pTab.zName, 0 "
"( v, OP_String8, 0, regFields + 1, 0, pIdx.zName, 0 "
"( v, OP_String8, 0, regFields, 0, pTab.zName, 0 "
"( v, OP_String8, 0, regTemp, 0, ' ', 0 "
"( v, OP_String8, 0, target, 0, pExpr.u.zToken, 0 "
"( v, OP_Subtract, r2, r1, target "
"( v, OP_ToInt, regTemp "
"( v, OP_Trace "
"( v, OP_Transaction, i, ( type == TK_EXCLUSIVE "
"( v, OP_Transaction, iDb, ( mask & pParse.writeMask "
"( v, OP_VBegin "
"( v, OP_VDestroy, iDb, 0, 0, pTab.zName, 0 "
"( v, OP_VRename, i, 0, 0, pVtab, P4_VTAB "
"( v, OP_Vacuum, 0, 0 "
"( v, OP_Variable, pExpr.iTable, target, 1 "
"( v, OP_VerifyCookie, iDb, pParse.cookieValue[iDb] "
"( v, OP_Yield, dest.iParm "
"( v, OP_Yield, pDest.iParm "
"( v, OP_Yield, regAddrA "
"( v, OP_Yield, regAddrB "
"( v, SQLITE_AFF_NUMERIC | SQLITE_JUMPIFNULL "
"( v, SQLITE_JUMPIFNULL "
"( v, _base + 1, pTrigger.name, 0 "
"( v, _base + 4, ""trigger"", P4_STATIC "
"( v, a1 "
"( v, aMoveOp[pX.op - TK_GT], iCur, addrBrk, r1 "
"( v, aStart[bRev], iCur, addrBrk "
"( v, addr "
"( v, addr + 1 "
"( v, addr + 1, ""rowid "", SQLITE_STATIC "
"( v, addr + 1, addr + 4 "
"( v, addr + 1, atoi( zRight "
"( v, addr + 1, iCookie "
"( v, addr + 1, iDb "
"( v, addr + 1, j + 2 "
"( v, addr + 2, ""ok"", P4_STATIC "
"( v, addr + 2, iCookie "
"( v, addr + 2, iDb "
"( v, addr + 3, "" missing from index "", SQLITE_STATIC "
"( v, addr + 3, addr + 2 "
"( v, addr + 3, j + 2 "
"( v, addr + 4 "
"( v, addr + 4, pIdx.zName, P4_STATIC "
"( v, addr + 6, SQLITE_DEFAULT_CACHE_SIZE "
"( v, addr + 7, pIdx.zName, P4_STATIC "
"( v, addr + 9 "
"( v, addr, -mxErr "
"( v, addr, iDb "
"( v, addr, keyInfo, P4_KEYINFO "
"( v, addr, nCol "
"( v, addr, pKeyInfo, P4_KEYINFO "
"( v, addr1 "
"( v, addr2 "
"( v, addrBreak "
"( v, addrContinue "
"( v, addrEnd "
"( v, addrIf "
"( v, addrInsTop "
"( v, addrNext "
"( v, addrOutputRow "
"( v, addrReset "
"( v, addrSortIndex, 1 "
"( v, addrSortingIdx, 1 "
"( v, allOk "
"( v, bRev != 0 ? OP_Last : OP_Rewind, iCur, addrBrk "
"( v, createStat1 "
"( v, d2 "
"( v, dropTrigger.Length, dropTrigger "
"( v, emptyDestTest "
"( v, emptySrcTest "
"( v, end "
"( v, endLabel "
"( v, endOfLoop "
"( v, getCacheSize.Length, getCacheSize "
"( v, i "
"( v, i, COLNAME_DECLTYPE, zType, SQLITE_TRANSIENT "
"( v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT "
"( v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC "
"( v, i, COLNAME_NAME, zName, SQLITE_TRANSIENT "
"( v, iAddr "
"( v, iAddr + 1, iDb "
"( v, iAddr + 2, iAddr + 4 "
"( v, iAddr + 4, eAuto - 1 "
"( v, iAddr + 5, iDb "
"( v, iAddr, iDb "
"( v, iBreak "
"( v, iCont "
"( v, iContinue "
"( v, iDb "
"( v, iEnd "
"( v, iEndAfterTrigger "
"( v, iEndBeforeTrigger "
"( v, iGoto "
"( v, iLoopBody "
"( v, iRetInit, sqlite3VdbeCurrentAddr( v "
"( v, j1 "
"( v, j2 "
"( v, j3 "
"( v, j4 "
"( v, j5 "
"( v, jmp2 "
"( v, k "
"( v, labelCmpr "
"( v, labelEnd "
"( v, loopTop "
"( v, nextCase "
"( v, op, iTable, iColumn, iReg "
"( v, op, r1 "
"( v, op, r1, dest "
"( v, op, r1, inReg "
"( v, op, r2, r1, target "
"( v, opcode, iCur, pTab.tnum, iDb "
"( v, p, addrContinue "
"( v, p, iContinue "
"( v, pEList.nExpr "
"( v, pExpr, false, target "
"( v, pExpr.u.zToken, false, target "
"( v, pIdx "
"( v, pIn.addrInTop + 1 "
"( v, pIn.addrInTop - 1 "
"( v, pLeft, true, target "
"( v, pLeft.u.zToken, true, target "
"( v, pLevel.addrBrk "
"( v, pLevel.addrCont "
"( v, pLevel.addrNxt "
"( v, pLevel.op, pLevel.p1, pLevel.p2 "
"( v, pLevel.p5 "
"( v, pParse.cookieGoto - 1 "
"( v, pTab "
"( v, pTab, i, -1 "
"( v, pTab, i, regData + i "
"( v, pTab, iColumn, iReg "
"( v, pTab, idx, -1 "
"( v, pWInfo.iBreak "
"( v, pWInfo.iTop "
"( v, pik_flags "
"( v, readCookie.Length, readCookie "
"( v, sqlite3VdbeCurrentAddr( v "
"( v, testAddr - 1 "
"( v, testAddr - 1, 2 "
"( v, testOp, memEndValue, addrBrk, iRowidReg "
"( v, to_op, inReg "
"( v, topOfLoop + 2 * ( i + 1 "
"( v, trace "
"( v, z, n, enc, xDel "
"( v, z, negFlag, iMem "
"( v, zCol != null ? OP_String8 : OP_Null, 0, 5, 0, zCol, 0 "
"( v, zFormat, ap "
"( v.db, rc "
"( v.db, ref v "
"( vm, i "
"( vm, index "
"( void_function xBenignBegin, void_function xBenignEnd "
"( vtabBestIndex(pParse, pTab, pIdxInfo"
"( w, p "
"( w, pSelect "
"( w, ref p "
"( w, ref pExpr "
"( winVfs, 1 "
"( xBenignBegin, xBenignEnd "
"( xCallback( pArg, nCol, azVals, azCols "
"( xCallback, pArg, iThreshold "
"( xInit != null && xInit( db, ref zErrmsg, (sqlite3_api_routines"
"( xInit(db, ref zErrmsg, sqlite3Apis"
"( xferCompatibleIndex( pDestIdx, pSrcIdx "
"( z != """" && p1 != 0 "
"( z == """" "
"( z == null || z == """" "
"( z, 0, n "
"( z, 0, pMem.z, 0, (int"
"( z, iOffset, i "
"( z, p "
"( z, pName.z, pName.n "
"( z, pTo.z, pTo.n "
"( z, pToCol.a[i].zName, n "
"( z, ref iz "
"( z, ref r "
"( z, ref value "
"( z.Substring( 0, N <= z.Length ? N : z.Length "
"( z1 != z2 && sqlite3StrICmp( z1, z2 "
"( z1, z2 "
"( z1, z2, n + 1 "
"( z2 = z ; z2 != """" && p2 != 0 ; p2-- "
"( z2 = z ; z2 != """" ; len++ "
"( zAlloc, p, nNewSize "
"( zAlloc, p, nSize "
"( zAs != null && sqlite3StrICmp( zAs, zCol "
"( zBuf, 0, n "
"( zBuf, 0, nBuf "
"( zBuf, n, (u32"
"( zBuf, ref r "
"( zBytes, iz0, azChar[ii], 0, azChar[ii].Length "
"( zBytes, ref iz "
"( zBytes, ref iz1 "
"( zColl == null || collationMatch( zColl, pIndex "
"( zColl.Substring( 0, nColl "
"( zConverted == null || zConverted == """" "
"( zConverted, 0, 0, 0"
"( zConverted, dwCreationDisposition, dwDesiredAccess, dwShareMode, 1024, dwFlagsAndAttributes "
"( zConverted, nByte, zTemp, 0"
"( zCsr, len "
"( zData, aType[p2], pDest "
"( zData, offset, pMem.zBLOB, 0, amt "
"( zData, ref  offset "
"( zData, zIdx, ref aType[i] "
"( zDatabase != null && sqlite3StrICmp( zDatabase, db.aDb[j].zName "
"( zDate + '\0', N0, min0, max0, nextC0, ref  pVal0 "
"( zDate, ref r "
"( zDate1 + '\0', N1, min1, max1, nextC1, ref  pVal1 "
"( zDb != null && sqlite3StrICmp( db.aDb[iDb].zName, zDb "
"( zDb != null && sqlite3StrICmp( db.aDb[j].zName, zDb "
"( zDb != null && sqlite3StrICmp( zDb, db.aDb[j].zName "
"( zErrDyn != """" "
"( zErrDyn == """" "
"( zErrMsg != """" "
"( zEsc, ref zEsc "
"( zExternal!="""" "
"( zExtra, zColl, nColl "
"( zFile != null && sqlite3_load_extension( db, zFile, zProc, ref zErrMsg "
"( zFilename == "":memory:"" "
"( zFilename, db, ref ppBtree, btFlags, vfsFlags "
"( zFormat, ap "
"( zHeader, 0 "
"( zHeader, aJournalMagic.Length + 12, pPager.sectorSize "
"( zHeader, aJournalMagic.Length + 16, (u32"
"( zHeader, aJournalMagic.Length + 20, (int"
"( zHeader, aJournalMagic.Length + 4, pPager.cksumInit "
"( zHeader, aJournalMagic.Length + 8, pPager.dbOrigSize "
"( zHeader, aJournalMagic.Length, 0 "
"( zHeader, aJournalMagic.Length, 0xffffffff "
"( zHeader, aJournalMagic.Length, pPager.nRec "
"( zIdent, j "
"( zIdent[j] == '""' "
"( zIn.Contains( ""blob"" "
"( zIn.Contains( ""char"" "
"( zIn.Contains( ""doub"" "
"( zIn.Contains( ""int"" "
"( zLeft == """" "
"( zLeft == ""journal_mode"" "
"( zLeft == ""page_count"" "
"( zLeft, ""freelist_count"" "
"( zLeft, ""quick_check"" "
"( zLeft, ""user_version"" "
"( zMasterPtr, zMaster "
"( zName != null && zName != """" "
"( zName == """" "
"( zName == null || SQLITE_OK != sqlite3CheckObjectName( pParse, zName "
"( zName, ""sqlite_"", 7 "
"( zName, SQLITE_UTF8, nArg, arg, (u8"
"( zName, SQLITE_UTF8, nArg, arg, likeFunc, flags "
"( zName, SQLITE_UTF8, nArg, iArg, (u8"
"( zNew, p.zText, p.nChar "
"( zNewRecord, i, (int"
"( zNewRecord, nHdr "
"( zNum, ""922337203685477580"" "
"( zNum, out pNum "
"( zNum.Substring( 0, i "
"( zOut, pChunk.zChunk[iChunkOffset], nCopy "
"( zOut, zIn, nCopy "
"( zPattern == """" "
"( zPattern, ref zPattern "
"( zPattern, zRep "
"( zProc == null || zProc == """" "
"( zRec, (int"
"( zRight !="""""
"( zRight && (sqlite3StrICmp(zLeft, ""hexkey"""
"( zRight == null || !sqlite3GetInt32( zRight, ref iLimit "
"( zRight, ref iLimit "
"( zSql != """" "
"( zSql, i, ref tokenType "
"( zSql, zCsr, ref token "
"( zSql.Length <= i ? """" : zSql.Substring( i, zSql.Length - i "
"( zSql8 !="""""
"( zSql=="""" "
"( zSrcData, (int"
"( zStmt, ref k, p.zName "
"( zStmt, ref k, pCol.zName "
"( zStr[i]!=zPattern[0] || memcmp(&zStr[i], zPattern, nPattern"
"( zString, ref len "
"( zString, ref zString "
"( zTName != null && sqlite3StrICmp( zTName, zTabName "
"( zTabName, -1 "
"( zTabName, zTab "
"( zTail8 !="""" && pzTail !="""""
"( zTempFilename, 1, FileOptions.DeleteOnClose "
"( zToken, p.u.zToken, nToken "
"( zType != null && sqlite3StrICmp( zType, ""INTEGER"" "
"( zVfs == null || zVfs == """" "
"( zWhere == """" "
"( zWrite, izWrite, p.endpoint.pChunk.zChunk, iChunkOffset, iSpace "
"( z[8], ref r "
"(!AdjustTokenPrivileges(hToken, false, ref tp, (UInt32"
"(!DuplicateToken(hToken, 2, ref DuplicatedToken"
"(!LookupPrivilegeValue(null, Privilege, out luid"
"(!OpenProcessToken(hProcess, TOKEN_IMPERSONATE | TOKEN_DUPLICATE, out hToken"
"(!OpenProcessToken(hProcess, TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, out hToken"
"(!OpenProcessToken(hProcess, TOKEN_QUERY, out hToken"
"(!PTRMAP_ISPAGE(pBt, iLastPg"
"(!PrivilegeCheck(hToken, ref privs, out ret"
"(!ReadFile(pFile.fs.Name, pBuf, amt, got, 0"
"(!SetThreadToken(IntPtr.Zero, DuplicatedToken"
"(!SystemTimeToFileTime(&time,&ft"
"(!hasReadConflicts(p, pCur.pgnoRoot"
"("""""
"(""%.78'-"""
"(""%.78c"",'-'"
"(""%s"", colv[i]"
"(""%s"",res.zErrMsg"
"(""--- IE/Edge Credential ---"""
"(""1.0.0.0"""
"(""2133c634-4139-466e-8983-9a23ec99e01b"""
"(""9223372036854775800"""
"("":SS.FFF"""
"(""=="" or ""IN"" operators"
"(""===============Chrome============="""
"(""===============IE============="""
"(""ALLOCATE: %d from end of file (pointer-map page"
"(""ALLOCATE: %d from end of file\n"", pPgno"
"(""ALLOCATE: %d trunk - %d free pages left\n"", pPgno, n - 1"
"(""AUTOVACUUM: Moving %d to free page %d (ptr page %d type %d"
"(""B"""
"(""BALANCE: begin page %d child of %d\n"", pPage.pgno, pParent.pgno"
"(""BALANCE: copy root %d into %d\n"", pRoot.pgno, pChild.pgno"
"(""BCrypt.BCryptDecrypt("
"(""BrowserGhost is a Chrome, Firefox and Edge data harvestor."""
"(""BrowserGhost"""
"(""Error occured while retrieving vault item. Error: 0x"" + result.ToString("
"(""FREE-PAGE: %d leaf on trunk page %d\n"", iPage, pTrunk.pgno"
"(""FREE-PAGE: %d new trunk page replacing %d\n"", pPage.pgno, iTrunk"
"(""GetOwner"""
"(""GetOwner"", inPar, null"
"(""INSERT INTO table VALUES(%Q"
"(""INSERT INTO table VALUES('%q'"
"(""PTRMAP_UPDATE: %d->(%d,%d"
"(""Recomputing index info for %s...\n"", pSrc.pTab.zName"
"(""Select * from Win32_Process WHERE processID="" + pID"
"(""Software\\Microsoft\\Internet Explorer\\TypedURLs"""
"(""Unable to open the following vault: "" + vaultType + "". Error: 0x"" + result.ToString("
"(""[*] Current user {0}"", Environment.UserName"
"(""[*] Impersonate user {0}"", Environment.UserName"
"(""[*] Recvtoself"""
"(""[*] [{0}] [{1}] [{2}]"", pid, processname, process_of_user"
"(""[+] Current user {0}"", Environment.UserName"
"(""[-] {0} Not Found!"", chrome_History_path"
"(""[-] {0} Not Found!"", chrome_book_path"
"(""[-] {0} Not Found!"", chrome_cookie_path"
"(""[-] {0} Not Found!"", login_data_path"
"(""[ERROR] Unable to enumerate vault items from the following vault: "" + vaultType + "". Error 0x"" + result.ToString("
"(""[ERROR] Unable to enumerate vaults. Error (0x"" + result.ToString("
"(""\""encrypted_key\"":\""(.*?"
"(""\n[*]Get Chrome Bookmarks"""
"(""\n[*]Get Chrome Cookie"""
"(""\n[*]Get Chrome History"""
"(""\n[*]Get Chrome Login Data"""
"(""\n[*]Get IE Books"""
"(""\n[*]Get IE History"""
"(""\n[*]Get IE Password"""
"(""\r\n\r\n=== Checking Windows Vaults ===\r\n"""
"(""\t"" + url_file_path"
"(""\tCredential   : {0}"", cred"
"(""\tIdentity     : {0}"", identity"
"(""\tLastModified : {0}"", System.DateTime.FromFileTimeUtc((long"
"(""\tPacakgeSid  : {0}"", packageSid"
"(""\tResource     : {0}"", resource"
"(""\tVault Type   : {0}"", vaultType"
"(""\t[+] Copy {0} to {1}"", chrome_History_path, cookie_tempFile"
"(""\t[+] Copy {0} to {1}"", chrome_cookie_path, cookie_tempFile"
"(""\t[+] Copy {0} to {1}"", login_data_path, login_data_tempFile"
"(""\t[+] Delete File {0}"", cookie_tempFile"
"(""\t[+] Delete File {0}"", login_data_tempFile"
"(""\t[URL] -> {0}\n\t[USERNAME] -> {1}\n\t[PASSWORD] -> {2}\n"", url, username, password"
"(""\t[{0}] \t {1}={2}"",host_key,name, cookie_value"
"(""\t\t"" + match.Value"
"(""\t{0} \t {1}"", url, title"
"(""\t{0}"", url"
"(""a+b"" in the example"
"(""abs"",                1, 0, 0, absFunc          "
"(""advapi32.dll"""
"(""advapi32.dll"", CharSet = CharSet.Auto, SetLastError = true"
"(""advapi32.dll"", SetLastError = true"
"(""avg"",               1, 0, 0, sumStep,         avgFinalize    "
"(""bcrypt.dll"""
"(""bcrypt.dll"", EntryPoint = ""BCryptGetProperty"""
"(""bcrypt.dll"", EntryPoint = ""BCryptSetProperty"""
"(""changes"",            0, 0, 0, changes          "
"(""coalesce"",           0, 0, 0, null                "
"(""coalesce"",           1, 0, 0, null                "
"(""coalesce"",          -1, 0, 0, ifnullFunc       "
"(""count"",             0, 0, 0, countStep,       countFinalize  "
"(""count"",             1, 0, 0, countStep,       countFinalize  "
"(""current_date"",      0, ""%Y-%m-%d %H:%M:%S"", 0, currentTimeFunc"
"(""current_date"",      0, 0, 0, (dxFunc"
"(""current_time"",      0, ""%H:%M:%S"",          0, currentTimeFunc"
"(""current_time"",      0, 0, 0, (dxFunc"
"(""current_timestamp"", 0, ""%Y-%m-%d"",          0, currentTimeFunc"
"(""current_timestamp"", 0, 0, 0, (dxFunc"
"(""date"",             -1, 0, 0, (dxFunc"
"(""datetime"",         -1, 0, 0, (dxFunc"
"(""error during initialization: %s"", zErrmsg"
"(""glob"", 2, globInfo, SQLITE_FUNC_LIKE|SQLITE_FUNC_CASE"
"(""group_concat"",      1, 0, 0, groupConcatStep, groupConcatFinalize"
"(""group_concat"",      2, 0, 0, groupConcatStep, groupConcatFinalize"
"(""hex"",                1, 0, 0, hexFunc          "
"(""ifnull"",             2, 0, 1, ifnullFunc       "
"(""julianday"",        -1, 0, 0, (dxFunc"
"(""kernel32.dll"", SetLastError = true"
"(""last_insert_rowid"",  0, 0, 0, last_insert_rowid"
"(""length"",             1, 0, 0, lengthFunc       "
"(""like"", 2, likeInfoAlt, SQLITE_FUNC_LIKE|SQLITE_FUNC_CASE"
"(""like"", 2, likeInfoNorm, SQLITE_FUNC_LIKE"
"(""like"", 3, likeInfoAlt, SQLITE_FUNC_LIKE|SQLITE_FUNC_CASE"
"(""like"", 3, likeInfoNorm, SQLITE_FUNC_LIKE"
"(""load_extension"",     1, 0, 0, loadExt          "
"(""load_extension"",     2, 0, 0, loadExt          "
"(""lower"",              1, 0, 0, lowerFunc        "
"(""ltrim"",              1, 1, 0, trimFunc         "
"(""ltrim"",              2, 1, 0, trimFunc         "
"(""main"", ""temp"" or the name of an attached db"
"(""max"",                0, 1, 1, null                "
"(""max"",               -1, 1, 1, minmaxFunc       "
"(""max"",               1, 1, 1, minmaxStep,      minMaxFinalize "
"(""min"",                0, 0, 1, null                "
"(""min"",               -1, 0, 1, minmaxFunc       "
"(""min"",               1, 0, 1, minmaxStep,      minMaxFinalize "
"(""new: %d(%d"
"(""nullif"",             2, 0, 1, nullifFunc       "
"(""quote"",              1, 0, 0, quoteFunc        "
"(""random"",             0, 0, 0, randomFunc       "
"(""randomblob"",         1, 0, 0, randomBlob       "
"(""rdtsc"" : ""=A"" (val"
"(""rdtsc"" : ""=a"" (lo"
"(""replace"",            3, 0, 0, replaceFunc      "
"(""round"",              1, 0, 0, roundFunc        "
"(""round"",              2, 0, 0, roundFunc        "
"(""rtrim"",              1, 2, 0, trimFunc         "
"(""rtrim"",              2, 2, 0, trimFunc         "
"(""soundex"",            1, 0, 0, soundexFunc      "
"(""sqlite_version"",     0, 0, 0, versionFunc      "
"(""strftime"",         -1, 0, 0, (dxFunc"
"(""substr"",             2, 0, 0, substrFunc       "
"(""substr"",             3, 0, 0, substrFunc       "
"(""sum"",               1, 0, 0, sumStep,         sumFinalize    "
"(""time"",             -1, 0, 0, (dxFunc"
"(""total"",             1, 0, 0, sumStep,         totalFinalize    "
"(""total_changes"",      0, 0, 0, total_changes    "
"(""trim"",               1, 3, 0, trimFunc         "
"(""trim"",               2, 3, 0, trimFunc         "
"(""typeof"",             1, 0, 0, typeofFunc       "
"(""upper"",              1, 0, 0, upperFunc        "
"(""url"" + i.ToString("
"(""vaultcli.dll"""
"(""vaultcli.dll"", EntryPoint = ""VaultGetItem"""
"(""vdbe_profile.out"", ""a"""
"(""vdbeaux.c"""
"(""xBestIndex for %s\n"", pTab.zName"
"(""zeroblob"",           1, 0, 0, zeroblobFunc     "
"(""{0} {1} {2}"", originUrl, username, password"
"(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"""
"(%d,%d"
"(& sqlite3GlobalConfig.m, 0, sizeof( sqlite3GlobalConfig.m"
"(&a, b, c, d, e"
"(&a, b, c, d, e, f"
"(&aNew[nCurrent], 0, (nSavepoint-nCurrent"
"(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *"
"(&ctx, 0, sizeof(ctx"
"(&data[24], 0, 100-24"
"(&data[cellbody], apCell[i], aSize[i]"
"(&db->aModule, zCopy, nName, (void*"
"(&db->aModule, zMod, sqlite3Strlen30(zMod"
"(&lTm,&pTm"
"(&m, 0, sizeof(m"
"(&m, SQLITE_UTF8"
"(&m, z, nByte, SQLITE_UTF16NATIVE, SQLITE_STATIC"
"(&pArg, 1"
"(&pMem->z[pMem->n], 0, pMem->u.nZero"
"(&pPager.dbFileVers, dbFileVers, sizeof(pPager.dbFileVers"
"(&pPager.zJournal[nPathname], ""-journal"", 8"
"(&pSchema->tblHash, zName, nName, pTab"
"(&pSrc.a[iStart], 0, sizeof(pSrc.a[0]"
"(&r1, t2, sizeof(r1"
"(&realvalue, nsd"
"(&sContext, 0, sizeof(sContext"
"(&sContext.s, MEM_Null"
"(&sContext.s, encoding"
"(&sContext.s, pDest"
"(&sLocal, t"
"(&sNC, p, zOrigDb, zOrigTab, zOrigCol"
"(&sqlite3_query_plan[nQPlan], ""* "", 2"
"(&sqlite3_query_plan[nQPlan], pLevel.plan.u.pIdx.zName, n"
"(&t, sLocal"
"(&t, sNow"
"(&uTm,&lTm"
"(&zBuf[n], cnt, sizeof(cnt"
"(&zBuf[n], i, sizeof(i"
"(&zBuf[n], x, sizeof(x"
"(&zOut[j], zRep, nRep"
"(&zOut[j], zStr[i], nStr-i"
"('CREATE TABLE abc(a, b, c"
"('hi','hoo','hum'"
"('index',%Q,%Q,#%d,%Q"
"('trigger',%Q,%Q,0,'CREATE TRIGGER %q'"
"(( nFree - nOrig + PTRMAP_PAGENO( pBt, nOrig "
"((pbegin = get2byte(data, addr"
"((rc = btreeGetPage(pBt, (Pgno"
"() API functions, backup_remaining("
"() directly.  For example, [sqlite3_open("
"() is running.  Furthermore, sqlite3_config("
"() may only be used within a trigger-program"" "
"() repairs the tree, and the if(..."
"() returns error code %d"", rc"
"() routine is similar to ""snprintf("
"() to seek cursor pCur to (pKey, nKey"
"()%5 AS x, count(*"
"(), -1, null"
"(), LIKEFUNC("
"(), LTRIM("
"(), NVL("
"(), PENDING_BYTE, 0, 1, 0"
"(), RESERVED_BYTE, 0, 1, 0"
"(), SHARED_FIRST, 0, SHARED_SIZE, 0"
"(), and do not mix calls to sqlite3_column_text16("
"(), and sqlite3SrcListDup("
"(), and sqlite3_result_text16be("
"(), blob_write("
"(), but call //sqlite3DbFree("
"(), can be called. sqlite3SelectDup("
"(), current_date("
"(), free("
"(), fs.Name "
"(), gmtime("
"(), heightOfExprList("
"(), isalnum("
"(), locktype, pFile.locktype, pFile.sharedLockByte "
"(), max("
"(), new Db("
"(), or sqlite3_column_text16("
"(), pFile.fs.Name "
"(), pTail = new RowSetEntry("
"(), rc "
"(), realloc("
"(), setSharedCacheTableLock("
"(), sqlite3FindCollSeq("
"(), sqlite3GetCollSeq("
"(), sqlite3_backup_pagecount("
"(), sqlite3_bind_text("
"(), sqlite3_column_text("
"(), sqlite3_errmsg("
"(), sqlite3_mutex_try("
"(), sqlite3_open16("
"(), sqlite3_reset("
"(), sqlite3_result_text16("
"(), which never calls malloc("
"(), xSleep("
"().  For a normal halt, this should be SQLITE_OK (0"
"().  On those systems, sqlite3_mutex_try("
"().  Similarly, sqlite3_shutdown("
"().CopyTo( buf, 0 "
"().GetField(""LastModified"""
"().GetField(""SchemaId"""
"().GetField(""Type"""
"().GetField(""pAuthenticatorElement"""
"().GetField(""pIdentityElement"""
"().GetField(""pPackageSid"""
"().GetField(""pResourceElement"""
"()///sqlite3DbFree(db,ref  "
"();     //  memcpy(saveBuf, pParse.nVar, SAVE_SZ"
"();    //  memset(pParse.nVar, 0, SAVE_SZ"
"();  //  memcpy(pParse.nVar, saveBuf, SAVE_SZ"
"();  //sqlite3DbMallocZero(db, ExprList"
"(); //    res = UnlockFile(pFilE.h, SHARED_FIRST + pFilE.sharedLockByte, 0, 1, 0"
"(); // TODO --            fprintf(yyTraceFILE, ""%sSyntax Error!\n"", yyTracePrompt"
"(); // TODO --        fprintf(yyTraceFILE, ""%sFail!\n"", yyTracePrompt"
"(); // TODO -- *va_arg(ap, sqlite3_pcache_methods*"
"(); // TODO --//va_arg(ap, sqlite3_mem_methods*"
"(); // TODO --pNew =  sqlite3GlobalConfig.m.xRealloc(ref pOld, nBytes"
"(); // memset(pFile, 0, sizeof(*pFile"
"(); // memset(sNC, 0, sNC"
"(); //memcpy(pColl, pColl2, sizeof(CollSeq"
"(); //memset( &pcache1, 0, sizeof( pcache1 "
"(); //memset( &sContext, 0, sizeof( sContext "
"(); //memset(&mem0, 0, sizeof(mem0"
"(); //memset(yygotominor, 0, yygotominor"
"(); //sqlite3_snprintf(nByte, pMem.z, ""%lld"", pMem->u.i"
"(); }// memset( yygotominor.yy346, 0, sizeof( yygotominor.yy346 "
"(); }//sqlite3DbMallocZero(pParse.db, sizeof(*yygotominor.yy65"
"();//      sqlite3DbMallocRaw(db, sizeof(*pKeyMerge"
"();//    static const Mem nullMem = {{0}, (double"
"();//  memset(&sMem, 0, sizeof(sMem"
"();// memset( &b, 0, sizeof( b "
"();// memset( &bestPlan, 0, sizeof( bestPlan "
"();// memset( &c1, 0, sizeof( c1 "
"();// memset( &dest, 0, sizeof( dest "
"();// memset( &keyInfo, 0, sizeof(keyInfo "
"();// memset( &nc, 0, sizeof( nc "
"();// memset( &pcache1, 0, sizeof( pcache1 "
"();// memset( &sNC, 0, sNC "
"();// memset( &sNC, 0, sizeof( sNC "
"();// memset( &sNC, 0, sizeof(sNC"
"();// memset( &sName, 0, sizeof(NameContext"
"();// memset( &tx, 0, sizeof(tx"
"();// memset(&sNC, 0, sNC"
"();// memset(sAggInfo, 0, sAggInfo"
"();// memset(sNC, 0, sizeof(sNC"
"();// memset(sSrc, 0, sizeof(sSrc"
"();// sqlite3DbMallocRaw( db, sizeof( Savepoint "
"();// sqlite3DbMallocZero( db, sizeof( Table "
"();// sqlite3DbMallocZero( db, sizeof( TriggerStep "
"();// sqlite3DbMallocZero( db, sizeof(TriggerStep "
"();// sqlite3DbMallocZero(db, Table"
"();// sqlite3DbMallocZero(db, Vdbe"
"();//memset( &c2, 0, sizeof( c2 "
"();//memset(&mem0, 0, sizeof(mem0"
"();//memset(&sContext, 0, sizeof(sContext"
"();//memset(db.aDb[j], 0, (db.nDb-j"
"();//memset(info, 0, sizeof(info"
"();//memset(p, 0, sizeof(*p"
"();//memset(p, 0, sizeof(PCache"
"();//memset(pCost, 0, sizeof(*pCost"
"();//memset(pItem, 0, sizeof(*pItem"
"();//memset(pOp, 0, sizeof(pOp[0]"
"();//memset(pPg.pExtra, 0, pPager.nExtra"
"();//memset(pSubSrc.a[i], 0, sizeof(pSubSrc.a[i]"
"();//memset(pVdbeFunc.apAux[nAux], 0, sizeof(struct AuxData"
"();//sqlite3DbMallocRaw( db, dupedExprSize( p, flags "
"();//sqlite3DbMallocRaw(db, nByte "
"();//sqlite3DbMallocRaw(db, sizeof(*p"
"();//sqlite3DbMallocRaw(db, sizeof(*pAndInfo"
"();//sqlite3DbMallocRaw(db, sizeof(*pNew"
"();//sqlite3DbMallocRaw(p.db, sizeof(*pNew"
"();//sqlite3DbMallocRaw(pKeyInfo.db, nByte"
"();//sqlite3DbMallocRaw(pParse.db, sizeof(*pInfo"
"();//sqlite3DbMallocZero(db, SrcList.Length "
"();//sqlite3DbMallocZero(db, nByte "
"();//sqlite3DbMallocZero(db, sizeof(*p"
"();//sqlite3DbMallocZero(db, sizeof(*pInfo"
"();//sqlite3DbMallocZero(db, sizeof(*pNew"
"();//sqlite3DbMallocZero(db, sizeof(*pOrInfo"
"();//sqlite3DbMallocZero(db, sizeof(Expr"
"();//sqlite3DbMallocZero(db, sizeof(IdList"
"();//sqlite3DbStrNDup(db, (char*"
"();//sqlite3StackAllocZero(db, sizeof(*pParse"
"();//sqlite3StackAllocZero(pErrorDb, sizeof(*pParse"
"()] interfaces are its constructors, and [sqlite3_close("
"()], [sqlite3_column_text("
"()], [sqlite3_create_collation16("
"()], [sqlite3_create_function("
"()], [sqlite3_errmsg("
"()], [sqlite3_free("
"()], [sqlite3_get_auxdata("
"()], [sqlite3_open16("
"()], [sqlite3_open_v2("
"()], [sqlite3_step("
"()], [sqlite3_user_data("
"()], [sqlite3_value_bytes16("
"()], [sqlite3_value_text("
"()], and [sqlite3_bind_parameter_index("
"()], or [sqlite3_open_v2("
"(*sqlite3OsDlSym(sqlite3_vfs *, void *, const char *"
"(0, all.n"
"(0, p"
"(0, rc"
"(0, ref vaultCount, ref vaultGuidPtr"
"(0, sizeof(p->u.aHash"
"(0, yygotominor.yy0.n"
"(0, zErrmsg"
"(0, zRight"
"(1,2,3"
"(20, zBuf[j]"
"(200, ref zContext, ""Page %d: "", iPage"
"(4,5,11"
"(4096, 24"
"(<y>, <z>..."
"(>, <, >= or <="
"(?, ?, ?"
"(A,B"
"(A,B,C"
"(A,B,C,0"
"(A,B,C,D,E,F,G,H,I,J,K,L"
"(A,C"
"(B,A"
"(B,C,D,E,F"
"(BCrypt.BCRYPT_AES_ALGORITHM, BCrypt.MS_PRIMITIVE_PROVIDER, BCrypt.BCRYPT_CHAIN_MODE_GCM"
"(BCrypt.BCRYPT_KEY_DATA_BLOB_MAGIC, BitConverter.GetBytes(0x1"
"(BENIGN_MALLOC_HOOKS, xBegin, xEnd"
"(BITVEC_TEST, size, program"
"(BenignMallocHooks,sqlite3Hooks"
"(Bit 0 is for main, bit 1 is for temp, and so forth."
"(Bitvec*, u32"
"(Bitvec*, u32, void*"
"(BtCursor *, const void *, int, int, int *"
"(BtCursor *, i64 *"
"(BtCursor pCsr, u32 offset, u32 amt, void *z"
"(BtCursor pCur, ref i64 pSize"
"(BtCursor pCur, ref i64 pnEntry"
"(BtCursor pCur, ref int pHasMoved"
"(BtCursor pCur, ref int pRes"
"(BtCursor pCur, ref u32 pSize"
"(BtCursor pCur, sqlite3_int64 iRowid"
"(BtCursor pCur, u32 newPgno"
"(BtCursor pCur, u32 offset, u32 amt, byte[] pBuf"
"(BtCursor*, i64 pSize"
"(BtCursor*, int pAmt"
"(BtCursor*, int pRes"
"(BtCursor*, int*"
"(BtCursor*, int*, int"
"(BtCursor*, sqlite3_int64"
"(BtCursor*, u32 offset, u32 amt, void*"
"(BtCursor*, u32 pSize"
"(BtCursor*, u32, u32, void*"
"(BtCursor*,int,int,int,Mem*"
"(BtShared *, MemPage **, Pgno *, Pgno, u8"
"(BtShared pBt, MemPage pMemPage, Pgno iPage"
"(BtShared pBt, Pgno iRoot, BtCursor pExcept"
"(BtShared pBt, Pgno key, ref u8 pEType, ref Pgno pPgno"
"(BtShared pBt, Pgno key, u8 eType, Pgno parent, ref int pRC"
"(BtShared pBt, Pgno nFin, Pgno iLastPg"
"(BtShared pBt, Pgno pgno"
"(BtShared*,sqlite3SharedCacheList"
"(Btree *, Btree *"
"(Btree *, int, int"
"(Btree *p, int nPagesize, int nReserve, int eFix"
"(Btree *pBtree, int idx, u32 *pValue"
"(Btree , int"
"(Btree , int, void(*"
"(Btree a, Pgno b"
"(Btree a, Pgno b, int c, int d"
"(Btree p, Pgno iTab, u8 eLock"
"(Btree p, Pgno iTable, ref int piMoved"
"(Btree p, Pgno iTable, u8 eLock"
"(Btree p, int autoVacuum"
"(Btree p, int iStatement"
"(Btree p, int iTab, u8 isWriteLock"
"(Btree p, int iTable, ref int piMoved"
"(Btree p, int iTable, ref int pnChange"
"(Btree p, int idx, ref u32 pMeta"
"(Btree p, int idx, u32 iMeta"
"(Btree p, int level, int fullSync"
"(Btree p, int mxPage"
"(Btree p, int nBytes, dxFreeSchema xFree"
"(Btree p, int op, int iSavepoint"
"(Btree p, int pageSize, int nReserve, int iFix"
"(Btree p, int wrflag"
"(Btree p, ref int piTable, int flags"
"(Btree p, string zMaster"
"(Btree pBtree, Pgno iRoot"
"(Btree pBtree, int errCode"
"(Btree x, i64 y, int z"
"(Btree*, int *aRoot, int nRoot, int, int*"
"(Btree*, int idx, u32 value"
"(Btree*, int"
"(Btree*, int*, int flags"
"(Btree*, int, int*"
"(Btree*, string zMaster"
"(Btree*,int"
"(Btree*,int,int"
"(BtreeMutexArray *pArray, Btree *pBtree"
"(BtreeMutexArray*, Btree*"
"(Buffer, 0, data, 0, Buffer.Length - tag.Length"
"(Buffer, Buffer.Length - 16, tag, 0, 16"
"(CP_UTF8, 0, zFilename, -1, NULL, 0"
"(CP_UTF8, 0, zFilename, -1, zWideFilename, nChar"
"(CP_UTF8, 0, zWideFilename, -1, 0, 0, 0, 0"
"(D,A,0,C"
"(D,A,B,0"
"(D,A,B,C"
"(D,I,P"
"(D,N"
"(D,P"
"(D,S"
"(D,V,..."
"(Db*, int, int"
"(DbFixer*, Expr*"
"(DbFixer*, ExprList*"
"(DbFixer*, Parse*, int, const char*, const Token*"
"(DbFixer*, Select*"
"(DbFixer*, SrcList*"
"(DbFixer*, TriggerStep*"
"(DbHasProperty(db, 0, DB_SchemaLoaded"
"(DbPage pDbPage, Pgno pgno, BtShared pBt"
"(DbPage*,int"
"(E,P"
"(EXPR, ?SEPARATOR?"
"(Expr pExpr, char aff2"
"(Expr pExpr, char idx_affinity"
"(Expr*, Expr*"
"(Expr*, int*"
"(Expr,iTable"
"(Expr,pLeft"
"(ExprSpan pOut, Parse pParse, int op, Token pValue"
"(ExprSpan pOut, Token pStart, Token pEnd"
"(FILE*, char *"
"(FILE*, int, Op*"
"(FuncDefHash*, FuncDef*"
"(FuncDefHash, sqlite3GlobalFunctions"
"(GLOBAL(struct PCacheGlobal, pcache1_g"
"(Hash*, const char *pKey, int nKey, void *pData"
"(IdList*,const char*"
"(In other words, sqlite3PagerWrite("
"(In other words, the ""major"" token."
"(Int32 offset, ref Int32 vaultCount, ref IntPtr vaultGuid"
"(IntPtr ExistingTokenHandle, int SECURITY_IMPERSONATION_LEVEL, ref IntPtr DuplicateTokenHandle"
"(IntPtr ProcessHandle, UInt32 DesiredAccess, out IntPtr TokenHandle"
"(IntPtr hAlg, byte[] key, out IntPtr hKey"
"(IntPtr hAlg, string name"
"(IntPtr hAlgorithm, uint flags"
"(IntPtr hObject, [MarshalAs(UnmanagedType.LPWStr"
"(IntPtr pHandle, IntPtr hToken"
"(IntPtr vaultHandle, Int32 chunkSize, ref Int32 vaultItemCount, ref IntPtr vaultItem"
"(IntPtr vaultHandle, ref Guid schemaId, IntPtr pResourceElement, IntPtr pIdentityElement, IntPtr pPackageSid, IntPtr zero, Int32 arg6, ref IntPtr passwordVaultPtr"
"(IntPtr vaultHandle, ref Guid schemaId, IntPtr pResourceElement, IntPtr pIdentityElement, IntPtr zero, Int32 arg5, ref IntPtr passwordVaultPtr"
"(IntegrityCk pCheck, Pgno iPage, string zContext"
"(KeyInfo*,int,const void*,char*,int"
"(LIKE, GLOB, REGEXP, and MATCH"
"(LayoutKind.Explicit, CharSet = CharSet.Ansi"
"(LayoutKind.Sequential, CharSet = CharSet.Ansi"
"(MAX_PATH-30, zMbcsPath"
"(MAX_PATH-30, zTempPath, ""%s"", sqlite3_temp_directory"
"(MAX_PATH-30, zTempPath, ""%s"", zMulti"
"(MAX_PATH-30, zTempPath, ""%s"", zUtf8"
"(MAX_PATH-30, zWidePath"
"(Mem *, int"
"(Mem pMem, char *zBuf"
"(Mem pMem, int desiredEnc"
"(Mem pMem, int n, int preserve"
"(Mem*, FuncDef*"
"(Mem*, Mem*"
"(Mem*, const Mem*"
"(Mem*, const Mem*, int"
"(Mem*, const char*, int, u8, void(*"
"(Mem*, double"
"(Mem*, i64"
"(Mem*, int"
"(Mem*, u8"
"(Mem*,int"
"(MemPage **apPage, int nPage"
"(MemPage pFrom, MemPage pTo, ref int pRC"
"(MemPage pPage, Pgno iFrom, Pgno iTo, u8 eType"
"(MemPage pPage, byte[] pCell, int offset"
"(MemPage pPage, int flagByte"
"(MemPage pPage, int flags"
"(MemPage pPage, int iCell"
"(MemPage pPage, int idx, int sz, ref int pRC"
"(MemPage pPage, int nByte, ref int pIdx"
"(MemPage pPage, int pCell"
"(MemPage pPage, int pCell, ref int pRC"
"(MemPage pPage, int start, int size"
"(MemPage pPage, ref int pRC"
"(MemPage pPage, u8[] pCell"
"(MemPage pPage, u8[] pCell, ref int pRC"
"(MemPage pParent, MemPage pPage, u8[] pSpace"
"(MemPage pParent, int iIdx, Pgno iChild"
"(MemPage pRoot, ref MemPage ppChild"
"(N,M"
"(NULL, FALSE, zName"
"(NameContext*, Expr*"
"(NameContext*,ExprList*"
"(Note, this list is NOT null terminated."
"(OE_Abort, OE_Ignore, etc"
"(OE_Abort, OE_Replace, etc."
"(OE_Abort, etc"
"(OP_Eq, OP_Ge etc."
"(P, 0, sizeof(*P"
"(P, T"
"(P, T, T1, T2"
"(P, enc"
"(P,D,N,X,E"
"(P,D,N,X,E,O"
"(P,I"
"(P,enc"
"(P->xCodec(P->pCodec,D,N,X"
"(P4_STATIC, P4_COLLSEQ etc."
"(PCache *, int"
"(PCache pCache, void (*xIter"
"(PCache*, Pgno x"
"(PCache*, Pgno, int createFlag, PgHdr**"
"(PTRMAP_ISPAGE(pBt, iGuess"
"(PTRMAP_ISPAGE(pBt, iLastPg"
"(PTRMAP_ISPAGE(pBt, nFin"
"(PTRMAP_ISPAGE(pBt, nOrig"
"(PTRMAP_PAGENO(pBt, i"
"(Pager *, i64"
"(Pager *, int"
"(Pager *pPager, Pgno pgno"
"(Pager *pPager, Pgno pgno, DbPage **ppPage, int clrFlag"
"(Pager *pPager, int n"
"(Pager *pPager, int op, int iSavepoint"
"(Pager*, int exFlag, int"
"(Pager*, int"
"(Pager*, int(*"
"(Pager*, int*"
"(Pager*, int, unsigned char*"
"(Pager*, u16*, int"
"(Pager*,DbPage*,Pgno,int"
"(Pager*,Pgno"
"(Pager*,const char *zMaster, int"
"(Pager*,int,int"
"(Parse *, CollSeq *"
"(Parse *, Expr *, Expr *"
"(Parse *, Expr *, int*"
"(Parse *, Expr *, int, int"
"(Parse *, Index *"
"(Parse *, SrcList *"
"(Parse *, SrcList *, Expr *, ExprList *, Expr *, Expr *, char *"
"(Parse *, SrcList *, Token *"
"(Parse *, Table *"
"(Parse *, Table*, int, ExprList*, int *pMask"
"(Parse *, Token *"
"(Parse *, Token *, Token *, Token **"
"(Parse *, const char *"
"(Parse *, const char*"
"(Parse *, int"
"(Parse *, int, int, u8, const char *"
"(Parse *, struct SrcList_item *"
"(Parse *pParse, Table *pTab"
"(Parse *pParse, Table *pTab, sqlite3_index_info *p"
"(Parse *pParse, Token *p"
"(Parse *pParse, Token *pEnd"
"(Parse *pParse, const char*zName"
"(Parse p, int iStartAddr, int iDb, Table pTab "
"(Parse pParse, Expr *, Token *"
"(Parse pParse, Expr p"
"(Parse pParse, Expr pExpr"
"(Parse*, AuthContext*, const char*"
"(Parse*, Expr*"
"(Parse*, Expr*, Expr*, Expr*"
"(Parse*, Expr*, int"
"(Parse*, Expr*, int*"
"(Parse*, Expr*, int, int"
"(Parse*, ExprList*, Token*, ExprList*, int"
"(Parse*, ExprList*, const char*"
"(Parse*, ExprList*, int, int"
"(Parse*, ExprList*, int, int, int"
"(Parse*, Index*, int, int, int"
"(Parse*, Select*, ExprList*, const char*"
"(Parse*, Select*, NameContext*"
"(Parse*, Select*, SelectDest*"
"(Parse*, SrcList*"
"(Parse*, SrcList*, Expr*"
"(Parse*, SrcList*, Expr*, ExprList**, u16"
"(Parse*, SrcList*, ExprList*, Expr*, int"
"(Parse*, SrcList*, ExprList*, Select*, IdList*, int"
"(Parse*, SrcList*, Token*"
"(Parse*, SrcList*, int"
"(Parse*, SrcList*, int, int"
"(Parse*, Table*"
"(Parse*, Table*, Expr*, int"
"(Parse*, Table*, Expr*, int, ExprList*"
"(Parse*, Table*, int"
"(Parse*, Table*, int, int"
"(Parse*, Table*, int, int*"
"(Parse*, Table*, int, int, int"
"(Parse*, Table*, int, int, int*, int, int,int,int"
"(Parse*, Table*, int, int, int, int"
"(Parse*, Token*"
"(Parse*, Token*, Token*"
"(Parse*, Token*, Token*, Token*"
"(Parse*, TriggerStep*, Token*"
"(Parse*, const char*, ..."
"(Parse*, const char*, char **"
"(Parse*, int iCur, int iDb, Table*, int"
"(Parse*, int"
"(Parse*, int, Expr*, Expr*, const Token*"
"(Parse*, int, Token*"
"(Parse*, int, int"
"(Parse*, int, int, int"
"(Parse*,Expr*,Schema*,SrcList*"
"(Parse*,ExprList*, Token*"
"(Parse*,ExprList*,Expr*"
"(Parse*,ExprList*,ExprSpan*"
"(Parse*,ExprList*,Token*,int"
"(Parse*,ExprSpan*"
"(Parse*,Select*"
"(Parse*,Table*"
"(Parse*,Token*"
"(Parse*,Token*,Token*,Select*"
"(Parse*,Token*,Token*,Token*,Select*,int,int"
"(Parse*,Token*,Token*,Token*,int"
"(Parse*,Token*,Token*,int,int,int,int"
"(Parse*,int isView,const char*, const char*"
"(Parse*,int"
"(Parse*,int, const char*, const char*, const char*"
"(Parse*,int,int"
"(Parse.Length - offsetof(Parse,nVar"
"(PgHdr*, Pgno"
"(Process proc, ProcessAccessFlags flags"
"(ProcessAccessFlags.QueryInformation, true, pid"
"(ProtectedData.Unprotect(cookieBytes, null, DataProtectionScope.CurrentUser"
"(ProtectedData.Unprotect(passwordBytes, null, DataProtectionScope.CurrentUser"
"(R,M"
"(RowSet*, i64"
"(RowSet*, i64*"
"(RowSet*, u8 iBatch, i64"
"(SELECT * FROM sub1, sub2"
"(SELECT x*3 AS a, y+10 AS b FROM t1"
"(SQLITE_CONFIG_MALLOC, &defaultMethods"
"(SQLITE_CONFIG_MUTEX,..."
"(SQLITE_OK == querySharedCacheTableLock(p, MASTER_ROOT, READ_LOCK"
"(SQLITE_STATUS_MEMORY_USED, -iSize"
"(SQLITE_STATUS_SCRATCH_OVERFLOW, -iSize"
"(SQLITE_STATUS_SCRATCH_SIZE, n"
"(SQLITE_STATUS_SCRATCH_USED, -1"
"(SQLITE_STATUS_SCRATCH_USED, 1"
"(SQLITE_TESTCTRL_ALWAYS, int X"
"(SQLITE_TESTCTRL_ASSERT, int X"
"(SQLITE_TESTCTRL_PENDING_BYTE, unsigned int X"
"(SQLITE_TESTCTRL_RESERVE, sqlite3 *db, int N"
"(SQLITE_UTF8, 16LE, 16BE"
"(SRT_Output, '\0', 0, 0, 0"
"(STRUCTURE,FIELD"
"(SelectDest*,int,int"
"(SrcList*, WhereClause*, int"
"(StrAccum*, int, const char*, va_list"
"(StrAccum*,const char*,int"
"(TYPE,A,B"
"(TextWriter TraceFILE, string zTracePrompt"
"(The ""_LIMIT_"" in the name is changed to ""_MAX_""."
"(The leading ""-"" is omitted from zNum."
"(Tue, 04 Aug 2009"
"(UnmanagedType.ByValArray, SizeConst = 1"
"(UnmanagedType.ByValArray, SizeConst = ANYSIZE_ARRAY"
"(V,I"
"(VaultEnum, 0, ref vaultCount, ref vaultGuidPtr"
"(Vdbe *, Index *"
"(Vdbe *, Table *"
"(Vdbe *, Table *, int, int"
"(Vdbe *, VdbeCursor*"
"(Vdbe *, int"
"(Vdbe v, const char *in"
"(Vdbe*, const char *z, int n, int"
"(Vdbe*, const char*, ..."
"(Vdbe*, int addr"
"(Vdbe*, int addr, const char *zP4, int N"
"(Vdbe*, int addr, int N"
"(Vdbe*, int addr, int P1"
"(Vdbe*, int addr, int P2"
"(Vdbe*, int addr, int P3"
"(Vdbe*, int nOp, VdbeOpList const *aOp"
"(Vdbe*, int"
"(Vdbe*, int, int, const char *, void(*"
"(Vdbe*, u8 P5"
"(Vdbe*,FILE*"
"(Vdbe*,Vdbe*"
"(Vdbe*,int"
"(Vdbe*,int,int"
"(Vdbe*,int,int,int"
"(Vdbe*,int,int,int,int"
"(Vdbe*,int,int,int,int,const char *zP4,int"
"(VdbeCursor*,UnpackedRecord*,int*"
"(VdbeFunc*, int"
"(Walker W, Select S"
"(Walker W, ref Expr E"
"(Walker*, Expr*"
"(Walker*, ExprList*"
"(Walker*, Select*"
"(Walker*,Select*"
"(WhereMaskSet*, ExprList"
"(WhereMaskSet*, Select"
"(X, Y"
"(X, ap"
"(X,Y"
"(X,Y,Z"
"(X,Y,Z,A"
"(X,Y,Z,A,B"
"(X,Y,Z,A,B,C"
"(X,Y,Z,A,B,C,D"
"(Y, Z"
"(YYCODETYPE lhs, byte nrhs"
"([SQLITE_CONFIG_PCACHE], ..."
"(a variable length integer, may have any value"
"(a, 0, sizeof(a"
"(a, b"
"(a, b, c"
"(a,b"
"(a,b,c"
"(a,b,c,d"
"(a,b,c,d,e"
"(a,b,c,d,e,f"
"(a.k.a ""rowid"""
"(aArg, nArg"
"(aBucket, 0, sizeof(aBucket"
"(aData, (int"
"(aData, (u32"
"(aData, 8 + closest * 4"
"(aFrom, iData, aTo, iData, pBt.usableSize - iData"
"(aFrom, iFromHdr + 5"
"(aFrom, iFromHdr, aTo, iToHdr, pFrom.cellOffset + 2 * pFrom.nCell"
"(aHandle, db.aExtension, sizeof(handle"
"(aNew, 0, sizeof(*aNew"
"(aNew, db.aDb, sizeof(db.aDb[0]"
"(aOvflSpace[apDiv[i]-pParent.aData], apDiv[i], szNew[i]"
"(aPayload, (u32"
"(aPayload, offset + 4, pBuf, pBufOffset, (u32"
"(aPayload, pCur.info.nLocal + pCur.info.iCell + pCur.info.nHeader"
"(aTo[iData], ref aFrom[iData], pBt.usableSize-iData"
"(aTo[iToHdr], ref aFrom[iFromHdr], pFrom.cellOffset + 2*pFrom.nCell"
"(aad, 0, pbAuthData, cbAuthData"
"(addr = hdr + 1; (pc = get2byte(data, addr"
"(aesDecryptor.Decrypt(MasterKey, iv, null, data, tag"
"(aiValues, p->u.aHash, sizeof(p->u.aHash"
"(also called ""host parameter names"" or ""SQL parameters"""
"(an SQL table, not an index"
"(ap, ""sqlite3"""
"(ap, ""sqlite3_pcache_methods"""
"(ap, int"
"(ap, sqlite3_mem_methods*"
"(ap, sqlite3_mutex_methods*"
"(ap, sqlite3_pcache_methods*"
"(ap, void*"
"(ap, zFormat"
"(ap,""int"""
"(apArg[i], 0"
"(apCell, 0, data, cellbody, aSize[i]"
"(apCell[offset + i], 0, data, cellbody, aSize[i + offset]"
"(apCopy[nOld - 1].aData, 8, apNew[nNew - 1].aData, 8, 4"
"(apNew, 0, sizeof(PgHdr1 *"
"(apNew, nNew"
"(apNew[0], pParent, ref rc"
"(apNew[0], ref rc"
"(apNew[i].aData, 8"
"(apOld, 0, (i+1"
"(apOld[i], ref rc"
"(array, 0, result, offset, array.Length"
"(b,11"
"(b0 is memory location iBMem+0, b1 is iBMem+1, and so forth"
"(book_path, ""*.url"", SearchOption.AllDirectories"
"(booktext, @""URL=(.*?"
"(btreeGetPage(pBt, 1, ref pPage1, 0"
"(byte[] encryptedData, byte[] MasterKey"
"(byte[] iv, byte[] aad, byte[] tag"
"(byte[] key, byte[] iv, byte[] aad, byte[] cipherText, byte[] authTag"
"(c, p"
"(c1 int, c2 int, c3 text"
"(c3,c1"
"(char **, sqlite3*, const char*, ..."
"(char**, sqlite3*"
"(checkRef(pCheck, (u32"
"(chrome_History_path, cookie_tempFile, true"
"(chrome_cookie_path, cookie_tempFile, true"
"(codepage, 0, zFilename, -1, NULL,0"
"(codepage, 0, zFilename, -1, zMbcsFilename, nByte"
"(codepage, 0, zWideFilename, -1, 0, 0, 0, 0"
"(collectively known as ""function creation routines"""
"(const Hash*, const char *pKey, int nKey"
"(const Mem*, const Mem*, const CollSeq*"
"(const char *, const char *"
"(const char *, const char *, int"
"(const char *, int"
"(const char *, int*"
"(const char *z, double*"
"(const char pData, int nByte"
"(const char*, ..."
"(const char*, i64*"
"(const char*, int*, u8"
"(const char*, va_list"
"(const char*,..."
"(const char*,sqlite3**"
"(const char*,sqlite3**,int,const char*"
"(const char*,va_list"
"(const u8*, const u8**"
"(const unsigned char *, int *"
"(const unsigned char *, u32 *"
"(const unsigned char *, u64 *"
"(const unsigned char*, int"
"(const unsigned char*, u32, Mem*"
"(const void *zIn, int nChar"
"(const void pData, int nChar"
"(const void*,sqlite3**"
"(context, ""?000"", 4, SQLITE_STATIC"
"(context, ((i64"
"(context, (2*(i64"
"(context, (i64"
"(context, z.ToString("
"(context, z1, -1, null"
"(context, z2.Length == 0 ? """" : z2.Substring(0, n"
"(context, zBuf, -1, SQLITE_TRANSIENT"
"(context, zHex.ToString("
"(context, zOut, j, null"
"(context, zResult, 4, SQLITE_TRANSIENT"
"(cookieBytes, masterKey"
"(count,             0, 0, 0, countStep,       countFinalize  "
"(data, 16, pBt.pageSize"
"(data, 36 + 4 * 4, pBt.autoVacuum ? 1 : 0"
"(data, 36 + 7 * 4, pBt.incrVacuum ? 1 : 0"
"(data, addr, cbrk - addr"
"(data, addr, start"
"(data, cbrk, temp, cbrk, usableSize - cbrk"
"(data, cellOffset + i * 2"
"(data, cellStart + i * 2"
"(data, hdr + 1"
"(data, hdr + 1, 4"
"(data, hdr + 1, get2byte(data, pbegin"
"(data, hdr + 3"
"(data, hdr + 3, nCell"
"(data, hdr + 5"
"(data, hdr + 5, cbrk"
"(data, hdr + 5, cellbody"
"(data, hdr + 5, pBt.usableSize"
"(data, hdr + 5, top"
"(data, i + 2"
"(data, i"
"(data, idx, iChild"
"(data, ins, idx"
"(data, pAddr"
"(data, pAddr, cbrk"
"(data, pCellptr, cellbody"
"(data, pPage.hdrOffset + 3, pPage.nCell"
"(data, pbegin + 2"
"(data, pbegin + 2, x"
"(data, pbegin"
"(data, pbegin, x"
"(data, pc + 2"
"(data, pc + 2, x"
"(data, pc"
"(data, pnext + 2"
"(data, pnext"
"(data, ptr + 2, data, ptr, (pPage.nCell - 1 - idx"
"(data, ptr"
"(data, start + 2, size"
"(data, start, pbegin"
"(data, zMagicHeader, sizeof(zMagicHeader"
"(data[cbrk], ref temp[pc], size"
"(data[cellbody], apCell[i], aSize[i]"
"(data[hdr+1], 0, 4"
"(data[hdr], 0, pBt.usableSize - hdr"
"(data[iCellFirst], 0, cbrk-iCellFirst"
"(data[start], 0, size"
"(db,  p.nExpr*sizeof(p.a[0]"
"(db, "
"(db, ""%s"", pTab->zName"
"(db, ""%s"", zErr"
"(db, ""CREATE VIRTUAL TABLE %T"", &pParse->sNameToken"
"(db, ""Invalid key value"""
"(db, ""database schema has changed"""
"(db, ""name='%q'"", pTab->zName"
"(db, ""no such column: \""%s\"""", zColumn"
"(db, ""no such module: %s"", zMod"
"(db, ""no such rowid: %lld"", iRow"
"(db, ""vtable constructor failed: %s"", zModuleName"
"(db, (char*"
"(db, (int"
"(db, (void *"
"(db, *pzErrmsg"
"(db, 0"
"(db, 0, (void**"
"(db, 0, DB_Empty"
"(db, 100"
"(db, 2*nCol*sizeof(const char*"
"(db, 200"
"(db, 3*sizeof(*pColl"
"(db, Index*.Length * nIdx"
"(db, Mem.Length * n"
"(db, SQLITE_ERROR, 0"
"(db, SQLITE_ERROR, zErr"
"(db, SQLITE_MISUSE, 0"
"(db, SQLITE_NOMEM, 0"
"(db, SQLITE_OK"
"(db, a"
"(db, db->aVTrans"
"(db, db.aDb, sizeof(db.aDb[0]"
"(db, db.nDb-1, zKey, nKey"
"(db, n / 2 + 1"
"(db, n"
"(db, n+1"
"(db, nBytes"
"(db, nMsg"
"(db, offsetof(sqlite3_module,xCommit"
"(db, offsetof(sqlite3_module,xRollback"
"(db, p"
"(db, p, n"
"(db, p.nId*sizeof(p.a[0]"
"(db, p.zErrMsg "
"(db, p.zErrMsg"
"(db, pArray, newSize * szEntry"
"(db, pChanges.a[aXRef[i]].pExpr,0"
"(db, pDef->zName"
"(db, pDel"
"(db, pEList->a[i].zSpan"
"(db, pList.a, n*sizeof(pList.a[0]"
"(db, pMod->pAux, nArg, azArg, &pVTable->pVtab, &zErr"
"(db, pNew"
"(db, pOld"
"(db, pOldItem.zAlias"
"(db, pOldItem.zDatabase"
"(db, pOldItem.zName"
"(db, pOp->p4.z"
"(db, pOp.p1, pOp.p4.z"
"(db, pOp.p1, pOp.p4.z, p.zErrMsg"
"(db, pParse"
"(db, pParse->apVtabLock[i]"
"(db, pParse->pNewTable, sqlite3DbStrNDup(db, z, n"
"(db, pRight, 0"
"(db, pRowid,0"
"(db, pSrclist, 3, 2"
"(db, pTab"
"(db, pTab, pMod, pMod->pModule->xConnect, &zErr"
"(db, pTab, pMod, pMod->pModule->xCreate, pzErr"
"(db, pTab->pSchema"
"(db, pTab.nCol + 1"
"(db, pTab.pSchema"
"(db, pTable, sqlite3DbStrDup(db, db->aDb[iDb].zName"
"(db, pTable, sqlite3DbStrDup(db, pTable->zName"
"(db, pTable, sqlite3NameFromToken(db, pModuleName"
"(db, pTable->azModuleArg"
"(db, pTable->azModuleArg, nBytes"
"(db, pTable->azModuleArg[j]"
"(db, pTable->pSchema"
"(db, pVTab"
"(db, pVTable"
"(db, pWC.a"
"(db, rc"
"(db, rc, (rc?""database is deadlocked"":0"
"(db, rc, (zErrMsg?""%s"":0"
"(db, rc, zErr"
"(db, ref p"
"(db, ref pExpr"
"(db, sizeof(*pBest"
"(db, sizeof(*pNew"
"(db, sizeof(*pParse"
"(db, sizeof(Incrblob"
"(db, sizeof(Module"
"(db, sizeof(VTable"
"(db, sizeof(aCol[0]"
"(db, sizeof(db.aDb[0]"
"(db, sizeof(handle"
"(db, sizeof(int"
"(db, sizeof(pWC.a[0]"
"(db, sqlite3GetVTable(db, pTab"
"(db, sqlite3_errmsg(db"
"(db, x, ""prefix %s suffix"", x"
"(db, zArg"
"(db, zErr"
"(db, zErrMsg"
"(db, zErrmsg"
"(db, zFormat, pTab->zName"
"(db, zFunc8, nArg, eTextRep, p, xFunc, xStep, xFinal"
"(db, zFunctionName, -1"
"(db, zKey, i/2"
"(db, zLowerName"
"(db, zModuleName"
"(db, zName"
"(db, zName, -1"
"(db, zName, pModule, pAux, 0"
"(db, zName, pModule, pAux, xDestroy"
"(db, zName8, enc, pCtx, xCompare, 0"
"(db, zRight, sqlite3Strlen30(zRight"
"(db, zSQL, 0, 0, 0"
"(db, zSql, (dxCallback"
"(db, zSql, nBytes"
"(db, zSql8, -1, saveSqlFlag, ref ppStmt, ref zTail8"
"(db, zStmt"
"(db, zTab, db->aDb[iDb].zName"
"(db, zTableName, zDbName"
"(db,"
"(db,p"
"(db,p.aCol,(p.nCol+8"
"(db,p.zBuf"
"(db,pBlob"
"(db,pParse.apVtabLock"
"(db,ref  p"
"(db,ref  pDel"
"(db,ref  pFile"
"(db,ref  zExtra"
"(db,ref  zOld"
"(db,ref  zOut"
"(db,ref db.aDb"
"(db,ref db.aExtension"
"(db,ref p.zErrMsg"
"(db,ref pFKey"
"(db,ref pMod"
"(db,ref pNew"
"(db,ref pTrigger.name"
"(db,ref pz"
"(db,ref z"
"(db,ref zErrmsg"
"(db,ref zFunc8"
"(db,ref zMaster"
"(db,ref zName8"
"(db,ref zSql8"
"(db,zSql,nBytes,false,ref ppStmt,ref pzTail"
"(db,zSql,nBytes,true,ref ppStmt,ref pzTail"
"(db->aDb[sqlite3SchemaToIndex(db, p->pSchema"
"(db->pAuthArg, code, zArg1, zArg2, zArg3, pParse->zAuthContext"
"(db->pErr, -1, sqlite3ErrStr(db->errCode"
"(db.aDbStatic, db.aDb, 2*sizeof(db.aDb[0]"
"(db.aDb[0].pBt, 0, x, 0"
"(db.aLimit, aHardLimit, sizeof(db.aLimit"
"(db.pVfs, rT"
"(dbFileVers, 0, dbFileVers"
"(decodeFlags(pPage, data[hdr]"
"(delete, truncate or zero the first part of"
"(dest, SRT_Table, ephemTab"
"(e.g. UPDATE, INSERT, DELETE"
"(eType != pPtrmap[offset] || sqlite3Get4byte(pPtrmap, offset + 1"
"(either 0, or 1, or NULL"
"(elementPtr, typeof(Double"
"(elementPtr, typeof(Guid"
"(encBlob, null, DataProtectionScope.CurrentUser"
"(encryptedData, 15, Buffer, 0, encryptedData.Length - 15"
"(encryptedData, 3, iv, 0, 12"
"(ex:  ""name"", 'name', [name], or `name`"
"(ex: ""a"""
"(ex: ""abc"""
"(ex: ""b"""
"(ex: the 'd' in ""%d"""
"(example:  ""a IN (SELECT * FROM table"
"(expr1,expr2,expr3"
"(false == PTRMAP_ISPAGE(pBt, PENDING_BYTE_PAGE(pBt"
"(flags, false, proc.Id"
"(for example, Windows 95"
"(get2byte(aFrom, iFromHdr + 5"
"(get2byte(apNew[0].aData, 5"
"(get2byte(data, hdr + 3"
"(get2byte(data, hdr + 5"
"(guidAddress, typeof(Guid"
"(h, INFINITE"
"(hAlg, 0x0"
"(hAlg, BCrypt.BCRYPT_AUTH_TAG_LENGTH"
"(hAlg, BCrypt.BCRYPT_CHAINING_MODE, chainMode, chainMode.Length, 0x0"
"(hAlg, BCrypt.BCRYPT_OBJECT_LENGTH"
"(hAlg, IntPtr.Zero, BCrypt.BCRYPT_KEY_DATA_BLOB, out hKey, keyDataBuffer, keyDataSize, keyBlob, keyBlob.Length, 0x0"
"(hAlg, key, out hKey"
"(hAlg, name, null, 0, ref size, 0x0"
"(hAlg, name, value, value.Length, ref size, 0x0"
"(hKey, cipherText, cipherText.Length, ref authInfo, ivData, ivData.Length, null, 0, ref plainTextSize, 0x0"
"(hKey, cipherText, cipherText.Length, ref authInfo, ivData, ivData.Length, plainText, plainText.Length, ref plainTextSize, 0x0"
"(hasSharedCacheTableLock(p, (u32"
"(hasSharedCacheTableLock(p, pCur.pgnoRoot, pCur.pKeyInfo != null ? 1 : 0, 2"
"(hereafter ""the page"""
"(hit+contentOffset, 0, usableSize-contentOffset"
"(hit, 1, contentOffset"
"(i.e. ""5"", ""5.1"", ""'a string'"""
"(i.e. ""main"", ""temp"" or an attached database"
"(i.e. ""main"", ""temp"""
"(i=0; i<20; i++, j++"
"(i=0; i<pIdxInfo.nConstraint; i++, pIdxCons++"
"(i=j=0, pTerm=pWC.a; i<pWC.nTerm; i++, pTerm++"
"(i=nTerm=0, pTerm=pWC.a; i<pWC.nTerm; i++, pTerm++"
"(iFrom == sqlite3Get4byte(pPage.aData, pCell, info.iOverflow"
"(iPtrmap, key"
"(idx=precision, rounder=0.4999; idx>0; idx--, rounder*=0.1"
"(in upper, lower or mixed case"
"(info, pCur.info, sizeof(info"
"(int N, int J"
"(int N, void *P"
"(int index, int bInteger "
"(int nByte, unsigned char pData"
"(int op, ..."
"(int op, int *pCurrent, int *pHighwater, int resetFlag"
"(int szPage, int bPurgeable"
"(int*,int*,int*,int*"
"(int, ..."
"(int, int"
"(int,char*,const char*, ..."
"(int,char*,const char*,..."
"(int,const void*,UnpackedRecord*"
"(int,int*"
"(int,int*,int*,int"
"(int,void*"
"(it must be, as it was just reconstructed using assemblePage("
"(iv, 0, pbNonce, cbNonce"
"(iv, aad, authTag"
"(j=end, ptr=&data[j]; j>ins; j-=2, ptr-=2"
"(length of master journal name in bytes, no nul-terminator"
"(length, data"
"(lk.Length, lk"
"(login_data_path, login_data_tempFile, true"
"(masterKey, 5, temp, 0, masterKey.Length - 5"
"(memcmp(pPager.dbFileVers, dbFileVers, dbFileVers"
"(memcmp(page1, 21, ""\x0040\x0020\x0020"", 3"
"(memcmp(page1, zMagicHeader, 16"
"(memcpy(&zBuf[n], pid, sizeof(pid"
"(n, zStmt,""CREATE TABLE """
"(n-k, zStmt[k], ""%s"", zEnd"
"(n-k, zStmt[k], zSep"
"(nBuf, zBuf, ""OsError 0x%x (%u"
"(nBuf, zBufOut"
"(nByte, pMem.z, ""%!.15g"", pMem->r"
"(nCell == get2byte(data, hdr + 3"
"(nCell, pCellKey, pIdxKey"
"(nCell, pPage.aData, pCell + 1, pIdxKey"
"(nCell, pPage.aData, pCell + 2, pIdxKey"
"(nTemp, ref zTemp, ""vtab:%p:%p"", pVtab, pVtab.pModule"
"(name,%d+18"
"(name,seq"
"(new Guid(""00000000-0000-0000-0000-000000000000"""
"(new Guid(""154E23D0-C644-4E6F-8CE6-5069272F999F"""
"(new Guid(""2F1A6504-0641-44CF-8BB5-3612D865F2E5"""
"(new Guid(""3C886FF3-2669-4AA2-A8FB-3F6759A77548"""
"(new Guid(""3CCD5499-87A8-4B10-A215-608888DD3B55"""
"(new Guid(""3E0E35BE-1B77-43E7-B873-AED901B6275B"""
"(new Guid(""4BF4C442-9B8A-41A0-B380-DD4A704DDB28"""
"(new Guid(""77BC582B-F0A6-4E15-4E80-61736B6F3B29"""
"(new Guid(""E69D7838-91B5-4FC9-89D5-230D4D4CC2BC"""
"(newCell, oldCell, 4"
"(new[] { tagLengthsValue[4], tagLengthsValue[5], tagLengthsValue[6], tagLengthsValue[7] }, 0"
"(new_ht, 0, new_size*sizeof(struct _ht"
"(null, i, p.aOp[i]"
"(numbered from left to right, starting at 0"
"(objLength, 0"
"(object obj,PgHdr pPhHdr"
"(object pData, sqlite3_int64 p1, int p2"
"(object pPrior, int nByte"
"(or an ""sqlite3_stmt"" as it is known to the outside world."
"(or up until the first pair of 0x00 bytes, whichever comes first"
"(out hAlg, alg, provider, 0x0"
"(out, ""%02x"", p.aOp[i].opcode"
"(out, ""---- """
"(out, ""\n"""
"(out, i, p.aOp[i]"
"(out, in, 8"
"(p, (int"
"(p, (u32"
"(p, 0, 1"
"(p, 0, n"
"(p, 0, sqlite3JournalSize(pVfs"
"(p, 4, maxRootPgno"
"(p, 4, pgnoRoot"
"(p, BTREE_LARGEST_ROOT_PAGE, ref maxRootPgno"
"(p, BTREE_LARGEST_ROOT_PAGE, ref pgnoRoot"
"(p, EP_xIsSelect"
"(p, MASTER_ROOT, READ_LOCK"
"(p, addr, _p4, p4type"
"(p, f"
"(p, iTab, lockType"
"(p, iTable, wrFlag, pKeyInfo, pCur"
"(p, n"
"(p, nByte+8 "
"(p, nKey, 0"
"(p, null"
"(p, op, p1, p2, p3"
"(p, pCur.info.nKey, 0"
"(p, pOp.p1, 0, -1, 0"
"(p, pgno"
"(p, rc"
"(p, ref piTable, flags"
"(p,db, pTab"
"(p,v"
"(p->dbMem, p->azModuleArg"
"(p->dbMem, p->azModuleArg[i]"
"(p->pReal, zBuf, iAmt, iOfst"
"(p->u.aHash, 0, sizeof(p->u.aHash"
"(p->u.apSub, 0, sizeof(p->u.apSub"
"(p.db, p.aLabel"
"(p.db, pBlock"
"(p.db, pBt.pCursor.pBtree.db"
"(p.db, pBt.pWriter.db"
"(p.db, pIter.pBtree.db"
"(p.db, pNew"
"(p.db, z, n"
"(p.db, zP4, n"
"(p.db,ref p.zMalloc"
"(p.pBt.pPager, mxPage"
"(p.pCsr, iOffset+p.iOffset, n, z"
"(p.pReal, flags"
"(p.pReal, p.zBuf, p.iSize, 0"
"(p.pReal, pSize"
"(p.pReal, size"
"(p.pReal, zBuf, iAmt, iOfst"
"(p.pSrc, 0"
"(p.pSrc, null"
"(p.pVfs, p.zJournal, pReal, p.flags, 0"
"(p.trace,R,M"
"(p.yystack, newSize*sizeof(pNew[0]"
"(p.yystack,newSize"
"(p.zBuf[iOfst], zBuf, iAmt"
"(p.zText, p.zBase, p.nChar + 1"
"(pAccum, zSpaces, N"
"(pAccum, zSpaces, zSpaces.Length-1"
"(pArg, nowUsed, nByte"
"(pBest.zName, zName, nName"
"(pBlob, (void *"
"(pBlob, z, n, iOffset, sqlite3BtreeData"
"(pBt, (Pgno"
"(pBt, 0, null"
"(pBt, 0, pagerPagecount(pBt"
"(pBt, 1, ref pPage1, 0"
"(pBt, child, ref e, ref n"
"(pBt, childPgno, PTRMAP_BTREE, pgno, ref rc"
"(pBt, iFreePage, eType, iPtrPage, ref rc"
"(pBt, iGuess, ref eType, ref pgno"
"(pBt, iLastPg"
"(pBt, iLastPg, ref eType, ref iPtrPage"
"(pBt, iLastPg, ref pLastPg, 0"
"(pBt, iLastPg, ref pPg, 0"
"(pBt, iNewTrunk, ref pNewTrunk, 0"
"(pBt, iPage"
"(pBt, iPage, PTRMAP_FREEPAGE, 0, ref rc"
"(pBt, iPtrPage, ref pPtrPage, 0"
"(pBt, iTrunk, ref pTrunk, 0"
"(pBt, key"
"(pBt, key, PTRMAP_BTREE, apNew[i].pgno, ref rc"
"(pBt, maxRootPgno"
"(pBt, maxRootPgno, ref pMove, 0"
"(pBt, nFin, iFree"
"(pBt, nearby, ref eType, ref Dummy0"
"(pBt, newPgno, ref pNewPage"
"(pBt, nextOvfl, PTRMAP_OVERFLOW2, iFreePage, ref rc"
"(pBt, nextPage, ref  MemPageDummy, ref nextPage"
"(pBt, ovfl, ref e, ref n"
"(pBt, ovfl, ref pPage, 0"
"(pBt, ovflPgno, ref pOvfl, ref iNext"
"(pBt, pCur.pgnoRoot, pCur"
"(pBt, pCur.pgnoRoot, ref pCur.apPage[0]"
"(pBt, pLastPg, eType, iPtrPage, iFreePg, (nFin != 0"
"(pBt, pMove, PTRMAP_ROOTPAGE, 0, iTable, 0"
"(pBt, pNew.pgno, PTRMAP_BTREE, pParent.pgno, ref rc"
"(pBt, pOvfl, ovflPgno"
"(pBt, pPgno"
"(pBt, pPgno, ref pPg, 0"
"(pBt, pPgno, ref ppPage, 0"
"(pBt, pPgno, ref ppPage, noContent"
"(pBt, pRoot, eType, iPtrPage, pgnoMove, 0"
"(pBt, pgno"
"(pBt, pgno, ref apOld[i]"
"(pBt, pgno, ref pPage"
"(pBt, pgno, ref ppPage, 0"
"(pBt, pgnoChild, PTRMAP_BTREE, pRoot.pgno, ref rc"
"(pBt, pgnoNew, PTRMAP_BTREE, pParent.pgno, ref rc"
"(pBt, pgnoOvfl"
"(pBt, pgnoOvfl, eType, pgnoPtrmap, ref rc"
"(pBt, pgnoRoot, PTRMAP_ROOTPAGE, 0, ref rc"
"(pBt, pgnoRoot, ref eType, ref iPtrPage"
"(pBt, pgnoRoot, ref pRoot, 0"
"(pBt, ref pChild, ref pgnoChild, pRoot.pgno, 0"
"(pBt, ref pFreePg, ref iFreePg, 0, 0"
"(pBt, ref pFreePg, ref iFreePg, iLastPg, 1"
"(pBt, ref pNew, ref pgno, pgno, 0"
"(pBt, ref pNew, ref pgnoNew, 0, 0"
"(pBt, ref pOvfl, ref pgnoOvfl, pgnoOvfl, 0"
"(pBt, ref pPageMove, ref pgnoMove, pgnoRoot, 1"
"(pBt, ref pRoot, ref pgnoRoot, 1, 0"
"(pBt, sqlite3Get4byte(apCell[i]"
"(pBt, sqlite3Get4byte(pCell, iCell"
"(pBt, sqlite3Get4byte(pPage.aData, 8"
"(pBt.autoVacuum && PTRMAP_ISPAGE(pBt, pPgno"
"(pBt.pHasContent, pgno"
"(pBt.pPage1.aData, 32"
"(pBt.pPage1.aData, 32, 0"
"(pBt.pPage1.aData, 36 + idx * 4"
"(pBt.pPage1.aData, 36"
"(pBt.pPage1.aData, 36, 0"
"(pBt.pPager, (u32"
"(pBt.pPager, btreeInvokeBusyHandler, pBt"
"(pBt.pPager, iLastPg"
"(pBt.pPager, iPtrmap, ref pDbPage"
"(pBt.pPager, iStatement"
"(pBt.pPager, level, fullSync != 0"
"(pBt.pPager, mxPage"
"(pBt.pPager, nFin"
"(pBt.pPager, nextPage, ref pDbPage"
"(pBt.pPager, op, iSavepoint"
"(pBt.pPager, p.db.nSavepoint"
"(pBt.pPager, pgno"
"(pBt.pPager, pgno, ref pDbPage, (u8"
"(pBt.pPager, ref nPage"
"(pBt.pPager, ref pBt.pageSize, nReserve"
"(pBt.pPager, wrflag > 1, sqlite3TempInMemory(p.db"
"(pBt.pPager, zDbHeader.Length, zDbHeader"
"(pBt.pPager, zMaster, false"
"(pBt=GLOBAL(BtShared*,sqlite3SharedCacheList"
"(pBuf, (int"
"(pBuf, pPayload, nByte"
"(pC.pData, pData.z, pC.nData"
"(pC.pVtabCursor, &v"
"(pCache, 0, sizeof(PCache1"
"(pCell, 0, _pCell_4, 4, pCell.Length"
"(pCell, 0, pNew.aData, 8, 4"
"(pCell, _pIter, ref nSize"
"(pCell, iCell + n, ref nPayload"
"(pCell, iCell + n, ref pInfo.nKey"
"(pCell, iCell"
"(pCell, iCell, info.iOverflow"
"(pCell, iChild"
"(pCell, info.iOverflow"
"(pCell, nHeader, (int"
"(pCell, nHeader, (u64"
"(pCell, nSkip, data, idx + nSkip, sz - nSkip"
"(pCell, nSkip, pTemp, nSkip, sz - nSkip"
"(pCell, offset, pTemp, 0, pCell.Length - offset"
"(pCell, ref nSize"
"(pCheck, (u32"
"(pCheck, 0, (int"
"(pCheck, iFreePage, PTRMAP_FREEPAGE, 0, zContext"
"(pCheck, iFreePage, zContext"
"(pCheck, pgno, zContext"
"(pCheck, pgnoOvfl, PTRMAP_OVERFLOW1, (u32"
"(pCheck, zContext, ""2nd reference to page %d"", iPage"
"(pCheck, zContext, ""Child page depth differs"""
"(pCheck, zContext, ""Failed to read ptrmap key=%d"", iChild"
"(pCheck, zContext, ""failed to get page %d"", iPage"
"(pCheck, zContext, ""invalid page number %d"", iPage"
"(pCheck.errMsg, ""\n"", 1"
"(pCheck.errMsg, 1, zFormat, ap"
"(pCheck.errMsg, zMsg1, -1"
"(pCheck.pBt, iChild, ref ePtrmapType, ref iPtrmapParent"
"(pChild.aOvfl, pRoot.aOvfl, pRoot.nOverflow*sizeof(pRoot.aOvfl[0]"
"(pCol, 0, sizeof(p.aCol[0]"
"(pColl[0].zName, zName, nName"
"(pCost, 0, sizeof(*pCost"
"(pCrsr, ref payloadSize"
"(pCsr, offset, amt, (byte[] *"
"(pCtx.s, z, n, SQLITE_UTF16BE, xDel"
"(pCtx.s, z, n, SQLITE_UTF16LE, xDel"
"(pCtx.s, z, n, SQLITE_UTF16NATIVE, SQLITE_TRANSIENT"
"(pCtx.s, z, n, SQLITE_UTF16NATIVE, xDel"
"(pCur, 0, (u32"
"(pCur, chldPg"
"(pCur, offset, amt, pBuf, 0"
"(pCur, pCur.pKey, pCur.nKey, 0, ref pCur.skipNext"
"(pCur, pIdxKey, nKey, bias != 0 ? 1 : 0, ref pRes"
"(pCur, pKey, nKey, appendBias, ref loc"
"(pCur, pgno"
"(pCur, ref notUsed"
"(pCur, ref pCur.nKey"
"(pCur, ref pRes"
"(pCur, sqlite3Get4byte(pPage.aData, findCell(pPage, iIdx"
"(pCur, sqlite3Get4byte(pPage.aData, findCell(pPage, idx"
"(pCur, sqlite3Get4byte(pPage.aData, pPage.hdrOffset + 8"
"(pCur, subpage"
"(pCur.apPage[iPage], pCur.aiIdx[iPage], ref info"
"(pCur.apPage[iPage],pCur.aiIdx[iPage],&pCur.info"
"(pCur.pKeyInfo, (int"
"(pCur.pVtabCursor, sContext, pOp.p2"
"(pData, aData, pPager.pageSize"
"(pData,nData"
"(pDbPage, pgno, pBt"
"(pDest, 0, N"
"(pDest, sContext.s"
"(pE, EP_FromJoin"
"(pEngine, null"
"(pExpr, pDup, sizeof(*pExpr"
"(pExpr->u.zToken,""max"""
"(pExpr->u.zToken,""min"""
"(pFilE.h, PENDING_BYTE, 0, 1, 0"
"(pFilE.h, RESERVED_BYTE, 0, 1, 0"
"(pFilE.h, SHARED_FIRST, 0, SHARED_SIZE, 0"
"(pFile.fs.Name, lowerBits, upperBits, FILE_BEGIN"
"(pFile.fs.Name, upperBits"
"(pFile.local, pFile.local"
"(pFile.shared, winceLock"
"(pIn1, encoding"
"(pIn1, z, -1, SQLITE_UTF8, null"
"(pIn2, encoding"
"(pItem.pExpr, EP_Agg"
"(pKey, nKey"
"(pKey,nKey"
"(pKey1, nKey1"
"(pKeyInfo, zP4, nByte"
"(pKeyInfo.aSortOrder, aSortOrder, nField"
"(pLeaf, pCell"
"(pLeaf, pLeaf.nCell - 1"
"(pLeaf, pLeaf.nCell - 1, nCell, ref rc"
"(pLeaf.aData, pCell - 4, pNext_4, 0, nCell + 4"
"(pMem, &ctx.s, sizeof(ctx.s"
"(pMem, (u8"
"(pMem, n, 0"
"(pMem, zBuf"
"(pMem->db, len"
"(pMem->db,ref pMem.zMalloc"
"(pMem.db, pMem.z"
"(pMem.db,ref pMem.zMalloc"
"(pMem.n < pMem.z.Length ? pMem.z.Substring(0, pMem.n"
"(pMem.r, x, sizeof(x"
"(pMem.z, 0, n"
"(pMem.z, pMem.z[2], pMem.n"
"(pMem.z, z, nAlloc"
"(pMem.zMalloc, pMem.z, pMem.n"
"(pMem[i], encoding"
"(pMove, ref rc"
"(pNew, 0, sizeof(*pNew"
"(pNew, 1, pCell, szCell"
"(pNew, PTF_INTKEY | PTF_LEAFDATA | PTF_LEAF"
"(pNew, aArg, nArg*sizeof(void *"
"(pNew, apCell[i], ref rc"
"(pNew, cntNew[i] - j, apCell, szCell, j"
"(pNew, p, db.lookaside.sz"
"(pNew, pCell, ref rc"
"(pNew, pageFlags"
"(pNew->zName, pDef->zName, sqlite3Strlen30(pDef->zName"
"(pNew.u.zToken, pToken.z, pToken.n"
"(pNew.zName, zName, nName+1"
"(pNewTrunk.aData, (u32"
"(pNewTrunk.aData[0], pTrunk.aData[0], 4"
"(pOld, apOld[i], sizeof(MemPage"
"(pOld, iFOFC"
"(pOld, j"
"(pOld, nNew"
"(pOld.aData, 8, apCell[nCell], 0, 4"
"(pOld.aData, apOld[i].aData, pBt.pageSize"
"(pOld.aData, iFOFC, apCell[nCell], 0, szCell[nCell]"
"(pOp.p1, pName"
"(pOp.p3, pDest"
"(pOp.p3, pQuery"
"(pOut, pOp->p4.z, -1, SQLITE_UTF8, SQLITE_STATIC"
"(pOvflData, 4"
"(pOvflData, 8 + i * 4"
"(pP1, 36 + idx * 4, iMeta"
"(pP1, PTF_INTKEY | PTF_LEAF | PTF_LEAFDATA"
"(pPage == null && SQLITE_OK != (rc = btreeGetPage(pBt, iPage, ref pPage, 0"
"(pPage, PTF_INTKEY | PTF_LEAF"
"(pPage, data, pc"
"(pPage, findCell(pPage, iCell"
"(pPage, flags"
"(pPage, i"
"(pPage, iCell"
"(pPage, iCell, pInfo"
"(pPage, iCellIdx"
"(pPage, iCellIdx, cellSizePtr(pPage, pCell"
"(pPage, iCellIdx, pNext_4, nCell + 4, null, n, ref rc"
"(pPage, idx"
"(pPage, idx, newCell, szNew, null, 0, ref rc"
"(pPage, idx, szOld, ref rc"
"(pPage, j"
"(pPage, newCell, pKey, nKey, pData, nData, nZero, ref szNew"
"(pPage, oldCell"
"(pPage, pCell"
"(pPage, pCell, ref debuginfo"
"(pPage, pCell, ref pRC"
"(pPage, pCell, ref rc"
"(pPage, pPage.aData, iCell, ref pInfo"
"(pPage, pPage.aData[0] | PTF_LEAF"
"(pPage, pPage.nCell - 1"
"(pPage, pc, sz"
"(pPage, ref pCur.apPage[1]"
"(pPage, ref rc"
"(pPage, sz, ref idx"
"(pPage, temp, pc"
"(pPage, z,  info"
"(pPage.aData, (pPage"
"(pPage.aData, 0, pPage.pBt.pageSize"
"(pPage.aData, 4, 0"
"(pPage.aData, findCell(pPage, lwr"
"(pPage.aData, findCell(pPage, pCur.aiIdx[pCur.iPage]"
"(pPage.aData, iCell, pCell, 0, pCell.Length"
"(pPage.aData, iCell, pCell, 0, pPage.aData.Length - iCell"
"(pPage.aData, iTo"
"(pPage.aData, iTrunk"
"(pPage.aData, pCell + info.iOverflow, (int"
"(pPage.aData, pCell - pPage.childPtrSize, pCellBody, 0, pCellBody.Length"
"(pPage.aData, pCell"
"(pPage.aData, pCell, (int"
"(pPage.aData, pCell, info.iOverflow"
"(pPage.aData, pCell, ref Dummy0"
"(pPage.aData, pCell, ref nCellKey"
"(pPage.aData, pPage.hdrOffset + 8"
"(pPage.aData, pPage.hdrOffset + 8, iTo"
"(pPage.aData,pPage.hdrOffset+8]"
"(pPage.pBt, ovfl, PTRMAP_OVERFLOW1, pPage.pgno, ref pRC"
"(pPage.pBt, pPage, pPage.pgno"
"(pPage.pPager.pageSize, (unsigned char *"
"(pPage1.aData, (u32"
"(pPage1.aData, 32"
"(pPage1.aData, 36"
"(pPage1.aData, 36, nFree + 1"
"(pPage1.aData[32], pTrunk.aData[0], 4"
"(pPager, 0"
"(pPager, 1"
"(pPager, pData, pPg->pgno, 7, return SQLITE_NOMEM, pData2"
"(pPager, pData, pPg.pgno, 3, rc=SQLITE_NOMEM"
"(pPager, pData, pPg.pgno, 7, return SQLITE_NOMEM, pData2"
"(pPager, pDbPage.pDbPage, iFreePage, isCommit"
"(pPager, pList->pData, pgno, 6, return SQLITE_NOMEM, pData"
"(pPager, pPg.pData, pPg.pgno, 3, rc = SQLITE_NOMEM"
"(pPager, pgno"
"(pPager.aHash, 0, sizeof(pPager.aHash"
"(pPager.dbFileVers, ((u8*"
"(pPager.dbFileVers, pData[24], pPager.dbFileVers"
"(pPager.pInJournal, pgno"
"(pPager.pPCache, pager_set_pagehash"
"(pPager.pPCache, pgno, 1,ref  ppPage"
"(pPager.zFilename, zPathname, nPathname"
"(pPager.zJournal, zPathname, nPathname"
"(pParent, 1"
"(pParent, apDiv[i]"
"(pParent, i + nxDiv - pParent.nOverflow"
"(pParent, i + nxDiv - pParent.nOverflow, szNew[i], ref rc"
"(pParent, iIdx, pSpace, iPage == 1 ? 1 : 0"
"(pParent, nxDiv, pCell, sz, pTemp, pNew.pgno, ref rc"
"(pParent, pCell"
"(pParent, pPage, aBalanceQuickSpace"
"(pParent, pParent.nCell, pSpace, pOut, //(int"
"(pParent.aData, apDiv[i]"
"(pParent.aData, apDiv[i], pTemp, 0, sz"
"(pParent.aData, pParent.hdrOffset + 8, pgnoNew"
"(pParent.aData, pRight"
"(pParent.aData, pRight, apNew[nNew - 1].pgno"
"(pParent.aOvfl[0].pCell, apDiv[i]"
"(pParse, ""%s"", pVtab.zErrMsg"
"(pParse, ""%s"", sqlite3ErrStr(rc"
"(pParse, ""%s"", zErr"
"(pParse, ""ORDER BY without LIMIT on %s"", zStmtType"
"(pParse, ""_rowid_"""
"(pParse, ""access to %s.%s is prohibited"",pTab->zName,zCol"
"(pParse, ""authorizer malfunction"""
"(pParse, ""cannot open view: %s"", zTable"
"(pParse, ""cannot open virtual table: %s"", zTable"
"(pParse, ""near \""%T\"": syntax error"", yyminor.yy0"
"(pParse, ""near \""%T\"": syntax error"", yymsp[0].minor.yy0"
"(pParse, ""no such module: %s"", zModule"
"(pParse, ""not authorized"""
"(pParse, ""out of memory"""
"(pParse, ""parser stack overflow"""
"(pParse, ""recursive triggers not supported (%s"
"(pParse, ""too many arguments on function %T"", yymsp[-4].minor.yy0"
"(pParse, ""too many columns in result set"""
"(pParse, ""too many terms in %s BY clause"", zType"
"(pParse, ""too many terms in ORDER BY clause"""
"(pParse, 0"
"(pParse, 0, 0"
"(pParse, 0, 0, 0, 0, yymsp[0].minor.yy328, 0, 0, 0, 0"
"(pParse, 0, 0, 0, yymsp[-2].minor.yy14, yymsp[0].minor.yy328, 0, 0, 0, 0"
"(pParse, 0, 0, yymsp[0].minor.yy3"
"(pParse, 0, p"
"(pParse, 0, pSrc, 0, 0, 0, 0, 0, 0, 0"
"(pParse, 0, sizeof(Parse"
"(pParse, 0, yymsp[-1].minor.yy132"
"(pParse, 0, yymsp[-1].minor.yy328, yymsp[0].minor.yy328, yymsp[-2].minor.yy328"
"(pParse, 0, yymsp[-1].minor.yy346.pExpr"
"(pParse, 0, yymsp[-2].minor.yy0, yymsp[-1].minor.yy14, yymsp[0].minor.yy328"
"(pParse, 0, yymsp[-2].minor.yy346.pExpr"
"(pParse, 0, yymsp[-3].minor.yy0"
"(pParse, 0, yymsp[-4].minor.yy65, 0, 0, 0, 0, 0, 0, 0"
"(pParse, 0, yymsp[0].minor.yy0"
"(pParse, 0, yymsp[0].minor.yy346.pExpr"
"(pParse, 0, zTable, zDb"
"(pParse, 1"
"(pParse, 2"
"(pParse, SAVEPOINT_BEGIN, yymsp[0].minor.yy0"
"(pParse, SAVEPOINT_RELEASE, yymsp[0].minor.yy0"
"(pParse, SAVEPOINT_ROLLBACK, yymsp[0].minor.yy0"
"(pParse, SQLITE_DELETE, pTab->zName, 0, zDb"
"(pParse, SQLITE_DELETE, zTab, 0, zDb"
"(pParse, SQLITE_FUNCTION, 0, pDef.zName, 0"
"(pParse, SQLITE_SAVEPOINT, az[op], zName, 0"
"(pParse, TK_ALL, 0, 0, yymsp[0].minor.yy0"
"(pParse, TK_BETWEEN, yymsp[-4].minor.yy346.pExpr, 0, 0"
"(pParse, TK_CASE, yymsp[-3].minor.yy132, yymsp[-1].minor.yy132, 0"
"(pParse, TK_CAST, yymsp[-3].minor.yy346.pExpr, 0, yymsp[-1].minor.yy0"
"(pParse, TK_COLUMN, 0, 0, 0"
"(pParse, TK_DOT, pLeft, pRight, 0"
"(pParse, TK_DOT, temp1, temp2, 0"
"(pParse, TK_DOT, temp1, temp4, 0"
"(pParse, TK_DOT, temp2, temp3, 0"
"(pParse, TK_EXISTS, 0, 0, 0"
"(pParse, TK_ID, 0, 0, yymsp[-2].minor.yy0"
"(pParse, TK_ID, 0, 0, yymsp[-4].minor.yy0"
"(pParse, TK_ID, 0, 0, yymsp[0].minor.yy0"
"(pParse, TK_IN, yymsp[-3].minor.yy346.pExpr, 0, 0"
"(pParse, TK_IN, yymsp[-4].minor.yy346.pExpr, 0, 0"
"(pParse, TK_NOT, yygotominor.yy346.pExpr, 0, 0"
"(pParse, TK_RAISE, 0, 0, 0"
"(pParse, TK_RAISE, 0, 0, yymsp[-1].minor.yy0"
"(pParse, TK_REGISTER, 0, 0, yymsp[0].minor.yy0"
"(pParse, TK_SELECT, 0, 0, 0"
"(pParse, TK_UMINUS, yymsp[0].minor.yy346.pExpr, 0, 0"
"(pParse, iDb"
"(pParse, op, 0, 0, pValue"
"(pParse, op, pLeft.pExpr, pRight.pExpr, 0"
"(pParse, op, pOperand.pExpr, 0, 0"
"(pParse, p"
"(pParse, p, yymsp[-1].minor.yy0"
"(pParse, pEList, pExpr"
"(pParse, pEList, pSrc, pWhere, 0, 0, 0, 0, 0, 0"
"(pParse, pInClause"
"(pParse, pList, yymsp[-2].minor.yy96.eOperator"
"(pParse, pList, yymsp[-3].minor.yy346.pExpr"
"(pParse, pList, yymsp[0].minor.yy346.pExpr"
"(pParse, pName1, pName2, 0, 0, 1, 0"
"(pParse, pSel"
"(pParse, pSelect, ref dest"
"(pParse, pTab"
"(pParse, pTab.aCol[i].zName"
"(pParse, pWC, pSrc, notReady, pOrderBy, pCost"
"(pParse, pWC, pSrc, notReady, pOrderBy, pCost, p"
"(pParse, pWC, pSrc, pOrderBy"
"(pParse, pWC, pTabItem, notReady, pOrderBy, &sCost, pp"
"(pParse, sContext, pTab.zName"
"(pParse, type, zAuthArg, 0, 0"
"(pParse, v"
"(pParse, yygotominor.yy14, ""index"""
"(pParse, yygotominor.yy14, yymsp[-1].minor.yy346"
"(pParse, yygotominor.yy14, yymsp[-2].minor.yy0, 1"
"(pParse, yygotominor.yy14, yymsp[0].minor.yy0, 1"
"(pParse, yygotominor.yy14, yymsp[0].minor.yy346.pExpr"
"(pParse, yygotominor.yy346.pExpr"
"(pParse, yygotominor.yy65, yymsp[-2].minor.yy0"
"(pParse, yymsp[-1].minor.yy0, 0, 0"
"(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0"
"(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0, 0"
"(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0, 0, 0"
"(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0, yymsp[-4].minor.yy328, 0, 0, yymsp[-2].minor.yy328"
"(pParse, yymsp[-1].minor.yy14, ""set list"""
"(pParse, yymsp[-1].minor.yy14, p"
"(pParse, yymsp[-1].minor.yy14, yymsp[-4].minor.yy0"
"(pParse, yymsp[-1].minor.yy328"
"(pParse, yymsp[-1].minor.yy346"
"(pParse, yymsp[-1].minor.yy346.pExpr"
"(pParse, yymsp[-1].minor.yy473, all"
"(pParse, yymsp[-2].minor.yy0, yymsp[-1].minor.yy0, 0"
"(pParse, yymsp[-2].minor.yy14, yymsp[-1].minor.yy346.pExpr"
"(pParse, yymsp[-2].minor.yy14, yymsp[0].minor.yy346.pExpr"
"(pParse, yymsp[-2].minor.yy346.pExpr"
"(pParse, yymsp[-2].minor.yy346.pExpr, yymsp[0].minor.yy0"
"(pParse, yymsp[-2].minor.yy65, 0, yymsp[0].minor.yy3, yymsp[-1].minor.yy408, yymsp[-4].minor.yy186"
"(pParse, yymsp[-2].minor.yy65, yymsp[-1].minor.yy0"
"(pParse, yymsp[-2].minor.yy65, yymsp[0].minor.yy132"
"(pParse, yymsp[-3].minor.yy0, yymsp[-2].minor.yy0, yymsp[-1].minor.yy0"
"(pParse, yymsp[-3].minor.yy0, yymsp[-2].minor.yy0, yymsp[0].minor.yy0"
"(pParse, yymsp[-3].minor.yy0, yymsp[-2].minor.yy0, yymsp[0].minor.yy0, 0"
"(pParse, yymsp[-3].minor.yy0, yymsp[-2].minor.yy0, yymsp[0].minor.yy0, 1"
"(pParse, yymsp[-3].minor.yy14, pDot"
"(pParse, yymsp[-3].minor.yy14, yymsp[-1].minor.yy132"
"(pParse, yymsp[-3].minor.yy14, yymsp[0].minor.yy328, yymsp[-2].minor.yy328, 0"
"(pParse, yymsp[-3].minor.yy346.pExpr, yymsp[-1].minor.yy346.pExpr, yymsp[0].minor.yy132"
"(pParse, yymsp[-3].minor.yy65, 0, 0, yymsp[-2].minor.yy408, yymsp[-5].minor.yy186"
"(pParse, yymsp[-3].minor.yy65, yymsp[0].minor.yy0"
"(pParse, yymsp[-4].minor.yy0, yymsp[-3].minor.yy0, yymsp[-1].minor.yy0, 0"
"(pParse, yymsp[-4].minor.yy0, yymsp[-3].minor.yy0, yymsp[-1].minor.yy0, 1"
"(pParse, yymsp[-4].minor.yy14, p"
"(pParse, yymsp[-4].minor.yy14, yymsp[-2].minor.yy346.pExpr"
"(pParse, yymsp[-4].minor.yy14, yymsp[0].minor.yy346.pExpr"
"(pParse, yymsp[-4].minor.yy65, yymsp[-1].minor.yy14, yymsp[0].minor.yy132, yymsp[-5].minor.yy186"
"(pParse, yymsp[-4].minor.yy65, yymsp[-3].minor.yy0"
"(pParse, yymsp[-5].minor.yy65, yymsp[-1].minor.yy14, 0, yymsp[-4].minor.yy408, yymsp[-7].minor.yy186"
"(pParse, yymsp[-6].minor.yy14, yymsp[-3].minor.yy0, yymsp[-2].minor.yy14, yymsp[-1].minor.yy328"
"(pParse, yymsp[-6].minor.yy14, yymsp[-5].minor.yy65, yymsp[-4].minor.yy132, yymsp[-3].minor.yy14, yymsp[-2].minor.yy132, yymsp[-1].minor.yy14, yymsp[-7].minor.yy328, yymsp[0].minor.yy476.pLimit, yymsp[0].minor.yy476.pOffset"
"(pParse, yymsp[-6].minor.yy65, 0, 0, yymsp[-2].minor.yy0, pSubquery, yymsp[-1].minor.yy132, yymsp[0].minor.yy408"
"(pParse, yymsp[-6].minor.yy65, 0, 0, yymsp[-2].minor.yy0, yymsp[-4].minor.yy3, yymsp[-1].minor.yy132, yymsp[0].minor.yy408"
"(pParse, yymsp[-6].minor.yy65, yymsp[-5].minor.yy0, yymsp[-4].minor.yy0, yymsp[-3].minor.yy0, 0, yymsp[-1].minor.yy132, yymsp[0].minor.yy408"
"(pParse, yymsp[-7].minor.yy0, yymsp[-3].minor.yy0, yymsp[-2].minor.yy0, yymsp[0].minor.yy3, yymsp[-6].minor.yy328, yymsp[-4].minor.yy328"
"(pParse, yymsp[-7].minor.yy0, yymsp[-6].minor.yy0, yymsp[-5].minor.yy328, yymsp[-4].minor.yy378.a, yymsp[-4].minor.yy378.b, yymsp[-2].minor.yy65, yymsp[0].minor.yy132, yymsp[-10].minor.yy328, yymsp[-8].minor.yy328"
"(pParse, yymsp[0].minor.yy0"
"(pParse, yymsp[0].minor.yy3, ref dest"
"(pParse, yymsp[0].minor.yy328"
"(pParse, yymsp[0].minor.yy346"
"(pParse, yymsp[0].minor.yy346.pExpr"
"(pParse, yymsp[0].minor.yy65"
"(pParse, yymsp[0].minor.yy65, 0, yymsp[-1].minor.yy328"
"(pParse, yymsp[0].minor.yy65, 1, yymsp[-1].minor.yy328"
"(pParse, yymsp[0].minor.yy65, yymsp[-1].minor.yy328"
"(pParse, zCreateTable, &zErr"
"(pParse->apVtabLock, n"
"(pParse->db, pSchema"
"(pParse->db, pTab"
"(pParse.db, 0, yymsp[-1].minor.yy0, yymsp[0].minor.yy0"
"(pParse.db, 0, yymsp[-3].minor.yy0, 0"
"(pParse.db, 0, yymsp[0].minor.yy0"
"(pParse.db, TK_ALL, null"
"(pParse.db, TK_COLUMN, null"
"(pParse.db, p"
"(pParse.db, pEList"
"(pParse.db, pName.z, pName.n"
"(pParse.db, pOrderBy"
"(pParse.db, pSelect"
"(pParse.db, pSrc,0"
"(pParse.db, pVtab.zErrMsg"
"(pParse.db, ref  (yypminor.yy14"
"(pParse.db, ref  (yypminor.yy65"
"(pParse.db, ref (yypminor.yy132"
"(pParse.db, ref (yypminor.yy3"
"(pParse.db, ref (yypminor.yy346"
"(pParse.db, ref (yypminor.yy378"
"(pParse.db, ref (yypminor.yy408"
"(pParse.db, ref (yypminor.yy473"
"(pParse.db, ref pLimit"
"(pParse.db, ref pList"
"(pParse.db, ref pOffset"
"(pParse.db, ref pSrc"
"(pParse.db, ref pWhere"
"(pParse.db, ref yymsp[-1].minor.yy14"
"(pParse.db, ref yymsp[-1].minor.yy3"
"(pParse.db, ref yymsp[-2].minor.yy14"
"(pParse.db, ref yymsp[-2].minor.yy3"
"(pParse.db, ref yymsp[0].minor.yy3"
"(pParse.db, sizeof(*pIdxInfo"
"(pParse.db, yymsp[-2].minor.yy0, yymsp[-1].minor.yy408, 0, yymsp[0].minor.yy3, yymsp[-4].minor.yy186"
"(pParse.db, yymsp[-2].minor.yy0, yymsp[0].minor.yy132"
"(pParse.db, yymsp[-2].minor.yy408, yymsp[0].minor.yy0"
"(pParse.db, yymsp[-4].minor.yy0, yymsp[-1].minor.yy14, yymsp[0].minor.yy132, yymsp[-5].minor.yy186"
"(pParse.db, yymsp[-5].minor.yy0, yymsp[-4].minor.yy408, yymsp[-1].minor.yy14, 0, yymsp[-7].minor.yy186"
"(pParse.db, yymsp[0].minor.yy3"
"(pParser, iFallback"
"(pParser, yymajor, yytos.minor"
"(pPayload, (int"
"(pPayload, 0, n"
"(pPayload, pBuf, nByte"
"(pPayload, pSrc, n"
"(pPg->pData, 0, pPager.pageSize"
"(pPrevTrunk.aData, (u32"
"(pPrevTrunk.aData, 0"
"(pPrevTrunk.aData[0], pTrunk.aData[0], 4"
"(pPrior, 0"
"(pPrior, pPriorIndex, pgnoOvfl"
"(pPtrPage, iDbPage, iFreePage, eType"
"(pPtrmap, offset + 1"
"(pPtrmap, offset + 1, parent"
"(pRoot, flags | PTF_LEAF"
"(pRoot, pChild, ref rc"
"(pRoot, pChild.aData[0] & ~PTF_LEAF"
"(pRoot.aData, pRoot.hdrOffset + 8"
"(pRoot.aData, pRoot.hdrOffset + 8, pgnoChild"
"(pRoot.aOvfl, pChild.aOvfl, pRoot.nOverflow"
"(pSrc, pSrcIndex, pPayload, pPayloadIndex, n"
"(pStmt, i, zData, nData, xDel, SQLITE_UTF16NATIVE"
"(pTemp+nSkip, pCell+nSkip, sz-nSkip"
"(pTemp, leafCorrection, apCell[nCell], 0, sz"
"(pTmp, -1, zName, SQLITE_UTF8, SQLITE_STATIC"
"(pTmp, SQLITE_UTF16NATIVE"
"(pTo, pFrom, MEMCELLSIZE"
"(pTo, pFrom, Mem"
"(pTo, pFrom, offsetof(sqlite3_mutex_methods, xMutexAlloc"
"(pTrunk.aData, (u32"
"(pTrunk.aData, 0, pPage1.aData, 32, 4"
"(pTrunk.aData, 12, pNewTrunk.aData, 8, (int"
"(pTrunk.aData, 4"
"(pTrunk.aData, 8"
"(pUsage, 0, sizeof(pUsage[0]"
"(pVal, -1, zFilename, SQLITE_UTF16NATIVE, SQLITE_STATIC"
"(pVal, -1, zSql, SQLITE_UTF16NATIVE, SQLITE_STATIC"
"(pVal, SQLITE_UTF16BE"
"(pVal, SQLITE_UTF16LE"
"(pVal, SQLITE_UTF16NATIVE"
"(pVal, SQLITE_UTF8"
"(pVfs, handle"
"(pVfs, handle, zProc"
"(pVfs, nMsg-1, zErrmsg"
"(pVfs, ref handle"
"(pVfs, zFilename, nFullPathname, zFullPathname"
"(pVfs, zName, pJfd, flags, 0"
"(pVfs.mxPathname, zFull, ""%s"", zOut"
"(pVfs.mxPathname, zFull, ""%s"", zRelative"
"(pVtab, nArg, apArg, &rowid"
"(pVtab, nArg, zLowerName, &xFunc, &pArg"
"(pVtab, p"
"(pVtab, pName.z"
"(pVtab, pVtabCursor"
"(pVtabCursor, iQuery, pOp.p4.z, nArg, apArg"
"(pWC.a, pOld, sizeof(pWC.a[0]"
"(pX, 0"
"(pZeroBlob, 0, pPayload, pPayloadIndex, n"
"(page1, 16"
"(passwordBytes, masterKey"
"(passwordVaultItem, VAULT_ITEM"
"(pc < get2byte(data, hdr + 5"
"(pc == get2byte(data, hdr + 5"
"(pgno==PTRMAP_PAGENO(pgsz, pgno"
"(pgnoRoot == PTRMAP_PAGENO(pBt, pgnoRoot"
"(pgptrmap, pgno"
"(phFile, SHARED_FIRST, 0, 1, 0"
"(processname == ""explorer"""
"(pzErrMsg, sqlite3_errmsg(db"
"(rc = WriteFile(pFile.fs.Name, pBuf, amt, wrote, 0"
"(ref Guid vaultGuid, UInt32 offset, ref IntPtr vaultHandle"
"(ref realvalue, ref nsd"
"(ref res.azResult, res.nData-1"
"(ref sqlite3_vfs vfs, int nByte, ref string zErrMsg"
"(ref sqlite3_vfs vfs, object data"
"(ref sqlite3_vfs vfs, object data, string zSymbol"
"(ref sqlite3_vfs vfs, string zFilename"
"(ref vaultGuid, (UInt32"
"(ref yyParser pointer_to_yyParser, int yyidx"
"(ref yypParser, yypParser.yyidx"
"(sCheck, (u32"
"(sCheck, 0, ""Page %d is never used"", i"
"(sCheck, 1, (int"
"(sCheck, aRoot[i], ""List of tree roots: """
"(sCheck, null, ""Page %d is never used"", i"
"(sCheck, null, ""Pointer map page %d is referenced"", i"
"(sCheck.errMsg, zErr, zErr.Capacity, 20000"
"(signature ""v10"""
"(similar to ""-"""
"(sql, %Q"
"(sql,%d"
"(sql,1,%d"
"(sql,14"
"(sql,21"
"(sqlite3 *, Btree *"
"(sqlite3 *, Expr *, u8, u8, sqlite3_value **"
"(sqlite3 *, VTable *"
"(sqlite3 *, const char *"
"(sqlite3 *, const void*, int"
"(sqlite3 *, i64 *"
"(sqlite3 *, int"
"(sqlite3 *, sqlite3 *"
"(sqlite3 *, void *, int"
"(sqlite3 *,FuncDef*, int nArg, Expr*"
"(sqlite3 *db, Table *p"
"(sqlite3 *db, Table *pTab"
"(sqlite3 *db, Table *pTable, char *zArg"
"(sqlite3 *db, VTable *pVTab"
"(sqlite3 *db, char **pzErrmsg"
"(sqlite3 *db, const char *z, int n"
"(sqlite3 *db, const char *zCreateTable"
"(sqlite3 *db, int iDb, const char *zTab"
"(sqlite3 *db, int iDb, const char *zTab, char **pzErr"
"(sqlite3 *db, int offset"
"(sqlite3 *db, int onoff"
"(sqlite3 *db, sqlite3 *pBlocker"
"(sqlite3 *pDb, sqlite3_stmt *pStmt"
"(sqlite3 db , Table T"
"(sqlite3 db,       int nOps, dxProgress xProgress, object pArg"
"(sqlite3 db, Schema *"
"(sqlite3 db, Select p, int flags"
"(sqlite3 db, const char *z"
"(sqlite3 db, int rc"
"(sqlite3 db, int"
"(sqlite3 db, object p, int n"
"(sqlite3 db, object pAux, int argc, string p4, object argv, sqlite3_vtab ppVTab, char p7"
"(sqlite3 db, string z, int nByte"
"(sqlite3*, CollSeq *, const char*"
"(sqlite3*, Expr*"
"(sqlite3*, ExprList*"
"(sqlite3*, ExprList*, int, ExprList*"
"(sqlite3*, IdList*"
"(sqlite3*, IdList*, Token*"
"(sqlite3*, Select *, int, ExprList *"
"(sqlite3*, Select*"
"(sqlite3*, SrcList*"
"(sqlite3*, SrcList*, Token*, Token*"
"(sqlite3*, SrcList*, int, int"
"(sqlite3*, Table*"
"(sqlite3*, Token*"
"(sqlite3*, Trigger*"
"(sqlite3*, TriggerStep*"
"(sqlite3*, char**"
"(sqlite3*, const char *z, int n"
"(sqlite3*, const char *zDbName, int op, void*"
"(sqlite3*, const char *zFuncName, int nArg"
"(sqlite3*, const char *zSQL"
"(sqlite3*, int id, int newVal"
"(sqlite3*, int ms"
"(sqlite3*, int onoff"
"(sqlite3*, int op, ..."
"(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg"
"(sqlite3*, int"
"(sqlite3*, int(*"
"(sqlite3*, int, const char *"
"(sqlite3*, int, const char *, char **"
"(sqlite3*, int, const char*,..."
"(sqlite3*, int, const void*, int"
"(sqlite3*, int, int(*"
"(sqlite3*, int, void**, int*"
"(sqlite3*, void(*"
"(sqlite3*, void(*xTrace"
"(sqlite3*, void*"
"(sqlite3*, void*, unsigned int"
"(sqlite3*,Expr*, Expr*"
"(sqlite3*,Expr*,Expr*,Expr*"
"(sqlite3*,Expr*,int"
"(sqlite3*,Expr*,int*,char*"
"(sqlite3*,ExprList*,int"
"(sqlite3*,IdList*"
"(sqlite3*,Select*"
"(sqlite3*,Select*,int"
"(sqlite3*,SrcList*,int"
"(sqlite3*,Token*, Expr*"
"(sqlite3*,Token*,ExprList*, Expr*, u8"
"(sqlite3*,char**,const sqlite3_api_routines*"
"(sqlite3*,char*,const char*,..."
"(sqlite3*,const char*"
"(sqlite3*,const char*, ..."
"(sqlite3*,const char*, const char*"
"(sqlite3*,const char*, int"
"(sqlite3*,const char*, va_list"
"(sqlite3*,const char*,char***,int*,int*,char**"
"(sqlite3*,const char*,const char*,const char*,char const**,char const**,int*,int*,int*"
"(sqlite3*,const char*,const char*,const char*,sqlite3_int64,int,sqlite3_blob**"
"(sqlite3*,const char*,const sqlite3_module*,void*"
"(sqlite3*,const char*,const sqlite3_module*,void*,void (*xDestroy"
"(sqlite3*,const char*,int,int,u8,int"
"(sqlite3*,const char*,int,int,void*,void (*xFunc"
"(sqlite3*,const char*,int,sqlite3_stmt**,const char**"
"(sqlite3*,const char*,int,void*"
"(sqlite3*,const char*,int,void*,int(*"
"(sqlite3*,const char*,sqlite3_callback,void*,char**"
"(sqlite3*,const void*,int,int,void*,void (*xFunc"
"(sqlite3*,const void*,int,sqlite3_stmt**,const void**"
"(sqlite3*,const void*,int,void*,int(*"
"(sqlite3*,int iDB"
"(sqlite3*,int ms"
"(sqlite3*,int"
"(sqlite3*,int(*"
"(sqlite3*,int,const Token*,int"
"(sqlite3*,int,const char*"
"(sqlite3*,int,int"
"(sqlite3*,int,int(*"
"(sqlite3*,sqlite3_stmt*"
"(sqlite3*,u8 enc, const char*,int"
"(sqlite3*,void(*"
"(sqlite3*,void(*xTrace"
"(sqlite3*,void*,int,const char*const*,sqlite3_vtab**,char**"
"(sqlite3*,void*,int,int,int*,int*,int*"
"(sqlite3*,void*,void(*"
"(sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0"
"(sqlite3AutoExtList,sqlite3Autoext"
"(sqlite3DbMallocSize(db, aDyn"
"(sqlite3DbMallocSize(db, pNew"
"(sqlite3Get4byte(aData, 8 + i * 4"
"(sqlite3Get4byte(aData, 8"
"(sqlite3Get4byte(pPage.aData, pCell"
"(sqlite3Get4byte(pParent.aData, findCell(pParent, iIdx"
"(sqlite3Get4byte(pParent.aData, pParent.hdrOffset + 8"
"(sqlite3Get4byte(page1, 36 + 4 * 4"
"(sqlite3Get4byte(page1, 36 + 7 * 4"
"(sqlite3PagerGet(pCheck.pPager, (Pgno"
"(sqlite3StatType,sqlite3Stat"
"(sqlite3StrICmp(pExpr->u.zToken,""match"""
"(sqlite3_backup *, Pgno, const u8 *"
"(sqlite3_backup *p, int nPage"
"(sqlite3_blob *, const void *z, int n, int iOffset"
"(sqlite3_blob *, void *Z, int N, int iOffset"
"(sqlite3_blob pBlob, const void *z, int n, int iOffset"
"(sqlite3_blob pBlob, void *z, int n, int iOffset"
"(sqlite3_blob*,const void*,int,int"
"(sqlite3_blob*,void*,int,int"
"(sqlite3_context pCtx, const void *z, int n"
"(sqlite3_context*, const char*, int"
"(sqlite3_context*, const char*, int, void(*"
"(sqlite3_context*, const void*, int"
"(sqlite3_context*, const void*, int, void(*"
"(sqlite3_context*, const void*, int,void(*"
"(sqlite3_context*, double"
"(sqlite3_context*, int N"
"(sqlite3_context*, int N, void*, void (*"
"(sqlite3_context*, int n"
"(sqlite3_context*, int nBytes"
"(sqlite3_context*, int"
"(sqlite3_context*, sqlite3_int64"
"(sqlite3_context*, sqlite3_value*"
"(sqlite3_context*,const char*,int"
"(sqlite3_context*,const char*,int,void(*"
"(sqlite3_context*,const void*,int"
"(sqlite3_context*,const void*,int,void(*"
"(sqlite3_context*,double"
"(sqlite3_context*,int nBytes"
"(sqlite3_context*,int"
"(sqlite3_context*,int,sqlite3_value **"
"(sqlite3_context*,int,sqlite3_value**"
"(sqlite3_context*,int,void*,void (*"
"(sqlite3_context*,sqlite3_value*"
"(sqlite3_context*,sqlite_int64"
"(sqlite3_file *id, int pResOut"
"(sqlite3_file pJfd, int flags"
"(sqlite3_file pJfd, sqlite_int64 pSize"
"(sqlite3_file pJfd, sqlite_int64 size"
"(sqlite3_file*, const void*, int amt, i64 offset"
"(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst"
"(sqlite3_file*, i64 pSize"
"(sqlite3_file*, i64 size"
"(sqlite3_file*, int *pResOut"
"(sqlite3_file*, int flags"
"(sqlite3_file*, int op, void *pArg"
"(sqlite3_file*, int"
"(sqlite3_file*, sqlite3_int64 *pSize"
"(sqlite3_file*, sqlite3_int64 size"
"(sqlite3_file*, void*, int amt, i64 offset"
"(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst"
"(sqlite3_file*,int,void*"
"(sqlite3_file,h"
"(sqlite3_mutex_methods, xMutexFree"
"(sqlite3_pcache pCache, int nCachesize"
"(sqlite3_pcache*, int nCachesize"
"(sqlite3_pcache*, unsigned iLimit"
"(sqlite3_pcache*, unsigned key, int createFlag"
"(sqlite3_pcache*, void*, int discard"
"(sqlite3_pcache*, void*, unsigned oldKey, unsigned newKey"
"(sqlite3_stmt *, sqlite3_stmt *"
"(sqlite3_stmt pStmt, int N"
"(sqlite3_stmt pStmt, int i"
"(sqlite3_stmt*, const char *zName"
"(sqlite3_stmt*, int N"
"(sqlite3_stmt*, int iCol"
"(sqlite3_stmt*, int op,int resetFlg"
"(sqlite3_stmt*, int"
"(sqlite3_stmt*, int, const char*, int n, void(*"
"(sqlite3_stmt*, int, const sqlite3_value*"
"(sqlite3_stmt*, int, const void*, int n, void(*"
"(sqlite3_stmt*, int, const void*, int, void(*"
"(sqlite3_stmt*, int, double"
"(sqlite3_stmt*, int, int n"
"(sqlite3_stmt*, int, int"
"(sqlite3_stmt*, int, sqlite3_int64"
"(sqlite3_stmt*, sqlite3_stmt*"
"(sqlite3_stmt*,const char*zName"
"(sqlite3_stmt*,int i"
"(sqlite3_stmt*,int iCol"
"(sqlite3_stmt*,int"
"(sqlite3_stmt*,int,const char*,int n,void(*"
"(sqlite3_stmt*,int,const sqlite3_value*"
"(sqlite3_stmt*,int,const void*,int n,void(*"
"(sqlite3_stmt*,int,const void*,int,void(*"
"(sqlite3_stmt*,int,double"
"(sqlite3_stmt*,int,int"
"(sqlite3_stmt*,int,sqlite_int64"
"(sqlite3_stmt*,sqlite3_stmt*"
"(sqlite3_value *, u8, u8"
"(sqlite3_value*, u8"
"(sqlite3_vfs *, const char *"
"(sqlite3_vfs *, const char *, int"
"(sqlite3_vfs *, const char *, int, char *"
"(sqlite3_vfs *, const char *, int, int pResOut"
"(sqlite3_vfs *, const char *, sqlite3_file **, int,int*"
"(sqlite3_vfs *, const char *, sqlite3_file *, int, int"
"(sqlite3_vfs *, const char *, sqlite3_file*, int, int *"
"(sqlite3_vfs *, double*"
"(sqlite3_vfs *, int"
"(sqlite3_vfs *, int, char *"
"(sqlite3_vfs *, vfsList"
"(sqlite3_vfs *, void *"
"(sqlite3_vfs pVfs, HANDLE pHandle, String zSymbol"
"(sqlite3_vfs pVfs, int nBuf, char *zBuf"
"(sqlite3_vfs pVfs, int nBuf, char *zBufOut"
"(sqlite3_vfs pVfs, string zFilename"
"(sqlite3_vfs*, const char *zFilename"
"(sqlite3_vfs*, const char *zName, int flags, int *pResOut"
"(sqlite3_vfs*, const char *zName, int nOut, char *zOut"
"(sqlite3_vfs*, const char *zName, int syncDir"
"(sqlite3_vfs*, double*"
"(sqlite3_vfs*, int makeDflt"
"(sqlite3_vfs*, int microseconds"
"(sqlite3_vfs*, int nByte, char *zErrMsg"
"(sqlite3_vfs*, int nByte, char *zOut"
"(sqlite3_vfs*, int, char *"
"(sqlite3_vfs*, void*"
"(sqlite3_vfs*,int"
"(sqlite3_vfs*,void*, const char *zSymbol"
"(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *"
"(sqlite3_vtab *pVTab, sqlite3_index_info*"
"(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor"
"(sqlite3_vtab *pVtab, const char *zNew"
"(sqlite3_vtab pVTab, int i2, sqlite3_value sv3, sqlite3_int64 v4"
"(sqlite3_vtab pVTab, sqlite3_index_info pIndexInfo"
"(sqlite3_vtab pVTab, sqlite3_vtab_cursor ppCursor"
"(sqlite3_vtab pVtab, int nArg, string zName"
"(sqlite3_vtab pVtab, string zNew"
"(sqlite3_vtab_cursor pCursor, int idmxNum, string idmxStr, int argc, sqlite3_value argv"
"(sqlite3_vtab_cursor pCursor, sqlite3_context ctx, int i3"
"(sqlite3_vtab_cursor pCursor, sqlite3_int64 pRowid"
"(sqlite3_vtab_cursor*, sqlite3_context*, int"
"(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid"
"(static, dynamic etc."
"(stderr, ""INPUT:  %s\n"", zBuf"
"(stderr, ""OUTPUT: %s\n"", zBuf"
"(stdout, ""%10llu "", elapsed"
"(stdout, origPc, p.aOp[origPc]"
"(string X, params object[] ap"
"(string alg, string provider, string chainingMode"
"(string lpSystemName, string lpName, out LUID lpLuid"
"(string pszAlgId, int cbSalt"
"(string zFilename, sqlite3_file pFile"
"(string.Format(""BCrypt.BCryptDecrypt("
"(string.Format(""BCrypt.BCryptGetProperty("
"(string.Format(""BCrypt.BCryptImportKey("
"(string.Format(""BCrypt.BCryptOpenAlgorithmProvider("
"(string.Format(""BCrypt.BCryptSetAlgorithmProperty(BCrypt.BCRYPT_CHAINING_MODE, BCrypt.BCRYPT_CHAIN_MODE_GCM"
"(struct Mem0Global, mem0"
"(struct Sqlite3Config, sqlite3Config"
"(struct sqlite3PrngType, sqlite3Prng"
"(struct sqlite3PrngType, sqlite3SavedPrng"
"(structAddress, VAULT_ITEM"
"(sz == cellSize(pPage, idx"
"(sz == cellSizePtr(pPage, pCell"
"(szNew == cellSizePtr(pPage, newCell"
"(t,v"
"(tag, 0, pbTag, cbTag"
"(tbl,idx,stat"
"(temp, null, DataProtectionScope.CurrentUser"
"(temp, pc, data, cbrk, size"
"(the "".FFF"""
"(the ""X"""
"(the ""Y"""
"(the ""file header"""
"(there are two of them, the main journal and the sub-journal"
"(this, query"
"(u8*, u32"
"(unsigned char*, int, Mem*, int"
"(unsigned char*, u32"
"(unsigned char*, u64"
"(v,  value"
"(v, 0, flags"
"(v, 0, iDb"
"(v, 1, 1, 1, 0"
"(v, 1, iDb"
"(v, 1, pTab.pSchema.schema_cookie"
"(v, 2, flags"
"(v, 2, iDb"
"(v, 2, pTab->tnum"
"(v, 2, pTab->zName, P4_TRANSIENT"
"(v, 3 + flags, iDb"
"(v, 3 + flags, pTab->tnum"
"(v, 3+flags, SQLITE_INT_TO_PTR(pTab->nCol+1"
"(v, 4 - flags, 1"
"(v, 7, pTab->nCol"
"(v, OP_Close, ephemTab, 0"
"(v, OP_Column,  ephemTab, 0, iReg"
"(v, OP_Column, ephemTab, i+1+(pRowid!=0"
"(v, OP_Expire, 0, 0"
"(v, OP_Integer, 1, pDest.iParm"
"(v, OP_Next, ephemTab, addr+1"
"(v, OP_Null, 0, regRowset"
"(v, OP_OpenEphemeral, ephemTab, pTab.nCol+1+(pRowid!=0"
"(v, OP_ParseSchema, iDb, 1, 0, zWhere, P4_DYNAMIC"
"(v, OP_Rewind, ephemTab, 0"
"(v, OP_VBegin, 0, 0, 0, vtab, P4_VTAB"
"(v, OP_VUpdate, 0, 1, iRowid, pVTab, P4_VTAB"
"(v, OP_VUpdate, 0, pTab.nCol+2, iReg, pVTab, P4_VTAB"
"(v, OP_VUpdate, 1, pTab->nCol+2, regIns, pVTab, P4_VTAB"
"(v, addr"
"(v, i, COLNAME_COLUMN, zOrigCol, SQLITE_TRANSIENT"
"(v, i, COLNAME_DATABASE, zOrigDb, SQLITE_TRANSIENT"
"(v, i, COLNAME_TABLE, zOrigTab, SQLITE_TRANSIENT"
"(v, iDb"
"(v, pParse, TK_STRING, yymsp[0].minor.yy0"
"(v, sizeof(openBlob"
"(v,w,x,y,z"
"(va_arg(ap,int*"
"(vaultElementPtr, typeof(VaultCli.VAULT_ITEM_ELEMENT"
"(vaultHandle, 512, ref vaultItemCount, ref vaultItemPtr"
"(vaultHandle, ref schemaId, pResourceElement, pIdentityElement, IntPtr.Zero, 0, ref passwordVaultItem"
"(vaultHandle, ref schemaId, pResourceElement, pIdentityElement, pPackageSid, IntPtr.Zero, 0, ref passwordVaultItem"
"(vm, i"
"(void **, int"
"(void **apArg, int nArg"
"(void *, int sz, int n"
"(void *,int ,char const *,char const *,sqlite3_int64"
"(void *,int"
"(void *K, int L"
"(void *pArg, sqlite3_int64 used,int N"
"(void pArg, sqlite3_int64 used,int N"
"(void*, PgHdr*"
"(void*, int"
"(void*, int, Token, Parse*"
"(void*, int, char**, char**"
"(void*, sqlite3_int64, int"
"(void*, sqlite3_int64,int"
"(void*, void(*"
"(void*,PgHdr*"
"(void*,const char*"
"(void*,const char*,sqlite3_uint64"
"(void*,const char*,sqlite_u3264"
"(void*,const char*,u64"
"(void*,int ,char const*,char const*,sqlite_int64"
"(void*,int"
"(void*,int, const char*,const char*,sqlite_int64"
"(void*,int, const void*, int, const void*"
"(void*,int,char const *,char const *,sqlite_int64"
"(void*,int,char**, char**"
"(void*,int,char**,char**"
"(void*,int,const char*,const char*,const char*,const char*"
"(void*,int,const void*,int,const void*"
"(void*,int,int"
"(void*,sqlite3*,int eTextRep,const char*"
"(void*,sqlite3*,int eTextRep,const void*"
"(void*,sqlite3_int64,int"
"(void*,void*,Pgno,int"
"(w,x,y,z"
"(w,x,y,z,rc"
"(which may be 0, 1 or 2"
"(with ""-DSQLITE_MUTEX_APPDEF=1"""
"(wrFlag == 0 || !hasReadConflicts(p, (u32"
"(wsdAutoext.aExt, nByte"
"(x PRIMARY KEY, y"
"(x, y"
"(x, y, UNIQUE(x, y"
"(x, y, rc"
"(x, y, z"
"(x,1,1"
"(x,p1,p2"
"(x,y"
"(x,y,z"
"(x86 linux, gcc version 4.1.2, -O6"
"(yyParser yypParser, YYMINORTYPE yypMinor"
"(yyTraceFILE, "" %s"", yyTokenName[yypParser.yystack[i].major]"
"(yyTraceFILE, ""%sAccept!\n"", yyTracePrompt"
"(yyTraceFILE, ""%sInput %s\n"", yyTracePrompt, yyTokenName[yymajor]"
"(yyTraceFILE, ""%sShift %d\n"", yyTracePrompt, yyNewState"
"(yyTraceFILE, ""%sStack Overflow!\n"", yyTracePrompt"
"(yyTraceFILE, ""%sStack:"", yyTracePrompt"
"(yyTraceFILE, ""\n"""
"(yyTracePrompt == """""
"(yygotominor.yy346, pParse, TK_ID, yymsp[0].minor.yy0"
"(yygotominor.yy346, pParse, TK_ISNULL, yymsp[-2].minor.yy346, yymsp[0].minor.yy0"
"(yygotominor.yy346, pParse, TK_NOTNULL, yymsp[-2].minor.yy346, yymsp[0].minor.yy0"
"(yygotominor.yy346, pParse, TK_NOTNULL, yymsp[-3].minor.yy346, yymsp[0].minor.yy0"
"(yygotominor.yy346, pParse, TK_UMINUS, yymsp[0].minor.yy346, yymsp[-1].minor.yy0"
"(yygotominor.yy346, pParse, TK_UPLUS, yymsp[0].minor.yy346, yymsp[-1].minor.yy0"
"(yygotominor.yy346, pParse, TK_VARIABLE, yymsp[0].minor.yy0"
"(yygotominor.yy346, pParse, yymsp[-1].major, yymsp[-2].minor.yy346, yymsp[0].minor.yy346"
"(yygotominor.yy346, pParse, yymsp[-1].major, yymsp[0].minor.yy346, yymsp[-1].minor.yy0"
"(yygotominor.yy346, pParse, yymsp[0].major, yymsp[-1].minor.yy346, yymsp[0].minor.yy0"
"(yygotominor.yy346, pParse, yymsp[0].major, yymsp[0].minor.yy0"
"(yygotominor.yy346, yymsp[-2].minor.yy0, yymsp[0].minor.yy0"
"(yygotominor.yy346, yymsp[-3].minor.yy0, yymsp[0].minor.yy0"
"(yygotominor.yy346, yymsp[-4].minor.yy0, yymsp[0].minor.yy0"
"(yygotominor.yy346, yymsp[-5].minor.yy0, yymsp[0].minor.yy0"
"(yygotominor.yy346, yymsp[0].minor.yy0, yymsp[0].minor.yy0"
"(yygotominor.yy346.pExpr, EP_xIsSelect"
"(yyminorunion, 0, yyminorunion"
"(yymsp[-yysize].stateno, (YYCODETYPE"
"(yypParser, (YYCODETYPE"
"(yypParser, yyact - YYNSTATE"
"(yypParser, yyact, yygoto, yygotominor"
"(yypParser, yyact, yymajor, yyminorunion"
"(yypParser, yymajor, yyminorunion"
"(yypParser, yyminorunion"
"(yypParser, yypMinor"
"(yypParser,(YYCODETYPE"
"(yypParser,yyact,YYERRORSYMBOL,u2"
"(yypParser,yymajor,yyminorunion"
"(z, (const u8**"
"(z, argv[i], n"
"(z, c"
"(z, i"
"(z, p.aCol[i].zName"
"(z, pResult"
"(z, zName"
"(zBuf, &p->zBuf[iOfst], iAmt"
"(zBuf, 20, zFormat, pTm"
"(zBuf, 20, zFormat, sNow"
"(zConverted, 0, 0, 0"
"(zConverted, nByte, zTemp, 0"
"(zCopy, zName, nName+1"
"(zCsr, 0, zEnd-zCsr"
"(zDbHeader, 16"
"(zDbHeader, 36 + 4 * 4"
"(zDbHeader, 36 + 7 * 4"
"(zFilename != """" && !isMemdb"
"(zFilename=="""""
"(zHeader, aJournalMagic, sizeof(aJournalMagic"
"(zIdx, aType[i]"
"(zIn, (const u8**"
"(zIn, c"
"(zIn, zTerm, (const u8**"
"(zIn, zTerm, c"
"(zLeft, ""hexrekey"""
"(zName, nArg, arg, flags"
"(zName, nArg, arg, nc, xStep, xFinal"
"(zName, nArg, iArg, bNC, xFunc"
"(zName, nArg, iArg, bNC, xStep, xFinal"
"(zName, nArg, pArg, bNC, xFunc"
"(zName, nArg, pArg, flags"
"(zName, nName"
"(zName, pFile"
"(zNew, z, n"
"(zOut, (int"
"(zOut, c"
"(zRelative, zFull"
"(zSql, chars_parsed"
"(zSql.Substring( i,zSql.Length-i "
"(zSql8, (int"
"(zVfs, pVfs.zName"
"(z[*pnEntry * szEntry], 0, szEntry"
( 
(   
(   (   ((rc = GetFileAttributesA(zConverted
(   (   ((rc = GetFileAttributesW(zConverted
(  (((u8*
(  pPager.state>=PAGER_SHARED && 0==MEMDB 
(  sqlite3GlobalConfig.bCoreMutex   
(  sqlite3GlobalConfig.bMemstat 
(  sqlite3GlobalConfig.mutex.xMutexAlloc != null 
(  sqlite3GlobalConfig.pHeap==0 
( ! sqlite3GlobalConfig.bCoreMutex   
( !( ( ( c = (byte
( !( p.approx | p.overflow != 0 
( !( pDest.eDest <= SRT_Discard 
( !( pIdx.onError == OE_Default || pIndex.onError == OE_Default 
( !(p.db.flags&SQLITE_ReadUncommitted
( !DIRECT_MODE && ALWAYS( rc == SQLITE_OK 
( !ExprHasProperty( ( pExpr = pTerm.pExpr 
( !File.Exists( zFilename 
( !IN_DECLARE_VTAB 
( !IgnorableOrderby(pDest
( !IsVirtual( pTab 
( !SAVEPOINT_BEGIN && SAVEPOINT_RELEASE==1 && SAVEPOINT_ROLLBACK==2 
( !SetEndOfFile( pFile->h 
( !String.IsNullOrEmpty( z 
( !String.IsNullOrEmpty( zExtra 
( !String.IsNullOrEmpty( zFilename 
( !String.IsNullOrEmpty( zRight 
( !String.IsNullOrEmpty( zTrace 
( !aOvflSpace 
( !aVTrans 
( !appendFlag 
( !db 
( !db || pRet 
( !db->init.busy 
( !db->mallocFailed 
( !db->pVTab 
( !done && _fmt < fmt.Length - 1 && ( c = ( fmt[++_fmt] 
( !dwRet 
( !flag_leftjustify 
( !id.fs.CanRead 
( !isAgg && pGroupBy == null 
( !isDistinct 
( !isErrorReset 
( !isFatalError( p.rc 
( !isFatalError( rc 
( !isOpen( pJournal 
( !isOpen( pPager.fd 
( !isOpen( pPager.jfd 
( !isPrepareV2 
( !isRowid 
( !isView 
( !isView && !IsVirtual( pTab 
( !isView || pTrigger != null 
( !max && cmp > 0 
( !needQuote 
( !needSync && 0 == sqlite3BtreeSyncDisabled( pBt 
( !p 
( !p || (p->locked==0 && p->sharable
( !p->locked 
( !p->locked || p->wantToLock>0 
( !p->sharable 
( !p.aConstraint[i].usable && p.aConstraintUsage[i].argvIndex>0 
( !p.affChange || allowAffChng 
( !p.isSorted 
( !p.readOnly 
( !p.readOnly || mrc != SQLITE_INTERRUPT 
( !p.sharable 
( !p.useMalloc 
( !pBt.pWriter 
( !pC.deferredMoveto 
( !pC.ephemPseudoTable 
( !pC.isTable 
( !pC.nullRow 
( !pC.pseudoTable 
( !pC.rowidIsValid 
( !pC.useRandomRowid 
( !pCsr.pBt.readOnly && pCsr.pBt.inTransaction==TRANS_WRITE 
( !pCsr.wrFlag 
( !pCx.deferredMoveto 
( !pCx.ephemPseudoTable 
( !pLater->locked || pLater->wantToLock>0 
( !pLock 
( !pMem.xDel 
( !pMod 
( !pOrderBy 
( !pPager.changeCountDone && ALWAYS(pPager.dbSize > 0 
( !pPager.dbModified 
( !pPager.dbModified || !isOpen( pPager.jfd 
( !pPager.doNotSync 
( !pPager.exclusiveMode 
( !pPager.exclusiveMode || pPager.journalOff > 0 
( !pPager.exclusiveMode || sqlite3IsMemJournal( pPager.sjfd 
( !pPager.journalStarted && !pPager.noSync 
( !pPager.noSync 
( !pPager.noSync && !noSync 
( !pPager.tempFile 
( !pPager.tempFile && isOpen( pPager.fd 
( !pPtr 
( !pTab 
( !pTab->aCol 
( !pVTab 
( !pVTable 
( !pVtab.zErrMsg 
( !pageInJournal( pPg 
( !prevEscape && c == matchAll 
( !prevEscape && c == matchOne 
( !rc && ++cnt < MX_CLOSE_ATTEMPT 
( !res 
( !sCheck.anRef 
( !seenReplace 
( !shortNames && !fullNames 
( !sqlite3BtreeIsInReadTrans( pBt 
( !sqlite3BtreeIsInReadTrans( pDb.pBt 
( !sqlite3IsNaN( pOp.p4.pReal 
( !sqlite3Isalnum( zIdent[j] 
( !sqlite3Isdigit( inStr[i] 
( !sqlite3Isdigit( z2[z2Index] 
( !sqlite3Isdigit( zDate[zIndex] 
( !sqlite3Isdigit( zNum[i] 
( !sqlite3Isdigit( z[iOffset + 1] 
( !sqlite3Isdigit( z[zIndex] 
( !sqlite3Isxdigit( c 
( !sqlite3SafetyCheckOk( db 
( !sqlite3SafetyCheckOk(db
( !sqlite3SafetyCheckSickOrOk( db 
( !sqlite3SafetyCheckSickOrOk(db
( !sqlite3VtabInSync( db 
( !sqlite3WhereTrace 
( !sqlite3_mutex_held(db->mutex
( !subjRequiresPage( pPg 
( !useJournal 
( !useTempTable 
( !winMutex_isInit 
( !wsdPrng.isInit 
( !z 
( !zCollSeq 
( !zFullPathname 
( !zMaster && isOpen(pPager.jfd
( !zMasterJournal 
( !zModuleName 
( !zOut 
( !zType 
( &(*ppFrom
( &mem1 
( &pIndex->aSortOrder[nCol] 
( &pIndex.zName[nName + 1] 
( &zBuf[k] 
( ' ' 
( '%' 
( '(' 
( '.' 
( '[' 
( '\'' 
( '\0' 
( ']' 
( 'e' 
( 's' 
( 't' 
( 'z' 
( ( ( ( x.iJD + 129600000 
( ( ( (i64
( ( ( (sbyte
( ( ( (u64
( ( ( *( pOut++ 
( ( ( BITVEC_SZ - ( 3 * sizeof( u32 
( ( ( X 
( ( ( buf[0] 
( ( ( c & 0x80 
( ( ( c - 1 
( ( ( flags & MEM_Str 
( ( ( i64 
( ( ( pExpr.op - TK_GT 
( ( ( pIn1.flags & ( MEM_Str | MEM_Blob 
( ( ( pIn1.flags | pIn2.flags 
( ( ( pIn2.flags & ( MEM_Str | MEM_Blob 
( ( ( pNew.nCol - 1 
( ( ( pPg.flags & PGHDR_NEED_SYNC 
( ( ( x.iJD + 43200000 
( ( (Bitmask
( ( (sbyte
( ( (sqlite3_int64
( ( (u32
( ( (u64
( ( (u8*
( ( *( pCell++ 
( ( *(void**
( ( *zIn & 0xc0 
( ( --aOp[pc + 1] 
( ( --pOther.nChild 
( ( 1 << (int
( ( 36525 * C 
( ( B - 122.1 
( ( B - D 
( ( MEM_Blob >> 3 
( ( OMIT_TEMPDB == 0 
( ( OMIT_TEMPDB == 0 || i != 1 
( ( P.flags & MEM_Zero 
( ( PENDING_BYTE / ( ( x 
( ( WO_EQ << ( op - TK_EQ 
( ( X1 + X2 + D + B - 1524.5 
( ( Z - 1867216.25 
( ( _p4.pVtab 
( ( _z < z.Length 
( ( a.wtFlags & TERM_ANDINFO 
( ( a.wtFlags & TERM_DYNAMIC 
( ( a.wtFlags & TERM_ORINFO 
( ( aMem[ii].flags & MEM_Null 
( ( aMem[nField].flags & MEM_Null 
( ( addr >= 0 && addr < p.nOp 
( ( andFlags & WHERE_UNIQUE 
( ( argc == 0 || SQLITE_NULL != sqlite3_value_type( argv[0] 
( ( bestPlan.plan.wsFlags & WHERE_INDEXED 
( ( bestPlan.plan.wsFlags & WHERE_ORDERBY 
( ( buf[0] << 24 
( ( buf[2] << 24 
( ( buf[4] << 24 
( ( buf[offset + 0] << 24 
( ( buf[offset + 2] << 24 
( ( buf[offset + 4] << 24 
( ( c = (byte
( ( c = C 
( ( c = pToken.z[0] 
( ( chngToIN & ( chngToIN - 1 
( ( combined_flags & ( MEM_Int | MEM_Real 
( ( combined_flags & MEM_Null 
( ( combined_flags & MEM_RowSet 
( ( combined_flags & MEM_Str 
( ( count + 1 
( ( ctx.pFunc.flags & SQLITE_FUNC_NEEDCOLL 
( ( db.aDb[j].pSchema.trigHash 
( ( db.flags & SQLITE_CountRows 
( ( db.flags & SQLITE_FullFSync 
( ( db.flags & SQLITE_InTrans 
( ( db.flags & SQLITE_InternChanges 
( ( db.flags & SQLITE_LoadExtension 
( ( db.flags & SQLITE_NoReadlock 
( ( db.flags & SQLITE_SqlTrace 
( ( eType = sqlite3_value_type( argv[0] 
( ( enc & 3 
( ( enc & SQLITE_UTF16_ALIGNED 
( ( enc == SQLITE_UTF16LE && p.iPrefEnc == SQLITE_UTF16BE 
( ( error = GetLastError(
( ( f & ( MEM_Dyn | MEM_Ephem 
( ( f & ( MEM_Static | MEM_Dyn 
( ( f & ( MEM_Static | MEM_Ephem 
( ( f & ( MEM_Str | MEM_Blob 
( ( f & MEM_Blob 
( ( f & MEM_Dyn 
( ( f & MEM_Ephem 
( ( f & MEM_Static 
( ( f & MEM_Str 
( ( f & MEM_Zero 
( ( f1 & ( MEM_Int | MEM_Real 
( ( f1 & MEM_Int 
( ( f1 & MEM_Real 
( ( f1 & MEM_Str 
( ( f1 & f2 & MEM_Int 
( ( f2 & ( MEM_Int | MEM_Real 
( ( f2 & MEM_Int 
( ( f2 & MEM_Real 
( ( f2 & MEM_Str 
( ( fg & ( MEM_Int | MEM_Real 
( ( fg & ( MEM_Str | MEM_Blob 
( ( fg & MEM_Int 
( ( fg & MEM_Real 
( ( fg & MEM_Zero 
( ( flags & ( MEM_Str | MEM_Blob 
( ( flags & 1 
( ( flags & 2 
( ( flags & EXPRDUP_REDUCE 
( ( flags & MEM_Int 
( ( flags & MEM_Null 
( ( flags & MEM_Real 
( ( flags & MEM_Str 
( ( flags & MEM_Term 
( ( flags & SQLITE_OPEN_CREATE 
( ( flags & SQLITE_OPEN_DELETEONCLOSE 
( ( flags & SQLITE_OPEN_EXCLUSIVE 
( ( flags & SQLITE_OPEN_FULLMUTEX 
( ( flags & SQLITE_OPEN_NOMUTEX 
( ( flags & SQLITE_OPEN_READWRITE 
( ( flags & SQLITE_SYNC_FULL 
( ( flags >> 16 
( ( flags >> 8 
( ( flags | SQLITE_OPEN_READONLY 
( ( fs == null 
( ( h >= '0' && h <= '9' 
( ( i & 0x7fffffff 
( ( i < 32 && ( new_col_mask & ( (u32
( ( i == 0 && ppOrderBy != null 
( ( i > 31 || ( mask & ( ( (u32
( ( i >= 0 && i <= 2 
( ( iDestroyed == 0 || ( iIdx < iDestroyed 
( ( iOff / nSrcPagesize 
( ( iOffset + i 
( ( iOffset + i == z.Length && c != delim 
( ( iPageSize - 1 
( ( iSectorSize - 1 
( ( iVal << 1 
( ( ii == pOrWc.nTerm - 1 
( ( infop.flags & FLAG_SIGNED 
( ( isMainJrnl & ~1 
( ( isSavepnt & ~1 
( ( jointype & JT_OUTER 
( ( k >= pAggInfo.nColumn 
( ( len = (u32
( ( locktype == EXCLUSIVE_LOCK 
( ( locktype == RESERVED_LOCK 
( ( lowerBits == INVALID_FILE_SIZE 
( ( m & notReady 
( ( m - 1 
( ( mask & pParse.cookieMask 
( ( max && cmp < 0 
( ( mem1.flags & MEM_Int 
( ( microsec + 999 
( ( mrc == SQLITE_NOMEM || mrc == SQLITE_FULL 
( ( n * 2 
( ( nByte >> 32 
( ( null == pColl 
( ( offset - c 
( ( offset >> 32 
( ( once != 0 && doNotReorder != 0 
( ( op & 1 
( ( op = aOp[pc] 
( ( op == SAVEPOINT_ROLLBACK 
( ( op == TK_AGG_COLUMN || op == TK_COLUMN || op == TK_REGISTER 
( ( op == TK_INTEGER || op == TK_FLOAT 
( ( opProperty & OPFLG_IN1 
( ( opProperty & OPFLG_IN2 
( ( opProperty & OPFLG_IN3 
( ( opProperty & OPFLG_OUT2_PRERELEASE 
( ( opProperty & OPFLG_OUT3 
( ( p = pCache.pDirty 
( ( p = pParse.pNewTable 
( ( p.btreeMask & ( 1 << iDb 
( ( p.btreeMask & ( 1 << p1 
( ( p.btreeMask & ( 1 << pOp.p1 
( ( p.btreeMask & ( 1 << pOp.p2 
( ( p.btreeMask & ( 1 << pOp.p5 
( ( p.btreeMask & mask 
( ( p.db.flags & SQLITE_VdbeListing 
( ( p.flags & ( MEM_Agg | MEM_Dyn | MEM_RowSet 
( ( p.flags & ( MEM_Blob | MEM_Str 
( ( p.flags & ( MEM_Int | MEM_Str 
( ( p.flags & ( MEM_Str | MEM_Blob 
( ( p.flags & EP_FixedDest 
( ( p.flags & EP_IntValue 
( ( p.flags & MEM_Agg 
( ( p.flags & MEM_Blob 
( ( p.flags & MEM_Dyn 
( ( p.flags & MEM_Int 
( ( p.flags & MEM_Null 
( ( p.flags & MEM_Real 
( ( p.flags & MEM_RowSet 
( ( p.flags & MEM_Zero 
( ( p.flags & PGHDR_DIRTY 
( ( p.flags & UNPACKED_NEED_DESTROY 
( ( p.flags & UNPACKED_NEED_FREE 
( ( p.flags2 & EP2_Irreducible 
( ( p.flags2 & EP2_MallocedToken 
( ( p.iJD + 129600000 
( ( p.iJD + 43200 
( ( p.iJD + 43200000 
( ( p.iSize > BITVEC_NBIT 
( ( p.isWriteLock != 0 || isWriteLock != 0 
( ( p.nCol & 0x7 
( ( p.op == TK_COLUMN || p.op == TK_AGG_COLUMN 
( ( p.readOnly == false 
( ( p.selFlags & ( SF_Distinct | SF_Aggregate 
( ( p.selFlags & SF_Aggregate 
( ( p.selFlags & SF_Distinct 
( ( p.selFlags & SF_Expanded 
( ( p.selFlags & SF_HasTypeInfo 
( ( p.selFlags & SF_Resolved 
( ( p.selFlags & SF_UsesEphemeral 
( ( p.tabFlags & TF_Autoincrement 
( ( p.tz != 0 
( ( p.u.aBitmap[i / BITVEC_SZELEM] & ( 1 << (int
( ( p5 & SQLITE_AFF_MASK 
( ( pA.flags & EP_Distinct 
( ( pAggInfo.aFunc[0].pFunc.flags & SQLITE_FUNC_COUNT 
( ( pBt.pageSize - 8 
( ( pBuf << 8 
( ( pC.cacheStatus == p.cacheCtr 
( ( pColl.enc & ~SQLITE_UTF16_ALIGNED 
( ( pColl.type != SQLITE_COLL_BINARY || pnoCase 
( ( pCost.plan.wsFlags & WHERE_INDEXED 
( ( pCrsr = pC.pCursor 
( ( pCtx.s.flags & MEM_Null 
( ( pData.flags & ( MEM_Blob | MEM_Str 
( ( pData.flags & MEM_Null 
( ( pData.flags & MEM_Zero 
( ( pDef.flags & SQLITE_FUNC_NEEDCOLL 
( ( pDest.flags & ( MEM_Blob | MEM_Str 
( ( pDest.flags & MEM_Dyn 
( ( pDest.flags & MEM_Null 
( ( pDest.iPKey < 0 && pDest.pIndex != null 
( ( pDest.tabFlags & TF_Autoincrement 
( ( pDest.tabFlags & TF_Virtual 
( ( pDup.flags & ( EP_Reduced | EP_TokenOnly 
( ( pEnd == null && pSelect == null 
( ( pEnd.flags & ( MEM_Agg | MEM_Dyn 
( ( pExpr.flags & EP_AnyAff 
( ( pExpr.flags & EP_Distinct 
( ( pExpr.flags & EP_ExpCollate 
( ( pExpr.flags & EP_IntValue 
( ( pExpr.flags & EP_xIsSelect 
( ( pExpr.iTable & 0x0000FFFF 
( ( pExpr.op + ( TK_ISNULL & 1 
( ( pExpr.pLeft.flags & ~EP_ExpCollate 
( ( pExpr.pRight.flags & ~EP_ExpCollate 
( ( pExpr.x.pList.nExpr % 2 
( ( pF.pFunc.flags & SQLITE_FUNC_NEEDCOLL 
( ( pFrom.flags & MEM_Dyn 
( ( pFrom.flags & MEM_RowSet 
( ( pIdx.aiColumn[0] == iCol 
( ( pIdx.flags & MEM_RowSet 
( ( pIn1.flags & ( MEM_Null | MEM_Int | MEM_Real 
( ( pIn1.flags & MEM_Blob 
( ( pIn1.flags & MEM_Dyn 
( ( pIn1.flags & MEM_Int 
( ( pIn1.flags & MEM_Null 
( ( pIn1.flags & MEM_RowSet 
( ( pIn1.flags & MEM_Str 
( ( pIn1.flags & pIn2.flags & MEM_Int 
( ( pIn2.flags & MEM_Blob 
( ( pIn2.flags & MEM_Null 
( ( pIn3.flags & MEM_Blob 
( ( pIn3.flags & MEM_Int 
( ( pIn3.flags & MEM_Null 
( ( pIn3.flags & MEM_Real 
( ( pItem = pList.a[i] 
( ( pItem.pExpr.flags & EP_Agg 
( ( pKey.flags & MEM_Int 
( ( pLeft.flags & EP_ExpCollate 
( ( pLevel.plan.wsFlags & ( WHERE_BTM_LIMIT | WHERE_TOP_LIMIT 
( ( pLevel.plan.wsFlags & ( WHERE_COLUMN_RANGE | WHERE_COLUMN_EQ 
( ( pLevel.plan.wsFlags & ( WHERE_ROWID_EQ | WHERE_ROWID_RANGE 
( ( pLevel.plan.wsFlags & WHERE_BTM_LIMIT 
( ( pLevel.plan.wsFlags & WHERE_IDX_ONLY 
( ( pLevel.plan.wsFlags & WHERE_INDEXED 
( ( pLevel.plan.wsFlags & WHERE_IN_ABLE 
( ( pLevel.plan.wsFlags & WHERE_MULTI_OR 
( ( pLevel.plan.wsFlags & WHERE_ORDERBY 
( ( pLevel.plan.wsFlags & WHERE_ROWID_EQ 
( ( pLevel.plan.wsFlags & WHERE_ROWID_RANGE 
( ( pLevel.plan.wsFlags & WHERE_TOP_LIMIT 
( ( pLevel.plan.wsFlags & WHERE_VIRTUALTABLE 
( ( pListItem.sortOrder & sortOrderMask 
( ( pMem.flags & ( MEM_Blob | MEM_Str 
( ( pMem.flags & ( MEM_Int | MEM_Real | MEM_Null 
( ( pMem.flags & ( MEM_Str | MEM_Blob 
( ( pMem.flags & MEM_Agg 
( ( pMem.flags & MEM_Blob 
( ( pMem.flags & MEM_Dyn 
( ( pMem.flags & MEM_Int 
( ( pMem.flags & MEM_Null 
( ( pMem.flags & MEM_Real 
( ( pMem.flags & MEM_RowSet 
( ( pMem.flags & MEM_Str 
( ( pMem.flags & MEM_Term 
( ( pMem.flags & MEM_Zero 
( ( pMem.flags & ~( MEM_Null | MEM_Agg 
( ( pMem1.flags & MEM_Blob 
( ( pOp.p2 & OPFLAG_NCHANGE 
( ( pOp.p5 & OPFLAG_ISUPDATE 
( ( pOp.p5 & OPFLAG_LASTROWID 
( ( pOp.p5 & OPFLAG_NCHANGE 
( ( pOp.p5 & OPFLAG_USESEEKRESULT 
( ( pOp.p5 & SQLITE_JUMPIFNULL 
( ( pOp.p5 & SQLITE_STOREP2 
( ( pOrTerm.eOperator & WO_SINGLE 
( ( pOrTerm.wtFlags & ( TERM_ANDINFO | TERM_ORINFO 
( ( pOrTerm.wtFlags & ( TERM_COPIED | TERM_VIRTUAL 
( ( pOrTerm.wtFlags & TERM_COPIED 
( ( pOrTerm.wtFlags & TERM_OR_OK 
( ( pOrTerm.wtFlags & TERM_VIRTUAL 
( ( pOrig.flags & EP_Resolved 
( ( pOut.flags & MEM_Ephem 
( ( pOut.flags & MEM_Static 
( ( pPKey2.flags & UNPACKED_IGNORE_ROWID 
( ( pPKey2.flags & UNPACKED_INCRKEY 
( ( pPKey2.flags & UNPACKED_PREFIX_MATCH 
( ( pPKey2.flags & UNPACKED_PREFIX_SEARCH 
( ( pPage 
( ( pPage = pNext 
( ( pPage = pp 
( ( pPage.flags & PGHDR_NEED_SYNC 
( ( pPage.pCache.bPurgeable ? 1 : 0 
( ( pPager.memDb == 0 || pPager.dbSize == 0 
( ( pPager.noSync 
( ( pPager.state == PAGER_SHARED 
( ( pPager.state >= PAGER_EXCLUSIVE 
( ( pPager.state >= locktype 
( ( pParse.cookieMask & mask 
( ( pParse.db.flags & SQLITE_ReverseOrder 
( ( pParse.trigStack != null 
( ( pPg.flags & PGHDR_DIRTY 
( ( pPg.flags & PGHDR_NEED_SYNC 
( ( pPg.pgno - 1 
( ( pRangeEnd != null || nEq != 0 
( ( pRec.flags & ( MEM_Blob | MEM_Str 
( ( pRec.flags & ( MEM_Real | MEM_Int 
( ( pRec.flags & MEM_Real 
( ( pRec.flags & MEM_Str 
( ( pRec.flags & MEM_Zero 
( ( pRight.flags & EP_ExpCollate 
( ( pRight.jointype & JT_NATURAL 
( ( pSelect.selFlags & SF_Distinct 
( ( pSelect.selFlags & SF_Resolved 
( ( pSrc.jointype & JT_LEFT 
( ( pSrc.tabFlags & TF_Virtual 
( ( pSrcList.a[i + 1].jointype & JT_NATURAL 
( ( pStart == null && pEnd == null 
( ( pSub.selFlags & SF_Distinct 
( ( pSub1.selFlags & ( SF_Distinct | SF_Aggregate 
( ( pSubitem.jointype & JT_OUTER 
( ( pTab = pParse.pNewTable 
( ( pTab.tabFlags & TF_Autoincrement 
( ( pTab.tabFlags & TF_Ephemeral 
( ( pTab.tabFlags & TF_HasPrimaryKey 
( ( pTab.tabFlags & TF_Readonly 
( ( pTabList.a[i].jointype & JT_NATURAL 
( ( pTerm.eOperator & ( WO_ISNULL | WO_IN 
( ( pTerm.eOperator & WO_EQ 
( ( pTerm.eOperator & WO_IN 
( ( pTerm.eOperator & WO_ISNULL 
( ( pTerm.flags & EP_ExpCollate 
( ( pTerm.prereqAll & notReady 
( ( pTerm.prereqAll & ~maskSrc 
( ( pTerm.wtFlags & ( TERM_DYNAMIC | TERM_ORINFO | TERM_ANDINFO 
( ( pTerm.wtFlags & ( TERM_VIRTUAL | TERM_CODED 
( ( pTerm.wtFlags & TERM_CODED 
( ( pTerm.wtFlags & TERM_ORINFO 
( ( pTo.flags & ( MEM_Str | MEM_Blob 
( ( pTrigger != null && tmask != 0 
( ( pUnpacked.flags & UNPACKED_IGNORE_ROWID 
( ( pUsing = pSrcList.a[i + 1].pUsing 
( ( pVal.flags & ( MEM_Ephem | MEM_Static 
( ( pVal.flags & MEM_Blob 
( ( pVal.flags & MEM_Int 
( ( pVal.flags & MEM_Null 
( ( pVal.flags & MEM_RowSet 
( ( pVal.flags & MEM_Str 
( ( pVal.flags & MEM_Zero 
( ( pValue.flags & MEM_Zero 
( ( pWInfo.wctrlFlags & WHERE_OMIT_CLOSE 
( ( pWalker.u.i 
( ( pX = pExpr.pLeft 
( ( p[0 + offset] << 24 
( ( p[0] << 24 
( ( pg1 + nPage 
( ( pg1 + nPagePerSector - 1 
( ( pnErr.flags & ( MEM_Str | MEM_Blob 
( ( pnErr.flags & MEM_Int 
( ( ppLast 
( ( ppPage 
( ( precision-- 
( ( prefix != '\0' 
( ( prereqExpr & prereqColumn 
( ( r - y 
( ( r.flags & UNPACKED_PREFIX_SEARCH 
( ( rNow - (int
( ( rc & ( v.db.errMask 
( ( rc & 0xFF 
( ( rc & 0xff 
( ( rc & db.errMask 
( ( rc & p.db.errMask 
( ( rc = sqlite3Step( v 
( ( rc == INVALID_FILE_ATTRIBUTES 
( ( rc == SQLITE_OK || ( rc == SQLITE_SCHEMA && ( ++nRetry 
( ( resultType = CSSQLite.sqlite3_step( vm
( ( s1 & s2 & ~s3 
( ( serial_type & 0x01 
( ( serial_type - 12 
( ( serial_type1 = aKey1[idx1] 
( ( sqlite3PcacheRefCount( pPager.pPCache 
( ( sqlite3UpperToLower[z[iOffset + 0]] 
( ( sqlite3_current_time.iValue 
( ( sqlite3_io_error_persist.iValue != 0 && sqlite3_io_error_hit.iValue != 0 
( ( sz + 7 
( ( szHdr1 = aKey1[0] 
( ( szJ - JOURNAL_HDR_SZ( pPager 
( ( szJ - pPager.journalOff 
( ( tmask & TRIGGER_BEFORE 
( ( v & ( ( (u64
( ( v & 0x7f 
( ( v & ~0x3fff 
( ( v & ~0x7f 
( ( v = sqlite3GetVdbe( pParse 
( ( v >> 7 
( ( v64 & SQLITE_MAX_U32 
( ( vfsFlags & SQLITE_OPEN_MAIN_DB 
( ( wctrlFlags & WHERE_DUPLICATES_OK 
( ( wctrlFlags & WHERE_ONEPASS_DESIRED 
( ( wctrlFlags & WHERE_ORDERBY_MIN 
( ( wsFlags & ( WHERE_COLUMN_IN | WHERE_COLUMN_NULL 
( ( x = (int
( ( x.iJD - y.iJD + 43200000 
( ( xDel == SQLITE_STATIC 
( ( xtype == etSQLESCAPE3 
( ( zCharSet = sqlite3_value_text( argv[1] 
( ( zJournal - zMasterJournal 
( ( zSql = zLeftover 
( ( z[iOffset + i + 1] == '+' || z[iOffset + i + 1] == '-' 
( (!aDyn && nArg==(int
( (((u64
( ((P
( (*(zIn++
( (*zIn & 0xc0
( (Bitmask
( (CollSeq[]
( (Mem
( (O=(char*
( (PCache1
( (Pgno
( (SQLITE_BIG_DBL/((double
( (VTable
( (Vdbe
( (WCHAR*
( (__GNUC__
( (byte[]
( (char
( (char*
( (compareInfo
( (db->nVTrans%ARRAY_INCR
( (double
( (dxalarmCallback
( (flags & (SQLITE_OPEN_READWRITE|SQLITE_OPEN_MAIN_DB
( (h&0x00FFFFFF
( (i&0xFFFFFFFE
( (i64
( (iAmt+iOfst
( (int
( (isTemp & 1
( (long
( (m.flags & MEM_Str
( (m.flags & MEM_Term
( (n&0x7fffffff
( (nReq<0 || nFree<nReq
( (offset-c
( (p->locked==0 && p->sharable
( (pBtree.sharable==null
( (pIter++
( (pLevel.plan.wsFlags & WHERE_VIRTUALTABLE
( (pMem->flags&MEM_RowSet
( (pMem->n+(desiredEnc==SQLITE_UTF8?1:2
( (pMem.flags&MEM_Str 
( (pSib = db.aDb[i].pBt
( (pTab->tabFlags & TF_Virtual
( (pTerm.eOperator&(pTerm.eOperator-1
( (ppPage
( (rc&0xff
( (sCheck.nPage+1
( (size_t
( (sqlite3
( (sqlite3_file
( (sqlite3_io_error_persist && sqlite3_io_error_hit
( (sqlite3_stmt
( (sqlite3_value
( (u32
( (u64
( (u8
( (u8*
( (wrflag && pBt.inTransaction==TRANS_WRITE
( (z-zBuf
( (zLeft[3] & 0xf
( *a!=0 && UpperToLower[*a]==UpperToLower[*b]
( *p == '\\' 
( *pp==db 
( *z!=0 && z<zTerm 
( *z2 
( *zNum=='+' 
( *zNum=='-' 
( ++pParse.nAlias 
( +1 
( --bufpt 
( -1 
( -1 - p2 
( -1 - pOp.p2 < p.nLabel 
( -10 
( -11 
( -12 
( -13 
( -14 
( -15 
( -16 
( -17 
( -2 
( -4 
( -5 
( -6 
( -7 
( -8 
( -9 
( /*  0 == db.mallocFailed && */  ( db.flags & SQLITE_RecoveryMode 
( /*  0 == db.mallocFailed && */  i < zSql.Length 
( /* db.mallocFailed != 0 || */ IN_DECLARE_VTAB 
( /* db.mallocFailed != 0 || */ pItem.pExpr == pSpan.pExpr 
( /* pMem.db.mallocFailed != 0 || */ ( flags & ( MEM_Str | MEM_Blob 
( /* pParse.nErr != 0 || */ db.mallocFailed != 0 
( /*db != null && db.mallocFailed != 0 || */ rc == SQLITE_IOERR_NOMEM 
( //( p[1] 
( 0 
( 0 == ( ( p.flags | pNew.flags 
( 0 == ( a & 0x80 
( 0 == ( b & 0x80 
( 0 == ( cntTab++ 
( 0 == ( flags & EXPRDUP_REDUCE 
( 0 == ( flags & SQLITE_OPEN_EXCLUSIVE 
( 0 == ( iDc & SQLITE_IOCAP_SAFE_APPEND 
( 0 == ( iDc & SQLITE_IOCAP_SEQUENTIAL 
( 0 == ( p.flags & PGHDR_DIRTY 
( 0 == ( pFrom.flags & MEM_Static 
( 0 == ( pMem.flags & MEM_Dyn 
( 0 == ( pRec.flags & MEM_Str 
( 0 == alreadyExists 
( 0 == callbackIsInit 
( 0 == createFlag && pBest == null 
( 0 == db.autoCommit 
( 0 == db.autoCommit || sqlite3BtreeIsInReadTrans( db.aDb[1].pBt 
( 0 == db.init.busy 
( 0 == db.init.busy && ( v = sqlite3GetVdbe( pParse 
( 0 == db.init.busy || pSelect == null 
( 0 == db.mallocFailed 
( 0 == desiredAutoCommit 
( 0 == firstTerm 
( 0 == initbusy && ( pColl == null || pColl.xCmp == null 
( 0 == isMainJrnl && pPg == null 
( 0 == isSavepnt 
( 0 == isTransaction 
( 0 == isView && !IsVirtual( pTab 
( 0 == isView && pTab.pSelect != null 
( 0 == okOnePass 
( 0 == omitTable 
( 0 == p.file_format 
( 0 == p.isAttached 
( 0 == p.okVar 
( 0 == p.u.aHash[h] 
( 0 == p.validJD 
( 0 == pItem.isPopulated 
( 0 == pItem.notIndexed && pItem.zIndex == null 
( 0 == pPage.nRef 
( 0 == pPager.setMaster 
( 0 == pWInfo.okOnePass && ( pLevel.plan.wsFlags & WHERE_IDX_ONLY 
( 0 == pWInfo.okOnePass && pTab.nCol < BMS 
( 0 == r 
( 0 == res 
( 0 == sqlite3Strlen30( sqlite3BtreeGetFilename( db.aDb[0].pBt 
( 0 == useIndexOnly || j < pIdx.nColumn 
( 0==( a&0x80
( 0==(1&SQLITE_PTR_TO_INT(pVal->z
( 0==(dc&(SQLITE_IOCAP_ATOMIC|(szPage>>8
( 0==(p.db.flags&SQLITE_ReadUncommitted
( 0==MEMDB 
( 0==MEMDB && !pPager.tempFile 
( 0==db->pBlockingConnection 
( 0==db.mallocFailed 
( 0==db.mallocFailed && rc==SQLITE_OK
( 0==db.mallocFailed && rc==SQLITE_OK 
( 0==pPage.leaf 
( 0==pTable->pIndex 
( 0x3f & *( zIn++ 
( 0x3f & zIn[zIndex++] 
( 0x7f 
( 0x7f << 14 
( 0xffffffff | ( ( (i64
( 1 
( 1 & ( h >> 6 
( 1 & ( pVal.z[0] 
( 1 + ( ( !pCache.bPurgeable || null == pCache.pDirty 
( 1 + bRev 
( 1 + sqlite3Strlen30( pColl.zName 
( 1 << ( I & 7 
( 1 << (int
( 1 << i 
( 1 << iDb 
( 100 
( 12 
( 16 
( 2 
( 2 * nBlob + 4 
( 20 
( 200 
( 255 
( 255 < ( nName = sqlite3Strlen30( zFunctionName 
( 30.6001 * E 
( 306001 * ( M + 1 
( 36525 * ( Y + 4716 
( 4 
( 4 * n + sz - 1 
( 4 + pPager.pageSize 
( 5 * ( pgno - pgptrmap - 1 
( 6 
( 8 
( 8 - ( SQLITE_PTR_TO_INT( pSpace 
( 8 - 5 * ( p.explain - 1 
( ; ( x = aPrefix[pre] 
( ; *p ; p++ 
( ; ; 
( ; _fmt <= fmt.Length && ( c = fmt[_fmt] 
( ; e2 >= 0 ; e2-- 
( ; i > 0 ; i-- 
( ; i >= 0 && okToChngToIN != 0 ; i-- 
( ; pProbe != null ; pProbe = ( pSrc.pIndex != null ? null : pProbe.pNext 
( <full-sync mode> 
( A 
( A / 4 
( A.Length < B.Length 
( A.Length < Limit 
( A.Length < bB.Length 
( A<0x80 
( ALWAYS( !String.IsNullOrEmpty( z 
( ALWAYS( eAuto >= 0 
( ALWAYS( iCol >= 0 && iCol < pS.pEList.nExpr 
( ALWAYS( idxLru >= 0 
( ALWAYS( n > 0 
( ALWAYS( nOp > 0 
( ALWAYS( p != null 
( ALWAYS( p != null && p.pNext == pIndex 
( ALWAYS( p.rc == SQLITE_OK 
( ALWAYS( pBt 
( ALWAYS( pC != null 
( ALWAYS( pC.pCursor != null 
( ALWAYS( pColl != null 
( ALWAYS( pCrsr != null 
( ALWAYS( pCur.eState == CURSOR_VALID 
( ALWAYS( pDef 
( ALWAYS( pDef != null 
( ALWAYS( pEList != null 
( ALWAYS( pExpr.op != TK_REGISTER 
( ALWAYS( pFunc != null && pFunc.xFinalize != null 
( ALWAYS( pItem.pExpr != null 
( ALWAYS( pName2 != null 
( ALWAYS( pOp != null 
( ALWAYS( pParse.nErr == 0 
( ALWAYS( pRes.flags != 0 
( ALWAYS( pSrc 
( ALWAYS( pSrcList != null 
( ALWAYS( pSubitem.pTab != null 
( ALWAYS( pTab 
( ALWAYS( pTab != null 
( ALWAYS( pTab.pSchema 
( ALWAYS( pTabList.a[i].pTab 
( ALWAYS( pTrigger != null 
( ALWAYS( rc == SQLITE_OK 
( ALWAYS( rc >= 0 
( ALWAYS( sEnd.z[0] != 0 
( ALWAYS( v 
( ALWAYS( zSpan 
( ALWAYS(nOvfl
( ALWAYS(pList
( ALWAYS(pModule.xUpdate
( ALWAYS(pStack
( ALWAYS(pTab!=0 && pTab->pVTable!=0
( ALWAYS(pVTable->pVtab
( A[i] != B[i] 
( A[i] != bB[i] 
( A[i] < B[i] 
( A[i] < bB[i] 
( B.Length < Limit 
( BITVEC_NELEM * BITVEC_SZELEM 
( BITVEC_NINT / 2 
( BITVEC_SZ 
( BITVEC_USIZE / 4 
( BITVEC_USIZE / sizeof( BITVEC_TELEM 
( BITVEC_USIZE / sizeof( u32 
( BMS - 1 
( BitConverter.GetBytes( r1 
( Bitvec b 
( Bitvec p 
( BtCursor 
( BtCursor X 
( BtShared pBt 
( Btree X 
( Btree bt 
( Btree p 
( Btree* pBtree 
( BtreeMutexArray X 
( BusyHandler p 
( CellInfo ci 
( Column C 
( Column X
( Convert.ToChar( ( hexToInt( z[i] 
( Convert.ToDouble( baseTime 
( Convert.ToDouble( unixTime 
( Convert.ToInt64( ap[vaNEXT - 1] 
( Convert.ToUInt32( ap[vaNEXT - 1] 
( D.aDb[I].pSchema.flags & P 
( D.aDb[I].pSchema.flags & ~P 
( D.aDb[I].pSchema.flags | P 
( DIRECT_MODE  
( DataRow row in table.Rows 
( DatabaseName 
( DateTime ct 
( DateTime p 
( DbPage dbPage
( DbPage dbPage 
( DbPage pDbPage 
( DbPage pPage 
( DbPage pPg 
( Double.IsInfinity( divisor 
( Double.IsInfinity( pMem.r 
( Double.IsNaN( realvalue 
( Double.IsNegativeInfinity( pMem.r 
( Double.IsPositiveInfinity( pMem.r 
( Double.TryParse( Convert.ToString( realvalue 
( E.flags & P 
( E.flags & ~P 
( E.flags | P 
( EIGHT_BYTE_ALIGNMENT( pMem 
( EIGHT_BYTE_ALIGNMENT( zCsr 
( EIGHT_BYTE_ALIGNMENT(*ppFrom
( EIGHT_BYTE_ALIGNMENT(SQLITE_INT_TO_PTR(journalFileSize
( EIGHT_BYTE_ALIGNMENT(aSpace1
( EIGHT_BYTE_ALIGNMENT(pMem
( EIGHT_BYTE_ALIGNMENT(pPager->jfd
( Encoding.UTF8.GetBytes( pMem.z 
( Encoding.UTF8.GetString( (byte[]
( Encoding.UTF8.GetString( inStr 
( Encoding.UTF8.GetString( pMem.zBLOB 
( Exception e 
( ExpandBlob( pIn1 
( Expr X 
( Expr cf 
( Expr p 
( Expr pExpr 
( ExprList pList 
( Hash H 
( Hash pH 
( Hash pNew 
( HashElem E 
( IOException 
( IOException e 
( ISAUTOVACUUM 
( IdChar( (u8
( Index p 
( Index pIdx 
( IsHiddenColumn( pCol 
( IsHiddenColumn( pTab.aCol[i] 
( IsHiddenColumn( pTab.aCol[j] 
( IsVirtual( pSrc.pTab 
( IsVirtual( pTab 
( IsVirtual( pTable 
( IsVirtual(pTab
( IsVirtual(pTabItem.pTab
( JT_INNER | JT_OUTER 
( LookasideSlot* 
( M <= 2 
( MAX_PATH + 1 
( MAX_PATH + 50 
( MAX_SECTOR_SIZE >= 512 
( MEM_Blob | MEM_Str 
( MEM_Ephem | MEM_Static 
( MEM_Int | MEM_Str 
( MEM_Str == ( MEM_Blob >> 3 
( ManagementObject moLogDisk in mosLogicalDisks.Get(
( ManagementObject moPDisk in mosDiskDrives.Get(
( Marshal.GetLastWin32Error(
( Mem 
( Mem P 
( Mem ct 
( Mem p 
( Mem pMem 
( Mem pRec 
( Mem x 
( Mem* 
( MemJournal 
( MemJournal pJfd 
( N < 0 
( N < n && N >= 0 
( N <= 0 
( N == 0 || NEVER( z == null 
( N > 0 
( N > x 
( N-- != 0 
( N-- > 0 
( N-- > 0 && ( zLeft[a] == zRight[b] || ( zLeft[a] != 0 && zLeft[a] < 256 && zRight[b] < 256 && UpperToLower[zLeft[a]] == UpperToLower[zRight[b]] 
( N-- > 0 && zLeft[a + offsetLeft] != 0 && UpperToLower[zLeft[a + offsetLeft]] == UpperToLower[zRight[b]] 
( N>0 
( N>=zSpaces.Length-1 
( NEVER( db.mallocFailed != 0 
( NEVER( iCol < 0 
( NEVER( iDb < 0 
( NEVER( iFrom == iTo 
( NEVER( iNew > pCache.iMaxKey 
( NEVER( j >= pIdx.nColumn 
( NEVER( mem1.zMalloc 
( NEVER( p == null 
( NEVER( p.pSrc == null 
( NEVER( p2 < 2 
( NEVER( pC.pCursor == null 
( NEVER( pDef == null 
( NEVER( pExpr == null 
( NEVER( pLeftTab == null || pRightTab == null 
( NEVER( pList == null 
( NEVER( pMem->zMalloc 
( NEVER( pName2 == null 
( NEVER( pPager.errCode 
( NEVER( pPager.errCode !=0
( NEVER( pPager.readOnly 
( NEVER( pPager.state < PAGER_RESERVED 
( NEVER( pParse.nErr != 0 
( NEVER( pTab == null 
( NEVER( pTerm == null 
( NEVER( r1 != r2 
( NEVER( rc != 0 
( NEVER( rc != SQLITE_OK 
( NEVER( res < 0 
( NEVER( v == null 
( NEVER( zTab == null 
( NEVER( zTabName == null 
( NEVER(!isOpen( pPager.fd 
( NEVER(i ==N_SORT_BUCKET - 1 
( NEVER(pExpr==0
( NEVER(pTab==0
( NEVER(rc!=SQLITE_OK
( NEVER(zAuthArg==0
( NOT <in-memory journal> 
( NOT SAFE_APPEND 
( NOT SEQUENTIAL 
( No string passed
( NotUsed 
( OMIT_TEMPDB != 0 && i == 1 
( OMIT_TEMPDB == 0 && ALWAYS( iDb == 1 
( OMIT_TEMPDB == 0 && iDb == 1 
( OMIT_TEMPDB == 0 && isTemp != 0 
( OMIT_TEMPDB == 0 && isTemp != 0 && iDb > 1 
( OMIT_TEMPDB ==0&& iDb 
( OMIT_TEMPDB ==0&& iDb==1 
( OMIT_TEMPDB ==0&& isTemp 
( P 
( P->xCodec==0 
( P.flags & MEM_Zero 
( PAGER_EXCLUSIVE == EXCLUSIVE_LOCK 
( PAGER_JOURNALMODE_QUERY < 0 
( PAGER_LOCKINGMODE_EXCLUSIVE == 1 
( PAGER_LOCKINGMODE_NORMAL >= 0 && PAGER_LOCKINGMODE_EXCLUSIVE >= 0 
( PAGER_LOCKINGMODE_QUERY < 0 
( PAGER_RESERVED == RESERVED_LOCK 
( PAGER_SHARED == SHARED_LOCK 
( PCache pCache 
( PCache1 p 
( PCache1 pCache 
( PENDING_BYTE + 1 
( PENDING_BYTE + 2 
( PENDING_BYTE_PAGE( p.pDest.pBt 
( PGHDR_DIRTY | PGHDR_NEED_SYNC 
( PTRMAP_PAGENO( ( pBt 
( Pager p 
( Pager pPager 
( Pager x 
( PagerSavepoint b 
( Parse p 
( Parse pParse 
( Path.GetTempPath(
( PgHdr 
( PgHdr X 
( PgHdr b 
( PgHdr p 
( PgHdr pIn 
( PgHdr pList 
( PgHdr pPage 
( PgHdr pPg 
( PgHdr1 p 
( PgHdr1 pPage 
( Pgno iLastPg = pagerPagecount(pBt
( READ_LOCK+1==WRITE_LOCK 
( ReadNextRow( statement.VirtualMachine(
( RowSet p 
( RowSetEntry pList 
( SQLITE_AFF_NONE 
( SQLITE_BIGENDIAN != 0 ? SQLITE_UTF16BE : SQLITE_UTF16LE 
( SQLITE_DEFAULT_FILE_FORMAT < 4 
( SQLITE_DEFAULT_PAGE_SIZE <= SQLITE_MAX_DEFAULT_PAGE_SIZE 
( SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE 
( SQLITE_IOERR | ( 1 << 8 
( SQLITE_IOERR | ( 10 << 8 
( SQLITE_IOERR | ( 11 << 8 
( SQLITE_IOERR | ( 12 << 8 
( SQLITE_IOERR | ( 13 << 8 
( SQLITE_IOERR | ( 14 << 8 
( SQLITE_IOERR | ( 15 << 8 
( SQLITE_IOERR | ( 16 << 8 
( SQLITE_IOERR | ( 17 << 8 
( SQLITE_IOERR | ( 2 << 8 
( SQLITE_IOERR | ( 3 << 8 
( SQLITE_IOERR | ( 4 << 8 
( SQLITE_IOERR | ( 5 << 8 
( SQLITE_IOERR | ( 6 << 8 
( SQLITE_IOERR | ( 7 << 8 
( SQLITE_IOERR | ( 8 << 8 
( SQLITE_IOERR | ( 9 << 8 
( SQLITE_LOCKED | ( 1 << 8 
( SQLITE_MISUSE 
( SQLITE_MUTEX_RECURSIVE 
( SQLITE_MUTEX_STATIC_LRU 
( SQLITE_MUTEX_STATIC_MASTER 
( SQLITE_MUTEX_STATIC_MEM 
( SQLITE_MUTEX_STATIC_PRNG 
( SQLITE_NOMEM 
( SQLITE_NULL != sqlite3_value_type( argv[i] 
( SQLITE_NULL == sqlite3_value_type( argv[1] 
( SQLITE_OK != rc 
( SQLITE_OK != sqlite3ReadSchema( pParse 
( SQLITE_OK == pPager.errCode 
( SQLITE_OK!=rc 
( SQLITE_OK==rc 
( SQLITE_OK==rc && !pTab 
( SQLITE_OPEN_DELETEONCLOSE | SQLITE_OPEN_TEMP_JOURNAL 
( SQLITE_OPEN_MAIN_JOURNAL 
( SQLITE_OPEN_READONLY | SQLITE_OPEN_MAIN_JOURNAL 
( SQLITE_OPEN_READONLY | SQLITE_OPEN_MASTER_JOURNAL 
( SQLITE_PRINT_BUF_SIZE 
( SQLITE_ROW == sqlite3_step( pStmt 
( SQLITE_STATUS_MEMORY_USED 
( SQLITE_TEMP_STORE < 1 || SQLITE_TEMP_STORE > 3 
( SQLITE_TEMP_STORE == 1 
( SQLITE_TEMP_STORE == 1 && db.temp_store <= 1 
( SQLITE_TEMP_STORE == 2 
( SQLITE_TEMP_STORE == 2 && db.temp_store == 1 
( SQLITE_TEMP_STORE == 3 
( SQLITE_THREADSAFE 
( SQLITE_THREADSAFE && sqlite3GlobalConfig.bCoreMutex 
( SQLITE_UTF16NATIVE==SQLITE_UTF16BE 
( SQLITE_UTF8 == 1 && SQLITE_UTF16LE == 2 && SQLITE_UTF16BE == 3 
( SQLite3IoTrace 
( SQLite3IoTrace == false 
( SaveBuf[nested] != null 
( Schema p 
( Schema schema 
( Select p 
( SimulateDiskfullError(
( SimulateIOError(
( SrcList p 
( StrAccum p 
( String DatabaseName 
( String query 
( String.IsNullOrEmpty( val 
( String.IsNullOrEmpty( z 
( String.IsNullOrEmpty( z = sqlite3_value_text( argv[i] 
( String.IsNullOrEmpty( zConverted 
( String.IsNullOrEmpty( zFilename 
( String.IsNullOrEmpty( zFmt 
( String.IsNullOrEmpty( zSql 
( String.IsNullOrEmpty( zUtf8Name 
( StringBuilder diskPath 
( StringBuilder z 
( System.DateTime date 
( T X 
( T x 
( TK_AND == OP_And 
( TK_BITAND == OP_BitAnd 
( TK_BITNOT == OP_BitNot 
( TK_BITOR == OP_BitOr 
( TK_CONCAT == OP_Concat 
( TK_EQ == OP_Eq 
( TK_GE == OP_Ge 
( TK_GE == TK_EQ + 4 
( TK_GE == TK_GT + 3 
( TK_GE == TK_LE + 2 
( TK_GT < TK_LE 
( TK_GT == OP_Gt 
( TK_GT > TK_EQ 
( TK_GT > TK_EQ && TK_GT < TK_GE 
( TK_ISNULL & 1 
( TK_ISNULL == OP_IsNull 
( TK_LE == OP_Le 
( TK_LE == TK_GT + 1 
( TK_LE > TK_EQ && TK_LE < TK_GE 
( TK_LSHIFT == OP_ShiftLeft 
( TK_LT == OP_Lt 
( TK_LT == TK_GT + 2 
( TK_LT > TK_EQ && TK_LT < TK_GE 
( TK_MINUS == OP_Subtract 
( TK_NE == OP_Ne 
( TK_NOT == OP_Not 
( TK_NOTNULL == OP_NotNull 
( TK_OR == OP_Or 
( TK_PLUS == OP_Add 
( TK_REM == OP_Remainder 
( TK_RSHIFT == OP_ShiftRight 
( TK_SLASH == OP_Divide 
( T[] x 
( Table T 
( Table X
( Table Y 
( Table pTable 
( Trigger pTrigger 
( UnpackedRecord p 
( UpperToLower == null 
( VTable X 
( V[I >> 3] & ( 1 << ( I & 7 
( Vdbe X 
( Vdbe ct 
( Vdbe p 
( Vdbe v 
( VdbeCursor 
( VdbeCursor p 
( VdbeCursor* 
( WO_EQ << ( TK_GE - TK_EQ 
( WO_EQ << ( TK_GT - TK_EQ 
( WO_EQ << ( TK_LE - TK_EQ 
( WO_EQ << ( TK_LT - TK_EQ 
( WO_EQ << ( op - TK_EQ 
( WO_EQ==SQLITE_INDEX_CONSTRAINT_EQ 
( WO_GE==SQLITE_INDEX_CONSTRAINT_GE 
( WO_GT==SQLITE_INDEX_CONSTRAINT_GT 
( WO_LE==SQLITE_INDEX_CONSTRAINT_LE 
( WO_LT==SQLITE_INDEX_CONSTRAINT_LT 
( WO_MATCH==SQLITE_INDEX_CONSTRAINT_MATCH 
( WRITE_LOCK>READ_LOCK 
( WhereClause 
( WhereClause pWC 
( WhereClause wc 
( WhereInfo pWInfo 
( WhereLevel 
( WhereMaskSet 
( WhereMaskSet wms 
( X 
( X != 0 
( X != null 
( X != true 
( X == 0 
( X == null 
( X == true 
( Z > n 
( _M != null 
( _M == null || _M.z == null 
( _M.z 
( _bufOrd != null 
( _bufOrd == null ? 0 : 2 
( _fmt < fmt.Length && ( c = ( fmt[++_fmt] 
( _p & 0x7F 
( _p4 == null 
( _p4.pVtab 
( _v == null || sqlite3ReadSchema( pParse 
( a != null 
( a < zLeft.Length && b < zRight.Length && UpperToLower[zLeft[a]] == UpperToLower[zRight[b]] 
( a == zLeft.Length 
( a == zLeft.Length && b == zRight.Length 
( a.Length - Offset < b.Length 
( a.Length < Offset + Limit 
( a==0 
( aArg==aDyn || (aDyn==0 && aArg==aStatic
( aCol == null 
( aCol[i] == null 
( aData != null 
( aHandle==null 
( aJournalMagic.Length + 20 
( aKeyword[j].i 
( aLen[i] == n && 0 == sqlite3StrNICmp( zText.ToString(
( aListelem[i + 1].pExpr.op == TK_COLUMN 
( aListelem[i + 1].pExpr.op == TK_REGISTER 
( aNew.pBt 
( aNew.pSchema == null 
( aNew.pSchema.file_format != 0 && aNew.pSchema.enc != ENC( db 
( aNew==0 
( aNext[i] 
( aOffset[p2] != 0 
( aOvfl != null 
( aPermute != null 
( aRegIdx != null && aRegIdx[i - 1] == 0 
( aRegIdx == null 
( aRegIdx[iCur] == 0 
( aRegIdx[i] == 0 
( aRoot == null 
( aSortOrder 
( aSpace 
( aTempRec 
( aType != null 
( aType[i] 
( aType[p2] 
( aUsage[j].omit 
( aUsage[k].argvIndex == j 
( aXRef == null 
( aXRef[i]>=0 
( aXRef[pIdx.aiColumn[i]] >= 0 
( a[i + Offset] != b[i] 
( a[i + Offset] < b[i] 
( a[i] == null 
( ac 
( acc 
( acc.mallocFailed != 0 
( action 
( action == OE_Restrict 
( addr != 0 
( addr < 0 
( addr < p.nOp 
( addr >= 0 
( addrNext != 0 
( addrSortIndex >= 0 && pOrderBy == null 
( aff 
( aff == '\0' 
( aff1 != '\0' && aff2 != '\0' 
( aff1 != '\0' ? aff1 : aff2 
( aff1 == '\0' && aff2 == '\0' 
( aff1 == 0 || aff2 == 0 
( aff1 >= SQLITE_AFF_NUMERIC || aff2 >= SQLITE_AFF_NUMERIC 
( affRight != 0 && affRight != affLeft 
( affinity != '\0' 
( affinity != SQLITE_AFF_NONE 
( affinity == '\0' 
( affinity == SQLITE_AFF_TEXT 
( aiValues == null 
( aiValues[j] != 0 
( aiValues[j] != 0 && aiValues[j] != ( i + 1 
( aiValues[j] - 1 
( allocSize 
( allowedOp( op 
( allowedOp( pAndTerm.pExpr.op 
( allowedOp( pExpr.op 
( alreadyExists != 0 
( amt - got 
( amt > 0 
( andFlags & WHERE_UNIQUE 
( andFlags & bestPlan.plan.wsFlags 
( ap 
( ap == null || ap.Length == 0 
( ap.Length == 0 
( apCell==null 
( apNew != null 
( apVal != null || n == 0 
( apVtabLock 
( ap[vaNEXT - 1] 
( ap[vaNEXT - 1] == null 
( ap[vaNEXT - 1].GetHashCode(
( ap[vaNEXT - 1].GetType(
( appendBias 
( argc 
( argc <= 1 
( argc == 0 
( argc == 0 || SQLITE_NULL == sqlite3_value_type( argv[0] 
( argc == 1 
( argc == 1 || argc == 2 
( argc == 2 
( argc == 3 
( argc == 3 && sqlite3_value_type( argv[2] 
( argc == 3 || argc == 2 
( argc > 1 
( argc==1 
( argv == null 
( argv == null || argv[0] == null || argv[1] == null 
( argv!=null 
( argv[0] 
( argv[0].z.Length > 0 
( argv[1] 
( argv[1] == null 
( argv[1].z.Length > 0 
( argv[2] 
( argv[2] != null && argv[2].Length != 0 
( argv[i]==null 
( assert_pager_state( pPager 
( assert_pager_state(pPager
( attr & FileAttributes.ReadOnly 
( attr == FileAttributes.Directory 
( auth!=SQLITE_OK 
( auth==SQLITE_DENY 
( autoInc != 0 
( autoInc * TF_Autoincrement 
( autoInc == 0 || autoInc == 1 
( avail >= 0 
( azChar == null 
( azCols == null 
( azCols[i] != null 
( azModuleArg==0 
( azNew==null 
( azResult !=null
( azResult!=0 
( azResult[i] 
( b 
( b != null 
( b == zRight.Length 
( b.Length < Limit 
( b.rc != SQLITE_OK 
( b01[0]==0xFE && b01[1]==0xFF 
( b01[0]==0xFF && b01[1]==0xFE 
( b1==0xFE && b2==0xFF 
( b1==0xFF && b2==0xFE 
( b2 ? 1 : 0 
( bA.Length < B.Length 
( bA.Length < Limit 
( bA.Length < bB.Length 
( bA[i] != B[i] 
( bA[i] != bB[i] 
( bA[i] < B[i] 
( bA[i] < bB[i] 
( bB.Length < Limit 
( bCloseTrans != 0 
( bNC * SQLITE_FUNC_NEEDCOLL 
( bNew 
( bOld 
( bPurgeable != 0 
( bRev != 0 
( bRev != 0 ? OP_Prev : OP_Next 
( bRev == ( ( pIdx.aSortOrder[nEq] == SQLITE_SO_ASC 
( bRev == 0 || bRev == 1 
( bestPlan.plan.u.pIdx == pIdx 
( bom!=0 
( bool X 
( bool x 
( bufStr.Length > buf.Length 
( buf[1] << 16 
( buf[1] << 8 
( buf[2] << 8 
( buf[3] << 16 
( buf[4] << 8 
( buf[5] << 16 
( buf[6] << 8 
( buf[bufpt - 1] == '.' 
( buf[bufpt - 1] == '0' 
( buf[offset + 1] << 16 
( buf[offset + 1] << 8 
( buf[offset + 2] << 8 
( buf[offset + 3] << 16 
( buf[offset + 4] << 8 
( buf[offset + 5] << 16 
( buf[offset + 6] << 8 
( bufpt 
( bufpt == 0 
( bufpt > 0 
( bufpt++ 
( byte X 
( byte x 
( byte[] inStr 
( byte[] p 
( byte[] pPrior 
( c 
( c != '%' 
( c != '*' || ( z[iOffset + i] != '/' 
( c != 0 
( c != c2 
( c & 0xFFFFF800 
( c & 0xFFFFFFFE 
( c + 1 
( c < 0x80 
( c << 6 
( c = (byte
( c == '
( c == '(' && n > 0 
( c == '*' 
( c == '+' 
( c == '-' 
( c == '.' 
( c == ':' && z[iOffset + i + 1] == ':' 
( c == '<' 
( c == '>' 
( c == 'A' - 1 
( c == 'Z' || c == 'z' 
( c == '\'' 
( c == ']' 
( c == 'l' 
( c == 0 
( c == c2 
( c == delim 
( c == esc 
( c == fmtinfo[idx].fmttype 
( c == matchSet 
( c > 0x1f && sqlite3IsAsciiIdChar[c - 0x20] 
( c > 0xff 
( c >= '0' && c <= '9' 
( c >= 0x20 && c < 0x7f 
( c >= 0xc0 
( c >= prior_c && c <= c2 
( c!=0 || (i==0 && zStart==zNum
( c!=0xfffd 
( c0 == 0 
( c1 
( c1 - localtimeOffset( p 
( c1 == 0 
( c2 
( c2 != 0 && c2 != ']' 
( c2 != 0 && c2 != c 
( c2 < 0x80 
( c2 == '-' && zPattern[0] != ']' && zPattern[0] != 0 && prior_c > 0 
( c2 == ']' 
( c2 == '^' 
( c2 == 0 
( c2 == 0 || ( seen ^ invert 
( c<0x00080 
( c<0x00800 
( c<0x10000 
( c<=0xFFFF 
( c==i 
( c==t 
( c>=0xD800 && c<0xE000 
( c>=0xc0 
( caseSensitive != 0 
( cbrk<iCellFirst || pc+size>usableSize 
( cc != null 
( cc.pNext == pTrigger 
( ch == q 
( char x 
( char* 
( checkSavepointCount( db 
( checkSavepointCount(db
( chngRowid 
( chngToIN != 0 
( ci.iOverflow != this.iOverflow || ci.nSize != this.nSize 
( ci.nHeader != this.nHeader || ci.nLocal != this.nLocal 
( ci.nKey != this.nKey || ci.nData != this.nData || ci.nPayload != this.nPayload 
( ci.pCell[ci.iCell] != this.pCell[iCell] 
( cksum != 0 
( cnt != 0 && c != 0 && 255 != (u8
( cnt != 1 
( cnt < 0 
( cnt < 100 && rc == SQLITE_OK && res == 0 
( cnt < 5 
( cnt < z.Length && ( c = z[cnt] 
( cnt == 0 
( cnt == 0 && ( pEList = pNC.pEList 
( cnt == 0 && ( v & 0xffffff 
( cnt == 0 && cntTab == 1 && sqlite3IsRowid( zCol 
( cnt == 1 
( cnt == db.activeVdbeCnt 
( cnt++ >= 16 
( cnt-- > 0 && res == 0 
( code!=prevcode 
( code>0 
( columnCount == 0 
( columnType 
( columnValues 
( context 
( convertUtf8Filename( zFullpath.ToString(
( cookie != db.aDb[iDb].pSchema.schema_cookie 
( cost 
( cost < pCost.rCost 
( count - ( NDELAY - 1 
( count < NDELAY 
( count > 0 
( count >= 0 
( count-- > 0 && ALWAYS( elem 
( cp.pDflt != null 
( createFlag != 0 && ( bestScore < 6 || pBest.nArg != nArg 
( createFlag == 1 
( createFlag == 1 || createFlag == 0 
( createStat1 == 0 
( ctx 
( ctx.isError != 0 
( ctx.pVdbeFunc != null 
( ctx.s 
( currentSize > newSize 
( cursorHoldsMutex( pCur 
( cursorHoldsMutex(pCsr
( cursorHoldsMutex(pCur
( d1 >= nKey1 && sqlite3VdbeSerialTypeLen( serial_type1 
( data == null 
( db 
( db != null 
( db != null && !sqlite3SafetyCheckSickOrOk( db 
( db != null && ( db.pErr != null || ( db.pErr = sqlite3ValueNew( db 
( db != null && db.mallocFailed != 0 
( db != null ? db.errMask : 0xff 
( db == null 
( db == null || sqlite3_mutex_held( db.mutex 
( db == v.db 
( db!=0 
( db->aVTrans 
( db->aVTrans[i]==pVTab 
( db->init.busy || IN_DECLARE_VTAB 
( db->mallocFailed 
( db->nDb>2 || iDb!=0 
( db->pBlockingConnection==0 && db->pUnlockConnection==0 
( db->pVTab 
( db->xAuth==0 
( db.Connection(
( db.aCollSeq 
( db.aDb == null 
( db.aDb.Length <= db.nDb 
( db.aDb==db.aDbStatic 
( db.aDb[0].Equals( db.aDbStatic[0] 
( db.aDb[0].pBt 
( db.aDb[0].pBt==0 
( db.aDb[1].pBt != null 
( db.aDb[1].pBt == null && pParse.explain == 0 
( db.aDb[1].pSchema != null 
( db.aDb[iDb].pBt != null 
( db.aDb[iDb].pBt != null || iDb == 1 
( db.aDb[iDb].pSchema != null 
( db.aDb[iDb].pSchema == pTab.pSchema 
( db.aDb[iDb].zName == zDbName 
( db.aDb[i].pBt 
( db.aDb[i].pBt != null 
( db.aDb[i].pBt == null 
( db.aDb[i].pSchema == pSchema 
( db.aDb[i].zName != null 
( db.aDb[i].zName == null 
( db.aDb[ii].pBt 
( db.aDb[ii].pBt != null 
( db.aDb[p1].pBt 
( db.aDb[pOp.p1].pBt != null 
( db.aDb[pOp.p1].pSchema.schema_cookie != iMeta 
( db.aFunc.a 
( db.aLimit.Length == aHardLimit.Length 
( db.aLimit[SQLITE_LIMIT_LENGTH] >= 0 
( db.activeVdbeCnt != 0 
( db.activeVdbeCnt == 0 
( db.activeVdbeCnt > 0 
( db.activeVdbeCnt > 0 || db.autoCommit == 0 || db.nStatement == 0 
( db.activeVdbeCnt >= db.writeVdbeCnt 
( db.autoCommit != 0 
( db.autoCommit == 0 || db.activeVdbeCnt > 1 
( db.errCode 
( db.errCode != CSSQLite.SQLITE_OK 
( db.flags & DB_Empty 
( db.flags & DB_SchemaLoaded 
( db.flags & SQLITE_FullColNames 
( db.flags & SQLITE_LegacyFileFmt 
( db.flags & SQLITE_NullCallback 
( db.flags & SQLITE_ReadUncommitted 
( db.flags & SQLITE_ShortColNames 
( db.flags & SQLITE_VdbeTrace 
( db.flags | SQLITE_InternChanges 
( db.init.busy != 0 
( db.init.busy != 0 || pTblName == null 
( db.init.busy == 0 
( db.init.busy == 0 || saveSqlFlag == 0 
( db.init.iDb == 0 || db.init.busy != 0 
( db.init.iDb == 1 
( db.init.orphanTrigger!=0 
( db.lookaside.bEnabled == 0 
( db.lookaside.bMalloced 
( db.lookaside.nOut 
( db.lookaside.nOut == 0 
( db.lookaside.nOut>db.lookaside.mxOut 
( db.lookaside.pStart 
( db.lookaside.pStart != 0 
( db.magic == SQLITE_MAGIC_BUSY 
( db.magic == SQLITE_MAGIC_OPEN 
( db.mallocFailed 
( db.mallocFailed != 0 
( db.mallocFailed != 0 && pParse.nAliasAlloc > 0 
( db.mallocFailed == 0 
( db.mallocFailed==0 
( db.mutex 
( db.mutex != null || isThreadsafe == 0 || !sqlite3GlobalConfig.bFullMutex 
( db.mutex == null 
( db.nDb != j 
( db.nDb <= 2 
( db.nDb <= 2 && db.aDb != db.aDbStatic 
( db.nDb > iDb 
( db.nDb >= db.aLimit[SQLITE_LIMIT_ATTACHED] + 2 
( db.nExtension>0 
( db.nProgressOps == nProgressOps 
( db.nStatement !=0 && p.iStatement!=0 
( db.nStatement == 0 
( db.nStatement > 0 
( db.nStatement >= 0 && db.nSavepoint >= 0 
( db.nVTrans > 0 && db.aVTrans == 0 
( db.nextPagesize 
( db.pCommitArg 
( db.pDfltColl != null 
( db.pErr 
( db.pErr != null 
( db.pProgressArg 
( db.pRollbackArg 
( db.pSavepoint != null 
( db.pSavepoint != null || db.isTransactionSavepoint == 0 
( db.pSavepoint != pSavepoint 
( db.pSavepoint == null || db.autoCommit == 0 
( db.pVdbe != null 
( db.pVdbe == p 
( db.pVfs == null 
( db.temp_store != 1 
( db.temp_store == 2 
( db.temp_store == ts 
( db.u1.isInterrupted 
( db.writeVdbeCnt > 0 
( db.xCollNeeded != null 
( db.xCollNeeded == null || db.xCollNeeded16 == null 
( db.xCollNeeded16!=null 
( db.xProfile != null && 0 == db.init.busy 
( db.xProgress != null 
( db.xRollbackCallback != null && ( inTrans != 0 || 0 == db.autoCommit 
( db.xTrace != null 
( db.xUpdateCallback != null && pOp.p4.z != null 
( db2 
( db2==db 
( db==0 
( db==0 || p->pBlockingConnection!=db 
( db==0 || p->pUnlockConnection!=db 
( debugMutexHeld(p
( delay <= 0 
( delim == '\'' 
( delim == '`' 
( dequote != 0 && !String.IsNullOrEmpty( pItem.zName 
( desiredAutoCommit != 0 
( desiredAutoCommit != 0 && 0 == db.autoCommit 
( desiredAutoCommit != 0 || 0 == desiredAutoCommit 
( desiredAutoCommit != 0 || 0 == iRollback 
( desiredAutoCommit != db.autoCommit 
( desiredAutoCommit == 0 ? 1 : 0 
( desiredEnc==SQLITE_UTF16BE 
( desiredEnc==SQLITE_UTF16LE 
( desiredEnc==SQLITE_UTF8 
( dest.eDest != priorOp 
( dest.eDest == SRT_EphemTab 
( dest.eDest == SRT_Output 
( dest.eDest == priorOp && ALWAYS( null == p.pLimit && null == p.pOffset 
( dest.nMem == nColumn 
( dist != 2 || ( token != TK_WHEN && token != TK_FOR && token != TK_BEGIN 
( doHardCopy /* && 0 == pParse.db.mallocFailed */ 
( doMakeRec 
( doNotReorder != 0 
( doTruncate != 0 || iLimit == 0 
( double 
( double N 
( double r 
( double x 
( dxInit xInit 
( e = 0 ; e < pEList.nExpr ; e++ 
( e2 < 0 
( eAuto >= 0 && eAuto <= 2 
( eDest 
( eDest != SRT_Exists 
( eDest == SRT_Coroutine 
( eDest == SRT_Discard 
( eDest == SRT_EphemTab 
( eDest == SRT_Output 
( eDest == SRT_Output || eDest == SRT_Coroutine 
( eDest == SRT_Table 
( eLock==READ_LOCK || (p==pBt.pWriter && p.inTrans==TRANS_WRITE
( eLock==READ_LOCK || eLock==WRITE_LOCK 
( eLock==READ_LOCK || pBt.inTransaction==TRANS_WRITE 
( eLock==READ_LOCK || pIter.pBtree==p || pIter.eLock==READ_LOCK
( eLock==WRITE_LOCK 
( eLock>pLock.eLock 
( eMode == PAGER_LOCKINGMODE_EXCLUSIVE 
( eMode == PAGER_LOCKINGMODE_NORMAL || eMode == PAGER_LOCKINGMODE_EXCLUSIVE 
( eMode >= 0 && !pPager.tempFile 
( eOp == SAVEPOINT_ROLLBACK 
( eOp == SAVEPOINT_ROLLBACK || eOp == SAVEPOINT_RELEASE 
( eOp!=0 
( eStatementOp != 0 
( eStatementOp != SAVEPOINT_ROLLBACK 
( eStatementOp == 0 
( eType == 0 
( eType == IN_INDEX_ROWID 
( elem != null 
( elem.next != null 
( elem.prev != null 
( emptyDestTest != 0 
( enc != 0 
( enc != SQLITE_UTF8 
( enc & ~SQLITE_UTF16_ALIGNED 
( enc == 0 
( enc == 0 ? MEM_Blob : MEM_Str 
( enc == 0 ? SQLITE_BLOB : SQLITE_TEXT 
( enc == 0 ? SQLITE_UTF8 : enc 
( enc == SQLITE_UTF16BE 
( enc == SQLITE_UTF16BE && p.iPrefEnc == SQLITE_UTF16LE 
( enc == SQLITE_UTF8 
( enc == SQLITE_UTF8 ? 1 : 2 
( enc == SQLITE_UTF8 || enc == SQLITE_UTF16LE || enc == SQLITE_UTF16BE 
( enc == p.iPrefEnc 
( enc >= SQLITE_UTF8 && enc <= SQLITE_UTF16BE 
( enc2 < SQLITE_UTF8 || enc2 > SQLITE_UTF16BE 
( enc2 == SQLITE_UTF16 
( enc2 == SQLITE_UTF16 || enc2 == SQLITE_UTF16_ALIGNED 
( enc2 == SQLITE_UTF16_ALIGNED 
( enc2 | ( enc & SQLITE_UTF16_ALIGNED 
( enc==SQLITE_ANY 
( enc==SQLITE_UTF16 
( encnames[SQLITE_UTF16BE].enc == SQLITE_UTF16BE 
( encnames[SQLITE_UTF16LE].enc == SQLITE_UTF16LE 
( encnames[SQLITE_UTF8].enc == SQLITE_UTF8 
( encnames[iEnc].zName == null 
( encoding == 0 
( encoding!=SQLITE_UTF8 
( endEq != bRev ? 1 : 0 
( errMsg 
( error == ERROR_FILE_NOT_FOUND 
( esc == 0 
( esc == c && !prevEscape 
( esign < 0 
( eval >= 1 
( eval >= 16 
( eval >= 4 
( eval >= 64 
( exFlag 
( exists 
( exists != 0 
( exp % 10 + '0' 
( exp / 10 + '0' 
( exp / 100 + '0' 
( exp < -4 || exp > precision 
( exp < 0 
( exp > 350 
( exp >= 100 
( f1 & MEM_Null 
( f2 & MEM_Null 
( false 
( fd != null 
( fd.pMethods != null 
( file_format >= 4 && ( i & 1 
( fire_this 
( first[0] != 0 
( flag != 0 
( flag != WHERE_ORDERBY_MIN ? 1 : 0 
( flag_alternateform && infop.prefix != 0 
( flag_altform2 
( flag_blanksign 
( flag_dp 
( flag_exp || xtype == etEXP 
( flag_leftjustify 
( flag_long 
( flag_longlong 
( flag_plussign 
( flag_rtz && flag_dp 
( flag_zeropad 
( flag_zeropad && !flag_leftjustify && length < width 
( flag_zeropad && precision < width - ( ( prefix != '\0' 
( flags 
( flags & 0xff 
( flags & EXPRDUP_REDUCE 
( flags & PAGER_NO_READLOCK 
( flags & PAGER_OMIT_JOURNAL 
( flags & SQLITE_FullColNames 
( flags & SQLITE_OPEN_CREATE 
( flags & SQLITE_ShortColNames 
( flags == EXPRDUP_REDUCE || flags == 0 
( flags == SQLITE_ACCESS_EXISTS 
( fout & SQLITE_OPEN_READONLY 
( fs == null || fs.SafeFileHandle.IsInvalid 
( fullNames 
( getBoolean( zRight 
( getDigits( zDate.Substring( 1 
( getDigits( zDate.Substring( zIndex 
( getSafetyLevel( z 
( getSafetyLevel( zRight 
( got == amt 
( gotPendingLock && locktype == SHARED_LOCK 
( groupBySort != 0 
( growOpArray( p 
( h + 1 
( h << 3 
( h = 0 ; h < pCache.nHash ; h++ 
( h >= 'A' && h <= 'F' 
( h >= 'a' && h <= 'f' 
( h >= BITVEC_NINT 
( h==(('b'<<24
( h==(('c'<<24
( h==(('d'<<24
( h==(('f'<<24
( h==(('r'<<24
( h==(('t'<<24
( handle == IntPtr.Zero 
( hasDistinct 
( hasMoved != 0 
( hasStatementBegin && !doesStatementRollback 
( hexdigits[( c >> 4 
( hexdigits[( zBlob[i] 
( hexdigits[( zBlob[i] >> 4 
( hexdigits[c & 0xf] 
( hit==null 
( i 
( i != 1 
( i % 2 != 0 || z.Length == iOffset + i && c != '\'' 
( i & ( BITVEC_SZELEM - 1 
( i & 0xFFFFFFFF 
( i + 1 
( i + 4 < nTemp 
( i + n + 3 
( i + n > nTemp 
( i < 0 
( i < 0 ? -i : i 
( i < 1 || i > db.aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] 
( i < 1 || i > p.nVar 
( i < 2 
( i < 32 && sqlite3ExprIsConstant( pFarg.a[i].pExpr 
( i < nEqCol 
( i < nTemp 
( i < p.nOp && p.explain == 2 && p.aOp[i].opcode != OP_Explain 
( i < p.nOp - 3 
( i < p.pSrc.nSrc - 1 
( i < pIdx.nColumn 
( i < pKeyInfo.nField 
( i < pList.nExpr - 1 
( i < pSrcList.nSrc - 1 
( i < pTab.nCol 
( i < sizeof( int 
( i < z.Length - 1 && ( z[i + 1] == quote 
( i <= p.iSize 
( i = ( aHash[h] 
( i = ( db.nDb - 1 
( i = 0 ; ( ch = escarg[i] 
( i = 0 ; ALWAYS( i < db.nDb 
( i = 0 ; ALWAYS(i <N_SORT_BUCKET - 1
( i = 0 ; aBucket[i] != null ; i++ 
( i = 0 ; go ; i++ 
( i = 0 ; i < 11 && i + iZnum < zNum.Length && ( c = zNum[iZnum + i] - '0' 
( i = 0 ; i < 16 && i < pMem.n ; i++ 
( i = 0 ; i < 2 ; i++ 
( i = 0 ; i < 255 ; i++ 
( i = 0 ; i < 3 && apAll[i] != null ; i++ 
( i = 0 ; i < 3 ; i++ 
( i = 0 ; i < ArraySize( aBuiltinFunc 
( i = 0 ; i < ArraySize( aCopy 
( i = 0 ; i < ArraySize( aDateTimeFuncs 
( i = 0 ; i < ArraySize( aPragma 
( i = 0 ; i < ArraySize( iLength 
( i = 0 ; i < ArraySize( meta 
( i = 0 ; i < BITVEC_NPTR ; i++ 
( i = 0 ; i < SQLITE_N_COLCACHE ; i++ 
( i = 0 ; i < aBucket.Length ; i++ 
( i = 0 ; i < argc - 1 ; i++ 
( i = 0 ; i < argc ; i++ 
( i = 0 ; i < db.nDb ; i++ 
( i = 0 ; i < db.nExtension ; i++ 
( i = 0 ; i < inStr.Length ; i++ 
( i = 0 ; i < n ; i += 2 
( i = 0 ; i < n ; i++ 
( i = 0 ; i < nBlob ; i++ 
( i = 0 ; i < nChar ; i++ 
( i = 0 ; i < nCol ; i++ 
( i = 0 ; i < nColumn ; i++ 
( i = 0 ; i < nExpr ; i = i + 2 
( i = 0 ; i < nExpr ; i++ 
( i = 0 ; i < nFarg ; i++ 
( i = 0 ; i < nField ; i++ 
( i = 0 ; i < nIdx ; i++ 
( i = 0 ; i < nIn ; i++ 
( i = 0 ; i < nOp ; i++ 
( i = 0 ; i < nOrderBy ; i++ 
( i = 0 ; i < nReg ; i++ 
( i = 0 ; i < nSubSrc ; i++ 
( i = 0 ; i < p.nCol ; i++ 
( i = 0 ; i < p.nConstraint ; i++ 
( i = 0 ; i < p.nCursor ; i++ 
( i = 0 ; i < p.nExpr ; i++ 
( i = 0 ; i < p.nHash ; i++ 
( i = 0 ; i < p.nId ; i++ 
( i = 0 ; i < p.nOp ; i++ 
( i = 0 ; i < p.nOrderBy ; i++ 
( i = 0 ; i < p.nSrc ; i++ 
( i = 0 ; i < p.nVar ; i++ 
( i = 0 ; i < p.pSrc.nSrc ; i++ 
( i = 0 ; i < pA.x.pList.nExpr ; i++ 
( i = 0 ; i < pAggInfo.nAccumulator ; i++ 
( i = 0 ; i < pAggInfo.nColumn ; i++ 
( i = 0 ; i < pAggInfo.nFunc ; i++ 
( i = 0 ; i < pChanges.nExpr ; i++ 
( i = 0 ; i < pColumn.nId ; i++ 
( i = 0 ; i < pDest.nCol ; i++ 
( i = 0 ; i < pEList.nExpr ; i++ 
( i = 0 ; i < pFrom.nVar ; i++ 
( i = 0 ; i < pGroupBy.nExpr ; i++ 
( i = 0 ; i < pIdx.nColumn ; i++ 
( i = 0 ; i < pIndex.nColumn ; i++ 
( i = 0 ; i < pList.nExpr ; i++ 
( i = 0 ; i < pList.nId ; i++ 
( i = 0 ; i < pList.nSrc ; i++ 
( i = 0 ; i < pMaskSet.n ; i++ 
( i = 0 ; i < pNC.pSrcList.nSrc ; i++ 
( i = 0 ; i < pNew.nCol ; i++ 
( i = 0 ; i < pOp.p2 ; i++ 
( i = 0 ; i < pOrderBy.nExpr ; i++ 
( i = 0 ; i < pPager.nSavepoint ; i++ 
( i = 0 ; i < pParse.nTableLock ; i++ 
( i = 0 ; i < pParse.nVarExpr ; i++ 
( i = 0 ; i < pProbe.nColumn ; i++ 
( i = 0 ; i < pSrc.nColumn ; i++ 
( i = 0 ; i < pSrc.nSrc - 1 ; i++ 
( i = 0 ; i < pSrcList.nSrc ; i++ 
( i = 0 ; i < pTab.nCol ; i++ 
( i = 0 ; i < pTabList.nSrc ; i++ 
( i = 0 ; i < pTable.nCol ; i++ 
( i = 0 ; i < pVdbeFunc.nAux ; i++ 
( i = 0 ; i < pWInfo.nLevel ; i++ 
( i = 0 ; i < sAggInfo.nColumn ; i++ 
( i = 0 ; i < sAggInfo.nFunc ; i++ 
( i = 0 ; i < sqlite3GlobalConfig.nPage ; i++ 
( i = 0 ; i < wsdAutoext.nExt ; i++ 
( i = 0 ; i < zConverted.Length && i < MAX_PATH ; i++ 
( i = 0 ; i <= nCol ; i++ 
( i = 0 ; i< z1.Length ; i++ 
( i = 0 ; p.pPrior == null && i < pTabList.nSrc ; i++ 
( i = 0 ; rc == SQLITE_OK && i < db.nDb ; i++ 
( i = 0 ; z != null && i <= pIndex.nColumn ; i++ 
( i = 0 ; z.Length > iOffset + i && sqlite3Isdigit( z[iOffset + i] 
( i = 0 ; z1[i] ; i++ 
( i = 1 ; ( iOffset + i 
( i = 1 ; /* db.mallocFailed == 0 && */ i <= p.pEList.nExpr ; i++ 
( i = 1 ; i < argc ; i++ 
( i = 1 ; i < z.Length ; i++ 
( i = 1 ; i < zNum.Length ; i++ 
( i = 1 ; i <= p.nMem ; i++ 
( i = 1 ; i <= sz ; i++ 
( i = 1 ; i <N_SORT_BUCKET ; i++ 
( i = 1 ; z.Length > iOffset + i && ( ( ( c = (byte
( i = 1 ; z.Length > iOffset + i && ( c = (byte
( i = 1 ; z.Length > iOffset + i && sqlite3Isdigit( z[iOffset + i] 
( i = 1 ; z.Length > iOffset + i && sqlite3Isspace( z[iOffset + i] 
( i = 2 ; z.Length > iOffset + i && ( c = (byte
( i = 7 ; i >= 0 ; i-- 
( i = OMIT_TEMPDB ; i < db.nDb ; i++ 
( i = cnt - 1 ; i >= 0 ; i-- 
( i = db.aCollSeq.first ; i != null ; i = i.next 
( i = db.aDb[iDb].pSchema.idxHash.first ; i != null ; i = i.next 
( i = db.aDb[idx].pSchema.tblHash.first ; i != null ; i = i.next 
( i = dbSize + 1 ; i <= pPager.dbOrigSize ; i++ 
( i = iDb ; i < db.nDb ; i++ 
( i = iFirst ; i < mx ; i++ 
( i = iFrom = 0 ; i < pTabList.nSrc ; i++ 
( i = iStart ; i < iStart + nExtra ; i++ 
( i = iStartAddr ; i < iEnd ; i++ 
( i = j = 0 ; i < zFmt.Length ; i++ 
( i = j = 0 ; j < nTerm && i <= pIdx.nColumn ; i++ 
( i = j = 2 ; i < db.nDb ; i++ 
( i = n = 0 ; ( ch = escarg[i] 
( i = nIdx - 1 ; i >= 0 ; i-- 
( i = p.nExpr ; i > 0 ; i-- 
( i = p.nSrc - 1 ; i > 0 ; i-- 
( i = pIdx.nColumn ; i >= 5 ; i-- 
( i = pOrWc.nTerm - 1 ; i >= 0 && indexable != 0 ; i-- 
( i = pOrWc.nTerm - 1 ; i >= 0 ; i-- 
( i = pSrc.nSrc - 1 ; i >= iStart ; i-- 
( i = pSrc.nSrc ; i > 0 ; i-- 
( i = pTabList.nSrc - 1 ; i >= 0 ; i-- 
( i = pWC.nTerm - 1 ; i >= 0 ; i-- 
( i = width ; i >= nPad ; i-- 
( i == 0 
( i == 1 
( i == 1 || ( pDb.pBt != null 
( i == 1 || ( pDb.pBt != null && sqlite3BtreeHoldsMutex( pDb.pBt 
( i == 10 
( i == 100 
( i == 101 
( i == 102 
( i == 103 
( i == 104 
( i == 105 
( i == 106 
( i == 107 
( i == 108 
( i == 109 
( i == 11 
( i == 110 
( i == 111 
( i == 112 
( i == 113 
( i == 114 
( i == 115 
( i == 116 
( i == 117 
( i == 118 
( i == 12 
( i == 13 
( i == 14 
( i == 15 
( i == 16 
( i == 17 
( i == 18 
( i == 19 
( i == 2 
( i == 20 
( i == 21 
( i == 22 
( i == 23 
( i == 24 
( i == 25 
( i == 26 
( i == 27 
( i == 28 
( i == 29 
( i == 3 
( i == 30 
( i == 31 
( i == 32 
( i == 33 
( i == 34 
( i == 35 
( i == 36 
( i == 37 
( i == 38 
( i == 39 
( i == 4 
( i == 40 
( i == 41 
( i == 42 
( i == 43 
( i == 44 
( i == 45 
( i == 46 
( i == 47 
( i == 48 
( i == 49 
( i == 5 
( i == 50 
( i == 51 
( i == 52 
( i == 53 
( i == 54 
( i == 55 
( i == 56 
( i == 57 
( i == 58 
( i == 59 
( i == 6 
( i == 60 
( i == 61 
( i == 62 
( i == 63 
( i == 64 
( i == 65 
( i == 66 
( i == 67 
( i == 68 
( i == 69 
( i == 7 
( i == 70 
( i == 71 
( i == 72 
( i == 73 
( i == 74 
( i == 75 
( i == 76 
( i == 77 
( i == 78 
( i == 79 
( i == 8 
( i == 80 
( i == 81 
( i == 82 
( i == 83 
( i == 84 
( i == 85 
( i == 86 
( i == 87 
( i == 88 
( i == 89 
( i == 9 
( i == 90 
( i == 91 
( i == 92 
( i == 93 
( i == 94 
( i == 95 
( i == 96 
( i == 97 
( i == 98 
( i == 99 
( i == db.aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] 
( i == db.aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] - 1 
( i == nByte 
( i == pIdx.nColumn 
( i == pTab.iPKey 
( i == z.Length 
( i > 0 
( i > 0 && ( zTName == null || zTName.Length == 0 
( i > 1 
( i > 10 
( i > mxSqlLen 
( i > nEqCol 
( i > p.iSize 
( i > pParse.nVar 
( i >= 0 
( i >= 0 && i < db.nDb 
( i >= 0 && i < p.db.nDb && i < sizeof( u32 
( i >= 1 
( i >= db.nDb 
( i >= nChar 
( i >= p.contextStackDepth 
( i >= p.nLabelAlloc 
( i >= p.nOp 
( i >= pAggInfo.nFunc 
( i >= pParse.nVarExpr 
( i >= wsdAutoext.nExt 
( i >> 32 
( i++ 
( i-- != 0 
( i<0 || i>=YY_SZ_ACTTAB || yy_lookahead[i]!=iLookAhead 
( i<19 
( i<nType 
( i==0 || pArray->aBtree[i-1]->pBt<p->pBt 
( i==pOrderBy.nExpr 
( i==wsdAutoext.nExt 
( i>=0xD800 && i<0xE000 
( i>=0xD800 && i<=0xDFFF 
( iA == -1 
( iA == -1 && iB == SMALLEST_INT64 
( iA == 0 
( iAlias 
( iAlias > 0 && iAlias <= pParse.nAlias 
( iArg < 0 
( iB % iA 
( iBatch != pRowSet.iBatch 
( iCell 
( iChunkOffset == 0 
( iCnt == 1 
( iCnt > 1 
( iCol < 0 
( iCol < 1 
( iCol < pTab.nCol 
( iCol <= 0 || iCol > pEList.nExpr 
( iCol = 0 ; iCol < pTab.nCol ; iCol++ 
( iCol == -1 || ( iCol >= 0 && iCol < pTab.nCol 
( iCol == 0 
( iCol == 31 
( iCol == 32 
( iCol == pTab.iPKey ? -1 : iCol 
( iCol > 0 
( iCol >= -1 && iCol < 32768 
( iCol >= 0 
( iCol >= 0 && iCol < pEList.nExpr 
( iCol >= 0 && iCol < pTab.nCol 
( iCol >= 32 
( iCol==pTab.nCol 
( iCol>=0 
( iColumn < 0 
( iColumn == pIdx.pTable.iPKey 
( iCompare != 0 
( iCompare < 0 
( iCompare == 0 
( iCur < p.nCursor 
( iCur >= 0 
( iDb 
( iDb < 0 
( iDb < SQLITE_MAX_ATTACHED + 2 
( iDb < db.nDb 
( iDb < pParse.db.nDb 
( iDb = 0 ; iDb < db.nDb ; iDb++ 
( iDb == 0 
( iDb == 0 && meta[BTREE_FILE_FORMAT - 1] >= 4 
( iDb == 0 || 0 == db.init.busy 
( iDb == 0 || iDb >= 2 
( iDb == 1 
( iDb == 1 && sqlite3OpenTempDatabase( pParse 
( iDb == 1 || sqlite3BtreeHoldsMutex( db.aDb[iDb].pBt 
( iDb > 0 
( iDb >= 0 
( iDb >= 0 && iDb < db.nDb 
( iDb >= 2 
( iDb<0 
( iDb==1 
( iDb>=0 
( iDb>=0 && iDb<db->nDb 
( iDc&(SQLITE_IOCAP_ATOMIC|(ii>>8
( iDepth = 1 ; pList != null ; iDepth++ 
( iDepth == 1 
( iDest == PENDING_BYTE_PAGE( p.pDest.pBt 
( iDestroyed == 0 || iTab < iDestroyed 
( iEnc = 0 ; encnames[iEnc].zName != null ; iEnc++ 
( iFirst < pList.nExpr 
( iIdxCur >= 0 
( iKey == SMALLEST_INT64 && ( pIn3.r < (double
( iLargest == 0 
( iLength[i] == n && sqlite3StrNICmp( zText.Substring( iOffset[i] 
( iLimit < -1 
( iLimit <= pCache.iMaxKey 
( iLimit > 0 
( iLimit >= -1 
( iMeta != pOp.p2 
( iNewSum >> ( sizeof( i64 
( iOff % nDestPgsz 
( iOff % nSrcPgsz 
( iOff + JOURNAL_CHUNKSIZE 
( iOff / nDestPgsz 
( iOff = iEnd - (i64
( iOffset + 2 >= z.Length || z[iOffset + 1] != '*' 
( iOffset + i 
( iOffset + i == z.Length 
( iOfst 
( iOfst % JOURNAL_CHUNKSIZE 
( iOfst + iAmt 
( iOfst + iAmt <= p.endpoint.iOffset 
( iOfst == p.endpoint.iOffset 
( iPtrMap * nPagesPerMapPage 
( iRandom % ( zChars.Length - 1 
( iReg != 0 && pParse.nTempReg < ArraySize( pParse.aTempReg 
( iReg != target + i 
( iReg == 0 
( iReg > 0 
( iReg >= 0 && pTab.aCol[i].affinity == SQLITE_AFF_REAL 
( iRollback != 0 
( iSavepoint < pPager.nSavepoint 
( iSavepoint >= 0 || op == SAVEPOINT_ROLLBACK 
( iSet != 0 
( iSet == -1 || iSet >= 0 
( iSet >= 0 
( iSet >= 0 ? iSet & 0xf : 0xff 
( iSortOrder == 0 || iSortOrder == 1 
( iSrcPg != PENDING_BYTE_PAGE( p.pSrc.pBt 
( iStart <= pSrc.nSrc 
( iStart >= 0 
( iTabDb==1 || isTemp 
( iTarget > 0 
( iTrigDb == iDb || iTrigDb == 1 
( iType 
( iType-2 < sizeof(winMutex_staticMutexes
( iVal < 0 
( iZnum < zNum.Length && zNum[iZnum] == '0' 
( id 
( id != null 
( id-2 < (int
( id-2 >= 0 
( id.sectorSize 
( idx < (int
( idx < p.nResColumn 
( idx = 0 ; idx < ArraySize( fmtinfo 
( idx = 1 ; idx < precision ; idx++ 
( idx = precision - length ; idx > 0 ; idx-- 
( idx == pTab.iPKey 
( idx1 < szHdr1 
( idx1 < szHdr1 && i < pPKey2.nField 
( idx1 == szHdr1 && rc != 0 
( idx==BTREE_LARGEST_ROOT_PAGE && pMeta>0 
( idxNew == 0 
( idxNew1 == 0 
( idxNew2 == 0 
( ifExists == 0 
( ifNotExist == 0 
( ii = 0 ; ( nPage < 0 || ii < nPage 
( ii = 0 ; ii < db.nDb ; ii++ 
( ii = 0 ; ii < nField ; ii++ 
( ii = 0 ; ii < nPage && rc == SQLITE_OK ; ii++ 
( ii = 0 ; ii < nPage ; ii++ 
( ii = 0 ; ii < p.pOrderBy.nExpr ; ii++ 
( ii = 0 ; ii < pOrWc.nTerm ; ii++ 
( ii = 0 ; ii < pPager.nSavepoint ; ii++ 
( ii = 0 ; rc == SQLITE_OK && ii < nJRec && pPager.journalOff < szJ ; ii++ 
( ii = 1 ; ii < db.nDb ; ii++ 
( ii = 2 ; ii < db.nDb ; ii++ 
( ii = nCurrent ; ii < nSavepoint ; ii++ 
( ii = nNew ; ii < pPager.nSavepoint ; ii++ 
( ii = pSavepoint.iSubRec ; rc == SQLITE_OK && ii < pPager.nSubRec ; ii++ 
( inMultIsEst != 0 && nRow * 2 > pProbe.aiRowEst[0] 
( inReg != target 
( inReg != target && pParse.pVdbe != null 
( indexable == 0 ? 0 : WO_OR 
( info.iOverflow 
( infop._base 
( initData.rc != 0 
( int 
( int X 
( int _pOrWC = 0 ; _pOrWC < pOrWC.nTerm ; _pOrWC++ 
( int _pt = 0 ; _pt < pWC.nTerm ; _pt++ 
( int action 
( int balance_deeper_called = 0 
( int balance_quick_called = 0 
( int h 
( int i 
( int i = 0 ; i < 20 ; i++ 
( int i = 0 ; i < Limit ; i++ 
( int i = 0 ; i < N ; i++ 
( int i = 0 ; i < aOvfl.Length ; i++ 
( int i = 0 ; i < columnCount ; i++ 
( int i = 0 ; i < dbFileVers.Length ; i++ 
( int i = 0 ; i < n && i < z.Length ; i++ 
( int i = 0 ; i < n ; i++ 
( int i = 0 ; i < new_size ; i++ 
( int i = 0 ; i < p.zBLOB.Length ; i++ 
( int i = 0 ; i < pRec.zBLOB.Length ; i++ 
( int i = 0 ; i < this.aColCache.Length ; i++ 
( int i = 0 ; i < zTerm ; i++ 
( int i = p1 ; i < p1 + p2 ; i++ 
( int iCacheLevel = pParse.iCacheLevel; 
( int iType 
( int id 
( int ii = 0 ; ii < nChar ; ii++ 
( int index 
( int ms 
( int n 
( int nByte 
( int nRef = sqlite3PagerRefcount(pPager
( int nSize 
( int op 
( int pD0 = 0 ; pD0 < nField ; pD0++ 
( int pD0 = pOp.p1 ; pD0 <= pOp.p1 + pOp.p2 - 1 ; pD0++ 
( int rI = 0 ; rI < r.nField ; rI++ 
( int ra = 0 ; ra < r.nField ; ra++ 
( int rc 
( int rc2 
( int rc; 
( int resetFlag 
( int sz 
( int x 
( int z 
( invalidateTempStorage( pParse 
( isAgg 
( isAgg && pSub.pOrderBy != null 
( isAgg && subqueryIsAgg 
( isAgg || ( p.selFlags & SF_Distinct 
( isAgg || pGroupBy != null 
( isAggSub 
( isAppropriateForFactoring( pExpr 
( isBtreeCursor != 0 
( isBtreeCursor ? sqlite3BtreeCursorSize(
( isComplete 
( isDeferred == 0 || isDeferred == 1 
( isDirect 
( isDirectMode 
( isDirectMode == false 
( isDistinct 
( isDistinct != 0 ? SF_Distinct : 0 
( isErrorReset || isHotJournal != 0 
( isExplain != 0 && nMem < 10 
( isHot != 0 || iHdrOff != pPager.journalHdr 
( isIndex 
( isMainJrnl != 0 
( isMainJrnl != 0 && ( 0 == isSavepnt || pOffset <= pPager.journalHdr 
( isMainJrnl != 0 || pDone != null 
( isMatchOfColumn( pExpr 
( isMemdb==null && zFilename && zFilename[0] 
( isMinQuery != 0 
( isNT(
( isOpen( pPager.fd 
( isOpen( pPager.jfd 
( isOpen( pPager.sjfd 
( isOpen(pPager.fd
( isOpen(pPager.jfd
( isOuter 
( isReduced 
( isRowid 
( isSavepnt != 0 
( isSavepnt != 0 || pDone == null 
( isSpecialError 
( isTemp 
( isTemp != 0 
( isTransaction != 0 && p1 == SAVEPOINT_RELEASE 
( isUpdate 
( isUpdate && rowidChng 
( isUpdate ? OPFLAG_ISUPDATE : OPFLAG_LASTROWID 
( isView 
( isView != 0 && pTab.pSelect == null 
( isView != 0 || isVirtual != 0 
( isVirtual != 0 
( isWriteLock == 0 || isWriteLock == 1 
( isWriteLock || 0==(db.flags&SQLITE_ReadUncommitted
( isWriteLock==null || isWriteLock==1 
( is_agg 
( is_agg && 0 == pNC.allowAgg 
( isnull 
( iz < z.Length && z[iz] != '\0' 
( iz < zIn.Length && ( zIn[iz] & 0xC0 
( iz < zIn.Length && zIn[iz - 1] >= 0xC0 
( j != 1 
( j < 0 
( j < 0 || nColumn == 0 || ( pColumn != null && j >= pColumn.nId 
( j < i 
( j < pTabList.nSrc 
( j < zIdent.Length && zIdent[j] != 0 
( j = 0 ; ALWAYS( j < pTabList.nSrc 
( j = 0 ; j < 15 && j < pMem.n ; j++ 
( j = 0 ; j < 2 && 0 == okToChngToIN ; j++ 
( j = 0 ; j < 3 ; j++ 
( j = 0 ; j < ArraySize( aKeyword 
( j = 0 ; j < ArraySize( db.aFunc.a 
( j = 0 ; j < BITVEC_NINT ; j++ 
( j = 0 ; j < db.nDb ; j++ 
( j = 0 ; j < i ; j++ 
( j = 0 ; j < n ; j++ 
( j = 0 ; j < nCol ; j++ 
( j = 0 ; j < nConstraint ; j++ 
( j = 0 ; j < nEq ; j++ 
( j = 0 ; j < nOrderBy ; j++ 
( j = 0 ; j < nRoot ; j++ 
( j = 0 ; j < p.nCol ; j++ 
( j = 0 ; j < p.nOp ; j++ 
( j = 0 ; j < pAndWC.nTerm ; j++ 
( j = 0 ; j < pColumn.nId ; j++ 
( j = 0 ; j < pEList.nExpr ; j++ 
( j = 0 ; j < pFK.nCol ; j++ 
( j = 0 ; j < pGroupBy.nExpr ; j++ 
( j = 0 ; j < pIdx.nColumn ; j++ 
( j = 0 ; j < pKeyInfo.nField ; j++ 
( j = 0 ; j < pLeftTab.nCol ; j++ 
( j = 0 ; j < pList.nId ; j++ 
( j = 0 ; j < pProbe.nColumn ; j++ 
( j = 0 ; j < pTab.nCol ; j++ 
( j = 0 ; j < pTabList.nSrc && pTabList.a[j].iCursor != pExpr.iTable ; j++ 
( j = 0 ; j < pWC.nTerm ; j++ 
( j = 0 ; j < zIdent.Length ; j++ 
( j = 0 ; pColl == null && j < nArg ; j++ 
( j = 0 ; pIdx.aiColumn[j] != iColumn ; j++ 
( j = 1 ; j <= nConstraint ; j++ 
( j = cnt = 0 ; j < i ; j++ 
( j = iFrom ; j < pTabList.nSrc ; j++ 
( j = pLevel.u._in.nIn ; j > 0 ; j-- 
( j = pWC.nTerm ; j > 0 ; j-- 
( j == 0 || j == 1 || j == 2 || j == 3 || j == 4 || j == 5 || j == 6 
( j == 1 
( j == iFrom 
( j == nOrderBy 
( j == pTab.iPKey 
( j == pTab.iPKey ? -1 : j 
( j >= 0 
( j >= 0 && j < p.nLabel 
( j >= ArraySize( aKeyword 
( j >= nTerm 
( j >= p.nCol 
( j >= pTab.nCol 
( j+nStr-i+1==nOut 
( j<4 
( j<=nOut 
( jointype & ( JT_INNER | JT_OUTER 
( jointype & ( JT_LEFT | JT_RIGHT 
( jointype & JT_ERROR 
( jumpIfNull == 0 
( jumpIfNull == SQLITE_JUMPIFNULL || jumpIfNull == 0 
( k 
( k < pEList.nExpr 
( k <= n 
( k = 0 ; k < nConstraint ; k++ 
( k = 0 ; k < pAggInfo.nColumn ; k++ 
( k = 0 ; k < pEList.nExpr ; k++ 
( k = 0 ; k < pIdx.nColumn ; k++ 
( k = 0 ; k < pUsing.nId ; k++ 
( k = p.pEList.nExpr ; k > 0 ; k-- 
( k = pDb.pSchema.tblHash.first ; k != null ; k = k.next 
( k = pGroupBy.nExpr ; k > 0 ; k-- 
( k = pSchema.tblHash.first ; k != null ; k = k.next 
( k = pWC.nTerm ; k != 0 ; k-- 
( k = pWInfo.iTop ; k < last ; k++ 
( k = sqliteHashFirst( pDb.pSchema.tblHash 
( k == nConstraint 
( k == pIdx.nColumn 
( k >= 0 && k < pSrc.nSrc 
( key 
( keyColumn < 0 
( keyColumn >= 0 
( lastTokenParsed != TK_SEMI 
( len 
( len != 0 
( len - pMem.n 
( len < zString.Length && patternCompare( inPattern.Substring( inPattern.Length - zPattern.Length - 1 
( len <= (u32
( len == 0 
( len == zBLOB.Length 
( len > (int
( len > (u32
( len > 0 
( length = 0 ; length < precision && length < bufStr.Length && buf[length] != 0 ; length++ 
( length == SHARED_SIZE 
( length > 0 
( level == 1 || pPager.tempFile 
( level == 3 && !pPager.tempFile 
( limitId < 0 || limitId >= SQLITE_N_LIMIT 
( locktype != PENDING_LOCK 
( locktype != RESERVED_LOCK || pFile.locktype == SHARED_LOCK 
( locktype <= SHARED_LOCK 
( locktype == EXCLUSIVE_LOCK && res != 0 
( locktype == NO_LOCK && type >= SHARED_LOCK 
( locktype == SHARED_LOCK && getReadLock( pFile 
( locktype == SHARED_LOCK && res != 0 
( long 
( long unixTime 
( longNames 
( longNames || pTabList.nSrc > 1 
( longvalue % 10 
( longvalue == 0 
( m 
( m == 0 
( m.flags & MEM_Dyn 
( m.n - lenRowid 
( m.zMalloc != 0 
( makeDflt != 0 || vfsList == null 
( mask != 0 ? pList : null 
( mask == -1 || mask == 0 
( mask == 0 
( matchSet < 0x80 
( mem0.alarmCallback != null 
( mem0.alarmCallback==0 
( mem0.mutex 
( mem0.nScratchFree == 0 
( memDb != 0 
( memId > 0 
( memRootPage >= 0 
( meta + aCopy[i + 1] 
( meta[BTREE_TEXT_ENCODING - 1] != 0 
( meta[BTREE_TEXT_ENCODING - 1] != ENC( db 
( meta[BTREE_TEXT_ENCODING - 1] & 3 
( minusFlag != 0 
( ms > 0 
( mustBeUnique == false || ( pIdx.nColumn == 1 && pIdx.onError != OE_None 
( mutex 
( mutexIsNT(
( mxErr <= 0 
( mxPage > 0 
( mxSelect != 0 && cnt > mxSelect 
( n 
( n != P4_KEYINFO && n != P4_VTAB 
( n * 2 + 1 
( n - 1 
( n - 1 < zBuf.Length 
( n - Z 
( n / 2 + 1 
( n < (u64
( n < 0 
( n < 1 
( n < 2 
( n < 50 
( n <= 0 
( n <= 0 || n >= 0x7fffff00 
( n <= 9 
( n <= pTab.nCol 
( n = (int
( n = 0 ; n < nArg ; n++ 
( n = 0 ; n < nVar ; n++ 
( n = 0 ; n < pIdx.nColumn ; n++ 
( n = 0 ; n < z.Length ; n++ 
( n = 0 ; n <= nMem ; n++ 
( n = 1 ; n < p.nMem ; n++ 
( n == ( db.nSavepoint + db.isTransactionSavepoint 
( n == (u64
( n == 0 
( n == 0 || ( pOp.p2 > 0 && pOp.p2 + n <= p.nMem + 1 
( n == 3 && z.ToString(
( n == 4 && z.ToString(
( n == 5 && z.ToString(
( n == 6 && z.ToString(
( n == BMS - 1 
( n == P4_COLLSEQ 
( n == P4_DYNAMIC || n == P4_STATIC 
( n == P4_FUNCDEF 
( n == P4_INT32 
( n == P4_INT64 
( n == P4_INTARRAY 
( n == P4_KEYINFO 
( n == P4_KEYINFO_HANDOFF || n == P4_KEYINFO_STATIC 
( n == P4_MEM 
( n == P4_REAL 
( n == P4_VTAB 
( n == db.aLimit[SQLITE_LIMIT_LENGTH] 
( n == db.aLimit[SQLITE_LIMIT_LENGTH] + 1 
( n == pBlob.Length 
( n > (u32
( n > (u64
( n > 0 
( n > 0 && n < pPager.pageSize 
( n > 0 && n <= z.Length 
( n > 0 && p1 > 0 && p2 > 0 
( n > 0 && z[iStart + n - 1] == ' ' 
( n > 10 || n < 3 
( n > 3 && n <= 9 
( n > 30 
( n > 5 && n <= 9 
( n > db.aLimit[SQLITE_LIMIT_LENGTH] 
( n > etBUFSIZE 
( n > z.Length 
( n >= 0 
( n >= 1 
( n >= BMS 
( n+nQPlan < sizeof(sqlite3_query_plan
( n-- != 0 
( n-- > 0 
( n64 > db.aLimit[SQLITE_LIMIT_LENGTH] 
( n<0 || iOffset<0 || (iOffset+n
( n<32 
( n<=db.lookaside.sz 
( n<nChar 
( n==pPage.pgno && e==PTRMAP_BTREE 
( n==pPage.pgno && e==PTRMAP_OVERFLOW1 
( n>0 && n<=4 
( n>nMaxArgs 
( nAlloc < z.Length 
( nAlloc >= pNew.nCol && nAlloc % 8 == 0 && nAlloc - pNew.nCol < 8 
( nArg < -1 || nArg > SQLITE_MAX_FUNCTION_ARG 
( nArg == -1 && ( p.xFunc != null || p.xStep != null 
( nArg == 1 
( nArg!=0 
( nArg<=(int
( nArg>1 && apArg[0] && (apArg[0].flags&MEM_Null
( nAttempt<5 && rc==SQLITE_SCHEMA 
( nBlob * 2 
( nBuf >= 0 
( nBuf>0 
( nByte 
( nByte & 0xffffffff 
( nByte && !db.mallocFailed 
( nByte + 8 
( nByte < 0 
( nByte <= 0 
( nByte <= pcache1.szSlot && pcache1.pFree != null 
( nByte = 0 ; nByte <= iLimit && nByte < z.Length && z[nByte] != 0 ; nByte++ 
( nByte = 0 ; nByte <= iLimit && z[nByte] != 0 || z[nByte + 1] != 0 ; nByte += 2 
( nByte == 0 
( nByte == db->aLimit[SQLITE_LIMIT_LENGTH] 
( nByte == db->aLimit[SQLITE_LIMIT_LENGTH] + 1 
( nByte > 0 
( nByte > db->aLimit[SQLITE_LIMIT_LENGTH] 
( nByte > db.aLimit[SQLITE_LIMIT_LENGTH] 
( nByte > iLimit 
( nByte > szSpace
( nByte >= 0 && nByte <= zInLength 
( nByte*sizeof(zMbcsFilename[0]
( nByte*sizeof(zTemp[0]
( nByte==0 
( nBytes 
( nBytes <= 0 
( nBytes == mxLen 
( nBytes == mxLen + 1 
( nBytes > mxLen 
( nBytes >= 0 && ( nBytes == 0 || zSql[nBytes - 1] != 0 
( nBytes >= 0x7fffff00 
( nCell 
( nCellKey <= 0 || nCellKey > 0x7fffffff 
( nChar = 0 ; iz < zBytes.Length ; nChar++ 
( nChar > 0 
( nChar*sizeof(zWideFilename[0]
( nChar==0 
( nCol + 1 
( nCol == pSelect.pEList.nExpr /*|| db.mallocFailed != 0 */ 
( nColumn == 1 
( nColumn > 0 
( nConstraint 
( nDestTruncate == (int
( nEq < pProbe.nColumn 
( nErr == 0 
( nErr > 0 && pParse.rc == SQLITE_OK 
( nExpr > 1 && ( eDest == SRT_Mem || eDest == SRT_Set 
( nExtra 
( nExtra < 1000 
( nExtra == 0 
( nExtra >= 1 
( nExtra >= nColl 
( nFarg != 0 
( nFarg > 0 
( nFarg >= 2 && ( pExpr.flags & EP_InfixFunc 
( nField != 0 
( nField + 1 
( nField > 0 
( nField > 0 && pOp.p2 > 0 && pOp.p2 + nField <= p.nMem + 1 
( nFull 
( nHeader > JOURNAL_HDR_SZ( pPager 
( nHeight > mxHeight 
( nId = 1 ; ( zIdx + nId 
( nIdx + 1 
( nIdx > 0 
( nIn 
( nIn > 0 
( nKey 
( nKey == elem.nKey 
( nKey > 0 
( nKey >= 0 
( nKey1 < nKey2 
( nLocal <= nKey 
( nMaster + 20 
( nMaster = 0 ; nMaster < zMaster.Length && zMaster[nMaster] != 0 ; nMaster++ 
( nMasterJournal > 0 
( nMax - pCache.nMax 
( nMax < (int
( nMn + nHr * 60 
( nName + 1 
( nNew - nOld 
( nNew < 256 
( nNew == 0 
( nNew == 0 && op == SAVEPOINT_RELEASE && isOpen( pPager.sjfd 
( nOld == nNew 
( nOp < 1 
( nOps > 0 
( nOrderBy >= nExpr /*|| db.mallocFailed != 0 */ 
( nOut < SQLITE_MAX_LENGTH 
( nOut-1==db->aLimit[SQLITE_LIMIT_LENGTH] 
( nOut-1>db->aLimit[SQLITE_LIMIT_LENGTH] 
( nOut-2==db->aLimit[SQLITE_LIMIT_LENGTH] 
( nPad-- != 0 
( nPage == 0 
( nPage > 0 
( nPage > pPager.mxPgno 
( nPage++; 
( nPageCount + 1 - pg1 
( nPagePerSector - 1 
( nPagePerSector > 1 
( nPat == db.aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] 
( nPat == db.aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] + 1 
( nPat > db.aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] 
( nPathname * 2 
( nQPlan>0 && sqlite3_query_plan[nQPlan-1]==' ' 
( nRead >= 0 && ( pChunk = pChunk.pNext 
( nRec == 0xffffffff 
( nRef != pNC.nRef 
( nReg == 1 
( nReg > pParse.nRangeReg 
( nReserve < 0 
( nReserve >= 0 && nReserve < 1000 
( nRoot > 0 
( nRow 
( nSavepoint > nCurrent && pPager.useJournal != 0 
( nSignificant < 18 
( nSignificant == 0 
( nSrcPage + 1 - p.iNext 
( nSrcPage + ratio - 1 
( nSrcPagesize / nDestPagesize 
( nSrcPagesize < nDestPagesize 
( nSrcPgsz != nDestPgsz && sqlite3PagerIsMemdb( sqlite3BtreePager( p.pDest 
( nStructSize & ( EP_Reduced | EP_TokenOnly 
( nSubSrc > 1 
( nTemp >= 20 
( nTerm > 0 
( nToken != 0 
( nUsed + nFull >= mem0.alarmThreshold 
( nVar >= 0 /* &&  ALWAYS(db->mallocFailed==0
( nVarint < sqlite3VarintLen( (u64
( nWrite = 0 ; rc == SQLITE_OK && nWrite < JOURNAL_HDR_SZ( pPager 
( nWrite == db.writeVdbeCnt 
( nWrite > 0 
( nZero != 0 
( nameToken.z 
( nc * SQLITE_FUNC_NEEDCOLL 
( needPagerReset != 0 
( needQuote 
( needQuote ? 2 : 0 
( needSyncPgno != 0 
( needSyncPgno <= pPager.dbOrigSize 
( needXcommit && db.xCommitCallback != null 
( neg != 0 
( negFlag 
( negP2 != 0 
( negateFlag 
( newIdx != -1 || oldIdx != -1 
( newIdx >= 0 
( newLimit > aHardLimit[limitId] 
( newLimit >= 0 
( newPgno > 0 
( newVal != 0 
( new_elem == null 
( new_ht == null 
( new_size*sizeof(struct _ht
( new_size==pH->htsize 
( nextC != 0 && zIndex < zDate.Length 
( noCase 
( noContent != 0 
( noErr != 0 
( noErr == 0 
( noReadlock && readOnly ? 1 : 0 
( no_such_func 
( nspace > 0 
( null 
( null == aNew[ii].pInSavepoint 
( null == apColl 
( null == db /*|| db.mallocFailed != 0 */ 
( null == p 
( null == p && ( pOn != null || pUsing != null 
( null == p && db != null 
( null == p.pDirtyTail 
( null == p.pFirst 
( null == p.pGroupBy 
( null == p.pSrc || null == p.pDest 
( null == p.pSynced && 0 == ( pPage.flags & PGHDR_NEED_SYNC 
( null == pBest || pIdx.nColumn < pBest.nColumn 
( null == pCache.pCache && createFlag != 0 
( null == pColl 
( null == pDone 
( null == pIdx 
( null == pMaster 
( null == pNew 
( null == pPage 
( null == pPage && eCreate == 1 
( null == pPage.pData 
( null == pPager.aSavepoint && !pPager.pInJournal 
( null == pPager.pTmpSpace 
( null == pPg 
( null == pPgOld || pPgOld.nRef == 1 
( null == pRangeEnd || ( pRangeEnd.eOperator & ( WO_LE | WO_GE 
( null == pRangeStart || ( pRangeStart.eOperator & ( WO_LE | WO_GE 
( null == pSavepoint 
( null == pSrc.pIndex 
( null == pTab.pSelect 
( null == pTrigger 
( null == pVal 
( null == pVdbeFunc 
( null == pVdbeFunc || iArg >= pVdbeFunc.nAux || iArg < 0 
( null == pVdbeFunc || pVdbeFunc.nAux <= iArg 
( null == zName || xDel != SQLITE_DYNAMIC 
( null == zRight 
( null==aNew 
( null==p.pReal 
( null==p.pReal && (iOfst+iAmt
( null==p.zBuf 
( null==pNew 
( null==pTab 
( null==pTab || pTab.pSelect 
( nullId.z 
( object NotUsed 
( object o 
( object pAuxArg 
( object pBusyHandlerArg 
( object pCommitArg 
( object pProgressArg 
( object pRollbackArg 
( object[] ap 
( oc == OP_SeekGe || oc == OP_SeekGt 
( oc == OP_SeekGt || oc == OP_SeekGe 
( oc == OP_SeekGt || oc == OP_SeekLe 
( oc == OP_SeekLe || oc == OP_SeekGt 
( oc == OP_SeekLt || oc == OP_SeekGe 
( oc == OP_SeekLt || oc == OP_SeekLe 
( offset % pPager.sectorSize == 0 
( offset & 0xffffffff 
( offset + amt <= available && ( pMem.flags & MEM_Dyn 
( offset == SHARED_FIRST 
( offset == ii * ( 4 + pPager.pageSize 
( offset > 98307 
( offset >= c 
( okOnePass != 0 
( okToChngToIN != 0 
( old_col_mask != 0 
( old_col_mask == 0 
( omitJournal 
( omitTable == 0 
( onError 
( onError != OE_Abort && onError != OE_Rollback 
( onError != OE_Replace || pTab.pIndex != null 
( onError == OE_Default 
( onError == OE_Fail 
( onError == OE_Ignore 
( onError == OE_None 
( onError == OE_Replace 
( onError == OE_Replace && pTab.aCol[i].pDflt == null 
( once != 0 
( once == 0 || sCost.rCost < bestPlan.rCost 
( onoff != 0 
( onoff ? 0xffffffff : 0xff 
( op 
( op != 0 
( op != 5 
( op != OP_Noop 
( op != TK_ALL 
( op != TK_CAST && op != TK_UPLUS 
( op != TK_EQ || c == WO_EQ 
( op != TK_GE || c == WO_GE 
( op != TK_GT || c == WO_GT 
( op != TK_IN || c == WO_IN 
( op != TK_ISNULL || c == WO_ISNULL 
( op != TK_LE || c == WO_LE 
( op != TK_LT || c == WO_LT 
( op < 0 || op >= ArraySize( wsdStat.nowValue 
( op == OP_IdxGE 
( op == OP_IdxLT 
( op == OP_Last 
( op == OP_Noop 
( op == OP_Null || pP4 != null 
( op == OP_Rewind 
( op == OP_SeekGe 
( op == OP_SeekGt 
( op == OP_SeekLe 
( op == OP_SeekLt 
( op == SAVEPOINT_RELEASE || op == SAVEPOINT_ROLLBACK 
( op == SAVEPOINT_ROLLBACK && isOpen( pPager.jfd 
( op == TK_ALL 
( op == TK_ALL || op == TK_UNION 
( op == TK_AND 
( op == TK_BITAND 
( op == TK_BITNOT 
( op == TK_BITOR 
( op == TK_BLOB 
( op == TK_CASE 
( op == TK_CAST 
( op == TK_CONCAT 
( op == TK_CONST_FUNC 
( op == TK_EQ 
( op == TK_EXCEPT || op == TK_INTERSECT 
( op == TK_EXISTS 
( op == TK_FUNCTION 
( op == TK_GE 
( op == TK_GT 
( op == TK_IN 
( op == TK_INSERT || op == TK_UPDATE || op == TK_DELETE 
( op == TK_INTERSECT 
( op == TK_ISNULL 
( op == TK_LE 
( op == TK_LSHIFT 
( op == TK_LT 
( op == TK_MINUS 
( op == TK_NE 
( op == TK_NOT 
( op == TK_NOTNULL 
( op == TK_OR 
( op == TK_PLUS 
( op == TK_REM 
( op == TK_RSHIFT 
( op == TK_SELECT 
( op == TK_SLASH 
( op == TK_STRING || op == TK_FLOAT || op == TK_INTEGER 
( op == TK_UMINUS 
( op == TK_UPDATE || op == TK_INSERT || op == TK_DELETE 
( op > 0 && op < 0xff 
( op >= 0 && op < ArraySize( wsdStat.nowValue 
( op >= TK_EQ && op <= TK_GE 
( opcode == OP_Destroy 
( opcode == OP_Function || opcode == OP_AggStep 
( opcode == OP_Halt 
( opcode == OP_OpenWrite || opcode == OP_OpenRead 
( opcode == OP_Statement 
( opcode == OP_Transaction && pOp.p2 != 0 
( opcode == OP_VUpdate 
( opcode > 0 && opcode < opcodeProperty.Length 
( opcode==OP_VFilter 
( opcode==OP_VUpdate || opcode==OP_VRename 
( opcodeProperty == null 
( opcodeProperty[opcode] & mask 
( openAll || aRegIdx[i] > 0 
( openedTransaction != 0 
( openedTransaction!=0 
( orconfin == OE_Default 
( osType==0 
( out 
( out long lpPerformanceCount 
( overage 
( overage > 0 
( overrideError != OE_Default 
( p 
( p != null 
( p != null && ALWAYS( p.nSrc > 0 
( p != null && p.a != null 
( p != null && p.cnt > 0 
( p != null && p.iPrefEnc == enc && p.nArg == nArg 
( p != null && p.pFunc != null 
( p != null && p.pFunc != null && p.pFunc.xStep != null 
( p != null && p.pMem != null && p.pFunc != null && p.pFunc.xStep != null 
( p != null && p.pPrior != null 
( p != null && p[0] != null && N != 0 
( p != null && sqlite3BtreeIsInTrans( p 
( p != null && type != SQLITE_NULL 
( p != null /*|| db.mallocFailed != 0 */ 
( p !=null
( p && p->sharable 
( p = db.aCollSeq.first ; p != null ; p = p.next 
( p = db.aFunc.a[j] ; p != null ; p = pHash 
( p = db.pSavepoint ; p != null ; p = p.pNext 
( p = db.pVdbe ; p != null ; p = p.pNext 
( p = pBackup ; p != null ; p = p.pNext 
( p = pCache.pDirty ; p != null ; p = p.pDirtyNext 
( p = pCache.pDirty ; p != null ; p = pNext 
( p = pHash.a[h] ; p != null ; p = p.pHash 
( p = pList ; p != null ; p = p.pNext 
( p = pParse.pAinc ; p != null ; p = p.pNext 
( p = pTrigger ; p != null ; p = p.pNext 
( p = pcache1.pLruHead ; p != null ; p = p.pLruNext 
( p = sqliteHashFirst( db.aCollSeq 
( p = sqliteHashFirst( pTmpSchema.trigHash 
( p == null 
( p == null && mem0.alarmCallback != null 
( p == null /*|| db.mallocFailed != 0 */ || pParse.nErr != 0 
( p == null ||  sqlite3GlobalConfig.mutex.xMutexHeld( p 
( p == null ||  sqlite3GlobalConfig.mutex.xMutexNotheld( p 
( p == null || IN_DECLARE_VTAB 
( p == null || NEVER( p.nCol < 1 
( p == null || NEVER( p.nSrc == 0 
( p == null || i < 1 || i > p.nVar 
( p == null || i == 0 
( p == null || p.expired 
( p == null || p.xCmp != null 
( p == null || p.xCmp == null 
( p == null || pWalker.xSelectCallback == null 
( p == pIndex 
( p == pOld 
( p >= pcache1.pStart && p < pcache1.pEnd 
( p->azModuleArg 
( p->cnt==0 
( p->db==p->pBt->db 
( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE 
( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(p
( p->locked
( p->locked 
( p->locked && ALWAYS(p->pNext
( p->locked==0 
( p->locked==1 
( p->pBlockingConnection==0 && p->pUnlockConnection==0 
( p->pBlockingConnection==db 
( p->pNext==0 || p->pNext->db==p->db 
( p->pNext==0 || p->pNext->pBt>p->pBt 
( p->pPrev 
( p->pPrev==0 || p->pPrev->db==p->db 
( p->pPrev==0 || p->pPrev->pBt<p->pBt 
( p->pReal 
( p->pUnlockConnection || p->pBlockingConnection 
( p->pUnlockConnection==db 
( p->sharable 
( p->sharable || (p->pNext==0 && p->pPrev==0
( p->sharable || p->wantToLock==0 
( p->sharable==0 || p->locked==0 || p->db==p->pBt->db 
( p->sharable==0 || p->locked==0 || p->wantToLock>0 
( p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->db->mutex
( p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->pBt->mutex
( p->wantToLock==0
( p->wantToLock==0 
( p->wantToLock==1 
( p->wantToLock>0 
( p->xUnlockNotify 
( p->xUnlockNotify!=xUnlockNotify && nArg!=0 
( p.Context == null 
( p.M - 1 
( p.M - 12 
( p.aCol == null 
( p.aColName != null 
( p.aColName[N] 
( p.aCol[p.nCol - 1] 
( p.aLabel != null 
( p.aMem != null 
( p.aMem[n].db == db 
( p.aMem[pOp.p1 + j] 
( p.aMutex 
( p.aOp != null 
( p.aOp != null ? SQLITE_OK : SQLITE_NOMEM 
( p.aOp == null 
( p.aOp == null /*|| db.mallocFailed != 0 */
( p.aOp == null || p.aOp[p.nOp - 1].zComment == null /* || p.db.mallocFailed != 0 */
( p.aOp[i + addr] == null 
( p.aOp[i] == null 
( p.aOp[pc - 1].opcode == OP_CollSeq 
( p.aOp[pc - 1].p4type == P4_COLLSEQ 
( p.aVar != null 
( p.aVar[i] 
( p.addrOpenEphm[0] == -1 
( p.addrOpenEphm[1] == -1 
( p.apCsr == null 
( p.apCsr[iCur] != null 
( p.apCsr[pOp.p1] != null 
( p.apHash != null ? SQLITE_OK : SQLITE_NOMEM 
( p.approx 
( p.bDestLocked != 0 
( p.cacheCtr + 2 
( p.changeCntOn
( p.contextStack != null 
( p.contextStack == null 
( p.contextStackTop >= 0 
( p.db 
( p.db != null 
( p.db == null || sqlite3_mutex_held( p.db.mutex 
( p.db!=null 
( p.db.mallocFailed != 0 
( p.db.mutex 
( p.deferredMoveto 
( p.enc == pColl.enc 
( p.endpoint.iOffset % JOURNAL_CHUNKSIZE 
( p.errorAction == OE_Abort 
( p.explain != 0 
( p.explain == 0 
( p.explain == 1 
( p.flags & PGHDR_NEED_SYNC 
( p.flags & ~( MEM_TypeMask | MEM_Zero 
( p.flags & ~MEM_Str 
( p.flags2 & EP2_MallocedToken 
( p.h * 3600000 + p.m * 60000 + p.s * 1000 
( p.iDb == iDb && p.iTab == iTab 
( p.iDivisor 
( p.iDivisor != 0 
( p.iLimit != 0 
( p.iLimit != 0 && op == TK_ALL 
( p.iLimit == 0 
( p.iNext > (Pgno
( p.iOffset != 0 && iContinue != 0 
( p.iReg != 0 
( p.iReg != 0 && p.iLevel > pParse.iCacheLevel 
( p.iReg != 0 && p.iTable == iTab && p.iColumn == iCol 
( p.iReg == 0 
( p.iReg == iReg 
( p.iSize + BITVEC_NPTR - 1 
( p.iSize <= BITVEC_NBIT 
( p.iSize<(iOfst+iAmt
( p.iSize>0 
( p.iStatement == ( db.nStatement + db.nSavepoint 
( p.iStatement == 0 
( p.iStatement == 0 || ( db.flags & SQLITE_CountRows 
( p.iSum == 42 
( p.iSum >> ( sizeof( i64 
( p.idxHash 
( p.inTrans!=TRANS_NONE 
( p.inTrans>0 
( p.isAttached != 0 
( p.isIncrblobHandle && (isClearTable || p.info.nKey==iRow
( p.isPrepareV2 && rc != SQLITE_ROW && rc != SQLITE_DONE 
( p.isSorted && rowid <= pLast.v 
( p.isSorted == false 
( p.isTable 
( p.lock.pBtree==p && p.lock.iTable==1 
( p.locked==null 
( p.lru < minLru 
( p.magic != VDBE_MAGIC_RUN 
( p.magic != VDBE_MAGIC_RUN || p.pc >= 0 
( p.magic == VDBE_MAGIC_INIT 
( p.magic == VDBE_MAGIC_RUN 
( p.magic == VDBE_MAGIC_RUN && p.pc >= 0 
( p.magic == VDBE_MAGIC_RUN || p.magic == VDBE_MAGIC_HALT 
( p.mallocFailed 
( p.nAlloc 
( p.nArg == nArg || nArg == -1 
( p.nChar + N >= p.nAlloc 
( p.nCol + 1 > db.aLimit[SQLITE_LIMIT_COLUMN] 
( p.nColumn!=nCol 
( p.nData + need >= p.nAlloc 
( p.nFresh == 0 
( p.nHash != 0 
( p.nHeight > pnHeight 
( p.nOp != 0 
( p.nOp + nOp > p.nOpAlloc && growOpArray( p 
( p.nOp > 0 
( p.nOp > 0 || p.aOp == null 
( p.nOp > addr 
( p.nOp==0 
( p.nOpAlloc != 0 ? p.nOpAlloc * 2 : 1024 / 4 
( p.nOpAlloc <= i 
( p.nRef !=0|| (p.flags&PGHDR_NEED_SYNC
( p.nRef == 0 
( p.nRef == 1 
( p.nRef > 0 
( p.nResColumn == pOp.p2 
( p.nRow==0 
( p.nRow==0 && argv!=null 
( p.nSet < ( BITVEC_NINT - 1 
( p.nSet >= BITVEC_MXHASH 
( p.nSrc > 0 
( p.nTab == 0 
( p.needToFreeIdxStr !=0
( p.op 
( p.op == TK_BLOB 
( p.op == TK_COLUMN 
( p.op == TK_EXCEPT 
( p.op == TK_FLOAT 
( p.op == TK_INTEGER 
( p.op == TK_INTERSECT 
( p.op == TK_NULL 
( p.op == TK_STRING 
( p.op == TK_UNION 
( p.op == TK_UPLUS 
( p.op == TK_VARIABLE 
( p.overflow != 0 
( p.pBt.inTransaction != TRANS_NONE || p.pBt.nTransaction == 0 
( p.pBt.inTransaction >= p.inTrans 
( p.pBt.inTransaction!=TRANS_NONE || p.pBt.nTransaction==0 
( p.pBt.inTransaction>=p.inTrans 
( p.pBt<pSib.pBt 
( p.pCache.bPurgeable 
( p.pCheck != null 
( p.pDest 
( p.pDest.pBt 
( p.pDestDb != null 
( p.pDestDb != null && p.pSrc.pBt.inTransaction == TRANS_WRITE 
( p.pDestDb.mutex 
( p.pEList 
( p.pEList != null 
( p.pEList != null && pPrior.pEList != null 
( p.pEList && p.pEList.nExpr>db.aLimit[SQLITE_LIMIT_COLUMN] 
( p.pEList.nExpr != pPrior.pEList.nExpr 
( p.pEntry != null 
( p.pEntry == null 
( p.pFirst != null 
( p.pGroupBy 
( p.pGroupBy != null 
( p.pGroupBy == null 
( p.pGroupBy == null || ( p.selFlags & SF_Aggregate 
( p.pHaving 
( p.pHaving != null 
( p.pHaving != null && pGroupBy == null 
( p.pLeft 
( p.pLeft != null 
( p.pLeft != null || p.pRight != null || p.pColl != null || p.x.pList != null || p.x.pSelect != null 
( p.pLeft.op == TK_FLOAT || p.pLeft.op == TK_INTEGER 
( p.pLimit != null 
( p.pLimit == null 
( p.pMethods!=&JournalFileMethods 
( p.pNext 
( p.pNext != null 
( p.pNext != null && p.pNext != pVfs 
( p.pNext == pVfs 
( p.pOffset != null 
( p.pOffset == null 
( p.pOffset == null || p.pLimit != null 
( p.pOrderBy 
( p.pOrderBy != null 
( p.pOrderBy != null && pSub.pOrderBy != null 
( p.pOrderBy == null 
( p.pOrderBy.a[ii].iCol == 0 
( p.pPrev 
( p.pPrev != null 
( p.pPrior != null 
( p.pPrior == null 
( p.pReal 
( p.pResultSet[i] 
( p.pResultSet[i_pMem] == null 
( p.pRight 
( p.pRight != null 
( p.pRightmost != null && pSub.pLimit != null && pSub.pOrderBy != null 
( p.pRightmost != p 
( p.pRightmost == null 
( p.pRightmost == p 
( p.pSchema != null 
( p.pSchema == p.pTabSchema || p.pSchema == db.aDb[1].pSchema 
( p.pSelect == null 
( p.pSrc 
( p.pSrc != null 
( p.pSrcDb.mutex 
( p.pSynced == pPage 
( p.pTabSchema != null 
( p.pTree != null 
( p.pWhere 
( p.pWhere != null 
( p.pc < 0 
( p.pc <= 0 && p.expired 
( p.pc >= 0 
( p.pgno == 1 
( p.pgno > pgno 
( p.rc != 0 
( p.rc != 0 && p.expired 
( p.rc != SQLITE_IOERR_BLOCKED 
( p.rc != SQLITE_OK && ( db.flags & SQLITE_InternChanges 
( p.rc != SQLITE_ROW && p.rc != SQLITE_DONE 
( p.rc == SQLITE_DONE 
( p.rc == SQLITE_NOMEM 
( p.rc == SQLITE_OK 
( p.rc == SQLITE_OK || ( p.errorAction == OE_Fail && !isSpecialError 
( p.rc == SQLITE_OK || p.errorAction == OE_Fail 
( p.rc == SQLITE_OK || p.rc == SQLITE_BUSY 
( p.rc == SQLITE_OK || p.rc == SQLITE_BUSY || p.rc == SQLITE_NOMEM 
( p.readOnly == false 
( p.readpoint.iOffset != iOfst || iOfst == 0 
( p.selFlags & SF_Aggregate 
( p.selFlags & SF_Distinct 
( p.selFlags & SF_Expanded 
( p.selFlags & ~SF_Distinct 
( p.selFlags & ~SF_UsesEphemeral 
( p.sharable 
( p.sharable || 0==*ppIter 
( p.tblHash 
( p.tempReg != 0 
( p.tooBig 
( p.tooBig != 0 
( p.trace != null 
( p.trace == null && pc == 0 
( p.trigHash 
( p.u.aHash[h] != 0 
( p.u.aHash[h] == i 
( p.u.apSub[bin] == null 
( p.u.pRowSet 
( p.u.zToken 
( p.v < iRowid 
( p.v > iRowid 
( p.validHMS != 0 
( p.validJD != 0 
( p.validTZ != 0 
( p.validYMD != 0 
( p.wantToLock==null 
( p.wc 
( p.xDel != null 
( p.z.Length == 0 
( p.z.ToString(
( p.zBLOB == null && p.z != null 
( p.zErrMsg
( p.zErrMsg != 0 
( p.zName 
( p.zText.ToString(
( p0type != SQLITE_BLOB 
( p0type == SQLITE_BLOB 
( p1 + n <= p2 || p2 + n <= p1 
( p1 + p2 > len 
( p1 < 0 
( p1 < p.nCursor 
( p1 == SAVEPOINT_BEGIN 
( p1 == SAVEPOINT_BEGIN || p1 == SAVEPOINT_RELEASE || p1 == SAVEPOINT_ROLLBACK 
( p1 == SAVEPOINT_RELEASE 
( p1 == SAVEPOINT_ROLLBACK && ( db.flags & SQLITE_InternChanges 
( p1 == SAVEPOINT_ROLLBACK && db.activeVdbeCnt > 1 
( p1 > 0 
( p1 > 0 && p1 + n <= p.nMem + 1 
( p1 >= 0 && p1 + n <= p.nVar 
( p1 >= 0 && p1 < db.nDb 
( p1 >= 0 && p2 >= 0 
( p2 < 0 
( p2 < nField 
( p2 <= p.nMem 
( p2 > 0 
( p2 > 0 && p2 + n <= p.nMem + 1 
( p2 >= 1 && p2 + n - 1 <= p.nMem 
( p2->xUnlockNotify==p->xUnlockNotify 
( p2->xUnlockNotify==p->xUnlockNotify || !seen 
( p4 != null 
( p4type 
( p==0 
( p==null 
( p==pBt.pWriter 
( pA 
( pA != null 
( pA != null && pB != null 
( pA == null || pB == null 
( pA.iTable != pB.iTable || pA.iColumn != pB.iColumn 
( pA.op != TK_COLUMN && pA.u.zToken != null 
( pA.op != pB.op 
( pA.pRight == null || pA.v <= pA.pRight.v 
( pA.pgno < pB.pgno 
( pA.v < pB.v 
( pA.x.pList != null && pB.x.pList != null 
( pA.x.pList != null || pB.x.pList != null 
( pA.x.pList.nExpr != pB.x.pList.nExpr 
( pAccum != null 
( pAccum.Context == null 
( pAccum.mallocFailed != 0 
( pAccum.tooBig != 0 
( pAggInfo != null 
( pAggInfo.directMode == 0 
( pAggInfo.nFunc + pAggInfo.nColumn == 0 
( pAggInfo.pGroupBy != null 
( pAggInfo.useSortingIdx != 0 
( pAlias != null 
( pAlias.n != 0 
( pAndInfo != null 
( pAndTerm.pExpr != null 
( pArg->z==0 
( pArray->aBtree[i]!=pBtree 
( pArray->aBtree[i]->pBt>pBt 
( pArray->nMutex<ArraySize(pArray->aBtree
( pArray->nMutex>=0 
( pAuthArg 
( pAutoinc 
( pAux.xDelete != null 
( pAuxData.pAux != null && pAuxData.xDelete != null 
( pB 
( pB != null 
( pB == null || pB.pRight == null || pB.v <= pB.pRight.v 
( pB.flags & EP_Distinct 
( pB.pRight == null || pB.v <= pB.pRight.v 
( pB.u.zToken == null 
( pB.v < pA.v 
( pBegin.z.Length - sEnd.z.Length 
( pBest != null && ( pBest.xStep != null || pBest.xFunc != null || createFlag != 0 
( pBest != null && pBest.nColumn < pTab.nCol 
( pBest = new FuncDef(
( pBest == null 
( pBest.flags != 0 
( pBitvec == null || pV == null || pTmpSpace == null 
( pBlock 
( pBt 
( pBt != null 
( pBt != null && sqlite3BtreeIsInBackup( pBt 
( pBt == null 
( pBt == null || ( pPager = sqlite3BtreePager( pBt 
( pBt.isExclusive==null || pBt.pWriter==pLock.pBtree 
( pBt.isPending==null || pBt.pWriter 
( pBt.mutex==null 
( pBt.nRef<=0 
( pBt.nRef>0 
( pBt.nTransaction==2 
( pBt.pPager 
( pBt.pWriter!=p && pBt.isExclusive 
( pBt.pWriter==p 
( pBt.pageSize 
( pBt.pageSize - 8 
( pBt==null 
( pBtree 
( pBtree != null 
( pBtree==0 || pBtree->sharable==0 
( pBuf == 0 
( pBuf == null 
( pBuf.Length >= amt 
( pC 
( pC != null 
( pC == null 
( pC.aRow != -1 
( pC.cacheStatus == p.cacheCtr 
( pC.deferredMoveto 
( pC.deferredMoveto == false 
( pC.ephemPseudoTable 
( pC.iDb >= 0 
( pC.isIndex 
( pC.isIndex || pOp.opcode == OP_RowData 
( pC.isTable 
( pC.isTable || pOp.opcode == OP_RowKey 
( pC.nData > 0 
( pC.nullRow 
( pC.pCursor 
( pC.pCursor != null 
( pC.pCursor != null || pC.pseudoTable 
( pC.pData == null 
( pC.pVtabCursor 
( pC.pVtabCursor==0 
( pC.pseudoTable 
( pC.pseudoTable == false 
( pC.rowidIsValid 
( pC.useRandomRowid 
( pCache 
( pCache != null 
( pCache.apHash[h] == pPage 
( pCache.bPurgeable 
( pCache.bPurgeable ? 1 : 0 
( pCache.bPurgeable || createFlag != 1 
( pCache.nHash > 0 
( pCache.nMax * 9 / 10 
( pCache.nPage == nPage 
( pCache.nPage >= pCache.nHash && pcache1ResizeHash( pCache 
( pCache.nRef == 0 && pCache.pDirty == null 
( pCache.pCache 
( pCache.pCache != null 
( pCache.pDirty 
( pCache.szPage 
( pCell 
( pCell != null 
( pCell++ 
( pCellKey == null 
( pCheck != null 
( pCheck.errMsg.mallocFailed 
( pChunk != null 
( pChunk = p.pChunk ; pChunk != null ; pChunk = pNextChunk 
( pCol 
( pCol != null 
( pCol.affinity - SQLITE_AFF_TEXT < azType.Length 
( pCol.affinity - SQLITE_AFF_TEXT >= 0 
( pCol.affinity == 0 
( pCol.affinity == SQLITE_AFF_INTEGER 
( pCol.affinity == SQLITE_AFF_NONE 
( pCol.affinity == SQLITE_AFF_NUMERIC 
( pCol.affinity == SQLITE_AFF_REAL 
( pCol.affinity == SQLITE_AFF_TEXT 
( pCol.iMem > 0 
( pCol.iSorterColumn < 0 
( pCol.iSorterColumn >= j 
( pCol.isPrimKey != 0 
( pCol.notNull != 0 && pDflt == null 
( pCol.zDflt != null 
( pCol.zName 
( pCol.zType 
( pCol.zType == null 
( pColExpr.op == TK_COLUMN && ALWAYS( pColExpr.pTab != null 
( pColExpr.op == TK_DOT 
( pColExpr.op == TK_ID 
( pColl != null 
( pColl != null && pColl.xCmp != null 
( pColl != null || pLeft.iColumn == -1 
( pColl != null || pParse.nErr != 0 
( pColl == null 
( pColl == null || pColl.xCmp != null 
( pColl.type != SQLITE_COLL_NOCASE || !pnoCase 
( pColl.zName 
( pColl2.xCmp != null 
( pColl[j].xDel != null 
( pColumn != null 
( pColumn != null && j >= pColumn.nId 
( pColumn != null && nColumn != pColumn.nId 
( pColumn == null 
( pColumn == null && nColumn != 0 && nColumn != ( pTab.nCol - nHidden 
( pColumn == null && nColumn > 0 
( pColumn.a[j].idx == i 
( pColumns != null 
( pCons.z == null 
( pContext->pParse 
( pCost.plan.wsFlags & WHERE_INDEXED 
( pCost.plan.wsFlags | eqTermMask 
( pCost.rCost 
( pCrsr 
( pCrsr != null 
( pCrsr == null 
( pCsr.apPage[pCsr.iPage].intKey 
( pCsr.eState!=CURSOR_REQUIRESEEK 
( pCsr.eState!=CURSOR_VALID 
( pCsr.isIncrblobHandle 
( pCtx 
( pCtx.s 
( pCur 
( pCur == null 
( pCur.aOverflow 
( pCur.aOverflow && pCur.aOverflow[iIdx+1] 
( pCur.aOverflow && pCur.aOverflow[offset/ovflSize] 
( pCur.eState >= CURSOR_REQUIRESEEK 
( pCur.eState==CURSOR_INVALID 
( pCur.info.iCell + pCur.info.nHeader 
( pCur.info.iCell + pCur.info.nHeader + nKey 
( pCur.info.nSize - pCur.info.nHeader - nKey 
( pCur.info.nSize==null 
( pCur.isIncrblobHandle && !pCur.aOverflow 
( pCur.nullRow 
( pCur.pBt.pageSize 
( pCur.pVtabCursor 
( pCx == null 
( pCx.pBt != null 
( pCx.pCursor 
( pCx.pCursor != null 
( pCx.pVtabCursor 
( pD0 < zAffinity.Length && zAffinity[pD0] != '\0' 
( pData.z 
( pData.zBLOB != null 
( pDatabase != null 
( pDatabase != null && String.IsNullOrEmpty(pDatabase.z
( pDatabase == null || pTable != null 
( pDb != null 
( pDb == db.aDb[0] 
( pDb.mutex 
( pDb.pBt 
( pDb.pBt != null 
( pDb.pBt == null 
( pDb.pSchema 
( pDb.pSchema != null 
( pDb.pSchema.cache_size == 0 
( pDb.pSchema.file_format < p.minWriteFileFormat 
( pDb.pSchema.file_format == 0 
( pDb.pSchema.file_format > SQLITE_MAX_FILE_FORMAT 
( pDb.pSchema.file_format >= 4 
( pDb.pSchema.pSeqTab == null 
( pDb.zName 
( pDbPage 
( pDef 
( pDef != null 
( pDef == null 
( pDef.flags & SQLITE_FUNC_CASE 
( pDef.flags & SQLITE_FUNC_EPHEM 
( pDef.flags & SQLITE_FUNC_LIKE 
( pDef.zName 
( pDel != null 
( pDel && pDel->xDestroy 
( pDel == null || pDel == pColl[0] 
( pDel==pMod 
( pDerived.flags | pBase.flags & EP_FromJoin 
( pDest 
( pDest != null && pSrc != null 
( pDest.aCol[i].affinity != pSrc.aCol[i].affinity 
( pDest.aCol[i].notNull != 0 && pSrc.aCol[i].notNull == 0 
( pDest.eDest 
( pDest.eDest <= SRT_Discard 
( pDest.eDest == SRT_EphemTab 
( pDest.eDest == SRT_Output 
( pDest.eDest == SRT_Table 
( pDest.iMem == 0 
( pDest.iPKey != pSrc.iPKey 
( pDest.iPKey >= 0 
( pDest.nCol != pSrc.nCol 
( pDest.nColumn != pSrc.nColumn 
( pDest.nMem == nResultCol 
( pDest.onError != pSrc.onError 
( pDest.pIndex == null 
( pDest.pTable != pSrc.pTable 
( pDestDb.mutex 
( pDestIdx = pDest.pIndex ; pDestIdx != null ; pDestIdx = pDestIdx.pNext 
( pDestIdx.onError != OE_None 
( pDestPager 
( pDestPg 
( pDflt != null 
( pDflt != null && pDflt.op == TK_NULL 
( pDirty 
( pDirty = pCache.pDirty ; pDirty != null ; pDirty = pDirty.pDirtyNext 
( pDup 
( pDup != null 
( pDup == null 
( pDup.op 
( pE 
( pE != null 
( pE != null && isOuterJoin 
( pE == null 
( pE.flags | EP_IntValue | flags 
( pE.op != TK_ALL && ( pE.op != TK_DOT || pE.pRight.op != TK_ALL 
( pE.op != TK_DOT || ( pE.pLeft != null && pE.pLeft.op == TK_ID 
( pE.op != TK_DOT || pE.pRight != null 
( pE.op == TK_ALL 
( pE.op == TK_DOT 
( pE.op == TK_DOT && pE.pRight.op == TK_ALL 
( pE.op == TK_ID 
( pE.pLeft != null 
( pE.x.pList == null || pE.x.pList.nExpr != 1 
( pEList != null 
( pEList != null && pEList.nExpr == mx 
( pEList != null && pEList.nExpr == mx + 1 
( pEList != null && pEList.nExpr > mx 
( pEList != null && pExpr.iColumn < pEList.nExpr 
( pEList != null || pSelect != null /*|| db.mallocFailed != 0 */ 
( pEList == null 
( pEList == null || pEList.nExpr != 1 
( pEList == null || pSelect == null 
( pEList.a[0].pExpr != null 
( pEList.a[0].pExpr.op != TK_AGG_COLUMN 
( pEList.a[0].pExpr.op != TK_ALL 
( pEList.a[0].pExpr.op != TK_COLUMN 
( pEList.a[iCol].iAlias == 0 
( pEList.a[i].zName != null 
( pEList.a[i].zName != null && ( zName = pEList.a[i].zName 
( pEList.nExpr != 1 
( pEList.nExpr == nColumn 
( pEType != 0 
( pElem 
( pElem = pHash.first ; pElem != null ; pElem = pElem.next 
( pElem = sqliteHashFirst( pHash 
( pElem = sqliteHashFirst( temp2 
( pElem = temp1.first ; pElem != null ; pElem = pElem.next 
( pEnd 
( pEnd != null 
( pEnd.leftCursor == iCur 
( pEnd.zMalloc != null 
( pEngine == null 
( pEntry != null 
( pEntry.chain == elem 
( pEntry.count >= 0 
( pExisting && pExisting.pBt==pBt 
( pExpr 
( pExpr != null 
( pExpr != null && zColl != null 
( pExpr == null 
( pExpr->iColumn<pTab->nCol 
( pExpr->iColumn>=0 
( pExpr->iTable==pStack->newIdx || pExpr->iTable==pStack->oldIdx 
( pExpr->iTable==pTabList->a[iSrc].iCursor 
( pExpr->op!=TK_COLUMN 
( pExpr->op==TK_COLUMN 
( pExpr.affinity != OE_Ignore 
( pExpr.affinity == OE_Ignore 
( pExpr.flags & EP_AnyAff 
( pExpr.iColumn < 0 
( pExpr.iColumn >= 0 && pMatch != null 
( pExpr.iTable < 0 
( pExpr.iTable == pItem.iCursor 
( pExpr.op 
( pExpr.op != TK_AGG_FUNCTION 
( pExpr.op != TK_COLUMN || pExpr.iTable != _base 
( pExpr.op != TK_EQ || op == OP_Ne 
( pExpr.op != TK_GE || op == OP_Lt 
( pExpr.op != TK_GT || op == OP_Le 
( pExpr.op != TK_ID 
( pExpr.op != TK_ISNULL || op == OP_NotNull 
( pExpr.op != TK_LE || op == OP_Gt 
( pExpr.op != TK_LT || op == OP_Ge 
( pExpr.op != TK_NE || op == OP_Eq 
( pExpr.op != TK_NOTNULL || op == OP_IsNull 
( pExpr.op != op 
( pExpr.op == TK_AGG_COLUMN 
( pExpr.op == TK_AGG_FUNCTION 
( pExpr.op == TK_BETWEEN && pWC.op == TK_AND 
( pExpr.op == TK_COLUMN 
( pExpr.op == TK_COLUMN && pExpr.iTable == iTable 
( pExpr.op == TK_CONST_FUNC 
( pExpr.op == TK_EXISTS 
( pExpr.op == TK_EXISTS || pExpr.op == TK_SELECT 
( pExpr.op == TK_ID 
( pExpr.op == TK_IN 
( pExpr.op == TK_OR 
( pExpr.op == TK_SELECT 
( pExpr.op >= TK_GT 
( pExpr.op >= TK_GT && pExpr.op <= TK_GE 
( pExpr.op!=TK_COLUMN || pExpr.iTable!=pSrc.iCursor 
( pExpr.op!=TK_FUNCTION 
( pExpr.pColl != null 
( pExpr.pLeft 
( pExpr.pLeft != null 
( pExpr.pLeft == null && pExpr.pRight == null 
( pExpr.pLeft.flags & EP_ExpCollate 
( pExpr.pRight != null 
( pExpr.pRight == null 
( pExpr.pRight.flags & EP_ExpCollate 
( pExpr.pTab != null && j < pExpr.pTab.nCol 
( pExpr.u.zToken 
( pExpr.u.zToken != null 
( pExpr.u.zToken.Length != 0 
( pExpr.u.zToken.Length > 1 
( pExpr.u.zToken[0] == 'x' || pExpr.u.zToken[0] == 'X' 
( pExpr.u.zToken[1] == '\'' 
( pExpr.x.pList != null 
( pExpr.x.pList == null 
( pExpr.x.pList.nExpr > 0 
( pExpr.x.pSelect == null 
( pExpr.x.pSelect.pEList.a[0].pExpr 
( pExpr2 
( pF.iDistinct >= 0 
( pFK != null 
( pFK.deleteConf 
( pFK.updateConf 
( pFKey != null 
( pFKey = pTab.pFKey 
( pFKey = pTable.pFKey ; pFKey != null ; pFKey = pNextFKey 
( pFKey == null 
( pFKey.aCol[i] == null 
( pFarg != null 
( pFd.pMethods == null 
( pFile 
( pFile != null 
( pFile.locktype != NO_LOCK || locktype == SHARED_LOCK 
( pFile.locktype == NO_LOCK 
( pFile.locktype == RESERVED_LOCK 
( pFile.locktype == SHARED_LOCK 
( pFile.locktype >= RESERVED_LOCK 
( pFile.locktype >= SHARED_LOCK 
( pFile.locktype >= locktype 
( pFile.zDeleteOnClose 
( pFirst.pPrior != null 
( pFrom 
( pFrom != null 
( pFrom.a[0].pOn == null 
( pFrom.a[0].pUsing == null 
( pFrom.db == null || pTo.db == null || pFrom.db == pTo.db 
( pFrom.db == null || sqlite3_mutex_held( pFrom.db.mutex 
( pFrom.flags & ~( MEM_Dyn | MEM_Static | MEM_Ephem 
( pFrom.nSrc == 1 
( pFrom.nVar != pTo.nVar 
( pFrom.pTab != null 
( pFrom.pTab != null && pFrom.zIndex != null && pFrom.zIndex.Length != 0 
( pFrom.pTab == null 
( pFrom.zName == null 
( pFromCol == null 
( pFunc.iDistinct >= 0 
( pFunc.nArg 
( pFunc.nArg == -1 || ( pFunc.nArg & 0xff 
( pGroupBy != null 
( pGroupBy != null || sNC.hasAgg != 0 
( pGroupBy == null 
( pH 
( pH != null 
( pH.count <= 0 
( pH.count == 0 
( pH.count >= 10 && pH.count > 2 * pH.htsize 
( pH.first != null 
( pH.first == null 
( pH.ht != null 
( pH.ht != null && pH.ht[h] != null 
( pH.htsize != 0 
( pH.htsize > 0 
( pHash.a 
( pHaving != null 
( pHead != null 
( pHead.prev != null 
( pI64 
( pId 
( pId.pMethods != null 
( pId2 != null 
( pId2.n == 0 
( pId2.n == 0 && eMode == PAGER_JOURNALMODE_QUERY 
( pId2.n == 0 && eMode == PAGER_LOCKINGMODE_QUERY 
( pIdList == null || NEVER( pEList == null 
( pIdx 
( pIdx != null 
( pIdx != null && pTerm.eOperator != WO_ISNULL 
( pIdx = p.pIndex ; pIdx != null ; pIdx = pIdx.pNext 
( pIdx = pTab.pIndex ; pIdx != null && eType == 0 && affinity_ok ; pIdx = pIdx.pNext 
( pIdx = pTab.pIndex ; pIdx != null ; pIdx = pIdx.pNext 
( pIdx.aSortOrder != null 
( pIdx.aiColumn[0] == i 
( pIdx.aiColumn[j]==iCol 
( pIdx.aiColumn[k] != pIndex.aiColumn[k] 
( pIdx.autoIndex != 0 
( pIdx.nColumn != pIndex.nColumn 
( pIdx.nColumn + 2 
( pIdx.nColumn == 1 
( pIdx.nColumn > nEq 
( pIdx.nColumn >= nEq 
( pIdx.onError != OE_None 
( pIdx.onError != pIndex.onError 
( pIdx.onError == OE_Default 
( pIdx.onError == OE_Replace 
( pIdx.pSchema == pTab.pSchema 
( pIdx.tnum == iFrom 
( pIdx.tnum==(int
( pIdx.zColAff == null || pIdx.zColAff[0] == '\0' 
( pIdxInfo->orderByConsumed 
( pIdxInfo.needToFreeIdxStr 
( pIdxInfo==0 
( pIdxInfo==null 
( pIdxKey 
( pIdxKey == null 
( pIdx_zColAff == null 
( pIn != null 
( pIn.nMem == 1 
( pIn.pLeft != null 
( pIn.pRight != null 
( pIn1 
( pIn1 != pOut 
( pIn1.flags & ~( MEM_Int | MEM_Real | MEM_Blob | MEM_Zero 
( pIn1.flags & ~( MEM_TypeMask & ~MEM_Blob 
( pIn1.u.i < 0 
( pIn1.u.i < pIn2.u.i 
( pIn1.u.i == 0 
( pIn1.u.i > 0 
( pIn1<=&p->aMem[p->nMem] 
( pIn2 
( pIn2.flags & MEM_Blob 
( pIn2.z 
( pIn2.z != null 
( pIn3 
( pIn3.r < (double
( pIn3.r < 0 
( pIn3.r > (double
( pInClause == null 
( pIndex 
( pIndex != null 
( pIndex = pTab.pIndex ; pIndex != null ; pIndex = pIndex.pNext 
( pIndex = pTable.pIndex ; pIndex != null ; pIndex = pNext 
( pIndex == null 
( pIndex.autoIndex != 0 
( pIndex.onError != OE_None 
( pIndex.pSchema == pTable.pSchema 
( pIndex.pTable.pIndex == pIndex 
( pIndex.zName 
( pIndexedBy != null 
( pIndexedBy.n == 1 && null == pIndexedBy.z 
( pInfo 
( pInfo != null 
( pInfo != null && pInfo.pTab != pTab 
( pInfo == null 
( pInfo.needToFreeIdxStr != 0 
( pInfo.needToFreeIdxStr==0 || db.mallocFailed 
( pItem != null && pSrc.nSrc == 1 
( pItem.done != 0 
( pItem.iAlias != 0 
( pItem.iCol != 0 
( pItem.iCol == i 
( pItem.iCol > 0 
( pItem.iCol > 0 && pItem.iCol <= p.pEList.nExpr 
( pItem.iCol > pEList.nExpr 
( pItem.iCursor >= 0 
( pItem.pSelect != null 
( pItem.pTab != null 
( pItem.zAlias != null 
( pItem.zDatabase != null 
( pItem.zDatabase == null 
( pItem.zName != null 
( pItem.zName == null 
( pItem==null 
( pIter.eLock==READ_LOCK || pIter.eLock==WRITE_LOCK 
( pIter.iTable==iTable && pIter.pBtree==p 
( pIter.pBtree!=p 
( pIter.pBtree!=p && pIter.iTable==iTab && pIter.eLock!=eLock 
( pIx.pSchema == pTab.pSchema 
( pJfd 
( pJournal 
( pKey != null 
( pKey !=null
( pKeyDup != null 
( pKeyDup == null 
( pKeyInfo != null 
( pKeyInfo == null 
( pKeyInfo->nField + 1 
( pKeyInfo.aSortOrder != null && pKeyInfo.aSortOrder[j] != 0 
( pKeyInfo.nField + 1 
( pKeyMerge != null 
( pLast != null 
( pLater->locked 
( pLater->pNext==0 || pLater->pNext->pBt>pLater->pBt 
( pLater->sharable 
( pLater->wantToLock 
( pLeft 
( pLeft != null 
( pLeft == null 
( pLeft.op != TK_COLUMN 
( pLeft.op == TK_COLUMN 
( pLeft.op == TK_FLOAT 
( pLeft.op == TK_INTEGER 
( pLeft.op == TK_UPLUS 
( pLeft.pColl != null 
( pLevel.iFrom > 0 && ( pTabItem.jointype & JT_LEFT 
( pLevel.iIdxCur >= 0 
( pLevel.iLeftJoin != 0 
( pLevel.iLeftJoin != 0 && !( ( pE.flags & EP_FromJoin 
( pLevel.op != OP_Noop 
( pLevel.op == OP_Return 
( pLevel.plan.nEq + nExtraReg 
( pLevel.plan.u.pIdx.zName 
( pLevel.plan.wsFlags & WHERE_BTM_LIMIT 
( pLevel.plan.wsFlags & WHERE_IDX_ONLY 
( pLevel.plan.wsFlags & WHERE_REVERSE 
( pLevel.plan.wsFlags & WHERE_ROWID_EQ 
( pLevel.plan.wsFlags & WHERE_ROWID_RANGE 
( pLevel.plan.wsFlags & WHERE_TOP_LIMIT 
( pLevel.u._in.aInLoop != null 
( pLevel.u._in.aInLoop == null 
( pLevel.u._in.nIn == 0 
( pLimit != null 
( pLimit == null 
( pLink.pSchema == pLink.pTabSchema 
( pLink.table 
( pList 
( pList != null 
( pList != null /* || pParse.db.mallocFailed != 0 */ 
( pList != null /*|| db.mallocFailed != 0 */ 
( pList != null ? pList : pTab.pTrigger 
( pList == null 
( pList == null || IsVirtual( pTab 
( pList.a != null 
( pList.a != null || ( pList.nExpr == 0 && pList.nAlloc == 0 
( pList.a[1].pExpr.op != TK_COLUMN 
( pList.a[i].pExpr 
( pList.a[i].zName == null 
( pList.nAlloc <= pList.nExpr 
( pList.nAlloc == 0 
( pList.nExpr <= pList.nAlloc 
( pList.nExpr == 2 
( pList.nExpr > 0 
( pList.nExpr > 1 
( pList.nExpr!=2 
( pList.pgno - 1 
( pList.pgno <= pPager.dbSize && 0 == ( pList.flags & PGHDR_DONT_WRITE 
( pListItem.pExpr != null && ALWAYS( pListItem.pExpr.pColl 
( pLock.eLock==READ_LOCK || pLock.pBtree==p 
( pLock.iTable!=1 
( pLock.iTable!=1 || pLock==&p.lock 
( pLock.pBtree.inTrans>=pLock.eLock 
( pLock.pBtree==p 
( pLoop = p ; pLoop != null ; pLoop = pLoop.pPrior 
( pLoop.addrOpenEphm[1] < 0 
( pMain 
( pMask != 0 
( pMaskSet.ix[i] == iCursor 
( pMaskSet.n < ArraySize( pMaskSet.ix 
( pMaskSet.n <= sizeof( Bitmask 
( pMaster 
( pMaster != null 
( pMatch.iCursor == pExpr.iTable 
( pMem 
( pMem != null 
( pMem->enc!=SQLITE_UTF8 && desiredEnc!=SQLITE_UTF8 
( pMem->enc==SQLITE_UTF16LE 
( pMem->enc==SQLITE_UTF8 
( pMem->n>1 
( pMem->n>=0 
( pMem->z && preserve && pMem->zMalloc && pMem->z!=pMem->zMalloc 
( pMem._StrAccum == null 
( pMem._SumCtx == null 
( pMem.db != null 
( pMem.db == null || sqlite3_mutex_held( pMem.db.mutex 
( pMem.db==null || sqlite3_mutex_held(pMem.db.mutex
( pMem.enc!=0 
( pMem.enc!=SQLITE_UTF8 && sqlite3VdbeMemHandleBom(pMem
( pMem.enc!=desiredEnc 
( pMem.flags & MEM_RowSet 
( pMem.flags & MEM_Str 
( pMem.flags & ~( MEM_Ephem | MEM_Static 
( pMem.flags & ~( MEM_Zero | MEM_Static | MEM_Ephem | MEM_Term 
( pMem.n + ( ( pMem.flags & MEM_Zero 
( pMem.n + pMem.u.nZero 
( pMem.n <= nBuf 
( pMem.n>=0 
( pMem.r 
( pMem.r == (double
( pMem.r.ToString(
( pMem.u.i + 1 
( pMem.u.i - 1 
( pMem.u.i == MAX_ROWID || pC.useRandomRowid 
( pMem.u.pRowSet 
( pMem.u.pRowSet != null 
( pMem.z 
( pMem.z != null 
( pMem.z != null && pMem.n < pMem.z.Length 
( pMem.z && pMem.flags&MEM_Dyn 
( pMem.z == null 
( pMem.z == null && pMem.zBLOB != null 
( pMem.z!= null 
( pMem.zBLOB 
( pMem.zBLOB != null 
( pMem.zMalloc 
( pMem1.enc == pColl.enc 
( pMem1.enc == pMem2.enc 
( pMem1.u.i < pMem2.u.i 
( pMem1.u.i > pMem2.u.i 
( pMem1.zBLOB != null 
( pMinMax != null 
( pMinMax == null && flag != 0 
( pMod 
( pMod != null 
( pMod->xFindFunction==0 
( pMod.xDestroy 
( pModule->xBegin 
( pModule.xRowid 
( pNC != null 
( pNC != null && cnt == 0 
( pNC != null && pTab == null 
( pNC.hasAgg != 0 
( pNC.isCheck != 0 
( pNC.nDepth == 0 
( pNC.nErr > 0 || w.pParse.nErr > 0 
( pNC.nRef >= nRef 
( pNC.pParse != null 
( pNC.pSrcList != null 
( pNC.pSrcList != null && pNC.pSrcList.nAlloc > 0 
( pName != null 
( pName != null && pName.z != null 
( pName == null 
( pName == null ? 1 : 0 
( pName.flags & MEM_Str 
( pName.nSrc == 1 
( pName1 != null 
( pName1 != null && pName2 != null 
( pName1 == null 
( pName1.z != null 
( pName2 != null 
( pName2 != null || pName1 == null 
( pName2.n == 0 
( pName2.n == 0 && pTab != null && pTab.pSchema == db.aDb[1].pSchema 
( pName2.n > 0 
( pNew 
( pNew != null 
( pNew != standin 
( pNew !=null
( pNew == null 
( pNew ==null
( pNew.a == null 
( pNew.aCol == null || pNew.zName == null 
( pNew.nCol > 0 
( pNew.pIndex != null 
( pNew==0 
( pNew==0 && mem0.alarmCallback 
( pNew==null   
( pNext != null 
( pNextFrom != null 
( pNextZombie != null 
( pNotNull 
( pOffset != null 
( pOffset == null 
( pOffset == null || pLimit != null 
( pOld 
( pOld != null 
( pOld == null 
( pOld == null || pOld == p 
( pOld!=pWC.aStatic 
( pOp != null 
( pOp->p4type==P4_DYNAMIC 
( pOp.opcode 
( pOp.opcode == OP_And 
( pOp.opcode == OP_Column 
( pOp.opcode == OP_CreateTable 
( pOp.opcode == OP_Found 
( pOp.opcode == OP_IdxGE 
( pOp.opcode == OP_IdxLT 
( pOp.opcode == OP_IfNot 
( pOp.opcode == OP_NullRow && useIndexOnly != 0 
( pOp.opcode == OP_OpenRead && pOp.p3 == iDb 
( pOp.opcode == OP_OpenWrite 
( pOp.opcode == OP_Rowid 
( pOp.opcode == OP_SCopy && pOp.p1 >= iReg && pOp.p1 < iReg + nReg 
( pOp.opcode == OP_ShiftRight 
( pOp.opcode == OP_Statement 
( pOp.opcode == OP_Trace && pOp.p4.z != null 
( pOp.opcode == OP_Variable 
( pOp.opcode==OP_VOpen && pOp.p4.pVtab==pVTab
( pOp.p1 != 0 
( pOp.p1 != pLevel.iTabCur 
( pOp.p1 + pOp.p2 <= p.nMem + 1 
( pOp.p1 <= db.aLimit[SQLITE_LIMIT_LENGTH] 
( pOp.p1 <= p.nMem 
( pOp.p1 == 0 
( pOp.p1 == 1 
( pOp.p1 == SQLITE_CONSTRAINT && pOp.p2 == OE_Abort 
( pOp.p1 > 0 
( pOp.p1 > 0 && pOp.p1 <= p.nMem 
( pOp.p1 > 0 && pOp.p1 <= p.nVar 
( pOp.p1 > db.aLimit[SQLITE_LIMIT_LENGTH] 
( pOp.p1 >= 0 
( pOp.p1 >= 0 && pOp.p1 < db.nDb 
( pOp.p1 >= 0 && pOp.p1 < p.nCursor 
( pOp.p2 != 0 
( pOp.p2 < SQLITE_N_BTREE_META 
( pOp.p2 <= p.nMem 
( pOp.p2 == 0 
( pOp.p2 == BTREE_FILE_FORMAT 
( pOp.p2 == BTREE_SCHEMA_VERSION 
( pOp.p2 == pIdx.aiColumn[j] 
( pOp.p2 > 0 
( pOp.p2 > 0 && pOp.p2 + pOp.p3 <= p.nMem + 1 
( pOp.p2 > 0 && pOp.p2 < p.nOp 
( pOp.p2 > 0 && pOp.p2 <= p.nMem 
( pOp.p2 > 0 && res != 0 
( pOp.p2 > nMaxArgs 
( pOp.p3 != 0 
( pOp.p3 < SQLITE_N_BTREE_META 
( pOp.p3 < pOp.p1 || pOp.p3 >= pOp.p1 + pOp.p2 
( pOp.p3 < pOp.p2 || pOp.p3 >= pOp.p2 + n 
( pOp.p3 <= p.nMem 
( pOp.p3 == 0 
( pOp.p3 > 0 
( pOp.p3 > 0 && pOp.p3 <= p.nMem 
( pOp.p4.ai != null 
( pOp.p4.i > 0 && pOp.p4.i <= p.nMem 
( pOp.p4.pI64 != 0 
( pOp.p4.pKeyInfo != null 
( pOp.p4.pVtab!=0 
( pOp.p4.z 
( pOp.p4.z != null 
( pOp.p4.z != null ? pOp.p4.z : p.zSql 
( pOp.p4.z == null || pOp.p3 == 1 
( pOp.p4.z == null || pOp.p4.z.Length == 0 
( pOp.p4type 
( pOp.p4type == P4_COLLSEQ 
( pOp.p4type == P4_COLLSEQ || pOp.p4.pColl == null 
( pOp.p4type == P4_FUNCDEF 
( pOp.p4type == P4_FUNCDEF || pOp.p4type == P4_VDBEFUNC 
( pOp.p4type == P4_INT32 
( pOp.p4type == P4_INTARRAY 
( pOp.p4type == P4_KEYINFO 
( pOp.p4type == P4_MEM 
( pOp.p4type==P4_VTAB 
( pOp.p5 != 0 
( pOp.p5 & OPFLAG_APPEND 
( pOp.p5 & SQLITE_AFF_MASK 
( pOp.p5 < db.nDb 
( pOp.p5 == 0 || pOp.p5 == 1 
( pOp.p5 > nMaxArgs 
( pOp.zComment != null 
( pOp[-1].opcode==OP_Integer 
( pOrInfo == null 
( pOrTerm - pOrWC.a 
( pOrTerm.eOperator != WO_EQ 
( pOrTerm.eOperator == 0 
( pOrTerm.eOperator == WO_AND 
( pOrTerm.eOperator == WO_EQ 
( pOrTerm.leftCursor != iCursor 
( pOrTerm.leftCursor == iCur 
( pOrTerm.leftCursor == iCur || pOrTerm.eOperator == WO_AND 
( pOrTerm.leftCursor == iCursor 
( pOrTerm.pExpr.pLeft 
( pOrTerm.pExpr.pRight 
( pOrTerm.u.leftColumn != iColumn 
( pOrTerm.u.leftColumn == iColumn 
( pOrTerm.wtFlags & TERM_COPIED 
( pOrTerm.wtFlags & TERM_VIRTUAL 
( pOrTerm.wtFlags & ~TERM_OR_OK 
( pOrWc.nTerm >= 2 
( pOrderBy 
( pOrderBy != null 
( pOrderBy == null 
( pOrderBy == null && !hasDistinct 
( pOrderBy == null /* || pParse.db.mallocFailed != 0 */ 
( pOrderBy!=null && (pLimit == null
( pOrderBy.a[0].pExpr.iColumn==pIdx.aiColumn[nEq] 
( pOrderBy.a[i].done == 0 
( pOrderBy.nExpr > 0 
( pOrderBy.nExpr==1 
( pOrderBy.nExpr>db.aLimit[SQLITE_LIMIT_COLUMN] 
( pOrig != null 
( pOrig.op != TK_COLUMN && ( zType.Length == 0 || zType[0] != 'G' 
( pOther != null 
( pOther != pDef && pOther.pNext != pDef 
( pOther.pNext != null && pOther.pNext.onError != OE_Replace 
( pOut 
( pOut != pIn1 
( pOut != pIn2 
( pOut == null 
( pOut == pIn2 
( pOut->flags & MEM_Dyn 
( pOut->zMalloc==pOut->z 
( pOut.flags & ~MEM_Static 
( pOut<=&p->aMem[p->nMem] 
( pOutFlags 
( pP4 != null 
( pPKey2.flags & ~UNPACKED_PREFIX_SEARCH 
( pPKey2.nField - 1 
( pPage 
( pPage != null 
( pPage != null && ( pPage.pLruNext != null || pPage == pcache1.pLruTail 
( pPage != null && iKey > pCache.iMaxKey 
( pPage != null ? PGHDR1_TO_PAGE( pPage 
( pPage != null || createFlag == 0 
( pPage = pCache.apHash[h] ; pPage != null && pPage.iKey != iKey ; pPage = pPage.pNext 
( pPage == null && eCreate != 0 
( pPage == p.pDirty 
( pPage == p.pDirtyTail 
( pPage.iKey % nNew 
( pPage.iKey == iOld 
( pPage.iKey >= iLimit 
( pPage.isInit!=0 
( pPage.pCache == pCache 
( pPage.pCache.szPage != pCache.szPage 
( pPage.pDirtyNext != null 
( pPage.pDirtyNext != null || pPage == p.pDirtyTail 
( pPage.pDirtyNext == null && pPage.pDirtyPrev == null && p.pDirty != pPage 
( pPage.pDirtyNext.pDirtyPrev == null 
( pPage.pDirtyPrev != null 
( pPage.pDirtyPrev != null || pPage == p.pDirty 
( pPage.pExtra == (void*
( pPage.pLruNext != null 
( pPage.pLruPrev != null 
( pPage.pLruPrev == null && pPage.pLruNext == null 
( pPage.pgno == pgno 
( pPager 
( pPager != null 
( pPager->xCodecFree 
( pPager->xCodecSizeChng 
( pPager.aSavepoint[ii].iHdrOffset == 0 
( pPager.dbFileSize > 0 
( pPager.dbFileVers 
( pPager.dbFileVers[i] != dbFileVers[i] 
( pPager.dbOrigSize == 0 
( pPager.dbSize 
( pPager.dbSize != pPager.dbFileSize 
( pPager.dbSize - ( pPager.dbSize == PAGER_MJ_PGNO( pPager 
( pPager.dbSize < (int
( pPager.dbSize > 0 
( pPager.dbSize >= nPage 
( pPager.dbSizeValid 
( pPager.dbSizeValid == false 
( pPager.doNotSync 
( pPager.doNotSync && (pPg.flags & PGHDR_NEED_SYNC 
( pPager.errCode != 0 
( pPager.errCode != 0 && pPager.errCode != SQLITE_FULL 
( pPager.errCode & 0xff 
( pPager.errCode == SQLITE_OK && pPager.state >= PAGER_RESERVED 
( pPager.errCode!=SQLITE_OK && pPager.errCode!=SQLITE_FULL 
( pPager.exclusiveMode && pPager.state > PAGER_SHARED 
( pPager.exclusiveMode || pPager.state == PAGER_SHARED 
( pPager.fd 
( pPager.fd.pMethods != null || pPager.tempFile 
( pPager.fullSync 
( pPager.fullSync && 0 == ( iDc & SQLITE_IOCAP_SEQUENTIAL 
( pPager.jfd 
( pPager.jfd->pMethods 
( pPager.journalMode != PAGER_JOURNALMODE_MEMORY 
( pPager.journalMode != PAGER_JOURNALMODE_OFF 
( pPager.journalMode != PAGER_JOURNALMODE_OFF || pPager.dbOrigSize == 0 
( pPager.journalMode == PAGER_JOURNALMODE_MEMORY 
( pPager.journalMode == PAGER_JOURNALMODE_MEMORY || pPager.subjInMemory != 0 
( pPager.journalMode == PAGER_JOURNALMODE_TRUNCATE 
( pPager.journalOff != 0 
( pPager.journalOff + JOURNAL_HDR_SZ( pPager 
( pPager.journalOff == 0 
( pPager.journalOff == JOURNAL_HDR_SZ( pPager 
( pPager.memDb == 0 
( pPager.nRec == 0 
( pPager.nSavepoint == 0 || isOpen( pPager.sjfd 
( pPager.nSavepoint > 0 
( pPager.needSync 
( pPager.noReadlock != 0 
( pPager.noSync 
( pPager.pBackup 
( pPager.pBackup != null 
( pPager.pBackup != null || sqlite3PcachePagecount( pPager.pPCache 
( pPager.pInJournal != null 
( pPager.pInJournal == null 
( pPager.pPCache 
( pPager.pPCache != null 
( pPager.pTmpSpace != null 
( pPager.pageSize * nPage 
( pPager.pageSize + 8 
( pPager.readOnly 
( pPager.sectorSize 
( pPager.sectorSize / pPager.pageSize 
( pPager.sectorSize < 512 
( pPager.sectorSize > MAX_SECTOR_SIZE 
( pPager.sectorSize > SQLITE_MAX_DEFAULT_PAGE_SIZE 
( pPager.sjfd 
( pPager.state != PAGER_SYNCED && pPager.dbModified 
( pPager.state != PAGER_UNLOCK 
( pPager.state < EXCLUSIVE_LOCK 
( pPager.state < PAGER_RESERVED 
( pPager.state <= PAGER_SHARED 
( pPager.state == ( tempFile != 0 ? PAGER_EXCLUSIVE : PAGER_UNLOCK 
( pPager.state == PAGER_RESERVED 
( pPager.state == PAGER_RESERVED && locktype == PAGER_EXCLUSIVE 
( pPager.state == PAGER_RESERVED || pPager.state >= PAGER_EXCLUSIVE 
( pPager.state == PAGER_SHARED 
( pPager.state == PAGER_SYNCED 
( pPager.state == PAGER_UNLOCK 
( pPager.state == PAGER_UNLOCK && locktype == PAGER_SHARED 
( pPager.state == PAGER_UNLOCK || isErrorReset 
( pPager.state > PAGER_UNLOCK 
( pPager.state >= PAGER_EXCLUSIVE 
( pPager.state >= PAGER_EXCLUSIVE && isOpen( pPager.fd 
( pPager.state >= PAGER_RESERVED 
( pPager.state >= PAGER_SHARED 
( pPager.state >= PAGER_SHARED || pPager.dbSizeValid == false 
( pPager.state >= SHARED_LOCK 
( pPager.state >= locktype 
( pPager.sync_flags == SQLITE_SYNC_FULL ? SQLITE_SYNC_DATAONLY : 0 
( pPager.tempFile 
( pPager.tempFile && rc == SQLITE_OK 
( pPager.tempFile == false || pPager.changeCountDone 
( pPager.tempFile == false || pPager.state >= PAGER_EXCLUSIVE 
( pPager.useJournal != 0 
( pPager.zFilename.Length==0
( pPager.zJournal 
( pParent != p 
( pParent == p 
( pParent.pGroupBy == null 
( pParent.pHaving == null 
( pParent.pOrderBy != null 
( pParent.pOrderBy == null 
( pParent.selFlags | pSub.selFlags & SF_Distinct 
( pParse 
( pParse != null 
( pParse == null 
( pParse == pWalker.pParse 
( pParse->pVdbe 
( pParse->sArg.z && ALWAYS(pParse->pNewTable
( pParse->zErrMsg 
( pParse.aTableLock != null 
( pParse.apVarExpr != null 
( pParse.apVarExpr == null 
( pParse.checkSchema != 0
( pParse.checkSchema!=0 
( pParse.ckBase > 0 
( pParse.colNamesSet != 0 || NEVER( v == null 
( pParse.cookieGoto == 0 
( pParse.cookieGoto > 0 
( pParse.db 
( pParse.db.flags & SQLITE_WriteSchema 
( pParse.db.mallocFailed != 0 
( pParse.db.mallocFailed == 0 
( pParse.explain != 0 
( pParse.explain == 2 
( pParse.iCacheLevel != 0 
( pParse.iCacheLevel == 0 
( pParse.iCacheLevel >= N 
( pParse.nAliasAlloc < pParse.nAlias 
( pParse.nErr 
( pParse.nErr != 0 
( pParse.nErr != 0 /* || pParse.db.mallocFailed != 0 */ 
( pParse.nErr != 0 /*|| db.mallocFailed != 0 */ 
( pParse.nErr == 0 
( pParse.nErr == 0 && pParse.nVar > db.aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] 
( pParse.nErr == 0 || rc != 0 
( pParse.nMem < 3 
( pParse.nMem < cnt + 4 
( pParse.nTab < baseCur + i 
( pParse.nTab == 1 
( pParse.nTab > iCur + i + 1 
( pParse.nTableLock + 1 
( pParse.nTempReg < ArraySize( pParse.aTempReg 
( pParse.nTempReg == 0 
( pParse.nVar == 0 
( pParse.nVar > 0 
( pParse.nVarExpr == 0 
( pParse.nVarExpr >= pParse.nVarExprAlloc - 1 
( pParse.nVarExprAlloc == 0 
( pParse.nested != 0 
( pParse.nested < 10 
( pParse.nested == 0 
( pParse.nested == 0 && pParse.trigStack == null 
( pParse.pAinc != null 
( pParse.pNewTable == null 
( pParse.pNewTrigger == null 
( pParse.pNewTrigger == pTrigger 
( pParse.pVdbe 
( pParse.pVdbe != null 
( pParse.pVdbe != null && ( rc != SQLITE_OK /*|| db.mallocFailed != 0 */ 
( pParse.pVdbe != null && pParse.nErr > 0 && pParse.nested == 0 
( pParse.pVdbe != null /* || pParse.db.mallocFailed != 0 */ 
( pParse.pZombieTab != null 
( pParse.rc != SQLITE_OK 
( pParse.rc == SQLITE_DONE 
( pParse.rc == SQLITE_OK 
( pParse.rc == SQLITE_SCHEMA 
( pParse.sNameToken.z.Length - pEnd.z.Length 
( pParse.trigStack == null 
( pParse.zErrMsg != null 
( pParse==0 
( pPg 
( pPg != null 
( pPg = pCache.pDirtyTail ; pPg != null && pPg.nRef != 0 ; pPg = pPg.pDirtyPrev 
( pPg == null || 0 == ( pPg.flags & PGHDR_NEED_SYNC 
( pPg!=null 
( pPg.flags & PGHDR_DIRTY 
( pPg.flags & PGHDR_NEED_SYNC 
( pPg.nRef != 0 || ( pPg.flags & PGHDR_NEED_SYNC 
( pPg.nRef > 0 
( pPg.nRef > 0 || pPg.pPager.memDb != 0 
( pPg.pPager == pPager 
( pPg.pgno != ( ( PENDING_BYTE / ( pPager.pageSize 
( pPg.pgno - pg1 
( pPg.pgno <= pPager.dbOrigSize 
( pPg.pgno > nPageCount 
( pPgHdr 
( pPgHdr == null || rc == SQLITE_OK 
( pPgOld 
( pPgOld != null 
( pPgOld.flags & PGHDR_NEED_SYNC 
( pPgno != 0 
( pPgnoNext
( pPrev == null 
( pPrimaryKey 
( pPrior != null 
( pPrior.pLimit != null 
( pPrior.pLimit == null 
( pPrior.pOrderBy != null 
( pPrior.pOrderBy == null 
( pPrior.pPrior == null 
( pPrior.pRightmost != pPrior 
( pPrior.pRightmost == p.pRightmost 
( pPrior==0 
( pProbe.aiRowEst[0] 
( pProbe.onError != OE_None && nEq == pProbe.nColumn 
( pRangeEnd != null 
( pRangeEnd != null && ( pRangeEnd.eOperator & WO_GE 
( pRangeEnd != null && ( pRangeEnd.eOperator & WO_LE 
( pRangeStart != null 
( pRangeStart != null && ( pRangeStart.eOperator & WO_GE 
( pRangeStart != null && ( pRangeStart.eOperator & WO_LE 
( pRangeStart != null || nEq > 0 
( pRec 
( pRec = pData0 ; pRec <= pLast ; pRec++ 
( pRec.flags & ( MEM_Real | MEM_Int 
( pRec.flags & ~( MEM_Real | MEM_Int 
( pRec.flags & ~MEM_Blob 
( pRec.zBLOB.Length 
( pRes 
( pRes != 0 
( pRes != null 
( pRet == null && iCol < p.pEList.nExpr 
( pRight != null 
( pRight != null && ( ( pRight.flags & EP_ExpCollate 
( pRight != null && pRight.op == TK_COLUMN 
( pRight == null 
( pRight.jointype & JT_OUTER 
( pRight.op != TK_STRING 
( pRight.op == TK_DOT 
( pRight.op == TK_ID 
( pRight.op == TK_UPLUS 
( pRight.pColl != null 
( pRight.pOn != null 
( pRight.pOn != null && pRight.pUsing != null 
( pRight.pOn != null || pRight.pUsing != null 
( pRight.pUsing != null 
( pRightmost != null 
( pRoot 
( pRoot == null 
( pRowSet 
( pRowSet.pEntry 
( pRowSet.pEntry != null 
( pRowid 
( pS != null 
( pS = pParse.trigStack ; pS != null && p != pS.pTrigger ; pS = pS.pNext 
( pS == null 
( pSavepoint != null 
( pSavepoint == db.pSavepoint 
( pSavepoint.nOrig 
( pSavepoint.pNext == null && db.isTransactionSavepoint != 0 
( pSchema != null 
( pSchema.flags & ~DB_SchemaLoaded 
( pSchema.idxHash 
( pSchema.trigHash 
( pSel != null 
( pSel.pPrior != null 
( pSelTab != null 
( pSelTab == null 
( pSelect != null 
( pSelect != null && moreToDo != 0 
( pSelect == null 
( pSelect == null && pCons != null && pEnd != null 
( pSelect.iLimit != 0 
( pSelect.iOffset != 0 
( pSelect.pEList != null 
( pSelect.pGroupBy != null 
( pSelect.pLimit != null 
( pSelect.pOffset == null 
( pSelect.pOrderBy != null 
( pSelect.pPrior != null 
( pSelect.pSrc != null 
( pSelect.pSrc.a[0].pSelect != null 
( pSelect.pSrc.nSrc != 1 
( pSelect.pWhere != null 
( pSelectRowid == null 
( pSelectSrc == null 
( pSib.pNext && pSib.pNext.pBt<p.pBt 
( pSib.pPrev 
( pSpan.zEnd- pSpan.zStart
( pSpan.zEnd.Length - pSpan.zStart.Length 
( pSrc != null 
( pSrc != null && iFrom >= 0 && iFrom < pSrc.nSrc 
( pSrc == null 
( pSrc == pDest 
( pSrc.a != null 
( pSrc.aSortOrder[i] != pDest.aSortOrder[i] 
( pSrc.a[0].pSelect != null 
( pSrc.aiColumn[i] != pDest.aiColumn[i] 
( pSrc.nSrc != 1 
( pSrc.nSrc + nExtra > pSrc.nAlloc 
( pSrc.nSrc == 1 
( pSrc.nSrc > 0 
( pSrc.nSrc > 1 || isAgg 
( pSrc.notIndexed != 0 
( pSrc.pIndex != null 
( pSrc.pSelect != null 
( pSrcDb == pDestDb 
( pSrcDb.mutex 
( pSrcIdx != null 
( pSrcIdx = pSrc.pIndex ; pSrcIdx != null ; pSrcIdx = pSrcIdx.pNext 
( pSrcIdx == null 
( pSrcList != null 
( pSrcList !=null && pSrcList.nSrc==1 
( pSrcList.a[i].iCursor >= 0 && pSrcList.a[i].iCursor < pParse.nTab 
( pSrcList==0 
( pSrcPg 
( pStart 
( pStart != null 
( pStart == null || pEnd != null 
( pStart.leftCursor == iCur 
( pStep != null 
( pStepList != null 
( pStmt 
( pStmt != null 
( pStmt == null 
( pStr1 != null 
( pSub != null 
( pSub = pSub.pPrior ; pSub != null ; pSub = pSub.pPrior 
( pSub == null || pItem.isPopulated != 0 
( pSub.pLimit != null 
( pSub.pLimit != null && p.pLimit != null 
( pSub.pLimit != null && p.pWhere != null 
( pSub.pOffset != null 
( pSub.pOrderBy != null 
( pSub.pPrior != null 
( pSub.pWhere != null 
( pSub.selFlags & SF_Aggregate 
( pSub1 = pSub ; pSub1 != null ; pSub1 = pSub1.pPrior 
( pSub1.pPrior != null && pSub1.op != TK_ALL 
( pSub1.pSrc == null 
( pSubSrc != null 
( pSubSrc.nSrc == 0 
( pSubWInfo 
( pSubWInfo != null 
( pSynced != null && ( pSynced.flags & PGHDR_NEED_SYNC 
( pTab 
( pTab != null 
( pTab != null && !IN_DECLARE_VTAB 
( pTab != null && null == pTab.pSelect && pExpr != null 
( pTab != null && pTab.zName != null 
( pTab && (pTab->tabFlags & TF_Virtual
( pTab && IsVirtual(pTab
( pTab && pTab.pSelect 
( pTab == null 
( pTab == null /*|| db.mallocFailed != 0 */ 
( pTab == null || IN_DECLARE_VTAB 
( pTab == pParse.pNewTable 
( pTab->iPKey<pTab->nCol 
( pTab->iPKey>=0 
( pTab->nModuleArg<1 
( pTab->pVTable==p && p->pNext==0 
( pTab.aCol[iCol].affinity == aff || aff == SQLITE_AFF_NONE 
( pTab.aCol[i].affinity 
( pTab.aCol[pIdx.aiColumn[n]].affinity 
( pTab.addColOffset > 0 
( pTab.azModuleArg && pTab.azModuleArg[0] 
( pTab.dbMem == null 
( pTab.iPKey<0 
( pTab.nCol 
( pTab.nCol + 1 
( pTab.nCol > 0 
( pTab.nCol > cnum 
( pTab.pCheck != null && ( pParse.db.flags & SQLITE_IgnoreChecks 
( pTab.pIndex == null 
( pTab.pSchema != pTempSchema 
( pTab.pSelect != null 
( pTab.pSelect != null && tr_tm != TK_INSTEAD 
( pTab.pSelect != null || IsVirtual( pTab 
( pTab.pSelect == null 
( pTab.pSelect == null && tr_tm == TK_INSTEAD 
( pTab.pTrigger == pTrigger 
( pTab.tabFlags & TF_Ephemeral 
( pTab.tnum == iFrom 
( pTab.zColAff == null 
( pTab==0 
( pTab==pOld 
( pTab==pParse->apVtabLock[i] 
( pTabItem.jointype & ( JT_LEFT | JT_CROSS 
( pTabItem.pTab != null 
( pTabList 
( pTabList.a[i].pTab 
( pTabList.a[j].iCursor == p.iTable 
( pTabList.nSrc - 1 
( pTabList.nSrc == 1 
( pTabList.nSrc > BMS 
( pTabSchema != null 
( pTabToDel.nRef == 1 
( pTable 
( pTable != null 
( pTable == null 
( pTable->azModuleArg 
( pTable.aCol == null 
( pTable.nCol < 0 
( pTable.nCol > 0 
( pTable.nCol >= 0 
( pTable.nRef == 0 
( pTable.nRef > 0 
( pTable.pSchema == pTrigger.pSchema || iDb == 1 
( pTable.pSelect != null 
( pTable==0 
( pTableName == null /*|| db.mallocFailed != 0 */ 
( pTableName.nSrc == 1 
( pTblName != null 
( pTemp 
( pTerm != null 
( pTerm - pWC.a 
( pTerm == null 
( pTerm.eOperator & (WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE|WO_MATCH
( pTerm.eOperator & (WO_IN|WO_ISNULL
( pTerm.eOperator & WO_IN 
( pTerm.eOperator & WO_ISNULL 
( pTerm.eOperator & op 
( pTerm.eOperator == WO_OR 
( pTerm.eOperator==WO_IN 
( pTerm.eOperator==WO_ISNULL 
( pTerm.iParent >= 0 
( pTerm.leftCursor != pSrc.iCursor 
( pTerm.leftCursor == iCur 
( pTerm.leftCursor >= 0 
( pTerm.pExpr != null 
( pTerm.prereqRight & notReady 
( pTerm.prereqRight & prereqLeft 
( pTerm.sortOrder == 0 || pTerm.sortOrder == 1 
( pTerm.u.pOrInfo.indexable & maskSrc 
( pTerm.wtFlags & TERM_CODED 
( pTerm.wtFlags & TERM_VIRTUAL 
( pTest != null 
( pTest.op == TK_COLUMN 
( pTmpSchema != pTab.pSchema 
( pTo 
( pTo != null 
( pTo.db == null || sqlite3_mutex_held( pTo.db.mutex 
( pTo.db == pFrom.db 
( pTo.db.mutex 
( pTo.flags & ~MEM_Dyn 
( pTo.nVar == pFrom.nVar 
( pToCol 
( pToCol != null 
( pToCol != null && pToCol.nExpr != 1 
( pToCol != null && pToCol.nExpr != pFromCol.nExpr 
( pToCol.a[i].zName 
( pToken != null 
( pToken.n > 0 
( pToken.z.Substring( 1 
( pToken.z.ToString(
( pTopNC != null 
( pTopNC == pNC 
( pTrig != null 
( pTrig.pSchema == pTempSchema 
( pTrigger 
( pTrigger != null 
( pTrigger == null 
( pTrigger == null && tmask == 0 
( pTrigger.pSchema == pTrigger.pTabSchema 
( pTrigger.table 
( pTriggerStack.pTab != null 
( pTriggerStep != null 
( pTriggerStep == null 
( pTriggerStep.op 
( pTriggerStep.op == TK_SELECT 
( pVTab !=null
( pVTab->db->magic==SQLITE_MAGIC_BUSY 
( pVTab->nRef==0 
( pVTab->nRef>0 
( pVTab.pVtab.pModule.xRename==null 
( pVTable 
( pVal 
( pVal == null 
( pVal.db == null || sqlite3_mutex_held( pVal.db.mutex 
( pVal.enc == ( enc & ~SQLITE_UTF16_ALIGNED 
( pValue != null 
( pValue == null 
( pValue.type 
( pVar 
( pVdbe != null 
( pVdbe.magic==VDBE_MAGIC_RUN && pVdbe.inVtabMethod<2 && pVdbe.pc>=0 
( pVdbeFunc != null ? pVdbeFunc.nAux : 0 
( pVdbeFunc == null 
( pVfs 
( pVfs = vfsList ; pVfs != null ; pVfs = pVfs.pNext 
( pVfs == null 
( pVfs.szOsFile * 2 
( pVm != null && ALWAYS( pVm.db != null 
( pVm != null && pVm.pResultSet != null && i < pVm.nResColumn && i >= 0 
( pVm == null || pVm.pResultSet == null 
( pVm.db.mutex 
( pVtab != null 
( pVtab && (x = pVtab->pModule->xSync
( pVtab!=0 
( pVtab->pModule!=0 
( pVtab.pModule.xRename 
( pWC.a != pWC.aStatic 
( pWC.a==null 
( pWC.aStatic 
( pWC.nTerm >= pWC.nSlot 
( pWC.op == TK_AND 
( pWC.vmask 
( pWC.vmask == 0 && pMaskSet.n == 0 
( pWInfo 
( pWInfo != null 
( pWInfo == null 
( pWInfo.a[0].plan.wsFlags & ~WHERE_IDX_ONLY 
( pWInfo.pWC 
( pWhen != null 
( pWhere != null 
( pWhere != null && ( pTabList.nSrc == 0 || sqlite3ExprIsConstantNotJoin( pWhere 
( pWhereRowid == null 
( pX 
( pX != null 
( pX.op == TK_COLUMN 
( pX.op == TK_EQ 
( pX.op == TK_IN 
( pX.op == TK_ISNULL 
( pX.op == TK_LT || pX.op == TK_GT 
( pX.op == TK_REGISTER 
( pX.pLeft != null 
( p[1 + offset] << 16 
( p[1] << 16 
( p[2 + offset] << 8 
( p[2] << 8 
( pageInJournal( pPg 
( pageSize 
( pageSize == 0 || ( pageSize >= 512 && pageSize <= SQLITE_MAX_PAGE_SIZE 
( parseHhMmSs( z2.Substring( z2Index 
( payloadSize <= (u32
( payloadSize == 0 
( payloadSize == 0 || zRec != null 
( payloadSize > (u32
( pbMayReplace 
( pc = p.pc ; rc == SQLITE_OK ; pc++ 
( pc == 0 
( pc > 0 
( pc > 1 
( pc >= -1 && pc < p.nOp 
( pc >= 0 && pc < p.nOp 
( pc<iCellFirst || pc>iCellLast 
( pcache1.isInit != 0 
( pcache1.isInit == 0 
( pcache1.nCurrentPage > pcache1.nMaxPage && pcache1.pLruTail != null 
( pcache1.nMaxPage + pCache.nMin - pcache1.nMinPage 
( pcache1.pLruHead != null 
( pcache1.pLruHead != pPage && pcache1.pLruTail != pPage 
( pcache1.pLruHead == pPage 
( pcache1.pLruTail == pPage 
( pcache1.pStart==0 
( pcacheCheckSynced(p
( pcacheCheckSynced(pCache
( pg != ( ( PENDING_BYTE / ( pPager.pageSize 
( pg1 + ii 
( pg1 <= pPg.pgno 
( pgno 
( pgno != 0 
( pgno - 1 
( pgno <= PAGER_MAX_PGNO && pgno != PAGER_MJ_PGNO( pPager 
( pgno <= p.nOrig 
( pgno <= pPager.dbOrigSize 
( pgno == 0 
( pgno == 0 && pCache.pPage1 != null 
( pgno == 0 || pgno == PAGER_MJ_PGNO( pPager 
( pgno == 1 
( pgno == MASTER_ROOT + 1 
( pgno > 0 
( pgno > PAGER_MAX_PGNO || pgno == PAGER_MJ_PGNO( pPager 
( pgno > pPager.dbFileSize 
( pgno > pPager.mxPgno 
( piNewColMask != 0 
( piOldColMask != 0 
( pnAlloc 
( pnEntry >= pnAlloc 
( pnPage 
( pnoCase 
( pp 
( pp != p 
( pp != pPage 
( pp = &pTab->pTrigger ; *pp != pTrigger ; pp = &( (*pp
( pp == pCache.apHash[h] 
( ppBtree != null
( ppIter 
( ppList == null 
( ppStmt 
( ppStmt && *ppStmt==0 
( ppStmt == null 
( ppStmt!=0 
( prNotFound != -1 
( prNotFound != 0 
( prc != 0 
( precision < 0 
( precision > 0 
( precision > 0 ? true : false 
( precision > etBUFSIZE - 40 && ( infop.flags & FLAG_STRING 
( precision > etBUFSIZE / 2 - 10 
( precision >= 0 
( precision>=0 && precision<length 
( prefix != '\0' 
( prefix != '\0' ? 1 : 0 
( prefix == '+' 
( prefix == '-' 
( preserve != 0 
( prior + delay > timeout 
( proxy_file_path!=0 
( pzBuffer != null 
( pzBuffer !=null
( pzBuffer == null || isReduced 
( pzCollSeq 
( pzDataType 
( pzErrMsg 
( pzErrMsg != null
( pzErrMsg != null 
( pzErrMsg !=null
( pzErrMsg !=null 
( pzErrMsg!=0 
( pzOriginDb != null 
( pzOriginTab != null && pzOriginCol != null 
( query 
( quote 
( r * ( 86400000.0 / ( 24.0 * 60.0 
( r * ( 86400000.0 / ( 24.0 * 60.0 * 60.0 
( r * ( 86400000.0 / 24.0 
( r * 86400000.0 + 0.5 
( r * 86400000.0 + rRounder 
( r < (double
( r < 0 
( r > (double
( r >= iFrom && r <= iTo 
( r >= iStart && r <= iEnd 
( r ^ ( ( (sqlite3_int64
( r1 
( r1 != r2 
( r1 != regBase + j 
( r1 < r2 
( r1 == r2 
( r1 > r2 
( r2 == r1 
( rA == (double
( rMayHaveNull != 0 
( rNotFound == 0 
( rTotal < pCost.rCost 
( rTotal >= pCost.rCost 
( rVal < 0 
( rc 
( rc != 0 
( rc != 0 && ( p.rc == SQLITE_OK || p.rc == SQLITE_CONSTRAINT 
( rc != 0 || NEVER( pParse.nErr != 0 
( rc != 0 || null == zName || ( pColName.flags & MEM_Term 
( rc != SQLITE_BUSY && rc != SQLITE_LOCKED 
( rc != SQLITE_DONE 
( rc != SQLITE_INTERRUPT && rc != SQLITE_LOCKED 
( rc != SQLITE_IOERR_BLOCKED 
( rc != SQLITE_IOERR_NOMEM 
( rc != SQLITE_OK 
( rc != SQLITE_OK && ++cnt < MX_DELETION_ATTEMPTS 
( rc != SQLITE_OK && ALWAYS( rc == sqlite3_errcode( db 
( rc != SQLITE_OK && cnt++ < MX_DELETION_ATTEMPTS 
( rc != SQLITE_OK && rc != SQLITE_BUSY 
( rc != SQLITE_OK && rc != SQLITE_BUSY && ALWAYS( rc != SQLITE_LOCKED 
( rc != SQLITE_OK && rc != SQLITE_IOERR_SHORT_READ 
( rc != SQLITE_OK && rc != SQLITE_READONLY /* && rc!=SQLITE_BUSY */ 
( rc != SQLITE_OK || iPageSize16 == (u16
( rc != SQLITE_OK || isOpen( pFile 
( rc != SQLITE_OK || isOpen( pPager.jfd 
( rc != SQLITE_OK || pPager.journalOff == szJ 
( rc != SQLITE_OK || res == 0 
( rc != SQLITE_OK || szJ == 0 
( rc != SQLITE_ROW 
( rc != SQLITE_ROW && db.xProfile != null && 0 == db.init.busy && p.zSql != null 
( rc != SQLITE_SCHEMA 
( rc !=0
( rc & db.errMask 
( rc = 
( rc = sqlite3BtreeCommitPhaseTwo( p.pDest 
( rc = sqlite3PagerSync( pDestPager 
( rc = sqlite3PagerWrite( pDestPg 
( rc = sqlite3Reprepare( v 
( rc = subjournalPage( pPg 
( rc == 0 
( rc == 0 || amt > (int
( rc == INVALID_SET_FILE_POINTER && ( error = GetLastError(
( rc == SQLITE_BUSY 
( rc == SQLITE_BUSY && pPager.xBusyHandler( pPager.pBusyHandlerArg 
( rc == SQLITE_BUSY || rc == SQLITE_OK 
( rc == SQLITE_CANTOPEN 
( rc == SQLITE_CONSTRAINT 
( rc == SQLITE_DONE 
( rc == SQLITE_EMPTY 
( rc == SQLITE_IOERR_NOMEM 
( rc == SQLITE_IOERR_SHORT_READ 
( rc == SQLITE_LOCKED 
( rc == SQLITE_NOMEM 
( rc == SQLITE_NOMEM || rc == SQLITE_IOERR_NOMEM 
( rc == SQLITE_NOMEM || rc == SQLITE_OK 
( rc == SQLITE_OK 
( rc == SQLITE_OK && !pPager.noSync 
( rc == SQLITE_OK && !readOnly 
( rc == SQLITE_OK && !sqlite3BtreeIsInReadTrans( p.pSrc 
( rc == SQLITE_OK && ( eAuto == 1 || eAuto == 2 
( rc == SQLITE_OK && ( fout & SQLITE_OPEN_READONLY 
( rc == SQLITE_OK && ALWAYS( db.nDb > 1 
( rc == SQLITE_OK && commit_internal 
( rc == SQLITE_OK && currentSize != newSize 
( rc == SQLITE_OK && db.xUpdateCallback != null && pOp.p4.z != null 
( rc == SQLITE_OK && encoding != 0 
( rc == SQLITE_OK && exists != 0 
( rc == SQLITE_OK && iCurrent > iSize 
( rc == SQLITE_OK && iLimit > 0 
( rc == SQLITE_OK && iMoved != 0 
( rc == SQLITE_OK && locked == 0 
( rc == SQLITE_OK && nPathname + 8 > pVfs.mxPathname 
( rc == SQLITE_OK && needSync 
( rc == SQLITE_OK && pDest.eDest == SRT_Output 
( rc == SQLITE_OK && pList 
( rc == SQLITE_OK && pPager.journalMode != PAGER_JOURNALMODE_OFF 
( rc == SQLITE_OK && pPager.journalOff < iHdrOff 
( rc == SQLITE_OK && pPager.journalOff < szJ 
( rc == SQLITE_OK && pPager.nSavepoint != 0 
( rc == SQLITE_OK && pParse.pVdbe != null && pParse.explain != 0 
( rc == SQLITE_OK && res == 0 
( rc == SQLITE_OK && res == 1 
( rc == SQLITE_OK && sqlite3ExprIsConstant( pExpr 
( rc == SQLITE_OK && sz > iLimit 
( rc == SQLITE_OK && zMaster[0] != '\0' && res != 0 
( rc == SQLITE_OK && zMaster[0] != 0 
( rc == SQLITE_OK ? rc2 : rc 
( rc == SQLITE_OK || ( db.flags & SQLITE_RecoveryMode 
( rc == SQLITE_OK || pFile.pMethods == null 
( rc == SQLITE_OK || pStmt == null 
( rc == SQLITE_OK || ppStmt == null 
( rc == SQLITE_OK || rc == SQLITE_NOMEM 
( rc == SQLITE_ROW 
( rc == SQLITE_SCHEMA 
( rc == SQLITE_SCHEMA && ALWAYS( v.isPrepareV2 
( rc!=SQLITE_OK 
( rc!=SQLITE_OK && rc!=SQLITE_IGNORE 
( rc!=SQLITE_ROW 
( rc2  = 
( rc2 == SQLITE_OK 
( rc2 |= 
( rc==0 
( rc==INVALID_SET_FILE_POINTER && (error=GetLastError(
( rc==INVALID_SET_FILE_POINTER && GetLastError(
( rc==SQLITE_ABORT 
( rc==SQLITE_DENY 
( rc==SQLITE_EMPTY || rc==SQLITE_OK 
( rc==SQLITE_IGNORE 
( rc==SQLITE_NOMEM 
( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM 
( rc==SQLITE_OK 
( rc==SQLITE_OK && pOp.p1 
( rc==SQLITE_OK || ppStmt==null || ppStmt==null 
( rc==SQLITE_ROW 
( rc==SQLITE_TOOBIG 
( rcauth == SQLITE_DENY 
( rcauth == SQLITE_OK && pWhere == null && null == pTrigger && !IsVirtual( pTab 
( rcauth == SQLITE_OK || rcauth == SQLITE_DENY || rcauth == SQLITE_IGNORE 
( realvalue < 0.0 
( realvalue < 1.0 
( realvalue < 1e-8 
( realvalue > 0.0 
( realvalue >= 10.0 
( realvalue >= 10.0 && exp <= 350 
( realvalue >= 1e32 && exp <= 350 
( realvalue >= 1e8 && exp <= 350 
( ref  azChar 
( ref  elem 
( ref  iValue 
( ref  p 
( ref  pColl[j].pUser 
( ref  pCx.pBt 
( ref  pFile 
( ref  pH.ht 
( ref  pMaster 
( ref  pOld 
( ref  pPage 
( ref  pPager 
( ref  pPager.pTmpSpace 
( ref  sqlite3GlobalConfig.pInitMutex 
( ref  string x 
( ref  zText 
( ref Bitvec p 
( ref FILETIME sysfiletime 
( ref Index p 
( ref PgHdr p
( ref PgHdr p 
( ref PgHdr pDestroyArg 
( ref PgHdr1 p 
( ref T x 
( ref Table pTable 
( ref Vdbe p 
( ref apCell 
( ref byte[]  pOld
( ref byte[] p 
( ref byte[][] p 
( ref db 
( ref db.aDb[1].pBt 
( ref db.aDb[iDb].pBt 
( ref db.aModule 
( ref db.lookaside.pStart 
( ref db.mutex 
( ref db.pErr 
( ref ft 
( ref iValue 
( ref int v 
( ref object pDelArg 
( ref p 
( ref p.apHash 
( ref p.pPgHdr 
( ref p.pUser 
( ref p.u.apSub[i] 
( ref p.z 
( ref pAux 
( ref pAux.pAux 
( ref pAuxData.pAux 
( ref pBitvec 
( ref pBt.pSchema 
( ref pCache 
( ref pCache.apHash 
( ref pCache.pCache 
( ref pCellKey 
( ref pDb.pBt 
( ref pDone 
( ref pFKey.zTo 
( ref pIndex 
( ref pIndex.zColAff 
( ref pInfo.idxStr 
( ref pItem.pTab 
( ref pItem.zName 
( ref pMem.z 
( ref pNew.u.zToken 
( ref pPage 
( ref pPager 
( ref pPager.aSavepoint 
( ref pPager.aSavepoint[ii].pInSavepoint 
( ref pPager.nHit 
( ref pPager.nMiss 
( ref pPager.nRead 
( ref pPager.nWrite 
( ref pPager.pInJournal 
( ref pParse.pNewTable 
( ref pParse.pVdbe 
( ref pSelTab 
( ref pStmt 
( ref pTab 
( ref pTmp 
( ref pTmpSpace 
( ref pV 
( ref pVal 
( ref ppStmt 
( ref sCheck.anRef 
( ref sqlite3Autoext.aExt 
( ref sqlite3_mutex m 
( ref sqlite3_mutex p 
( ref sqlite3_pcache p 
( ref sqlite3_stmt pStmt 
( ref sqlite3_temp_directory 
( ref sqlite3_value v 
( ref string pDelArg 
( ref string x 
( ref string z 
( ref vm 
( ref wsdAutoext.aExt 
( ref z
( ref z 
( ref z2 
( ref zBuf 
( ref zErr 
( ref zMasterJournal 
( ref zName 
( ref zPathname 
( regFree1 == 0 
( regFree2 == 0 
( regIdxKey 
( regPrev != 0 
( regRec > pParse.nMem 
( regRow != pDest.iMem + i 
( register==NULL 
( res 
( res != 0 
( res != 0 && rc == SQLITE_OK 
( res != SQLITE_OK 
( res < 0 
( res < 0 || ( res == 0 && oc == OP_SeekGt 
( res <= 0 
( res == 0 
( res > 0 
( res > 0 || ( res == 0 && oc == OP_SeekLt 
( res >= 0 
( res.azResult==null 
( res.nAlloc>res.nData 
( res.nData 
( resetFlag != 0 
( result && negFlag && pNum == Int64.MaxValue  
( retries > 0 
( reuseUnlikely != 0 || pcache1.nCurrentPage > pcache1.nMaxPage 
( rev != 0 
( row.ItemArray[0].ToString(
( rowidChng 
( s > 59.999 
( sAggInfo.aCol[i].iSorterColumn >= j 
( sCheck.anRef[i]==null 
( sCheck.mallocFailed 
( sContext 
( sContext.isError 
( sEnd.n 
( sMem 
( sMem.xDel == null 
( sMem.z == sMem.zMalloc
( sMem.zMalloc != null 
( sParse.zErrMsg 
( savedHasAgg != 0 
( score > bestScore 
( scratchAllocOut == 0 
( scratchAllocOut == 1 
( seenReplace 
( select 
( serial_type 
( serial_type - 12 
( serial_type <= 7 && serial_type > 0 
( serial_type == 6 
( serial_type == 7 
( serial_type >= 12 
( setStatement != 0 && pParse.nested == 0 
( sign < 0 ? -v1 : v1 
( size 
( size < 0 
( size == 0 
( size<p.iSize 
( sizeof( Bitmask 
( sizeof( DWORD 
( sizeof( PCache1 
( sizeof( PgHdr1* 
( sizeof( UnpackedRecord 
( sizeof( WhereInfo 
( sizeof( char* 
( sizeof( double 
( sizeof( i64 
( sizeof( long 
( sizeof( sqlite3_backup 
( sizeof( sqlite_int64 
( sizeof( u32 
( sizeof( u64 
( sizeof( u8 
( sizeof( v
( sizeof(*p
( sizeof(HashElem
( sizeof(p
( sizeof(r1
( sizeof(res.azResult[0]
( skipKey 
( sqlite3 X 
( sqlite3 db 
( sqlite3 p 
( sqlite3 x 
( sqlite3Autoext.nExt == 0 
( sqlite3BitvecSize( pBitvec 
( sqlite3BtreeCursorIsValid( pC.pCursor 
( sqlite3BtreeCursorIsValid( pCrsr 
( sqlite3BtreeCursorIsValid( pCur 
( sqlite3BtreeCursorIsValid(pCur
( sqlite3BtreeHoldsAllMutexes( db 
( sqlite3BtreeHoldsAllMutexes( pParse.db 
( sqlite3BtreeHoldsAllMutexes(db
( sqlite3BtreeHoldsMutex( db.aDb[iDb].pBt 
( sqlite3BtreeHoldsMutex( p.pSrc 
( sqlite3BtreeHoldsMutex( pBt 
( sqlite3BtreeHoldsMutex(p
( sqlite3BtreeHoldsMutex(pBtree
( sqlite3BtreeIsInReadTrans( pDb.pBt 
( sqlite3BtreeIsInTrans( db.aDb[i].pBt 
( sqlite3BtreeIsInTrans( pBt 
( sqlite3BtreeIsInTrans( pMain 
( sqlite3BtreeIsInTrans( pTemp 
( sqlite3BtreePager( db.aDb[1].pBt 
( sqlite3BtreePager( p.pSrc 
( sqlite3BtreePager( pMain 
( sqlite3CtypeMap[( (byte
( sqlite3CtypeMap[(byte
( sqlite3ExprAffinity( pLeft 
( sqlite3ExprIsConstantNotJoin( p 
( sqlite3ExprIsConstantOrFunction( pSpan.pExpr 
( sqlite3GlobalConfig == null 
( sqlite3GlobalConfig.bCoreMutex 
( sqlite3GlobalConfig.bCoreMutex && sqlite3GlobalConfig.pInitMutex == null 
( sqlite3GlobalConfig.bCoreMutex == false 
( sqlite3GlobalConfig.bFullMutex && isThreadsafe != 0 
( sqlite3GlobalConfig.bMemstat 
( sqlite3GlobalConfig.isInit != 0 
( sqlite3GlobalConfig.isInit == 0 && sqlite3GlobalConfig.inProgress == 0 
( sqlite3GlobalConfig.isMallocInit == 0 
( sqlite3GlobalConfig.m.pAppData 
( sqlite3GlobalConfig.m.xMalloc == null 
( sqlite3GlobalConfig.m.xShutdown != null 
( sqlite3GlobalConfig.mutex.xMutexEnd 
( sqlite3GlobalConfig.nRefInitMutex <= 0 
( sqlite3GlobalConfig.nRefInitMutex == 0 
( sqlite3GlobalConfig.pInitMutex 
( sqlite3GlobalConfig.pInitMutex == null 
( sqlite3GlobalConfig.pcache.pArg 
( sqlite3GlobalConfig.pcache.xInit == null 
( sqlite3GlobalConfig.pcache.xShutdown != null 
( sqlite3GlobalConfig.sharedCacheEnabled 
( sqlite3GlobalConfig.szPage 
( sqlite3GlobalConfig.szScratch < n 
( sqlite3HashFind( ( db.aDb[iDb].pSchema.trigHash 
( sqlite3IoTrace 
( sqlite3IsMemJournal( pPager.jfd 
( sqlite3IsNaN( pMem.r 
( sqlite3IsNaN( rB 
( sqlite3IsNaN( val 
( sqlite3IsNaN( value 
( sqlite3IsNaN( y 
( sqlite3IsNaN((double
( sqlite3IsRowid( pChanges.a[i].zName 
( sqlite3IsRowid( pColumn.a[i].zName 
( sqlite3IsRowid(zColumnName
( sqlite3Isdigit( z[0] 
( sqlite3Isdigit( z[iOffset + i + 1] 
( sqlite3Isdigit( z[zDx] 
( sqlite3Isspace( z[n] 
( sqlite3Isspace( z[zDx] 
( sqlite3Isspace(*(u8*
( sqlite3Isspace(z[i]
( sqlite3JournalSize( pVfs 
( sqlite3MemJournalSize(
( sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER 
( sqlite3OpenTempDatabase( pParse 
( sqlite3OsDeviceCharacteristics( pMaster 
( sqlite3OsDeviceCharacteristics( pPager.fd 
( sqlite3OsTrace 
( sqlite3PagerGetExtra( pDestPg 
( sqlite3PagerTrace 
( sqlite3PcacheDirtyList( pPager.pPCache 
( sqlite3PcacheRefCount( pPager.pPCache 
( sqlite3PendingByte != newVal 
( sqlite3ReadSchema( pParse 
( sqlite3SafetyCheckOk(db
( sqlite3SafetyCheckSickOrOk( db 
( sqlite3SafetyOff( db 
( sqlite3SafetyOff(db
( sqlite3SafetyOn( db 
( sqlite3SafetyOn(db
( sqlite3StatusValue( SQLITE_STATUS_MEMORY_USED 
( sqlite3StrAccumFinish( acc 
( sqlite3Strlen30( pTab.zName 
( sqlite3Strlen30( zJournal 
( sqlite3UpperToLower[(u8
( sqlite3UpperToLower[c1] + nName 
( sqlite3UpperToLower[z[iOffset + n - 1]] * 3 
( sqlite3VdbeAddopTrace 
( sqlite3VdbeDb( v 
( sqlite3VdbeHalt( p 
( sqlite3VdbeIntValue( pIn1 
( sqlite3VdbeIntValue( pIn2 
( sqlite3VdbeMemMakeWriteable( pVal 
( sqlite3VdbeMemNulTerminate( pMem 
( sqlite3VdbeMemTooBig( pMem 
( sqlite3VdbeMemTooBig( pOut 
( sqlite3VdbeMemTooBig( pVar 
( sqlite3VdbeMemTooBig(pDest
( sqlite3VdbeRealValue( pIn1 
( sqlite3VtabInSync(db
( sqlite3WhereTrace 
( sqlite3_backup p 
( sqlite3_backup pBackup 
( sqlite3_context context 
( sqlite3_context ctx 
( sqlite3_context p 
( sqlite3_context pCtx 
( sqlite3_context_db_handle( context 
( sqlite3_diskfull_pending 
( sqlite3_diskfull_pending == 1 
( sqlite3_diskfull_pending.iValue != 0 
( sqlite3_diskfull_pending.iValue == 1 
( sqlite3_file File_ID 
( sqlite3_file fd 
( sqlite3_file id 
( sqlite3_file pFd 
( sqlite3_file pFile 
( sqlite3_file pId 
( sqlite3_file pJfd 
( sqlite3_file x 
( sqlite3_index_info p 
( sqlite3_initialize(
( sqlite3_interrupt_count == 0 
( sqlite3_interrupt_count > 0 
( sqlite3_io_error_benign == 0 
( sqlite3_io_error_pending.iValue <= 0 
( sqlite3_memory_used(
( sqlite3_mutex m 
( sqlite3_mutex p 
( sqlite3_mutex_held( db.mutex 
( sqlite3_mutex_held( mem0.mutex 
( sqlite3_mutex_held( p.pSrc.pBt.mutex 
( sqlite3_mutex_held( p.s.db.mutex 
( sqlite3_mutex_held( pCtx.s.db.mutex 
( sqlite3_mutex_held( pCur.pBtree.db.mutex 
( sqlite3_mutex_held( pcache1.mutex 
( sqlite3_mutex_held( sqlite3MutexAlloc( SQLITE_MUTEX_STATIC_MASTER 
( sqlite3_mutex_held( sqlite3VdbeDb( p 
( sqlite3_mutex_held(db->mutex
( sqlite3_mutex_held(p->db->mutex
( sqlite3_mutex_held(p->pBt->mutex
( sqlite3_mutex_held(p.db.mutex
( sqlite3_mutex_held(pBt.mutex
( sqlite3_mutex_held(pCsr.pBtree.db.mutex
( sqlite3_mutex_held(pCtx.s.db.mutex
( sqlite3_mutex_held(pCur.pBtree.db.mutex
( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER
( sqlite3_mutex_notheld(p->pBt->mutex
( sqlite3_mutex_notheld(pBt.mutex
( sqlite3_mutex_try(p->pBt->mutex
( sqlite3_pcache p 
( sqlite3_stmt pStmt 
( sqlite3_temp_directory 
( sqlite3_value pVal 
( sqlite3_value pval 
( sqlite3_value_double( argv[0] 
( sqlite3_value_text( pVal 
( sqlite3_value_type( argv[0] 
( sqlite3_value_type( argv[1] 
( sqlite3_value_type( argv[i] 
( sqlite3_vfs pVfs 
( sqlite3_vtab pVTab 
( sqlite3_vtab_cursor pCursor 
( srcType == MEM_Ephem || srcType == MEM_Static 
( ss != null 
( startEq << 1 
( start_constraints << 2 
( state == 0 
( stateno>YY_REDUCE_MAX 
( step_list != null 
( string X 
( string inStr 
( string z 
( string zFilename 
( string zIn 
( string zNum 
( string zSql 
( string zVfs 
( subjRequiresPage( pPg 
( subqueryIsAgg 
( subqueryIsAgg && pSrc.nSrc > 1 
( syncDir 
( sysType 
( sz 
( sz * cnt 
( sz + 7 
( sz <= (int
( sz == 0 || cnt == 0 
( sz > sizeof( LookasideSlot* 
( szHdr == 3 
( szHdr == m.n 
( szNew > p.mxAlloc 
( szPageDflt < pPager.sectorSize 
( szScratch 
( t 
( t2 
( tableSeen == 0 
( target > 0 
( target > 0 && target <= pParse.nMem 
( temp1 
( temp2 
( termSortOrder != sortOrder 
( testAddr != 0 
( testAddr != 0 && sqlite3ExprIsConstant( pE2 
( testAddr > 0 /* || pParse.db.mallocFailed != 0 */ 
( testOp != OP_Noop 
( this == null 
( timeF / ntuPerDay 
( timeSpan.TotalSeconds 
( time_t baseTime 
( tmask & TRIGGER_AFTER 
( tmp 
( tnum == pIndex.tnum 
( tnum == pTab.tnum 
( to_op == OP_ToBlob 
( to_op == OP_ToBlob || aff != SQLITE_AFF_NONE 
( to_op == OP_ToInt 
( to_op == OP_ToInt || aff != SQLITE_AFF_INTEGER 
( to_op == OP_ToNumeric 
( to_op == OP_ToNumeric || aff != SQLITE_AFF_NUMERIC 
( to_op == OP_ToReal 
( to_op == OP_ToReal || aff != SQLITE_AFF_REAL 
( to_op == OP_ToText 
( to_op == OP_ToText || aff != SQLITE_AFF_TEXT 
( token != TK_LP && token != TK_USING 
( token == TK_DOT || token == TK_ON 
( token == TK_SPACE 
( tokenType 
( tr_tm == TK_BEFORE 
( tr_tm == TK_INSTEAD 
( tr_tm == TRIGGER_BEFORE || tr_tm == TRIGGER_AFTER 
( true 
( turnOnAC != 0 && 0 == iRollback && db.writeVdbeCnt > 0 
( turnOnAC != 0 && iRollback != 0 && db.activeVdbeCnt > 1 
( tx 
( type != TK_DEFERRED 
( type == SQLITE_INTEGER 
( type >= EXCLUSIVE_LOCK 
( type >= PENDING_LOCK 
( type >= RESERVED_LOCK 
( type<12 
( typeRowid 
( typeRowid == 1 
( typeRowid == 2 
( typeRowid == 3 
( typeRowid == 4 
( typeRowid == 5 
( typeRowid == 6 
( typeRowid == 8 
( typeRowid == 9 
( u <= 127 
( u <= 2147483647 
( u <= 32767 
( u <= 8388607 
( u <= MAX_6BYTE 
( u <= pKeyInfo.nField + 1 
( u = 0 ; u < len ; u++ 
( u = 0 ; u < nRec ; u++ 
( u32 
( u32 X 
( u32 iSize 
( u32 serial_type 
( u64 
( u64 v 
( u8 C 
( u8[] p 
( unionTab == dest.iParm || dest.eDest != priorOp 
( unlikely( (u32
( unlikely( szHdr < 3 || (int
( unlikely( typeRowid < 1 || typeRowid > 9 || typeRowid == 7 
( unsigned int nPage = 0; 
( useExtended != 0 || ( infop.flags & FLAG_INTERN 
( useJournal ? 1 : 0 
( useJournal || pPager.tempFile 
( useSeekResult 
( useTempTable 
( v 
( v != 0 
( v != 0 && ALWAYS( i < 9 
( v != null 
( v != null && ALWAYS( pParse.nErr == 0 
( v != null /*|| db.mallocFailed != 0 */ 
( v & 0x7f 
( v & 0xFF 
( v && (rc!=SQLITE_OK || db->mallocFailed
( v - neg > 2147483647 
( v < ( pMem.u.i + 1 
( v < 0 
( v <= 0x7F 
( v == 0 
( v == 40 || v == 41 
( v == MAX_ROWID 
( v == null 
( v == null || NEVER( pTab == null 
( v >> ( sizeof( i64 
( v >> 16 & 0xFF 
( v >> 24 & 0xFF 
( v >> 8 
( v >> 8 & 0xFF 
( v.db.mutex 
( v1 == 2 
( v==0 
( val - d 
( val < min || val > max || zIndex < zDate.Length && ( nextC != 0 && nextC != zDate[zIndex] 
( var < COLNAME_N 
( vfsFlags & SQLITE_OPEN_READONLY 
( vfsFlags & ~SQLITE_OPEN_MAIN_DB 
( vfsList != null 
( vfsList == pVfs 
( viewOk == 0 && pTab.pSelect != null 
( vm 
( wc.pMaskSet 
( wctrlFlags & WHERE_FORCE_TABLE 
( wctrlFlags & WHERE_OMIT_OPEN 
( width < 0 
( width > etBUFSIZE - 10 
( winMutex_isInit==1 
( wrflag 
( wrflag>1 
( wrong_num_args 
( wsFlags != 0 && ( pParse.db.flags & SQLITE_ReverseOrder 
( wsFlags != 0 && cost < pCost.rCost 
( wsFlags != 0 && pSrc.colUsed < ( ( (Bitmask
( wsFlags & WHERE_COLUMN_IN 
( wsFlags & WHERE_COLUMN_NULL 
( wsFlags == 0 
( wsdAutoext.aExt[i] == xInit 
( wsdAutoext.nExt == 0 
( wsdHooks.xBenignBegin != null 
( wsdHooks.xBenignEnd != null 
( wsdPrng.j + t 
( wsdPrng.j + wsdPrng.s[i] + k[i] 
( wsdStat.nowValue[op] > wsdStat.mxValue[op] 
( wtFlags & TERM_DYNAMIC 
( x 
( x + 7 
( x < BMS - 1 
( x < y 
( x << 32 
( x = pTbls.first ; x != null && !isQuick ; x = x.next 
( x = pTbls.first ; x != null ; x = x.next 
( x == 1 
( x >= 4 || ( longvalue / 10 
( x >= iFrom && x < iFrom + nReg 
( x.Y < 1971 || x.Y >= 2038 
( x.iJD / 1000 - 21086676 * (i64
( x.iJD / 1000 - 210866760000L 
( x.pList != null 
( x.pSelect != null 
( x.s 
( x.s + 0.5 
( xConstruct 
( xDel == SQLITE_DYNAMIC 
( xDel == SQLITE_TRANSIENT 
( xDelete != null 
( xDestroy 
( xFunc != null && ( xFinal != null || xStep != null 
( xFunc == null && ( xFinal != null && xStep == null 
( xFunc == null && ( xFinal == null && xStep != null 
( xInit==0 
( xNotify==0 
( xSectorSize != null ? xSectorSize( id 
( xtype 
( xtype != etFLOAT 
( xtype == etDYNSTRING 
( xtype == etEXP 
( xtype == etFLOAT 
( xtype == etGENERIC 
( xtype == etGENERIC && precision > 0 
( xtype == etINVALID 
( xtype == etORDINAL 
( xtype == etSQLESCAPE2 
( y 
( y != r 
( y != z 
( y.iJD - x.iJD 
( yyTraceFILE 
( yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-3].minor.yy0.z 
( yymx!=YYERRORSYMBOL 
( yymx==YYERRORSYMBOL || yyerrorhit 
( yypParser.yyerrcnt<0 
( yypParser.yyidx < 0 || yymajor==0 
( yypParser.yyidx>=yypParser.yystksz 
( yypParser.yyidx>yypParser.yyidxMax 
( yypParser.yystksz <=0 
( yyruleno == 285 
( yysize!=0 
( z 
( z != null 
( z != null && z == zName 
( z != null && zName != null 
( z != null || N == 0 
( z != pMem.z 
( z < 32 || z > 126 
( z == 0 
( z == null 
( z == null || z.Length == 0 
( z.Length 
( z.Length != 0 
( z.Length <= 9 
( z.Length == 1 
( z.Length > 1 
( z.Length > iOffset + 1 && ( c = (byte
( z.Length > iOffset + 1 && z[iOffset + 1] == '-' 
( z.Length > iOffset + 1 && z[iOffset + 1] == '\'' 
( z.Length > iOffset + i && ( ( ( c = (byte
( z.Length > iOffset + i && sqlite3Isdigit( z[iOffset + i] 
( z.Length > iOffset + i && z[iOffset + i] == '.' 
( z.Length > iOffset + i + 1 && ( z[iOffset + i] == 'e' || z[iOffset + i] == 'E' 
( z.Length > iOffset + i + 1 && z[iOffset + i + 1] == delim 
( z.Substring( 1 
( z.ToString(
( z1 
( z1 !=null
( z1 == null 
( z1[i] 
( z2 != null 
( z2 == null 
( z2 == sqlite3_value_text( argv[0] 
( z<=zTerm 
( z==0 
( z==null 
( zA != null && zB != null 
( zAlias1 == null 
( zAlias2 == null 
( zArg == null || zArg.Length == 0 
( zArg[i] == '\'' 
( zB == sqlite3_value_text( argv[0] 
( zBLOB == null 
( zBLOB.Length 
( zBLOB.Length == 0 || p1 > zBLOB.Length 
( zBlob != null 
( zBlob.Length == sqlite3_value_blob( argv[0] 
( zBlob.ToString(
( zBuf = z 
( zBuf == null 
( zBuf.Length - 1 
( zBuf.ToString(
( zCharSet != null 
( zCol != null 
( zColAff == null 
( zColl 
( zColl != null 
( zColl == null 
( zColname 
( zConverted 
( zConverted.Length != 0 
( zConverted==0 
( zConverted[i] == '\\' 
( zCsr 
( zCsr - (u8*
( zCsr == zSql.Length 
( zData != null 
( zDate.IndexOf( nextC0 
( zDate.Length == 6 
( zDate.Length > 6 
( zDate.Substring( zDate.IndexOf( nextC0 
( zDate1.Substring( zDate1.IndexOf( nextC1 
( zDate[zIndex] == '-' 
( zDb != null 
( zDb == null && zTab != null && cnt == 0 && pParse.trigStack != null 
( zDbName == null 
( zDbase != null 
( zDx 
( zEnd 
( zEnd>zCol && (*zEnd==';' || sqlite3Isspace(*zEnd
( zErr==0 
( zErrmsg 
( zErrmsg !=null
( zEsc == null 
( zExternal == null 
( zExtra 
( zFile 
( zFile==null 
( zFile[0] == 0 
( zFilename 
( zFilename == null 
( zFilename8 
( zFilename==0 
( zFmt[i] != '%' 
( zFmt[i] == '%' 
( zFmt[i] == 'W' 
( zFormat != null 
( zFormat == null 
( zFull.Length > pVfs.mxPathname 
( zHex != null 
( zId 
( zIdent[0] 
( zIdx < zEndHdr 
( zIdx < zSql.Length 
( zIdx < zSql.Length && zSql[zIdx] != '*' || zIdx < zSql.Length - 1 && zSql[zIdx + 1] != '/' 
( zIdx < zSql.Length && zSql[zIdx] != '\n' 
( zIdx < zSql.Length && zSql[zIdx] != ']' 
( zIdx < zSql.Length && zSql[zIdx] != c 
( zIdx == zEndHdr && offset64 != (u64
( zIdx == zSql.Length 
( zIdxName 
( zIn == null 
( zIn == null || zIn.Length == 0 
( zIn == sqlite3_value_text( argv[0] 
( zIn!=zEnd 
( zIn!=zTerm && (*zIn & 0xc0
( zIn++ 
( zIn.Length == 0 
( zIn<zTerm 
( zIn==0 
( zIn[0] 
( zIn[i] 
( zIn[zTerm - 1] == 0 ? 1 : 0 
( zIndex 
( zIndex != zIn.Length && ( zIn[zIndex] & 0xc0 
( zIndex + 1 < zDate.Length && zDate[zIndex] == '.' && sqlite3Isdigit( zDate[zIndex + 1] 
( zIndex < z.Length && ( c = z[zIndex] 
( zIndex < z.Length && ( z[zIndex] == '+' || z[zIndex] == '-' 
( zIndex < z.Length && ( z[zIndex] == 'e' || z[zIndex] == 'E' 
( zIndex < z.Length && sqlite3Isdigit( z[zIndex] 
( zIndex < z.Length && z[zIndex] == ' ' 
( zIndex < z.Length && z[zIndex] == '.' 
( zIndex < zDate.Length && ( sqlite3Isspace( zDate[zIndex] 
( zIndex < zDate.Length && parseHhMmSs( zDate.Substring( zIndex 
( zIndex < zDate.Length && parseTimezone( zDate.Substring( zIndex 
( zIndex < zDate.Length && sqlite3Isdigit( zDate[zIndex] 
( zIndex < zDate.Length && zDate[zIndex] == ':' 
( zIndex == z.Length || !sqlite3Isdigit( z[zIndex] 
( zIndex >= zDate.Length 
( zLeft[0] 
( zLeft[0] == 'q' 
( zLeft[a] < 256 && zRight[b] < 256 
( zLoc + tname.n 
( zLowerName 
( zMasterJournal != null 
( zMbcsFilename==0 
( zMod.Substring( n 
( zMod.ToLower(
( zMulti 
( zName 
( zName != null 
( zName == null 
( zName.Length == nName 
( zName8 
( zNew 
( zNum.Length <= 18 
( zNum[0] >= '0' && zNum[0] <= '9' 
( zNum[0]=='0' 
( zNum[iZnum] == '+' 
( zNum[iZnum] == '-' 
( zNum[i]>='0' && zNum[i]<='9' 
( zObj == null 
( zOut 
( zOut != null 
( zOut==0 
( zPathname 
( zPathname != null 
( zPathname == null 
( zPattern == null 
( zPattern == sqlite3_value_text( argv[1] 
( zRec != null 
( zRec == null && avail < len 
( zRec!=0 || avail>=payloadSize || avail>=9 
( zRelative 
( zRep == null 
( zRep == sqlite3_value_text( argv[2] 
( zRight 
( zRight != null 
( zRight != null && iCookie != BTREE_FREE_PAGE_COUNT 
( zRight == null 
( zRight.Length > 0 
( zRight[0]!=0 
( zSep 
( zSql 
( zSql != null 
( zSql == null 
( zSql.Length - ( pParse.zTail == null ? 0 : pParse.zTail.Length 
( zSql.Length >= i && nErr == 0 && pParse.rc == SQLITE_OK 
( zSql8 
( zSqlCopy != null 
( zSql[zIdx + 1] != '*' 
( zSql[zIdx + 1] != '-' 
( zSql[zIdx] 
( zSrcData != null 
( zStmt 
( zStmt==0 
( zStorageType 
( zStr == null 
( zStr == sqlite3_value_text( argv[0] 
( zTName != null 
( zTab != null 
( zTab == null && zDb == null 
( zTabName 
( zTabName != null && zTabName[0] != '\0' 
( zTabName == null 
( zTemp 
( zTemp != null 
( zTemp == null 
( zTemp==0 
( zTerm == zInLength 
( zText != null 
( zTmpWide==0 
( zToken 
( zToken != null 
( zType 
( zType[i]=='\0' && i>0 
( zUtf8 
( zUtf8Name 
( zVal 
( zVal == null 
( zVal[nVal] == '\'' 
( zVfs 
( zVfs == pVfs.zName 
( zWhere != null 
( zWhere == null 
( zWideFilename==0 
( z[0] 
( z[0] == ' ' 
( z[0] == '$' 
( z[0] == '-' 
( z[0] == '0' 
( z[0] == '1' 
( z[0] == '2' 
( z[0] == '3' 
( z[0] == '4' 
( z[0] == '5' 
( z[0] == '6' 
( z[0] == '7' 
( z[0] == '8' 
( z[0] == '9' 
( z[0] == ':' 
( z[0] == '?' 
( z[0] == '@' 
( z[0] == 'X' 
( z[0] == '\f' 
( z[0] == '\n' 
( z[0] == '\r' 
( z[0] == '\t' 
( z[0] == 'x' 
( z[0] >= '0' && z[0] <= '2' 
( z[i + 1] 
( z[i-1]!=' ' 
( z[iOffset + 0] 
( z[iOffset + 1] != '=' 
( z[iOffset + 1] != '|' 
( z[iOffset + 1] == '=' ? 1 : 0 
( z[iOffset + i + 2] 
( z[i] 
( z[i] == quote 
( z[n - 1] 
( z[n - 1] == 's' 
( z[n] == ':' 
( z[n] == '\'' 
( z[n] == (byte
( z[zDx] - '0' 
( z[zDx] == '+' 
( z[zDx] == '-' 
( z[zDx] == '.' 
( z[zDx] == '0' 
( z[zDx] == 'e' || z[zDx] == 'E' 
( z[zIndex] == '-' || z[zIndex] == '+' 
( zindex 
( zindex != 0 
( zindex < zSql.Length && sqlite3Isspace( zSql[zindex] 
( ~( EP_Reduced | EP_TokenOnly | EP_Static 
( ~s1 & ~s2 & s3 
(!String.IsNullOrEmpty(zFilename
(!String.IsNullOrEmpty(zMsg1
(!end_constraints
(!p.pBt.autoVacuum
(!p.pBt.incrVacuum
(!p.sharable || removeFromSharingList(pBt
(!pBt.autoVacuum
(!pBt.incrVacuum
(!pBt.readOnly
(!pCur.aOverflow
(!pCur.aOverflow[iIdx] || pCur.aOverflow[iIdx]==nextPage
(!pCur.isIncrblobHandle
(!pFile.hMutex
(!pFile.shared
(!pTstAlloc
(!rc && ++cnt < MX_CLOSE_ATTEMPT
(!start_constraints && startEq &&   bRev
(!start_constraints && startEq &&  !bRev
(!x || !sqlite3IsMemJournal(x
(!yyendofinput
(!zMaster
(#
(%d
(%s
(&(((Mem *
(&((char*
(&buf[etBUFSIZE-1]-bufpt
(&db.aModule
(&m
(&p->aMutex
(&p->z[p->n] - pArg->z
(&pMod[1]
(&pModuleName->z[pModuleName->n] - pName1->z
(&sInfo
(&sqlite3one
(&t
(&temp1
(&time
(&winMutex_staticMutexes[i].mutex
(&zHeader[sizeof(aJournalMagic
(&zRight[4]
(&zRight[6]
('CREATE INDEX i ON abc(a
('It''s a happy day!'
('It's a happy day!'
('a'<<8
('e'<<16
('h'<<16
('l'<<16
('n'<<8
('now'
('o'<<16
('o'<<8
('u'<<8
('x'<<8
((!OMIT_TEMPDB
(('i'<<16
((((char*
((((u64
(((BITVEC_SZ-(3*sizeof(u32
(((D
(((E
(((P
(((X
(((c&0x03C0
(((c-0x10000
(((c=C
(((c>>10
(((char*
(((i64
(((pCell[_pCell++]
(((pCell[_pIter++]
(((pMem.flags & MEM_Dyn
(((pSpace[pOut++] = pCell[_pCell++]
(((pageSize - 1
(((sqlite3_int64
(((u32
(((u8 *
(((x
((*(A
((*zIn++
((--nOverflow
((A
((B
((CHAR*
((DWORD
((E
((H
((HANDLE
((JournalFile *
((N - ROUND8(sizeof(*p
((P
((PENDING_BYTE/((x
((Pgno
((ROWSET_ALLOCATION_SIZE-8
((STRUCTURE*
((WCHAR*
((X
((X->eDest
((__GNUC__
((aligned(8
((balance_deeper_called++
((balance_quick_called++
((c&0x003F
((c-1
((c>>12
((c>>18
((c>>6
((c>>8
((char *
((char*
((db
((double
((error = GetLastError(
((flags & MEM_Blob
((flags & MEM_Zero
((frag < 0
((h1 & 0xf
((i + nxDiv - pParent.nOverflow
((i--
((i386
((i64
((info.nData + (pPage.intKey != 0 ? 0 : info.nKey
((info.nPayload - info.nLocal + ovflPageSize - 1
((int
((lk & 0x7fffffff
((lwr + upr
((nSize & ~3
((p
((pBt.pageSize & 7
((pBt.pageSize - 1
((pBt.pageSize-8
((pBt.usableSize - 12
((pCheck.anRef[iPage]++
((pCur.pKeyInfo == null
((pFd
((pIdxKey == null
((pKey == null
((pMem.flags & MEM_Ephem
((pMem.flags & MEM_Static
((pMem.zMalloc !=null 
((pPage
((pPager.pageSize
((pQuery.flags&MEM_Int
((pRC
((pRoot.nCell > 0
((pTo.pgno == 1
((pVfs
((pageFlags & PTF_LEAF
((pageSize & 7
((pageSize - 1
((pc + size - 1
((pgno - 2
((pgno > 0 && pgno <= iLastPg
((ppPage
((prof.Groups[1].Value
((rc = btreeInitPage(pPage
((rc = sqlite3PagerWrite(pPage.pDbPage
((rc == SQLITE_DONE || rc == SQLITE_OK
((sqlite3_destructor_type
((sqlite3_mutex*
((sqlite3_stmt *
((sqlite_u3264
((start + size
((string
((sz > info.nLocal
((u32
((u8 
((u8*
((unsigned char
((unsigned int
((upr + lwr
((v
((void
((void*
((x
()
() 
()  (1
() (balance_deeper(
() (if any
() (may be null
() (the worker function for sqlite3BtreeData(
() ? new MediumTrustLockingStrategy(
() API function backup_step(
() again
() and //sqlite3_free_table(
() and BackupRestart(
() and BtreeRollback(
() and DataFetch(
() and FormatMessage(
() and NEVER(
() and UnlockFileEx(
() and UpdateMeta(
() and assert(
() and atof(
() and backup_pagecount(
() and balance_deeper(
() and free(
() and isxdigit(
() and lower(
() and max(
() and moveToRightmost(
() and randomblob(
() and sqlite3GetVarint32(
() and sqlite3PagerLookup(
() and sqlite3_backup_pagecount(
() and sqlite3_column_text16(
() and sqlite3_create_collation_v2(
() and sqlite3_errcode(
() and sqlite3_errmsg16(
() and sqlite3_mutex_notheld(
() and sqlite3_mutex_try(
() and sqlite3_open16(
() and sqlite3_open_v2(
() and sqlite3_os_end(
() and sqlite3_prepare16_v2(
() and sqlite3_prepare_v2(
() and sqlite3_realloc(
() and sqlite3_result_error16(
() and sqlite3_shutdown(
() and sqlite3_value_text16le(
() and sqlite3_vmprintf(
() and winMutexEnd(
() and write(
() and xShutdown(
() and xUnlock(
() but works for allocations obtained from sqlite3MemMalloc(
() call above
() contain multiple assert(
() contains Debug.Assert(
() could clobber the value before it is used
() directly instead of sqliteMalloc(
() does not invalidate the _text(
() failed during sqlite3_open(
() failing and the sqlite3OsXXX(
() fails in sqlite3_create_function(
() failure occurred in sqlite3HashInsert(
() failure or IO error
() followed by sqlite3_column_bytes(
() followed by sqlite3_column_bytes16(
() function (otherwise it is unmodified
() function follows the (broken
() function returns (void *
() funtion calls sqlite3VdbeMemSetStr(
() in sqlite3LockAndPrepare(
() increases the lock. xUnlock(
() inside a call to sqlite3_column_text(
() inside of the sqlite3GenerateIndexKey(
() inside rehash(
() interface works like sqlite3_open(
() is called by bestOrClauseIndex(
() is called by sqlite3_shutdown(
() is noop if negative. Next(
() is only used for the TryEnterCriticalSection(
() is that _get(
() is undefined.  The sqlite3_extended_errcode(
() is used more often than toupper(
() is zero or negative then sqlite3_malloc(
() may have failed within the call to sqlite3_value_text16(
() method is called once for each call to [sqlite3_initialize(
() method is used to delete a cache allocated by xCreate(
() on the supplied value (type Mem*
() on unix
() or 0xffffffff for max(
() or BackupRestart(
() or BtreePutData(
() or DataFetch(
() or IO failure
() or UnlockFileEx(
() or atof(
() or attachFunc(
() or avg(
() or backup_finish(
() or balance_deeper(
() or localtime_s(
() or max(
() or moveToRoot(
() or since last time the progress callback was called
() or sqlite3_close(
() or sqlite3_column_blob(
() or sqlite3_column_name16(
() or sqlite3_create_collation16(
() or sqlite3_create_function16(
() or sqlite3_malloc(
() or sqlite3_open_v2(
() or sqlite3_os_end(
() or sqlite3_realloc(
() or sqlite3_result_error16(
() or sqlite_attach(
() or xConnect(
() or xCreate(
() procedure
() returns something other than SQLITE_OK. lockBtree(
() routine is similar to sqlite3_column_bytes(
() should be called if sqlite3SafetyOn(
() since the last sqlite3_initialize(
() sqlite3_mutex_enter(pcache1.mutex
() sqlite3_mutex_leave(pcache1.mutex
() the same as testcase(
() then sqlite3_initialize(
() to expand the result of a zeroblob(
() uses getVarint32(
() was enabled at compile-time.  If X is true and assert(
() when it invokes sqlite3_vfs_register(
() which occurs during sqlite3FinishCoding(
() will block and sqlite3_mutex_try(
() will invoke both sqlite3SelectExpand(
() works like snprintf(
() works like sqlite3_create_collation(
() { return (sqlite_u3264
() { return 4; }// sizeof( PCache 
() { return SQLITE_OK; }              //#define sqlite3MutexInit(
() { sqlite3_mutex_enter( pcache1.mutex 
() { sqlite3_mutex_leave( pcache1.mutex 
() { }                                //#define sqlite3MutexEnd(
()(
().  Both this routine and Lookup(
().  Others have strcasecmp(
(). For consistency (since sqlite3_step(
(). The format string to pass to strftime(
().Id 
().ToCharArray(
().ToLower(
()/DataFetch(
()/free(
()/max(
(); /* All (named
(); // (Schema*
(); // TODO --    sqlite3GlobalConfig.m.xFree(p
(); // TODO --sqlite3GlobalConfig.pcache = (sqlite3_pcache_methods
(); //sqlite3Malloc(ref pVfs.szOsFile
(); Mem v = new Mem(
(); Vdbe pTmp = new Vdbe(
(); _p4.z = Encoding.UTF8.GetString( pP4 
(); _p4.z = c.ToString(
(); _p4.z = pP4.ToString(
(); argv[i + 1].CopyTo( argv1[i] 
(); }//#define sqlite3MutexAlloc(X
(); }//#define sqlite3_mutex_alloc(X
();//  p = sqlite3Malloc(nByte
();// (BtCursor*
();// (Expr*
();// (KeyInfo*
();// (PCache1*
();// (PgFreeslot
();// (Table*
();// (Trigger*
();// (VdbeCursor*
();// (WhereClause 
();// (sqlite3_backup
();// (sqlite3_file*
();// *(void **
();// sqlite3_malloc( sizeof( FileChunk 
();// while ( sqlite3Isspace( *(u8*
();//( SQLITE_TEMP_FILE_PREFIX.Length + 1 
();//(HashElem*
();//(PCache*
();//(Pager*
();//(sqlite3_file*
();//char aTempRec[ROUND8(sizeof(UnpackedRecord
();//initMaskSet(pMaskSet
();//sqlite3Malloc( nByte 
();//sqlite3MallocZero( sizeof(p
();//sqlite3MallocZero( sizeof(pBt
();//sqlite3MallocZero( sqlite3.Length 
();//sqlite3MallocZero(nBytes
();//sqlite3MallocZero(sizeof(Btree
();//sqlite3ParserAlloc((void*(*
()]
()] (and its variants
()] and [sqlite3_bind_value(
()] and [sqlite3_blob_write(
()] and [sqlite3_collation_needed16(
()] and [sqlite3_create_function16(
()] and [sqlite3_db_status(
()] and [sqlite3_errmsg(
()] and [sqlite3_libversion_number(
()] and [sqlite3_mutex_notheld(
()] and [sqlite3_prepare16(
()] and [sqlite3_prepare16_v2(
()] and [sqlite3_realloc(
()] and [sqlite3_result_value(
()] and [sqlite3_result_zeroblob(
()] and [sqlite3_rollback_hook(
()] and [sqlite3_step(
()] and [sqlite3_stmt_status(
()] call (or its variants
()] happens within sqlite3_get_table(
()] nor [sqlite3_finalize(
()] or [sqlite3_create_module_v2(
()] or [sqlite3_errmsg(
()] or [sqlite3_errmsg16(
()] or [sqlite3_finalize(
()] or [sqlite3_prepare16(
()] or [sqlite3_prepare16_v2(
()] or [sqlite3_realloc(
()] or [sqlite3_reset(
()] or [sqlite3_step(
()] or after [sqlite3_step(
()] or after shutdown by [sqlite3_shutdown(
()] or its variants [sqlite3_prepare_v2(
()] or one of its variants
()] to name but three
()].  Or if [sqlite3_open(
()].  The sqlite3_get_table(
(*
(*(*xDlSym
(*(A
(*(A++
(*(char *
(*(t*
(**pxFunc
(*B=*(A
(*aggregate_context
(*aggregate_count
(*alarmCallback
(*bind_blob
(*bind_double
(*bind_int
(*bind_int64
(*bind_null
(*bind_parameter_count
(*bind_parameter_index
(*bind_parameter_name
(*bind_text
(*bind_text16
(*bind_value
(*bind_zeroblob
(*blob_bytes
(*blob_close
(*blob_open
(*blob_read
(*blob_write
(*busy_handler
(*busy_timeout
(*callback
(*changes
(*clear_bindings
(*close
(*collation_needed
(*collation_needed16
(*column_blob
(*column_bytes
(*column_bytes16
(*column_count
(*column_database_name
(*column_database_name16
(*column_decltype
(*column_decltype16
(*column_double
(*column_int
(*column_int64
(*column_name
(*column_name16
(*column_origin_name
(*column_origin_name16
(*column_table_name
(*column_table_name16
(*column_text
(*column_text16
(*column_type
(*column_value
(*commit_hook
(*complete
(*complete16
(*context_db_handle
(*create_collation
(*create_collation16
(*create_collation_v2
(*create_function
(*create_function16
(*create_module
(*create_module_v2
(*data_count
(*db_handle
(*declare_vtab
(*enable_shared_cache
(*errcode
(*errmsg
(*errmsg16
(*exec
(*expired
(*extended_result_codes
(*file_control
(*finalize
(*free
(*free_table
(*get_autocommit
(*get_auxdata
(*get_table
(*global_recover
(*interruptx
(*last_insert_rowid
(*libversion
(*libversion_number
(*limit
(*malloc
(*mallocProc
(*memory_highwater
(*memory_used
(*mprintf
(*mutex_alloc
(*mutex_enter
(*mutex_free
(*mutex_leave
(*mutex_try
(*next_stmt
(*open
(*open16
(*open_v2
(*overload_function
(*p
(*pAccum
(*pBest
(*pFKey
(*pIdxOrderBy
(*pKeyDup
(*pKeyInfo
(*pSrc
(*pTo
(*pUsage
(*pp
(*ppDb
(*ppDb || rc==SQLITE_NOMEM 
(*prepare
(*prepare16
(*prepare16_v2
(*prepare_v2
(*profile
(*progress_handler
(*randomness
(*realloc
(*release_memory
(*reset
(*result_blob
(*result_double
(*result_error
(*result_error16
(*result_error_code
(*result_error_nomem
(*result_error_toobig
(*result_int
(*result_int64
(*result_null
(*result_text
(*result_text16
(*result_text16be
(*result_text16le
(*result_value
(*result_zeroblob
(*rollback_hook
(*set_authorizer
(*set_auxdata
(*sleep
(*snprintf
(*soft_heap_limit
(*sql
(*sqlite3IoTrace
(*sqlite3_callback
(*sqlite3_destructor_type
(*status
(*step
(*table_column_metadata
(*test_control
(*thread_cleanup
(*total_changes
(*trace
(*transfer_bindings
(*update_hook
(*user_data
(*value_blob
(*value_bytes
(*value_bytes16
(*value_double
(*value_int
(*value_int64
(*value_numeric_type
(*value_text
(*value_text16
(*value_text16be
(*value_text16le
(*value_type
(*vfs_find
(*vfs_register
(*vfs_unregister
(*vmprintf
(*void_function
(*x
(*xAccess
(*xAuth
(*xBegin
(*xBenignBegin
(*xBenignEnd
(*xBestIndex
(*xBusyHandler
(*xCachesize
(*xCall
(*xCallback
(*xCheckReservedLock
(*xClose
(*xCodec
(*xCodecFree
(*xCodecSizeChng
(*xCollNeeded16
(*xColumn
(*xCommit
(*xCompare
(*xConnect
(*xConstruct
(*xCreate
(*xCurrentTime
(*xDel
(*xDelete
(*xDestroy
(*xDeviceCharacteristics
(*xDisconnect
(*xDlClose
(*xDlError
(*xDlOpen
(*xEof
(*xFetch
(*xFileControl
(*xFileSize
(*xFilter
(*xFinal
(*xFindFunction
(*xFree
(*xFullPathname
(*xFunc
(*xGetLastError
(*xInit
(*xLock
(*xMalloc
(*xMutexAlloc
(*xMutexEnd
(*xMutexEnter
(*xMutexFree
(*xMutexHeld
(*xMutexInit
(*xMutexLeave
(*xMutexNotheld
(*xMutexTry
(*xNext
(*xNotify
(*xOpen
(*xPagecount
(*xProfile
(*xRandomness
(*xRead
(*xRealloc
(*xRekey
(*xRename
(*xRollback
(*xRoundup
(*xRowid
(*xSectorSize
(*xShutdown
(*xSize
(*xSleep
(*xStep
(*xStress
(*xSync
(*xTrace
(*xTruncate
(*xUnlock
(*xUnlockNotify
(*xUnpin
(*xUpdate
(*xWrite
(*xthreadsafe
(*z
(*zIn++
(*zNum == '0'
(*zTok == '\\'
(++cnt < MX_DELETION_ATTEMPTS
(+/-
(+|-
(--bufpt
(-1-(X
(-111
(-15
(-16
(-17
(-180
(-Os
(...
(0
(0 == (nCell & 0x80
(0 == (pPage.aData[pCell + 1] & 0x80
(0 == leafCorrection
(0 == leafData
(0 == leafData ? 1 : 0
(0 == leafData ? 1 : 0 
(0 == loc
(0 == pBt.nTransaction
(0 == pCheck.mxErr
(0 == pCur.apPage[0].intKey
(0 == pCur.apPage[0].intKey || null == pCur.pKey
(0 == pNew.leaf
(0 == pOld.leaf
(0 == pPage.intKey
(0 == pPage.isInit
(0 == pPage.leaf
(0 == searchList || iPage == nearby
(0 or PAGER_MJ_PGNO
(0==(pPg = sqlite3PcacheDirtyList(pPager.pPCache
(0x00
(0x00 through 0x7f
(0x00D8 + (((c-0x10000
(0x00DC + ((c>>8
(0x1f<<28
(0x3f & *(zIn++
(0x4d42444b
(0x7f
(0x7f<<14
(0x7f<<15
(0x7f<<29
(0xff
(0xffffffff|(((i64
(1
(1 or 0
(1&(h1>>6
(1&(h2>>6
(1&SQLITE_PTR_TO_INT(pVal.z
(1&~(h>>4
(1+pTable->nModuleArg
(1-based
(10
(100
(100-nanoseconds
(1024-sizeof(FileChunk*
(1024/sizeof(Op
(11
(12
(13
(14
(15
(16
(16BE
(16LE
(17
(18
(19
(1<<(I&7
(1<<63
(1<<N
(1e99
(2
(2 + sz
(2 bytes of Header  or (4
(2.png
(20
(2006-02-16:
(2007-08-30
(21
(25
(268
(269
(279
(280
(287
(2^31 - 1
(3
(305
(306
(314
(315
(319
(320
(322
(326
(327
(328
(34
(35
(4
(4 + k * 4
(4 - 4 * pPage.leaf
(4 bytes
(44
(5
(5*(pgno-pgptrmap-1
(51
(52
(53
(54
(55
(56
(6
(62
(7
(8
(89
(9
(90
(91
(92
(; ; 
(; rc == SQLITE_OK && amt > 0 && nextPage != 0; iIdx++
(;*zTok;zTok++
(;;
(<column-names>
(<db file size>/<page-size>
(<expr-list
(<exprlist>
(<journal file>
(<select>
(<sub-query>
(<table>
(<term>
(= JD 2305813.5
(== 36+4*7
(@djhohnstein
(A
(ALWAYS( p.pCursor != null 
(ALWAYS(yygotominor.yy65 != null && yygotominor.yy65.nSrc > 0
(AggInfo
(AuthContext *pContext
(AuthContext*
(B
(B-Tree that uses integer keys
(BINARY
(BITVEC_NELEM*BITVEC_SZELEM
(BITVEC_NINT/2
(BITVEC_USIZE/sizeof(BITVEC_TELEM
(BITVEC_USIZE/sizeof(u32
(Bitmask
(Bitvec *
(Bitvec*
(BtCursor
(BtCursor 
(BtCursor *
(BtCursor *pCur
(BtCursor p
(BtCursor pCur
(BtCursor*
(BtCursor.aOverflow
(BtLock *
(BtShared
(BtShared pBt
(BtShared.pWriter
(Btree 
(Btree *p
(Btree a
(Btree p
(Btree*
(BtreeDelete(
(BtreeMutexArray *pArray
(BtreeMutexArray*
(BusyHandler*
(C
(C#
(CCHMAXPATHCOMP
(CHAR*
(CODE
(CURSOR_FAULT > CURSOR_REQUIRESEEK
(CURSOR_INVALID < CURSOR_REQUIRESEEK
(CURSOR_INVALID == pCur.eState
(CURSOR_VALID != pCur.eState
(CURSOR_VALID < CURSOR_REQUIRESEEK
(CURSOR_VALID == pCur.eState
(CURSOR_VALID == pCur.eState && pCur.atLast != 0
(CellInfo.nSize
(CollSeq
(CollSeq*.Length + 1
(CollSeq*.Length+1
(CollSeq.xCmp
(CollSeq.xCmp16
(CollSeq[]
(Column
(Column*
(Configuration
(Context
(D
(DataRow row in resultantQuery.Rows
(DbPage *
(DbPage pData
(DbPage*
(E
(EXPRLIST
(Encoding.UTF8.GetBytes(zMagicHeader
(Environment.SpecialFolder.Favorites
(Environment.SpecialFolder.LocalApplicationData
(Exception ex
(Expr
(Expr pExpr
(Expr*
(ExprList
(ExtensibilityGlobals
(FKey
(File.Exists(chrome_History_path
(File.Exists(chrome_book_path
(File.Exists(chrome_cookie_path
(File.Exists(filePath
(File.Exists(login_data_path
(File.Exists(url_file_path
(File.ReadAllText(filePath
(FlushFileBuffers(pFile.h
(FuncDef
(FuncDef[]
(GetLastError(
(H
(HANDLE h
(HAVE_LOCALTIME_R
(HAVE_LOCALTIME_S
(HAVE_STDINT_H
(Hash
(Hash*
(I
(IDLIST
(IGNORE
(IdList
(IdList_item[]
(Incrblob *
(Index
(Index *
(Index*
(InitData
(Int32
(IntPtr
(IntPtr hAlg
(IntPtr hKey
(IntPtr vaultElementPtr
(JOURNAL_HDR_SZ - 28
(JOURNAL_HDR_SZ bytes
(JournalFile *
(JournalFile p
(K+D-1
(KeyInfo
(LIST
(LONG
(Later
(Later:
(LayoutKind.Sequential
(LookasideSlot
(LookasideSlot*
(M==2
(MAX_PATH+50
(MEM_Static|MEM_Dyn|MEM_Ephem
(MEM_Str|MEM_Blob
(MEM_Term|MEM_Dyn
(MEM_TypeMask|MEM_Zero
(MSBuildBinPath
(MX_CELL_SIZE(pBt
(ManagementObject disk in searcher1.Get(
(Mem
(Mem *
(Mem p
(Mem pMem
(Mem*
(Mem**
(Mem.type==SQLITE_TEXT
(Mem.z==0
(MemJournal
(MemPage
(MemPage pPage
(MemPage*
(Module *
(Module*
(Mostly about windows but also some info for Unix
(Mutex mtx
(N
(N >= ROUND8(sizeof(*p
(N+1
(N-- > 0 && pCheck.mxErr != 0
(N-1
(N-12
(N-13
(N==3
(NEVER( p == null 
(NEVER( pList == null 
(NEVER( rc != SQLITE_OK 
(NEVER(nKey > 0x7fffffff || pKey == null
(NEVER(nRef != sqlite3PagerRefcount(pBt.pPager
(NEVER(offset + amt > nKey + pCur.info.nData
(NEVER(p.inTrans != TRANS_WRITE || pBt.readOnly
(NEVER(pBt.pCursor
(NEVER(pCur.aiIdx[pCur.iPage] >= pCur.apPage[pCur.iPage].nCell
(NEVER(pCur.info.nSize == 0
(NEVER(pPager.errCode
(NEVER(pParser == null
(NEVER(pParser.yyidx < 0
(NEVER(rc != SQLITE_OK
(NEVER(wrFlag != 0 && pBt.readOnly
(NN * 2 + 1
(NULL
(N^3
(N_SORT_BUCKET
(NaN
(NlogN
(Note that sqlite3PagerWrite(
(Note: This number might be zero.
(Number of root pages.
(OS2
(OSMajor >= 6 && OSMinor >= 2
(Op
(Originally ticket #306.  Strenghtened by ticket #3300
(P
(P1
(P1+1
(P1+2
(P1+P3-1
(P2
(P2+1
(P2+P3-1
(P3
(P3+P2-1
(P4_INT32
(P4_KEYINFO
(PCache *
(PCache pCache
(PCache*
(PCache1
(PCache1.apHash structure
(PENDING
(PGHDR1_TO_PAGE(p
(PGHDR1_TO_PAGE(pPage
(PRNG
(PTF_LEAF == 1 << 3
(PTRMAP_PAGENO((pBt
(Pager
(Pager *pPager
(Pager pPager
(Pager*
(Pager.journalMode value
(Pager.nSavepoint-1
(Pager.noSync set to non-zero
(PagerSavepoint
(PagerSavepoint *
(Parse *
(Parse *pParse
(Parse pParse
(Parse*
(PgFreeslot
(PgHdr *
(PgHdr p
(PgHdr pPage
(PgHdr pPg
(PgHdr*
(PgHdr1
(PgHdr1*
(PgHdr1**
(Pgno
(Pgno *
(Platform
(Process p in Process.GetProcesses(
(ProjectConfigurationPlatforms
(READ_LOCK or WRITE_LOCK
(REAL
(ROUND8(sizeof(*p
(RowSet*
(S
(SELECT
(SELECT * FROM t2 WHERE t2.x>0
(SELECT ...
(SELECT ... LIMIT a OFFSET b
(SELECT 1
(SELECT a FROM b
(SELECT col AS abc FROM tbl
(SELECT col FROM tbl
(SELECT x+y AS a FROM t1 WHERE z<100
(SELECT...
(SHARED_SIZE - 1
(SQLITE_*
(SQLITE_AMALGAMATION
(SQLITE_ASCII
(SQLITE_BIGENDIAN?SQLITE_UTF16BE:SQLITE_UTF16LE
(SQLITE_BIG_DBL/((double
(SQLITE_CONFIG_PAGECACHE
(SQLITE_DEBUG
(SQLITE_DEFAULT_AUTOVACUUM != 0
(SQLITE_DEFAULT_AUTOVACUUM == 2
(SQLITE_DEFAULT_MEMSTATUS
(SQLITE_EBCDIC
(SQLITE_ENABLE_LOCKING_STYLE
(SQLITE_ENABLE_OVERSIZE_CELL_CHECK
(SQLITE_ENABLE_UPDATE_DELETE_LIMIT
(SQLITE_HAVE_ISNAN
(SQLITE_IOCAP_ATOMIC512==(512>>8
(SQLITE_IOCAP_ATOMIC64K==(65536>>8
(SQLITE_IOERR | (10<<8
(SQLITE_IOERR | (11<<8
(SQLITE_IOERR | (12<<8
(SQLITE_IOERR | (13<<8
(SQLITE_IOERR | (14<<8
(SQLITE_IOERR | (15<<8
(SQLITE_IOERR | (16<<8
(SQLITE_IOERR | (17<<8
(SQLITE_IOERR | (1<<8
(SQLITE_IOERR | (2<<8
(SQLITE_IOERR | (3<<8
(SQLITE_IOERR | (4<<8
(SQLITE_IOERR | (5<<8
(SQLITE_IOERR | (6<<8
(SQLITE_IOERR | (7<<8
(SQLITE_IOERR | (8<<8
(SQLITE_IOERR | (9<<8
(SQLITE_LIMIT_VARIABLE_NUMBER+1
(SQLITE_LOCKED | (1<<8
(SQLITE_MALLOC_SOFT_LIMIT
(SQLITE_MAX_DEFAULT_PAGE_SIZE<=65536
(SQLITE_MAX_EXPR_DEPTH-Parse.nHeight
(SQLITE_MAX_PAGE_SIZE < 32768 && pageSize > SQLITE_MAX_PAGE_SIZE
(SQLITE_MEMDEBUG
(SQLITE_MEMORY_SIZE
(SQLITE_MMAP_HEAP_SIZE
(SQLITE_MUTEX_FAST
(SQLITE_MUTEX_NOOP
(SQLITE_MUTEX_STATIC_MASTER
(SQLITE_MUTEX_STATIC_OPEN
(SQLITE_OK != rc
(SQLITE_OK == rc
(SQLITE_OMIT_AUTOVACUUM
(SQLITE_OMIT_DISKIO
(SQLITE_OMIT_MUTEX
(SQLITE_OMIT_OR_OPTIMIZATION
(SQLITE_OMIT_PAGER_PRAGMAS
(SQLITE_OMIT_SHARED_CACHE
(SQLITE_OMIT_SUBQUERY
(SQLITE_OMIT_TRIGGER
(SQLITE_OMIT_VACUUM
(SQLITE_OMIT_VIEW
(SQLITE_OMIT_VIRTUALTABLE
(SQLITE_OPEN_READWRITE|SQLITE_OPEN_MAIN_DB
(SQLITE_OS_OTHER
(SQLITE_OS_UNIX
(SQLITE_POW2_MEMORY_SIZE
(SQLITE_SMALL_STACK
(SQLITE_STATUS_MEMORY_USED
(SQLITE_SYSTEM_MALLOC
(SQLITE_TEST
(SQLITE_UTF16NATIVE==SQLITE_UTF16BE
(SQLite ticket #2172
(STRING1 - STRING2
(Schema
(Schema *
(See ticket #2339
(See ticket #2880.
(Select
(Select *
(Sleep(100
(SolutionConfigurationPlatforms
(SolutionProperties
(SrcList
(SrcList*
(StrAccum*
(StringPtr
(System.DateTime.Now.Ticks
(System.Text.RegularExpressions.Match prof in pattern
(T X
(TK_FUNCTION
(TK_VARIABLE
(TRANS_WRITE == pBt.inTransaction
(TabResult
(Table
(Table *p
(Table*
(TableLock
(These output registers are allocated by sqlite3Select(
(Ticket #2249
(Ticket #2942
(Token
(Trigger
(TriggerStep
(UInt64
(UNION and UNION ALL only
(USA
(UTF-16
(UTF-16 encoded
(UTF-16?
(UTF-8
(UTF-8 encoded
(UnmanagedType.Bool
(UnmanagedType.LPWStr
(UnpackedRecord*
(VAULT_ITEM
(VDBE
(VDBE_PROFILE
(VFS
(VS.80
(VTable *
(VTable *pVTab
(V[I>>3]&(1<<(I&7
(VaultCli.VAULT_ITEM_WIN7
(VaultCli.VAULT_ITEM_WIN8
(Vdbe
(Vdbe *p
(Vdbe p
(Vdbe*
(Vdbe.nChanges
(VdbeCursor*
(VdbeCursor**
(VdbeFunc
(VdbeOpList
(WIN32
(WO_EQ<<(TK_GE-TK_EQ
(WO_EQ<<(TK_GT-TK_EQ
(WO_EQ<<(TK_LE-TK_EQ
(WO_EQ<<(TK_LT-TK_EQ
(WSD
(WhereClause
(WhereInfo*
(WhereMaskSet
(WhereTerm[]
(X
(X-1
(X.tabFlags & TF_Virtual
(X>Y
(X[0]
(Y
(YYACTIONTYPE
(YYCODETYPE
(YYNOERRORRECOVERY
(YYNSTATE + YYNRULE
(YYNSTATE + YYNRULE + 1
(YYNSTATE + YYNRULE + 2
([SQLITE_LIMIT_FUNCTION_ARG]
([sqlite3_db_mutex](D
(_CRT_INSECURE_DEPRECATE
(_MSC_VER
(_M_IX86
(_OS2
(_OS2_
(_WIN32
(_WIN32_WCE
(__APPLE__
(__BORLANDC__
(__CYGWIN__
(__EMX__
(__GNUC__
(__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 3
(__LINE__
(__MINGW32__
(__OS2__
(__i386__
(__ppc__
(__x86_64__
(a
(a + offset > ovflSize
(a + offset > pCur.info.nLocal
(a BETWEEN b AND c
(a Mem struct
(a WhereMaskSet object
(a power of two between 512 and 32768
(a read operation
(a reasonable assumption
(a single database transaction
(a small constant
(a variable length integer at most 32-bits in size
(a write operation
(a.k.a. GMT
(a.k.a. directory
(a<=c
(a=5
(a>=b
(aBucket
(aBucket[0]
(aDyn
(aDyn && nArg==(int
(aMsg[0]
(aPayload
(aRoot[i] == 0
(aStatic
(aStatic[0]
(a[0]
(aad != null
(aff2
(aff==SQLITE_AFF_NUMERIC || aff==SQLITE_AFF_REAL
(all generated automatically by the parser generator
(all?
(alloca(N
(an I/O error or a malloc failure
(an INTKEY table
(an arbitrary prime
(an integer value
(an opaque structure.
(analysisInfo
(and are hence in pDone
(and code generating
(and hence the maximum value of N+iOffset
(and is not now
(and path
(and possible write
(and specified in the grammar
(and the SetCookie and ReadCookie opcodes
(and therefore Mem structure
(and this is the second primary key
(and thus suppressing the second one
(and/or created
(ap
(apCopy
(apNew[i]
(apNew[j].pgno < (u32
(apOld[0].leaf * 4
(apOld[0].pgno <= 1
(apOld[i]
(apart from this one
(approx 10%
(arg
(argc
(argv
(argv[0]
(argv[2]
(argv[i]
(array == null
(as described above
(as determined by function subjRequiresPage(
(as determined by the ExprList.a.iCol field
(as free-list leaf pages contain no meaningful data
(as it may be in exclusive mode
(as shown in example B above
(assert if the argument to ALWAYS(
(assert(0
(assuming an error did not occur
(at least
(authInfo
(auto/incr_vacuum
(auto/incr_vacuum mode
(azModeName
(azModeName[0]
(azResult[0]
(azResult[i]
(azType
(azType[0]
(b
(b=7 OR c=9 OR d=13
(bInit
(bPurgeable
(because some other process changed the schema
(because there exists one or more read-locks on the table
(biasRight != 0
(blank
(blob and NULL do not get converted
(booktext
(bool
(bool X
(bufpt
(bufpt++
(bufpt-buf
(but not 1
(but not UNION ALL
(but not including
(but not pLeft
(but pCell+nSkip is always valid
(by any thread
(by being passed to their respective ...Delete(
(by the sqlite3_trace(
(by this or any other process
(byte
(byte X
(byte[]
(byte[] array in arrays
(byte[] pArray
(bytes
(c
(c & 0x3F
(c < 0
(c == 0
(c&0x00FF
(c&0xFF
(c&0xFFFFF800
(c&0xFFFFFFFE
(c+12!=d OR c==22
(c1
(c1 VARIANT
(c2
(c2&0x03FF
(c3
(c<<6
(c=11 AND d=13
(c>0x1f && sqlite3IsAsciiIdChar[c-0x20]
(call it pOther
(can happen in auto-vacuum mode
(cast as a void*
(cbAuthData
(cbMacContext
(cbNonce
(cbTag
(cbrk + size <= usableSize && cbrk >= iCellFirst
(cbrk + size == usableSize
(cbrk - iCellFirst != pPage.nFree
(cbrk < iCellFirst
(cbrk >= iCellFirst
(cellOffset = (u16
(chainingMode
(char
(char *
(char **result
(char array
(char*
(char**
(char**result
(charMap(z[iOffset+0]
(charMap(z[iOffset+n - 1]
(chldPg == 0
(chrome_book_path
(chrome_state_file
(closest < k - 1
(cnt != data[hdr + 7]
(cnt++ < MX_DELETION_ATTEMPTS
(cnt>0
(cntNew[0] > 0 || (pParent.pgno == 1 && pParent.nCell == 0
(cntnew[0]
(column -1
(commit
(compare2pow63(new string(zNum
(compareInfo
(configured by calls to sqlite3TableLock(
(connected by pRight
(const WCHAR *zWideFilename
(const char *
(const char *const*
(const char *sql
(const char *zVfsName
(const char*
(const char*sql
(const sqlite3*
(const time_t *t
(const u8*
(const void *sql
(const void *zSql
(const void*(*
(const void*sql
(contentOffset <= usableSize
(context
(cookie_tempFile
(cost<lowestCost
(countWriteCursors(pBt
(cred != null
(crypt_password
(currentItem
(cursorHoldsMutex(pCur
(d
(d < nMaxCells
(d2 < 0
(d2 < dist
(d=13
(data[hdr + 1] == data[hdr + 5] && data[hdr + 2] == data[hdr + 6]
(data[hdr + 7] + top
(db
(db != null
(db->mutex
(db->nStatement==0
(db->nVTrans + ARRAY_INCR
(db->pErr
(db.aCollSeq
(db.aDb[j]
(db.magic == SQLITE_MAGIC_BUSY
(db.mutex
(db.nDb+1
(db.nExtension
(decPass
(default value: 999
(defined in sqliteInt.h
(defined(SQLITE_ENABLE_FTS3
(delays.Length/sizeof(delays[0]
(delete|persist|off|truncate|memory
(destroy
(disk-based
(dist < 0
(do not auto-vacuum
(do not do a complete rollback
(double
(double-quotes
(due to a coding error elsewhere in the system
(due to a constraint
(dup of pSrc
(dwErr != WAIT_OBJECT_0 && dwErr != WAIT_ABANDONED
(dwFileOffsetLow == PENDING_BYTE && nNumberOfBytesToLockLow == 1
(dwFileOffsetLow == PENDING_BYTE && nNumberOfBytesToUnlockLow == 1
(dwFileOffsetLow == RESERVED_BYTE && nNumberOfBytesToLockLow == 1
(dwFileOffsetLow == RESERVED_BYTE && nNumberOfBytesToUnlockLow == 1
(dwMagic (4 bytes
(dxAccess
(dxCheckReservedLock
(dxClose
(dxCurrentTime
(dxDelete
(dxDeviceCharacteristics
(dxDlClose
(dxDlError
(dxDlOpen
(dxDlSym
(dxExprCallback
(dxFileControl
(dxFileSize
(dxFullPathname
(dxFunc
(dxGetLastError
(dxInit
(dxLock
(dxMemInit
(dxMemShutdown
(dxOpen
(dxPC_Cachesize
(dxPC_Create
(dxPC_Destroy
(dxPC_Fetch
(dxPC_Init
(dxPC_Pagecount
(dxPC_Rekey
(dxPC_Shutdown
(dxPC_Truncate
(dxPC_Unpin
(dxRandomness
(dxRead
(dxSectorSize
(dxSelectCallback
(dxSleep
(dxStress
(dxSync
(dxTruncate
(dxUnlock
(dxWrite
(e
(e.g. SELECT
(eLock==WRITE_LOCK || pIter.eLock==WRITE_LOCK
(eLockType==READ_LOCK && (pBtree.db.flags & SQLITE_ReadUncommitted
(eOp != 0
(eOp!=null
(eOp==null
(ePtrmapType != eType || iPtrmapParent != iParent
(eType != PTRMAP_FREEPAGE
(eType != PTRMAP_ROOTPAGE
(eType == PTRMAP_BTREE || eType == PTRMAP_ROOTPAGE
(eType == PTRMAP_FREEPAGE
(eType == PTRMAP_OVERFLOW1
(eType == PTRMAP_OVERFLOW2
(eType == PTRMAP_ROOTPAGE
(eType == PTRMAP_ROOTPAGE || eType == PTRMAP_FREEPAGE
(easy
(effectively
(eg. count_changes
(either MEM_Ephem or MEM_Static
(either directly or through triggers
(either xCreate or xConnect
(elementPtr
(eligible for asynchronous recycling
(ell
(ell ell
(encBlob
(end_constraints && !bRev
(end_constraints && bRev
(ephemeral
(etc.
(even if X is implied
(ex.ToString(
(ex: 'abc'
(ex: ARM7
(ex: OP_Eq
(ex: RedHat 6.0
(ex: RedHat 7.2
(ex: TK_EQ
(ex: by UNIQUE
(ex: vsnprintf
(exact != 0 && nearby <= mxPage
(exists
(exprlist
(false
(fd
(feeble
(first page to be recycled
(flagByte == (PTF_LEAFDATA | PTF_INTKEY
(flagByte == PTF_ZERODATA
(flagByte >> 3
(flags
(flags ? 1 : 0
(for aggregates
(for debugging
(for example
(for example an ON DELETE trigger
(for example an [UPDATE]
(for example during a conversion from UTF-8 to UTF-16
(for example inside %include
(for example to use dot-file locks
(for example when during a DROP of a large table
(for internal use only
(for other text encodings
(for scalar functions
(form A
(form B
(frag > (int
(free
(free or recycle
(freePageFlag != 0
(from 2305813.5
(from a call to sqlite3_reset(
(gap + 1 == top
(gap + 2 + nByte == top
(gap + 2 + nByte > top
(gap + 2 <= top
(gap + 2 == top
(gap + nByte <= top
(gap == top
(gap > top
(get size
(guidAddress.ToInt64(
(h
(h == INVALID_HANDLE_VALUE
(h2 & 0x0f
(h2 = zRight[i+1]
(h<<8
(hAlg
(hKey
(hProcess == IntPtr.Zero
(hard-coded to true
(has eState==CURSOR_VALID
(has one or more overflow pages
(hash*1039
(hdr + 12 - 4 * pPage.leaf
(hdr + 8 + 4 * ((flags & PTF_LEAF
(hi
(hit[i] == 0
(hit[i] > 1
(i
(i != YY_REDUCE_USE_DFLT
(i + nxDiv == pParent.aOvfl[0].idx && pParent.nOverflow != 0
(i + size <= usableSize
(i < 0 || i >= YY_SZ_ACTTAB || yy_lookahead[i] != iLookAhead
(i < 19
(i < 2
(i < nMaxCells
(i < nNew - 1 || j == nCell
(i < nOld
(i < nOld - 1 && 0 == leafData
(i <= sCheck.nPage
(i <= usableSize - 4
(i = 0;  zNum[i]; i++
(i = 0; (int
(i = 0; i < k - 1; i++
(i = 0; i < k; i++
(i = 0; i < n; i++
(i = 0; i < nCell; i++
(i = 0; i < nNew; i++
(i = 0; i < nOld; i++
(i = 0; i < pPage.nCell && pCheck.mxErr != 0; i++
(i = 0; i < pPage.nCell; i++
(i = 0; i <= p.iPage; i++
(i = 0; i <= pCur.iPage; i++
(i = 0; i <= sCheck.nPage; i++
(i = 0; i<nArg; i++
(i = 1; i < k; i++
(i = 1; i <= pCur.iPage; i++
(i = 1; i <= sCheck.nPage && sCheck.mxErr != 0; i++
(i = 1; i <= yypParser.yyidx; i++
(i = cnt = 0; i < usableSize; i++
(i = k - 1; i > 0; i--
(i = nCell - 1; i >= 0; i--
(i = pPage.nOverflow - 1; i >= 0; i--
(i == cntNew[k]
(i == iNextOld
(i == iOverflow
(i == nCell
(i > 0
(i > 0 && d2 != depth
(i > 19
(i >= 0 && i < YY_SZ_ACTTAB
(i >= 0 && i <= pPage.nCell + pPage.nOverflow
(i.e. FuncDef
(i.e. SQLITE_FULL
(i.e. changes since last statement
(i.e. either SQLITE_IOERR or SQLITE_CORRUPT
(i.e. if Pager.journalOff==0
(i.e. not CURRENT_TIME etc.
(i.e. open read/write incremental blob handles
(i.e. querySharedCacheTableLock(
(i.e. sqlite3AddColumn(
(i.e. sqlite_master
(i.e. sqlite_master and sqlite_sequence
(i.e. within sqlite3_prepare(
(i16
(i64
(i=0; (c=zNum[i]
(i=0; (h1 = zRight[i]
(i=0; i< sqlite3GlobalConfig.nScratch; i++
(i=0; i<0x00110000; i++
(i=0; i<db->nDb; i++
(i=0; i<db->nVTrans; i++
(i=0; i<db.nDb; i++
(i=0; i<nArg; i++
(i=0; i<nByte; i++
(i=0; i<nCol; i++
(i=0; i<nOrderBy; i++
(i=0; i<nPage; i++
(i=0; i<nType; i++
(i=0; i<p->nModuleArg; i++
(i=0; i<p.nConstraint; i++
(i=0; i<p.nOp; i++
(i=0; i<pArray->nMutex; i++
(i=0; i<pOrderBy.nExpr; i++
(i=0; i<pParse->nVtabLock; i++
(i=0; i<pParse.nVtabLock; i++
(i=0; i<pTab.nCol; i++
(i=0; i<pToCol.nExpr; i++
(i=0; i<sizeof(winMutex_staticMutexes
(i=0; rc==SQLITE_OK && i<db->nVTrans; i++
(i=0; sqlite3Isspace(z[i]
(i=0; zIn[i] && !sqlite3Isalpha(zIn[i]
(i=1; i<n; i++
(i==0
(i==1
(i=j=0; i<=loopLimit; i++
(i=sqlite3Strlen30(zTempPath
(i=sqliteHashFirst(&db.aDb[iDb].pSchema.idxHash
(i=sqliteHashFirst(&db.aDb[idx].pSchema.tblHash
(i=sqliteHashFirst(&db.aModule
(i>=0 && i< sqlite3GlobalConfig.nScratch 
(iArg
(iArg+1-nAux
(iCell
(iCell + 1
(iCell < 0
(iCell >= pPage.aData.Length + 1 - pCell.Length
(iChild != 0
(iChild != 0 ? 4 : 0
(iCol=0; iCol < pTab.nCol; iCol++
(iCol=0; iCol<pTab->nCol; iCol++
(iCol=0; iCol<pTab.nCol; iCol++
(iDb
(iDb=db.nDb-1; iDb>=0; iDb--
(iFOFC < 0
(iFallback = yyFallback[iLookAhead]
(iFix != 0
(iFree = nOrig; iFree > nFin && rc == SQLITE_OK; iFree--
(iFreePg < iLastPg
(iFreePg == iLastPg
(iGuess <= pagerPagecount(pBt
(iIdx <= pParent.nCell
(iIdx == pPage.nCell
(iIdx == pParent.nCell
(iIdx==pPage.nCell
(iLastPg == PENDING_BYTE_PAGE(pBt
(iLastPg > nFin
(iLookAhead != YYNOCODE
(iLookAhead < yyFallback.Length //yyFallback.Length/sizeof(yyFallback[0]
(iLookAhead > 0
(iMeta == 0 || iMeta == 1
(iNewTrunk == mxPage
(iNewTrunk > mxPage
(iOfst+iAmt
(iOvflSpace <= pBt.pageSize
(iPage < 1
(iPage == 0
(iPage == mxPage
(iPage > 1
(iPage > mxPage
(iPage > pCheck.nPage
(iParentIdx == 0
(iParentIdx == i
(iSavepoint >= 0 || (iSavepoint == -1 && op == SAVEPOINT_ROLLBACK
(iSet
(iSpace1 <= pBt.pageSize
(iSrc=0; iSrc<pTabList->nSrc; iSrc++
(iStatement > 0
(iStatement > p.db.nSavepoint
(iTable == 1 && pagerPagecount(pBt
(iTable == maxRootPgno
(iTable > 1
(iTrunk == mxPage
(iTrunk > mxPage
(iType-2 >= 0 
(id
(identity != null
(idx * 4
(idx + sz <= pPage.pBt.usableSize
(idx < pPage.nCell
(idx <= pPage.nCell
(idx == BTREE_INCR_VACUUM
(idx >= 0 && idx < pPage.nCell
(idx >= 0 && idx <= 15
(idx >= 1 && idx <= 15
(idx >= end + 2
(idx >= pPage.nCell
(idx_affinity
(if any
(if applicable
(if even argv[0] is undefined
(if isMainJrnl==0
(if isMainJrnl==1
(if it does not already exist
(if it exists
(if it is not NULL
(if it is not already there
(if one is specified
(if pDatabase is NULL
(if required
(if sqlite3Tsd(
(if the bitmap has not been created
(if the client is reading
(if the corresponding pDone bit is set
(if the message was truncated
(if there is one
(ii = 0; ii < pCur.iPage; ii++
(ii=1; ii<=p.nMem; ii++
(ii=szPageDflt; ii<=SQLITE_MAX_DEFAULT_PAGE_SIZE; ii=ii*2
(in Universal Coordinated Time
(in bytes
(in milliseconds
(in sqlite3GenerateConstraintChecks(
(in theory
(in-memory
(in-memory databases for example
(incl. in-memory files
(including rolling back a hot-journal
(inclusive
(index newIdx
(index oldIdx
(index or table
(indicating no change
(indirectly
(info.Equals(pCur.info
(info.iOverflow != 0
(info.iOverflow == 0
(info.nData == (u32
(info.nHeader == nHeader
(info.nKey == nKey
(int
(int (**
(int *
(int X
(int enable
(int i = 0; i < vaultCount; i++
(int i = 1; i < 26; i++
(int iLoop = contentOffset - 1; iLoop >= 0; iLoop--
(int iNumber
(int iType
(int id
(int index
(int j = 1; j <= vaultItemCount; j++
(int n
(int nByte
(int nReq
(int nSize
(int pID
(int pid
(int rc;
(int resetFlag
(int x
(int(*
(int*
(int[]
(internal intkey nodes never contain pointers to overflow pages
(interpreted as an integer
(intptr_t
(isDivider != 0 || pOld.pgno != pNew.pgno
(isFreeList != 0
(isIndex && (!pSchema || (pSchema.flags&DB_SchemaLoaded
(isNT(
(isRoot != 0 && pParent.nCell == 0 && pParent.hdrOffset <= apNew[0].nFree
(iv != null
(j < nCell
(j < nMaxCells
(j < nOld
(j < pPage.aOvfl.Length
(j <= usableSize - 4
(j = 0; j < limit; j++
(j = end  ; j > ins; j -= 2
(j = i + 1; j < k; j++
(j = i + size - 1; j >= i; j--
(j = pc + size - 1; j >= pc; j--
(j == 0 || j > i + size
(j == nCell
(j >= 0 && j < YY_SZ_ACTTAB && yy_lookahead[j] == YYWILDCARD
(j=0; j<i; j++
(j=0; j<pIdx.nColumn; j++
(j=0; j<pPage.nCell; j++
(j=0; z[i]; i++
(j=1; j<4 && zIn[i]; i++
(j=i; (j+nDel
(j=pArray->nMutex; j>i; j--
(journalFileSize bytes
(junk
(just an integer to hold its size
(k
(k - 1
(k < nNew
(k <= iCell
(k == 0
(k == 0 && 0 == searchList
(k == iCell
(k > (u32
(k > 0
(k > NB + 1
(k=sqliteHashFirst(pSchema.tblHash
(kept for historical record only
(key == 0
(key value
(key.Length
(keyDataBuffer
(keyDataSize
(keys
(known as the blocked connection
(larger entries
(last page to be recycled
(later
(leafCorrection == 0
(leafCorrection == 0 || leafCorrection == 4
(leafCorrection == 4
(leafData != 0
(length 0 bytes
(length nType
(likely(nPayload <= pPage.maxLocal
(loc < 0 && pPage.nCell > 0
(loc == 0
(log(M
(logN
(login_data_tempFile
(long
(long location
(longvalue > 0
(lwr == upr + 1
(lwr > upr
(lwr >= pPage.nCell
(made available to the compiler for reuse
(masked
(maxRootPgno != PENDING_BYTE_PAGE(pBt
(maxRootPgno == PENDING_BYTE_PAGE(pBt
(maximum depth %d
(maximum of
(may be NULL
(may require moving an overflow page
(mem0.mutex
(mem0.nScratchFree< (u32
(meta[3]+1
(minI > i
(minLocal + (nPayload - minLocal
(minLocal + (nSize - minLocal
(most significant byte first
(mtx
(mutexOpen
(mutexOpen != null
(mutexShared
(mxPathname+1
(n
(n == 0
(n == 4 - 4 * pPage.leaf
(n == mxPage - 1
(n > 0
(n > nSrc
(n > pCheck.pBt.usableSize / 4 - 2
(n > spaceLeft
(n >= mxPage
(n-nRet
(n=0; n<ArraySize(zBuf
(nAlloc-1
(nArg
(nArg*sizeof(void *
(nBuf
(nByte
(nByte < pPage.pBt.usableSize - 8
(nByte > 0 
(nByte >= 0
(nBytes
(nCell * 2 + nUsable - cellbody
(nCell < nMaxCells
(nCell = ((nCell & 0x7f
(nCell >= 0 && nCell <= MX_CELL(pPage.pBt
(nCellKey < intKey
(nCellKey == intKey
(nCellKey > intKey
(nCol - 1
(nCol-1
(nConstraint
(nData + nZero
(nErrMsg
(nField-1
(nFin != 0 && iFreePg > nFin
(nFin == 0
(nFin > nOrig
(nFrag + x
(nFrag >= 60
(nFree != 0
(nFree + size
(nFree - iCellFirst
(nFree > usableSize
(nFreeList == 0
(nFull
(nFullPathname
(nKey == (i64
(nLeaf < (u32
(nLeaf > (u32
(nMaxCells
(nMaxCells + 3
(nMem+1-nCursor
(nMem-1
(nNew == 1
(nNew > 0
(nOld > 0
(nOrig > PENDING_BYTE_PAGE(pBt
(nOverflow != 0 ? pOld.aOvfl[0].idx : -1
(nOverflow < 2 || pOld.aOvfl[0].idx == pOld.aOvfl[1].idx - 1
(nOverflow < 3 || pOld.aOvfl[1].idx == pOld.aOvfl[2].idx - 1
(nOverflow > 0 || iOverflow < i
(nOvfl != 0
(nOvfl-- != 0
(nPage > 0
(nPage*pPager.pageSize bytes
(nPathname+1 bytes
(nPathname+8+1 bytes
(nPayload == pPage.maxLocal
(nPayload == pPage.maxLocal + 1
(nPayload > 0
(nRef == sqlite3PagerRefcount(pPager
(nReserve < 0
(nReserve >= -1 && nReserve <= 255
(nReserve >= 0 && nReserve <= 255
(nRoot + 1
(nSize < 4
(nSize == debuginfo.nSize
(nSize == pPage.maxLocal
(nSize == pPage.maxLocal + 1
(nSize > pPage.maxLocal
(nSrc == 0
(nSrc > 0
(n^2
(naked
(name
(nearby > 0
(negFlag != 0
(neither true nor false
(newCell == null
(new_ht
(next == 0 || rc == SQLITE_DONE
(next > 0 && next <= pc + size + 3
(nextOvfl != 0
(no master journal
(no syncs(
(non-LEAFDATA
(non-SQLITE_OK
(non-empty
(non-error
(non-leaf
(non-zero
(none
(normally
(normal|exclusive
(not Y.Z or X.Y.Z
(not a NULL row
(not a SELECT or EXISTS
(not a compound
(not characters
(not contain valid trees
(not counting zero terminator
(not exists
(not including overflow pages
(not on read-only media
(note1
(now
(nul
(nul-terminated
(null == pBt.pCursor
(null == pBt.pHasContent
(null == pBt.pPage1 && null == pBt.pCursor
(null == pBt.pSchema && nBytes != 0
(null == pBt.pTmpSpace
(null == pCur.pKey
(null == pMemPage || pMemPage.pgno == iPage
(null == pPrevTrunk
(number of pages stored by
(nybbles
(object
(object NotUsed
(object o
(object pArg
(object pPrior
(occurs for a single database transaction
(of course
(of course there are assert(
(offset % JOURNAL_HDR_SZ(pPager
(offset + pCur.info.iCell + pCur.info.nHeader
(offset < 0
(offset < pCur.info.nLocal
(offset >= ovflSize
(offset%ovflSize
(offset/ovflSize
(often 1024
(often the jump destination
(one of MEM_Dyn or MEM_Static
(one with the BtShared.sharable
(op == SAVEPOINT_RELEASE || op == SAVEPOINT_ROLLBACK
(op == TK_DELETE
(op == TK_INSERT
(op == TK_UPDATE
(op==SAVEPOINT_RELEASE
(operation 1
(optionally
(or -1
(or -9223372036854775808
(or 0 if has not opened stmt
(or 255
(or EBCDIC
(or a new row is inserted into it
(or as close to as possible
(or both
(or if it is already open
(or newer
(or no pages if the journal header is corrupted
(or not required
(or raised
(or read-write
(or statement
(or subtracts
(or subtree
(or subtrees
(or transaction
(or upgraded from READ_LOCK to WRITE_LOCK
(or virtual root
(or write
(os_*.c
(otherwise not
(otherwise x.pList is
(out
(out i
(ovfl+1
(ovflPgno < 2 || ovflPgno > pagerPagecount(pBt
(ovflPgno == 0 || nOvfl > 0
(ovflSize - offset
(p
(p 
(p != null
(p != null && (p.inTrans == TRANS_WRITE
(p != null && (pgno > sqlite3BitvecSize(p
(p != null && p.inTrans == TRANS_WRITE
(p != pColl
(p != pExcept && (0 == iRoot || p.pgnoRoot == iRoot
(p = pBt.pCursor; p != null; p = p.pNext
(p = pBtree.pBt.pCursor; p != null; p = p.pNext
(p = pCur.pBt.pCursor; p != null; p = p.pNext
(p == null || sqlite3_mutex_held(p.db.mutex
(p == pColl
(p->pBt->mutex
(p->pStmt
(p->pVtab
(p->sharable==0 || p->locked
(p->wantToLock==0 || !sqlite3_mutex_held(p->pBt->mutex
(p.CacheAllocated
(p.a=1 AND q.b=2 AND r.c=3
(p.aColName == 0
(p.aCol[0]
(p.aLabel[0]
(p.apPage[i]
(p.db
(p.fd
(p.iSize<=p.nBuf
(p.id==SQLITE_MUTEX_FAST || p.id==SQLITE_MUTEX_RECURSIVE 
(p.id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld(p
(p.inTrans != TRANS_NONE
(p.inTrans == TRANS_NONE
(p.inTrans == TRANS_WRITE
(p.inTrans == TRANS_WRITE || (p.inTrans == TRANS_READ && 0 == wrflag
(p.inTrans > TRANS_NONE
(p.inTrans > TRANS_NONE && pBt.inTransaction > TRANS_NONE
(p.inTrans > pBt.inTransaction
(p.mutex
(p.nChar + 1
(p.nMem
(p.nMem-1
(p.nRef==0 
(p.nRef==0 || p.id==SQLITE_MUTEX_RECURSIVE 
(p.nRef>0 
(p.nSrc-1
(p.nSrc>0 ? sizeof(p.a[0]
(p.owner==GetCurrentThreadId(
(p.pBt.mutex
(p.pBt.pPager
(p.pBt.pPager != null
(p.pBtree.db.flags & SQLITE_ReadUncommitted
(p.pCsr
(p.pReal
(p.pSrc
(p.pgnoRoot == pCur.pgnoRoot
(p.rc
(p.trace
(p.useMalloc && p.zText == p.zBase
(p.wantToLock == 0 && !p.locked
(p.x=4 AND q.y=5 AND r.z=6
(p.zText
(p.zText.Length > 0
(p1
(p2
(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked
(p==null || p.nRef!=0 || (p.flags&PGHDR_NEED_SYNC
(p=db->pBlockingConnection; p && p!=db; p=p->pUnlockConnection
(p=pBt.pCursor; p!=null; p=p.pNext
(p=pBtree.pBt.pCursor; p!=null; p=p.pNext
(p=pCache.pDirtyTail; p!=pCache.pSynced; p=p.pDirtyPrev
(p=pcache1.pLruTail
(p=sqlite3BlockedList; p; p=p->pNextBlocked
(p=sqliteHashFirst(&h
(p=sqliteHashFirst(pSchema.idxHash
(pArg->z < p->z
(pAuthenticatorElement
(pAux
(pBlob.pCsr
(pBt
(pBt != null && pBt.pPager != null
(pBt == null
(pBt.autoVacuum
(pBt.autoVacuum && aRoot[i] > 1
(pBt.autoVacuum && rc == SQLITE_OK
(pBt.autoVacuum == true || pBt.autoVacuum == false
(pBt.autoVacuum || iMeta == 0
(pBt.db != null
(pBt.db.busyHandler
(pBt.inTransaction == TRANS_NONE && pBt.pPage1 != null
(pBt.inTransaction == TRANS_WRITE
(pBt.inTransaction == TRANS_WRITE && p.inTrans == TRANS_WRITE
(pBt.incrVacuum == true || pBt.incrVacuum == false
(pBt.maxLeaf + 23 <= MX_CELL_SIZE(pBt
(pBt.mutex
(pBt.nTransaction > 0
(pBt.pCursor == null || pBt.inTransaction > TRANS_NONE
(pBt.pPage1
(pBt.pPage1 != null
(pBt.pPage1 != null && pBt.pPage1.aData != null
(pBt.pPage1 == null
(pBt.pPage1 == null && SQLITE_OK == (rc = lockBtree(pBt
(pBt.pPage1.aData != null
(pBt.pPage1.pDbPage
(pBt.pPager
(pBt.pSchema
(pBt.pageSize - 1
(pBt.pageSize - nReserve
(pBt.pageSize - pBt.usableSize
(pBt.pageSize >= 512 && pBt.pageSize <= 32768
(pBt.pageSize-8
(pBt.pageSizeFixed
(pBt.pageSizeFixed && (av != 0
(pBt.readOnly
(pBt.readOnly && wrflag != 0
(pBt.usableSize - 35
(pBt.usableSize - 4
(pBt.usableSize - first
(pBt.usableSize / 4 - 2
(pBt.usableSize / 5
(pBt.usableSize <= pBt.pageSize && pBt.usableSize + 255 >= pBt.pageSize
(pBt.usableSize > 32
(pBt.usableSize > 4
(pBt.xFreeSchema != null && pBt.pSchema != null
(pBtree
(pBtree != null
(pBuf = db.lookaside.pFree
(pC.nData + 2
(pCell != 0
(pCell != null
(pCell[1] & 0x80
(pCell[info.iOverflow]<=&pPage.aData[pBt.usableSize]
(pCheck.anRef[iPage] == 1
(pCheck.errMsg.nChar != 0
(pCheck.pBt.autoVacuum
(pCheck.pBt.autoVacuum && N > 0
(pChild
(pChild.nCell == pRoot.nCell
(pColl != null
(pColl != null 
(pCsr
(pCsr != null
(pCsr = pBt.pCursor; pCsr != null && pCsr.pBtree != p; pCsr = pCsr.pNext
(pCsr == null || p.inTrans > TRANS_NONE
(pCur
(pCur != null
(pCur != null && pCur.iPage >= 0 && pCur.apPage[pCur.iPage] != null
(pCur = pBt.pCursor; pCur != null; pCur = pCur.pNext
(pCur->pBtree
(pCur.aiIdx[ii] == pCur.apPage[ii].nCell
(pCur.aiIdx[pCur.iPage] < pCur.apPage[pCur.iPage].nCell
(pCur.aiIdx[pCur.iPage] < pPage.nCell
(pCur.aiIdx[pCur.iPage] == 0
(pCur.aiIdx[pCur.iPage] == pCur.apPage[pCur.iPage].nCell - 1
(pCur.aiIdx[pCur.iPage] >= pCur.apPage[pCur.iPage].nCell
(pCur.aiIdx[pCur.iPage] >= pPage.nCell
(pCur.apPage[0].intKey != 0
(pCur.apPage[0].intKey != 0 || pIdxKey != null
(pCur.apPage[0].intKey == 1 || pCur.apPage[0].intKey == 0
(pCur.apPage[1].nOverflow != 0
(pCur.apPage[i]
(pCur.apPage[pCur.iPage--]
(pCur.apPage[pCur.iPage]
(pCur.apPage[pCur.iPage] != null
(pCur.apPage[pCur.iPage].isInit != 0
(pCur.apPage[pCur.iPage].leaf != 0
(pCur.apPage[pCur.iPage].nCell == 0
(pCur.apPage[pCur.iPage].nCell > 0
(pCur.apPage[pCur.iPage].nCell > 0 || pCur.eState == CURSOR_INVALID
(pCur.apPage[pCur.iPage].nOverflow == 0
(pCur.atLast != 0 && pCur.info.nKey < intKey
(pCur.cachedRowid == iRowid
(pCur.eState != CURSOR_VALID
(pCur.eState != CURSOR_VALID || pCur.skipNext != 0
(pCur.eState == CURSOR_FAULT
(pCur.eState == CURSOR_INVALID
(pCur.eState == CURSOR_INVALID || pCur.eState == CURSOR_VALID
(pCur.eState == CURSOR_VALID
(pCur.eState == CURSOR_VALID || (pCur.eState == CURSOR_INVALID && loc != 0
(pCur.eState == CURSOR_VALID || pCur.eState == CURSOR_INVALID
(pCur.eState >= CURSOR_REQUIRESEEK
(pCur.iPage < BTCURSOR_MAX_DEPTH
(pCur.iPage == 0
(pCur.iPage > 0
(pCur.iPage > iCellDepth
(pCur.iPage >= (BTCURSOR_MAX_DEPTH - 1
(pCur.iPage >= 0
(pCur.iPage >= 0 && pCur.apPage[pCur.iPage] != null
(pCur.info.nKey == intKey
(pCur.info.nLocal - offset
(pCur.info.nPayload-pCur.info.nLocal+ovflSize-1
(pCur.info.nSize == 0
(pCur.pKeyInfo == null
(pCur.pNext != null
(pCur.pPrev != null
(pCur.pVtabCursor
(pCur.pVtabCursor 
(pCur.skipNext != SQLITE_OK
(pCur.skipNext < 0
(pCur.skipNext > 0
(pCur.wrFlag != 0
(pCur.wrFlag != 0 && pBt.inTransaction == TRANS_WRITE && !pBt.readOnly
(pCur.wrFlag != 0 && pCur.eState != CURSOR_FAULT
(pData
(pDbPage
(pDbPage.aData
(pDbPage.pBt == pBt
(pDef
(pDef->zName
(pDel->pAux
(pDest
(pEList
(pEType < 1 || pEType > 5
(pElem
(pEnd->z - pParse->sNameToken.z
(pEnd.n
(pEngine
(pExcept == null || pExcept.pBt == pBt
(pExpr
(pFKey.aCol[0]
(pFd
(pFile
(pFile.fs.SafeFileHandle.DangerousGetHandle(
(pFile.h
(pFile.hMutex
(pFile.hShared
(pFile.hShared == NULL
(pFile.local.bExclusive
(pFile.local.bPending
(pFile.local.bReserved
(pFile.local.nReaders
(pFile.local.nReaders == 0
(pFile.local.nReaders == 1
(pFile.shared
(pFile.shared.bExclusive == 0
(pFile.shared.bPending == 0
(pFile.shared.bReserved == 0
(pFile.shared.nReaders == 0 && pFile.shared.bExclusive == 0
(pFile.zDeleteOnClose
(pFree != null
(pFreePg
(pFrom.isInit != 0
(pFrom.nFree >= iToHdr
(pIdentityElement
(pIdx->nColumn+2
(pIdx=pTab.pIndex; pIdx; pIdx=pIdx.pNext
(pIdxInfo.idxStr
(pIdxKey
(pIdxKey == null
(pIn 
(pIn1
(pInClause
(pIndex->aiColumn[nCol]
(pIndex->aiRowEst[nCol+1]
(pIndex->azColl[nCol]
(pIndex[1]
(pInfo
(pInfo.aCol[0]
(pInfo.aFunc[0]
(pInfo.iOverflow + 4
(pInfo.nLocal + n
(pIter - pCell
(pIter.eLock!=eLock
(pIter=pBt.pLock; pIter; pIter=pIter.pNext
(pKey != null
(pKey.aColl[nCol]
(pKey.aSortOrder[nCol] == &(((u8*
(pKeyInfo.aColl[0]
(pLastPg
(pLastPg.pDbPage
(pLater
(pLater = p->pNext; pLater; pLater=pLater->pNext
(pLater=p->pNext; pLater; pLater=pLater->pNext
(pLeaf.pDbPage
(pLeft AS token
(pLevel.u._in.aInLoop[0]
(pList
(pList.a[0]
(pListItem->pExpr->pColl
(pLock.iTable==iTab || (pLock.eLock==WRITE_LOCK && pLock.iTable==1
(pLock=pBt.pLock; pLock; pLock=pLock.pNext
(pLock=pBtree.pBt.pLock; pLock; pLock=pLock.pNext
(pMaster
(pMem
(pMem.r
(pMem.u.pRowSet
(pMem.z != null
(pMem.zBLOB==null && String.IsNullOrEmpty(pMem.z
(pMemPage != null
(pMem[i]
(pMod.pAux
(pModulE.xColumn 
(pModulE.xNext 
(pMove
(pNew
(pNew != null
(pNew == 0
(pNew ? SQLITE_OK : SQLITE_NOMEM
(pNew.nCell > 0 || (nNew == 1 && cntNew[0] == 0
(pNew.nOverflow == 0
(pNew.pDbPage
(pNewPage.nCell < 1 || pNewPage.intKey != pCur.apPage[i].intKey
(pNewTrunk
(pNewTrunk.pDbPage
(pOld.aOvfl[-(iFOFC + 1
(pOld.hdrOffset == 0
(pOld.nOverflow != 0
(pOp > p.aOp
(pOp.p3
(pOp.p3>0 && pOp.p3<=p.nMem 
(pOp[-1].opcode == OP_CollSeq
(pOp[-1].p4type == P4_COLLSEQ
(pOrderBy
(pOut
(pOut-pSpace
(pOvfl
(pOvfl != null
(pOvfl.pDbPage
(pOvflData
(pOvflPage
(pP1 != null
(pP1.pDbPage
(pPackageSid
(pPackageSid != IntPtr.Zero && pPackageSid != null
(pPage
(pPage != null
(pPage == sqlite3PagerGetExtra(pPage.pDbPage
(pPage.aData
(pPage.aData != null
(pPage.aData == sqlite3PagerGetData(pPage.pDbPage
(pPage.aData[0] == (PTF_INTKEY | PTF_LEAFDATA | PTF_LEAF
(pPage.aOvfl[-(iCell + 1
(pPage.aOvfl[0]
(pPage.cellOffset == hdr + 12 - 4 * pPage.leaf
(pPage.hasData != 0
(pPage.hdrOffset == (pPage.pgno == 1 ? 100 : 0
(pPage.intKey != 0
(pPage.intKey != 0 && 0 == pPage.leaf
(pPage.intKey != 0 ? 0 : (int
(pPage.intKey != 0 || nKey >= 0
(pPage.intKey == ((pIdxKey == null
(pPage.isInit != 0
(pPage.leaf != 0
(pPage.leaf != 0 || 0 == pPage.intKey
(pPage.leaf == 0 || pPage.leaf == 1
(pPage.nCell
(pPage.nCell - 1
(pPage.nCell <= 0
(pPage.nCell <= MX_CELL(pPage.pBt
(pPage.nCell == 0
(pPage.nCell == MX_CELL(pBt
(pPage.nCell > 0
(pPage.nCell > MX_CELL(pBt
(pPage.nCell >> 8
(pPage.nFree + size
(pPage.nFree >= nByte
(pPage.nOverflow != 0
(pPage.nOverflow != 0 || sz + 2 > pPage.nFree
(pPage.nOverflow <= ArraySize(pPage.aOvfl
(pPage.nOverflow == 0
(pPage.nOverflow == 0 && pPage.nFree <= nMin
(pPage.nOverflow == 0 || sqlite3PagerPageRefcount(pPage.pDbPage
(pPage.nOverflow == 1
(pPage.pBt
(pPage.pBt != null
(pPage.pBt.autoVacuum
(pPage.pBt.pPager
(pPage.pBt.usableSize - 4
(pPage.pBt.usableSize <= SQLITE_MAX_PAGE_SIZE
(pPage.pDbPage
(pPage.pgno == 1 ? 100 : 0
(pPage.pgno == sqlite3PagerPagenumber(pPage.pDbPage
(pPage1
(pPage1.pDbPage
(pPageMove
(pPager
(pPager->pCodec
(pPager.cksumInit
(pPager.dbFileVers
(pPager.dbSize
(pPager.dbSize / 8 + 1
(pPager.fd
(pPager.jfd
(pPager.journalMode != PAGER_JOURNALMODE_OFF
(pPager.journalOff > 0 
(pPager.pageSize >= pPager.pVfs->mxPathname+1
(pPager.pageSize%200
(pPager.sectorSize
(pParent
(pParent.isInit != 0
(pParent.nOverflow == 0 || pParent.aOvfl[0].idx == iParentIdx
(pParent.nOverflow == 0 || pParent.nOverflow == 1
(pParent.pDbPage
(pParse
(pParse->apVtabLock[0]
(pParse->nVtabLock+1
(pParse->pNewTable
(pParse->pNewTable->tabFlags & TF_Virtual
(pParse->pVdbe
(pParse.aAlias[0]
(pParse.apVarExpr[0]
(pParse.db
(pParse.declareVtab
(pParse.nAlias-pParse.nAliasAlloc
(pParse.nested == 0
(pParse.sLastToken.z-yymsp[-2].minor.yy0.z
(pParser
(pParser != null
(pParser.yyidx >= 0
(pParser.yystack
(pPg
(pPg.flags&PGHDR_DIRTY
(pPg.pDbPage
(pPgno
(pPgno != PENDING_BYTE_PAGE(pBt
(pPgno == PENDING_BYTE_PAGE(pBt
(pPgno == iTrunk
(pPostOp.n
(pPrevTrunk
(pPrevTrunk != null
(pPrevTrunk == null
(pPrevTrunk.pDbPage
(pPrior!=0 
(pPrior!=0 && nByte>0 
(pPtr
(pPtr += ROUND8(pVfs->szOsFile
(pPtr += ROUND8(pcacheSize
(pPtr += ROUND8(sizeof(*pPager
(pPtr += journalFileSize
(pPtr += nPathname + 1
(pPtrPage
(pPtrPage.pDbPage
(pRC != 0
(pRangeStart and pRangeEnd
(pRec = pData0; pRec <= pLast; pRec++
(pResourceElement
(pRoot
(pRoot.intKey != 0
(pRoot.isInit != 0 && (pCur.pKeyInfo == null
(pRoot.nCell == 0 && 0 == pRoot.leaf
(pRoot.nOverflow > 0
(pRoot.pDbPage
(pRoot.pgno != 1
(pRoot.pgno == pCur.pgnoRoot
(pSelect
(pSrc != null
(pSrc->a[0]
(pSrc.a[0]
(pSrc.notIndexed!=0
(pSrc.pIndex
(pStmt
(pTab
(pTab->zName
(pTab.tabFlags & TF_Autoincrement
(pTemp != null
(pTerm.prereqRight & notReady
(pTmp
(pTmp.pBtree == p
(pTo
(pToCol->a[i].zName
(pToRelease
(pToRelease == null || sqlite3PagerIswriteable(pToRelease.pDbPage
(pTrunk
(pTrunk.pDbPage
(pTstAlloc
(pType.n
(pVTab
(pVTab->pVtab
(pVTable
(pVal
(pValue.n
(pVdbe=db.pVdbe; pVdbe; pVdbe=pVdbe.pNext
(pVfs
(pVfs->szOsFile+sizeof(JournalFile
(pVfs.szOsFile
(pVfs.szOsFile bytes
(pVtab
(pVtab && pModule
(pVtab=pTab->pVTable; pVtab && pVtab->db!=db; pVtab=pVtab->pNext
(pVtabCursor
(pWC.a[0]
(packageSid != null
(page X
(page number
(page1[18] > 1
(page1[19] > 1
(pageSize != pBt.pageSize
(pagesize - 4 bytes
(params byte[][] arrays
(part of the main SQLite library - not an extension
(partial
(partialElement
(passwordItem
(pbAuthData
(pbAuthData != IntPtr.Zero
(pbMacContext
(pbMacContext != IntPtr.Zero
(pbNonce
(pbNonce != IntPtr.Zero
(pbTag
(pbTag != IntPtr.Zero
(pbegin + psize
(pbegin + psize + 3 >= pnext && pnext > 0
(pbegin < addr + 4
(pbegin <= pPage.pBt.usableSize - 4
(pbegin > addr
(pbegin > addr || pbegin == 0
(pbegin > iLast
(pc + size == usableSize
(pc + sz == pPage.pBt.usableSize
(pc + sz == usableSize
(pc + sz > usableSize
(pc < iCellFirst || pc > iCellLast
(pc <= usableSize - 4
(pc == iCellFirst
(pc == iCellLast
(pc > 0
(pc >= iCellFirst && pc <= iCellLast
(pcache.c
(pcacheSize
(pgno
(pgno == 0
(pgno == iLastPg
(pgno > pagerPagecount(pBt
(pgnoMove != pgnoRoot
(pgnoPtrmap != 0 ? PTRMAP_OVERFLOW2 : PTRMAP_OVERFLOW1
(pgnoRoot >= 3
(phFile
(pid
(pnChange != 0
(possibly
(possibly existing
(possibly shared
(possibly synchronous
(possibly updated
(pp=&sqlite3BlockedList; *pp; /* no-op */ 
(pp=&sqlite3BlockedList; *pp; pp = &(*pp
(ppDb 
(ppPage
(ppPage != null
(presumably by auto-vacuum code
(prof.Success
(pzErrMsg
(pzTail != null
(query
(query1
(r < nMaxCells
(rT - 2440587
(rT - 2440587.5
(rc != 0
(rc != SQLITE_OK
(rc != SQLITE_OK || pPage.nCell > 0 || pPage.nOverflow > 0
(rc = 
(rc = sqlite3PagerWrite(pPage.pDbPage
(rc == SQLITE_CORRUPT
(rc == SQLITE_DONE ? SQLITE_OK : rc
(rc == SQLITE_OK
(rc == SQLITE_OK && 0 == (pPage = pCur.apPage[pCur.iPage]
(rc == SQLITE_OK && amt > 0
(rc == SQLITE_OK && eType == PTRMAP_OVERFLOW2 && pgno == ovfl
(rc == SQLITE_OK && pCur.iPage > iCellDepth
(rc == SQLITE_OK && pPage.nOverflow != 0
(rc == SQLITE_OK && pgno <= sqlite3BitvecSize(pBt.pHasContent
(rc == SQLITE_OK && wrflag != 0
(rc == SQLITE_OK ? 1 : 0
(rc == SQLITE_OK || nPage == -1
(rc == SQLITE_OK || pPage == null
(rc == SQLITE_OK || rc == SQLITE_LOCKED_SHAREDCACHE
(rc!=SQLITE_OK 
(rc2 != SQLITE_OK
(rc==0
(rc==SQLITE_NOMEM || pMem.enc==desiredEnc
(rc==SQLITE_OK    || pMem.enc!=desiredEnc
(rc==SQLITE_OK    || rc==SQLITE_NOMEM
(re
(read + write
(read or write
(readCookie
(recorded in Pager.pInJournal
(recursively
(ref 
(ref  elem 
(ref  location
(ref (sqlite3_value
(ref Btree p
(ref IntPtr vaultHandle
(ref azResult
(ref hit
(ref int v
(ref p
(ref p.idxStr
(ref p.zErrMsg
(ref pBt
(ref pBt.pHasContent
(ref pBt.pTmpSpace
(ref pCur
(ref pCur.aOverflow
(ref pCur.pKey
(ref pFree
(ref pKey
(ref pLock
(ref pNew.u._zToken
(ref pParser
(ref pTmp
(ref pzErrMsg
(ref res.azResult[1]
(ref res.azResult[1] 
(ref res.zErrMsg
(ref sqlite3_pcache pCache
(ref zFullPathname
(regIdx
(res = LockFile(pFile.fs.SafeFileHandle.DangerousGetHandle(
(res.nData
(res.nData+1
(resource != null
(respectively
(result != 0
(ret == PENDING_BYTE_PAGE(pBt
(return 0
(return 1
(return SQLITE_IOERR_DELETE
(return SQLITE_IOERR_FSTAT
(return SQLITE_IOERR_READ
(return SQLITE_IOERR_TRUNCATE
(returned by subsequent calls to sqlite3_changes(
(returning SQLITE_OK immediately
(returning void
(returns SQLITE_OK
(retval
(right-most
(rightmost
(root page 1
(s
(sCheck.anRef[0]
(sCheck.errMsg
(sCheck.nErr == 0
(sCheck.nPage == 0
(sCheck.pBt
(sContext
(sInfo
(sbyte
(scalar
(schemaIdInfo.GetValue(currentItem
(searchList != 0
(searchList != 0 && nearby == iTrunk
(sector-size and atomic write(
(see CommitPhaseOne(
(see above
(see below
(see below for exceptions
(see btreeParseCellPtr(
(see function pager_write(
(see note above
(see pagerPlaybackSavepoint(
(see pcache1EnterMutex(
(see sqlite3VdbeSerialType(
(see syncJournal(
(see the PGHDR1_TO_PAGE(
(see the balance(
(see vtab.c
(select a from t1
(set by sqlite3PagerDontWrite(
(set to false
(short
(sidPtr
(signified by the MEM_Ephem flag
(similar to this one
(since after version 2.8.12
(since it is not a valid journal file anyway
(since there are no records in the table
(single database transaction
(size >= 0
(size >= nByte
(size_t
(sizeof(*pIdxCons
(sizeof(*pNew
(sizeof(*pPager
(sizeof(Bitmask
(sizeof(BtLock
(sizeof(CollSeq*
(sizeof(MemPage
(sizeof(Pager
(sizeof(Pgno
(sizeof(X
(sizeof(aJournalMagic
(sizeof(aMsg
(sizeof(aStatic
(sizeof(char*
(sizeof(i64
(sizeof(pPage.aOvfl
(sizeof(u16
(sizeof(u32
(sizeof(u64
(sizeof(zChars
(sizeof(zErr
(slower
(small
(smaller entries
(so that SQLite cannot call it anymore
(spaceLeft == 0
(specified in the first argument
(sqlite.h.in
(sqlite3
(sqlite3 *
(sqlite3 *db
(sqlite3 db
(sqlite3*
(sqlite3*db
(sqlite3.lastRowid
(sqlite3.xUpdateCallback
(sqlite3BtreeHoldsMutex(p
(sqlite3BtreePager(db.aDb[0].pBt
(sqlite3BtreeTrace
(sqlite3CtypeMap[(unsigned char
(sqlite3EndBenignMalloc(
(sqlite3Get4byte(pPage.aData
(sqlite3GlobalConfig.szScratch-4
(sqlite3IsNumericAffinity(aff1
(sqlite3Malloc(
(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER
(sqlite3PagerGetData(pPage.pDbPage
(sqlite3PagerGetExtra(pPage.pDbPage
(sqlite3PagerIswriteable(pChild.pDbPage
(sqlite3PagerIswriteable(pNew.pDbPage
(sqlite3PagerIswriteable(pPage.pDbPage
(sqlite3PagerIswriteable(pPage1.pDbPage
(sqlite3PagerIswriteable(pParent.pDbPage
(sqlite3PagerIswriteable(pRoot.pDbPage
(sqlite3PagerIswriteable(pTrunk.pDbPage
(sqlite3PagerPageRefcount((ppPage
(sqlite3PagerPageRefcount(pData
(sqlite3PagerPagenumber(pPage.pDbPage
(sqlite3PagerRefcount(pBt.pPager
(sqlite3PcacheSize(
(sqlite3Prng
(sqlite3PrngType
(sqlite3UpperToLower[(unsigned char
(sqlite3VdbeDb(v
(sqlite3WhereTrace
(sqlite3_backup *
(sqlite3_backup *p
(sqlite3_blob *
(sqlite3_blob *pBlob
(sqlite3_blob pBlob
(sqlite3_blob*
(sqlite3_context*
(sqlite3_errmsg(db
(sqlite3_extension_init
(sqlite3_file
(sqlite3_file *
(sqlite3_file *id
(sqlite3_file p
(sqlite3_file pFile
(sqlite3_file pJfd
(sqlite3_file*
(sqlite3_index_constraint
(sqlite3_index_constraint_usage
(sqlite3_index_orderby
(sqlite3_initialize(
(sqlite3_int64
(sqlite3_int64*
(sqlite3_mem_methods
(sqlite3_module *
(sqlite3_mutex *
(sqlite3_mutex *p
(sqlite3_mutex p
(sqlite3_mutex sm
(sqlite3_mutex*
(sqlite3_mutex_held(
(sqlite3_mutex_held(db.mutex
(sqlite3_mutex_held(mutexOpen
(sqlite3_mutex_held(p.db.mutex
(sqlite3_mutex_held(pBt.db.mutex
(sqlite3_mutex_held(pBt.mutex
(sqlite3_mutex_held(pCur.pBtree.db.mutex
(sqlite3_mutex_held(pPage.pBt.mutex
(sqlite3_mutex_methods
(sqlite3_os_type == 0
(sqlite3_pcache pCache
(sqlite3_pcache*
(sqlite3_pcache_methods
(sqlite3_query_plan
(sqlite3_step(
(sqlite3_stmt
(sqlite3_stmt *
(sqlite3_stmt *pStmt
(sqlite3_stmt*
(sqlite3_stmt*pStmt
(sqlite3_user_data(
(sqlite3_user_data(context
(sqlite3_value
(sqlite3_value pVal
(sqlite3_value*
(sqlite3_value_text(argv[0]
(sqlite3_vfs *
(sqlite3_vfs pVfs
(sqlite3_vfs*
(sqlite3_vtab *
(sqlite3_vtab *pVTab
(sqlite3_vtab pVTab
(sqlite3_vtab_cursor pCursor
(sqlite3_vtab_cursor*
(sqliteMallocRaw
(sqlite_int64
(sqlite_u3264
(start <= iLast
(start >= pPage.hdrOffset + 6 + pPage.childPtrSize
(start_constraints  &&  startEq &&  bRev
(start_constraints  &&  startEq && !bRev
(start_constraints  && !startEq &&  bRev
(start_constraints  && !startEq && !bRev
(stateno <= YY_REDUCE_MAX
(stateno > YY_SHIFT_MAX || (i = yy_shift_ofst[stateno]
(status != BCrypt.ERROR_SUCCESS
(status == BCrypt.STATUS_AUTH_TAG_MISMATCH
(stdout
(stored in BtCursor.aOverflow[]
(string
(string Privilege
(string alg
(string filePath
(string url in urls
(string url_file_path in files
(string zFilename
(string[]
(string[] args
(struct AuxData
(struct RowSetEntry
(struct RowSetEntry*
(struct _ht
(struct _ht *
(structAddress.ToInt64(
(sub-
(subtotal = k = i = 0; i < nCell; i++
(subtotal > usableSpace
(such as B
(surplus <= maxLocal
(surplus == maxLocal
(surplus == maxLocal + 1
(sz
(sz - info.nLocal + usableSize - 5
(sz <= pBt.pageSize / 4
(sz == info.nPayload
(szCell[0] > pNew.minLocal
(szCell[i] > pNew.minLocal
(szCell[j] == 4
(szCell[nCell] - leafCorrection
(szCell[nCell] < 4
(szNew <= MX_CELL_SIZE(pBt
(szPage
(szRight == 0 || szRight + szCell[d] + 2 <= szLeft - (szCell[r] + 2
(t1 LEFT OUTER JOIN t2
(t1.X <op> <expr>
(t1.Y <op> <expr>
(t1.x=t2.z AND t1.y=15
(t2
(t2 JOIN t3
(t2.b==t1.a
(t64 + 11644473600
(tag != null
(template 3
(template 4
(terminals
(that the pSelect parameter points to
(the 1st parameter
(the 4-byte header field at byte offset 24 of the database file
(the 5th parameter
(the OP_Return
(the P3 record is a prefix of the P1 record
(the Ptr(N
(the [sqlite3_stmt] object
(the blocking connection
(the cache is lazily populated
(the first byte of the header
(the first created
(the flags parameter to [sqlite3_blob_open(
(the if(...
(the journal finalization one
(the last field in the record
(the memory pointer
(the middle slot
(the names and datatypes of the columns
(the number of significant digits in a 64-bit float
(the pSrcList
(the page number of pPage
(the system malloc(
(the third parameter to [sqlite3_db_config(
(the value returned by sqlite3_errcode(
(this can happen with an auto-vacuum database
(this was not always the case
(thus guaranting that it is too large
(ticket #3922
(to 2 or 3
(to be retrieved using sqlite3_errmsg(
(to be used next iteration of this loop
(to establish a read lock
(to get a smaller binary
(top + nByte <= pPage.pBt.usableSize
(tp
(triggers fired by other triggers
(true
(type
(type Bitmask
(type Btree*
(type sqlite3_file*
(type='table' AND rootpage=0
(type='table' OR type='index' OR type='trigger'
(typeof(BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO
(typeof(Guid
(u16
(u16*
(u32
(u32 *
(u32*
(u64
(u64 in
(u64 v
(u8
(u8 *
(u8*
(uint
(ulong
(unless an error occurs
(unless the atomic-write optimization is used
(unmasked
(unreduced
(unsigned *
(unsigned char
(unsigned char *
(unsigned char *zIn
(unsigned char*
(url != null
(url_file_path
(usableSize - 4
(usableSize < 480
(used by triggers
(used for error msg
(ushort
(using [sqlite3_busy_handler(
(using sqliteMalloc(
(usually 0 or 1
(usually SQLITE_CORRUPT
(usually but not always -1
(usually only once during the lifetime of the process
(v
(value of *pPageSize
(vaultElementPtr.ToInt64(
(vaultGuidString.ToString(
(vaultItemCount > 0
(vaultSchema.ContainsKey(vaultGuid
(version 3.3.8 and later
(via sqlite3_step(
(virtual table definition
(void
(void (*
(void (*xEntryPoint
(void *
(void **
(void p
(void pPrior
(void(*
(void*
(void*(*
(void**
(void_function
(when all fields present
(when the statement handle is passed to [sqlite3_reset(
(when the xMalloc(
(where NNN is a number
(which causes the transaction to commit
(which corresponds to memory cell P3
(which does not need to malloc(
(which is either NULL or 0
(which may be this one
(which occurs during hot-journal rollback
(which should be the last to shutdown.
(which we call pPgOld
(winFile*
(winMutex_staticMutexes[0]
(winceLock*
(with [SQLITE_THREADSAFE=0] and with [sqlite3_threadsafe(
(with a different compareInfo structure
(with high probability
(with no X and Y prefix
(with wwww+1==uuuuu
(wrFlag == 0 || p.inTrans == TRANS_WRITE
(wrFlag == 0 || wrFlag == 1
(wrflag != 0 ? TRANS_WRITE : TRANS_READ
(wrflag>1
(wsdAutoext.aExt[0]
(wsdAutoext.nExt+1
(www.wireshark.org
(x
(x & ~(map[x]&0x20
(x - 0x20
(x < 4
(x == 3
(x == 4
(x86
(x==1
(x=sqliteHashFirst(pTbls
(xBegin/xRollback/xCommit and optionally xSync
(xProgress
(y
(y>11 AND y<22 AND z LIKE '*hello*'
(yyParser p
(yyParser pParser
(yyParser*
(yyRuleName.Length/sizeof(yyRuleName[0]
(yyTraceFILE != null
(yyTraceFILE != null && pParser.yyidx >= 0
(yyTraceFILE != null && yypParser.yyidx > 0
(yyTraceFILE == null
(yy_action.Length/sizeof(yy_action[0]
(yy_lookahead[i] == iLookAhead
(yyact < YYNSTATE
(yyact < YYNSTATE + YYNRULE
(yyact == YYNSTATE + YYNRULE + 1
(yyact == YY_ERROR_ACTION
(yyendofinput
(yygotominor.yy14 != null
(yygotominor.yy14 != null && ALWAYS(yygotominor.yy14.a
(yygotominor.yy346.pExpr != null
(yygotominor.yy65
(yymajor
(yymajor != YYNOCODE && yypParser.yyidx >= 0
(yymajor == 0
(yyminor.yy0
(yyminor.yy0.z.Length > 0
(yymsp[-1].minor.yy0.n
(yymsp[-1].minor.yy0.n > 0
(yymsp[-1].minor.yy0.z.Length - yymsp[0].minor.yy0.z.Length
(yymsp[-1].minor.yy14 != null && yymsp[-1].minor.yy14.nExpr > pParse.db.aLimit[SQLITE_LIMIT_FUNCTION_ARG]
(yymsp[-1].minor.yy328 & ~yymsp[0].minor.yy429.mask
(yymsp[-1].minor.yy473 != null
(yymsp[-2].minor.yy0.z.Length - pParse.sLastToken.z.Length
(yymsp[-2].minor.yy328 != 0
(yymsp[-2].minor.yy328 != 0 && yygotominor.yy346.pExpr != null
(yymsp[-2].minor.yy473 != null
(yymsp[-2].minor.yy96.not
(yymsp[-3].minor.yy0.z.Length - yymsp[0].minor.yy0.z.Length
(yymsp[-3].minor.yy328 != 0
(yymsp[-4].minor.yy65
(yymsp[-6].minor.yy0.n == 0 ? yymsp[-7].minor.yy0 : yymsp[-6].minor.yy0
(yymsp[-6].minor.yy65 == null && yymsp[-2].minor.yy0.n == 0 && yymsp[-1].minor.yy132 == null && yymsp[0].minor.yy408 == null
(yymsp[0].minor.yy0.n
(yymsp[0].minor.yy0.n > 0
(yymsp[0].minor.yy0.z - yymsp[-3].minor.yy0.z
(yymsp[0].minor.yy0.z-yymsp[-1].minor.yy0.z
(yymsp[0].minor.yy0.z.Substring(1
(yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-5].minor.yy0.z
(yymsp[0].minor.yy3 != null
(yymsp[0].minor.yy346.pExpr != null
(yypMinor
(yypParser
(yypParser.yyerrcnt <= 0
(yypParser.yyidx < 0
(yypParser.yyidx >= 0
(yypParser.yyidx >= YYSTACKDEPTH
(yyruleno
(yyruleno==0
(yyruleno==1
(yyruleno==10
(yyruleno==100
(yyruleno==103
(yyruleno==107
(yyruleno==108
(yyruleno==11
(yyruleno==114
(yyruleno==116
(yyruleno==118
(yyruleno==119
(yyruleno==12
(yyruleno==120
(yyruleno==126
(yyruleno==127
(yyruleno==137
(yyruleno==145
(yyruleno==146
(yyruleno==15
(yyruleno==150
(yyruleno==154
(yyruleno==157
(yyruleno==158
(yyruleno==159
(yyruleno==16
(yyruleno==160
(yyruleno==161
(yyruleno==167
(yyruleno==168
(yyruleno==179
(yyruleno==18
(yyruleno==180
(yyruleno==187
(yyruleno==190
(yyruleno==191
(yyruleno==2
(yyruleno==20
(yyruleno==200
(yyruleno==201
(yyruleno==202
(yyruleno==203
(yyruleno==204
(yyruleno==205
(yyruleno==206
(yyruleno==209
(yyruleno==21
(yyruleno==210
(yyruleno==211
(yyruleno==219
(yyruleno==222
(yyruleno==223
(yyruleno==225
(yyruleno==226
(yyruleno==235
(yyruleno==236
(yyruleno==237
(yyruleno==238
(yyruleno==239
(yyruleno==240
(yyruleno==241
(yyruleno==242
(yyruleno==246
(yyruleno==247
(yyruleno==25
(yyruleno==251
(yyruleno==254
(yyruleno==260
(yyruleno==261
(yyruleno==262
(yyruleno==263
(yyruleno==264
(yyruleno==265
(yyruleno==266
(yyruleno==267
(yyruleno==268
(yyruleno==269
(yyruleno==275
(yyruleno==277
(yyruleno==279
(yyruleno==280
(yyruleno==287
(yyruleno==298
(yyruleno==3
(yyruleno==30
(yyruleno==303
(yyruleno==304
(yyruleno==305
(yyruleno==306
(yyruleno==31
(yyruleno==314
(yyruleno==315
(yyruleno==319
(yyruleno==320
(yyruleno==322
(yyruleno==324
(yyruleno==325
(yyruleno==326
(yyruleno==327
(yyruleno==328
(yyruleno==34
(yyruleno==35
(yyruleno==39
(yyruleno==4
(yyruleno==40
(yyruleno==41
(yyruleno==42
(yyruleno==43
(yyruleno==44
(yyruleno==46
(yyruleno==49
(yyruleno==51
(yyruleno==52
(yyruleno==53
(yyruleno==54
(yyruleno==55
(yyruleno==56
(yyruleno==59
(yyruleno==62
(yyruleno==70
(yyruleno==71
(yyruleno==83
(yyruleno==84
(yyruleno==85
(yyruleno==86
(yyruleno==89
(yyruleno==90
(yyruleno==91
(yyruleno==92
(yyruleno==97
(yyruleno==98
(z
(z - zOut
(z*2
(z-(unsigned char const *
(z-zBuf
(z2 - z
(z=(unsigned char*
(zBuf
(zBuf[0]=='\0'
(zConverted
(zCsr
(zDbName
(zFilename
(zFilename 
(zIn
(zIn++
(zIn+1
(zIn[i]
(zMagicHeader.Length == 16
(zMbcsFilename
(zMbcsPath
(zMulti
(zName
(zNum
(zOut
(zOut - zStart
(zP4
(zPathname
(zRelative
(zSQL
(zSql8
(zStmt[k]
(zTail8-zSql8
(zTemp
(zTmpWide
(zType
(zType[6] && zType[6]!=' '
(zType[i+6] ? 1 : 0
(zType[i+7]=='\0' || zType[i+7]==' '
(zType[i-1]==' '
(zUtf8
(zWideFilename
(zWidePath
(z[iOffset+i]
(z[info.iOverflow]
(zero
