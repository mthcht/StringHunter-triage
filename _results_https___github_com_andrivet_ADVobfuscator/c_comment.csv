"//
"// ""Random Number Generators: Good Ones Are Hard To Find"", considered as ""minimal standard"""
"// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ..."
"// 1988, Stephen Park and Keith Miller"
"// Do not use a loop, it will not work (it will print 10 times the same number):"
"// F0 = 0, F1 = 1"
"// For a more complete and sophisticated example, see:"
"// Generate a lot of transitions (at least 19, at most 19 + 2 * 40)"
"// Generate a lot of transitions (at least 55, at most 98)"
"// However, I do belive it is neglictable in this case (M is far lower than 2^31 - 1)"
"// I is a list of indexes 0, 1, 2, ..."
"// In production, it would be better to put it in the middle of the FSM with some computing triggering it."
"// In this example, the execution of the FSM is combined with the checking of a predicate (is a debugger present or not)."
"// In this example, the target is called at the end of the FSM so it can be located."
"// It is still possible to define operator """" but it will always use the same key for all encrypted string."
"// MakeIndex<N>::type generates Indexes<0, 1, 2, 3, ..., N>"
"// Park-Miller 31 bit pseudo-random number generator, implemented with G. Carta's optimisation:"
"// Partial specialization with a list of indexes I, a key K and algorithm N = 0"
"// Partial specialization with a list of indexes I, a key K and algorithm N = 1"
"// Partial specialization with a list of indexes I, a key K and algorithm N = 2"
"// Represents an obfuscated string, parametrized with a list of indexes and a key"
"// Represents an obfuscated string, parametrized with a list of indexes"
"// Represents an obfuscated string, parametrized with an alrorithm number N, a list of indexes Indexes and a key Key"
"// Runtime decryption. Most of the time, inlined"
"// Use 0x7F as maximum value since most of the time, char is signed (we have however 1 bit less of randomness)"
"// Warning: ##__VA_ARGS__ is not portable (only __VA_ARGS__ is). However, ##__VA_ARGS__ is far better (handles cases when it is empty) and supported by most compilers"
"// key. ""volatile"" is important to avoid uncontrolled over-optimization by the compiler"
"// loops are executed at run-time,"
"// std::index_sequence will be available with C++14 (C++1y). For the moment, implement a (very) simplified and partial version. You can find more complete versions on the Internet"
//    Start     Event         Next      Action               Guard
//  +---------+-------------+---------+---------------------+----------------------+
//  ADVobfuscator
//  Copyright (c) 2014 Andrivet. All rights reserved.
//  Created by sebastien on 22/09/14."
//  DetectDebugger.cpp"
//  DetectDebugger.h"
//  Indexes.h"
//  Inline.h"
//  Log.h"
//  MetaFSM.h"
//  MetaFactorial.h"
//  MetaFibonacci.h"
//  MetaRandom.h"
//  MetaString.h"
//  MetaString1.h"
//  MetaString2.h"
//  MetaString3.h"
//  MetaString4.h"
//  ObfuscatedCall.h"
//  ObfuscatedCallWithPredicate.h"
//  Unroller.h"
//  main.cpp"
// !$*UTF8*$!
// - Algorithm selected at compile time (there are three examples below)
// - Hard-coded algorithm
// - Hard-coded key
// - Key generated at compile time
// - May generate strange things if string has less than 6 characters
// - No truncation
// - Truncate strings with more than 6 characters
// -- Events
// --- Events
// --- Guards
// --- Initial state of the FSM. Must be defined
// --- States
// --- Transition table
// --- Transitions
// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer."
// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution."
// 2^31 - 1
// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission."
// 7^5
// All rights reserved.
// Almost everything is compile-time
// Alternative (prefix) notation
// Args: Arguments of target
// Be sure that the encryption key is never 0.
// Buffer to store the encrypted string + terminating null byte
// Buffer to store the encrypted string + terminating null byte + key
// Buffer to store the encrypted string + terminating null byte. Key is not stored
// Call our target. Will be actually called only if predicate P is true
// Call target function
// Code common to our FSM (finite state machines)
// Combine lower 15 bits of hi with lo's upper bits
// Constructor
// Constructor. Evaluated at compile time
// Constructor. Evaluated at compile time.
// Constructor. Evaluated at compile time. Key is *not* stored
// Constructor. Evaluated at compile time. Key is stored as the first element of the buffer
// Convert time string (hh:mm:ss) into a number
// Copyright (c) 2010-2014, Sebastien Andrivet"
// Copyright (c) 2010-2016, Sebastien Andrivet"
// Copyright (c) 2010-2017, Sebastien Andrivet"
// Counter to obfuscate predicate result
// Create a instance of ObfuscatedFunc and deduce types
// Custom literal suffix. Not supported by Intel compiler
// Declaration and usage are separated
// Declare and use at the same time
// Demonstrate generation of Factorial at compile time
// Demonstrate generation of Fibonacci sequence at compile time
// Discard lower 15 bits of hi
// E: Event associated with target
// Each character is encrypted (XOR) with an incremented key.
// Each character is encrypted (XOR) with the same key
// Encrypt / decrypt a character of the original string
// Encrypt / decrypt a character of the original string with the key
// Entry point
// Event template to call a function F with a list of parameters.
// Except decrypt()
// F: Function (target)
// FSM: Finite State Machine
// Fibonacci numbers:
// Finite State Machine
// First implementation of an obfuscated string
// First implementation of obfuscated string
// Fn = Fn-1 + Fn-2
// Fourth and final implementation of obfuscated string
// Fourth implementation of an obfuscated string
// Fourth implementation of obfuscated string
// Generate a list of indexes to extract arguments from tuple
// Generate a sequence of random numbers [0..10) at runtime
// Get latest version on https://github.com/andrivet/ADVobfuscator"
// Helper to generate a key
// I use current (compile time) as a seed
// Important: This has to be an odd number to detect if the predicate is true or not
// Inspired from work of Martin Stettner and Jimmy J
// Integral type big enough (and not too big) to store a function pointer
// Limitation:
// Limitations:
// List of indexes generated by MakeIndexes
// Multiply higher 16 bits by 16807
// Multiply lower 16 bits by 16807
// N! = 1 * 2 * 3 * 4 * ... * N
// N! = N * (N - 1)!
// No limitation:
// Note: A bias is introduced by the modulo operation.
// Note: F is passed as value.
// Note: It is possible to merge these two members with ObfuscatedCall and ObfuscatedCallRet (by introducing a TruePredicate) but it will make the 1st FSM example more complicated.
// Note: It is possible to obfuscate this with ADVobfuscator (like the calls to getpid and sysctl)
// Obfuscate function call with a finite state machine (FSM).
// Obfuscate function calls
// Obfuscate functions calls. Behaviour is dependent of a runtime value (debugger detected or not)
// Obfuscate the address of the target. Very simple implementation but enough to annoy IDA and Co.
// Only Apple platforms are implemented in this example. Other platforms are simulated (not debugged)
// Only implemented for Apple platforms (it is just an example)
// P: Predicate
// P: Predicate (functor)
// Partial specialization with a list of indexes I
// Partial specialization with a list of indexes I and a key K
// Pointer to a function
// Predicate
// Prefix notation
// R: Type of return value
// R: Type of the returned value
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:"
// Represents an obfuscated string
// Result of the target
// Returns true if the current process is being debugged (either running under the debugger or has a debugger attached post facto).
// Same as void but can be instantiated
// Second implementation of an obfuscated string
// Second implementation of obfuscated string
// Shift the value of each character and does not store the key. It is only used at compile-time.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
// The function 'ImportantFunctionInTheApplication' will only be called if a debugger is NOT detected
// Third implementation of an obfuscated string
// Third implementation of obfuscated string
// This is computed at Compile-Time
// This is just an example of what is possible. In actual production code it would be better to call event E in the middle of this loop and to make transitions more complex.
// This is not what we want so use instead the macro ENCRYPTED3.
// This is only a (simplified) example to show the principle
// This will call our target. In actual production code it would be better to call event E in the middle of the FSM processing.
// To remove Boost assert messages
// Unroll a loop
// Very simple compile-time random numbers generator.
// When F does not return a value (void)
// When F is returning a value
// When function F is not returning a value
// When function F is returning a value
// [fokede] mingw compatibility
// __TIME__ has the following format: hh:mm:ss in 24-hour time
// functors
// http://www.researchgate.net/profile/Zalan_Szgyi/publication/259005783_Random_number_generator_for_C_template_metaprograms/file/e0b49529b48272c5a6.pdf
// https://developer.apple.com/library/mac/qa/qa1361/_index.html
// we want to generate 10 different numbers are compile-time.
// with 32-bit math and without division
