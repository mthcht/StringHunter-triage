    
     
        
            
                
                    
                        
                            
                                                                            'ommited it use the domain part (FQDN) specified in the target parameter')
                                                                          '(128 or 256 bits)')
                                            history.append(url)
                                        if match:
                                        match = hist_regex.search(line)
                                    continue
                                    fh = BytesIO(hist_data)
                                    for line in fh:
                                    pass
                                    print(e)
                                    urls.append(url)
                                except Exception as e:
                                except:
                                group_commands.append(module)
                                if match:
                                if not mkey.match(str(file.get_longname())):
                                instance_data['Properties'] = properties
                                key_path = f'{mk_dir}
                                keys.append(masterkey)
                                match = url_regex.search(line)
                                mk_name = file.get_longname()
                                password = base64.b64decode(temp_password.text).decode('utf-8')
                                properties = class_part.getProperties()
                                try:
                            'This is useful when target is the NetBIOS name and you cannot resolve it')
                            'ones specified in the command line')
                            bookmarks = parse_bookmarks(json_data)
                            break
                            class_part = current_class['ClassPart']                      
                            continue
                            download = Download()
                            downloads.append(down)
                            downloads.append(download)
                            else:
                            except Exception as e:
                            favorites.append(url.strip(' '))
                            ff_cred_four = f'{firefox_base_path}
                            ff_cred_three = f'{firefox_base_path}
                            ff_history_file = f'{firefox_base_path}
                            ff_history_file = f'{firefox_hist_path}
                            fh = BytesIO(hist_data)
                            fix_dir = f'C:{dl_location}'
                            fix_path = f'C:{firefox_base_path}
                            fn = f.get_longname()
                            for line in fh:
                            if e.getErrorCode() == 0xc0000043:
                            if history_last_mod != datetime.min or credential_three_last_mod != datetime.min or credential_four_last_mod != datetime.min:
                            if not file.is_directory():
                            instance_data['Values'] = values
                            j 
                            name = temp_name.text
                            print(e)
                            try:
                            url = line[4:]
                            values = instance_type.getValues(instance_data['Properties'])
                            workspace = Workspace()
                            workspaces.append(workspace)
                        'InstanceClassName': instance_type['InstanceClassName']
                        break
                        configs.append(conf)
                        context_lines.append(script_block_parts[i 
                        context_lines.append(script_block_parts[i - j].strip())
                        continue
                        current_class = instance_type['CurrentClass']                    
                        except Exception as e:
                        except SessionError as e:
                        fix_path = f'C:{ch_bm_path}'
                        if 'ClassPart' in current_class.fields:
                        if directory.is_directory():
                        if i - j <= 0 or printed >= context:
                        if len(line) > 4:
                        if not f.is_directory():
                        if not line.startswith('URL='):
                        if printed >= context or i 
                        if script_block_parts[i 
                        if temp_name is not None:
                        if temp_password is not None:
                        import inspect
                        j 
                        ofs 
                        output.Domain.DefaultInboundAction = FirewallAction(domain_profile_inbound).name
                        output.Domain.DefaultOutboundAction = FirewallAction(domain_profile_outbound).name
                        output.Domain.DisableNotifications = domain_profile_notifications == 1
                        output.Private.DefaultInboundAction = FirewallAction(private_profile_inbound).name
                        output.Private.DefaultOutboundAction = FirewallAction(private_profile_outbound).name
                        output.Private.DisableNotifications = private_profile_notifications == 1
                        output.Public.DefaultInboundAction = FirewallAction(public_profile_inbound).name
                        output.Public.DefaultOutboundAction = FirewallAction(public_profile_outbound).name
                        output.Public.DisableNotifications = public_profile_notifications == 1
                        output.Standard.DefaultInboundAction = FirewallAction(standard_profile_inbound).name
                        output.Standard.DefaultOutboundAction = FirewallAction(standard_profile_outbound).name
                        output.Standard.DisableNotifications = standard_profile_notifications == 1
                        pass
                        printed 
                        properties[k] = v
                        return None
                        return ret_vals.uValue
                        rule.Action = v
                        rule.ApplicationName = v
                        rule.Description = v
                        rule.Direction = v
                        rule.LocalAddresses = v
                        rule.LocalPorts = v
                        rule.Name = v
                        rule.Profiles = v
                        rule.Protocol = protocols[v]
                        rule.RemoteAddresses = v
                        rule.RemotePorts = v
                        source = inspect.getsource(module.command_base)
                        try:
                        yield obj
                        yield obj.getProperties()
                        yield parsed_event['xml_content']
                       help='IP Address of the target machine. If omitted it will use whatever was specified as target. '
                       help='Use Kerberos authentication. Grabs credentials from ccache file '
                    'domain': domain
                    'enabled': not bool(user_info['UserAccountControl'] 
                    'password_expired': bool(user_info['UserAccountControl'] 
                    ) or (
                    10: 'Label'
                    account[x] = result
                    acred_location = f'{path}
                    azure_base = f'C:{acred_location}'
                    bcred_location = f'{path}
                    bluemix_base = f'C:{bcred_location}'
                    bm = f'{ch_bm_path}
                    break
                    ch_bm_path = f'
                    ch_bm_path = f'{user_path}
                    ch_hist_path = f'
                    chrome_base = f'C:{ch_bm_path}'
                    chrome_cookies = f'{ch_bm_path}Cookies'
                    chrome_history = f'{ch_bm_path}History'
                    chrome_logindata = f'{ch_bm_path}LoginData'
                    configs.append(config)
                    context_lines.append(m.group().strip())
                    context_lines.append(match.group().strip())
                    continue
                    credential_four_last_mod = datetime.min
                    credential_three_last_mod = datetime.min
                    day = install_date_str[6:8]
                    deserialized = json.loads(content)
                    directories = str(f.get_longname())
                    dl_location = f'{outlook_base}{dir.get_longname()}'
                    downloads = []
                    elif k == 'Active':
                    elif k == 'App':
                    elif k == 'Desc':
                    elif k == 'Dir':
                    elif k == 'LA4':
                    elif k == 'LPort':
                    elif k == 'Name':
                    elif k == 'Profile':
                    elif k == 'Protocol':
                    elif k == 'RA4':
                    elif k == 'RPort':
                    elif next_token == 0x04:
                    elif next_token == 0x05:
                    elif next_token == 0x0e or next_token == 0x0d:
                    else:
                    event_data = result_buffer[event_offset:event_offset 
                    event_offset = resp['EventDataIndices'][i]['Data']
                    event_size = resp['EventDataSizes'][i]['Data']
                    file_path = path
                    fixed_dir = f'C:{mk_dir}'
                    for directory in directories:
                    for f in files:
                    for file in files:
                    for item in value:
                    for line in rdr.splitlines():
                    for obj in objects:
                    for server in servers[0]:
                    found_file = f'C:
                    gcred_location = f'{path}
                    google_base = f'C:{gcred_location}'
                    guid_masterkey = uuid.UUID(bytes_le=guid_masterkey_bytes)
                    guid_masterkey_bytes = blob_bytes[offset:offset
                    history = []
                    history_last_mod = datetime.min
                    if 'CurrentClass' in instance_type.fields:
                    if dir.get_longname() == '.' or dir.get_longname() == '..':
                    if dirs.get_longname() == '.' or dirs.get_longname() == '..':
                    if domain_profile_inbound is not None:
                    if domain_profile_notifications is not None:
                    if domain_profile_outbound is not None:
                    if history is not None or cookies is not None or login_data is not None:
                    if k == 'Action':
                    if len(configs) > 0:
                    if len(objects) == 0:
                    if len(onv) == 1:
                    if m.group() not in script_block_parts[i]:
                    if match.group() not in script_block_parts[i]:
                    if next_token == 0x01 or next_token == 0x41:
                    if parsed_event:
                    if private_profile_inbound is not None:
                    if private_profile_notifications is not None:
                    if private_profile_outbound is not None:
                    if public_profile_inbound is not None:
                    if public_profile_notifications is not None:
                    if public_profile_outbound is not None:
                    if standard_profile_inbound is not None:
                    if standard_profile_notifications is not None:
                    if standard_profile_outbound is not None:
                    if str(e).find('S_FALSE') < 0:
                    installed_clr.append(location.strip('v'))
                    instance_data = {
                    j = 1
                    k = onv[0]
                    keys = []
                    location = str(d.get_longname())
                    mk_dir = f'{dpapi_basepath}{dirs.get_longname()}'
                    module.command_base(options)
                    module_name = file[:-3]
                    month = install_date_str[4:6]
                    next_token = buf[ofs]
                    ntlm_v1_users.add(account_name)
                    ntlm_v2_users.add(account_name)
                    offset = 24
                    ofs 
                    onv = prop.split('=')
                    output.Rules.append(rule)
                    owner = f'{owner_info.Domain}
                    parsed_event = self.parse_event(event_data)
                    pass
                    print(i)
                    printed = 0
                    properties[key] = value
                    provider[x] = result
                    results[name] = val
                    return None         
                    scope_ids.append(mp_key)
                    self._children.append(element)
                    session_id = session.get('SessionId')
                    settings[key] = result
                    time_created = time_created.astimezone(datetime.timezone.utc)
                    user_name = str(data['User']).strip()
                    v = onv[1]
                    value = bytes(value)
                    while i - j > 0 and printed < context:
                    while printed < context and i 
                    workspaces = []
                    year = install_date_str[0:4]
                    }
                )
                PrintHandler._print_single_key_value_object(item)
                PrintHandler.print_key_entries(autoruns)
                PrintHandler.print_kv(aps)
                PrintHandler.print_kv(settings)
                PrintHandler.print_kv(wef)
                PrintHandler.print_props(autologon)
                PrintHandler.print_props(avs)
                PrintHandler.print_props(boot)
                PrintHandler.print_props(cache)
                PrintHandler.print_props(cc)
                PrintHandler.print_props(drives)
                PrintHandler.print_props(events)
                PrintHandler.print_props(kp)
                PrintHandler.print_props(proc)
                PrintHandler.print_props(product)
                PrintHandler.print_props(profiles)
                PrintHandler.print_props(providers)
                PrintHandler.print_props(ps_hist)
                PrintHandler.print_props(res)
                PrintHandler.print_props(sccm)
                PrintHandler.print_props(sessions)
                PrintHandler.print_props(shares)
                PrintHandler.print_props(shutdown)
                PrintHandler.print_props(sysmon)
                PrintHandler.print_props(users)
                PrintHandler.print_props(wsus)
                access_str=access_str
                action_args.append('Allow')
                action_args.append('Block')
                aws_base = f'C:{aws_key}'
                aws_key = f'{path}
                break
                category = 'browser'
                category = 'interesting'
                commands.append(c)
                configs = []
                context_lines = []
                continue
                cookie_base = f'{user_path}
                cookies_last_write_time = datetime.min
                direction_args.append('In')
                direction_args.append('Out')
                directories = str(f.get_longname())
                display = True
                domain = domains[domain_index]['Name'] if domain_index != -1 else ''
                domain = p.Domain
                domain_index = name['DomainIndex']
                downloads_base = f'{user_path}
                downloads_last_write_time = datetime.min
                elif lm_package_name == 'NTLM V2':
                elif type == 11:  
                elif type == 2:  
                elif type == 3:  
                elif type == 4:  
                elif type == 7:  
                else:
                enforcementModeStr = 'Audit Mode'
                enforcementModeStr = 'Enforce Mode'
                enforcementModeStr = 'not configured'
                enforcementModeStr = f'Unknown value {enforcement_mode}'
                event_data[elem.tag.split('}')[1]] = elem.text
                event_data[name] = data.text
                except Exception as e:
                except ImportError:
                except wmi.DCERPCSessionError as e:
                except:
                file_path = f'{fz_path}{f}'
                file_version = (
                firefox_base_path = f'
                firefox_hist_path = f'
                fixed_path = f'C:{file_path}'
                for a_location in azure_locations:
                for b_location in bluemix_locations:
                for g_location in google_locations:
                for i in range(len(script_block_parts)):
                for i in range(resp['NumActualRecords']):
                for i in script_block_parts:
                for path in path_list:
                for prop in props:
                for session in sessions:
                format_result(env_vars)
                format_results(applocker)
                format_results(bookmark)
                format_results(chrome_presence)
                format_results(conns)
                format_results(defender)
                format_results(dotnet_info)
                format_results(downloads)
                format_results(events)
                format_results(favorites)
                format_results(features)
                format_results(filezilla)
                format_results(firefox)
                format_results(fw)
                format_results(groups)
                format_results(history)
                format_results(hotfix)
                format_results(ieurls)
                format_results(info)
                format_results(laps)
                format_results(mks)
                format_results(od)
                format_results(phk)
                format_results(po)
                format_results(ps)
                format_results(rcs)
                format_results(rdp_settings)
                format_results(res)
                format_results(sch_task)
                format_results(sessions)
                format_results(settings)
                format_results(slack)
                format_results(super_putty)
                format_results(uac)
                format_results(wmi)
                format_results(workspaces)
                groups.append({
                if 'ERROR_NO_MORE_ITEMS' in str(e) or 'RPC_X_BAD_STUB_DATA' in str(e):
                if cookies_last_write_time is not None or workspace_last_write_time is not None or downloads_last_write_time is not None:
                if d.get_longname() == '.' or d.get_longname() == '..':
                if dir.is_directory():
                if dirs.is_directory():
                if domain_profile_enabled is not None:
                if f.get_longname() == '.' or f.get_longname() == '..' or f.get_longname() == 'Public' or f.get_longname() == 'Default' or f.get_longname() == 'Default User' or f.get_longname() == 'All Users':
                if instance_type != NULL:
                if key == 'AgentFwd' or key == 'ConnectionSharing':
                if key == 'LastModifiedTime':
                if len(configs) > 0:
                if lm_package_name == 'NTLM V1':
                if m:
                if mp_key == 'LastModifiedTime':
                if not filter_results or (len(action_args) == 0 and len(protocol_args) == 0 and len(direction_args) == 0 and len(profile_args) == 0 and 
                if not m:
                if not match:
                if not result_buffer or resp['NumActualRecords'] == 0:
                if not servers or len(servers[0]) == 0:
                if not servers:
                if not sessions:
                if owner_info.ReturnValue == 0:
                if private_profile_enabled is not None:
                if public_profile_enabled is not None:
                if result is not None and result != '':
                if result:
                if ret_vals.ReturnValue == 0:
                if standard_profile_enabled is not None:
                if time_bytes is None:
                if time_created:
                if type == 1:  
                if u.get_longname().endswith('.url'):
                if url_time > start_time:
                if val is not None and val != '':
                if value.ReturnValue == 0 and val is not None:
                if x == 'Business':
                import traceback
                instance_type = object_block.fields['InstanceType']
                kerberos_users.add(account_name)
                kp_config = f'{path}
                last_access_time = file_attributes[0].get_atime_epoch()
                last_write_time = file_attributes[0].get_mtime_epoch()
                local_dt = dt.astimezone()
                m = reg.search(command_line)
                m = reg.search(content)
                match = regex.search(script_block)
                ofs 
                output.Domain.Enabled = domain_profile_enabled == 1
                output.Domain.Present = True
                output.Private.Enabled = private_profile_enabled == 1
                output.Private.Present = True
                output.Public.Enabled = public_profile_enabled == 1
                output.Public.Present = True
                output.Standard.Enabled = standard_profile_enabled == 1
                output.Standard.Present = True
                owner_info = proc.GetOwner()
                parsed = parse_value(parsed)
                path = f'{user_path}
                principal = trustee
                print()
                print(e)
                print(f'      [
                print(f'     {key:<20} : {sessions[key]}')
                print(f'  {key:<30} : {result}')
                print(f'  {key:<30} : {value}')
                print(f'Error obtaining owner: {e}')
                print(line)
                print_single_obj(obj)
                proc_key = f'{path}
                product = browser_processes[process_name]
                product = interesting_processes[process_name]
                product_version = (
                profile_args.append('Domain')
                profile_args.append('Private')
                profile_args.append('Public')
                properties = {}
                props = value.split('
                protocol_args.append('TCP')
                protocol_args.append('UDP')
                raise
                raise e
                rep_obj = o['Repetition']
                resp = self.dce.request(request)
                result = value.hex('-').upper()
                result[key] = None
                result_buffer = resp['ResultBuffer']
                results.append({
                return
                return None
                return [parse_value(item) for item in value]
                return file_attributes[0].get_filesize()
                return formatted_time
                return product_version
                return self.parse_wmi_object(str(value))
                return value
                root = ET.fromstring(doc)
                rpctransport.setRemoteHost(self.kdcHost)
                rpctransport.setRemoteName(self.target)
                rule = WindowsFirewallRule()
                rules.append(rule)
                scope_ids.append(acc)
                script_block_parts = content.splitlines()
                script_block_parts = script_block.split('
                sd = 'slack-downloads'
                self.PolicyManagerPathExclusions.append(s)
                self._attributes.append(attr)
                self._empty = False
                self._empty = True
                self.values.append(value)
                sid = trustee
                sid_type = name['Use']
                slack_base = f'{user_path}
                slack_downloads_base = f'{user_path}
                slack_workspace_base = f'{user_path}
                state = 'Audited'
                state = 'Blocked'
                state = 'Disabled'
                state = f'{rule.State} - Unknown'
                sw = 'slack-workspaces'
                sysdll = f'{path}
                time_created = event_detail['TimeCreated.SystemTime']
                traceback.print_exc()
                trigger = ScheduledTaskTrigger()
                trigger.Duration = rep_obj['Duration']
                trigger.Enabled = o['Enabled']
                trigger.EndBoundary = o['EndBoundary']
                trigger.ExecutionTimeLimit = o['ExecutionTimeLimit']
                trigger.Interval = rep_obj['Interval']
                trigger.Properties = properties
                trigger.StartBoundary = o['StartBoundary']
                trigger.StopAtDurationEnd = rep_obj['StopAtDurationEnd']
                trigger.Type = obj['Triggers']['qualifiers']['EmbeddedInstance']
                trigger_objects.append(trigger)
                try:
                type_desc = {
                url_time = from_file_time(time_long)
                user = f.get_longname()
                user = p.User
                user = str(f.get_longname())
                user_rid = user['RelativeId']
                users.append({
                values_length 
                while True:
                workspace_base = f'{user_path}
                workspace_last_write_time = datetime.min
                xmlDoc = ET.fromstring(file_data)
                xml_file = 'Sessions.xml'
                })
             }
            'ObjectBlock': {}
            ))
            PrintHandler._print_single_key_value_object(obj_or_list)
            ]
            access_list.append(PluginAccess(
            access_str
            account = {}
            account_name = f'{target_domainname}
            action = 'awake'
            action = 'shutdown'
            action = 'shutdown(UnexpectedShutdown)'
            action = 'sleep'
            action = 'startup'
            action = ScheduledTaskAction()
            action.Properties = properties
            action.Type = obj['Actions']['qualifiers']['EmbeddedInstance']
            actions_list.append(action)
            algorithms.append(alg.name)
            arch = 'x64'
            args = module_args.split()
            attrs = vars(obj)
            autoruns = list(settings.values())
            bmark.append(bookmark)
            business = False
            c_fav = []
            category = None
            chrome_path = chrome_path[3:]
            command_args[module_name] = module_args
            commands = []
            configured = True
            connections.append(connection)
            context_lines = []
            continue
            data = even_conn.parse_xml(event)
            data = wmi_conn.parse_wmi(d)
            data = wmi_conn.parse_wmi(properties)
            days = int(args[0])
            display = False
            domainId=domain_sid
            domain_handle = self._get_domain_handle(builtin=False)
            domain_handle = self._get_domain_handle(builtin=True)
            domain_name
            domains = names['ReferencedDomains']['Domains']
            dpapi_basepath = f'{path}
            elif arg.lower() == 'deny' or arg.lower() == 'block':
            elif arg.lower() == 'domain':
            elif arg.lower() == 'in':
            elif arg.lower() == 'out':
            elif arg.lower() == 'private':
            elif arg.lower() == 'public':
            elif arg.lower() == 'tcp':
            elif arg.lower() == 'udp':
            elif authentication_package == 'Kerberos':
            elif enforcement_mode == 0:
            elif enforcement_mode == 1:
            elif next_token == 0x02:
            elif next_token == 0x03:
            elif process_name.lower() in [x.lower() for x in interesting_processes.keys()]:
            elif rule.State == 1:
            elif rule.State == 2:
            else:
            encoding_unit_bytes = bytes.fromhex(hex_string)
            env_var = self.parse_wmi(data)
            event_bytes = b''.join(event_data)
            except Exception as e:
            except ImportError:
            except TypeError as e:
            exit(0)
            favorites = []
            favorites_base = f'{path}
            fixed_path = f'C:{ps_con_hist_path}'
            for dir in directories:
            for dirs in dpapi_listing:
            for f in files:
            for i in ids:
            for item in obj_or_list:
            for item in response['Buffer']['Buffer']:
            for key in keys:
            for module in group_commands:
            for o in triggers:
            for obj in obj_or_list:
            for r in applocker.Rules:
            for reg in ps_regex:
            for reg in sysmon_regex:
            for regex in ps_regex:
            for s in exclusion_path.split('
            for u in urls:
            for user in response['Buffer']['Buffer']:
            groups = []
            hive_num = self._get_hive_num(hive)
            iEnumWbemClassObject = self.iWbemServices.ExecQuery(wql)
            iWbemLevel1Login = wmi.IWbemLevel1Login(iInterface)
            if 'InstanceType' in object_block.fields:
            if 'policy_handle' in locals():
            if applocker is not None:
            if aps is not None:
            if arg.lower() == 'allow':
            if authentication_package == 'NTLM':
            if autologon is not None:
            if autoruns is not None:
            if avs is not None:
            if bookmark is not None:
            if boot is not None:
            if business == True:
            if cache is not None:
            if cc is not None:
            if chrome_presence is not None:
            if conns is not None:
            if d.is_directory():
            if defender is not None:
            if display_name is not None:
            if domain_profile_enabled is not None:
            if dotnet_info is not None:
            if downloads is not None:
            if drives is not None:
            if e.getErrorCode() == 0xc0000043:  
            if elem.text and elem.text.strip():
            if enforcement_mode is None:
            if env_vars is not None:
            if events is not None:
            if f.get_longname() == '.' or f.get_longname() == '..' or f.get_longname() == 'Public' or f.get_longname() == 'Default' or f.get_longname() == 'Default User' or f.get_longname() == 'All Users':
            if f.is_directory():
            if favorites is not None:
            if features is not None:
            if file.endswith('_command.py'):
            if file_attributes:
            if filezilla is not None:
            if firefox is not None:
            if fw is not None:
            if groups is not None:
            if history is not None:
            if hotfix is not None:
            if ieurls is not None:
            if info is not None:
            if install_date_str and install_date_str.strip():
            if key != 'SessionName':
            if key in ordered_dict:
            if kp is not None:
            if laps is not None:
            if len(sessions) != 0:
            if line:
            if logging.getLogger().level == logging.DEBUG:
            if m:
            if mks is not None:
            if mp not in provider.Odsp.mpList:
            if name:
            if next_token == 0x06 or next_token == 0x46:
            if not display:
            if not self.connect():
            if not sid.startswith('S-1-5') or sid.endswith('_Classes'):
            if od is not None:
            if p.ReturnValue == 0:
            if phk is not None:
            if po is not None:
            if private_profile_enabled is not None:
            if proc is not None:
            if process_name.lower() in [x.lower() for x in browser_processes.keys()]:
            if product is not None:
            if profiles is not None:
            if providers is not None:
            if ps is not None:
            if ps_hist is not None:
            if public_profile_enabled is not None:
            if rcs is not None:
            if rdp_settings is not None:
            if recent_commands is None or len(recent_commands) == 0:
            if res is not None:
            if rule.State == 0:
            if sccm is not None:
            if sch_task is not None:
            if sddl:
            if self.doKerberos is True:
            if self.doKerberos:
            if self.kdcHost is not None:
            if sessions is not None:
            if settings is None or len(settings) <= 1:
            if settings is not None:
            if shares is not None:
            if shutdown is not None:
            if slack is not None:
            if smb_conn.connect():
            if standard_profile_enabled is not None:
            if str(e).find('STATUS_MORE_ENTRIES') < 0:
            if str(e).find('S_FALSE') < 0:
            if super_putty is not None:
            if sysmon is not None:
            if template.values[self._dependency].type == 0x00:
            if trustee.isalpha():
            if uac is not None:
            if users is not None:
            if val is not None and val != '':
            if value['value'] is None:
            if wef is not None:
            if wmi is not None:
            if workspaces is not None:
            if wsus is not None:
            install_date = datetime.min
            key_name = k
            keys = [
            keys.append(kvp)
            l = 'Require Remote Credential Guard'
            l = 'Require Restricted Admin Mode'
            l = 'Require Restricted Admin or Remote Credential Guard'
            last_days = int(args[0])
            lsat_rpc = transport.DCERPCTransportFactory(f'ncacn_np:{self.target}[
            lsat_rpc.set_smb_connection(self._smb_conn)
            m = reg.search(command_line)
            module_name = parts[0].lower().strip()
            name = data.get('Name')
            next_token = buf[ofs]
            o.AcctoMPMapping[acc] = scope_ids
            o.OneDriveList[acc] = account
            o.mpList[rname] = provider
            o.useScopeIDs.extend(scope_ids)
            od_value = value['value']
            ofs 
            outlook_base = f'{path}
            output = WindowsFirewall(rule_location)
            output[key] = parse_value(parsed)
            owner = None
            owner = f'{domain}
            p = proc.GetOwner()
            parsed = parse_value(od_value)
            partial_path = f'{user_path}
            parts = version_str.split('.')
            pass
            pe = pefile.PE(data=file_data)
            policy_handle = lsad.hLsarOpenPolicy2(self._lsat_dce)['PolicyHandle']
            principal = trustee
            print('
            print('         Version is 80
            print('        [!] You can do a PowerShell version downgrade to bypass the logging.')
            print('      [
            print('ERROR: Argument is not an integer')
            print()
            print(f'          {m}')
            print(f'      {sub_key} : {sub_val}')
            print(f'    ExtraArgs   : {config.ExtraArgs}')
            print(f'    {exclusion}')
            print(f'    {ext}')
            print(f'    {path}')
            print(f'    {proc}')
            print(f'    {state:<10} {asr_rule}')
            print(f'  {conn.RemoteHost:<34} {conn.UserNameHint}')
            print(f'  {member['class']:<15} {member['domain']}
            print(f'error: {e}')
            print_single_obj(obj_or_list)
            print_user_set(kerberos_users)
            print_user_set(ntlm_v1_users)
            print_user_set(ntlm_v2_users)
            process_name = splitext(data['Name'])[0]
            product = None
            properties = proc.getProperties()
            properties = {}
            provider = {}
            ps_con_hist_path = f'{user_path}
            raise
            record = pEnum.getProperties()
            request = even6.EvtRpcQueryNext()
            request['Flags'] = 0
            request['LogQuery'] = log_handle
            request['NumRequestedRecords'] = batch_size
            request['TimeOutEnd'] = 1000
            result['ObjectBlock']['ObjectFlags'] = object_block['ObjectFlags']
            result_set = ResultSet(event_bytes)
            results = []
            return
            return False
            return None
            return True
            return []
            return bytes(ret_vals.uValue)
            return data['Version']
            return files
            return groups
            return iEnumWbemClassObject
            return list(self.full_query(wql))
            return record.items()
            return results
            return ret_vals.sNames or []
            return ret_vals.sValue
            return self.parse_version_info(file_data)
            return str(uuid.UUID(bytes_le=value.data))
            return users
            return value.data.decode('utf16')
            return value.data.hex()
            return value.template.xml()
            return {'xml_content': xml_content}
            return {}
            rpctransport = transport.DCERPCTransportFactory(binding)
            running = True
            samr_rpc = transport.DCERPCTransportFactory(f'ncacn_np:{self.target}[
            samr_rpc.set_smb_connection(self._smb_conn)
            scope_ids = []
            script_block = data['ScriptBlockText']
            sddl = security_element.get('Sddl')
            self.AsrSettings.Exclusions.append(val.key)
            self.ExtensionExclusions.append(k)
            self.PathExclusions.append(k)
            self.ProcessExclusions.append(k)
            self._domain_handle = None
            self._lsat_dce = None
            self._lsat_dce = lsat_rpc.get_dce_rpc()
            self._lsat_dce.bind(lsat.MSRPC_UUID_LSAT)
            self._lsat_dce.connect()
            self._lsat_dce.disconnect()
            self._samr_dce = None
            self._samr_dce = samr_rpc.get_dce_rpc()
            self._samr_dce.bind(samr.MSRPC_UUID_SAMR)
            self._samr_dce.connect()
            self._samr_dce.disconnect()
            self._server_handle
            self._server_handle = None
            self._server_handle = samr.hSamrConnect(self._samr_dce)['ServerHandle']
            self._smb_conn = None
            self._smb_conn.close()
            self.build = int(parts[2]) if len(parts) > 2 else 0
            self.close()
            self.connection.close()
            self.dce = rpctransport.get_dce_rpc()
            self.dce.bind(EVEN6_UUID)
            self.dce.connect()
            self.dce.set_auth_level(RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
            self.dce.set_auth_level(RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
            self.dcom.disconnect()
            self.iWbemServices.RemRelease()
            self.length = 22 
            self.major = int(parts[0]) if len(parts) > 0 else 0
            self.minor = int(parts[1]) if len(parts) > 1 else 0
            self.values = []
            sessions.append(settings)
            settings = {
            sid = trustee
            sid_mapping = {
            sids = [member['Data']['SidPointer'].formatCanonical() for member in members['Members']['Sids']]
            state = None
            sysmon_options = SysmonOptions(reg_options).name
            sysmon_options = reg_options
            t = 'Require Remote Credential Guard'
            t = 'Require Restricted Admin Mode'
            t = 'Require Restricted Admin or Remote Credential Guard'
            target_command = f'{module_name}_command'
            target_outbound_domain = data['TargetOutboundDomainName']
            target_outbound_user = data['TargetOutboundUserName']
            try:
            urls = []
            user = str(f.get_longname())
            user_name = f.get_longname()
            username = f.get_longname()
            users = []
            value_type = type(value)
            values_length = 0
            vbs_setting = VBS(data['VirtualizationBasedSecurityStatus']).name
            version = os.path.basename(path.rstrip(os.path.sep)).lstrip('v')
            versions.append(ver)
            versions.append(version)
            while True:
            xml_content = result_set.xml()
            }
           continue
         procs = wmi_conn.get_wmi_object('SELECT 
        'SOFTWARE
        'SYSTEM
        ))
        )['Buffer']['Buffer'][1 if builtin else 0]['Name']
        )['DomainHandle']
        )['DomainId']
        WINDOWS_TICKS = int(shutdown_int)
        ]
        accName = item_key
        access = []
        access_list = []
        ace_pattern = r'(A
        action = None
        actions = data['Actions']
        actions_list = []
        all_args = ' '.join(args)
        appIdSvcState = data['State']
        arch = 'x86'
        authentication_package = data['AuthenticationPackageName']
        av_info = wmi_conn.wmi_get('SELECT 
        base64_rules = base64.b64encode(reg_sysmon_rules).decode('utf-8')
        batch_size = 200
        boot_time = info.BootTimeUtc
        boot_time = info.BootTimeUtc.replace(tzinfo=timezone.utc)
        build_number 
        client_sess_sec = SessionSecurity(int(ntlm.NTLMMinClientSec)).name
        command_args = parse_module_commands(options.command)
        command_line = str(data['CommandLine']).strip()
        command_line = str(event_detail['CommandLine'])
        commands = [commands]
        configured = False
        connections = []
        current_time = info.CurrentTimeUtc
        current_time = info.CurrentTimeUtc.replace(tzinfo=timezone.utc)
        data = even_conn.parse_xml(event)
        data = wmi_conn.parse_wmi(av)
        data = wmi_conn.parse_wmi(cg)
        data = wmi_conn.parse_wmi(d)
        data = wmi_conn.parse_wmi(fixes)
        data = wmi_conn.parse_wmi(logged)
        data = wmi_conn.parse_wmi(o)
        data = wmi_conn.parse_wmi(obj)
        data = wmi_conn.parse_wmi(s)
        data = wmi_conn.parse_wmi(shares)
        data = wmi_conn.parse_wmi(w)
        data_two = wmi_conn.parse_wmi(sess)
        date_created = convert_binary_datetime(date_created_bytes)
        date_lastconnected = convert_binary_datetime(date_connected_bytes)
        decoded_content = output.decode(encoding)
        def parse_value(value):
        def print_single_obj(obj):
        delta = WINDOWS_TICKS / 10_000_000
        deserialized = json.loads(contents)
        dns_data = wmi_conn.wmi_get('SELECT 
        domain = data['Domain']
        domain = m2.group(1)
        domain = user_domain[0]
        domain_handle = samr.hSamrOpenDomain(
        domain_name = samr.hSamrEnumerateDomainsInSamServer(
        domain_sid = samr.hSamrLookupDomainInSamServer(
        elif event['Id']  == 12:
        elif event['Id']  == 13:
        elif event['Id']  == 42:
        elif event['Id']  == 6008:
        elif level == 2:
        elif level == 3:
        elif next_token == 0x01 or next_token == 0x41:
        elif next_token[0] == 0x0e:
        elif rra_type == 2:
        elif rra_type == 3:
        elif self._type == 0x11:
        elif self._type == 0x13:
        elif self._type == 0x15 or self._type == 0x10:
        elif self._type == 0x21:
        elif self._type == 0x4:
        elif self._type == 0x6:
        elif self._type == 0x7:
        elif self._type == 0x8:
        elif self._type == 0xa:
        elif self._type == 0xf:
        else:
        encoding_unit = wmi.ENCODING_UNIT(encoding_unit_bytes)
        even_conn.close()
        even_conn.connect()
        event = even_conn.parse_xml(data)
        event_data = {}
        event_detail = even_conn.parse_xml(event)
        except Exception as e:
        except KeyboardInterrupt:
        except SessionError as e:
        except ValueError as e:
        except pefile.PEFormatError as e:
        except samr.DCERPCSessionError as e:
        except socket.error as e:
        except:
        fh = BytesIO()
        file_obj = BytesIO()
        filter_results = False
        finally:
        fix_data = wmi_conn.wmi_get('SELECT 
        for acc in od_account:
        for applocker in get_app_lockers(wmi_conn):
        for aps in get_audit_policy(wmi_conn):
        for arg in args:
        for autologon in get_windows_auto_logon(wmi_conn):
        for autoruns in get_auto_runs(wmi_conn):
        for avs in get_av(wmi_conn):
        for b in bookmark.Bookmarks:
        for bookmark in get_chromium_bookmarks(smb_conn):
        for boot in get_secure_boot(wmi_conn):
        for cache in get_dns_cache(wmi_conn):
        for cc in get_cloud_credentials(smb_conn):
        for conn in rdp.Connections:
        for conns in get_rdp_saved_connections(wmi_conn):
        for d in dirs:
        for d in wmi_data:
        for data in odict:
        for defender in get_windows_defender(wmi_conn):
        for downloads in get_slack_downloads(smb_conn):
        for drives in get_mapped_drives(wmi_conn):
        for elem in root.findall('.//ns:System//
        for entry in children:
        for env_vars in get_env_vars(wmi_conn):
        for event in xml_event:
        for exclusion in asr_settings.Exclusions:
        for ext in extension_exclusions:
        for f in directory_listing:
        for favorites in get_ie_favorites(smb_conn):
        for features in get_optional_features(wmi_conn):
        for file in os.listdir(commands_dir):
        for filezilla in get_filezilla(smb_conn):
        for firefox in get_firefox_presence(smb_conn):
        for history in get_chromium_history(smb_conn):
        for history in get_firefox_history(smb_conn):
        for host in subkeys:
        for hotfix in get_hotfixes(wmi_conn):
        for k in exclusion_path:
        for k in extension_exclusion_data:
        for k in keys:
        for k in proc_exclusions_data:
        for key in sessions.keys():
        for key in wmi_keys:
        for kp in get_keepass(smb_conn):
        for laps in get_laps(wmi_conn):
        for m in powershell.ModuleNames:
        for match in matches:
        for member in group.Members:
        for mks in get_dpapi_masterkeys(smb_conn):
        for mp in provider.Odsp.AcctoMPMapping[accName]:
        for o in actions:
        for od in get_outlook_downloads(smb_conn):
        for path in path_exclusions:
        for phk in get_putty_host_keys(wmi_conn):
        for po in get_process_owners(wmi_conn):
        for proc in get_interesting_processes(wmi_conn):
        for proc in process_exclusions:
        for product in get_installed_products(wmi_conn):
        for profiles in get_network_profiles(wmi_conn):
        for providers in get_amsi_providers(wmi_conn):
        for rcs in get_explore_run_commands(wmi_conn):
        for rdp_settings in get_rdp_settings(wmi_conn):
        for reg in proc_regex:
        for res in get_cloud_sync_providers(wmi_conn):
        for res in get_cred_guard(wmi_conn):
        for rname in subkeys:
        for rule in asr_settings.Rules:
        for rule in firewall.Rules:
        for s in value:
        for sccm in get_sccm(wmi_conn):
        for session_name in subkeys:
        for sessions in get_logon_sessions(wmi_conn):
        for sessions in get_putty_sessions(wmi_conn):
        for settings in get_lsa_settings(wmi_conn):
        for settings in get_ntlm_settings(wmi_conn):
        for settings in get_ps_session_settings(wmi_conn):
        for shares in get_network_shares(wmi_conn):
        for shutdown in get_lastshutdown(wmi_conn):
        for sid in sids:
        for slack in get_slack_presence(smb_conn):
        for sub_key in sub_key_names:
        for super_putty in get_super_putty(smb_conn):
        for sysmon in get_sysmon(wmi_conn):
        for uac in get_uac(wmi_conn):
        for val in asr_exclusions:
        for val in asr_rules:
        for wef in get_windows_event_forwarding(wmi_conn):
        for workspaces in get_slack_workspaces(smb_conn):
        for wsus in get_wsus(wmi_conn):
        group_commands = []        
        hashing_alg = get_sysmon_alg(int(reg_hash_alg))
        hive_map = {
        hive_num = self._get_hive_num('HKU')
        hive_num = self._get_hive_num(hive)
        i 
        if 'TargetOutboundDomainName' in data:
        if 'TargetOutboundUserName' in data:
        if 'filter' in args:
        if (manufacturer == 'microsoft corporation' and 'VIRTUAL' in model.upper()) or 'vmware' in manufacturer or 'xen' in manufacturer or model == 'VirtualBox':
        if 1 in data['SecurityServicesConfigured']:
        if 1 in data['SecurityServicesRunning']:
        if chrome_path is not None:
        if config is None:
        if config.ExtraArgs:
        if data['InstallState'] != OptionalFeatureState.Enabled:
        if data['VirtualizationBasedSecurityStatus']:
        if event['Id'] == 1:
        if excluded_path is not None:
        if f.is_directory():
        if filetime['LowPart'] == 0 and filetime['HighPart'] == 0:
        if firewall_rules is not None:
        if group_commands:
        if hashes is not None:
        if highest_version.major < 3:
        if highest_version.major < 5:
        if host_keys is None or len(host_keys) == 0:
        if i % 3 == 0:
        if len(applocker.Rules) == 0:
        if len(attrs) > 0:
        if len(chrome_path) > 2 and chrome_path[1] == ':' and chrome_path[2] == '
        if len(item_val) == 0:
        if len(kerberos_users) > 0:
        if len(ntlm_v1_users) > 0 or len(ntlm_v2_users) > 0:
        if len(ntlm_v1_users) > 0:
        if len(ntlm_v2_users) > 0:
        if level == 1:
        if logon_type == 'Network':
        if lowest_version.major < 3:
        if lowest_version.major < 5:
        if members:
        if module_args:
        if next_token == 0x0C:
        if next_token == 0x0F:
        if next_token[0] == 0x05 or next_token == 0x45:
        if not m2:
        if not m:
        if not self._server_handle:
        if not self._smb_conn:
        if not self.connection:
        if not self.iWbemServices:
        if not sid.startswith('S-1-5') or sid.endswith('_Classes'):
        if not subkeys or len(subkeys) <= 0:
        if ntlm.LanmanCompatabilityLevel is not None and int(ntlm.LanmanCompatabilityLevel) < 3 and not (client_sess_sec 
        if ntlm.LanmanCompatabilityLevel is not None and int(ntlm.LanmanCompatabilityLevel) < 3 and not (server_sess_sec 
        if object_block != NULL:
        if od_account is None:
        if parts:
        if prod == 'SOFTWARE
        if ret_vals.ReturnValue != 0:
        if ret_vals.ReturnValue == 0:
        if rra_type == 1:
        if scope_id in provider.Odsp.useScopeIDs:
        if security_element is not None:
        if self._dependency != 0xFFFF:
        if self._domain_handle:
        if self._empty:
        if self._lsat_dce:
        if self._samr_dce:
        if self._server_handle:
        if self._smb_conn:
        if self._type == 0x1:
        if self.connection:
        if self.dcom:
        if self.iWbemServices:
        if self.type == 0x21:
        if settings and len(settings) != 0:
        if subkeys is None:
        if token == 0x41:
        if trigger.Duration is not None and trigger.Duration != '':
        if trigger.EndBoundary is not None and trigger.EndBoundary != '':
        if trigger.ExecutionTimeLimit is not None and trigger.ExecutionTimeLimit != '':
        if trigger.Interval is not None and trigger.Interval != '':
        if trigger.Properties is not None:
        if trigger.StartBoundary is not None and trigger.StartBoundary != '':
        if trigger.StopAtDurationEnd is not None and trigger.StopAtDurationEnd != '':
        if triggers != None:
        if trustee in well_known_sids:
        if user is not None:
        if value 
        if value.type == 0x0:
        if var == '2.0' and not '2.0.50727' in powershell.InstalledCLRVersions:
        if ver is not None:
        inbound_audit_str = 'Disable'
        inbound_audit_str = 'Enable auditing for all accounts'
        inbound_audit_str = 'Enable auditing for domain accounts'
        inbound_audit_str = 'Not defined'
        inbound_rest_str = 'Allow all'
        inbound_rest_str = 'Deny all accounts'
        inbound_rest_str = 'Deny all domain accounts'
        inbound_rest_str = 'Not defined'
        installed = True
        installed_dotnet_versions.append(dot_net_four)
        installed_dotnet_versions.append(dot_net_threefive)
        ip_address = data['IpAddress']
        keys = []
        ldap_signing_str = 'Negotiate signing'
        ldap_signing_str = 'No signing'
        ldap_signing_str = 'Require Signing'
        ldap_signing_str = 'Unknown'
        line 
        lm_package = data['LmPackageName']
        lmstr = 'Send LM 
        lmstr = 'Send NTLM response only'
        lmstr = 'Send NTLMv2 response only - Win7
        lmstr = 'Send NTLMv2 response only. DC: Refuse LM 
        lmstr = 'Send NTLMv2 response only. DC: Refuse LM'
        lmstr = 'Unknown'
        local_time = shutdown_time.astimezone()
        log_handle = resp['Handle']
        logon_id = m.group(1)
        logon_type = SECURITY_LOGON_TYPE(int(data['LogonType'])).name
        manufacturer = data['Manufacturer'].lower()
        members = samr_conn.get_local_group_members(group['name'])
        model = data['Model']
        module_args = options.command_args[command.lower()]
        namespaces = {'pc': 'http://schemas.microsoft.com/wbem/wsman/1/config/PluginConfiguration'}
        network_category = NetworkCategory(int(networkcategory)).name
        network_type = NetworkType(int(networktype)).name
        ns = {'ns': 'http://schemas.microsoft.com/win/2004/08/events/event'}
        o = OneDriveSyncProvider()
        object_block = encoding_unit['ObjectBlock']
        odict =  self.wmi_get(query)
        ofs = offset 
        options.command_args = command_args
        options.command_args = {}
        oubound_rest_str = 'Allow All'
        oubound_rest_str = 'Audit All'
        oubound_rest_str = 'Deny All'
        oubound_rest_str = 'Not defined'
        output = fh.getvalue()
        output = {}
        owner = ''
        parts = module_str.split()
        pass
        path = f'{net_path}{dir.get_longname()}'
        principal = ScheduledTaskPrincipal()
        principal.DisplayName = temp_principal['DisplayName']
        principal.GroupId = temp_principal['GroupId']
        principal.Id = temp_principal['Id']
        principal.LogonType = SECURITY_LOGON_TYPE(int(temp_logon_type)).name
        principal.RunLevel = RunlvelEnum(int(temp_run_level)).name
        principal.UserId = temp_principal['UserId']
        print('
        print('        [!] The highest .NET version is enrolled in AMSI!')
        print('        [!] You can do a PowerShell version downgrade to bypass AMSI.')
        print('  [
        print(' [X] Cannot enumerate antivirus. root
        print('All Local Groups (and memberships)
        print('Collecting Windows Firewall Non-standard Rules
        print('Collecting all Windows Firewall Rules
        print('Domain Profile')
        print('Non-empty Local Groups (and memberships)
        print('Private Profile')
        print('Public Profile')
        print('Rules:
        print('Standard Profile')
        print()
        print(e)
        print(event)
        print(f'
        print(f'    
        print(f'        [
        print(f'       {history}')
        print(f'      {var}')
        print(f'      {vv}')
        print(f'      {v}')
        print(f'     Chrome Version                         :  {chrome.ChromeVersion}')
        print(f'    DefaultInboundAction     : {firewall.Domain.DefaultInboundAction}')
        print(f'    DefaultInboundAction     : {firewall.Private.DefaultInboundAction}')
        print(f'    DefaultInboundAction     : {firewall.Public.DefaultInboundAction}')
        print(f'    DefaultInboundAction     : {firewall.Standard.DefaultInboundAction}')
        print(f'    DefaultOutboundAction    : {firewall.Domain.DefaultOutboundAction}
        print(f'    DefaultOutboundAction    : {firewall.Private.DefaultOutboundAction}
        print(f'    DefaultOutboundAction    : {firewall.Public.DefaultOutboundAction}
        print(f'    DefaultOutboundAction    : {firewall.Standard.DefaultOutboundAction}
        print(f'    DisableNotifications     : {firewall.Domain.DisableNotifications}')
        print(f'    DisableNotifications     : {firewall.Private.DisableNotifications}')
        print(f'    DisableNotifications     : {firewall.Public.DisableNotifications}')
        print(f'    DisableNotifications     : {firewall.Standard.DisableNotifications}')
        print(f'    Enabled                  : {firewall.Domain.Enabled}')
        print(f'    Enabled                  : {firewall.Private.Enabled}')
        print(f'    Enabled                  : {firewall.Public.Enabled}')
        print(f'    Enabled                  : {firewall.Standard.Enabled}')
        print(f'    FilePath  : {conf.FilePath}')
        print(f'    Host      : {conf.Host}')
        print(f'    Name      : {conf.Name}')
        print(f'    Password  : {conf.Password}
        print(f'    Port      : {conf.Port}')
        print(f'    Protocol  : {conf.Protocol}')
        print(f'    Username  : {conf.UserName}')
        print(f'    [
        print(f'    {access.Principal:<35}    {access.Permissions:<22}')
        print(f'    {k.LastAccessed}    {k.LastModified}    {k.FileName}')
        print(f'    {key}')
        print(f'    {line}')
        print(f'    {rc.Key:<10} :  {rc.Value}')
        print(f'    {str(url.Time):<23} :  {url.Url}')
        print(f'  RestrictedRemoteAdministrationType: {l}')
        print(f'  RestrictedRemoteAdministrationType: {t}')
        print(f'  {f}')
        print(f'  {url}')
        print(f'Bookmarks ({bookmark.FilePath})
        print(f'Exception {e}')
        print(f'Saved RDP Connection Information ({rdp.Sid})
        print(f'Username Filter: {user_regex}')
        print(line)
        print(result)
        print_extra()
        process_cmdline_regex = [
        process_name = data['ProcessName']
        pwd = ntpath.normpath(pwd)
        reg_hash_alg = reg_hash_alg 
        request = even6.EvtRpcRegisterLogQuery()
        request['Flags'] = even6.EvtQueryChannelName 
        request['Path'] = f'{log_name}
        request['Query'] = f'{query}
        resp = self.dce.request(request)
        result = {
        result = {}
        results = {}
        results.append((
        results.append(feature)
        return
        return None
        return []
        return access_list
        return datetime.fromtimestamp(total)
        return decoded_content
        return domain_handle
        return env_var['VariableValue']
        return event_data
        return file_obj.getvalue()
        return output
        return process_cmdline_regex
        return result
        return results
        return self
        return self._element.xml(template)
        return self._val
        return self._xml.xml()
        return self._xml.xml(self)
        root = ET.fromstring(config)
        root = ET.fromstring(xml_content)
        running = False
        samr_conn.connect()
        samr_conn.disconnect()
        self.AcctoMPMapping = {}
        self.Action = action
        self.Actions = actions
        self.AdmPwdEnabled = admpwdenabled
        self.AllowDemandStart = allowdemandstart
        self.AllowHardTerminate = allowhardterminate
        self.AllowSmartCardRedirection = allowsmartcardredirection
        self.AltDefaultDomainName = altdomainname
        self.AltDefaultPassword = altpassword
        self.AltDefaultUserName = altusername
        self.AlternateServer = alternateserver
        self.AppIdSvcState = appidsvcstate
        self.ApplicationName = applicationname
        self.Architecture = architecture
        self.AsrSettings = AsrSettings(asr_enabled is not None and asr_enabled != 0)
        self.AsrSettings = None
        self.AuthenticationPackage = authenticationpackage
        self.Author = author
        self.BlockClipboardRedirection = blockclipboardredirection
        self.BlockComPortRedirection = blockcomportredirection
        self.BlockDriveRedirection = blockdriveredirection
        self.BlockLptPortRedirection = blocklptportredirection
        self.BlockPnPDeviceRedirection = blockpnpdeviceredirection
        self.BlockPrinterRedirection = blockprinterredirection
        self.Bookmarks = bookmarks
        self.BootTimeUtc = boottimeutc
        self.Build = build
        self.BuildBranch = buildbranch
        self.Caption = caption
        self.Category = category
        self.ChromeVersion = chromeversion
        self.ClientNegotiateSigning = clientnegotiatesigning
        self.ClientRequireSigning = clientrequiresigning
        self.ClientSettings = clientsettings
        self.CommandLine = commandline
        self.Commands = commands
        self.Comment = comment
        self.ComputerName = computername
        self.Configs = configs
        self.Configured = configured
        self.ConnectionState = connectionstate
        self.Connections = connections
        self.ConsentPromptBehaviorAdmin = consentpromptbehavioradmin
        self.ConsoleHistoryPath = consolehistorypath
        self.Context = context
        self.ContextJoined = contextjoined
        self.CookiesLastModified = cookieslastmodified
        self.CredentialFile3LastModified = credentialfile3lastmodified
        self.CredentialFile4LastModified = credentialfile4lastmodified
        self.CurrentMajorVersionNumber = currentmajorversionnumber
        self.CurrentTimeUtc = currenttimeutc
        self.CurrentVersion = currentversion
        self.Data = data
        self.Date = date
        self.DateCreated = datecreated
        self.DateLastConnected = datelastconnected
        self.DateUtc = dateutc
        self.DefaultDomainName = defaultdomainname
        self.DefaultInboundAction = defaultinboundaction
        self.DefaultOutboundAction = defaultoutboundaction
        self.DefaultPassword = defaultpassword
        self.DefaultUserName = defaultusername
        self.Description = description
        self.Direction = direction
        self.DisableNotifications = disablenotifications
        self.DisablePasswordSaving = disablepasswordsaving
        self.DisallowStartIfOnBatteries = disallowstartifonbatteries
        self.DisplayName = None
        self.DisplayName = displayname
        self.DisplayVersion = displayversion
        self.Domain = WindowsFirewallProfileSettings()
        self.Domain = domain
        self.DownloadPath = downloadpath
        self.Downloads = downloads
        self.DownloadsLastModified = downloadslastmodified
        self.Duration = None
        self.EditionId = editionid
        self.EnableLua = enablelua
        self.Enabled = None
        self.Enabled = enabled
        self.EndBoundary = None
        self.EnforcementMode = enforcementmode
        self.Engine = engine
        self.Entries = entries
        self.Entry = entry
        self.EnumerationMethod = enumerationmethod
        self.EventID = eventid
        self.EventId = eventid
        self.Exclusions = []
        self.ExecutionTimeLimit = None
        self.ExecutionTimeLimit = executiontimelimit
        self.ExtensionExclusions = []
        self.ExtraArgs = extraargs
        self.Favorites = favorites
        self.FileName = filename
        self.FilePath = filepath
        self.FilterAdministratorToken = filteradministratortoken
        self.Folder = folder
        self.GUID = guid
        self.GroupComment = groupcomment
        self.GroupId = None
        self.GroupName = groupname
        self.GroupPolicySettings = grouppolicysettings
        self.HashingAlgorithm = hashingalgorithm
        self.Hidden = hidden
        self.History = history
        self.HistoryLastModified = historylastmodified
        self.Host = host
        self.HostKeys = hostkeys
        self.Hostname = hostname
        self.HotFixID = hotfixid
        self.ID = id
        self.Id = None
        self.InboundAuditing = inboundauditing
        self.InboundRestrictions = inboundrestrictions
        self.InputLanguage = inputlanguage
        self.InstallDate = installdate
        self.Installed = installed
        self.InstalledBy = installedby
        self.InstalledCLRVersions = installedclrversions
        self.InstalledDotNetVersions = installeddotnetversions
        self.InstalledInputLanguages = installedinputlanguages
        self.InstalledOnUTC = installedonutc
        self.InstalledVersions = installedversions
        self.Interval = None
        self.IpAddress = ipaddress
        self.IsHighIntegrity = ishighintegrity
        self.IsLocalAdmin = islocaladmin
        self.IsVirtualMachine = isvirtualmachine
        self.Key = key
        self.KeyName = keyname
        self.LAPSAdminAccountName = lapsadminaccountname
        self.LAPSPasswordComplexity = lapspasswordcomplexity
        self.LAPSPasswordLength = lapspasswordlength
        self.LanmanCompatabilityLevel = lanmancompatabilitylevel
        self.LapsPwdExpirationProtectionEnabled = lapspwdexpirationprotectionenabled
        self.LastAccessed = lastaccessed
        self.LastLogon = lastlogon
        self.LastModified =  lastmodified
        self.LastModified = lastmodified
        self.LastShutDown = lastshutdown
        self.LastSuccessfulInstallParams = lastsuccessfulinstallparams
        self.LdapSigning = ldapsigning
        self.LmPackage = lmpackage
        self.LocalAccountTokenFilterPolicy = localaccounttokenfilterpolicy
        self.LocalAddresses = localaddress
        self.LocalName = localname
        self.LocalPorts = localports
        self.LocalSettings = localsettings
        self.Locale = locale
        self.Location = location
        self.LoginDataLastModified = logindatalastmodified
        self.LogonId = logonid
        self.LogonServer = logonserver
        self.LogonServerDnsDomain = logonserverdnsdomain
        self.LogonTime = logontime
        self.LogonType = None
        self.LogonType = logontype
        self.MachineGuid = machineguid
        self.Managed = managed
        self.MasterKeyGuid = masterkeyguid
        self.MasterKeys = masterkeys
        self.Match = match
        self.Members = members
        self.ModuleLogging = modulelogging
        self.ModuleNames = modulenames
        self.NTLMMinClientSec = ntlmminclientsec
        self.NTLMMinServerSec = ntlmminserversec
        self.Name = name
        self.NetworkCategory = networkcategory
        self.NetworkLevelAuthentication = nla
        self.NetworkType = networktype
        self.NumLogins = numlogins
        self.Odsp = odsp
        self.OneDriveList = {}
        self.Options = options
        self.OsSupportsAmsi = ossupportamsi
        self.OsSupportsAmsi = ossupportsamsi
        self.OutboundExceptions = outboundexceptions
        self.OutboundRestrictions = outboundrestrictions
        self.Owner = owner
        self.Password = password
        self.Path = path
        self.PathExclusions = []
        self.Permission = permission
        self.Permissions = permission
        self.Persistent = persistent
        self.Plugin = plugin
        self.PolicyManagerPathExclusions = []
        self.Port = port
        self.Present = present
        self.Principal = principal
        self.Private = WindowsFirewallProfileSettings()
        self.Process = process
        self.ProcessExclusions = []
        self.ProcessID = processid
        self.ProcessName = processname
        self.ProcessorCount = processorcount
        self.Product = product
        self.ProductEXE = productexe
        self.ProductName = productname
        self.ProductVersion = productversion
        self.ProfileName = profilename
        self.Profiles = profiles
        self.Properties = None
        self.Protocol = protocol
        self.ProviderPath = providerpath
        self.Public = WindowsFirewallProfileSettings()
        self.Publisher = publisher
        self.PwdLastSet = pwdlastset
        self.QueryResults = queryresults
        self.ReleaseId = releaseid
        self.RemoteAddresses = remoteaddress
        self.RemoteHost = remotehost
        self.RemoteName = remotename
        self.RemotePath = remotepath
        self.RemotePorts = remoteports
        self.ReportingEXE = reportingexe
        self.RestrictedRemoteAdministration = restrictedadmin
        self.RestrictedRemoteAdministrationType = restrictedadmintype
        self.Rid = rid
        self.Rule = rule
        self.Rules = []
        self.Rules = rules
        self.RunLevel = None
        self.Running = running
        self.SDDL = sddl
        self.ScriptBlockInvocationLogging = scriptblockinvocationlogging
        self.ScriptBlockLogging = scriptblocklogging
        self.Server = server
        self.ServerAuthLevel = serverauthlevel
        self.ServerNegotiateSigning = servernegotiatesigning
        self.ServerRequireSigning = serverrequiresigning
        self.ServerSettings = serversettings
        self.SessionID = sessionid
        self.SessionName = sessionname
        self.Sessions = sessions
        self.Sid = sid
        self.SiteCode = sitecode
        self.Size = size
        self.Source = source
        self.Standard = WindowsFirewallProfileSettings()
        self.StartBoundary = None
        self.StartTime = datetime
        self.StartTime = starttime
        self.State = state
        self.StatisticsServer = statisticsserver
        self.Status = status
        self.StopAtDurationEnd = None
        self.StopIfGoingOnBatteries = stopifgoingonbatteries
        self.SubjectDomain = subjectdomain
        self.SubjectDomainName = subjectdomainname
        self.SubjectUser = subjectuser
        self.SubjectUserName = subjectusername
        self.TargetDomain = targetdomain
        self.TargetDomainName = targetdomainname
        self.TargetOutboundDomainName = targetoutbounddomainname
        self.TargetOutboundUserName = targetoutboundusername
        self.TargetUser = targetuser
        self.TargetUserName = targetusername
        self.TaskPath = taskpath
        self.TeamID = teamid
        self.Time = time
        self.TimeCreated = timecreated
        self.TimeCreatedUtc = timecreatedutc
        self.TimeZone = timezone
        self.TimeZoneUtcOffset = timezoneutcoffset
        self.TranscriptionDirectory = transcriptiondirectory
        self.TranscriptionInvocationLogging = transcriptioninvocationlogging
        self.TranscriptionLogging = transcriptionlogging
        self.Triggers = triggers
        self.Type = None
        self.Type = credtype
        self.Type = type
        self.URLs = urls
        self.Url = url
        self.Urls = urls
        self.UseWUServer = usewuserver
        self.User = user
        self.UserID = userid
        self.UserId = None
        self.UserId = userid
        self.UserName = username
        self.UserNameHint = usernamehint
        self.UserPrincipalName = userprincipalname
        self.UserSID = usersid
        self.UserType = usertype
        self.Username = username
        self.Value = value
        self.Version = version
        self.VirtualizationBasedSecurityStatus = virtualizationbasedsecuritystatus
        self.Workspaces = workspaces
        self.WorkspacesLastModified = workspaceslastmodified
        self._attributes = []
        self._children = []
        self._dependency = dependency_id
        self._domain_handle = None
        self._id = sub_id
        self._lsat_dce = None
        self._optional = sub_token == 0x0e
        self._samr_dce = None
        self._server_handle = None
        self._smb_conn = None
        self._type = sub_type
        self._val = buf[offset 
        self.aesKey = aesKey
        self.connection = None
        self.data = buf[value_offset:value_offset 
        self.dce = None
        self.dce.disconnect()
        self.dcom = None
        self.doKerberos = doKerberos
        self.domain = domain
        self.iWbemServices = None
        self.kdcHost = kdcHost
        self.length = 1 
        self.length = 4
        self.length = 4 
        self.length = ofs - offset
        self.lmhash = ''
        self.mpList = {}
        self.namespace = namespace
        self.nthash = ''
        self.password = password
        self.port = 445
        self.target = target
        self.useScopeIDs = []
        self.username = username
        self.val = buf[offset 
        server_sess_sec = SessionSecurity(int(ntlm.NTLMMinServerSec)).name
        sessions = []
        settings = {}
        shutdown_time = WINDOWS_EPOCH 
        smb_conn.close()
        smb_conn.close()  
        smb_conn.close()    
        state = OptionalFeatureState(data['InstallState']).name
        state = StateEnum(int(data['State'])).name
        str_values = [str(x) for x in value]
        subject_domainname = data['SubjectDomainName']
        subject_username = data['SubjectUserName']
        target_domainname = data['TargetDomainName']
        target_outbound_domain = '-'
        target_outbound_user = '-'
        target_outbound_user = f'{logon.TargetOutboundDomainName}
        target_username = data['TargetUserName']
        temp_logon_type = temp_principal['LogonType']
        temp_principal = data['Principal']
        temp_run_level = temp_principal['RunLevel']
        total -= 116444736000000000
        total /= 10000000
        total = (filetime['HighPart'] << 32) 
        trigger_objects = []
        triggers = data['Triggers']
        try:
        try:            
        types = type_dict.get(int(data['Type']))
        uefi_state = 0
        user = m2.group(2)
        user = str(event_detail['TargetUserName'])
        user_name = user_domain[1]
        user_regex = args[1]
        val = self._value.xml(template)
        value = template.values[self._id]
        value_names = ret_vals.sNames or []
        value_types = ret_vals.Types or []
        vbs_setting = VBS(0).name
        versions.append(ps_v2)
        versions.append(ps_v4p)
        while True:
        wmi_conn.close()
        wmi_conn.close()    
        wmi_conn.connect()
        wmi_data = wmi_conn.wmi_get('SELECT 
        wmi_namespace == args[0]
        wmi_query = args[0]
        wmi_query = args[1]
        yield LastShutdown(formatted_time)
        yield output
        yield r
        }
       parser.print_help()
       sys.exit(1)
     return
    @staticmethod
    ALLOW = 0
    Absent = 3
    BLOCK = 1
    Batch = 4
    Batch = 4                     
    CachedInteractive = 11
    CachedInteractive = 11        
    CachedRemoteInteractive = 12  
    CachedUnlock = 13             
    Confidentiality = 0x00000020
    Disabled = 1
    Disabled = 2
    ENABLED_AND_RUNNING = 2
    ENABLED_NOT_RUNNING = 1
    Enabled = 1
    HOME = 1
    IMPHASH = 8
    ImageLoading = 2
    Integrity = 0x00000010
    Interactive = 2
    Interactive = 2               
    MD5 = 2
    MOBILE_BROADBAND = 243
    NOT_ENABLED = 0
    NTLMv2 = 0x00080000
    Network = 3
    Network = 3                   
    NetworkCleartext = 8
    NetworkCleartext = 8          
    NetworkConnection = 1
    NewCredentials = 9
    NewCredentials = 9            
    NotDefined = 0
    PUBLIC = 0
    PrintHandler.show_banner(command)
    Proxy = 6                     
    Queued = 2
    Ready = 3
    RemoteInteractive = 10
    RemoteInteractive = 10        
    Require128BitKey = 0x20000000
    Require56BitKey = 0x80000000
    Running = 4
    SHA1 = 1
    SHA256 = 4
    Service = 5
    Service = 5                   
    TASK_RUNLEVEL_HIGHEST = 1
    TASK_RUNLEVEL_LUA = 0
    Unknown = 0
    Unknown = 4
    Unlock = 7
    Unlock = 7                    
    VPN = 23
    WIRED = 6
    WIRELESS = 25
    WORK = 2
    ]
    ace_pattern = r'
    ace_types = {
    action_args = []
    algorithms = []
    all_scope_ids = list(provider.Odsp.mpList.keys())
    arch = wmi_conn.get_env_var('PROCESSOR_ARCHITECTURE')
    args = ''
    args = []
    asr_settings = settings.AsrSettings
    autorun_locs = [
    azure_locations = [
    base64_rules = None
    bluemix_locations = [
    bmark = []
    bookmarks = []
    boot_time = datetime.min
    browser_processes = {
    class Version:
    client = rdpsettings.ClientSettings
    command = 'AMSIProviders'
    command = 'AntiVirus'
    command = 'AppLocker'
    command = 'AuditPolicyRegistry'
    command = 'Autoruns'
    command = 'ChromiumBookmarks'
    command = 'ChromiumHistory'
    command = 'ChromiumPresence'
    command = 'CloudCredentials'
    command = 'CloudSyncProviders'
    command = 'CredGuard'
    command = 'DNSCache'
    command = 'DotNet'
    command = 'DpapiMasterKeys'
    command = 'EnvironmentVariables'
    command = 'ExplicitLogonEvents'
    command = 'ExplorerRunCommands'
    command = 'FileZilla'
    command = 'FirefoxHistory'
    command = 'FirefoxPresence'
    command = 'Hotfixes'
    command = 'IEFavorites'
    command = 'IEUrls'
    command = 'InstalledProducts'
    command = 'InterestingProcesses'
    command = 'KeePass'
    command = 'LAPS'
    command = 'LSASettings'
    command = 'LastShutdown'
    command = 'LocalGroups'
    command = 'LocalUsers'
    command = 'LogonEvents'
    command = 'LogonSessions'
    command = 'MappedDrives'
    command = 'NTLMSettings'
    command = 'NetworkProfiles'
    command = 'NetworkShares'
    command = 'OSInfo'
    command = 'OptionalFeatures'
    command = 'OutlookDownloads'
    command = 'PSSessionSettings'
    command = 'PowerShell'
    command = 'PowerShellEvents'
    command = 'PowerShellHistory'
    command = 'PoweredOnEvents'
    command = 'ProcessCreationEvents'
    command = 'ProcessOwners'
    command = 'PuttyHostKeys'
    command = 'PuttySessions'
    command = 'RDPSavedConnections'
    command = 'RDPSessions'
    command = 'RDPsettings'
    command = 'SCCM'
    command = 'ScheduledTasks'
    command = 'SecureBoot'
    command = 'SlackDownloads'
    command = 'SlackPresence'
    command = 'SlackWorkspaces'
    command = 'SuperPutty'
    command = 'Sysmon'
    command = 'SysmonEvents'
    command = 'UAC'
    command = 'WMI'
    command = 'WSUS'
    command = 'WindowsAutoLogon'
    command = 'WindowsDefender'
    command = 'WindowsEventForwarding'
    command = 'WindowsFirewall'
    command_args = {}
    computer_name = computer
    computername = computer
    configs = []
    context = 3
    days = 7
    def __init__(self):
    def _print_single_key_value_object(obj):
    def close(self):
    def connect(self):
    def disconnect(self):
    def get_local_groups(self):
    def get_local_users(self):
    def get_process_cmdline_regex():
    def get_user_sids(self):
    def parse_sddl(sddl_string):
    def parse_version(version):
    def print_key_entries(obj_or_list):        
    def print_kv(obj_or_list):
    def print_props(obj_or_list):       
    def show_banner(banner: str):
    def xml(self):
    defensive_processes = {
    description = 'AWS/Google/Azure/Bluemix cloud credential files'
    description = 'All configured Office 365 endpoints (tenants and teamsites) which are synchronised by OneDrive.'
    description = 'Audit settings via the registry'
    description = 'Auto run executables/scripts/programs'
    description = 'Checks if interesting Chrome/Edge/Brave/Opera files exist'
    description = 'Checks if interesting Firefox files exist'
    description = 'Checks if interesting Slack files exist'
    description = 'CredentialGuard configuration'
    description = 'Current incoming RDP sessions (argument == computername to enumerate)'
    description = 'DNS Cache Entries'
    description = 'DotNet versions'
    description = 'Enumerates PS Session Settings from the registry'
    description = 'EnvironmentVariables'
    description = 'FileZilla configuration files'
    description = 'Finds KeePass configuration files'
    description = 'Hotfixes'
    description = 'Installed products via the registry'
    description = 'Internet Explorer favorites'
    description = 'LSA settings (including auth packages)'
    description = 'List DPAPI master keys'
    description = 'List Optional Features/Roles (via WMI)'
    description = 'List files downloaded by Outlook'
    description = 'NTLM authentication settings'
    description = 'Network shares exposed by the machine (via WMI)'
    description = 'Parses any found 
    description = 'Parses any found Chrome/Edge/Brave/Opera bookmark files'
    description = 'Parses any found Chrome/Edge/Brave/Opera history files'
    description = 'Parses any found FireFox history files'
    description = 'PowerShell script block logs (4104) with sensitive data'
    description = 'PowerShell versions and security settings'
    description = 'Process creation logs (4688) with sensitive data'
    description = 'Providers registered for AMSI'
    description = 'Registered antivirus'
    description = 'Registry autologon information'
    description = 'Remote Desktop Server/Client Settings'
    description = 'Returns the DateTime of the last system shutdown (via the registry).'
    description = 'Running non-session 0 process list with owners. For remote use.'
    description = 'Runs a specified WMI query'
    description = 'Saved Putty SSH host keys'
    description = 'Saved Putty configuration (interesting fields) and SSH host keys'
    description = 'Saved RDP connections stored in the registry'
    description = 'Scheduled tasks (via WMI) that aren
    description = 'Searches PowerShell console history files for sensitive regex matches.'
    description = 'Secure Boot configuration'
    description = 'Sysmon configuration from the registry'
    description = 'Sysmon process creation logs (1) with sensitive data'
    description = 'UAC system policies via the registry'
    description = 'Users mapped drives (via WMI)'
    description = 'Windows Defender settings (including exclusion locations)'
    description = 'Windows Event Forwarding (WEF) settings via the registry'
    description = 'Windows logon sessions'
    description = 'Windows network profiles'
    direction_args = []
    display_defender_settings(defender.GroupPolicySettings)
    display_defender_settings(defender.LocalSettings)
    dn_support_amsi = int(highest_version.split('.')[0]) >= 4 and int(highest_version.split('.')[1]) >= 8
    domain = ''
    e_vars = []
    eid = '4624'
    eid = '4648'
    elapsed_time = end_time - start_time
    elem_type = type(value[0]) if value else str
    elif applocker.EnforcementMode == 'not configured':
    elif find == 'highest':
    elif len(args) == 2:
    elif ntlm.InboundAuditing == 1:
    elif ntlm.InboundAuditing == 2:
    elif ntlm.InboundRestrictions == 1:
    elif ntlm.InboundRestrictions == 2:
    elif ntlm.LanmanCompatabilityLevel == 'Send LM 
    elif ntlm.LanmanCompatabilityLevel == 'Send NTLM response only':
    elif ntlm.LanmanCompatabilityLevel == 'Send NTLMv2 response only - Win7
    elif ntlm.LanmanCompatabilityLevel == 'Send NTLMv2 response only. DC: Refuse LM 
    elif ntlm.LanmanCompatabilityLevel == 'Send NTLMv2 response only. DC: Refuse LM':
    elif ntlm.LanmanCompatabilityLevel == 'Unknown':
    elif ntlm.LanmanCompatabilityLevel == None:
    elif ntlm.LdapSigning == 1:
    elif ntlm.LdapSigning == 2:
    elif ntlm.OutboundRestrictions == 1:
    elif ntlm.OutboundRestrictions == 2:
    elif uac.ConsentPromptBehaviorAdmin == 1:
    elif uac.ConsentPromptBehaviorAdmin == 2:
    elif uac.ConsentPromptBehaviorAdmin == 3:
    elif uac.ConsentPromptBehaviorAdmin == 4:
    elif uac.ConsentPromptBehaviorAdmin == 5:
    else:
    enable_lua = uac.EnableLua == 1 or uac.EnableLua is None
    end_time = datetime.now()
    end_time = time.time()
    end_time_utc = end_time.astimezone(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%fZ')
    enforcementModeStr = ''
    even_conn.close()
    except Exception as e:
    except KeyError as e:
    except KeyboardInterrupt:
    except json.JSONDecodeError:
    except:
    extension_exclusions = settings.ExtensionExclusions
    filter_administrator_token_enabled = uac.FilterAdministratorToken == 1
    filter_results = False
    filter_results = True
    fix_path = ''
    for access in settings.Permission:
    for action in schtask.Actions:
    for alg in SysmonHashAlgorithm:
    for av in av_info:
    for cg in wmi_data:
    for conf in filezilla.Configs:
    for config in super_putty.Configs:
    for d in dns_data:
    for d in downloads.Downloads:
    for d in env_data:
    for d in wmi_data:
    for d in wmidata:
    for data in xml_event:
    for dir in dirs:
    for download in s_downloads.Downloads:
    for event in xml_event:
    for f in directory_listing:
    for f in iefav.Favorites:
    for fixes in fix_data:
    for group in groups:
    for history in history.History:
    for i in autorun_locs:
    for i in range(len(sorted_users)):
    for k in dpapi.MasterKeys:
    for key in keys:
    for key in phk.HostKeys:
    for log_name in powershell_logs:
    for logged in wmi_data:
    for match in matches:
    for module_str in module_splits:
    for o in os_query:
    for o in wmi_data:
    for obj in wmi_data:
    for pguid in profile_guids:
    for plugin in plugins:
    for proc in procs:
    for proc in wmi_data:
    for prod in product_keys:
    for provider_clsid in provider_clsids:
    for query_result in wmi.QueryResults:
    for rc in run_commands.Commands:
    for rule_location in rule_locations:
    for s in searcher:
    for scope_id in all_scope_ids:
    for sess in wmi_data_two:
    for sessions in puttysessions.Sessions:
    for shares in wmi_data:
    for sid in sids:
    for trigger in schtask.Triggers:
    for url in history.URLs:
    for url in ie.Urls:
    for user in local_users:
    for v in dotnet_obj.InstalledCLRVersions:
    for var in powershell.InstalledCLRVersions:
    for var in powershell.InstalledVersions:
    for vv in dotnet_obj.InstalledDotNetVersions:
    for w in wd:
    for workspace in slack.Workspaces:
    google_locations = [
    group = parser.add_argument_group('authentication')
    group_wd = WindowsDefendersettings()
    groups = samr_conn.get_local_groups()
    hashing_alg = SysmonHashAlgorithm(0)
    high_int = True
    hist_regex = re.compile(rb'(http
    host_name = target
    i = 0
    if 'Google' in chrome.Folder :
    if adm_pwd_enabled is not None and adm_pwd_enabled != '':
    if applocker.AppIdSvcState != 'Running':
    if asr_settings.Enabled:
    if bytes_data is None or len(bytes_data) == 0:
    if chrome.CookiesLastModified:
    if chrome.Folder:
    if chrome.HistoryLastModified:
    if chrome.LoginDataLastModified:
    if dot_net_four is not None:
    if dot_net_threefive is not None:
    if dotnet_obj.OsSupportsAmsi and dn_support_amsi and int(lowest_version.split('.')[0]) == 3 or int(lowest_version.split('.')[0]) == 4 and int(lowest_version.split('.')[1]) < 8:
    if elem_type == str:
    if enable_lua and local_account_filter_policy_enabled:
    if enable_lua and not local_account_filter_policy_enabled and filter_administrator_token_enabled:
    if enable_lua and not local_account_filter_policy_enabled and not filter_administrator_token_enabled:
    if find == 'lowest':
    if firefox.CredentialFile3LastModified != datetime.min:
    if firefox.CredentialFile4LastModified != datetime.min:
    if firefox.HistoryLastModified != datetime.min:
    if firewall.Domain.Present:
    if firewall.Private.Present:
    if firewall.Public.Present:
    if firewall.Standard.Present:
    if group == None:
    if group.Members is not None:
    if info.BootTimeUtc.tzinfo is None:
    if info.CurrentTimeUtc.tzinfo is None:
    if int(highest_version.split('.')[0]) == 4 and int(highest_version.split('.')[1]) >= 8:
    if keys is not None and len(keys) != 0:
    if laps.AdmPwdEnabled == 'False':
    if len(args) == 1:
    if len(args) > 0:
    if len(args) >= 1:
    if len(args) >=2:
    if len(asr_settings.Exclusions) > 0:
    if len(bookmark.Bookmarks) > 0:
    if len(extension_exclusions) != 0:
    if len(firewall.Rules) > 0:
    if len(path_exclusions) != 0:
    if len(process_exclusions) != 0:
    if len(rdp.Connections) > 0:
    if len(sys.argv) == 1:
    if level:
    if line:
    if logon.TargetOutboundUserName != '-':
    if not applocker.Configured:
    if not enable_lua:
    if ntlm.InboundAuditing == 0:
    if ntlm.InboundRestrictions == 0:
    if ntlm.LanmanCompatabilityLevel == 'Send LM 
    if ntlm.LdapSigning == 0:
    if ntlm.NTLMMinClientSec is not None:
    if ntlm.NTLMMinServerSec is not None:
    if ntlm.OutboundRestrictions == 0:
    if options.command_args:
    if powershell.ModuleLogging:
    if powershell.ModuleNames is not None:
    if powershell.OsSupportsAmsi and lowest_version.major < 3:
    if powershell.ScriptBlockLogging:
    if ps_v2 is not None:
    if ps_v4p is not None:
    if reg_hash_alg is not None and reg_hash_alg != 0:
    if reg_hash_alg is not None or reg_options is not None or reg_sysmon_rules is not None:
    if reg_options is not None:
    if reg_sysmon_rules is not None:
    if rra_type:
    if settings is None:
    if settings is not None and len(settings) != 0:
    if settings is not None:
    if shutdown_bytes is not None:
    if slack.CookiesLastModified is not datetime.min:
    if slack.DownloadsLastModified is not datetime.min:
    if slack.WorkspacesLastModified is not datetime.min:
    if smb_conn.connect():
    if uac.ConsentPromptBehaviorAdmin == 0:
    if ubr:
    if uefi_state is None:
    if wmi_data is None:
    inbound_audit_str = None
    inbound_rest_str = None
    installed = False
    installed_clr = []
    installed_clr.extend(get_clr_versions(smb_conn))
    installed_clr_versions = get_clr_versions(smb_conn)
    installed_dotnet_versions = []
    installed_versions = []
    installed_versions.extend(get_powershell_versions(wmi_conn))
    installed_versions.extend(get_pscore_versions(wmi_conn))
    interesting_processes = {
    isvm = is_vm(wmi_conn)
    kerberos_users = set()
    key_name = ''
    last_days = 10
    last_days = 7
    ldap_signing_str = None
    level = rdpsettings.ClientSettings.ServerAuthLevel
    lmstr = None
    local_account_filter_policy_enabled = uac.LocalAccountTokenFilterPolicy == 1
    local_admin = True
    local_users = samr_conn.get_local_users()
    local_wd = WindowsDefendersettings()
    log_name = 'Microsoft-Windows-Sysmon/Operational'
    log_name = 'Security'
    log_name = 'System'
    logger.init()
    logon_map = {}
    main()
    masterkeys = []
    microseconds = (file_time - unix_epoch_offset) // 10
    mkey = re.compile(r'[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}')
    net_path = '
    none = 0x00000000
    ntlm_v1_users = set()
    ntlm_v2_users = set()
    options = parser.parse_args()
    os_amsi = int(os_version) >= 10
    os_query = wmi_conn.wmi_get('SELECT Version FROM Win32_OperatingSystem')
    os_sup_amsi = int(os_ver_major) >= 10
    os_ver_major = get_os_version(wmi_conn).split('.')[0]
    os_version = get_os_version(wmi_conn).split('.')[0]
    oubound_rest_str = None
    path_exclusions = settings.PathExclusions
    path_list = [
    powershell_logs = [
    print('
    print('    ------------              ------------              --------')
    print('    LastAccessed              LastModified              FileName')
    print('  Installed CLR Versions')
    print('  [
    print('Command not implemented')
    print('Locally-defined Settings:')
    print('RDP Server Settings:')
    print('Rules:')
    print('Searching Sysmon process creation logs (Sysmon ID 1) for sensitive data.
    print('Searching process creation logs (EID 4688) for sensitive data')
    print('Searching script block logs (EID 4104) for sensitive data.
    print()
    print()    
    print(args)
    print(f'
    print(f'      Enabled            : {powershell.ScriptBlockLogging}')
    print(f'      Invocation Logging : {powershell.ScriptBlockInvocationLogging}')
    print(f'      OS Supports AMSI: {powershell.OsSupportsAmsi}')
    print(f'      OS supports AMSI           : {dotnet_obj.OsSupportsAmsi}')
    print(f'     .NET version support AMSI   : {dn_support_amsi}')
    print(f'  Downloads ({s_downloads.UserName}):
    print(f'  FileZilla Configs ({filezilla.UserName}):
    print(f'  Folder : {dpapi.Folder}
    print(f'  Name : {settings.Plugin}')
    print(f'  SuperPutty Configs ({super_putty.UserName}):
    print(f'  Workspaces ({slack.UserName}):
    print(f'  {'Architecture':<30}:  {info.Architecture}')
    print(f'  {'Build':<30}:  {info.Build}')
    print(f'  {'BuildBranch':<30}:  {info.BuildBranch}')
    print(f'  {'CurrentMajorVersionNumber':<30}:  {info.CurrentMajorVersionNumber}')
    print(f'  {'CurrentTimeUtc':<30}:  {current_utc_formatted} (Local time: {local_time_formatted})')
    print(f'  {'CurrentVersion':<30}:  {info.CurrentVersion}')
    print(f'  {'Domain Name':<30}:  {info.Domain}')
    print(f'  {'EditionID':<30}:  {info.EditionId}')
    print(f'  {'HighIntegrity':<30}:  {info.IsHighIntegrity}')
    print(f'  {'Hostname':<30}:  {info.Hostname}')
    print(f'  {'InputLanguage':<30}:  {info.InputLanguage}')
    print(f'  {'InstalledInputLanguages':<30}:  {info.InstalledInputLanguages}')
    print(f'  {'IsLocalAdmin':<30}:  {info.IsLocalAdmin}')
    print(f'  {'IsVirtualMachine':<30}:  {info.IsVirtualMachine}')
    print(f'  {'MachineGuid':<30}:  {info.MachineGuid}')
    print(f'  {'ProcessorCount':<30}:  {info.ProcessorCount}')
    print(f'  {'ProductName':<30}:  {info.ProductName}')
    print(f'  {'ReleaseID':<30}:  {info.ReleaseId}')
    print(f'  {'TimeZone':<30}:  {info.TimeZone}')
    print(f'  {'TimeZoneOffset':<30}:  {info.TimeZoneUtcOffset}')
    print(f'  {'Username':<30}:  {info.Username}')
    print(f'  {event.TimeCreatedUtc:<22}  {event.User:<30} {event.Match}')
    print(f'  {firefox.Folder}
    print(f'  {hotfix.HotFixID:<10} {hotfix.InstalledOnUTC:<22} {hotfix.Description:<30} {hotfix.InstalledBy}')
    print(f'  {phk.Sid} :')
    print(f'  {provider.Sid} :')
    print(f'  {puttysessions.Sid} :
    print(f'  {slack.Folder}
    print(f'HashingAlgorithm: {sysmon.HashingAlgorithm}')
    print(f'History ({history.FilePath}):
    print(f'Installed:        {sysmon.Installed}')
    print(f'Internet Explorer typed URLs for the last {days} days
    print(f'Listing 4624 Account Logon Events for the last {last_days} days.
    print(f'Listing 4648 Explicit Credential Events - A process logged on using plaintext credentials over last {last_days} days')
    print(f'Location                     : {firewall.Location}
    print(f'Options:          {sysmon.Options}')
    print_banner()
    proc_count = wmi_conn.get_env_var('NUMBER_OF_PROCESSORS')
    proc_regex = MiscUtil.get_process_cmdline_regex()
    process_commands(options)
    process_exclusions = settings.ProcessExclusions
    product_keys = [
    profile_args = []
    protocol_args = []
    protocols = {
    ps_regex = MiscUtil.get_process_cmdline_regex()
    results = []
    return ''
    return None
    return Version(version_str)
    return [string[i:i
    return bmark
    return command_args
    return data['Version']
    return e_vars
    return installed_clr
    return results
    return versions
    return {
    rra_type = rdpsettings.ClientSettings.RestrictedRemoteAdministrationType
    rule_locations = [
    rules = []
    samr_conn.disconnect()
    searcher = wmi_conn.wmi_get('Select 
    searcher = wmi_conn.wmi_get(query)
    server = rdpsettings.ServerSettings
    sids = wmi_conn.get_user_sids()
    smb_conn.close()
    sorted_users = sorted(users)
    start_time = date.today() - timedelta(days=days)
    start_time = datetime.now() - timedelta(days=last_days)
    start_time = time.time()
    start_time_utc = start_time.astimezone(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%fZ')
    subject_user = f'{logon.SubjectDomainName}
    subject_user = f'{logon.SubjectDomain}
    sysmon_options = SysmonOptions(0)
    sysmon_regex = MiscUtil.get_process_cmdline_regex()
    target_outbound_user = ''
    target_user = f'{logon.TargetDomainName}
    target_user = f'{logon.TargetDomain}
    temp = []
    try:
    type_dict = {
    unix_epoch_offset = int(delta.total_seconds() 
    uptime = current_time - boot_time
    url_regex = re.compile(rb'(http
    urls = []
    user_path = '
    user_regex = None
    utc_dt = datetime.fromisoformat(logon.TimeCreatedUtc).replace(tzinfo=timezone.utc)
    version_str = version.split('-')[0]
    versions = []
    versions = [get_version_from_string(v) for v in powershell.InstalledVersions]
    wd = wmi_conn.wmi_get('Select Domain from Win32_ComputerSystem')
    well_known_sids = {
    wmi_conn.close()
    wmi_data = None
    wmi_data = wmi_conn.get_wmi_object('SELECT 
    wmi_data = wmi_conn.wmi_get('SELECT 
    wmi_data = wmi_conn.wmi_get('SELECT Version FROM Win32_OperatingSystem')
    wmi_data_two = wmi_conn.wmi_get('SELECT 
    wmi_query = 'Select 
    yield RDPSettings(
    yield WMI_Data(searcher)
    }
   //(_
   L   
 (length 
 ({group.GroupComment})
 /     
 0x16)
 1) 
 1):
 1e7)
 22 
 4:offset 
 AMSIProviders          - Providers registered for AMSI
 AntiVirus              - Registered antivirus (via WMI)
 AuditPolicyRegistry    - Audit settings via the registry
 AutoRuns               - Auto run executables/scripts/programs
 BUILTIN groups
 Binary
 CarSeat: A junior Seatbelt
 Carseat - A Junior Seatbelt
 ChromiumBookmarks      - Parses any found Chrome/Edge/Brave/Opera bookmark files
 ChromiumHistory        - Parses any found Chrome/Edge/Brave/Opera history files
 ChromiumPresence       - Checks if interesting Chrome/Edge/Brave/Opera files exist
 CloudCredentials       - AWS/Google/Azure/Bluemix cloud credential files
 CloudSyncProviders     - All configured Office 365 endpoints (tenants and teamsites) which are synchronised by OneDrive.
 Copyright (C) 2024 Steven F
 Copyright (C) Iwan Timmer.
 CredGuard              - CredentialGuard configuration
 Credits
 Currently not correct
 DNSCache               - DNS cache entries (via WMI)
 DWORD
 Description
 Don't think there is a way to get user_type info unless using USER_INFO_3 struct
 DotNet                 - DotNet versions
 DpapiMasterKeys        - List DPAPI master keys
 EnvironmentVariables   - Current environment variables
 Expanded String
 FROM MSFT_DNSClientCache')
 FROM MSFT_ScheduledTask')
 FROM Win32_DeviceGuard')
 FROM Win32_LoggedOnUser')
 FROM Win32_LogonSession')
 FROM Win32_Process WHERE SessionID != 0')
 FROM Win32_Process')
 FROM Win32_QuickFixEngineering')
 FROM Win32_Share')
 FROM win32_networkconnection')
 FileZilla              - FileZilla configuration files
 FirefoxHistory         - Parses any found FireFox history files
 FirefoxPresence        - Checks if interesting Firefox files exist
 GNU General Public License for more details.
 Hotfixes               - Installed hotfixes (via WMI)
 IEFavorites            - Internet Explorer favorites
 Impacket bug needs to be fixed first
 Impacket has a bug getting MSFT_ScheduledTask Settings property so we have to get everything except that
 InstalledProducts      - Installed products via the registry
 KeePass                - Finds KeePass configuration files
 LSASettings            - LSA settings (including auth packages)
 LastShutdown           - Returns the DateTime of the last system shutdown (via the registry).
 LogonSessions          - Windows logon sessions
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 MappedDrives           - Users' mapped drives (via WMI)
 More data
 Multi-String
 NTLM - Use NTLMv2 session security if negotiated'
 NTLM - Use NTLMv2 session security if negotiated':
 NTLM responses'
 NTLM responses':
 NTLM'
 NTLM':
 NTLMSettings           - NTLM authentication settings
 NetworkProfiles        - Windows network profiles
 NetworkShares          - Network shares exposed by the machine (via WMI)
 Not supported.
 OptionalFeatures       - List Optional Features/Roles (via WMI)
 OutlookDownloads       - List files downloaded by Outlook
 PSSessionSettings      - Enumerates PS Session Settings from the registry
 PowerShell             - PowerShell versions and security settings
 PowerShellEvents       - PowerShell script block logs (4104) with sensitive data.
 PowerShellHistory      - Searches PowerShell console history files for sensitive regex matches.
 ProcessCreationEvents  - Process creation logs (4688) with sensitive data.
 ProcessOwners          - Running non-session 0 process list with owners. For remote use.
 PuttyHostKeys          - Saved Putty SSH host keys
 PuttySessions          - Saved Putty configuration (interesting fields) and SSH host keys
 QWORD
 RDPSavedConnections    - Saved RDP connections stored in the registry
 RDPsettings            - Remote Desktop Server/Client Settings
 Regular expression to match ACE entries in SDDL
 SHARING_VIOLATION
 SecureBoot             - Secure Boot configuration
 SessionSecurity.NTLMv2):
 SlackDownloads         - Parses any found 'slack-downloads' files
 SlackPresence          - Checks if interesting Slack files exist
 SlackWorkspaces        - Parses any found 'slack-workspaces' files
 String
 SuperPutty             - SuperPutty configuration files
 Sysmon                 - Sysmon configuration from the registry
 SysmonEvents           - Sysmon process creation logs (1) with sensitive data.
 System and Well-Known SIDs
 TODO: Maybe implement LSA enumeration
 TODO: Test this to make sure it actually gets the GUID
 Tattempt to unlock a workstation.
 This file is part of Carseat.
 This may be problematic
 This program is free software
 UAC                    - UAC system policies via the registry
 Useage
 WMI                    - Runs a specified WMI query
 WindowsAutoLogon       - Registry autologon information
 WindowsDefender        - Windows Defender settings (including exclusion locations)
 WindowsEventForwarding - Windows Event Forwarding (WEF) settings via the registry
 You should have received a copy of the GNU General Public License
 alg.value:
 along with this program
 and give any other recipients of the Program a copy of this License along with the Program.
 and that you know you can do these things.
 as published by the Free Software Foundation
 attempt to unlock a workstation
 attempt to use the cached credentials without going out across the network
 attrs
 but WITHOUT ANY WARRANTY
 caller can clone its current token and specify new credentials for outbound connections
 default'
 default':
 either version 2
 even6.EvtReadNewestToOldest
 event_size]
 filetime['LowPart']
 from AntiVirusProduct')
 from Win32_ComputerSystem'
 from Win32_ComputerSystem')
 https://github.com/fortra/impacket/issues/1845
 i:12 
 i])[0] for i in range(number_of_sub_ids)]
 if self.tid is None:
 installation
 it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.
 j < len(script_block_parts):
 j >= len(script_block_parts):
 j].strip())
 keep intact all the notices that refer to this License and to the absence of any warranty
 length 
 logging on interactively.
 logging using a network.
 logon for a batch process.
 logon for a service account.
 modify it under the terms of the GNU General Public License
 network logon with cleartext credentials
 num_values 
 re.MULTILINE)
 re.MULTILINE)]
 self._element.length
 self._name.length
 self._name.length 
 self._name.length)
 self._name.length))
 self._value.length
 self._xml.length 
 self._xml.length)
 self.length]
 terminal server session that is both remote and interactive
 the Settings property has a property named MaintenanceSetting which sometimes does not exist and that throws an error in the WMI library
 timedelta(microseconds=microseconds)).date()
 timedelta(seconds=delta)
 user_type_map = {
 values_length
 values_length)
 v{version}
 we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally.
 will run all modules since they are all considered remote. 
 without even the implied warranty of
 you can redistribute it and/or
 {group.ComputerName}
"                                            url = match.group(0).decode('utf-8', errors='replace').strip()"
"                                    credential_four_last_mod = smb_conn.get_last_write_time(share, ff_cred_four)"
"                                    credential_three_last_mod = smb_conn.get_last_write_time(share, ff_cred_three)"
"                                    download.StartTime = datetime.fromtimestamp(int(dl[""startTime""]), tz=timezone.utc)"
"                                    hist_data = smb_conn.read_special(share, ff_history_file)"
"                                    history_last_mod = smb_conn.get_last_write_time(share, ff_history_file)"
"                                    url = match.group(0).decode('utf-8', errors='replace').strip()"
"                                download.DownloadPath = str(dl[""downloadPath""])"
"                                download.TeamID = str(dl[""teamId""])"
"                                download.UserID = str(dl[""userId""])"
"                                masterkey = MasterKey(mk_name, mk_lastaccessed, mk_lastaccessed)"
"                                mk_lastaccessed = smb_conn.get_last_access_time(share, key_path)"
"                                password = ""<PROTECTED BY MASTERKEY>"""
"                                print(f""Error getting properties from ClassPart: {str(e)}"")"
"                                raise Exception(f""IO exception, history file likely in use (i.e. browser is likely running): {e}"")"
"                                workspace.Domain = str(dl[""domain""])"
"                                workspace.ID = str(dl[""id""])"
"                                workspace.Name = str(dl[""name""])"
"                                yield FirefoxPresence(fix_path, history_last_mod, credential_three_last_mod, credential_four_last_mod)"
"                            '(KRB5CCNAME) based on target parameters. If valid credentials cannot be found, it will use the '"
"                            down = OutlookDownload(fn, la ,la)"
"                            encoding = temp_password.get(""encoding"")"
"                            hist_data = smb_conn.read_special(share, f'{ch_hist_path}"
"                            if ""domain"" in dl:"
"                            if ""downloadPath"" in dl:"
"                            if ""id"" in dl:"
"                            if ""name"" in dl:"
"                            if ""startTime"" in dl:"
"                            if ""teamId"" in dl:"
"                            if ""userId"" in dl:"
"                            if encoding == ""base64"":"
"                            if f""'{options.group}'"" in source or f'""{options.group}""' in source:"
"                            if smb_conn.file_exists(share, ff_cred_four):"
"                            if smb_conn.file_exists(share, ff_cred_three):"
"                            if smb_conn.file_exists(share, ff_history_file):"
"                            json_data = smb_conn.show_file_content(share, ch_bm_path, 'Bookmarks')"
"                            la = smb_conn.get_last_access_time(share, f'{dl_location}"
"                            output = {key: details['value'] for key, details in values.items()}"
"                            print(f""Error getting values: {str(e)}"")"
"                        'EncodingLength': instance_type['EncodingLength'],"
"                        'InstanceFlags': instance_type['InstanceFlags'],"
"                        a_cred_size = smb_conn.get_file_size(share, acred_location)"
"                        a_last_accessed = smb_conn.get_last_access_time(share, acred_location)"
"                        a_last_modified = smb_conn.get_last_write_time(share, acred_location)"
"                        b_cred_size = smb_conn.get_file_size(share, bcred_location)"
"                        b_last_accessed = smb_conn.get_last_access_time(share, bcred_location)"
"                        b_last_modified = smb_conn.get_last_write_time(share, bcred_location)"
"                        conf = FileZillaConfig(fixed_path, name, host, port, protocol, user, password)"
"                        element = Element(buf, ofs)"
"                        element = Substitution(buf, ofs)"
"                        element = Value(buf, ofs)"
"                        for _, dl in first_level_dict.items():"
"                        g_cred_size = smb_conn.get_file_size(share, gcred_location)"
"                        g_last_accessed = smb_conn.get_last_access_time(share, gcred_location)"
"                        g_last_modified = smb_conn.get_last_write_time(share, gcred_location)"
"                        host = server.find(""Host"").text if server.find(""Host"") is not None else """""
"                        if ""command_group"" in source:"
"                        if script_block_parts[i - j].strip() == """":"
"                        name = ""<RECENT SERVER>"""
"                        password = ""<NULL>"""
"                        port = server.find(""Port"").text if server.find(""Port"") is not None else """""
"                        print(""Unknown intern next_token"", hex(next_token), hex(ofs))"
"                        print(f""    {item}"")"
"                        print(f""WMI query iteration error: {e}"")"
"                        protocol = server.find(""Protocol"").text if server.find(""Protocol"") is not None else """""
"                        temp_name = server.find(""Name"")"
"                        temp_password = server.find(""Pass"")"
"                        user = server.find(""User"").text if server.find(""User"") is not None else """""
"                        yield ChromiumHistory(user, ch_hist_path, urls)"
"                        yield ChromiumPresence(chrome_base, history, cookies, login_data, chrome_version)"
"                        yield CloudCredentials('Azure', azure_base, a_last_accessed, a_last_modified, a_cred_size)"
"                        yield CloudCredentials('Bluemix', bluemix_base, b_last_accessed, b_last_modified, b_cred_size)"
"                        yield CloudCredentials('Google', google_base, g_last_accessed, g_last_modified, g_cred_size)"
"                        yield FileZilla(username, configs)"
"                    'class': type_desc,"
"                    'comment': item['Description'] if hasattr(item, 'Description') else ''"
"                    'comment': user_info['AdminComment'] if hasattr(user_info, 'AdminComment') else ''"
"                    'last_logon': self._filetime_to_datetime(user_info['LastLogon']),"
"                    'name': item['Name'],"
"                    'name': name['Name'],"
"                    'name': user['Name'],"
"                    'num_logins': user_info['LogonCount'],"
"                    'pwd_last_set': self._filetime_to_datetime(user_info['PasswordLastSet']),"
"                    'rid': user_rid,"
"                    'sid': sids[i],"
"                    'sid_type': sid_type,"
"                    'user_type': None,"
"                    (""Allow"" in action_args and rule.Action == ""Allow"") or"
"                    (""Block"" in action_args and rule.Action == ""Block"") or"
"                    (""Domain"" in profile_args and rule.Profiles.strip() == ""Domain"") or"
"                    (""In"" in direction_args and rule.Direction == ""In"") or"
"                    (""Out"" in direction_args and rule.Direction == ""Out"") or"
"                    (""Private"" in profile_args and rule.Profiles.strip() == ""Private"") or"
"                    (""Public"" in profile_args and rule.Profiles.strip() == ""Public"")):"
"                    (""TCP"" in protocol_args and rule.Protocol == ""TCP"") or"
"                    (""UDP"" in protocol_args and rule.Protocol == ""UDP"") or"
"                    1: 'User',"
"                    2: 'Group',"
"                    3: 'Domain',"
"                    4: 'Alias',"
"                    5: 'WellKnownGroup',"
"                    6: 'DeletedAccount',"
"                    7: 'Invalid',"
"                    8: 'Unknown',"
"                    9: 'Computer',"
"                    access.append(PluginAccess(principal, sid, access_str))"
"                    blob_bytes = smb_conn.read_file_raw(share, proc_key)"
"                    business = result == ""1"""
"                    conf_size = smb_conn.get_file_size(share, kp_config)"
"                    config = SuperPuttyConfig(file_path, session_id, session_name, host, port, protocol, username, extra_args)"
"                    content = smb_conn.show_file_content(share, slack_downloads_base, sd)"
"                    content = smb_conn.show_file_content(share, slack_workspace_base, sw)"
"                    cookies = smb_conn.get_last_write_time(share, chrome_cookies)"
"                    cookies_last_write_time = smb_conn.get_last_write_time(share, cookie_base)"
"                    cred_size = smb_conn.get_file_size(share, aws_key)"
"                    date = f""{year}-{month}-{day}"""
"                    directories = smb_conn.list_directory(share, firefox_base_path)"
"                    directories = smb_conn.list_directory(share, firefox_hist_path)"
"                    downloads_last_write_time = smb_conn.get_last_write_time(share, downloads_base)"
"                    extra_args = session.get(""ExtraArgs"")"
"                    f""{pe.VS_FIXEDFILEINFO[0].FileVersionLS "
"                    f""{pe.VS_FIXEDFILEINFO[0].FileVersionLS >> 16}."""
"                    f""{pe.VS_FIXEDFILEINFO[0].FileVersionMS "
"                    f""{pe.VS_FIXEDFILEINFO[0].FileVersionMS >> 16}."""
"                    f""{pe.VS_FIXEDFILEINFO[0].ProductVersionLS "
"                    f""{pe.VS_FIXEDFILEINFO[0].ProductVersionLS >> 16}."""
"                    f""{pe.VS_FIXEDFILEINFO[0].ProductVersionMS "
"                    f""{pe.VS_FIXEDFILEINFO[0].ProductVersionMS >> 16}."""
"                    files = smb_conn.list_directory(share, dl_location)"
"                    files = smb_conn.list_directory(share, mk_dir)"
"                    for _, first_level_dict in deserialized.items():"
"                    for j in range(1, i "
"                    for j in range(1, len(script_block_parts)):"
"                    formatted_date = parsed_date.strftime(""%a %d %b %Y %H:%M:%S"")"
"                    guid_string = f""{{{str(guid_masterkey)}}}"""
"                    history = smb_conn.get_last_write_time(share, chrome_history)"
"                    host = session.get(""Host"")"
"                    if 'Properties' in instance_data and hasattr(instance_type, 'getValues'):"
"                    if hasattr(module, ""command_base""):"
"                    if hasattr(ret_vals, 'uValue'):"
"                    if not re.match(pattern, k):"
"                    if smb_conn.file_exists(share, acred_location):"
"                    if smb_conn.file_exists(share, bcred_location):"
"                    if smb_conn.file_exists(share, bm):"
"                    if smb_conn.file_exists(share, ch_hist_path):"
"                    if smb_conn.file_exists(share, gcred_location):"
"                    install_date = datetime.strptime(date, ""%Y-%m-%d"")"
"                    key_size = smb_conn.get_file_size(share, proc_key)"
"                    last_accessed = smb_conn.get_last_access_time(share, aws_key)"
"                    last_accessed = smb_conn.get_last_access_time(share, kp_config)"
"                    last_accessed = smb_conn.get_last_access_time(share, proc_key)"
"                    last_modified = smb_conn.get_last_write_time(share, aws_key)"
"                    last_modified = smb_conn.get_last_write_time(share, kp_config)"
"                    last_modified = smb_conn.get_last_write_time(share, proc_key)"
"                    login_data = smb_conn.get_last_write_time(share, chrome_logindata)"
"                    module = importlib.import_module(f""commands.{module_name}"")"
"                    not rule.Name == ""Shell Input Application"" and rule.Action == ""Block"""
"                    not rule.Name.startswith(""@"") and "
"                    objects = iEnumWbemClassObject.Next(0xffffffff, 1)"
"                    parsed_date = datetime.strptime(mp_val, ""%Y-%m-%d %H:%M:%S"")"
"                    parsed_date = datetime.strptime(value, ""%Y-%m-%d %H:%M:%S"")"
"                    port = session.get(""Port"")"
"                    print(f""      "
"                    print(f""      {key:<30}:   {val}"")"
"                    print(f""  {attr:<30} : {'' if value is None else value}"")"
"                    print(f""  {value} :"")"
"                    print(f""Error executing {module.__name__}: {e}"")"
"                    print(f""Error: {target_command} does not have a command_base function"")"
"                    print(f""Warning: Could not import {module_name}"")"
"                    print(f""Warning: Error processing {module_name}: {e}"")"
"                    protocol = session.get(""Proto"")"
"                    rdr = smb_conn.show_file_content(share, favorites_base, u.get_longname())"
"                    result = wmi_conn.get_dword_value('HKU', f'{sid}"
"                    result = wmi_conn.get_string_value('HKU', f'{sid}"
"                    servers = xmlDoc.findall("".//RecentServers"")"
"                    session_name = session.get(""SessionName"")"
"                    urls.append(TypedURL(url_time, v.strip()))"
"                    username = session.get(""Username"")"
"                    val = bytes(value.uValue) if hasattr(value, 'uValue') else None"
"                    val = value.sValue if hasattr(value, 'sValue') else None"
"                    val = value.uValue if hasattr(value, 'uValue') else None"
"                    value = classObject.GetBinaryValue(hive_num, key_path, name)"
"                    value = classObject.GetDWORDValue(hive_num, key_path, name)"
"                    value = classObject.GetExpandedStringValue(hive_num, key_path, name)"
"                    value = classObject.GetMultiStringValue(hive_num, key_path, name)"
"                    value = classObject.GetQWORDValue(hive_num, key_path, name)"
"                    value = classObject.GetStringValue(hive_num, key_path, name)"
"                    workspace_last_write_time = smb_conn.get_last_write_time(share, workspace_base)"
"                    yield CloudCredentials('AWS', aws_base, last_accessed, last_modified, cred_size)"
"                    yield DPAPIMasterKeys(fixed_dir, keys)"
"                    yield FirefoxHistory(user, history)"
"                    yield KeePass(found_file, last_accessed, last_modified, '', conf_size)"
"                    yield KeePass(found_file, last_accessed, last_modified, guid_string, key_size)"
"                    yield OutlookDownloads(fix_dir, downloads)"
"                    yield SlackDownloads(user, downloads)"
"                    yield SlackPresence(slack_base, cookies_last_write_time, workspace_last_write_time, downloads_last_write_time)"
"                    yield SlackWorkspaces(user, workspace)"
"                    yield SuperPutty(user, configs)"
"                    yield SysmonEvent(data['TimeCreated.SystemTime'], data['EventId'], user_name, m.group())"
"                 0: ""Guest"","
"                 1: ""User"","
"                 2: ""Administrator"""
"                ""AN"": ""Anonymous"","
"                ""AU"": ""Authenticated Users"","
"                ""AgentFwd"""
"                ""BA"": ""BUILTIN"
"                ""BU"": ""BUILTIN"
"                ""ConnectionSharing"","
"                ""HostName"","
"                ""IU"": ""Interactive Users"","
"                ""LA"": ""Local Administrator"""
"                ""NO"": ""Network Configuration Operators"","
"                ""PortForwardings"","
"                ""PublicKeyFile"","
"                ""SY"": ""NT AUTHORITY"
"                ""SessionName"": session_name"
"                ""UserName"","
"                ""WD"": ""Everyone"","
"                attr = Attribute(buf, ofs)"
"                c = RunCommand(k, v)"
"                chrome_version = smb_conn.get_version_info(share, chrome_path)"
"                context_joined = """
"                doc = smb_conn.show_file_content(share, path, xml_file)"
"                domain_profile_inbound = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"                domain_profile_notifications = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"                domain_profile_outbound = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"                dt = datetime.fromtimestamp(last_access_time, tz=timezone.utc)"
"                dt = datetime.fromtimestamp(last_write_time, tz=timezone.utc)"
"                event_data[f""{elem.tag.split('}')[1]}.{attr_name}""] = attr_value"
"                file_data = smb_conn.show_file_content(share, fz_path, f)"
"                for attr, value in vars(obj).items():"
"                for k, v in o.items():"
"                for mp_key, mp_val in od_mount_points.items():"
"                for principal, sid, access_str in parse_sddl(sddl):"
"                formatted_time = local_dt.strftime(""%m/%d/%Y %I:%M:%S %p"")"
"                if hasattr(module, ""command_base""):"
"                if isinstance(value, list):"
"                if key != ""PSComputerName"":"
"                if not smb_conn.file_exists(share, f'{path}"
"                if not smb_conn.file_exists(share, file_path):"
"                if not smb_conn.file_exists(share, slack_base):"
"                if smb_conn.file_exists(share, aws_key):"
"                if smb_conn.file_exists(share, cookie_base):"
"                if smb_conn.file_exists(share, downloads_base):"
"                if smb_conn.file_exists(share, f'{slack_downloads_base}"
"                if smb_conn.file_exists(share, f'{slack_workspace_base}"
"                if smb_conn.file_exists(share, firefox_base_path):"
"                if smb_conn.file_exists(share, firefox_hist_path):"
"                if smb_conn.file_exists(share, kp_config):"
"                if smb_conn.file_exists(share, proc_key):"
"                if smb_conn.file_exists(share, sysdll):"
"                if smb_conn.file_exists(share, workspace_base):"
"                lsad.hLsarClose(self._lsat_dce, policy_handle)          "
"                module = importlib.import_module(f""commands.{target_command}"")"
"                pattern = r""Id"
"                principal = f""BUILTIN"
"                principal=principal,"
"                print(""Unknown element next_token"", hex(next_token), hex(ofs))"
"                print(""Version information not found in the file."")"
"                print(f""      {key:<30}:   {val}"")"
"                print(f""  {attr:<30} : {'' if value is None else value}"")"
"                print(f""  {value_name:<30}: {value['value']}"")        "
"                print(f""Error: Command '{module_name}' not found"")"
"                print(f""Error: {e}"")"
"                print(f""Failed to connect to {self.server}"")"
"                print_array_value(value_type, value_name, value)"
"                private_profile_inbound = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"                private_profile_notifications = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"                private_profile_outbound = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"                public_profile_inbound = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"                public_profile_notifications = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"                public_profile_outbound = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"                result = "","".join(value)"
"                result = value.join(',')"
"                result = wmi_conn.get_string_value('HKU', f'{sid}"
"                result[key] = ordered_dict[key].get('value', None)"
"                return """""
"                return {k: parse_value(v) for k, v in value.items()}"
"                rpctransport.set_credentials(self.username, self.password, self.domain, self.lmhash, self.nthash, self.aesKey)"
"                rpctransport.set_kerberos(self.doKerberos, kdcHost=self.target)"
"                rule = wmi_conn.get_string_value('HKLM', f""Software"
"                samr.hSamrCloseHandle(self._samr_dce, user_handle)"
"                security_identifier=sid,"
"                self._smb_conn.kerberosLogin(self.username, self.password, self.domain, self.lmhash, self.nthash, self.aesKey, self.kdcHost)"
"                self._smb_conn.login(self.username, self.password, self.domain, self.lmhash, self.nthash)"
"                self.connection.getFile(share, file_path, file_obj.write, shareAccessMode=0x7)"
"                self.connection.kerberosLogin(self.username, self.password, self.domain, self.lmhash, self.nthash, self.aesKey, self.kdcHost)"
"                self.connection.login(self.username, self.password, self.domain, self.lmhash, self.nthash)"
"                servers = xmlDoc.findall("".//Servers"")"
"                sessions = root.findall("".//SessionData"")"
"                standard_profile_inbound = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"                standard_profile_notifications = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"                standard_profile_outbound = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"                time_bytes = wmi_conn.get_binary_value('HKU', f'{sid}"
"                time_long = struct.unpack('<Q', time_bytes)[0]"
"                user_handle = samr.hSamrOpenUser(self._samr_dce, domain_handle, samr.MAXIMUM_ALLOWED, user_rid)['UserHandle']"
"                user_info = samr.hSamrQueryInformationUser2(self._samr_dce, user_handle, samr.USER_INFORMATION_CLASS.UserAllInformation)['Buffer']['All']"
"                value = ValueSpec(buf, offset "
"                yield ChromiumBookmark(user, fix_path, bookmarks)"
"                yield InstalledProducts(display_name, display_version, publisher, install_date, arch)"
"                yield LocalSecurityAuthority(key, result)"
"                yield LocalSecurityAuthority(key, value)"
"                yield PowerShellEvents(data['TimeCreated.SystemTime'], data['EventID'], data['Security.UserID'], match.group(), context_joined)"
"                yield PowerShellHistory(user_name, fixed_path, m.group(), context_joined)"
"                yield ProcessCreationEvent(time_created, event_detail['EventID'], user, m)"
"                yield PuttySessions(sid, sessions)"
"                yield WindowsEventForwarding(key, result)"
"                yield WindowsEventForwarding(key, str(value))"
"                }.get(sid_type, 'Unknown')"
"            'HKCC': 0x80000005,"
"            'HKCR': 0x80000000,"
"            'HKCU': 0x80000001,"
"            'HKLM': 0x80000002,"
"            'HKU': 0x80000003,"
"            'ObjectEncodingLength': encoding_unit['ObjectEncodingLength'],"
"            'Signature': encoding_unit['Signature'],"
"            access_str = ""Allow"" if ace_type == ""A"" else ""Deny"""
"            ace_type, flags, rights, object_guid, inherit_object_guid, sid = match.groups()"
"            alias_handle = samr.hSamrOpenAlias(self._samr_dce, domain_handle, samr.MAXIMUM_ALLOWED, group_rid)['AliasHandle']"
"            asr_rule = asr_guids().get(str(rule.Rule), f""{rule.Rule} - Please report this"")"
"            attr_len = struct.unpack_from('<I', buf, ofs)"
"            attrs = "" "" "
"            bookmark = Bookmark(name=entry[""name""].strip(), url=entry.get(""url"", ""(Bookmark Folder"
"            children = map(lambda x: x.xml(template), self._children)"
"            classObject, _ = self.iWbemServices.GetObject('StdRegProv')"
"            connection = RDPConnection(host, user_hint)"
"            content = smb_conn.show_file_content(share, partial_path, 'ConsoleHost_history.txt')"
"            directories = smb_conn.list_directory(share, outlook_base)"
"            display_name = wmi_conn.get_string_value('HKLM', f'{prod}"
"            display_version = wmi_conn.get_string_value('HKLM', f'{prod}"
"            domain_profile_enabled = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"            dpapi_listing = smb_conn.list_directory(share, dpapi_basepath)"
"            dt = datetime.strptime(s_time, ""%Y%m%d%H%M%S"")"
"            elif isinstance(value, bytes) or (isinstance(value, list) and all(isinstance(x, bytes) for x in value)):"
"            elif isinstance(value, dict):"
"            elif isinstance(value, list):"
"            enforcement_mode = wmi_conn.get_dword_value('HKLM', f'Software"
"            eof, num_values = struct.unpack_from('<BI', buf, offset "
"            file_attributes = self.connection.listPath(share, file_path)"
"            file_data = self.read_file_raw(share, file_path)"
"            files = ['sitemanager.xml', 'recentservers.xml']"
"            files = self.connection.listPath(share, pwd)"
"            for attr, value in attrs.items():"
"            for attr, value in vars(obj_or_list).items():"
"            for attr_name, attr_value in elem.attrib.items():"
"            for i, name in enumerate(names['TranslatedNames']['Names']):"
"            for k, v in recent_commands.items():"
"            for k, v in settings.items():"
"            for key, val in trigger.Properties.items():"
"            for key, value in firewall_rules.items():"
"            for key, value in o.items():"
"            for key, value in provider.Odsp.mpList[scope_id].items():"
"            for mp_key, mp_val in provider.Odsp.mpList[mp].items():"
"            for x in [""DisplayName"", ""Business"", ""ServiceEndpointUri"", ""SPOResourceId"", ""UserEmail"", ""UserFolder"", ""UserName"", ""WebServiceUrl""]:"
"            for x in [""LibraryType"", ""LastModifiedTime"", ""MountPoint"", ""UrlNamespace""]:"
"            for x in range(0, num_values):"
"            full_reg_key = f""HKLM:{i}"""
"            fz_path = f""{user_path}"
"            group_rid = samr.hSamrLookupNamesInDomain(self._samr_dce, domain_handle, (group_name,))['RelativeIds']['Element'][0]['Data']"
"            iInterface = self.dcom.CoCreateInstanceEx(wmi.CLSID_WbemLevel1Login, wmi.IID_IWbemLevel1Login)"
"            iav = struct.unpack_from('>Q', value.data, 2)[0]"
"            ids = wmi_conn.get_subkey_names('HKLM', f'Software"
"            if hasattr(pe, 'VS_FIXEDFILEINFO'):"
"            if hasattr(ret_vals, 'ReturnValue'):"
"            if hasattr(rpctransport, 'set_credentials'):"
"            if isinstance(value, (list, tuple)):"
"            if isinstance(value, list) and all(isinstance(x, str) for x in value):"
"            if isinstance(value, wmi.ENCODING_UNIT):"
"            if not isinstance(parsed, str):"
"            if not smb_conn.file_exists(share, dpapi_basepath):"
"            if not smb_conn.file_exists(share, outlook_base):"
"            if not smb_conn.file_exists(share, ps_con_hist_path):"
"            if re.search(""Microsoft"", str(data[""Author""])):"
"            install_date_str = wmi_conn.get_string_value('HKLM', f'{prod}"
"            l = f'{level} - Unknown, please report this'"
"            line = ""    """
"            logging.error(f""Couldn't connect {self.target}. Error: {str(e)}"")"
"            logon_type = SECURITY_LOGON_TYPE(int(data_two[""LogonType""])).name"
"            members = samr.hSamrGetMembersInAlias(self._samr_dce, alias_handle)"
"            module_args = "" "".join(parts[1:]) if len(parts) > 1 else """""
"            names = lsat.hLsarLookupSids2(self._lsat_dce, policy_handle, sids)"
"            od_mount_points = wmi_conn.get_registry_value('HKU', f'{sid}"
"            pEnum = iEnum.Next(0xffffffff,1)[0]"
"            principal = sid_mapping.get(sid, sid)"
"            principal, sid = well_known_sids[trustee]"
"            principal,"
"            print(""        [!] NTLM clients support NTLMv1!"")"
"            print(""        [!] NTLM services on this machine support NTLMv1!"")"
"            print(""        [!] Version 2.0.50727 of the CLR is not installed - PowerShell v2.0 won't be able to run."")"
"            print(""  NTLM v1 authentication is 100 percent broken!"
"            print(""  You can obtain NetNTLMv2 for these accounts by sniffing NTLM challenge/responses."")"
"            print(""  You can obtain these accounts' "
"            print(""  You can then try and crack their passwords."
"            print("""
"            print(""Unknown attribute next_token"", hex(next_token[0]), hex(offset "
"            print(""Unknown binxml token"", hex(next_token))"
"            print(""Unknown template token"", hex(next_token))"
"            print(""Unknown value type"", hex(value.type))"
"            print('        [!] Module logging is configured. Logging will not occur, however, because it requires PSv3.')"
"            print('        [!] Script block logging is configured. Logging will not occur, however, because it requires PSv5.""')"
"            print(f""      {'Duration':<30}:   {trigger.Duration}"")"
"            print(f""      {'EndBoundary':<30}:   {trigger.EndBoundary}"")"
"            print(f""      {'ExecutionTimeLimit':<30}:   {trigger.ExecutionTimeLimit}"")"
"            print(f""      {'Interval':<30}:   {trigger.Interval}"")"
"            print(f""      {'StartBoundary':<30}:   {trigger.StartBoundary}"")"
"            print(f""      {'StopAtDurationEnd':<30}:   {trigger.StopAtDurationEnd}"")"
"            print(f""      {s}"")"
"            print(f""    Name : {b.Name}"")"
"            print(f""    URL  : {b.Url}"
"            print(f""  Action               : {rule.Action}"")"
"            print(f""  ApplicationName      : {rule.ApplicationName}"")"
"            print(f""  Description          : {rule.Description}"")"
"            print(f""  Direction            : {rule.Direction}"")"
"            print(f""  Local Addr:Port      : {rule.LocalAddresses}:{rule.LocalPorts}"")"
"            print(f""  Name                 : {rule.Name}"")"
"            print(f""  Profiles             : {rule.Profiles}"")"
"            print(f""  Protocol             : {rule.Protocol}"")"
"            print(f""  Remote Addr:Port     : {rule.RemoteAddresses}:{rule.RemotePorts}"
"            print(f""  {obj.Key:<25} : {obj.Value}"")"
"            print(f""Error during connection: {str(e)}"")"
"            print(f""Error executing WMI query: {e}"")"
"            print(f""Error getting file size for {file_path}: {str(e)}"")"
"            print(f""Error getting version info for {file_path}: {str(e)}"")"
"            print(f""Error parsing event: {str(e)}"")"
"            print(f""Error: No commands found for group '{options.group}'"")"
"            print(f""Error: Not a valid PE file. {str(e)}"")"
"            print(f""Error: {str(e)}"")"
"            print(f""Event data (first 50 bytes): {event_bytes[:50].hex()}"")"
"            print(f""Failed to connect to {self.target}: {str(e)}"")"
"            print(f""Invalid object: {obj}"")"
"            private_profile_enabled = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"            provider_path = """""
"            provider_path = wmi_data.get_string_value('HKLM', provider_path_key, """")"
"            public_profile_enabled = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"            publisher = wmi_conn.get_string_value('HKLM', f'{prod}"
"            raise Exception(""Not connected to SMB server. Call connect() first."")"
"            raise Exception(""WMI service not initialized. Call connect() first."")"
"            raise Exception(f""Failed to enumerate local groups: {str(e)}"")"
"            raise Exception(f""Failed to enumerate local users: {str(e)}"")"
"            raise Exception(f""Failed to get group members: {str(e)}"")"
"            raise ValueError(f""Invalid hex string: {str(e)}"")"
"            re.compile(r""(ConvertTo-SecureString."
"            re.compile(r""(bitsadmin(.exe)"
"            re.compile(r""(bootcfg(.exe)"
"            re.compile(r""(certreq(.exe)"
"            re.compile(r""(certutil(.exe)"
"            re.compile(r""(cmdkey(.exe)"
"            re.compile(r""(cscript."
"            re.compile(r""(driverquery(.exe)"
"            re.compile(r""(eventcreate(.exe)"
"            re.compile(r""(getmac(.exe)"
"            re.compile(r""(gpfixup(.exe)"
"            re.compile(r""(gpresult(.exe)"
"            re.compile(r""(kitty(.exe)"
"            re.compile(r""(mapadmin(.exe)"
"            re.compile(r""(mount(.exe)"
"            re.compile(r""(net(.exe)"
"            re.compile(r""(nfsadmin(.exe)"
"            re.compile(r""(openfiles(.exe)"
"            re.compile(r""(pscp(.exe)"
"            re.compile(r""(psexec(.exe)"
"            re.compile(r""(psexec64(.exe)"
"            re.compile(r""(putty(.exe)"
"            re.compile(r""(schtasks(.exe)"
"            re.compile(r""(setx(.exe)"
"            re.compile(r""(ssh(.exe)"
"            re.compile(r""(systeminfo(.exe)"
"            re.compile(r""(takeown(.exe)"
"            re.compile(r""(taskkill(.exe)"
"            re.compile(r""(tscon(.exe)"
"            re.compile(r""(wecutil(.exe)"
"            re.compile(r""(winrm(.vbs)"
"            re.compile(r""(winrs(.exe)"
"            re.compile(r""(wmic(.exe)"
"            recent_commands = wmi_conn.get_registry_value('HKU', f'{sid}"
"            response = samr.hSamrEnumerateAliasesInDomain(self._samr_dce, domain_handle)"
"            response = samr.hSamrEnumerateUsersInDomain(self._samr_dce, domain_handle, samr.USER_NORMAL_ACCOUNT)"
"            result = "","".join(v)"
"            ret_vals = classObject.GetDWORDValue(hive_num, key_path, value_name)"
"            return ""<{}{}/>"".format(self._name.val, attrs)"
"            return ""<{}{}>{}</{}>"".format(self._name.val, attrs, """".join(children), self._name.val)"
"            return 'S-{0}-{1}-{2}'.format(revision, iav, '-'.join([str(sub_id) for sub_id in sub_ids]))"
"            return None if self._optional else """""
"            return datetime.fromtimestamp(timestamp, tz=timezone.utc).isoformat()"
"            return self.dce, rpctransport"
"            return str(struct.unpack('<B', value.data)[0])"
"            return str(struct.unpack('<H', value.data)[0])"
"            return str(struct.unpack('<I', value.data)[0])"
"            return str(struct.unpack('<Q', value.data)[0])"
"            return str(struct.unpack('<i', value.data)[0])"
"            revision, number_of_sub_ids = struct.unpack_from('<BB', value.data)"
"            s_time = str(data_two[""StartTime""])[:14]"
"            samr.hSamrCloseHandle(self._samr_dce, self._domain_handle)"
"            samr.hSamrCloseHandle(self._samr_dce, self._server_handle)"
"            self.AsrSettings.Rules.append(AsrRule(uuid.UUID(val['Key']), int(val['Value'])))"
"            self._element = Element(buf, offset "
"            self._element = TemplateInstance(buf, offset "
"            self._samr_dce, "
"            self._server_handle, "
"            self._smb_conn = SMBConnection(self.target, self.target, sess_port=self.port)"
"            self._value = Substitution(buf, offset "
"            self._value = Value(buf, offset "
"            self._xml = BinXML(buf, offset "
"            self.connection = SMBConnection(self.target, self.target)"
"            self.connection.getFile(share, file_path, file_obj.write)"
"            self.connection.getFile(share, pathname, fh.write)"
"            self.connection.listPath(share, file_path)"
"            self.dcom = DCOMConnection(self.target, self.username, self.password, self.domain, self.lmhash, self.nthash, self.aesKey, oxidResolver=True, doKerberos=self.doKerberos, kdcHost=self.kdcHost)"
"            self.iWbemServices = iWbemLevel1Login.NTLMLogin(self.namespace, NULL, NULL)"
"            self.lmhash, self.nthash = hashes.split(':')"
"            self.template = BinXML(buf, value_offset)"
"            settings = wmi_conn.get_registry_value('HKU', f'{sid}"
"            sid,"
"            standard_profile_enabled = wmi_conn.get_dword_value('HKLM', f'{rule_location}"
"            start_time = dt.strftime(""%m/%d/%Y %I:%M:%S %p"")"
"            sub_ids = [struct.unpack('<I', value.data[8 "
"            t = f'{rra_type} - Unknown, please report this'"
"            timestamp = struct.unpack('<Q', value.data)[0] / 1e7 - 11644473600"
"            urls = smb_conn.list_directory(share, favorites_base)"
"            user_domain = logon_map[str(data_two[""LogonId""])]"
"            user_hint = wmi_conn.get_string_value('HKU', f'{sid}"
"            value_name = str(key) if key is not None else """""
"            yield AuditPolicy(k, result)"
"            yield AuditPolicy(k, v)"
"            yield AutoRuns(full_reg_key, autoruns)"
"            yield ExplorerRunCommands(sid, commands)"
"            yield IEFavorites(username, favorites)"
"            yield IEUrls(sid, urls)"
"            yield InterestingProcess(category, data['Name'], product, data['ProcessId'], owner, data['CommandLine'])"
"            yield LocalGroupMembership(computer_name, group['name'], group['comment'], members)"
"         ""_avp32"": ""UNKNOWN"","
"         ""_avpcc"": ""UNKNOWN"","
"         ""_avpm"": ""UNKNOWN"""
"         ""aawtray"": ""UNKNOWN"","
"         ""ackwin32"": ""UNKNOWN"","
"         ""ad-aware"": ""UNKNOWN"","
"         ""adaware"": ""UNKNOWN"","
"         ""advxdwin"": ""UNKNOWN"","
"         ""aexnsagent"": ""Symantec"","
"         ""agentsvr"": ""UNKNOWN"","
"         ""agentw"": ""UNKNOWN"","
"         ""alertsvc"": ""UNKNOWN"","
"         ""alevir"": ""UNKNOWN"","
"         ""alogserv"": ""UNKNOWN"","
"         ""amon9x"": ""UNKNOWN"","
"         ""anti-trojan"": ""UNKNOWN"","
"         ""antivirus"": ""UNKNOWN"","
"         ""ants"": ""UNKNOWN"","
"         ""apimonitor"": ""UNKNOWN"","
"         ""aplica32"": ""UNKNOWN"","
"         ""apvxdwin"": ""UNKNOWN"","
"         ""arr"": ""UNKNOWN"","
"         ""atcon"": ""UNKNOWN"","
"         ""atguard"": ""UNKNOWN"","
"         ""atro55en"": ""UNKNOWN"","
"         ""atupdater"": ""UNKNOWN"","
"         ""atwatch"": ""UNKNOWN"","
"         ""au"": ""UNKNOWN"","
"         ""aupdate"": ""UNKNOWN"","
"         ""auto-protect.nav80try"": ""UNKNOWN"","
"         ""autodown"": ""UNKNOWN"","
"         ""autoruns"": ""UNKNOWN"","
"         ""autorunsc"": ""UNKNOWN"","
"         ""autotrace"": ""UNKNOWN"","
"         ""autoupdate"": ""UNKNOWN"","
"         ""avconsol"": ""UNKNOWN"","
"         ""ave32"": ""UNKNOWN"","
"         ""avgcc32"": ""UNKNOWN"","
"         ""avgctrl"": ""UNKNOWN"","
"         ""avgemc"": ""UNKNOWN"","
"         ""avgnt"": ""UNKNOWN"","
"         ""avgrsx"": ""UNKNOWN"","
"         ""avgserv"": ""UNKNOWN"","
"         ""avgserv9"": ""UNKNOWN"","
"         ""avguard"": ""UNKNOWN"","
"         ""avgui"": ""UNKNOWN"","
"         ""avgw"": ""UNKNOWN"","
"         ""avgwdsvc"": ""UNKNOWN"","
"         ""avkpop"": ""UNKNOWN"","
"         ""avkserv"": ""UNKNOWN"","
"         ""avkservice"": ""UNKNOWN"","
"         ""avkwctl9"": ""UNKNOWN"","
"         ""avltmain"": ""UNKNOWN"","
"         ""avnt"": ""UNKNOWN"","
"         ""avp"": ""UNKNOWN"","
"         ""avp32"": ""UNKNOWN"","
"         ""avpcc"": ""UNKNOWN"","
"         ""avpdos32"": ""UNKNOWN"","
"         ""avpm"": ""UNKNOWN"","
"         ""avptc32"": ""UNKNOWN"","
"         ""avpupd"": ""UNKNOWN"","
"         ""avsched32"": ""UNKNOWN"","
"         ""avsynmgr"": ""UNKNOWN"","
"         ""avwin"": ""UNKNOWN"","
"         ""avwin95"": ""UNKNOWN"","
"         ""avwinnt"": ""UNKNOWN"","
"         ""avwupd"": ""UNKNOWN"","
"         ""avwupd32"": ""UNKNOWN"","
"         ""avwupsrv"": ""UNKNOWN"","
"         ""avxmonitor9x"": ""UNKNOWN"","
"         ""avxmonitornt"": ""UNKNOWN"","
"         ""avxquar"": ""UNKNOWN"","
"         ""backweb"": ""UNKNOWN"","
"         ""bargains"": ""UNKNOWN"","
"         ""bd_professional"": ""UNKNOWN"","
"         ""bds-vision"": ""BDS Vision behavioral analysis"","
"         ""beagle"": ""UNKNOWN"","
"         ""belt"": ""UNKNOWN"","
"         ""besclient"": ""IBM BigFix"","
"         ""bidef"": ""UNKNOWN"","
"         ""bidserver"": ""UNKNOWN"","
"         ""bipcp"": ""UNKNOWN"","
"         ""bipcpevalsetup"": ""UNKNOWN"","
"         ""bisp"": ""UNKNOWN"","
"         ""blackd"": ""UNKNOWN"","
"         ""blackice"": ""UNKNOWN"","
"         ""blink"": ""UNKNOWN"","
"         ""blss"": ""UNKNOWN"","
"         ""bootconf"": ""UNKNOWN"","
"         ""bootwarn"": ""UNKNOWN"","
"         ""borg2"": ""UNKNOWN"","
"         ""bpc"": ""UNKNOWN"","
"         ""brasil"": ""UNKNOWN"","
"         ""brkrprcs64"": ""Symantec DLP"","
"         ""bs120"": ""UNKNOWN"","
"         ""bundle"": ""UNKNOWN"","
"         ""bvt"": ""UNKNOWN"","
"         ""cb"": ""Carbon Black behavioral analysis"","
"         ""ccapp"": ""UNKNOWN"","
"         ""ccevtmgr"": ""UNKNOWN"","
"         ""ccpxysvc"": ""UNKNOWN"","
"         ""ccsvchst"": ""Symantec"","
"         ""cdp"": ""UNKNOWN"","
"         ""cfd"": ""UNKNOWN"","
"         ""cfgwiz"": ""UNKNOWN"","
"         ""cfiadmin"": ""UNKNOWN"","
"         ""cfiaudit"": ""UNKNOWN"","
"         ""cfinet"": ""UNKNOWN"","
"         ""cfinet32"": ""UNKNOWN"","
"         ""claw95"": ""UNKNOWN"","
"         ""claw95cf"": ""UNKNOWN"","
"         ""clean"": ""UNKNOWN"","
"         ""cleaner"": ""UNKNOWN"","
"         ""cleaner3"": ""UNKNOWN"","
"         ""cleanpc"": ""UNKNOWN"","
"         ""cleanup"": ""UNKNOWN"","
"         ""click"": ""UNKNOWN"","
"         ""cmdagent"": ""UNKNOWN"","
"         ""cmesys"": ""UNKNOWN"","
"         ""cmgrdian"": ""UNKNOWN"","
"         ""cmon016"": ""UNKNOWN"","
"         ""connectionmonitor"": ""UNKNOWN"","
"         ""cpd"": ""UNKNOWN"","
"         ""cpf9x206"": ""UNKNOWN"","
"         ""cpfnt206"": ""UNKNOWN"","
"         ""csfalcon"": ""CrowdStrike Falcon EDR"","
"         ""csfalconcontainer"": ""CrowdStrike Falcon EDR"","
"         ""csfalconservice"": ""CrowdStrike Falcon EDR"","
"         ""ctrl"": ""UNKNOWN"","
"         ""cv"": ""UNKNOWN"","
"         ""cwnb181"": ""UNKNOWN"","
"         ""cwntdwmo"": ""UNKNOWN"","
"         ""cylancesvc"": ""Cylance Protect"","
"         ""cylanceui"": ""Cylance Protect"","
"         ""cyprotect"": ""UNKNOWN"","
"         ""cyserver"": ""UNKNOWN"","
"         ""cytray"": ""UNKNOWN"","
"         ""cyupdate"": ""UNKNOWN"","
"         ""cyveraservice"": ""UNKNOWN"","
"         ""datemanager"": ""UNKNOWN"","
"         ""dcomx"": ""UNKNOWN"","
"         ""defalert"": ""UNKNOWN"","
"         ""defscangui"": ""UNKNOWN"","
"         ""defwatch"": ""UNKNOWN"","
"         ""deputy"": ""UNKNOWN"","
"         ""dgagent"": ""Verdasys Digital Guardian DLP"","
"         ""dgprompt"": ""UNKNOWN"","
"         ""dgservice"": ""UNKNOWN"","
"         ""divx"": ""UNKNOWN"","
"         ""dllcache"": ""UNKNOWN"","
"         ""dllreg"": ""UNKNOWN"","
"         ""doors"": ""UNKNOWN"","
"         ""dpf"": ""UNKNOWN"","
"         ""dpfsetup"": ""UNKNOWN"","
"         ""dpps2"": ""UNKNOWN"","
"         ""drwatson"": ""UNKNOWN"","
"         ""drweb32"": ""UNKNOWN"","
"         ""drwebupw"": ""UNKNOWN"","
"         ""dssagent"": ""UNKNOWN"","
"         ""dumpcap"": ""UNKNOWN"","
"         ""dvp95"": ""UNKNOWN"","
"         ""dvp95_0"": ""UNKNOWN"","
"         ""ecengine"": ""UNKNOWN"","
"         ""edpa"": ""Symantec DLP"","
"         ""efpeadm"": ""UNKNOWN"","
"         ""egui"": ""UNKNOWN"","
"         ""ekrn"": ""UNKNOWN"","
"         ""emet_agent"": ""UNKNOWN"","
"         ""emet_service"": ""UNKNOWN"","
"         ""emsw"": ""UNKNOWN"","
"         ""engineserver"": ""UNKNOWN"","
"         ""enstart64"": ""Encase (Forensics tool)"","
"         ""ent"": ""UNKNOWN"","
"         ""esafe"": ""UNKNOWN"","
"         ""escanhnt"": ""UNKNOWN"","
"         ""escanv95"": ""UNKNOWN"","
"         ""espwatch"": ""UNKNOWN"","
"         ""ethereal"": ""UNKNOWN"","
"         ""etrustcipe"": ""UNKNOWN"","
"         ""evpn"": ""UNKNOWN"","
"         ""exantivirus-cnet"": ""UNKNOWN"","
"         ""exe.avxw"": ""UNKNOWN"","
"         ""expert"": ""UNKNOWN"","
"         ""explore"": ""UNKNOWN"","
"         ""f-agnt95"": ""UNKNOWN"","
"         ""f-prot"": ""UNKNOWN"","
"         ""f-prot95"": ""UNKNOWN"","
"         ""f-stopw"": ""UNKNOWN"","
"         ""fameh32"": ""UNKNOWN"","
"         ""fast"": ""UNKNOWN"","
"         ""fcags"": ""McAfee DLP Agent"","
"         ""fcagswd"": ""McAfee DLP Agent"","
"         ""fch32"": ""UNKNOWN"","
"         ""fih32"": ""UNKNOWN"","
"         ""findviru"": ""UNKNOWN"","
"         ""firesvc"": ""McAfee Host Intrusion Prevention"","
"         ""firetray"": ""UNKNOWN"","
"         ""firewall"": ""UNKNOWN"","
"         ""fnrb32"": ""UNKNOWN"","
"         ""fp-win"": ""UNKNOWN"","
"         ""fp-win_trial"": ""UNKNOWN"","
"         ""fprot"": ""UNKNOWN"","
"         ""frameworkservice"": ""UNKNOWN"","
"         ""frminst"": ""UNKNOWN"","
"         ""frw"": ""UNKNOWN"","
"         ""fsaa"": ""UNKNOWN"","
"         ""fsav"": ""UNKNOWN"","
"         ""fsav32"": ""UNKNOWN"","
"         ""fsav530stbyb"": ""UNKNOWN"","
"         ""fsav530wtbyb"": ""UNKNOWN"","
"         ""fsav95"": ""UNKNOWN"","
"         ""fsgk32"": ""UNKNOWN"","
"         ""fsm32"": ""UNKNOWN"","
"         ""fsma32"": ""UNKNOWN"","
"         ""fsmb32"": ""UNKNOWN"","
"         ""gator"": ""UNKNOWN"","
"         ""gbmenu"": ""UNKNOWN"","
"         ""gbpoll"": ""UNKNOWN"","
"         ""generics"": ""UNKNOWN"","
"         ""gmt"": ""UNKNOWN"","
"         ""guard"": ""UNKNOWN"","
"         ""guarddog"": ""UNKNOWN"","
"         ""hacktracersetup"": ""UNKNOWN"","
"         ""hbinst"": ""UNKNOWN"","
"         ""hbsrv"": ""UNKNOWN"","
"         ""hijackthis"": ""UNKNOWN"","
"         ""hipmgmt"": ""McAfee Host Intrusion Protection"","
"         ""hipsvc"": ""UNKNOWN"","
"         ""hotactio"": ""UNKNOWN"","
"         ""hotpatch"": ""UNKNOWN"","
"         ""htlog"": ""UNKNOWN"","
"         ""htpatch"": ""UNKNOWN"","
"         ""hwpe"": ""UNKNOWN"","
"         ""hxdl"": ""UNKNOWN"","
"         ""hxiul"": ""UNKNOWN"","
"         ""iamapp"": ""UNKNOWN"","
"         ""iamserv"": ""UNKNOWN"","
"         ""iamstats"": ""UNKNOWN"","
"         ""ibmasn"": ""UNKNOWN"","
"         ""ibmavsp"": ""UNKNOWN"","
"         ""icload95"": ""UNKNOWN"","
"         ""icloadnt"": ""UNKNOWN"","
"         ""icmon"": ""UNKNOWN"","
"         ""icsupp95"": ""UNKNOWN"","
"         ""icsuppnt"": ""UNKNOWN"","
"         ""idle"": ""UNKNOWN"","
"         ""iedll"": ""UNKNOWN"","
"         ""iedriver"": ""UNKNOWN"","
"         ""iface"": ""UNKNOWN"","
"         ""ifw2000"": ""UNKNOWN"","
"         ""inetlnfo"": ""UNKNOWN"","
"         ""infus"": ""UNKNOWN"","
"         ""infwin"": ""UNKNOWN"","
"         ""init"": ""UNKNOWN"","
"         ""intdel"": ""UNKNOWN"","
"         ""intren"": ""UNKNOWN"","
"         ""iomon98"": ""UNKNOWN"","
"         ""istsvc"": ""UNKNOWN"","
"         ""jammer"": ""UNKNOWN"","
"         ""jdbgmrg"": ""UNKNOWN"","
"         ""jedi"": ""UNKNOWN"","
"         ""kavlite40eng"": ""UNKNOWN"","
"         ""kavpers40eng"": ""UNKNOWN"","
"         ""kavpf"": ""UNKNOWN"","
"         ""kazza"": ""UNKNOWN"","
"         ""keenvalue"": ""UNKNOWN"","
"         ""kerio-pf-213-en-win"": ""UNKNOWN"","
"         ""kerio-wrl-421-en-win"": ""UNKNOWN"","
"         ""kerio-wrp-421-en-win"": ""UNKNOWN"","
"         ""kernel32"": ""UNKNOWN"","
"         ""keypass"": ""UNKNOWN"","
"         ""killprocesssetup161"": ""UNKNOWN"","
"         ""kvoop"": ""Symantec DLP"","
"         ""launcher"": ""UNKNOWN"","
"         ""ldnetmon"": ""UNKNOWN"","
"         ""ldpro"": ""UNKNOWN"","
"         ""ldpromenu"": ""UNKNOWN"","
"         ""ldscan"": ""UNKNOWN"","
"         ""lnetinfo"": ""UNKNOWN"","
"         ""loader"": ""UNKNOWN"","
"         ""localnet"": ""UNKNOWN"","
"         ""lockdown"": ""UNKNOWN"","
"         ""lockdown2000"": ""UNKNOWN"","
"         ""lookout"": ""UNKNOWN"","
"         ""lordpe"": ""UNKNOWN"","
"         ""lsetup"": ""UNKNOWN"","
"         ""luall"": ""UNKNOWN"","
"         ""luau"": ""UNKNOWN"","
"         ""lucomserver"": ""UNKNOWN"","
"         ""luinit"": ""UNKNOWN"","
"         ""luspt"": ""UNKNOWN"","
"         ""macmnsvc"": ""McAfee"","
"         ""macompatsvc"": ""McAfee"","
"         ""mapisvc32"": ""UNKNOWN"","
"         ""masvc"": ""McAfee"","
"         ""mbae"": ""MalwareBytes Anti-Exploit"","
"         ""mbamservice"": ""UNKNOWN"","
"         ""mcafeefire"": ""UNKNOWN"","
"         ""mcagent"": ""UNKNOWN"","
"         ""mcmnhdlr"": ""UNKNOWN"","
"         ""mcscript"": ""UNKNOWN"","
"         ""mcscript_inuse"": ""UNKNOWN"","
"         ""mcshield"": ""McAfee"","
"         ""mctool"": ""UNKNOWN"","
"         ""mctray"": ""UNKNOWN"","
"         ""mcupdate"": ""UNKNOWN"","
"         ""mcvsrte"": ""UNKNOWN"","
"         ""mcvsshld"": ""UNKNOWN"","
"         ""md"": ""UNKNOWN"","
"         ""mfeann"": ""McAfee VirusScan Enterprise"","
"         ""mfecanary"": ""McAfee"","
"         ""mfeesp"": ""McAfee"","
"         ""mfemactl"": ""McAfee"","
"         ""mfemms"": ""McAfee"","
"         ""mfetp"": ""McAfee"","
"         ""mfevtps"": ""UNKNOWN"","
"         ""mfin32"": ""UNKNOWN"","
"         ""mfw2en"": ""UNKNOWN"","
"         ""mfweng3.02d30"": ""UNKNOWN"","
"         ""mgavrtcl"": ""UNKNOWN"","
"         ""mgavrte"": ""UNKNOWN"","
"         ""mghtml"": ""UNKNOWN"","
"         ""mgui"": ""UNKNOWN"","
"         ""minilog"": ""UNKNOWN"","
"         ""minionhost"": ""Cyberreason"","
"         ""mmod"": ""UNKNOWN"","
"         ""monitor"": ""UNKNOWN"","
"         ""moolive"": ""UNKNOWN"","
"         ""mostat"": ""UNKNOWN"","
"         ""mpfagent"": ""UNKNOWN"","
"         ""mpfservice"": ""UNKNOWN"","
"         ""mpftray"": ""UNKNOWN"","
"         ""mrflux"": ""UNKNOWN"","
"         ""msapp"": ""UNKNOWN"","
"         ""msascui"": ""Windows Defender AV"","
"         ""msascuil"": ""Windows Defender AV"","
"         ""msbb"": ""UNKNOWN"","
"         ""msblast"": ""UNKNOWN"","
"         ""mscache"": ""UNKNOWN"","
"         ""msccn32"": ""UNKNOWN"","
"         ""mscman"": ""UNKNOWN"","
"         ""msconfig"": ""UNKNOWN"","
"         ""msdm"": ""UNKNOWN"","
"         ""msdos"": ""UNKNOWN"","
"         ""msiexec16"": ""UNKNOWN"","
"         ""msinfo32"": ""UNKNOWN"","
"         ""mslaugh"": ""UNKNOWN"","
"         ""msmgt"": ""UNKNOWN"","
"         ""msmpeng"": ""Windows Defender AV"","
"         ""msmpsvc"": ""Windows Defender AV"","
"         ""msmsgri32"": ""UNKNOWN"","
"         ""mssense"": ""Microsoft Defender ATP"","
"         ""mssmmc32"": ""UNKNOWN"","
"         ""mssys"": ""UNKNOWN"","
"         ""msvxd"": ""UNKNOWN"","
"         ""mu0311ad"": ""UNKNOWN"","
"         ""mwatch"": ""UNKNOWN"","
"         ""n32scanw"": ""UNKNOWN"","
"         ""naprdmgr"": ""UNKNOWN"","
"         ""nav"": ""UNKNOWN"","
"         ""navap.navapsvc"": ""UNKNOWN"","
"         ""navapsvc"": ""UNKNOWN"","
"         ""navapw32"": ""UNKNOWN"","
"         ""navdx"": ""UNKNOWN"","
"         ""navlu32"": ""UNKNOWN"","
"         ""navnt"": ""UNKNOWN"","
"         ""navstub"": ""UNKNOWN"","
"         ""navw32"": ""UNKNOWN"","
"         ""navwnt"": ""UNKNOWN"","
"         ""nc2000"": ""UNKNOWN"","
"         ""ncinst4"": ""UNKNOWN"","
"         ""ndd32"": ""UNKNOWN"","
"         ""neomonitor"": ""UNKNOWN"","
"         ""neowatchlog"": ""UNKNOWN"","
"         ""netarmor"": ""UNKNOWN"","
"         ""netd32"": ""UNKNOWN"","
"         ""netinfo"": ""UNKNOWN"","
"         ""netmon"": ""UNKNOWN"","
"         ""netscanpro"": ""UNKNOWN"","
"         ""netspyhunter-1.2"": ""UNKNOWN"","
"         ""netstat"": ""UNKNOWN"","
"         ""netutils"": ""UNKNOWN"","
"         ""nisserv"": ""UNKNOWN"","
"         ""nisum"": ""UNKNOWN"","
"         ""nmain"": ""UNKNOWN"","
"         ""nod32"": ""UNKNOWN"","
"         ""normist"": ""UNKNOWN"","
"         ""norton_internet_secu_3.0_407"": ""UNKNOWN"","
"         ""notstart"": ""UNKNOWN"","
"         ""npf40_tw_98_nt_me_2k"": ""UNKNOWN"","
"         ""npfmessenger"": ""UNKNOWN"","
"         ""nprotect"": ""UNKNOWN"","
"         ""npscheck"": ""UNKNOWN"","
"         ""npssvc"": ""UNKNOWN"","
"         ""nsched32"": ""UNKNOWN"","
"         ""nssys32"": ""UNKNOWN"","
"         ""nstask32"": ""UNKNOWN"","
"         ""nsupdate"": ""UNKNOWN"","
"         ""nt"": ""UNKNOWN"","
"         ""ntrtscan"": ""UNKNOWN"","
"         ""ntvdm"": ""UNKNOWN"","
"         ""ntxconfig"": ""UNKNOWN"","
"         ""nui"": ""UNKNOWN"","
"         ""nupgrade"": ""UNKNOWN"","
"         ""nvarch16"": ""UNKNOWN"","
"         ""nvc95"": ""UNKNOWN"","
"         ""nvsvc32"": ""UNKNOWN"","
"         ""nwinst4"": ""UNKNOWN"","
"         ""nwservice"": ""UNKNOWN"","
"         ""nwtool16"": ""UNKNOWN"","
"         ""nxlog"": ""UNKNOWN"","
"         ""ollydbg"": ""UNKNOWN"","
"         ""onsrvr"": ""UNKNOWN"","
"         ""optimize"": ""UNKNOWN"","
"         ""osqueryd"": ""UNKNOWN"","
"         ""ossec"": ""OSSEC intrusion detection"","
"         ""ostronet"": ""UNKNOWN"","
"         ""otfix"": ""UNKNOWN"","
"         ""outpost"": ""UNKNOWN"","
"         ""outpostinstall"": ""UNKNOWN"","
"         ""outpostproinstall"": ""UNKNOWN"","
"         ""padmin"": ""UNKNOWN"","
"         ""panixk"": ""UNKNOWN"","
"         ""parity"": ""Bit9 application whitelisting"","
"         ""patch"": ""UNKNOWN"","
"         ""pavcl"": ""UNKNOWN"","
"         ""pavproxy"": ""UNKNOWN"","
"         ""pavsched"": ""UNKNOWN"","
"         ""pavw"": ""UNKNOWN"","
"         ""pccwin98"": ""UNKNOWN"","
"         ""pcfwallicon"": ""UNKNOWN"","
"         ""pcip10117_0"": ""UNKNOWN"","
"         ""pcscan"": ""UNKNOWN"","
"         ""pdsetup"": ""UNKNOWN"","
"         ""periscope"": ""UNKNOWN"","
"         ""persfw"": ""UNKNOWN"","
"         ""perswf"": ""UNKNOWN"","
"         ""pf2"": ""UNKNOWN"","
"         ""pfwadmin"": ""UNKNOWN"","
"         ""pgmonitr"": ""UNKNOWN"","
"         ""pingscan"": ""UNKNOWN"","
"         ""platin"": ""UNKNOWN"","
"         ""pop3trap"": ""UNKNOWN"","
"         ""poproxy"": ""UNKNOWN"","
"         ""popscan"": ""UNKNOWN"","
"         ""portdetective"": ""UNKNOWN"","
"         ""portmonitor"": ""UNKNOWN"","
"         ""powerscan"": ""UNKNOWN"","
"         ""ppinupdt"": ""UNKNOWN"","
"         ""pptbc"": ""UNKNOWN"","
"         ""ppvstop"": ""UNKNOWN"","
"         ""prizesurfer"": ""UNKNOWN"","
"         ""prmt"": ""UNKNOWN"","
"         ""prmvr"": ""UNKNOWN"","
"         ""procdump"": ""UNKNOWN"","
"         ""processmonitor"": ""UNKNOWN"","
"         ""procexp"": ""UNKNOWN"","
"         ""procexp64"": ""UNKNOWN"","
"         ""procexplorerv1.0"": ""UNKNOWN"","
"         ""procmon"": ""UNKNOWN"","
"         ""programauditor"": ""UNKNOWN"","
"         ""proport"": ""UNKNOWN"","
"         ""protectx"": ""UNKNOWN"","
"         ""pspf"": ""UNKNOWN"","
"         ""purge"": ""UNKNOWN"","
"         ""qconsole"": ""UNKNOWN"","
"         ""qserver"": ""UNKNOWN"","
"         ""rapapp"": ""UNKNOWN"","
"         ""rav7"": ""UNKNOWN"","
"         ""rav7win"": ""UNKNOWN"","
"         ""rav8win32eng"": ""UNKNOWN"","
"         ""ray"": ""UNKNOWN"","
"         ""rb32"": ""UNKNOWN"","
"         ""rcsync"": ""UNKNOWN"","
"         ""realmon"": ""UNKNOWN"","
"         ""reged"": ""UNKNOWN"","
"         ""regedit"": ""UNKNOWN"","
"         ""regedt32"": ""UNKNOWN"","
"         ""repmgr"": ""Carbon Black Defense"","
"         ""reputils"": ""Carbon Black Defense"","
"         ""repux"": ""Carbon Black Defense"","
"         ""repwsc"": ""Carbon Black Defense"","
"         ""rescue"": ""UNKNOWN"","
"         ""rescue32"": ""UNKNOWN"","
"         ""rrguard"": ""UNKNOWN"","
"         ""rshell"": ""UNKNOWN"","
"         ""rtvscan"": ""UNKNOWN"","
"         ""rtvscn95"": ""UNKNOWN"","
"         ""rulaunch"": ""UNKNOWN"","
"         ""run32dll"": ""UNKNOWN"","
"         ""rundll"": ""UNKNOWN"","
"         ""rundll16"": ""UNKNOWN"","
"         ""ruxdll32"": ""UNKNOWN"","
"         ""safeweb"": ""UNKNOWN"","
"         ""sahagent.exescan32"": ""UNKNOWN"","
"         ""save"": ""UNKNOWN"","
"         ""savenow"": ""UNKNOWN"","
"         ""savservice"": ""Sophos AV"","
"         ""sbserv"": ""UNKNOWN"","
"         ""scam32"": ""UNKNOWN"","
"         ""scan32"": ""UNKNOWN"","
"         ""scan95"": ""UNKNOWN"","
"         ""scanpm"": ""UNKNOWN"","
"         ""scrscan"": ""UNKNOWN"","
"         ""sensecncproxy"": ""Microsoft Defender ATP"","
"         ""sentinelone"": ""SentinelOne Endpoint Security Software"","
"         ""serv95"": ""UNKNOWN"","
"         ""setup_flowprotector_us"": ""UNKNOWN"","
"         ""setupvameeval"": ""UNKNOWN"","
"         ""sfc"": ""UNKNOWN"","
"         ""sgssfw32"": ""UNKNOWN"","
"         ""sh"": ""UNKNOWN"","
"         ""shellspyinstall"": ""UNKNOWN"","
"         ""shn"": ""UNKNOWN"","
"         ""showbehind"": ""UNKNOWN"","
"         ""shstat"": ""McAfee VirusScan Enterprise"","
"         ""sisidsservice"": ""Symantec IDS"","
"         ""sisipsservice"": ""Symantec IPS"","
"         ""sisipsutil"": ""Symantec IPS"","
"         ""smc"": ""UNKNOWN"","
"         ""smcgui"": ""Symantec Endpoint Detection"","
"         ""sms"": ""UNKNOWN"","
"         ""smss32"": ""UNKNOWN"","
"         ""snac64"": ""Symantec Endpoint Detection"","
"         ""sofi"": ""UNKNOWN"","
"         ""sperm"": ""UNKNOWN"","
"         ""spf"": ""UNKNOWN"","
"         ""sphinx"": ""UNKNOWN"","
"         ""splunk"": ""Splunk"","
"         ""splunk-admon"": ""Splunk"","
"         ""splunk-powershell"": ""Splunk"","
"         ""splunk-winevtlog"": ""Splunk"","
"         ""splunkd"": ""Splunk"","
"         ""spoler"": ""UNKNOWN"","
"         ""spoolcv"": ""UNKNOWN"","
"         ""spoolsv32"": ""UNKNOWN"","
"         ""spyxx"": ""UNKNOWN"","
"         ""srexe"": ""UNKNOWN"","
"         ""srng"": ""UNKNOWN"","
"         ""ss3edit"": ""UNKNOWN"","
"         ""ssg_4104"": ""UNKNOWN"","
"         ""ssgrate"": ""UNKNOWN"","
"         ""st2"": ""UNKNOWN"","
"         ""start"": ""UNKNOWN"","
"         ""stcloader"": ""UNKNOWN"","
"         ""supftrl"": ""UNKNOWN"","
"         ""support"": ""UNKNOWN"","
"         ""supporter5"": ""UNKNOWN"","
"         ""svchostc"": ""UNKNOWN"","
"         ""svchosts"": ""UNKNOWN"","
"         ""sweep95"": ""UNKNOWN"","
"         ""sweepnet.sweepsrv.sys.swnetsup"": ""UNKNOWN"","
"         ""symantec antivirus"": ""Symantec"","
"         ""symproxysvc"": ""UNKNOWN"","
"         ""symtray"": ""UNKNOWN"","
"         ""sysedit"": ""UNKNOWN"","
"         ""sysmon"": ""Sysinternals Sysmon"","
"         ""sysupd"": ""UNKNOWN"","
"         ""taniumclient"": ""Tanium"","
"         ""taskmg"": ""UNKNOWN"","
"         ""taskmo"": ""UNKNOWN"","
"         ""taumon"": ""UNKNOWN"","
"         ""tbmon"": ""UNKNOWN"","
"         ""tbscan"": ""UNKNOWN"","
"         ""tc"": ""UNKNOWN"","
"         ""tca"": ""UNKNOWN"","
"         ""tcm"": ""UNKNOWN"","
"         ""tcpview"": ""UNKNOWN"","
"         ""tds-3"": ""UNKNOWN"","
"         ""tds2-98"": ""UNKNOWN"","
"         ""tds2-nt"": ""UNKNOWN"","
"         ""teekids"": ""UNKNOWN"","
"         ""tfak"": ""UNKNOWN"","
"         ""tfak5"": ""UNKNOWN"","
"         ""tgbob"": ""UNKNOWN"","
"         ""titanin"": ""UNKNOWN"","
"         ""titaninxp"": ""UNKNOWN"","
"         ""tlaservice"": ""UNKNOWN"","
"         ""tlaworker"": ""UNKNOWN"","
"         ""tmccsf"": ""Trend Micro AV"","
"         ""tmpfw"": ""Trend Micro firewall"","
"         ""tracert"": ""UNKNOWN"","
"         ""trickler"": ""UNKNOWN"","
"         ""triumfant"": ""Triumfant behavioral analysis"","
"         ""trjscan"": ""UNKNOWN"","
"         ""trjsetup"": ""UNKNOWN"","
"         ""trojantrap3"": ""UNKNOWN"","
"         ""tsadbot"": ""UNKNOWN"","
"         ""tshark"": ""UNKNOWN"","
"         ""tvmd"": ""UNKNOWN"","
"         ""tvtmd"": ""UNKNOWN"","
"         ""udaterui"": ""UNKNOWN"","
"         ""undoboot"": ""UNKNOWN"","
"         ""updat"": ""UNKNOWN"","
"         ""update"": ""UNKNOWN"","
"         ""updaterui"": ""UNKNOWN"","
"         ""upgrad"": ""UNKNOWN"","
"         ""utpost"": ""UNKNOWN"","
"         ""vbcmserv"": ""UNKNOWN"","
"         ""vbcons"": ""UNKNOWN"","
"         ""vbust"": ""UNKNOWN"","
"         ""vbwin9x"": ""UNKNOWN"","
"         ""vbwinntw"": ""UNKNOWN"","
"         ""vcsetup"": ""UNKNOWN"","
"         ""vet32"": ""UNKNOWN"","
"         ""vet95"": ""UNKNOWN"","
"         ""vettray"": ""UNKNOWN"","
"         ""vfsetup"": ""UNKNOWN"","
"         ""vir-help"": ""UNKNOWN"","
"         ""virusmdpersonalfirewall"": ""UNKNOWN"","
"         ""vnlan300"": ""UNKNOWN"","
"         ""vnpc3000"": ""UNKNOWN"","
"         ""vpc32"": ""UNKNOWN"","
"         ""vpc42"": ""UNKNOWN"","
"         ""vpfw30s"": ""UNKNOWN"","
"         ""vptray"": ""UNKNOWN"","
"         ""vscan40"": ""UNKNOWN"","
"         ""vscenu6.02d30"": ""UNKNOWN"","
"         ""vsched"": ""UNKNOWN"","
"         ""vsecomr"": ""UNKNOWN"","
"         ""vshwin32"": ""UNKNOWN"","
"         ""vsisetup"": ""UNKNOWN"","
"         ""vsmain"": ""UNKNOWN"","
"         ""vsmon"": ""UNKNOWN"","
"         ""vsstat"": ""UNKNOWN"","
"         ""vstskmgr"": ""McAfee VirusScan Enterprise"","
"         ""vswin9xe"": ""UNKNOWN"","
"         ""vswinntse"": ""UNKNOWN"","
"         ""vswinperse"": ""UNKNOWN"","
"         ""w32dsm89"": ""UNKNOWN"","
"         ""w9x"": ""UNKNOWN"","
"         ""watchdog"": ""UNKNOWN"","
"         ""wdp"": ""Symantec Endpoint Detection"","
"         ""webdav"": ""UNKNOWN"","
"         ""webscanx"": ""UNKNOWN"","
"         ""webtrap"": ""UNKNOWN"","
"         ""wfindv32"": ""UNKNOWN"","
"         ""whoswatchingme"": ""UNKNOWN"","
"         ""wimmun32"": ""UNKNOWN"","
"         ""win-bugsfix"": ""UNKNOWN"","
"         ""win32"": ""UNKNOWN"","
"         ""win32us"": ""UNKNOWN"","
"         ""winactive"": ""UNKNOWN"","
"         ""windefend"": ""Windows Defender AV"","
"         ""window"": ""UNKNOWN"","
"         ""windows"": ""UNKNOWN"","
"         ""wininetd"": ""UNKNOWN"","
"         ""wininitx"": ""UNKNOWN"","
"         ""winlogin"": ""UNKNOWN"","
"         ""winmain"": ""UNKNOWN"","
"         ""winnet"": ""UNKNOWN"","
"         ""winppr32"": ""UNKNOWN"","
"         ""winrecon"": ""UNKNOWN"","
"         ""winservn"": ""UNKNOWN"","
"         ""winssk32"": ""UNKNOWN"","
"         ""winstart"": ""UNKNOWN"","
"         ""winstart001"": ""UNKNOWN"","
"         ""wintsk32"": ""UNKNOWN"","
"         ""winupdate"": ""UNKNOWN"","
"         ""wireshark"": ""UNKNOWN"","
"         ""wkufind"": ""UNKNOWN"","
"         ""wnad"": ""UNKNOWN"","
"         ""wnt"": ""UNKNOWN"","
"         ""wradmin"": ""UNKNOWN"","
"         ""wrctrl"": ""UNKNOWN"","
"         ""wrsa"": ""WebRoot AV"","
"         ""wsbgate"": ""UNKNOWN"","
"         ""wupdater"": ""UNKNOWN"","
"         ""wupdt"": ""UNKNOWN"","
"         ""wyvernworksfirewall"": ""UNKNOWN"","
"         ""xagt"": ""FireEye Endpoint Security (HX)"","
"         ""xpf202en"": ""UNKNOWN"","
"         ""zapro"": ""UNKNOWN"","
"         ""zapsetup3001"": ""UNKNOWN"","
"         ""zatutor"": ""UNKNOWN"","
"         ""zonalm2601"": ""UNKNOWN"","
"         ""zonealarm"": ""UNKNOWN"","
"        """
"        "".azure"
"        "".bluemix"
"        ""0"": ""HOPOPT"","
"        ""01443614-cd74-433a-b99e-2ecdc07bfc25"": ""Block executable files from running unless they meet a prevalence, age, or trusted list criteria"","
"        ""1"": ""ICMP"","
"        ""10"": ""BBN-RCC-MON"","
"        ""100"": ""GMTP"","
"        ""101"": ""IFMP"","
"        ""102"": ""PNNI"","
"        ""103"": ""PIM"","
"        ""104"": ""ARIS"","
"        ""105"": ""SCPS"","
"        ""106"": ""QNX"","
"        ""107"": ""A/N"","
"        ""108"": ""IPComp"","
"        ""109"": ""SNP"","
"        ""11"": ""NVP-II"","
"        ""110"": ""Compaq-Peer"","
"        ""111"": ""IPX-in-IP"","
"        ""112"": ""VRRP"","
"        ""113"": ""PGM"","
"        ""114"": ""0-hop"","
"        ""115"": ""L2TP"","
"        ""116"": ""DDX"","
"        ""117"": ""IATP"","
"        ""118"": ""STP"","
"        ""119"": ""SRP"","
"        ""12"": ""PUP"","
"        ""120"": ""UTI"","
"        ""121"": ""SMP"","
"        ""122"": ""SM"","
"        ""123"": ""PTP"","
"        ""124"": ""ISIS"","
"        ""125"": ""FIRE"","
"        ""126"": ""CRTP"","
"        ""127"": ""CRUDP"","
"        ""128"": ""SSCOPMCE"","
"        ""129"": ""IPLT"","
"        ""13"": ""ARGUS"","
"        ""130"": ""SPS"","
"        ""131"": ""PIPE"","
"        ""132"": ""SCTP"","
"        ""133"": ""FC"","
"        ""134"": ""RSVP-E2E-IGNORE"","
"        ""135"": ""Mobility"","
"        ""136"": ""UDPLite"","
"        ""137"": ""MPLS-in-IP"","
"        ""138"": ""manet"","
"        ""139"": ""HIP"","
"        ""14"": ""EMCON"","
"        ""140"": ""Shim6"","
"        ""141"": ""WESP"","
"        ""142"": ""ROHC"","
"        ""143"": ""Unassigned"","
"        ""15"": ""XNET"","
"        ""16"": ""CHAOS"","
"        ""17"": ""UDP"","
"        ""18"": ""MUX"","
"        ""19"": ""DCN-MEAS"","
"        ""2"": ""IGMP"","
"        ""20"": ""HMP"","
"        ""21"": ""PRM"","
"        ""22"": ""XNS-IDP"","
"        ""23"": ""TRUNK-1"","
"        ""24"": ""TRUNK-2"","
"        ""25"": ""LEAF-1"","
"        ""253"": ""Experimentation"","
"        ""254"": ""Experimentation"","
"        ""255"": ""Reserved"""
"        ""26"": ""LEAF-2"","
"        ""26190899-1602-49e8-8b27-eb1d0a1ce869"": ""Block Office communication applications from creating child processes"","
"        ""27"": ""RDP"","
"        ""28"": ""IRTP"","
"        ""29"": ""ISO-TP4"","
"        ""3"": ""GGP"","
"        ""30"": ""NETBLT"","
"        ""31"": ""MFE-NSP"","
"        ""32"": ""MERIT-INP"","
"        ""33"": ""DCCP"","
"        ""34"": ""3PC"","
"        ""35"": ""IDPR"","
"        ""36"": ""XTP"","
"        ""37"": ""DDP"","
"        ""38"": ""IDPR-CMTP"","
"        ""39"": ""TP"
"        ""3b576869-a4ec-4529-8536-b80a7769e899"": ""Block Office applications from creating executable content"
"        ""4"": ""IPv4"","
"        ""40"": ""IL"","
"        ""41"": ""IPv6"","
"        ""42"": ""SDRP"","
"        ""43"": ""IPv6-Route"","
"        ""44"": ""IPv6-Frag"","
"        ""45"": ""IDRP"","
"        ""46"": ""RSVP"","
"        ""47"": ""GRE"","
"        ""48"": ""DSR"","
"        ""49"": ""BNA"","
"        ""5"": ""ST"","
"        ""50"": ""ESP"","
"        ""51"": ""AH"","
"        ""52"": ""I-NLSP"","
"        ""53"": ""SWIPE"","
"        ""54"": ""NARP"","
"        ""55"": ""MOBILE"","
"        ""56"": ""TLSP"","
"        ""57"": ""SKIP"","
"        ""58"": ""IPv6-ICMP"","
"        ""59"": ""IPv6-NoNxt"","
"        ""5beb7efe-fd9a-4556-801d-275e5ffc04cc"": ""Block execution of potentially obfuscated scripts"","
"        ""6"": ""TCP"","
"        ""60"": ""IPv6-Opts"","
"        ""61"": ""any host"","
"        ""62"": ""CFTP"","
"        ""63"": ""any local"","
"        ""64"": ""SAT-EXPAK"","
"        ""65"": ""KRYPTOLAN"","
"        ""66"": ""RVD"","
"        ""67"": ""IPPC"","
"        ""68"": ""any distributed file system"","
"        ""69"": ""SAT-MON"","
"        ""7"": ""CBT"","
"        ""70"": ""VISA"","
"        ""71"": ""IPCV"","
"        ""72"": ""CPNX"","
"        ""73"": ""CPHB"","
"        ""74"": ""WSN"","
"        ""75"": ""PVP"","
"        ""75668c1f-73b5-4cf0-bb93-3ecf5cb7cc84"": ""Block Office applications from injecting code into other processes"","
"        ""76"": ""BR-SAT-MON"","
"        ""7674ba52-37eb-4a4f-a9a1-f0f9a1619a2c"": ""Block Adobe Reader from creating child processes"","
"        ""77"": ""SUN-ND"","
"        ""78"": ""WB-MON"","
"        ""79"": ""WB-EXPAK"","
"        ""8"": ""EGP"","
"        ""80"": ""ISO-IP"","
"        ""81"": ""VMTP"","
"        ""82"": ""SECURE-VMTP"","
"        ""83"": ""VINES"","
"        ""84"": ""TTP"","
"        ""85"": ""NSFNET-IGP"","
"        ""86"": ""DGP"","
"        ""87"": ""TCF"","
"        ""88"": ""EIGRP"","
"        ""89"": ""OSPFIGP"","
"        ""9"": ""IGP"","
"        ""90"": ""Sprite-RPC"","
"        ""91"": ""LARP"","
"        ""92"": ""MTP"","
"        ""92e97fa1-2edf-4476-bdd6-9dd0b4dddc7b"": ""Block Win32 API calls from Office macro"
"        ""93"": ""AX.25"","
"        ""94"": ""IPIP"","
"        ""95"": ""MICP"","
"        ""96"": ""SCC-SP"","
"        ""97"": ""ETHERIP"","
"        ""98"": ""ENCAP"","
"        ""99"": ""any private encryption scheme"","
"        ""9e6c4e1f-7d60-472f-ba1a-a39ef669e4b2"": ""Block credential stealing from the Windows local security authority subsystem (lsass.exe)"","
"        ""A"": ""AccessAllowed"","
"        ""AC"": (""ALL APPLICATION PACKAGES"", ""S-1-15-2-1""),"
"        ""AL"": ""SystemAlarm"""
"        ""AN"": (""NT AUTHORITY"
"        ""AO"": (""NT AUTHORITY"
"        ""AU"": ""SystemAudit"","
"        ""AU"": (""NT AUTHORITY"
"        ""AppData"
"        ""BA"": (""BUILTIN"
"        ""BG"": (""BUILTIN"
"        ""BK"": (""BUILTIN"
"        ""BO"": (""BUILTIN"
"        ""BP"": (""BUILTIN"
"        ""BS"": (""BUILTIN"
"        ""BU"": (""BUILTIN"
"        ""CA"": (""Certificate Publishers"", ""S-1-5-21domain-517""),"
"        ""CG"": (""Creator Group"", ""S-1-3-1""),"
"        ""CN"": (""BUILTIN"
"        ""CO"": (""Creator Owner"", ""S-1-3-0""),"
"        ""CY"": (""NT AUTHORITY"
"        ""D"": ""AccessDenied"","
"        ""DA"": (""Domain Admins"", ""S-1-5-21domain-512""),"
"        ""DC"": (""Domain Computers"", ""S-1-5-21domain-515""),"
"        ""DD"": (""BUILTIN"
"        ""DU"": (""Domain Users"", ""S-1-5-21domain-513""),"
"        ""EA"": (""Enterprise Admins"", ""S-1-5-21root domain-519""),"
"        ""ED"": (""Enterprise Domain Controllers"", ""S-1-5-9""),"
"        ""IU"": (""NT AUTHORITY"
"        ""LS"": (""NT AUTHORITY"
"        ""Microsoft-Windows-PowerShell/Operational"","
"        ""NO"": (""BUILTIN"
"        ""NS"": (""NT AUTHORITY"
"        ""NU"": (""Network"", ""S-1-5-2""),"
"        ""OA"": ""ObjectAccessAllowed"","
"        ""OD"": ""ObjectAccessDenied"","
"        ""OW"": (""OWNER RIGHTS"", ""S-1-3-4""),"
"        ""PA"": (""BUILTIN"
"        ""PS"": (""Principal Self"", ""S-1-5-10""),"
"        ""PU"": (""BUILTIN"
"        ""RA"": (""RESTRICTED APPLICATION PACKAGES"", ""S-1-15-2-2""),"
"        ""RC"": (""BUILTIN"
"        ""RE"": (""BUILTIN"
"        ""RM"": (""NT AUTHORITY"
"        ""RS"": (""RAS and IAS Servers"", ""S-1-5-21domain-553""),"
"        ""RU"": (""BUILTIN"
"        ""SOFTWARE"
"        ""SY"": (""NT AUTHORITY"
"        ""WD"": (""Everyone"", ""S-1-1-0""),"
"        ""WR"": (""Everyone"", ""S-1-1-0""),"
"        ""Windows PowerShell"""
"        ""b2b3f03d-6a65-4f7b-a9c7-1c7ef74a9ba4"": ""Block untrusted and unsigned processes that run from USB"","
"        ""be9ba2d9-53ea-4cdc-84e5-9b1eeee46550"": ""Block executable content from email client and webmail"","
"        ""brave"": ""Brave Browser"","
"        ""c1db55ab-c21a-4637-bb3f-a12568109d35"": ""Use advanced protection against ransomware"","
"        ""chrome"":""Google Chrome"","
"        ""cmd""        :""Command Prompt"","
"        ""cmrcservice"":""Configuration Manager Remote Control Service"","
"        ""d1e49aac-8f56-4280-b9ba-993a6d77406c"": ""Block process creations originating from PSExec and WMI commands"","
"        ""d3e037e1-3eb8-44c8-a917-57927947596d"": ""Block JavaScript or VBScript from launching downloaded executable content"","
"        ""d4f940ab-401b-4efc-aadc-ad5f3c50688a"": ""Block all Office applications from creating child processes"","
"        ""e6db77e5-3df2-4cf1-b95a-636979351e5b"": ""Block persistence through WMI event subscription"","
"        ""firefox"": ""Mozilla Firefox"","
"        ""ftp""        :""Misc. FTP client"","
"        ""iexplore"": ""Microsoft Internet Explorer"","
"        ""kaseya.agentendpoint.exe"": ""Command Prompt"","
"        ""keepass""    :""KeePass password vault"","
"        ""kitty""      :""Kitty SSH client"","
"        ""lmiguardian"":""LogMeIn Reporter"","
"        ""logmeinsystray"":""LogMeIn System Tray"","
"        ""mmc""        :""Microsoft Management Console"","
"        ""msedge"": ""Microsoft Edge"","
"        ""mstsc""      :""Microsoft RDP client"","
"        ""opera"": ""Opera Browser"","
"        ""pageant""    :""Putty SSH auth agent"","
"        ""plink""      :""Putty CLI client"","
"        ""powershell"" :""PowerShell host process"","
"        ""pscp""       :""Putty SCP client"","
"        ""psftp""      :""Putty SFTP client"","
"        ""putty""      :""Putty SSH client"","
"        ""puttytel""   :""Putty Telnet client"","
"        ""ramaint""    :""LogMeIn maintenance sevice"","
"        ""securecrt""  :""SecureCRT SSH/Telnet client"","
"        ""teamviewer"" :""TeamViewer"","
"        ""telnet""     :""Misc. Telnet client"","
"        ""tv_w32""     :""TeamViewer x86 remote control"","
"        ""tv_x64""     :""TeamViewer x64 remote control"","
"        ""vnc""        :""Possible VNC client"","
"        (next_token) = struct.unpack_from('<B', buf, offset "
"        (sub_token, sub_id, sub_type) = struct.unpack_from('<BHB', buf, offset)"
"        0: ""Disk Drive"","
"        1: ""Print Queue"","
"        2147483648: ""Disk Drive Admin"","
"        2147483649: ""Print Queue Admin"","
"        2147483650: ""Device Admin"","
"        2147483651: ""IPC Admin"","
"        2: ""Device "","
"        3: ""IPC"","
"        ClientSettings(restricted_admin != None and restricted_admin != 0, restricted_admin_type, server_auth_level, disable_pw_saving != None or disable_pw_saving != 0 ),"
"        ServerSettings(nla, block_clipboard, block_com_port, block_drives, block_lpt_port, block_smart_card, block_pnp, block_printers))"
"        WINDOWS_EPOCH = datetime(1601, 1, 1, tzinfo=timezone.utc)"
"        access_str = ace_types.get(ace_type, ""Unknown"")"
"        ace_type, rights, inheritance_flags, prop_flags, object_type, trustee = match.groups()"
"        all_args = "" "".join(args)"
"        asr_enabled = wmi_conn.get_dword_value('HKLM', f'{reg_key}"
"        asr_exclusions = wmi_conn.get_registry_value('HKLM', f'{reg_key}"
"        asr_rules = wmi_conn.get_registry_value('HKLM', f'{reg_key}"
"        attrs = "" "".join(attrs)"
"        attrs = filter(lambda x: x != None, map(lambda x: x.xml(template), self._attributes))"
"        binding = epm.hept_map(destHost=self.target, remoteIf=EVEN6_UUID, protocol = 'ncacn_ip_tcp')"
"        bookmark_bar = roots[""bookmark_bar""]"
"        children = bookmark_bar[""children""]"
"        chrome_path = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"        classObject, _ = self.iWbemServices.GetObject('StdRegProv')"
"        commands_dir = ""commands"""
"        config = wmi_conn.get_string_value('HKLM', f'SOFTWARE"
"        date_connected_bytes = wmi_conn.get_binary_value('HKLM', f'SOFTWARE"
"        date_created_bytes = wmi_conn.get_binary_value('HKLM', f'SOFTWARE"
"        def __init__(self, version_str: str):"
"        description = wmi_conn.get_string_value('HKLM', f'SOFTWARE"
"        directory_listing = smb_conn.list_directory(share, path)"
"        directory_listing = smb_conn.list_directory(share, user_path)"
"        dirs = smb_conn.list_directory(share, path)"
"        domain_ignore_regex = """
"        elif trustee.startswith(""S-1-""):"
"        encoding = chardet.detect(output)[""encoding""]"
"        env_data = wmi_conn.wmi_get('Select UserName,Name,VariableValue from win32_environment')"
"        even_conn = EVENHandler(address, username, password, domain, options.hashes, options.aesKey, options.k, options.dc_ip)"
"        except (TypeError, ValueError):"
"        excluded_path = wmi_conn.get_string_value('HKLM', f'{reg_key}"
"        exclusion_path = wmi_conn.get_registry_value('HKLM', f'{reg_key}"
"        extension_exclusion_data = wmi_conn.get_registry_value('HKLM', f'{reg_key}"
"        feature = OptionalFeatures(data['Name'], data['Caption'], state)"
"        filename = filename.replace('/','"
"        firewall_rules = wmi_conn.get_registry_value('HKLM', f'{rule_location}"
"        for chrome_presence in get_chrome_presence(wmi_conn, smb_conn):"
"        for data in root.findall('.//ns:EventData/ns:Data', ns):"
"        for dotnet_info in get_dotnet(wmi_conn, smb_conn):"
"        for events in get_explicit_logon_events(even_conn, args):"
"        for events in get_logon_events(even_conn, args):"
"        for events in get_powered_on_events(even_conn, args):"
"        for events in get_powershell_events(even_conn, args):"
"        for events in get_process_creation_events(even_conn, args):"
"        for events in get_sysmon_events(even_conn, args):"
"        for fw in get_fw_rules(wmi_conn, args):"
"        for groups in get_local_groups(samr_conn, args, address):"
"        for ieurls in get_ie_urls(wmi_conn, args):"
"        for info in get_osinfo(wmi_conn, address):"
"        for key, val in action.Properties.items():"
"        for key, value in ordered_dict.items():"
"        for key, value in settings.items():"
"        for key, value in sorted(query_result.items()):"
"        for kvp, val in host_keys.items():"
"        for module_name, args in command_args.items():"
"        for name, type in zip(value_names, value_types):"
"        for ps in get_powershell(wmi_conn, smb_conn):"
"        for ps_hist in get_powershell_history(smb_conn, args):"
"        for sch_task in get_scheduled_tasks(wmi_conn ,args):"
"        for sub_key, sub_val in item_val.items():"
"        for users in get_local_users(samr_conn, address):"
"        for wmi in get_wmi(wmi_conn, wmi_query):"
"        formatted_time = local_time.strftime(""%m/%d/%Y %I:%M:%S %p"")"
"        hash, length = struct.unpack_from('<HH', buf, offset)"
"        header_token, major_version, minor_version, flags, next_token = struct.unpack_from('<BBBBB', buf, offset)"
"        host_keys = wmi_conn.get_registry_value('HKU', f'{sid}"
"        if (filter_results and re.match(data['Computer'], target_username) or re.match(r'"
"        if chrome.ChromeVersion and chrome.ChromeVersion.startswith(""8""):"
"        if command_line != """":"
"        if hasattr(obj, 'Key') and hasattr(obj, 'Value'):"
"        if isinstance(obj_or_list, list):"
"        if isinstance(settings, list) and all(isinstance(item, str) for item in settings):"
"        if smb_conn.file_exists(share, f'{path}"
"        if user_regex is None and re.match(domain_ignore_regex, target_domainname, re.IGNORECASE):"
"        if user_regex is None and re.match(user_ignore_regex, target_username, re.IGNORECASE):"
"        if user_regex is not None and not re.match(user_regex, target_username):"
"        if user_regex is not None and not re.match(user_regex, target_username, re.IGNORECASE):"
"        laps_admin_account_name = wmi_conn.get_string_value('HKLM', 'Software"
"        laps_password_complexity = wmi_conn.get_string_value('HKLM', 'Software"
"        laps_password_length = wmi_conn.get_string_value('HKLM', 'Software"
"        laps_pwd_expiration_protection_enabled = wmi_conn.get_string_value('HKLM', 'Software"
"        lm_package_name = """" if lm_package == ""-"" else lm_package"
"        logon_map[logon_id] = [domain, user]"
"        logon_type = """""
"        m = logon_id_regex.search(str(data[""Dependent""]))"
"        m2 = user_domain_regex.search(str(data[""Antecedent""]))"
"        managed = wmi_conn.get_dword_value('HKLM', f'SOFTWARE"
"        matches = re.finditer(ace_pattern, sddl_string)"
"        networkcategory = wmi_conn.get_dword_value('HKLM', f'SOFTWARE"
"        networktype = wmi_conn.get_dword_value('HKLM', f'SOFTWARE"
"        od_account = wmi_conn.get_subkey_names('HKU', f'{sid}"
"        pathname = ntpath.join(path,filename)"
"        print(""      ------------------------------"")"
"        print(""    ["
"        print(""  ----------                         ------------"")"
"        print(""  RemoteHost                         UsernameHint"")"
"        print(""  ["
"        print(""  [X] 'MSFT_DNSClientCache' WMI class unavailable (minimum supported versions of Windows: 8/2012)"")"
"        print(""  [X] 'MSFT_ScheduledTask' WMI class unavailable (minimum supported versions of Windows: 8/2012)"")"
"        print(""[-] File is not a valid JSON"")"
"        print(f""      NTLMMinClientSec        : {ntlm.NTLMMinClientSec} ({client_sess_sec})"")"
"        print(f""      NTLMMinServerSec        : {ntlm.NTLMMinServerSec} ({server_sess_sec})"
"        print(f""      {'Enabled':<30}:   {trigger.Enabled}"")"
"        print(f""      {'Type':<30}:   {action.Type}"")"
"        print(f""      {'Type':<30}:   {trigger.Type}"")"
"        print(f""    '"
"        print(f""    'Cookies'                   ({slack.CookiesLastModified})  :  Download the 'Cookies' and 'storage"
"        print(f""    'key3.db'        ({firefox.CredentialFile3LastModified})  :  Credentials file, run SharpWeb (https://github.com/djhohnstein/SharpWeb)"")"
"        print(f""    'key4.db'        ({firefox.CredentialFile4LastModified})  :  Credentials file, run SharpWeb (https://github.com/djhohnstein/SharpWeb)"")"
"        print(f""    'places.sqlite'  ({firefox.HistoryLastModified})  :  History file, run the 'FirefoxTriage' command"")"
"        print(f""    Domain : {workspace.Domain}"")"
"        print(f""    DownloadPath : {download.DownloadPath}"")"
"        print(f""    FilePath    : {config.FilePath}"")"
"        print(f""    Host        : {config.Host}"")"
"        print(f""    ID     : {workspace.ID}"")"
"        print(f""    Name   : {workspace.Name}"")"
"        print(f""    Port        : {config.Port}"")"
"        print(f""    Protocol    : {config.Protocol}"")"
"        print(f""    SessionID   : {config.SessionID}"")"
"        print(f""    SessionName : {config.SessionName}"")"
"        print(f""    StartTime    : {download.StartTime}"
"        print(f""    TeamID       : {download.TeamID}"")"
"        print(f""    UserId       : {download.UserID}"")"
"        print(f""    Username    : {config.UserName}"")"
"        print(f""    {d.LastAccessed:<22}    {d.LastModified:<22}    {d.FileName}"")"
"        print(f""  {'ConsentPromptBehaviorAdmin':<30} : PromptForNonWindowsBinaries"")"
"        print(f""  {'ConsentPromptBehaviorAdmin':<30} : {uac.ConsentPromptBehaviorAdmin} - No prompting"")"
"        print(f""  {'ConsentPromptBehaviorAdmin':<30} : {uac.ConsentPromptBehaviorAdmin} - PromptForCredsNotOnSecureDesktop"")"
"        print(f""  {'ConsentPromptBehaviorAdmin':<30} : {uac.ConsentPromptBehaviorAdmin} - PromptForNonWindowsBinaries"")"
"        print(f""  {'ConsentPromptBehaviorAdmin':<30} : {uac.ConsentPromptBehaviorAdmin} - PromptForPermitDenyNotOnSecureDesktop"")"
"        print(f""  {'ConsentPromptBehaviorAdmin':<30} : {uac.ConsentPromptBehaviorAdmin} - PromptOnSecureDesktop"")"
"        print(f""  {'ConsentPromptBehaviorAdmin':<30} : {uac.ConsentPromptBehaviorAdmin} - PromptPermitDenyOnSecureDesktop"")"
"        print(f""  {'LAPS Admin Account Name':<37} : {laps.LAPSAdminAccountName}"")"
"        print(f""  {'LAPS Enabled':<37} : {laps.AdmPwdEnabled}"")"
"        print(f""  {'LAPS Expiration Protection Enable':<37} : {laps.LapsPwdExpirationProtectionEnabled}"")"
"        print(f""  {'LAPS Password Complexity':<37} : {laps.LAPSPasswordComplexity}"")"
"        print(f""  {'LAPS Password Length':<37} : {laps.LAPSPasswordLength}"")"
"        print(f""  {name:<30}: {v}"")"
"        print(f""  {name:<30}:"")"
"        print(f"""
"        print(f""[-] Error processing bookmarks: {str(e)}"")"
"        print(f""[-] Expected key not found in JSON structure: {e}"")"
"        print(f""{'State':<8} {'Name':<50} {'Caption'}"")"
"        print(f'     {""SessionName"":<20} : {sessions[""SessionName""]}')"
"        print(f'    {""State"":<10} Rule"
"        proc_exclusions_data = wmi_conn.get_registry_value('HKLM', f'{reg_key}"
"        proc_regex = [re.compile(all_args, re.IGNORECASE "
"        profile_name = wmi_conn.get_string_value('HKLM', f'SOFTWARE"
"        provider_clsids = wmi_data.get_subkey_names('HKLM', 'SOFTWARE"
"        provider_path_key = f""SOFTWARE"
"        ps_regex = [re.compile(all_args, re.IGNORECASE "
"        pwd = ntpath.join(path,'"
"        pwd = pwd.replace('/','"
"        query = f"""
"        query = f""SELECT VariableValue from win32_environment WHERE name='{variable}' AND UserName='<SYSTEM>'"""
"        raise ValueError(""find must be either 'lowest' or 'highest'"")"
"        ret_vals = classObject.EnumKey(hive_num, '')"
"        ret_vals = classObject.EnumKey(hive_num, key_path)"
"        ret_vals = classObject.EnumValues(hive_num, key_path)"
"        ret_vals = classObject.GetBinaryValue(hive_num, key_path, value_name)"
"        ret_vals = classObject.GetStringValue(hive_num, key_path, value_name)"
"        return None if val == None else '{}=""{}""'.format(self._name.val, val)"
"        return datetime.min.strftime(""%m/%d/%Y %I:%M:%S %p"")"
"        return hive_map.get(hive, 0x80000002)"
"        return max(versions, key=parse_version)"
"        return min(versions, key=parse_version)"
"        return tuple(map(int, version.split('.')))"
"        roots = deserialized[""roots""]"
"        samr_conn = SAMRHandler(address, username, password, domain, options.hashes, options.aesKey, options.k, options.dc_ip)"
"        security_element = root.find('.//pc:Security', namespaces)"
"        self._name = Name(buf, offset "
"        self._xml = BinXML(buf, 0x14)"
"        self.connection.getFile(share, file_path, file_obj.write)"
"        self.length, self.type, value_eof = struct.unpack_from('<HBB', buf, offset)"
"        settings = wmi_obj.get_registry_value('HKLM', i)"
"        shutdown_int = struct.unpack('<Q', shutdown_bytes)[0]"
"        sids = wmi_conn.get_subkey_names('HKU', '')"
"        smb_conn = SMBHandler(address, username, password, domain, options.hashes, options.aesKey, options.k, options.dc_ip)"
"        start_time = datetime.now().strftime(""%m/%d/%Y %I:%M:%S %p"") "
"        sub_key_names = wmi_conn.get_subkey_names('HKLM', prod)"
"        subkeys = wmi_conn.get_subkey_names('HKU', f'{sid}"
"        sysmon_regex = [re.compile(all_args, re.IGNORECASE "
"        token = struct.unpack_from('<B', buf, offset)"
"        token, dependency_id, length = struct.unpack_from('<BHI', buf, offset)"
"        token, string_type, length = struct.unpack_from('<BBH', buf, offset)"
"        token, unknown0, guid, length, next_token = struct.unpack_from('<BB16sIB', buf, offset)"
"        total_size, header_size, event_offset, bookmark_offset, binxml_size = struct.unpack_from('<IIIII', buf)"
"        user_domain = ["""", """"]"
"        user_ignore_regex = f"""
"        v = "","".join(str_values)"
"        ver = wmi_conn.get_string_value('HKLM', f'SOFTWARE"
"        wmi_conn = WMIHandler(address, wmi_namespace, username, password, domain, options.hashes, options.aesKey, options.k, options.dc_ip)"
"        wmi_data = wmi_conn.wmi_get('SELECT Actions, Author, Date, Description, Documentation, Principal, SecurityDescriptor, Source, State, TaskName, TaskPath, Triggers, URI, Version FROM MSFT_ScheduledTask')"
"        xml_event = even_conn.EvtRpcRegisterLogQuery_EvtRpcQueryNext(log_name, query)"
"        yield AMSIProviders(provider_clsid, provider_path)"
"        yield AntiVirus(data['displayName'], data['pathToSignedProductExe'], data['pathToSignedReportingExe'])"
"        yield AppLocker(False, appIdSvcState, key_name, enforcementModeStr, rules)"
"        yield AppLocker(True, appIdSvcState, key_name, enforcementModeStr, rules)"
"        yield CloudSyncProviders(sid, o)"
"        yield CredGuard(vbs_setting , configured, running)"
"        yield DNSCache(data['Entry'], data['Name'], data['Data'])"
"        yield EnvironmentVariables(data['UserName'], data['Name'], data['VariableValue'])"
"        yield ExplicitLogonEvents(subject_username, subject_domainname, target_username, target_domainname, process_name, ip_address, data['TimeCreated.SystemTime'])"
"        yield HotFix(data['HotFixID'], data['InstalledOn'], data['Description'], data['InstalledBy'])"
"        yield LAPS(""1"", laps_admin_account_name, laps_password_complexity, laps_password_length, laps_pwd_expiration_protection_enabled)"
"        yield LAPS('False', None, None, None, None)"
"        yield LocalUser(computername, user['name'], user['enabled'], user['rid'], user['user_type'], user['comment'], user['pwd_last_set'], user['last_logon'], user['num_logins'])"
"        yield LogonEvents(data['TimeCreated.SystemTime'], target_username, target_domainname, logon_type, ip_address, subject_username, subject_domainname, authentication_package, lm_package, target_outbound_user, target_outbound_domain)"
"        yield LogonSession('WMI', user_name, domain, logon_id, logon_type, data_two['AuthenticationPackage'], start_time, '', '', '', '', '')"
"        yield MappedDrives(data['LocalName'], data['RemoteName'], data['RemotePath'], data['Status'], data['ConnectionState'], data['Persistent'], data['UserName'], data['Description'])"
"        yield NetworkProfiles(profile_name, description, network_category, network_type, managed, date_created, date_lastconnected)"
"        yield NetworkShares(data['Name'], data['Path'], data['Description'], types)"
"        yield PSSessionSettings(plugin, access)"
"        yield PoweredOnEvent(event['TimeCreated.SystemTime'], action)"
"        yield ProcessOwner(data['Name'], data['ProcessId'], owner)"
"        yield PuttyHostKeys(sid, keys)"
"        yield RDPSavedConnection(sid, connections)"
"        yield ScheduledTask(data['TaskName'], principal, data['Author'], data['Description'], data['Source'], state, data['SecurityDescriptor'], actions_list, trigger_objects, None, data['TaskPath'], None, data['Date'], None, None, None, None, None)"
"     print(""No share selected"")"
"    """""")"
"    adm_pwd_enabled = wmi_conn.get_string_value('HKLM', 'Software"
"    alt_domain_name = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    alt_password = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    alt_user_name = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    appIdSvcState = ""Service not found"""
"    block_clipboard = wmi_conn.get_dword_value('HKLM', 'SOFTWARE"
"    block_com_port = wmi_conn.get_dword_value('HKLM', 'SOFTWARE"
"    block_drives = wmi_conn.get_dword_value('HKLM', 'SOFTWARE"
"    block_lpt_port = wmi_conn.get_dword_value('HKLM', 'SOFTWARE"
"    block_pnp = wmi_conn.get_dword_value('HKLM', 'SOFTWARE"
"    block_printers = wmi_conn.get_dword_value('HKLM', 'SOFTWARE"
"    block_smart_card = wmi_conn.get_dword_value('HKLM', 'SOFTWARE"
"    boot_formatted = boot_time.strftime(""%m/%d/%Y %I:%M:%S %p"")"
"    boot_time_str = f""{uptime.days:02d}:{uptime.seconds//3600:02d}:{(uptime.seconds//60)%60:02d}:{uptime.seconds%60:02d}"""
"    build_branch = wmi_conn.get_string_value('HKLM', 'Software"
"    build_number = wmi_conn.get_string_value('HKLM', 'Software"
"    client_nego_signing = wmi_conn.get_dword_value('HKLM', 'System"
"    client_req_signing = wmi_conn.get_dword_value('HKLM', 'System"
"    command_group = ['misc', 'chromium', 'remote']"
"    command_group = ['misc', 'remote', 'test']"
"    command_group = ['misc', 'remote']"
"    command_group = ['system', 'remote']"
"    command_group = ['user', 'chromium', 'remote']"
"    command_group = ['user', 'remote']"
"    command_string = "" "".join(commands)"
"    content_prompt = wmi_conn.get_dword_value('HKLM', 'SOFTWARE"
"    current_major_version = wmi_conn.get_dword_value('HKLM', 'Software"
"    current_utc_formatted = current_time.strftime(""%m/%d/%Y %I:%M:%S %p"")"
"    current_version = wmi_conn.get_string_value('HKLM', 'Software"
"    day = int(f""{bytes_data[7]:02X}{bytes_data[6]:02X}"", 16)"
"    def EvtRpcRegisterLogQuery_EvtRpcQueryNext(self, log_name, query):"
"    def __init__(self, admpwdenabled: str, lapsadminaccountname: str, lapspasswordcomplexity:str, lapspasswordlength: str, lapspwdexpirationprotectionenabled: str):"
"    def __init__(self, buf):"
"    def __init__(self, buf, offset):"
"    def __init__(self, buf, offset, value_offset):"
"    def __init__(self, category: str, process: str, product: str, processid: str, owner: str, commandline: str):"
"    def __init__(self, clientsettings: ClientSettings, serversettings: ServerSettings):"
"    def __init__(self, computername: str, groupname: str, groupcomment: str, members: list):"
"    def __init__(self, computername: str, username: str, enabled: bool, rid: int, usertype: str, comment: str, pwdlastset: datetime, lastlogon: str, numlogins: str):"
"    def __init__(self, configured: bool, appidsvcstate: str, keyname: str, enforcementmode: str, rules: str):"
"    def __init__(self, consentpromptbehavioradmin: int, enablelua: int, filteradministratortoken: int, localaccounttokenfilterpolicy: int):"
"    def __init__(self, credtype: str, filename: str, lastaccessed: str, lastmodified: str, size: str):"
"    def __init__(self, dateutc: datetime, description: str):"
"    def __init__(self, defaultdomainname: str, defaultusername: str, defaultpassword: str, altdomainname: str, altusername: str, altpassword: str):"
"    def __init__(self, displayname: str, displayversion: str, publisher: str, installdate: str, architecture: str):"
"    def __init__(self, enabled: bool):"
"    def __init__(self, enabled: bool, publisher: str, version: str):"
"    def __init__(self, engine: str, productexe: str, reportingexe: str):"
"    def __init__(self, entry: str, name :str, data: str):"
"    def __init__(self, enumerationmethod: str, username: str, domain: str, logonid: str, logontype: str, authenticationpackage: str, starttime: str, logontime: str, logonserver: str, logonserverdnsdomain: str, userprincipalname: str, usersid: str):"
"    def __init__(self, filename: str, lastaccessed: str, lastmodified: str):"
"    def __init__(self, filename: str, lastaccessed: str, lastmodified: str, masterkeyguid: str, size: str):"
"    def __init__(self, filepath: str, name: str, host: str, port: str, protocol: str, username: str, password: str):"
"    def __init__(self, filepath: str, sessionid: str, sessionname: str, host: str, port: str, protocol: str, username: str, extraargs: str):"
"    def __init__(self, folder: str, cookieslastmodified: datetime, workspaceslastmodified: datetime, downloadslastmodified: datetime):"
"    def __init__(self, folder: str, downloads: list):"
"    def __init__(self, folder: str, historylastmodified: datetime, credentialfile3lastmodified: datetime, credentialfile4lastmodified: datetime):"
"    def __init__(self, folder: str, historylastmodified: str, cookieslastmodified: str, logindatalastmodified: str, chromeversion: str):"
"    def __init__(self, folder: str, masterkeys: list):"
"    def __init__(self, guid: str, providerpath: str):"
"    def __init__(self, hostname: str, domain: str, username: str, productname: str, editionid: str, releaseid: str, build: str, buildbranch: str, currentmajorversionnumber: str, currentversion: str, architecture: str, processorcount: str, isvirtualmachine: bool, boottimeutc: str, ishighintegrity: bool, islocaladmin: bool, currenttimeutc: str, timezone: str, timezoneutcoffset: str, locale: str, inputlanguage: str, installedinputlanguages: str, machineguid: str):"
"    def __init__(self, hotfixid: str, installedonutc: str, description: str, installedby: str):"
"    def __init__(self, installed: bool, hashingalgorithm: SysmonHashAlgorithm, options: SysmonOptions, rules: str):"
"    def __init__(self, installedclrversions: list, installedversions: list, transcriptionlogging: str, transcriptioninvocationlogging: str, transcriptiondirectory: str, modulelogging: str, modulenames: str, scriptblocklogging: str, scriptblockinvocationlogging: str, ossupportamsi: str):"
"    def __init__(self, installedclrversions: str, installeddotnetversions: str, ossupportsamsi: str):"
"    def __init__(self, key: str, entries: list):"
"    def __init__(self, key: str, value: str):"
"    def __init__(self, lanmancompatabilitylevel: str, clientrequiresigning: bool, clientnegotiatesigning: bool, serverrequiresigning: bool, servernegotiatesigning: bool, ldapsigning: str, ntlmminclientsec: str, ntlmminserversec: str, inboundrestrictions: str, outboundrestrictions: str, inboundauditing: str, outboundexceptions: str):"
"    def __init__(self, lastshutdown: str):"
"    def __init__(self, localname: str, remotename: str, remotepath: str, status: str, connectionstate: str, persistent: str, username: str, description: str):"
"    def __init__(self, localsettings: WindowsDefendersettings, grouppolicysettings: WindowsDefendersettings):"
"    def __init__(self, location: str):"
"    def __init__(self, name: str = None, description: str = None, applicationname: str = None, protocol: str = None, action: str = None, direction: str = None, profiles: str = None, localaddress: str = None, localports: str = None, remoteaddress: str = None, remoteports: str = None):"
"    def __init__(self, name: str = None, domain: str = None, id: str = None):"
"    def __init__(self, name: str, caption: str, state: str):"
"    def __init__(self, name: str, path: str, description: str, type: str):"
"    def __init__(self, name: str, principal: ScheduledTaskPrincipal, author: str, description: str, source: str, state: str, sddl: str, actions: ScheduledTaskAction, triggers: ScheduledTaskTrigger, enabled: str, taskpath: str, hidden: str, date: str, allowdemandstart: str, allowhardterminate: str, disallowstartifonbatteries: str, executiontimelimit: str, stopifgoingonbatteries: str):"
"    def __init__(self, name: str, url: str):"
"    def __init__(self, nla: int, blockclipboardredirection: int, blockcomportredirection: int, blockdriveredirection: int, blocklptportredirection: int, allowsmartcardredirection: int, blockpnpdeviceredirection: int, blockprinterredirection: int):"
"    def __init__(self, plugin: str, permission: list):"
"    def __init__(self, present: bool = False, enabled: bool = False, defaultinboundaction: FirewallAction = None, defaultoutboundaction: FirewallAction = None, disablenotifications: bool = None):"
"    def __init__(self, principal: str, sid: str, permission: str):"
"    def __init__(self, processname: str, processid: str, owner: str):"
"    def __init__(self, profilename: str, description: str, networkcategory: str, networktype: str, managed: str, datecreated: str, datelastconnected: str):"
"    def __init__(self, queryresults: dict):"
"    def __init__(self, remotehost: str, usernamehint: str):"
"    def __init__(self, restrictedadmin: bool, restrictedadmintype: int, serverauthlevel: int, disablepasswordsaving: bool):"
"    def __init__(self, rule: uuid, state: int):"
"    def __init__(self, server: str, sitecode: str, productversion: str, lastsuccessfulinstallparams: str):"
"    def __init__(self, sid: str, commands :str):"
"    def __init__(self, sid: str, connections: list):"
"    def __init__(self, sid: str, hostkeys: list):"
"    def __init__(self, sid: str, odsp: OneDriveSyncProvider):"
"    def __init__(self, sid: str, sessions: list):"
"    def __init__(self, sid: str, urls: list):"
"    def __init__(self, subjectuser: str, subjectdomain :str, targetuser: str, targetdomain: str, process: str, ipaddress: str, timecreatedutc: datetime):"
"    def __init__(self, target, namespace, username='', password='', domain='', hashes=None, aesKey=None, doKerberos=False, kdcHost=None):"
"    def __init__(self, target, username='', password='', domain='', hashes=None, aesKey=None, doKerberos=False, kdcHost=None):"
"    def __init__(self, target: str, username: str = '', password: str = '', domain: str = '', hashes: str = None, aesKey: str = None, doKerberos: bool = False, kdcHost: str = None):"
"    def __init__(self, teamid: str = None, userid: str = None, downloadpath: str = None, datetime: datetime = None):"
"    def __init__(self, time: str, url: str):"
"    def __init__(self, timecreated: datetime, eventid: int, userid: str, match: str, context: str):"
"    def __init__(self, timecreated: datetime, eventid: int, username: str, match: str):"
"    def __init__(self, timecreatedutc: datetime, eventid: int, user: str, match: str):"
"    def __init__(self, timecreatedutc: datetime, targetusername :str, targetdomainname: str, logontype: str, ipaddress: str, subjectusername: str, subjectdomainname: str, authenticationpackage: str, lmpackage: str, targetoutboundusername: str, targetoutbounddomainname: str):"
"    def __init__(self, username: str, configs: FileZillaConfig):"
"    def __init__(self, username: str, configs: list):"
"    def __init__(self, username: str, consolehistorypath: str, match: str, contextjoined: str):"
"    def __init__(self, username: str, downloads: list):"
"    def __init__(self, username: str, favorites: list):"
"    def __init__(self, username: str, filepath: str, bookmarks: list):"
"    def __init__(self, username: str, filepath: str, urls: list):"
"    def __init__(self, username: str, history: list):"
"    def __init__(self, username: str, name :str, value: str):"
"    def __init__(self, username: str, workspaces: list):"
"    def __init__(self, usewuserver: str, server: str, alternateserver: str, statisticsserver: str):"
"    def __init__(self, virtualizationbasedsecuritystatus: VBS, configured: bool, running: bool):"
"    def _filetime_to_datetime(filetime: Dict[str, int]) -> Optional[datetime]:"
"    def _get_domain_handle(self, builtin: bool = False) -> bytes:"
"    def _get_hive_num(self, hive):"
"    def file_exists(self, share, file_path):"
"    def full_query(self, wql):"
"    def get_binary_value(self, hive, key_path, value_name):"
"    def get_defender_settings(self, wmi_conn, reg_key):"
"    def get_dword_value(self, hive, key_path, value_name):"
"    def get_env_var(self, variable):"
"    def get_file_size(self, share, file_path):"
"    def get_last_access_time(self, share, file_path):"
"    def get_last_write_time(self, share, file_path):"
"    def get_local_group_members(self, group_name: str):"
"    def get_registry_value(self, hive, key_path):"
"    def get_string_value(self, hive, key_path, value_name):"
"    def get_subkey_names(self, hive, key_path):"
"    def get_version_info(self, share, file_path):"
"    def get_wmi_data(self, iEnum):"
"    def get_wmi_object(self, wql):"
"    def list_directory(self, share, path):"
"    def parse_event(self, event_data):"
"    def parse_version_info(self, file_data):"
"    def parse_wmi(self, ordered_dict):"
"    def parse_wmi_key(self, ordered_dict, wmi_keys):"
"    def parse_wmi_object(self, hex_string):"
"    def parse_xml(self, xml_content):"
"    def query(self, wql):"
"    def read_file_raw(self, share, file_path):"
"    def read_special(self, share, file_path):"
"    def show_file_content(self, share, path, filename):"
"    def wmi_get(self, wql):"
"    def xml(self, template = None):"
"    default_domain_name = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    default_password = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    default_user_name = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    delta = datetime(1970, 1, 1, tzinfo=timezone.utc) - windows_epoch"
"    description = '""Interesting"" processes - defensive products and admin tools'"
"    description = 'AppLocker settings, if installed'"
"    description = 'Basic OS info (i.e. architecture, OS version, etc.)'"
"    description = 'Explicit Logon events (Event ID 4648) from the security event log. Default of 7 days, argument == last X days'"
"    description = 'Internet Explorer typed URLs (last 7 days, argument == last X days)'"
"    description = 'LAPS settings, if installed'"
"    description = 'Local users, whether they"
"    description = 'Logon events (Event ID 4624) from the security event log. Default of 10 days, argument == last X days.'"
"    description = 'Non-empty local groups, ""-full"" displays all groups (argument == computername to enumerate)'"
"    description = 'Non-standard firewall rules, ""-full"" dumps all (arguments == allow/deny/tcp/udp/in/out/domain/private/public)'"
"    description = 'Reboot and sleep schedule based on the System event log EIDs 1, 12, 13, 42, and 6008. Default of 7 days, argument == last X days.'"
"    description = 'Recent Explorer ""run"" commands'"
"    description = 'SuperPutty configuration files""'"
"    description = 'System Center Configuration Manager (SCCM) settings, if applicable'"
"    description = 'Windows Server Update Services (WSUS) settings, if applicable'"
"    directory_listing = smb_conn.list_directory(share, path)"
"    directory_listing = smb_conn.list_directory(share, user_path)"
"    dirs = smb_conn.list_directory(share, net_path)"
"    disable_pw_saving = wmi_conn.get_dword_value('HKLM', 'SOFTWARE"
"    domain, username, password, address = parse_target(options.target)"
"    dot_net_four = wmi_conn.get_string_value('HKLM ', r'SOFTWARE"
"    dot_net_threefive = wmi_conn.get_string_value('HKLM ', r'SOFTWARE"
"    dt = datetime(year, month, day, hour, minute, second)"
"    edition_id = wmi_conn.get_string_value('HKLM', 'Software"
"    enable_lua = wmi_conn.get_dword_value('HKLM', 'SOFTWARE"
"    filter_admin_token = wmi_conn.get_dword_value('HKLM', 'SOFTWARE"
"    for item_key, item_val in provider.Odsp.OneDriveList.items():"
"    for k, v in settings.items():"
"    for line in format_string(sysmon.Rules, 100):"
"    for r in sorted(results, key=lambda x: x.Name):"
"    formatted_time = utc_dt.astimezone().strftime(""%m/%d/%Y %I:%M %p"")"
"    group.add_argument('-aesKey', action=""store"", metavar=""hex key"", help='AES key to use for Kerberos Authentication '"
"    group.add_argument('-dc-ip', action='store', metavar=""ip address"", help='IP Address of the domain controller. If '"
"    group.add_argument('-hashes', action=""store"", metavar=""LMHASH:NTHASH"", help='NTLM hashes, format is LMHASH:NTHASH')"
"    group.add_argument('-k', action=""store_true"","
"    group.add_argument('-no-pass', action=""store_true"", help='don"
"    group.add_argument('-target-ip', action='store', metavar=""ip address"","
"    group_settings = group_wd.get_defender_settings(wmi_conn, 'SOFTWARE"
"    highest_version = get_version(dotnet_obj.InstalledDotNetVersions, find='highest')"
"    highest_version = max(versions, key=lambda v: (v.major, v.minor, v.build))"
"    hour = int(f""{bytes_data[9]:02X}{bytes_data[8]:02X}"", 16)"
"    if hasattr(options, 'group') and options.group:"
"    if isinstance(commands, str):"
"    inbound_audit = wmi_conn.get_dword_value('HKLM', 'SYSTEM"
"    inbound_restrict = wmi_conn.get_dword_value('HKLM', 'SYSTEM"
"    keys = wmi_conn.get_subkey_names('HKLM', 'Software"
"    keys = wmi_conn.get_subkey_names('HKLM','SOFTWARE"
"    lanman_compat_level = wmi_conn.get_dword_value('HKLM', 'System"
"    last_valid = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    ldap_signing = wmi_conn.get_dword_value('HKLM', 'System"
"    line = """""
"    local_account_token_filter = wmi_conn.get_dword_value('HKLM', 'SOFTWARE"
"    local_settings = local_wd.get_defender_settings(wmi_conn, 'SOFTWARE"
"    local_time_formatted = current_time.astimezone().strftime(""%m/%d/%Y %I:%M:%S %p"")"
"    logon_id_regex = re.compile(r'LogonId=""("
"    lowest_version = get_version(dotnet_obj.InstalledDotNetVersions, find='lowest')"
"    lowest_version = min(versions, key=lambda v: (v.major, v.minor, v.build))"
"    machine_guid = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    matches = re.finditer(ace_pattern, sddl_value)"
"    minute = int(f""{bytes_data[11]:02X}{bytes_data[10]:02X}"", 16)"
"    module_logging = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    module_names = wmi_conn.get_registry_value('HKLM', 'SOFTWARE"
"    module_splits = [cmd.strip() for cmd in command_string.split(',')]"
"    month = int(f""{bytes_data[3]:02X}{bytes_data[2]:02X}"", 16)"
"    name = f""{value_name}({value_type.__name__})"""
"    nla = wmi_conn.get_dword_value('HKLM', 'SOFTWARE"
"    ntlm_min_client_sec = wmi_conn.get_dword_value('HKLM', 'SYSTEM"
"    ntlm_min_server_sec = wmi_conn.get_dword_value('HKLM', 'SYSTEM"
"    outbound_except = wmi_conn.get_string_value('HKLM', 'SYSTEM"
"    outbound_restrict = wmi_conn.get_dword_value('HKLM', 'SYSTEM"
"    parser = argparse.ArgumentParser(add_help=True, description=""Carseat: A junior Seatbelt"")"
"    parser.add_argument('-group', action='store', help='group commands together')"
"    parser.add_argument('command', nargs='"
"    parser.add_argument('target', action='store', help='[[domain/]username[:password]@]<targetName or address>')"
"    path = """
"    plugins = [""Microsoft.PowerShell"", ""Microsoft.PowerShell.Workflow"", ""Microsoft.PowerShell32""]"
"    policy_publisher = wmi_conn.get_string_value('HKLM', 'SYSTEM"
"    policy_version = wmi_conn.get_string_value('HKLM', 'SYSTEM"
"    print(""      ------------------------------"")"
"    print(""      Logged Module Names :"")"
"    print(""  --- TargetUser,ProcessResults,SubjectUser,IpAddress ---"")"
"    print(""  <Dates the credential was used to logon>"
"    print(""  TimeCreated,TargetUser,LogonType,IpAddress,SubjectUsername,AuthenticationPackageName,LmPackageName,TargetOutboundUser"")"
"    print("""
"    print(""Enumerating Windows Hotfixes. For "
"    print(""Logon Sessions (via WMI)"
"    print(""Mapped Drives (via WMI)"
"    print(""Output Format:"")"
"    print(""Powered On Events (Time is local time)"")"
"    print('Format: Date(Local time),User,Command line."
"    print(f""      ClientNegotiateSigning  : {ntlm.ClientNegotiateSigning}"")"
"    print(f""      ClientRequireSigning    : {ntlm.ClientRequireSigning}"")"
"    print(f""      Enabled             : {powershell.ModuleLogging}"")"
"    print(f""      Enabled            : {powershell.TranscriptionLogging}"")"
"    print(f""      InboundAuditing         : {ntlm.InboundAuditing}({inbound_audit_str})"")"
"    print(f""      InboundRestrictions     : {ntlm.InboundRestrictions}({inbound_rest_str})"")"
"    print(f""      Invocation Logging : {powershell.TranscriptionInvocationLogging}"")"
"    print(f""      LdapSigning             : {ntlm.LdapSigning} ({ldap_signing_str})"")"
"    print(f""      Log Directory      : {powershell.TranscriptionDirectory}"")"
"    print(f""      OutboundExceptions      : {ntlm.OutboundExceptions}"")"
"    print(f""      OutboundRestrictions    : {ntlm.OutboundRestrictions}({oubound_rest_str})"")"
"    print(f""      ServerNegotiateSigning  : {ntlm.ServerNegotiateSigning}"")"
"    print(f""      ServerRequireSigning    : {ntlm.ServerRequireSigning}"")"
"    print(f""      {'GroupId':<30}:   {schtask.Principal.GroupId}"")"
"    print(f""      {'Id':<30}:   {schtask.Principal.Id}"")"
"    print(f""      {'LogonType':<30}:   {schtask.Principal.LogonType}"")"
"    print(f""      {'RunLevel':<30}:   {schtask.Principal.RunLevel}"")"
"    print(f""      {'UserId':<30}:   {schtask.Principal.UserId}"")"
"    print(f""  "
"    print(f""  AllowSmartCardRedirection:  {server.AllowSmartCardRedirection}"")"
"    print(f""  BlockClipboardRedirection:  {server.BlockClipboardRedirection}"")"
"    print(f""  BlockComPortRedirection:    {server.BlockComPortRedirection}"")"
"    print(f""  BlockDriveRedirection:      {server.BlockDriveRedirection}"")"
"    print(f""  BlockLptPortRedirection:    {server.BlockLptPortRedirection}"")"
"    print(f""  BlockPnPDeviceRedirection:  {server.BlockPnPDeviceRedirection}"")"
"    print(f""  BlockPrinterRedirection:    {server.BlockPrinterRedirection}"")"
"    print(f""  DisablePasswordSaving: {client.DisablePasswordSaving}"")"
"    print(f""  Folder : {downloads.Folder}"
"    print(f""  LanmanCompatibilityLevel    : {ntlm.LanmanCompatabilityLevel}({lmstr})"")"
"    print(f""  NetworkLevelAuthentication: {server.NetworkLevelAuthentication}"")"
"    print(f""  RestrictedRemoteAdministration: {client.RestrictedRemoteAdministration}"")"
"    print(f""  ["
"    print(f""  {'Actions':<30}    :"")"
"    print(f""  {'AllowDemandStart':<30}    :   {schtask.AllowDemandStart}"")"
"    print(f""  {'Author':<30}    :   {schtask.Author}"")"
"    print(f""  {'Date':<30}    :   {schtask.Date}"")"
"    print(f""  {'Description':<30}    :   {schtask.Description}"")"
"    print(f""  {'DisallowStartIfOnBatteries':<30}    :   {schtask.DisallowStartIfOnBatteries}"")"
"    print(f""  {'EnableLUA (Is UAC enabled"
"    print(f""  {'Enabled':<30}    :   {schtask.Enabled}"")"
"    print(f""  {'ExecutionTimeLimit':<30}    :   {schtask.ExecutionTimeLimit}"")"
"    print(f""  {'FilterAdministratorToken':<30} : {uac.FilterAdministratorToken}"")"
"    print(f""  {'LocalAccountTokenFilterPolicy':<30} : {uac.LocalAccountTokenFilterPolicy}"")"
"    print(f""  {'Name':<30}    :   {schtask.Name}"")"
"    print(f""  {'Principal':<30}    :"")"
"    print(f""  {'SDDL':<30}    :   {schtask.SDDL}"")"
"    print(f""  {'Source':<30}    :   {schtask.Source}"")"
"    print(f""  {'State':<30}    :   {schtask.State}"")"
"    print(f""  {'StopIfGoingOnBatteries':<30}    :   {schtask.StopIfGoingOnBatteries}"")"
"    print(f""  {'Triggers':<30}    :"")"
"    print(f""  {env_obj.UserName:<35} {env_obj.Name:<35} {env_obj.Value}"")"
"    print(f""  {event.DateUtc:<23} :  {event.Description}"")"
"    print(f"" {process.ProcessName:<50} {process.ProcessID:<10} {process.Owner}"")"
"    print(f"""
"    print(f"""""""
"    print(f""Collecting kernel boot (EID 12) and shutdown (EID 13) events from the last {last_days} days"
"    print(f""{features.State:<8} {features.Name:<50} {features.Caption}"")"
"    print(f'  {""BootTimeUtc (approx)"":<30}:  {boot_formatted} (Total uptime: {boot_time_str})')"
"    print(f'  {formatted_time},{target_user},{logon.LogonType},{logon.IpAddress},{subject_user},{logon.AuthenticationPackage},{logon.LmPackage},{target_outbound_user}')"
"    print(f'{formatted_time},{unique_cred}')"
"    prod_ver = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    product_name = wmi_conn.get_string_value('HKLM', 'Software"
"    profile_guids = wmi_conn.get_subkey_names('HKLM', 'SOFTWARE"
"    ps_v2 = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    ps_v4p = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    query = f"""
"    query = f""(("
"    reg_hash_alg = wmi_conn.get_dword_value('HKLM', 'SYSTEM"
"    reg_options = wmi_conn.get_dword_value('HKLM', 'SYSTEM"
"    reg_sysmon_rules = wmi_conn.get_binary_value('HKLM', 'SYSTEM"
"    release_id = wmi_conn.get_string_value('HKLM', 'Software"
"    restricted_admin = wmi_conn.get_dword_value('HKLM', 'Software"
"    restricted_admin_type = wmi_conn.get_dword_value('HKLM', 'Software"
"    return ', '.join(algorithms)"
"    return (datetime(1970, 1, 1, tzinfo=timezone.utc) "
"    return dt.strftime(""%m/%d/%Y %I:%M:%S %p"")"
"    script_block_invocation_log = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    script_block_logging = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    second = int(f""{bytes_data[13]:02X}{bytes_data[12]:02X}"", 16)"
"    server_auth_level = wmi_conn.get_dword_value('HKLM', 'SOFTWARE"
"    server_nego_siging = wmi_conn.get_dword_value('HKLM', 'System"
"    server_req_signing = wmi_conn.get_dword_value('HKLM', 'System"
"    settings = wmi_conn.get_registry_value('HKLM', 'SYSTEM"
"    settings = wmi_conn.get_registry_value('HKLM', 'Software"
"    share = ""C$"""
"    shutdown_bytes = wmi_conn.get_binary_value('HKLM', 'SYSTEM"
"    site_code = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    st_serv = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    successful_install_param = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    transcription_directory = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    transcription_invo_log = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    transcription_logging = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    ubr = wmi_conn.get_string_value('HKLM', 'Software"
"    uefi_state = wmi_conn.get_dword_value('HKLM', 'SYSTEM"
"    unique_cred = f'{target_user},{logon.Process},{subject_user},{logon.IpAddress}'"
"    us_serv = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    use_wsus = wmi_conn.get_dword_value('HKLM', 'SOFTWARE"
"    user_domain_regex = re.compile(r'Domain=""(."
"    user_path = """
"    version = ""1.0"""
"    weekday = int(f""{bytes_data[5]:02X}{bytes_data[4]:02X}"", 16)"
"    windows_epoch = datetime(1601, 1, 1, tzinfo=timezone.utc)"
"    wmi_data = wmi_conn.wmi_get('SELECT Name,Caption,InstallState FROM Win32_OptionalFeature')"
"    wmi_namespace = ""//./Root/Microsoft/Windows/TaskScheduler"""
"    wmi_namespace = ""//./root/CIMv2"""
"    wmi_namespace = ""//./root/Microsoft/Windows/DeviceGuard"""
"    wmi_namespace = ""//./root/SecurityCenter2"""
"    wmi_namespace = ""//./root/StandardCIMv2"""
"    wmidata = wmi_conn.wmi_get(""SELECT Name, State FROM win32_service WHERE Name = 'AppIDSvc'"")"
"    wuserver = wmi_conn.get_string_value('HKLM', 'SOFTWARE"
"    xml_event = even_conn.EvtRpcRegisterLogQuery_EvtRpcQueryNext(log_name, query)"
"    year = int(f""{bytes_data[1]:02X}{bytes_data[0]:02X}"", 16)"
"    yield DotNet(installed_clr_versions, installed_dotnet_versions, os_amsi)"
"    yield NTLMSettings(lanman_compat_level, client_req_signing, client_nego_signing, server_req_signing, server_nego_siging, ldap_signing, ntlm_min_client_sec, ntlm_min_server_sec, inbound_restrict, outbound_restrict, inbound_audit, outbound_except)"
"    yield OSInfo(host_name, domain, '', product_name, edition_id, release_id, build_number, build_branch, str(current_major_version), current_version, arch, proc_count, isvm, boot_time, high_int, local_admin, datetime.now(timezone.utc), '', '', '', '', temp, machine_guid)"
"    yield PowerShell(installed_clr, installed_versions, transcription_logging, transcription_invo_log, transcription_directory, module_logging, module_names, script_block_logging, script_block_invocation_log, os_sup_amsi)"
"    yield SCCMClient(last_valid, site_code, prod_ver, successful_install_param)"
"    yield SecureBoot(True if uefi_state == 1 else False, policy_publisher, policy_version)"
"    yield Sysmon(installed, hashing_alg, sysmon_options, base64_rules)"
"    yield UAC(content_prompt, enable_lua, filter_admin_token, local_account_token_filter)"
"    yield WSUS(use_wsus, wuserver, us_serv, st_serv)"
"    yield WindowsAutoLogon(default_domain_name, default_user_name, default_password, alt_domain_name, alt_user_name, alt_password)"
"    yield WindowsDefender(local_settings, group_settings)"
" 0xFFFF}"""
" 0xFFFF}."""
" 2].decode(""utf16"")"
" 4, offset "
" AppLocker              - AppLocker settings, if installed"
" ExplicitLogonEvents    - Explicit Logon events (Event ID 4648) from the security event log. Default of 7 days, argument == last X days."
" ExplorerRunCommands    - Recent Explorer ""run"" commands"
" IEUrls                 - Internet Explorer typed URLs (last 7 days, argument == last X days)"
" InterestingProcesses   - ""Interesting"" processes - defensive products and admin tools"
" LAPS                   - LAPS settings, if installed"
" LocalGroups            - Non-empty local groups, ""-full"" displays all groups (argument == computername to enumerate)"
" LocalUsers             - Local users, whether they're active/disabled, and pwd last set (argument == computername to enumerate)"
" LogonEvents            - Logon events (Event ID 4624) from the security event log. Default of 10 days, argument == last X days."
" Microsoft updates, use the 'MicrosoftUpdates' command."
" OSInfo                 - Basic OS info (i.e. architecture, OS version, etc.)"
" PoweredOnEvents        - Reboot and sleep schedule based on the System event log EIDs 1, 12, 13, 42, and 6008. Default of 7 days, argument == last X days."
" SCCM                   - System Center Configuration Manager (SCCM) settings, if applicable"
" ScheduledTasks         - Scheduled tasks (via WMI) that aren't authored by 'Microsoft', ""-full"" dumps all Scheduled tasks"
" This file contains code from Tivan, available at https://github.com/irtimmer/tivan."
" This program is distributed in the hope that it will be useful,"
" WSUS                   - Windows Server Update Services (WSUS) settings, if applicable"
" WindowsFirewall        - Non-standard firewall rules, ""-full"" dumps all (arguments == allow/deny/tcp/udp/in/out/domain/private/public)"
" hashes by sniffing NTLM challenge/responses and then cracking them!"")"
" if not, see <https://www.gnu.org/licenses/>."
" j].strip() == """":"
" of the License, or (at your option) any later version."
" or,"
" rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Program."
" re.MULTILINE),"
" re.compile(r""(New-Object."
" same as RemoteInteractive, except used internally for auditing purposes"
" samr.USER_ACCOUNT_DISABLED),"
" samr.USER_PASSWORD_EXPIRED),"
" they are outside its scope. The act of running the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program (independent of having been made by running the Program). Whether that is true depends on what the Program does."
" this section has the sole purpose of protecting the integrity of the free software distribution system, which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system"
" user_type = user_type_map.get(priv_level, ""Unknown"")"
" {key} : {value} ({formatted_date})"")"
" {key} : {value}"") "
" {mp_key} : {mp_val} ({formatted_date})"")"
" {mp_key} : {mp_val}"") "
"$)$"""
"'     ({chrome.CookiesLastModified})  :  Run SharpDPAPI/SharpChrome or the Mimikatz ""dpapi::chrome"" module')"
"'  ({chrome.LoginDataLastModified})  :  Run SharpDPAPI/SharpChrome or the Mimikatz ""dpapi::chrome"" module')"
"', ""-full"" dumps all Scheduled tasks'"
"', default=' ', help='carseat command/module to run')"
"', ns):"
"'re active/disabled, and pwd last set (argument == computername to enumerate)'"
"(NT VIRTUAL MACHINE)$"""
")""')"
")""))"
")"", re.IGNORECASE "
")"",Name=""(."
")':<30} : {uac.EnableLua}"")"
", new DPAPI scheme must be used')"
"0. This License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed under the terms of this General Public License. The ""Program"", below, refers to any such program or work, and a ""work based on the Program"" means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of it, either verbatim or with modifications and/or translated into another language. (Hereinafter, translation is included without limitation in the term ""modification"".) Each licensee is addressed as ""you""."
"1. You may copy and distribute verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty"
"10. If you wish to incorporate parts of the Program into other free programs whose distribution conditions are different, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation"
"11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM ""AS IS"" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION."
"12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES."
"2. You may modify your copy or copies of the Program or any portion of it, thus forming a work based on the Program, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions:"
"3. You may copy and distribute the Program (or a work based on it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you also do one of the following:"
"4. You may not copy, modify, sublicense, or distribute the Program except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense or distribute the Program is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance."
"5. You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Program or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Program (or any work based on the Program), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Program or works based on it."
"6. Each time you redistribute the Program (or any work based on the Program), the recipient automatically receives a license from the original licensor to copy, distribute or modify the Program subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties to this License."
"7. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Program at all. For example, if a patent license would not permit royalty-free redistribution of the Program by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Program."
"8. If the distribution and/or use of the Program is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Program under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License."
"9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns."
"= f""{sorted_users[i]:<30}"""
"ANONYMOUS LOGON"", ""S-1-5-7""),"
"ASR', 'ExploitGuard_ASR_Rules')"
"AU', 'UseWUServer') == 1"
"Account Operators"", ""S-1-5-32-548""),"
"Activities other than copying, distribution and modification are not covered by this License"
"AdmPwd', 'AdmPwdEnabled')"
"AdmPwd', 'AdminAccountName')"
"AdmPwd', 'PasswordComplexity')"
"AdmPwd', 'PasswordLength')"
"AdmPwd', 'PwdExpirationProtectionEnabled')"
"Administrators"", ""S-1-5-32-544""),"
"Administrators"","
"Also, for each author's protection and ours, we want to make certain that everyone understands that there is no warranty for this free software. If the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems introduced by others will not reflect on the original authors' reputations."
"Authenticated Users"", ""S-1-5-11""),"
"AzureRMContext.json"""
"AzureRMContext.json"","
"Backup Operators"", ""S-1-5-32-551""),"
"CCMSetup', 'LastValidMP')"
"CredentialsDelegation', 'RestrictedRemoteAdministration')"
"CredentialsDelegation', 'RestrictedRemoteAdministrationType')"
"Cryptographic Operators"", ""S-1-5-32-569""),"
"Cryptography', 'MachineGuid')"
"CurrentVersion', 'BuildBranch')"
"CurrentVersion', 'CurrentBuildNumber')"
"CurrentVersion', 'CurrentMajorVersionNumber')"
"CurrentVersion', 'CurrentVersion')"
"CurrentVersion', 'EditionID')"
"CurrentVersion', 'ProductName')"
"CurrentVersion', 'ReleaseId')"
"CurrentVersion', 'UBR')"
"Device Owners"", ""S-1-5-32-583""),"
"DomainProfile', 'DefaultInboundAction')"
"DomainProfile', 'DefaultOutboundAction')"
"DomainProfile', 'DisableNotifications')"
"DomainProfile', 'EnableFirewall')"
"EVEN6_UUID = uuidtup_to_bin(('F6BEAFF7-1E19-4FBB-9F8F-B89E2018337C', '1.0'))"
"Each version is given a distinguishing version number. If the Program specifies a version number of this License which applies to it and ""any later version"", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation."
"Finally, any free program is threatened constantly by software patents. We wish to avoid the danger that redistributors of a free program will individually obtain patent licenses, in effect making the program proprietary. To prevent this, we have made it clear that any patent must be licensed for everyone's free use or not licensed at all."
"For example, if you distribute copies of such a program, whether gratis or for a fee, you must give the recipients all the rights that you have. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights."
"Framework"""
"Full', 'Version')"
"Guests"", ""S-1-5-32-546""),"
"INTERACTIVE"", ""S-1-5-4""),"
"If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply and the section as a whole is intended to apply in other circumstances."
"If distribution of executable or object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place counts as distribution of the source code, even though third parties are not compelled to copy the source along with the object code."
"In addition, mere aggregation of another work not based on the Program with the Program (or with a work based on the Program) on a volume of a storage or distribution medium does not bring the other work under the scope of this License."
"InprocServer32"""
"LDAP', 'LDAPClientIntegrity')"
"LOCAL SERVICE"", ""S-1-5-19""),"
"Like other impacket tools CarSeat accepts passwords, hashes or kerberos tickets for authentication."
"Lsa', 'LmCompatibilityLevel')"
"MSRPC_UUID_EPM = uuidtup_to_bin(('E1AF8308-5D1F-11C9-91A4-08002B14A0FA', '3.0'))"
"MSV1_0', 'AuditReceivingNTLMTraffic')"
"MSV1_0', 'ClientAllowedNTLMServers')"
"MSV1_0', 'NtlmMinClientSec')"
"MSV1_0', 'NtlmMinServerSec')"
"MSV1_0', 'RestrictReceivingNTLMTraffic')"
"MSV1_0', 'RestrictSendingNTLMTraffic')"
"Mobile Client', 'AssignedSiteCode')"
"Mobile Client', 'LastSuccessfulInstallParams')"
"Mobile Client', 'ProductVersion')"
"ModuleLogging', 'EnableModuleLogging') == '1'"
"NETWORK SERVICE"", ""S-1-5-20""),"
"Network Configuration Operators"", ""S-1-5-32-556""),"
"Parameters', 'EnableSecuritySignature') == 1"
"Parameters', 'HashingAlgorithm')"
"Parameters', 'Options')"
"Parameters', 'RequireSecuritySignature') == 1"
"Parameters', 'Rules')"
"Policy Manager', 'ExcludedPaths')"
"Power Users"", ""S-1-5-32-547""),"
"PowerShellEngine', 'PowerShellVersion')"
"Pre-Windows 2000 Compatible Access"", ""S-1-5-32-554""),"
"Print Operators"", ""S-1-5-32-550""),"
"Prints a little bit differently than seatbelt, move to format_results"
"PrivateProfile', 'DefaultInboundAction')"
"PrivateProfile', 'DefaultOutboundAction')"
"PrivateProfile', 'DisableNotifications')"
"PrivateProfile', 'EnableFirewall')"
"PublicProfile', 'DefaultInboundAction')"
"PublicProfile', 'DefaultOutboundAction')"
"PublicProfile', 'DisableNotifications')"
"PublicProfile', 'EnableFirewall')"
"RESTRICTED"", ""S-1-5-12""),"
"Remote Desktop Users"", ""S-1-5-32-555""),"
"Remote Management Users"", ""S-1-5-32-580""),"
"Repetition"""
"Replicator"", ""S-1-5-32-552""),"
"Run"","
"RunOnce"","
"RunOnceService"""
"RunOnceService"","
"RunService"","
"SYSTEM"", ""S-1-5-18""),"
"SYSTEM"","
"ScriptBlockLogging', 'EnableScriptBlockInvocationLogging') == '1'"
"ScriptBlockLogging', 'EnableScriptBlockLogging') == '1'"
"Server Operators"", ""S-1-5-32-549""),"
"StandardProfile', 'DefaultInboundAction')"
"StandardProfile', 'DefaultOutboundAction')"
"StandardProfile', 'DisableNotifications')"
"StandardProfile', 'EnableFirewall')"
"State', 'PolicyPublisher')"
"State', 'PolicyVersion')"
"State', 'UEFISecureBootEnabled')"
"System' , 'EnableLUA')"
"System', 'ConsentPromptBehaviorAdmin')"
"System', 'FilterAdministratorToken')"
"System', 'LocalAccountTokenFilterPolicy')"
"TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION"
"Terminal Services', 'AuthenticationLevel')"
"Terminal Services', 'DisablePasswordSaving')"
"Terminal Services', 'UserAuthentication')"
"Terminal Services', 'fDisableCcm')"
"Terminal Services', 'fDisableCdm')"
"Terminal Services', 'fDisableClip')"
"Terminal Services', 'fDisableCpm')"
"Terminal Services', 'fDisableLPT')"
"Terminal Services', 'fDisablePNPRedir')"
"Terminal Services', 'fEnableSmartCard')"
"The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users. This General Public License applies to most of the Free Software Foundation's software and to any other program whose authors commit to using it. (Some other Free Software Foundation software is covered by the GNU Lesser General Public License instead.) You can apply it to your programs, too."
"The precise terms and conditions for copying, distribution and modification follow."
"The source code for a work means the preferred form of the work for making modifications to it. For an executable work, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the executable. However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable."
"These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Program, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Program, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it."
"This needs to be revisited - do obj.SystemProperties[""__CLASS""].Value}"
"This needs to be revisited - do obj.SystemProperties[""__SUPERCLASS""].Value}"
"Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you"
"To protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights. These restrictions translate to certain responsibilities for you if you distribute copies of the software, or if you modify it."
"TokenCache.dat"","
"Transcription', 'EnableInvocationHeader') == '1'"
"Transcription', 'EnableTranscripting') == '1'"
"Transcription', 'OutputDirectory')"
"TypedURLsTime', k)"
"Uninstall"""
"Uninstall"","
"Users""  "
"Users"" "
"Users"""
"Users"", ""S-1-5-32-545""),"
"Users"","
"Version 2, June 1991"
"VersionInfo = namedtuple('VersionInfo', ['FileVersion', 'ProductVersion'])"
"We protect your rights with two steps: (1) copyright the software, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the software."
"When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs"
"Window Manager)$', target_domainname)):"
"Windows', 'ShutdownTime')"
"WindowsFirewall',"
"WindowsUpdate', 'UpdateServiceUrlAlternate')"
"WindowsUpdate', 'WUServer')"
"WindowsUpdate', 'WUStatusServer')"
"Winlogon', 'AltDefaultDomainName')"
"Winlogon', 'AltDefaultPassword')"
"Winlogon', 'AltDefaultUserName')"
"Winlogon', 'DefaultDomainName')"
"Winlogon', 'DefaultPassword')"
"Winlogon', 'DefaultUserName')"
"You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee."
"[System/EventID=1]"""
"[System/EventID=4104]"""
"[System/EventID=4688]"""
"[System[TimeCreated[@SystemTime <= '{end_time_utc}']]]"""
"] Any administrative local account can be used for lateral movement."")"
"] AppLocker not configured"")"
"] Default Windows settings - Only the RID-500 local admin account can be used for lateral movement."")"
"] Local accounts cannot be used for lateral movement."")"
"] LocalAccountTokenFilterPolicy == 1. Any administrative local account can be used for lateral movement."")"
"] Use the Mimikatz ""dpapi::masterkey"" module with appropriate arguments (/pvk or /rpc) to decrypt')"
"] You can also extract many DPAPI masterkeys from memory with the Mimikatz ""sekurlsa::dpapi"" module')"
"a) Accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange"
"access_tokens.db"""
"azureProfile.json"","
"b) Accompany it with a written offer, valid for at least three years, to give any third party, for a charge no more than your cost of physically performing source distribution, a complete machine-readable copy of the corresponding source code, to be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange"
"b) You must cause any work that you distribute or publish, that in whole or in part contains or is derived from the Program or any part thereof, to be licensed as a whole at no charge to all third parties under the terms of this License."
"c) Accompany it with the information you received as to the offer to distribute corresponding source code. (This alternative is allowed only for noncommercial distribution and only if you received the program in object code or executable form with such an offer, in accord with Subsection b above.)"
"c) If the modified program normally reads commands interactively when run, you must cause it, when started running for such interactive use in the most ordinary way, to print or display an announcement including an appropriate copyright notice and a notice that there is no warranty (or else, saying that you provide a warranty) and that users may redistribute the program under these conditions, and telling the user how to view a copy of this License. (Exception: if the Program itself is interactive but does not normally print such an announcement, your work based on the Program is not required to print an announcement.)"
"chrome.exe', '')"
"config.json"""
"config.json"","
"credentials.db"","
"def format_string(string, length):"
"def get_chrome_presence(wmi_conn, smb_conn):"
"def get_dotnet(wmi_conn, smb_conn):"
"def get_explicit_logon_events(even_conn, args):"
"def get_fw_rules(wmi_conn, args):"
"def get_ie_urls(wmi_conn, args):"
"def get_local_groups(samr_conn, args, computer):"
"def get_local_users(samr_conn, computer):"
"def get_logon_events(even_conn, args):"
"def get_osinfo(wmi_conn, target):"
"def get_powered_on_events(even_conn, args):"
"def get_powershell(wmi_conn, smb_conn):"
"def get_powershell_events(even_conn, args):"
"def get_powershell_history(smb_conn, args):"
"def get_process_creation_events(even_conn, args):"
"def get_scheduled_tasks(wmi_conn, args):"
"def get_sysmon_events(even_conn, args):"
"def get_version(versions, find='lowest'):"
"def get_wmi(wmi_conn, query):"
"def print_array_value(value_type, value_name, value):"
"from datetime import datetime, timedelta, date, timezone"
"from datetime import datetime, timedelta, timezone"
"from datetime import datetime, timezone"
"from datetime import datetime, timezone, timedelta"
"from impacket.dcerpc.v5 import even6, transport, epm"
"from impacket.dcerpc.v5 import transport, samr, lsad, lsat, wkst, srvs"
"from impacket.dcerpc.v5.dcomrt import DCOMConnection, NULL"
"from impacket.dcerpc.v5.rpcrt import RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, DCERPCException"
"from impacket.smbconnection import SMBConnection, SessionError"
"from impacket.structure import Structure, hexdump"
"from typing import Optional, List, Dict, Any"
"if __name__ == ""__main__"":"
"import struct, uuid"
"legacy_credentials"","
"length] for i in range(0, len(string), length)]"
"n  Accounts authenticate to this machine using NTLM v1!"")"
"n  Accounts authenticate to this machine using NTLM v2!"")"
"n  Module Logging Settings"")"
"n  NTLM Auditing and Restrictions"")"
"n  NTLM Signing Settings"")"
"n  Session Security"")"
"n  Transcription Logging Settings"")"
"n"".join(context_lines)"
"of this license document, but changing it is not allowed."
"output = {key: parse_value(value['value']) for key, value in ordered_dict.items()}"
"python CarSeat.py domain/user:password@10.10.10.10 AntiVirus,UAC,ScheduledTasks"
"raise Exception(f""File not found: {file_path}"")"
"return VersionInfo(file_version, product_version)"
"return datetime.utcfromtimestamp(struct.unpack('<Q', value.data)[0] / 1e7 - 11644473600).isoformat()"
"slack-downloads'  ({slack.DownloadsLastModified})  :  Run the 'SlackDownloads' command"")"
"slack-workspaces' ({slack.WorkspacesLastModified})  :  Run the 'SlackWorkspaces' command"")"
"slack-workspaces' files to clone Slack access"")"
"uac_value = getattr(uac_obj, 'fields', {}).get('Data', uac_obj)"
"v3.5', 'Version')"
"w.,@"
"{acc}', x)"
"{host}', 'UsernameHint')"
"{i}"", ""Value"")"
"{key}', 'SemanticVersion')"
"{k}', 'EnforcementMode')"
"{pguid}', 'Category')"
"{pguid}', 'DateCreated')"
"{pguid}', 'Description')"
"{pguid}', 'Managed')"
"{pguid}', 'NameType')"
"{pguid}', 'ProfileName')"
"{plugin}', 'ConfigXML')"
"{rname}', x)"
"{session_name}', key)"
"{sub_key}', 'DisplayName')"
"{sub_key}', 'DisplayVersion')"
"{sub_key}', 'InstallDate')"
"{sub_key}', 'Publisher')"
"{trustee}"""
'     ({chrome.HistoryLastModified})  :  Run the 
' command')
' files'
'ChromiumHistory
'Cookies
'History
'Login Data
'Microsoft
'slack-downloads
'slack-workspaces
't ask for password (useful for -k)')
't authored by 
(-pw
(/RemoveCredentials
(/up
(Font Driver Host
(SYSTEM
))([
---I---
-group remote
-i .
-p .
-p:.
-pass) .
-pw .
-w .
.DS_Store
.aws
/-->
/SetCredentials) .
/cup
/p .
/p(assword)
/p):.
/pass:.
/password:.
/pwd:.
/rp) .
= attr.length
= element.length
= f'.{ubr}'
= value.length
AMSI
ANONYMOUS LOGON
ASROnlyExclusions')
Accounts
Accounts')
All credits going to all of the awesome work done by Will ([@harmj0y](http://twitter.com/harmj0y)) Lee ([@tifkin_](http://twitter.com/tifkin_)) and all of the [contributors](https://github.com/GhostPack/Seatbelt
App Paths
AppData
AsPlainText.
Audit')
Available commands:
Bookmarks'
Brave-Browser
BraveSoftware
CLSID
Carseat is a python implementation of [Seatbelt](https://github.com/GhostPack/Seatbelt/). This tool contains all (all minus one technically) modules in Seatbelt that support remote execution as an option. Just like Seatbelt you likely will need privileged access to the target host you are running any modules against.
Chrome
Classes
ConsoleHost_history.txt'
Content.Outlook
Control
ControlSet001
Cookies'
Copyright (C) 2024 Steven F.
CurrentControlSet
CurrentVersion
DWM-[0-9]
Default
Documents
END OF TERMS AND CONDITIONS
Edge
Enabled
EndBoundary
Event log parsing code comes from Iwan Timmer's [tivan project](https://github.com/irtimmer/tivan)
EventForwarding
EventLog
Everyone is permitted to copy and distribute verbatim copies
Exclusions
ExecutionTimeLimit
Explorer
Extensions')
Favorites
FileZilla
Firefox
FirewallPolicy'
FirewallRules')
Framework
GNU GENERAL PUBLIC LICENSE
Google
Groups are the same as Seatbelt's. Only difference is 
History')
INetCache
InstalledVersions
Internet Explorer
It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims
KeePass
KeePass.config.xml'
LOCAL SERVICE
LanmanServer
LanmanWorkstation
Local
Lsa')
Microsoft
Microsoft Services
Microsoft.Net
ModuleLogging
ModuleNames')
Mozilla
NET Framework Setup
NETWORK SERVICE
NO WARRANTY
NTLM
Needs to be updated for the settings
NetworkList
Note: Command names and descriptions are from Seatbelts README
OneDrive
OneDrive')
Opera Software
Opera Stable
PSReadline
PSReadline'
Parameters
Paths')
Plugin
Policies
PowerShell
PowerShellCore
Preamble
Processes')
Profiles
Profiles'
Protect
ProtectedUserKey.bin'
Providers
Providers')
PuTTY
Roaming
Rules')
RunMRU')
SOFTWARE
ScopeIdToMountPointPathCache')
SecureBoot
SecurityCenter2 WMI namespace is not available on Windows Servers')
Servers
Servers')
Services
Sessions
SharedAccess
SimonTatham
Slack
Slack'
Software
SrpV2
SrpV2')
SshHostKeys
StartBoundary
SubscriptionManager')
SuperPuTTY'
SyncEngines
SysmonDrv
System
System.Management.Automation.PSCredential.
System.dll'
System.dll'):
TODO: Fix getting comments
TODO: Fix getting some extra info
TODO: Look into collecting other data from non remote if possible
Terminal Server Client
The only non-standard python libraries used are impacket and pefile. So you can install them individually or through the requirements file. 
This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.
To run a single command
To run command with arguments
To run grouped commands
To run multiple at once
TypedURLs')
UMFD-[0-9]
Uninstall':
User Data
Users
Users'
WSMAN
WTSOpenServerA (wtsapi32.h)
Windows
Windows Azure Powershell
Windows Defender Exploit Guard
Windows Defender')
Windows NT
WindowsUpdate
Wow6432Node
[System/EventID=1] and 
[System/EventID=42]) or (
[System/EventID=6008]) or (
[System/EventID={eid}] and 
[System[(EventID=12 or EventID=13) and Provider[@Name='Microsoft-Windows-Kernel-General']]] or 
[System[Provider[@Name='Microsoft-Windows-Power-Troubleshooter']]])) and 
[System[TimeCreated[@SystemTime >= '{start_time_utc}']]] and 
] AppIDSvc service is {applocker.AppIdSvcState}
] Applocker is not running because the AppIDSvc is not running
] Completed collection in {elapsed_time:.2f} seconds
] LAPS not installed')
] LocalAccountTokenFilterPolicy set to 0 and FilterAdministratorToken == 1.
] No rules')
] UAC is disabled.
] You can also use SharpDPAPI for masterkey retrieval.')
] You can invoke .NET version {lowest_version.split('.')[0]}.{lowest_version.split('.')[1]} to bypass AMSI.')
] {applocker.KeyName} is in {applocker.EnforcementMode}')
] {applocker.KeyName} not configured')
] {r}')
_()___()_//
___/_)
__pycache__/
a) You must cause the modified files to carry prominent notices stating that you changed the files and the date of any change.
acknowledgments) of Seatbelt over the years.
args = ''
class AMSIProviders:
class AntiVirus:
class AppLocker:
class AsrRule:
class AsrSettings:
class Attribute:
class AuditPolicy:
class AutoRuns:
class BinXML:
class Bookmark:
class ChromiumBookmark:
class ChromiumHistory:
class ChromiumPresence:
class ClientSettings:
class CloudCredentials:
class CloudSyncProviders:
class CredGuard:
class DNSCache:
class DPAPIMasterKeys:
class DotNet:
class Download:
class EVENHandler:
class Element:
class EnvironmentVariables:
class ExplicitLogonEvents:
class ExplorerRunCommands:
class FileZilla:
class FileZillaConfig:
class FirefoxHistory:
class FirefoxPresence:
class FirewallAction(IntEnum):
class HotFix:
class IEFavorites:
class IEUrls:
class InstalledProducts:
class InterestingProcess:
class KeePass:
class LAPS:
class LastShutdown:
class LocalGroupMembership:
class LocalSecurityAuthority:
class LocalUser:
class LogonEvents:
class LogonSession:
class MappedDrives:
class MasterKey:
class MiscUtil:
class NTLMSettings:
class Name:
class NetworkCategory(IntEnum):
class NetworkProfiles:
class NetworkShares:
class NetworkType(IntEnum):
class OSInfo:
class OneDriveSyncProvider:
class OptionalFeatureState(IntEnum):
class OptionalFeatures:
class OutlookDownload:
class OutlookDownloads:
class PSSessionSettings:
class PluginAccess:
class PowerShell:
class PowerShellEvents:
class PowerShellHistory:
class PoweredOnEvent:
class PrintHandler:
class ProcessCreationEvent:
class ProcessOwner:
class PuttyHostKeys:
class PuttySessions:
class RDPConnection:
class RDPSavedConnection:
class RDPSettings:
class ResultSet:
class RunCommand:
class RunlvelEnum(IntEnum):
class SAMRHandler:
class SCCMClient:
class SECURITY_LOGON_TYPE(IntEnum):
class SMBHandler:
class ScheduledTask:
class ScheduledTaskAction:
class ScheduledTaskPrincipal:
class ScheduledTaskTrigger:
class SecureBoot:
class ServerSettings:
class SessionSecurity(IntEnum):
class SlackDownloads:
class SlackPresence:
class SlackWorkspaces:
class StateEnum(IntEnum):
class Substitution:
class SuperPutty:
class SuperPuttyConfig:
class Sysmon:
class SysmonEvent:
class SysmonHashAlgorithm(IntEnum):
class SysmonOptions(IntEnum):
class TemplateInstance:
class TypedURL:
class UAC:
class VBS(IntEnum):
class Value:
class ValueSpec:
class WMIHandler:
class WMI_Data:
class WSUS:
class WindowsAutoLogon:
class WindowsDefender:
class WindowsDefendersettings:
class WindowsEventForwarding:
class WindowsFirewall:
class WindowsFirewallProfileSettings:
class WindowsFirewallRule:
class Workspace:
client settings
credentials'
def asr_guids():
def command_base(options):
def convert_binary_datetime(bytes_data):
def display_defender_settings(settings):
def format_result(env_obj):
def format_results(applocker):
def format_results(bookmark):
def format_results(chrome):
def format_results(defender):
def format_results(dotnet_obj):
def format_results(downloads):
def format_results(dpapi):
def format_results(event):
def format_results(features):
def format_results(filezilla):
def format_results(firefox):
def format_results(firewall):
def format_results(group):
def format_results(history):
def format_results(hotfix):
def format_results(ie):
def format_results(iefav):
def format_results(info):
def format_results(laps):
def format_results(logon):
def format_results(ntlm):
def format_results(phk):
def format_results(powershell):
def format_results(process):
def format_results(provider):
def format_results(puttysessions):
def format_results(rdp):
def format_results(rdpsettings):
def format_results(run_commands):
def format_results(s_downloads):
def format_results(schtask):
def format_results(settings):
def format_results(slack):
def format_results(super_putty):
def format_results(sysmon):
def format_results(uac):
def format_results(wmi):
def from_file_time(file_time):
def get_amsi_providers(wmi_data):
def get_app_lockers(wmi_conn):
def get_audit_policy(wmi_conn):
def get_auto_runs(wmi_obj):
def get_av(wmi_conn):
def get_chromium_bookmarks(smb_conn):
def get_chromium_history(smb_conn):
def get_cloud_credentials(smb_conn):
def get_cloud_sync_providers(wmi_conn):
def get_clr_versions(smb_conn):
def get_cred_guard(wmi_conn):
def get_dns_cache(wmi_conn):
def get_dpapi_masterkeys(smb_conn):
def get_env_vars(wmi_conn):
def get_explore_run_commands(wmi_conn):
def get_filezilla(smb_conn):
def get_firefox_history(smb_conn):
def get_firefox_presence(smb_conn):
def get_hotfixes(wmi_conn):
def get_ie_favorites(smb_conn):
def get_installed_products(wmi_conn):
def get_interesting_processes(wmi_conn):
def get_keepass(smb_conn):
def get_laps(wmi_conn):
def get_lastshutdown(wmi_conn):
def get_logon_sessions(wmi_conn):
def get_lsa_settings(wmi_conn):
def get_mapped_drives(wmi_conn):
def get_network_profiles(wmi_conn):
def get_network_shares(wmi_conn):
def get_ntlm_settings(wmi_conn):
def get_optional_features(wmi_conn):
def get_os_version(wmi_conn):
def get_outlook_downloads(smb_conn):
def get_powershell_versions(wmi_conn):
def get_process_owners(wmi_conn):
def get_ps_session_settings(wmi_conn):
def get_pscore_versions(wmi_conn):
def get_putty_host_keys(wmi_conn):
def get_putty_sessions(wmi_conn):
def get_rdp_saved_connections(wmi_conn):
def get_rdp_settings(wmi_conn):
def get_sccm(wmi_conn):
def get_secure_boot(wmi_conn):
def get_slack_downloads(smb_conn):
def get_slack_presence(smb_conn):
def get_slack_workspaces(smb_conn):
def get_super_putty(smb_conn):
def get_sysmon(wmi_conn):
def get_sysmon_alg(value):
def get_uac(wmi_conn):
def get_version_from_string(version):
def get_windows_auto_logon(wmi_conn):
def get_windows_defender(wmi_conn):
def get_windows_event_forwarding(wmi_conn):
def get_wsus(wmi_conn):
def is_vm(wmi_conn):
def main():
def parse_bookmarks(contents):
def parse_module_commands(commands):
def parse_sddl(sddl_value: str):
def print_banner():
def print_extra():
def print_user_set(users):
def process_commands(options):
don't know if i can get this with samr
export KRB5CCNAME=admin_tgt.ccache
file)://([
from .EVENHandler import EVENHandler
from .MiscUtil import MiscUtil
from .PrintHandler import PrintHandler
from .SAMRHandler import SAMRHandler
from .SMBHandler import SMBHandler
from .WMIHandler import WMIHandler
from collections import OrderedDict
from datetime import datetime
from enum import IntEnum
from fileinput import filename
from impacket.dcerpc.v5.dcom import wmi
from impacket.dcerpc.v5.dtypes import NULL
from impacket.examples import logger
from impacket.examples.utils import parse_target
from impacket.smbconnection import SMBConnection
from impacket.smbconnection import SessionError
from impacket.uuid import uuidtup_to_bin
from io import BytesIO
from lib import EVENHandler
from lib import MiscUtil
from lib import PrintHandler
from lib import SAMRHandler
from lib import SMBHandler
from lib import WMIHandler
from os.path import splitext
from textwrap import wrap
from xml.sax.saxutils import escape
gcloud
hashing_alg = SysmonHashAlgorithm(int(reg_hash_alg)).name
https
https://github.com/irtimmer/tivan/blob/master/tivan/parser/binxml.py
if sysmon isnt installed this will likely throw an exception
impacket
import argparse
import base64
import charset_normalizer as chardet
import importlib
import json
import logging
import ntpath
import os
import pefile
import re
import socket
import struct
import sys
import time
import uuid
import xml.etree.ElementTree as ET
key3.db'
key4.db'
lmstr = None
lsarpc]')
n    History ({history.UserName}):
n    Orphaned :')
n    [
n    {accName} :')
n  ASR Exclusions:')
n  Anti-Malware Scan Interface (AMSI)')
n  Attack Surface Reduction Rules:
n  Extension Exclusions')
n  Installed .NET Versions')
n  Installed CLR Versions')
n  Installed PowerShell Versions')
n  Other accounts authenticate to this machine using NTLM! NTLM-relay may be possible')
n  Path Exclusions:')
n  PolicyManagerPathExclusions:')
n  Process Exclusions')
n  Script Block Logging Settings')
n  The following users have authenticated to this machine using Kerberos.
n  [
n  {run_commands.Sid} :')
n {chrome.Folder}
n {ie.Sid}')
n====== {banner} ======
nFavorites ({iefav.UserName})
nGPO-defined Settings:')
nRDP Client Settings:')
need LOCALGROUP_INFO_1 structure
need USER_INFO_3 structure
not a great way to catch the exception currently
pefile
pip3 install -r requirements.txt
pipe
places.sqlite'
print()
python CarSeat.py -group remote domain/user:password@10.10.10.10 ExplicitLogonEvents 10
python CarSeat.py -group remote domain/user:password@10.10.10.10 InterestingProcesses
python CarSeat.py -hashes :8846F7EAEE8FB117AD06BDD830B7586C -no-pass domain/user:@10.10.10.10 WSUS
python CarSeat.py -k -no-pass domain/user:@10.10.10.10 WindowsFirewall
python CarSeat.py domain/user:password@10.10.10.10 AntiVirus
samr]')
server settings
settings = data['Settings']
slack-downloads'
slack-workspaces'
storage
storage'
tab=readme-ov-file
uac_obj = user_info['UserAccountControl']
use .
user .
w_-]
wmi_data = wmi_conn.wmi_get('SELECT 
x00'
{a_location}'
{acc}
{b_location}'
{d.get_longname()}
{data['Computer']}
{directories}
{directories}{path}'
{directory.get_longname()}
{directory.get_longname()}'
{fn}')
{g_location}'
{group.GroupName} 
{k}')
{logon.SubjectUserName}'
{logon.SubjectUser}'
{logon.TargetOutboundUserName}'
{logon.TargetUserName}'
{logon.TargetUser}'
{member['name']:<40} {member['sid']}')
{mk_name}'
{owner_info.User}'
{provider_clsid}
{sd}'):
{sw}'):
{target_username}'
{user_name}
{username}
{user}
{user}'
{user}{path}'
{xml_file}'):
