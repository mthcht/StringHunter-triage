// indirect
// https://groups.google.com/forum/#!topic/golang-nuts/wnH302gBa4I
// Helper function to serialize known-good objects.
"// that value is then embedded in another operation, for instance by being"
// Note: It's not possible to directly check whether the data pointed at by an
"// incorrect. Because this method is intended for known-good objects, and a nil"
// Perform decompression based on algorithm
"// Writing to byte buffer, err is always nil"
// Handling nil here allows us to transparently handle nil slices when serializing.
"// interface is a nil pointer, so we do this hacky workaround."
"// (https://github.com/square/go-jose/issues/22), the result will be"
"// We never want to serialize the top-level value ""null,"" since it's not a"
// Compress with DEFLATE
// base64-encoded and fed as input to a signing algorithm
// Precondition: value is not a nil pointer.
// byteBuffer represents a slice of bytes that can be serialized to url-safe base64.
// Strip all newlines and whitespace
"// valid JOSE message. But if a caller passes in a nil pointer to this method,"
"// MarshalJSON will happily serialize it as the top-level value ""null"". If"
// Perform compression based on algorithm
"// pointer is not a known-good object, we are free to panic in this case."
// Decompress with DEFLATE
// ECDH-ES + AES key wrap (192)
// not be validated with the given verify options.
"// getEncryption extracts parsed ""enc"" from the raw JSON."
// rawHeader represents the JOSE header for JWE/JWS objects (used for parsing).
// AES key wrap (192)
"// for the selected algorithm. This can occur, for example, when trying to"
// Header represents the read-only JOSE header for JWE/JWS objects.
"// in the x5c header field of a message, if one was present. Returns"
// HMAC using SHA-512
// Unverified certificate chain parsed from x5c header.
// AES-CBC + HMAC-SHA384 (192)
// ContentEncryption represents a content encryption algorithm.
// AES-GCM (192)
// ErrNotSupported serialization of object is not supported. This occurs when
// HMAC using SHA-384
// ErrUnsupportedAlgorithm indicates that a selected algorithm is not
// AES-GCM key wrap (192)
// ECDH-ES + AES key wrap (256)
// *byteBuffer
// ErrCryptoFailure represents an error in cryptographic primitive. This
"// getByteBuffer gets a byte buffer from the raw JSON. Returns (nil, nil) if"
// RSASSA-PKCS-v1.5 using SHA-512
// *JSONWebKey
// RSA-OAEP-SHA256
// AES-CBC + HMAC-SHA256 (128)
"// it a key of an unrecognized type or with unsupported parameters, such as"
// HMAC using SHA-256
"// getString gets a string from the raw JSON, defaulting to """"."
"// getCompression extracts parsed ""zip"" from the raw JSON."
// RSASSA-PSS using SHA384 and MGF1-SHA384
// returns an empty slice.
// RSASSA-PSS using SHA256 and MGF1-SHA256
// Get size of curve in bytes
// same time we need to receive any extra fields unhandled by this library to
// ErrUnsupportedKeyType indicates that the given key type/format is not
// DEFLATE (RFC 1951)
// ECDH-ES + AES key wrap (128)
// AES-GCM key wrap (128)
// AES-GCM key wrap (256)
// RSASSA-PSS using SHA512 and MGF1-SHA512
// AES-GCM (256)
// KeyAlgorithm represents a key management algorithm.
// Any headers not recognised above get unmarshaled
// trying to compact-serialize an object which can't be represented in
// AES-GCM (128)
// CompressionAlgorithm
// supported. This occurs when trying to instantiate an encrypter and passing
// nonce header parameter was included in an unprotected header object.
// RSASSA-PKCS-v1.5 using SHA-384
// ECDSA using P-256 and SHA-256
// algorithm that is not yet implemented.
// pass through to consuming code in case it wants to examine them.
// constants is preferred to enhance type safety.
// an RSA private key with more than two primes.
// not specified.
// PBES2 + HMAC-SHA384 + AES key wrap (192)
// RSA-PKCS1v1.5
// ECDH-ES
// compact form.
// Certificates verifies & returns the certificate chain present
// from JSON in a generic manner and placed in this map.
// CompressionAlgorithm represents an algorithm used for plaintext compression.
"// getS2C extracts parsed ""p2c"" from the raw JSON."
// Signature algorithms
// library.
// string
// These are set by go-jose and shouldn't need to be set by consumers of the
"// getAPU extracts parsed ""apu"" from the raw JSON."
// A key in the protected header of a JWS object. Use of the Header...
// ContentEncryption
// []*x509.Certificate
// ECDSA using P-521 and SHA-512
// Content encryption algorithms
"// getEPK extracts parsed ""epk"" from the raw JSON."
// []string
"// getSignatureAlgorithm extracts parsed ""alg"" from the raw JSON as a SignatureAlgorithm."
// AES key wrap (256)
// Key management algorithms
"// getCritical extracts parsed ""crit"" from the raw JSON. If omitted, it"
// encrypt with AES-256 but passing only a 128-bit key as input.
// AES key wrap (128)
// Compression algorithms
// AES-CBC + HMAC-SHA512 (256)
"// ErrUnprotectedNonce indicates that while parsing a JWS or JWE object, a"
// ContentType represents type of the contained data.
// SignatureAlgorithm represents a signature (or MAC) algorithm.
// Get JOSE name of curve
"// getJWK extracts parsed ""jwk"" from the raw JSON."
// RSASSA-PKCS-v1.5 using SHA-256
"// getTag extracts parsed ""tag"" frpom the raw JSON."
"// Merge headers from src into dst, giving precedence to headers from l."
// supported. This occurs when trying to instantiate an encrypter for an
// PBES2 + HMAC-SHA512 + AES key wrap (256)
"// getS2S extracts parsed ""p2s"" from the raw JSON."
// PBES2 + HMAC-SHA256 + AES key wrap (128)
// RSA-OAEP-SHA1
// sanitized produces a cleaned-up header object from the raw JSON.
// could not be decrypted.
"// occurs when, for example, a message had an invalid authentication tag or"
// No compression
// *byteBuffer (int)
// an error if there was no x5c header present or the chain could
"// getIV extracts parsed ""iv"" frpom the raw JSON."
"// getAPV extracts parsed ""apv"" from the raw JSON."
"//
// The decoding of the constituent items is deferred because we want to marshal"
// *byteBuffer ([]byte)
"// getAlgorithm extracts parsed ""alg"" from the raw JSON as a KeyAlgorithm."
// ErrInvalidKeySize indicates that the given key is not the correct size
// ECDSA using P-384 and SHA-384
// Direct encryption
"// some members into particular structs rather than generic maps, but at the"
// otherwise fields from the protected header will not get picked up.
// parseEncryptedCompact parses a message in compact format.
// Check that there is not a nonce in the unprotected headers
// CompactSerialize serializes an object using the compact serialization format.
// rawJSONWebEncryption represents a raw JWE JSON object. Used for parsing/serializing.
"// Note: this must be called _after_ we parse the protected header,"
// Get the additional authenticated data from a JWE object.
// ParseEncrypted parses an encrypted message in compact or full serialization format.
// Use flattened serialization
// JSONWebEncryption represents an encrypted JWE object after parsing.
// rawRecipientInfo represents a raw JWE Per-Recipient header JSON object. Used for parsing/serializing.
// parseEncryptedFull parses a message in compact format.
// recipientInfo represents a raw JWE Per-Recipient header JSON object after parsing.
// GetAuthData retrieves the (optional) authenticated data attached to the object.
// Check that there is not a nonce in the unprotected header
// FullSerialize serializes an object using the full JSON serialization format.
// Get the merged header values
// sanitized produces a cleaned-up JWE object from the raw JSON.
// user of this interface.
// Algs returns a list of supported signing algorithms.
// algorithm.
// OpaqueVerifier is an interface that supports verifying payloads with opaque
"// example, occur in a hardware module. An OpaqueSigner may rotate signing keys"
// OpaqueSigner is an interface that supports signing payloads with opaque
// transparently to the user of this interface.
"// private key(s). Private key operations preformed by implementors may, for"
// Public returns the public key of the current signing key.
// public key(s). An OpaqueSigner may rotate signing keys transparently to the
// SignPayload signs a payload with the current signing key using the given
"// separated from each other, and the signature can have multiple signers at the"
// payload header. You cannot assume that the key received in a payload is
// if necessary. It returns itself and so can be used in a fluent style.
"// We want to embed the JWK or set the kid header, but not both. Having a protected"
// each other.
// object and the payload. We return the signature and index to guarantee that
"// of the signature that was verified, along with the signature object. We return"
// Optional map of additional keys to be inserted into the protected header
// exclusive. The fact that both can exist at the same time is a somewhat unfortunate
"// WithHeader adds an arbitrary value to the ExtraHeaders map, initializing it"
"// the pub key for embedding, but doesn't have extra params like key id."
// callers are getting the verified value.
// was created for the inner key (such as a RSA or ECDSA public key). It contains
"// returns the index of the signature that was verified, along with the signature"
"// most cases, you will probably want to use Verify instead. DetachedVerify"
"// WithType adds a type (""typ"") header and returns the updated SignerOptions."
// NonceSource represents a source of random nonces to go into JWS objects
"// This function does not support multi-signature, if you desire multi-sig"
// Verify validates the signature on the object and returns the payload.
// VerifyMulti validates (one of the multiple) signatures on the object and
// DetachedVerifyMulti validates a detached signature on the given payload with
"//
			// See https://github.com/square/go-jose/issues/157 for more context."
// trusted.
"// header is confusing, and at least in ACME the two are considered to be mutually"
// additional values here. All values must be JSON-serializable.
// verification use VerifyMulti instead.
// UnsafePayloadWithoutVerification returns the payload without
// DetachedVerify validates a detached signature on the given payload. In
// a signature/object that has potentially multiple signers. This returns the index
// DetachedVerifyMulti is only useful if you have a payload and signature that are
// of a JWS object. Some specifications which make use of JWS like to insert
"// WithContentType adds a content type (""cty"") header and returns the updated"
// is only useful if you have a payload and signature that are separated from
// same time.
"//
// Be careful when verifying signatures based on embedded JWKs inside the"
"// This should be impossible, but let's check anyway."
// result of the JOSE spec. We've decided that this library will only include one or
// header that contains an embedded JWK while also simultaneously containing the kid
// the signature and index to guarantee that callers are getting the verified value.
// SigningKey represents an algorithm/key used to sign a message.
// Unsupported crit header
// NewSigner creates an appropriate signer based on the key type
// NewMultiSigner creates a signer for multiple recipients
// verifying it. The content returned from this function cannot be
// recipient.publicKey is a JWK synthesized for embedding when recipientSigInfo
// the other to avoid this confusion.
"//
// In most cases, you will probably want to use Verify or VerifyMulti instead."
// SignerOptions represents options that can be set when creating signers.
// Signer represents a signer which takes a payload and produces a signed JWS object.
// newVerifier creates a verifier based on the key type
// SignerOptions.
// so stubbing is meanlingless (hence the direct use of rand.Reader).
// A generic EC-based encrypter/verifier
// newRSASigner creates a recipientSigInfo based on the given key.
"// ECDH-ES mode doesn't wrap a key, the shared secret is used directly as the key."
// newRSARecipient creates recipientKeyInfo based on the given key.
// Sign the given payload
"// prevent chosen-ciphertext attacks as described in RFC 3218, ""Preventing"
// A key generator for ECDH-ES
// the size of the public modulus (e.g. using a 2048 bit key will
"// ECDH-ES uses direct key agreement, no key unwrapping necessary."
// therefore deliberately ignoring errors here.
// We serialize the outputs (r and s) into big-endian byte arrays and pad
// A generic RSA-based encrypter/verifier
// A generic EC-based decrypter/signer
"// Decrypt the given payload. Based on the key encryption algorithm,"
// this will either use RSA-PKCS1v1.5 or RSA-OAEP (with SHA-1 or SHA-256).
// produce 256 bytes of output). Reject this since it's invalid input.
"// When decrypting an RSA-PKCS1v1.5 payload, we must take precautions to"
"// Input size is incorrect, the encrypted payload should always match"
"// This has been fixed in Go 1.3.1 (released 2014/08/13), the recover()"
// newECDHRecipient creates recipientKeyInfo based on the given key.
"// According to documentation, Write() on hash never fails"
// See: https://groups.google.com/forum/#!topic/golang-dev/7ihX6Y6kx9k
// Encrypt the given payload and update the object.
// DecryptPKCS1v15SessionKey sometimes panics on an invalid payload
"// Encrypt the given payload. Based on the key encryption algorithm,"
// Verify the given payload
// See: https://code.google.com/p/go/source/detail?r=58ee390ff31602edb66af41ed10901ec95904d33
"// because of an index out of bounds error, which we want to ignore."
// Perform some input validation.
// them with zeros on the left to make sure the sizes work out. Both arrays
"// must be keyBytes long, and the output must be 2*keyBytes long."
// Decrypt the given payload and return the content encryption key.
// Verify that key management algorithm is supported by this encrypter
// Get a content encryption key for ECDH-ES
// Use rand.Reader for RSA blinding
"// the Million Message Attack on Cryptographic Message Syntax"". We are"
// A generic RSA-based decrypter/signer
// only exists for preventing crashes with unpatched versions.
// Get key size for EC key generator
"// Note: The random reader on decrypt operations is only used for blinding,"
// newECDSASigner creates a recipientSigInfo based on the given key.
// values. Prefer using Protected and Unprotected fields instead of this.
// Values in this header may or may not have been signed and in general
// we cannot marshal losslessly. So we have to keep around the original bytes.
// header struct only if those bytes are not available.
// Protected header. Values in this header were signed and
"// the original bytes of a protected header, and fall back on marshaling the"
// https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41#section-4
// The actual signature value
// FullSerialize serializes an object using the full JSON serialization format.
// rawJSONWebSignature represents a raw JWS JSON object. Used for parsing/serializing.
"// If we unmarshal Protected into a rawHeader with its explicit list of fields,"
"// No signatures array, must be flattened serialization"
// CompactSerialize serializes an object using the compact serialization format.
// Copy value of sig
// will be verified as part of the signature verification process.
// Check that there is not a nonce in the unprotected header
// and in general should not be trusted.
// parseSignedFull parses a message in full format.
// Protected header. This is necessary because the Protected header can
// ParseSigned parses a signed message in compact or full serialization format.
// Unprotected header. Values in this header were not signed
// Get a header value
// Compute data to be signed
// VerifyMulti() to ensure that the data you're getting is verified.
// Signature represents a single signature over the JWS payload and protected header.
// should not be trusted.
"// As per RFC 7515 Section 4.1.3, only public keys are allowed to be embedded."
"// Make a fake ""original"" rawSignatureInfo to store the unprocessed"
// rawSignatureInfo represents a single JWS signature over the JWS payload and protected header.
// Signatures attached to this object (may be more than one for multi-sig).
"// Be careful about accessing these directly, prefer to use Verify() or"
// contain arbitrary fields not registered as part of the spec. See
// JSONWebSignature represents a signed JWS object after parsing.
// parseSignedCompact parses a message in compact format.
// Merged header fields. Contains both protected and unprotected header
"// This is used in computeAuthData, which will first attempt to use"
// sanitized produces a cleaned-up JWS object from the raw JSON.
// https://tools.ietf.org/html/rfc7518#section-6.2.2.1
// Valid checks that the key contains the expected parameters.
// cases where they are not distinct. Hence method returns a slice
"// rawJSONWebKey represents a public or private key in JWK format, used for parsing/serializing."
// UnmarshalJSON reads a key from its JSON representation.
// JSONWebKey represents a public or private key in JWK format.
// Key convenience method returns keys by key ID. Specification states
// Thumbprint computes the JWK Thumbprint of a key using the
"// IsPublic returns true if the JWK represents a public key (not symmetric, not private)."
// Certificates
// indicated hash algorithm.
// of JSONWebKeys.
"// RSA uses D, P and Q, while ECDSA uses only D. Fields Dp, Dq, and Qi are"
// private key.
// returning invalid key
// Public creates JSONWebKey with corresponding publik key if JWK represents asymmetric private key.
"// that a JWK Set ""SHOULD"" use distinct key IDs, but allows for some"
// octets (where n is the order of the curve).
// MarshalJSON serializes the given key to its JSON representation.
// -- Following fields are only used for private keys --
"// completely optional. Therefore for RSA/ECDSA, D != nil is a contract that"
// The length of this octet string MUST be ceiling(log-base-2(n)/8)
// https://tools.ietf.org/html/rfc7518#section-6.2.1.2
// we have a private key whereas D == nil means we have only a public key.
// JSONWebKeySet represents a JWK Set object.
"// dSize returns the size in octets for the ""d"" member of an elliptic curve"
// The length of this octet string MUST be the full size of a coordinate for
"// the curve specified in the ""crv"" parameter."
// and the plaintext.
"// DecryptMulti decrypts and validates the object and returns the plaintexts,"
// Found a valid CEK -- let's try to decrypt.
// if necessary. It returns itself and so can be used in a fluent style.
"// on the password-based encryption algorithms PBES2-HS256+A128KW,"
// Can just add a standard recipient
// Decrypt and validate the object and return the plaintext. Note that this
"// PBES2-HS384+A192KW, and PBES2-HS512+A256KW. If they are not provided a safe"
// with support for multiple recipients. It returns the index of the recipient
// Optional map of additional keys to be inserted into the protected header
"// WithHeader adds an arbitrary value to the ExtraHeaders map, initializing it"
// only a single recipient.
"// The ""zip"" header parameter may only be present in the protected header."
// be generated.
// A generic content cipher
// A generic key decrypter
// ECDH-ES (w/o key wrapping) is similar to DIRECT mode
"//
// PBES2Count and PBES2Salt correspond with the  ""p2c"" and ""p2s"" headers used"
"// WithType adds a type (""typ"") header and returns the updated EncrypterOptions."
// EncrypterOptions.
// A generic encrypter based on the given key encrypter and content cipher.
// additional values here. All values must be JSON-serializable.
// Decrypt a key
// A generic key encrypter
// of a JWS object. Some specifications which make use of JWS like to insert
"// WithContentType adds a content type (""cty"") header and returns the updated"
// NewMultiEncrypter creates a multi-encrypter based on the given parameters
// default of 100000 will be used for the count and a 128-bit random salt will
// Encrypter represents an encrypter which produces an encrypted JWE object.
// Direct encryption mode must be treated differently
// newDecrypter creates an appropriate decrypter based on the key type
// Implementation of encrypt method producing a JWE object.
// Move per-recipient headers into main protected header if there's
// A key generator (for generating/getting a CEK)
// Encrypt a key
"// function does not support multi-recipient, if you desire multi-recipient"
// decryption use DecryptMulti instead.
// NewEncrypter creates an appropriate encrypter based on the key type
"// for which the decryption was successful, the merged headers for that recipient,"
// EncrypterOptions represents options that can be set on new encrypters.
// Recipient represents an algorithm/key to encrypt messages to.
// Generate a static key (for direct mode)
// Static key generator
// https://tools.ietf.org/html/rfc7518#section-4.8.1.2
// getPbkdf2Params returns the key length and hash function used in
// Create a new content cipher based on AES-GCM
// getRandomSalt generates a new salt of the given size.
// Sign the given payload
// Decrypt some data
// Compute the HMAC based on the given alg value
// PBES2 Salt Input
"// RFC7518 recommends a minimum of 1,000 iterations:"
// https://support.1password.com/pbkdf2/
// Input/output from an AEAD operation
// Initialize a new nonce
// use AES cipher with derived key
// Key size for static generator
// Encrypt the content encryption key.
// derive key
"// According to documentation, Write() on hash never fails"
// newSymmetricSigner creates a recipientSigInfo based on the given key.
// newSymmetricRecipient creates a JWE encrypter based on AES-GCM key wrap.
// Dummy key cipher for shared symmetric key mode
// Random reader (stubbed out in tests)
// Get a new AEAD instance
"// 1Password uses 100,000:"
// Default salt size: 128 bits
// Verify the given payload
"// NIST recommends a minimum of 10,000:"
// Get key size for this cipher
// PBES2 Count
// https://pages.nist.gov/800-63-3/sp800-63b.html
// A content cipher based on an AEAD construction
// Verify that key management algorithm is supported by this encrypter
// Get an AEAD cipher object for the given content encryption algorithm
// Random key generator
// Decrypt the content encryption key.
// Create a new content cipher based on AES-CBC+HMAC
// Generate a random key for the given content cipher
// pbkdf2.Key.
// salt is UTF8(Alg) || 0x00 || Salt Input
// Signer/verifier for MAC modes
// Pre-shared content-encryption key
// Encrypt some data
// Key size for random generator
// UseNumber causes the Decoder to unmarshal a number into an interface{} as a
// Terminate each value with a newline.
// Number instead of as a float64.
// read data from r beyond the JSON values requested.
// object from it before the error happened.
// First slide down data already consumed.
"// a larger operation such as Encode, and those will call Flush when finished."
"//
// See the documentation for Unmarshal for details about"
// Decode reads the next JSON-encoded value from its
// It returns an error if the delimiters [ ] { } are not properly used.
// An Encoder writes JSON objects to an output stream.
// MarshalJSON returns *m as the JSON encoding of m.
"//
//	Delim, for the four JSON delimiters [ ] { }"
"// At the end of the input stream, Token returns nil, io.EOF."
// This makes the output look a little nicer
// followed by a newline character.
// be used to delay JSON decoding or precompute a JSON encoding.
// input and stores it in the value pointed to by v.
// Make room to read more into the buffer.
// buffer. The reader is valid until the next call to Decode.
// Look in the buffer for a new value.
// UnmarshalJSON sets *m to a copy of data.
// Buffered returns a reader of the data remaining in the Decoder's
// Did the last read have an error?
// It returns the length of the encoding.
// peek is only called when using the Token API.
"// Encode writes the JSON encoding of v to the stream,"
"// without using Encode, need to call Flush when finished to ensure that"
// It implements Marshaler and Unmarshaler and can
// Commas and colons are elided.
"//
type Token interface{}"
// More reports whether there is another element in the
"// when debugging, and some kind of space"
"// is required if the encoded value was a number,"
// start of unread data in buf
// license that can be found in the LICENSE file.
// Read whole value into buffer.
// NewEncoder returns a new encoder that writes to w.
// readValue reads a JSON value into dec.buf.
"//
// EncodeToken does not call Flush, because usually it is part of"
// Token returns the next JSON token in the input stream.
"//	bool, for JSON booleans"
// Delayed until now to allow buffer scan.
"//
// Token guarantees that the delimiters [ ] { } it returns are"
// to mark the start and end of arrays and objects.
"//
// The decoder introduces its own buffering and may"
"// delimiter in the input, it will return an error."
"//	string, for JSON string literals"
"// We might block trying to get that byte from src,"
// A Token holds a value of one of these types:
// Don't save err from unmarshal into dec.err:
// the connection is still usable since we read a complete JSON
// NewDecoder returns a new decoder that reads from r.
// fixup token streaming state
// current array or object being parsed.
// properly nested and matched: if Token encounters an unexpected
// RawMessage is a raw encoded JSON object.
"//	Number, for JSON numbers"
// the conversion of JSON into a Go value.
// so instead invent a space byte.
"//
// See the documentation for Marshal for details about the"
"// Note: Not calling peek before switch, to avoid"
// digits coming.
// EncodeToken writes the given JSON token to the stream.
// scanEnd is delayed one byte.
"//	nil, for JSON null"
// advance tokenstate from a separator state to a value state
// putting peek into the standard Decode path.
// so that the reader knows there aren't more
"//
// The input stream consists of basic JSON values—bool, string,"
// Copyright 2010 The Go Authors.  All rights reserved.
"// buffer has been scanned, now report any error"
// conversion of Go values to JSON.
"// Callers that create an Encoder and then invoke EncodeToken directly,"
// Use of this source code is governed by a BSD-style
// the JSON is written to the underlying writer.
"//	float64, for JSON numbers"
"// number, and null—along with delimiters [ ] { } of type Delim"
// A Decoder reads and decodes JSON objects from an input stream.
"// A Delim is a JSON array or object delimiter, one of [ ] { or }."
// Read.  Delay error for next iteration (after scan).
// Grow buffer if not large enough.
// A nil interface value encodes as the null JSON object.
// An encodeState encodes JSON into a bytes.Buffer.
// Package json implements encoding and decoding of JSON objects as defined in
// are rendered into JSON and served to some browsers.
"//
//   // Field appears in JSON as key ""myName"" and"
// Record found field and index sequence.
"// were fields in the outer struct, subject to the usual Go visibility rules amended"
"//
//   // Field appears in JSON as key ""myName""."
// newTypeEncoder constructs an encoderFunc for a type.
// and can lead to security holes there. It is valid JSON to
// An anonymous struct field of interface type is treated the same as having
// A field represents a single field found in a struct.
"// for small buffers, using Encode directly is much faster."
// replacing invalid bytes with the Unicode replacement rune U+FFFD.
"// []byte encodes as a base64-encoded string, and a nil slice"
// length zero. The object's default key string is the struct field name
"// but can be specified in the struct field's tag value. The ""json"" key in"
// Marshaler is the interface implemented by objects that
// stringValues is a slice of reflect.Value holding *reflect.StringValue.
// we keep compatibility so check validity after this.
"//
// String values encode as JSON strings coerced to valid UTF-8,"
"// having that name, rather than being anonymous."
"//
// Boolean values encode as JSON booleans."
"// They are both technically valid characters in JSON strings,"
// This error is no longer generated but is kept for backwards compatibility
"// but don't work in JSONP, which has to be evaluated as JavaScript,"
// unexported
"// Delete all fields that are hidden by the Go rules for embedded fields,"
// so don't bother generating any more copies.
"// escape them, so we do so unconditionally."
"// of field index length. Loop over names; for each name, delete"
"//
// Handling of anonymous struct fields is new in Go 1.1."
// The map's key type must be string; the map keys are used as JSON object
// One iteration per name.
// deciding which field to marshal or unmarshal. If there are
"// sliceEncoder just wraps an arrayEncoder, checking to make sure the value isn't nil."
"//
//   // Field is ignored by this package."
// nested (and would therefore be the nesting level selected by the
"//   - the field's tag is ""-"", or"
// so just scan the string one byte at a time.
"// that type as its name, rather than being anonymous."
// the whole string value that caused the error
"// As of Go 1.2, Marshal instead coerces the string to valid UTF-8 by"
"// JSON tags. If there are multiple top-level fields, the boolean"
"//   - the field is empty and its tag specifies the ""omitempty"" option."
"//   Field int `json:"",omitempty""`"
"// This encodes bytes < 0x20 except for \n and \r,"
// If an encountered value implements the Marshaler interface
"//
func Marshal(v interface{}) ([]byte, error) {"
// https://golang.org/doc/articles/json_and_go.html
"//
// Marshal traverses the value v recursively."
"// keys, subject to the UTF-8 coercion described for string values above."
// An UnsupportedTypeError is returned by Marshal when attempting
// Byte slices get special treatment; arrays don't.
// its MarshalText method.
// accumulated output
// hidden fields by choosing the one dominant field that survives.
// becomes a member of the object unless
"//
// Pointer values encode as the value pointed to."
// when communicating with JavaScript programs:
// Number's zero-val
"//
// Channel, complex, and function values cannot be encoded in JSON."
// buffer space.
// and options. Examples:
// to produce JSON. If no MarshalJSON method is present but the
"//   Field int `json:""myName""`"
"// dominantField looks through the fields, all of which are known to"
"//
// Anonymous struct fields are usually marshaled as if their inner exported fields"
// to keep some browsers from misinterpreting JSON output as HTML.
"// we have a conflict (two fields named ""X"" at the same level) and we"
"//
// Struct values encode as JSON objects. Each exported struct field"
"// It only cares about the distinction between 1 or 2,"
// except that fields with JSON tags are promoted.
"// as well as <, > and &. The latter are escaped because they"
// U+2028 is LINE SEPARATOR.
// Only one field with this name
// []byte(name)
// Count of queued names for current level and the next.
"// then breaking ties with ""name came from json tag"", then"
"//
// Array and slice values encode as JSON arrays, except that"
"//
//   // Field appears in JSON as key ""Field"" (the default), but"
"// Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of"
// can lead to security holes when user-controlled strings
// license that can be found in the LICENSE file.
"//
// JSON cannot represent cyclic data structures and Marshal does not"
// byIndex sorts field by index sequence.
"// have the same name, to find the single field that dominates the"
"// HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029"
// underscores and slashes.
// Return no field.
"//
// The ""string"" option signals that a field is stored as JSON inside a"
// with programs that might mention it.
//   // as defined above.
// will be false: This condition is an error in Go and we skip all
// func is only used for recursive types.
"//
// The key name will be used if it's a non-empty string consisting of"
"// but mimics a similar, necessary exception in the behavior of"
// Marshal returns the JSON encoding of v.
"//
// See ""JSON and Go"" for an introduction to this package:"
// Fields found.
// Record new anonymous struct to explore in next round.
"// an anonymous struct field in both current and earlier versions, give the field"
// encodes as the null JSON object.
// An anonymous struct field with a name given in its JSON tag is treated as
"//
//    Int64String int64 `json:"",string""`"
// It implements the methods to sort by string.
"//
// Floating point, integer, and Number values encode as JSON numbers."
// as described in the next paragraph.
"// The angle brackets ""<"" and "">"" are escaped to ""\u003c"" and ""\u003e"""
"//
// 1) Of those fields, if any are JSON-tagged, only tagged fields are considered,"
"// Ampersand ""&"" is also escaped to ""\u0026"" for the same reason."
"// If there were multiple instances, add a second,"
// A nil pointer encodes as the null JSON object.
// newCondAddrEncoder returns an encoder that checks whether its value
// The returned encoder only checks CanAddr when allowAddr is true.
// Anonymous fields to explore at the current level and the next.
// replacing invalid bytes with the Unicode replacement rune.
// and then any reachable anonymous structs.
// cachedTypeFields is like typeFields but uses a cache to avoid repeated work.
// NOTE: keep in sync with stringBytes below.
// to encode an unsupported value type.
// must therefore be one with the shortest index length. Drop all
"// The empty values are false, 0, any"
"// only Unicode letters, digits, dollar signs, percent signs, hyphens,"
// Attempting to encode such a value causes Marshal to return
// Convert U+2028 and U+2029 (E2 80 A8 and E2 80 A9).
// Index of first tagged field.
// The nil pointer exception is not strictly necessary
"//   // the field is omitted from the object if its value is empty,"
"// value implements encoding.TextMarshaler instead, Marshal calls"
// even if there are multiple untagged fields that would otherwise conflict.
// Multiple tagged fields at the same level: conflict.
// MarshalIndent is like Marshal but applies Indent to format the output.
"// for large buffers, avoid unnecessary extra temporary"
"// Backslash and quote chars are reserved, but"
"// the struct field's tag value is the key name, followed by an optional comma"
// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.
// NOTE: keep in sync with string above.
"// Only strings, floats, integers, and booleans can be quoted."
// in the documentation for the Marshal and Unmarshal functions.
"// characters inside string literals changed to \u003c, \u003e, \u0026, \u2028, \u2029"
"// In Go1.5 the empty string encodes to ""0"", while this is not a valid number literal"
// so that the annihilation code will see a duplicate.
// U+2029 is PARAGRAPH SEPARATOR.
"// copy JSON into buffer, checking validity."
// number of bits
"// The characters can only appear in string literals,"
"//   Field int `json:""-""`"
// attempting to encode a string value with invalid UTF-8 sequences.
"// CanAddr and delegates to canAddrEnc if so, else to elseEnc."
"// The fields are sorted in primary order of name, secondary order"
// in a tag name.
// typeFields returns a list of fields that JSON should recognize for the given type.
"// others using Go's embedding rules, modified by the presence of"
// Types already visited at an earlier level.
"// To deal with recursive types, populate the map with an"
// Compute fields without lock.
// The algorithm is breadth-first search over the set of structs to include - the top struct
"// longer entries, which is easy: just truncate the slice."
"// as well as <, >, and &. The latter are escaped because they"
// Copyright 2010 The Go Authors.  All rights reserved.
"// byName sorts field by name, breaking ties with depth,"
// return no field.
"//   Field int `json:""myName,omitempty""`"
// be used.
// the fields.
// breaking ties with index sequence.
"//
// Map values encode as JSON objects."
"// escaping within <script> tags, so an alternative JSON encoding must"
"// For historical reasons, web browsers don't honor standard HTML"
"// nil pointer or interface value, and any array, slice, map, or string of"
// real func (f) to be ready and then calls it.  This indirect
// Use of this source code is governed by a BSD-style
// UnmarshalJSON.
// handle them.  Passing cyclic structures to Marshal will result in
// RFC 4627. The mapping between JSON objects and Go values is described
"//
// The Go visibility rules for struct fields are amended for JSON when"
// Find the sequence of fields with the name of this first field.
"// a JSON tag of ""-""."
"//
// Otherwise, Marshal uses the following type-dependent default encodings:"
// an UnsupportedTypeError.
// an infinite recursion.
// indirect func before we build it. This type waits on the
// otherwise any punctuation chars are allowed
// Follow pointer.
"// All remaining fields have the same length. If there's more than one,"
// Scan f.typ for fields to include.
"// usual Go rules), the following extra rules apply:"
"// 2) If there is exactly one field (tagged or not according to the first rule), that is selected."
// so that the JSON will be safe to embed inside HTML <script> tags.
"// multiple fields at the same level, and that level is the least"
//   // the field is skipped if empty.
// Might duplicate effort but won't hold other computations back.
"// 3) Otherwise there are multiple fields, and all are ignored; no error occurs."
// can marshal themselves into valid JSON.
"//
// Interface values encode as the value contained in the interface."
"// JSON-encoded string. It applies only to fields of string, floating point,"
"// Before Go 1.2, an InvalidUTF8Error was returned by Marshal when"
// The fields are sorted in increasing index-length order. The winner
"// integer, or boolean types. This extra level of encoding is sometimes used"
"// and is not a nil pointer, Marshal calls its MarshalJSON method"
//   // Note the leading comma.
// comma-separated options.
// Contains reports whether a comma-separated list of options
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// parseTag splits a struct field's json tag into its name and
// contains a particular substr flag. substr must be surrounded by a
// string boundary or commas.
"// tagOptions is the string following a comma in a struct field's ""json"""
"// tag, or the empty string. It does not include the leading comma."
// indented line beginning with prefix followed by one or more
"// Each element in a JSON object or array begins on a new,"
// Emit semantically uninteresting bytes
// delay indent so that empty object and array are formatted as {} and [].
"// at the beginning of src are dropped, trailing space characters"
// at the end of src are preserved and copied to dst.
// Copyright 2010 The Go Authors.  All rights reserved.
"// (in particular, punctuation in strings) unmodified."
// insignificant space characters elided.
// copies of indent according to the indentation nesting.
// Compact appends to dst the JSON-encoded src with
// Use of this source code is governed by a BSD-style
"// if src ends in a trailing newline, so will dst."
// Add spacing around real punctuation.
// license that can be found in the LICENSE file.
"// Although leading space characters (space, tab, carriage return, newline)"
// Indent appends to dst an indented form of the JSON-encoded src.
// suppress indent in empty object/array
// Convert U+2028 and U+2029 (E2 80 A8 and E2 80 A9).
"// any indentation, to make it easier to embed inside other formatted JSON data."
"// For example, if src has no trailing spaces, neither will dst;"
// The data appended to dst does not begin with the prefix nor
// but they avoid the weight of reflection in this common case.
// Our scanner has seen the opening brace/bracket
// quoted string literal or literal null into an interface value.
// arrayInterface is like array but returns []interface{}.
// Unmarshaler is the interface implemented by objects
// whether the value is wrapped in a string to be decoded first
// Otherwise it's invalid.
// Check type of target.
// if it wishes to retain the data after returning.
"// the value pointed at by the pointer.  If the pointer is nil, Unmarshal"
// read offset in data
// led to an unexported (and therefore unwritable) struct field.
// Make sure we are at the end.
"// getu4 decodes \uXXXX from the beginning of s, returning the hex value,"
// Look ahead for ] - can only happen on first iteration.
// d.scan thinks we just read an object key; finish the object
// Unmarshal replaces the slice with a new empty slice.
"// The next value is known to be an object or array, not a literal."
"// As a special case, to unmarshal an empty JSON array into a slice,"
// Invalid surrogate; fall back to replacement rune.
"// Instead, they are replaced by the Unicode replacement"
// character U+FFFD.
// Write value back to map;
// on the value and produces no error.
// All bytes inside literal return scanContinue op code.
// Grow slice if necessary
// map must have string kind
// A valid pair; consume.
"// If the JSON array is smaller than the Go array,"
// in the value pointed to by v.
// Check for unmarshaler.
"// Get element of array, growing if necessary."
"//
// Unmarshal uses the inverse of the encodings that"
"//
// The JSON null value unmarshals into an interface, map, pointer, or slice"
// the first byte of the array ('[') has been read already.
"// the JSON being the JSON literal null.  In that case, Unmarshal sets"
// error occurred after reading Offset bytes
"//
func Unmarshal(data []byte, v interface{}) error {"
"// establishes a map to use, If the map is nil, Unmarshal allocates a new map."
"// otherwise, ignore null for primitives/string"
"//	[]interface{}, for JSON arrays"
"// The rules are different than for Go, so cannot use strconv.Unquote."
// invent a closing brace/bracket to get it out.
// See https://tools.ietf.org/html/rfc7159#section-6
// The input can be assumed to be a valid encoding of
// value decodes a JSON value from d.data[d.off:] into the value.
// mark processed EOF with len+1
"//
//	bool, for JSON booleans"
"// literal consumes a literal from d.data[d.off-1:], decoding into the value v."
"//
// To unmarshal JSON into a struct, Unmarshal matches incoming object"
// Array.  Zero the rest.
"//	map[string]interface{}, for JSON objects"
// Ran out of fixed array: skip.
// decodeState represents the state while decoding a JSON value.
// malformed UTF-8 and we're replacing each
// next cuts off and returns the next full JSON value in d.data[d.off:].
// convertNumber converts the number literal s to a float64 or a Number
// String returns the literal text of the number.
// depending on the setting of d.useNumber.
// literalStore decodes a literal stored in item into v.
// Unmarshal then stores key-value pairs from the JSON object into the map.
"// the pointer to nil.  Otherwise, Unmarshal unmarshals the JSON into"
// that can unmarshal a JSON description of themselves.
// Scan read one byte too far; back up.
// JSON array elements into corresponding Go array elements.
// by setting that Go value to nil. Because null is often used in JSON to mean
// invalid UTF-16 surrogate pairs are not treated as an error.
// Copyright 2010 The Go Authors. All rights reserved.
"// or if a JSON number overflows the target type, Unmarshal"
// scanWhile processes bytes in d.data[d.off:] until it
// Avoids filling out half a data structure
// byte with RuneError.
// license that can be found in the LICENSE file.
"// string from the "",string"" struct tag option. this is used only to"
"//
// To unmarshal JSON into a pointer, Unmarshal first handles the case of"
// (The argument to Unmarshal must be a non-nil pointer.)
// (No longer used; kept for compatibility.)
// 1 or more digits.
"// object consumes an object from d.data[d.off-1:], decoding into the value v."
// This function implements the JSON numbers grammar.
// usefully addressable.
// skips that field and completes the unmarshaling as best it can.
"// Next token must be , or ]."
// An UnmarshalTypeError describes a JSON value that was
// Optional -
"// If it finds anything other than a quoted string literal or null,"
// and thinks we're still in the middle of the object.
// null
// Read string key.
// test must be applied at the top level of the value.
"// true, false"
// Check type of target: struct or map[string]T
//	nil for JSON null
"// description of JSON value - ""bool"", ""array"", ""number -5"""
"// if using struct, subv points into struct already."
// the additional Go array elements are set to zero values.
"// if it encounters an Unmarshaler, indirect stops and returns that."
// valueQuoted is like value but decodes a
// (that's how the caller knows it's a literal).
// there is a bug in the JSON decoder or something is editing
"// ``not present,'' unmarshaling a JSON null into any other Go type has no effect"
// skip over { } in input
"// Quote, control characters are invalid."
"// then no unquoting is needed, so return a slice of the"
// string
// error aborts the decoding by panicking with err.
// produce more helpful error messages.
// Read key.
// not appropriate for a value of a specific Go type.
// Coerce to well-formed UTF-8.
// the data slice while the decoder executes.
// the additional JSON array elements are discarded.
"// Read opening "" of string key or closing }."
// The xxxInterface routines build up a value to be stored
"// strings, arrays, and maps."
"// If the Go array is smaller than the JSON array,"
// Back up so d.value can have the byte we just read.
// type of Go value it could not be assigned to
"// indirect walks down v allocating pointers as needed,"
// Check for well-formedness.
// A Number represents a JSON number literal.
// an UnmarshalTypeError describing the earliest such error.
// isValidNumber reports whether s is a valid JSON number literal.
"//	string, for JSON strings"
"// array consumes an array from d.data[d.off-1:], decoding into the value v."
// valueQuoted returns unquotedValue{}.
// Decode into element.
// and http://json.org/number.gif
"//
// To unmarshal a JSON object into a string-keyed map, Unmarshal first"
// Read value.
// Out of room?  Can only happen if s is full of
// the first byte ('{') of the object has been read already.
// The first byte of the literal has been read already
"//
// To unmarshal JSON into an interface value,"
// An InvalidUnmarshalError describes an invalid argument passed to Unmarshal.
"// start with its address, so that if the type has pointer methods,"
"// saveError saves the first err it is called with,"
// with the following additional rules:
// until it gets to a non-pointer.
"// Load value from interface, but only if the result will be"
"// in an empty interface.  They are not strictly necessary,"
// Float64 returns the number as a float64.
"//
// If a JSON value is not appropriate for a given target type,"
"// If v is a named type and is addressable,"
// An UnmarshalFieldError describes a JSON object key that
// Unmarshal will only set exported fields of the struct.
// we find them.
// objectInterface is like object but returns map[string]interface{}.
// before discovering a JSON syntax error.
// receives a scan code not equal to op.
// Figure out field corresponding to key.
"//
// fromQuoted indicates whether this literal came from unwrapping a"
"//
// To unmarshal a JSON array into a Go array, Unmarshal decodes"
// We decode rv not rv.Elem because the Unmarshaler interface
// number
// e or E followed by an optional - or + and
"// Represents JSON data structure using native Go types: booleans, floats,"
// for calls to nextValue
// so that it knows we got to the end of the value.
// literalInterface is like literal but returns an interface value.
"// Marshal uses, allocating maps, slices, and pointers as necessary,"
// or it returns -1.
// Digits
"// Next token must be , or }."
// preferring an exact match but also accepting a case-insensitive match.
// it updates d.off to point past the decoded value.
// valueInterface is like value but returns interface{}
"// Check for unusual characters. If there are none,"
// d.scan thinks we're still at the beginning of the item.
// rewind.
// ASCII
"//
// When unmarshaling quoted strings, invalid UTF-8 or"
// for reporting at the end of the unmarshal.
// Check for duplicate keys.
// It updates d.off and returns the new scan code.
"// If no more serious errors are encountered, Unmarshal returns"
// errPhase is used for errors that should not happen unless
// Use of this source code is governed by a BSD-style
// closing } - can only happen on first iteration.
"//	float64, for JSON numbers"
// Read : before value.
// Unmarshal stores one of these in the interface value:
// to zero and then appends each element to the slice.
"// keys to the keys used by Marshal (either the struct field name or its tag),"
"//
// To unmarshal a JSON array into a slice, Unmarshal resets the slice length"
// allocates a new value for it to point to.
// unquote converts a quoted JSON string literal s into an actual string t.
"// if decodingNull is true, indirect stops at the last pointer so it can be set to nil."
// . followed by 1 or more digits.
"// Feed in an empty string - the shortest, simplest value -"
"// Otherwise Unmarshal reuses the existing map, keeping existing entries."
// Unmarshal parses the JSON-encoded data and stores the result
// a JSON value. UnmarshalJSON must copy the JSON data
// Int64 returns the number as an int64.
// Decoding into nil interface?  Switch to non-reflect code.
// original bytes.
"// is not a space, scanEndTop allocates a needless error."
// It returns a scan status just as s.step does.
"// stateInStringEscU is the state after reading `""\u` during a quoted string."
// pushParseState pushes a new parse state p onto the parse stack.
// state0 is the state after reading `0` during a number.
// They give details about the current state of the scan that
"// and ending literals, objects, and arrays, so that the"
// stateBeginValueOrEmpty is the state after reading `[`.
// Complain about non-space byte on next call.
// undo causes the scanner to return scanCode from the next state transition.
// such as after reading `314e-2` or `0.314e+1` or `3.14e0`.
// beginning of 1234.5
// Only space characters should be seen now.
// just finished object key (string)
"// stateInStringEsc is the state after reading `""\` during a quoted string."
// stateT is the state after reading `t`.
"// stateError is the state after reaching a syntax error,"
"// stateBeginString is the state after reading `{""key"": value,`."
"// top-level value ended *before* this byte; known to be first ""stop"" result"
// checkValid verifies that data is valid JSON-encoded data.
"// with a switch, but using the func directly was 10% faster"
"// stateInStringEscU12 is the state after reading `""\u12` during a quoted string."
// error occurred after reading Offset bytes
// to recognize the end of numbers: is 123 a whole value or
// It must be called before calling s.step.
// parsing object value (after colon)
// such as after reading `314e` or `0.314e`.
"// and at least one digit of the exponent in a number,"
// begin array
"// Some parts are a bit tedious, but overall it nicely factors out the"
// JSON value parser state machine.
"// get scanEnd on the next character. Otherwise, if the next character"
// every subsequent call will return scanError too.
"// such as after reading `{}` or `true` or `[""x""`."
// stateBeginValue is the state at the beginning of the input.
"// stateDot0 is the state after reading the integer, decimal point, and subsequent"
// This gives callers a simple 1-byte undo mechanism.
// such as after reading `314e-` or `0.314e+`.
// parsing object key (before colon)
"// the parseState describes the nested state, outermost at entry 0."
// stateTru is the state after reading `tru`.
// stateN is the state after reading `n`.
// scan is passed in for use by nextValue to avoid an allocation.
// before diving into the scanner itself.
"// space byte; can skip; known to be last ""continue"" result"
// stateNul is the state after reading `nul`.
// quoteChar formats c as a quoted character literal
// Callers call scan.reset() and then pass bytes in one at a time
"// stateE0 is the state after reading the mantissa, e, optional sign,"
// popParseState pops a parse state (already obtained) off the stack
// Continue.
// just finished non-last object value
// beginning of null
// A SyntaxError is a description of a JSON syntax error.
// license that can be found in the LICENSE file.
"// digits of a number, such as after reading `3.14`."
// The step is a func to be called to execute the next transition.
"// call to scanner.state: if one call returns scanError,"
// eof tells the scanner that the end of input has been reached.
// These values are returned by the state transition functions
"// nextValue splits data after the next whole JSON value,"
// parsing array value
// stateFals is the state after reading `fals`.
// such as after reading `[1}` or `5.1.2`.
// Just about at the limit of what is reasonable to write by hand.
// These values are stored in the parseState stack.
"// stateInStringEscU123 is the state after reading `""\u123` during a quoted string."
"//
// This file starts with two simple examples using the scanner"
// beginning of false
// Reached end of top-level value.
"// stateInStringEscU1 is the state after reading `""\u1` during a quoted string."
// stateNu is the state after reading `nu`.
// just finished array value
// just got passed in.  (The indication must be delayed in order
// Completed top-level before the current byte.
// being scanned.  If the parser is inside a nested value
"// stateDot is the state after reading the integer and decimal point in a number,"
// A scanner is a JSON scanning state machine.
// beginning of true
// error records an error and switches to the error state.
// use quoted string with different quotation marks
// stateNeg is the state after reading `-` during a number.
// such as after reading `1` or `100` but not `0`.
// end implied by next result != scanContinue
"// by calling scan.step(&scan, c) for each byte."
"// stateE is the state after reading the mantissa and e in a number,"
// caller can follow along if it wishes.
// 1-byte redo (see undo method)
// begin object
// description of error
"// stateInString is the state after reading `""`."
"// total bytes consumed, updated by decoder.Decode"
// otherwise common code from the multiple scanning functions
"// on a 64-bit Mac Mini, and it's nicer to read."
"// stateESign is the state after reading the mantissa, e, and sign in a number,"
"// The return value, referred to as an opcode, tells the"
// caller about significant parsing events like beginning
// They give the current state of a composite value
"// Stack of what we're in the middle of - array values, object keys, object values."
// uninteresting byte
"// state1 is the state after reading a non-zero integer during a number,"
// Stop.
// reset prepares the scanner for use.
// It is okay to ignore the return value of any particular
// stateTr is the state after reading `tr`.
// returning that value and the bytes that follow it as separate slices.
// and updates s.step accordingly.
// the beginning of 12345e+6?).
// stateFa is the state after reading `fa`.
// stateFal is the state after reading `fal`.
"// JSON value has been completed, *before* the byte that"
// stateBeginStringOrEmpty is the state after reading `{`.
// beginning of 0.123
// The return value scanEnd indicates that a single top-level
// Copyright 2010 The Go Authors.  All rights reserved.
// end object (implies scanObjectValue if possible)
// stateRedo helps implement the scanner's 1-byte undo.
"// such as after reading `{}` or `[1,2,3]`."
"// hit an error, scanner.err."
// such as after reading `1.`.
// special cases - different from quoted strings
// Use of this source code is governed by a BSD-style
// end array (implies scanArrayValue if possible)
// numbers
// stateF is the state after reading `f`.
// scan is passed in for use by checkValid to avoid an allocation.
"// in this package (Compact, Indent, checkValid, nextValue, etc)."
// probe the scanner with a space to determine whether we will
"// stateEndValue is the state after completing a value,"
// Also tried using an integer constant and a single func
// assigned to scanner.state and the method scanner.eof.
"// stateEndTop is the state after finishing the top-level value,"
// callers might be interested to know about.
"// Error that happened, if any."
// KeyWrap implements NIST key wrapping; it wraps a content encryption key (cek) with the given block cipher.
// KeyUnwrap implements NIST key unwrapping; it unwraps a content encryption key (cek) with the given block cipher.
// Seal encrypts and authenticates the plaintext.
// An AEAD based on CBC+HMAC
"// Maximum overhead is block size (for padding) plus auth tag length, where"
// the length of the auth tag is equivalent to the key size.
// Output buffer -- must take care not to mangle plaintext input.
"// According to documentation, Write() on hash.Hash never fails."
// Apply padding
// Compute an authentication tag
// Remove padding
// Open decrypts and authenticates the ciphertext.
// resize ensures the the given slice has a capacity of at least n bytes.
"// If the capacity of the slice is less than n, a new slice is allocated"
// NewCBCHMAC instantiates a new AEAD based on CBC+HMAC.
// and the existing data will be copied.
"// Make copy of ciphertext buffer, don't want to modify in place"
// DeriveECDHES derives a shared encryption key using ECDH/ConcatKDF as described in JWE/JWA.
// Read on the KDF will never fail
// curve. Callers must ensure that the keys are valid before calling this function. Output
// It is an error to call this function with a private/public key that are not on the same
"// algId, partyUInfo, partyVInfo inputs must be prefixed with the length"
// size may be at most 1<<16 bytes (64 KiB).
// suppPubInfo is the encoded length of the output size in bits
// Write on a hash.Hash never fails
// NewConcatKDF builds a KDF reader based on the given inputs.
// Check if the buffer is empty.
// Flush the output buffer.
// Set the writer error and return false.
// The information associated with the document nodes.
// The single-quoted scalar style.
// The end of the node.
// The currently parsed document.
// An ALIAS token.
// Expect a block node or indentless sequence.
// Expect a value of an ordered mapping.
// The node type.
// The stream encoding.
// The end of the tag directives list.
"//
// @returns On success, the handler should return @c 1.  If the handler failed,"
// The emitter structure.
// EOF flag
// Expect a value of a flow mapping.
// If the node has been emitted?
// A STREAM-END event.
// Expect DOCUMENT-START or STREAM-END.
// The position index.
// The byte about which the problem occurred.
// The tag !!float for float values.
// The currently emitted document.
// Expect a block mapping key.
// The current emitter state.
// A mapping node.
// Expect a block mapping value.
// Emitter Definitions
// Expect nothing.
// The head of the event queue.
// Expect the first key of a block mapping.
// Writer stuff
// Write handler.
// The pointer position.
// The node tag.
"//
type yaml_write_handler_t func(emitter *yaml_emitter_t, buffer []byte) error"
// The error context.
// String output data.
// A MAPPING-END event.
"//
// All members are internal.  Manage the structure using the @c yaml_emitter_"
// Does the tokens queue contain a token ready for dequeueing.
// The tag suffix (for yaml_TAG_TOKEN).
// A BLOCK-ENTRY token.
// A DOCUMENT-START event.
// Expect a value of a block mapping.
// [out]      buffer      The buffer to write the data from the source.
// A FLOW-MAPPING-END token.
// The node structure.
// The flow mapping style.
// The scalar parameters (for yaml_SCALAR_NODE).
// The scalar value.
// An empty event.
// The tag !!seq is used to denote sequences.
// The document structure.
// Anchor analysis.
// Tag analysis.
// Expect a key of a flow mapping.
// The current parser state.
// The emitter states.
// Is a simple key required?
// Cannot compose a YAML document.
// Error handling
// The key of the element.
// File input data.
// The anchor.
// The parser states stack.
// The anchor id.
// Expect the first entry of a block sequence.
// Is the tag optional for any non-plain style? (for yaml_SCALAR_EVENT).
// The version directive.
// The scalar value (for yaml_SCALAR_EVENT).
// the returned value should be @c 0.
// A VALUE token.
// A VERSION-DIRECTIVE token.
// A TAG token.
"//
// All members are internal. Manage the structure using the"
"// The anchor (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT, yaml_ALIAS_EVENT)."
// The stack of sequence items.
// Is it a sequence context?
// A SCALAR token.
// The tokens queue.
// The version directive data.
// Many bad things could happen with the parser and emitter.
"// The style (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT)."
// Cannot read or decode the input stream.
// Event types.
// The preferred width of the output lines.
// Node Styles
// Have we reached the end of the input stream?
// A FLOW-SEQUENCE-START token.
// Expect DOCUMENT-END.
// Cannot allocate or reallocate a block of memory.
// Is the document end indicator implicit?
// Token types.
// Scalar analysis.
// The current flow level.
// The flow sequence style.
// If the stream was already closed?
// The default sequence tag is !!seq.
// Expect an entry of a flow sequence.
// Tokens
// The tag !!timestamp for date and time values.
// An empty token.
// Does the scalar contain line breaks?
// yaml_parser_ family of functions.
// The working buffer.
// The beginning of the stack.
// The default UTF-8 encoding.
// An element of a mapping node.
// The head of the tokens queue.
// Expect the beginning of an implicit document.
// The number of the token.
// The prototype of a write handler.
// The tag !!str for string values.
// Is it an alias?
// A FLOW-SEQUENCE-END token.
// The mark of the current position.
// Nodes
// The current indentation level.
// A STREAM-END token.
// Parser stuff
// Dumper stuff
// A FLOW-MAPPING-START token.
// [out]      size_read   The actual number of bytes read from the source.
// The output style.
// Can the scalar be expressed in the literal or folded styles?
// Node types.
// The tag directive data.
// The current position of the buffer.
// The tag !!map is used to denote mapping.
// Reader stuff
// Not in original libyaml.
// Expect a value for a simple key of a block mapping.
// The stack of indentation levels.
// Expect the first item of a block sequence.
// Cannot write to the output stream.
// Events
// characters to the output.  The handler should write @a size bytes of the
// @param[in]       size        The size of the buffer.
// source. The handler should write not more than size bytes to the buffer.
// A SEQUENCE-END event.
// size_read to 0 and return 1.
// Let the emitter choose the style.
// Is a simple key possible?
// A SCALAR event.
// The number of indentation spaces.
// A DOCUMENT-START token.
// Expect STREAM-START.
// Can the scalar be expressed in the single quoted style?
// The anchor value.
// The literal scalar style.
// [in]       size        The size of the buffer.
// Expect the first entry of a flow sequence.
// Use LN for line breaks (Unix style).
"// the returned value should be 0. On EOF, the handler should set the"
// The node id.
// Expect the first item of a flow sequence.
// The list of tag directives (for yaml_DOCUMENT_START_EVENT).
// The mapping style.
// The number of references.
// Expect the key of a block mapping.
// A FLOW-ENTRY token.
// The last assigned anchor id.
// The length of the scalar value.
// The parser structure.
// The tag !!null with the only possible value: null.
// @param[in]       buffer      The buffer with bytes to be written.
// The number of unclosed '[' and '{' indicators.
// family of functions.
// Expect a flow node.
// The input encoding.
"// Is the document start/end indicator implicit, or the tag optional?"
"// If the last character was an indentation character (' ', '-', '?', ':')?"
// A STREAM-START token.
// Is it the document root context?
// The value of the element.
// The number of unread characters in the buffer.
// Error description.
// Read handler.
// The scalar style (for yaml_SCALAR_TOKEN).
// The tag prefix.
// The sequence parameters (for YAML_SEQUENCE_NODE).
// Expect the content of a document.
"// The tag (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT)."
// The position mark.
// This structure holds information about a potential simple key.
// Expect an entry of a block sequence.
// The top of the stack.
// This structure holds aliases data.
// If the output is in the canonical style?
// The number of written bytes should be set to the size_read variable.
// A sequence node.
// @a buffer to the output.
// The folded scalar style.
"//
// [in,out]   data        A pointer to an application data specified by"
// The plain scalar style.
// The event structure.
// Let the parser choose the encoding.
// A BLOCK-END token.
// The document encoding (for yaml_STREAM_START_EVENT).
// The double-quoted scalar style.
// The states of the parser.
// The beginning of the node.
// Expect the and of an ordered mapping entry.
// The default scalar tag is !!str.
// The list of TAG directives.
// Error type.
// An element of a sequence node.
// The block mapping style.
// If the last character was a whitespace?
// The block sequence style.
// Sequence styles.
// Expect an empty value of a flow mapping.
// A DOCUMENT-END event.
// The stream encoding (for yaml_STREAM_START_TOKEN).
// Use CR for line breaks (Mac style).
// The tag directive prefix (for yaml_TAG_DIRECTIVE_TOKEN).
// The stack of marks.
// Let the parser choose the break type.
// Expect a value for a simple key of a flow mapping.
// A MAPPING-START event.
"// (for yaml_ALIAS_TOKEN, yaml_ANCHOR_TOKEN, yaml_SCALAR_TOKEN, yaml_TAG_TOKEN, yaml_TAG_DIRECTIVE_TOKEN)."
// No error is produced.
// The node data.
// Expect a key of an ordered mapping.
// The sequence style.
// Expect an entry of an indentless sequence.
// Expect DOCUMENT-START.
//                              yaml_emitter_set_output().
// A DOCUMENT-END token.
// An ANCHOR token.
// The stack of states.
// The mapping parameters (for yaml_MAPPING_NODE).
// Scalar styles.
// The position column.
// The default mapping tag is !!map.
// Expect the first key of a flow mapping.
// A SEQUENCE-START event.
// The offset of the current position (in bytes).
// The UTF-16-LE encoding with BOM.
// The alias data.
// The position line.
// The version directive (for yaml_DOCUMENT_START_EVENT).
// Use CR LN for line breaks (DOS style).
// Cannot emit a YAML stream.
// The stack of simple keys.
// Expect the first DOCUMENT-START or STREAM-END.
// Line break types.
//                        yaml_parser_set_input().
// An ALIAS event.
// The major version number.
// The UTF-16-BE encoding with BOM.
// The indentation levels stack.
// The tag !!bool with the values: true and false.
"//
// On success, the handler should return 1.  If the handler failed,"
"// The stack of mapping pairs (key, value)."
// The raw buffer.
// Is it a mapping context?
// Cannot scan the input stream.
// Can the scalar be expressed in the block plain style?
// An empty node.
// If the stream was already opened?
// May a simple key occur at the current position?
// File output data.
// Allow unescaped non-ASCII characters?
// If an explicit document end is required?
// Cannot parse the input stream.
"//
// The read handler is called when the parser needs to read more bytes from the"
// A TAG-DIRECTIVE token.
// The tag suffix.
// A scalar node.
// The preferred line break.
"// (for yaml_DOCUMENT_START_EVENT, yaml_DOCUMENT_END_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT, yaml_SCALAR_EVENT)."
// The minor version number.
// A KEY token.
// Emitter stuff
// The list of tag directives.
// Mapping styles.
// Expect an item of a block sequence.
// Is it a simple mapping key context?
"//
// The write handler is called when the emitter needs to flush the accumulated"
// The end of the stack.
// The token type.
// A STREAM-START event.
// The version directive major/minor (for yaml_VERSION_DIRECTIVE_TOKEN).
// The scalar style.
// String input data.
// The start/end of the token.
// The tag !!int for integer values.
// A BLOCK-SEQUENCE-END token.
// The tag handle.
// Expect a block node.
// The start and end of the event.
"//
// @param[in,out]   data        A pointer to an application data specified by"
// The event type.
// The event queue.
// Scanner stuff
// Is the document start indicator implicit?
// The current line.
// The start/end of the document.
// The number of tokens fetched from the queue.
// The document nodes.
// The current column.
// The alias/anchor/scalar value or tag/tag directive handle
// The beginning of the tag directives list.
// The prototype of a read handler.
// The anchor mark.
// A BLOCK-SEQUENCE-START token.
// Expect an item of a flow sequence.
// Can the scalar be expessed in the flow plain style?
// Have we started to scan the input stream?
// The token structure.
// Determine the width of the character.
// Check if the character is ASCII.
// Check if the character at the specified position is space.
// Don't replace these by a switch without first
// Check if the character at the specified position is NUL.
// The size of the output buffer.
// The size of the output raw buffer.
// Check if the beginning of the buffer is a BOM.
// Check if the character at the specified position is tab.
"// Check if the character is a line break, space, or NUL."
// is_breakz:
// is_z:
// Get the value of a digit.
// #xE000 <= . <= #xFFFD
// LS (#x2028)
// Check if the character at the specified position is a digit.
"// Check if the character is a line break, space, tab, or NUL."
// confirming that it is being inlined.
// Check if the character is a line break or NUL.
// Check if the character at the specified position is blank (space or tab).
// Check if the character at the specified position is an alphabetical
// It should be possible to decode the whole raw buffer.
// && . != #xFEFF
// LF (#xA)
// CR (#xD)
// is_break:
// The size of the input buffer.
"// character, a digit, '_', or '-'."
// Check if the character at the specified position is a line break.
// NEL (#x85)
// Check if the character at the start of the buffer can be printed unescaped.
// is_space:
// The size of the input raw buffer.
// PS (#x2029)
// Get the value of a hex-digit.
// It should be possible to encode the whole output buffer.
// The size of other stacks and queues.
// Check if the character at the specified position is a hex-digit.
// is_blank:
// #x20 <= . <= #x7E
// #0xA0 <= . <= #xD7FF
// . == #x0A
// correctly populate the data.
// Note: struct fields must be public in order for unmarshal to
// a and b must necessarily have the same kind.
// and whether it is a number/bool or not.
// keyFloat returns a float value for v if it is a number/bool
// numLess returns whether a < b.
"//
//    memset(document, 0, sizeof(yaml_document_t))"
//    assert(token);  // Non-NULL token object expected.
//                            // Valid item id is required.
"//        tag *yaml_char_t, style yaml_mapping_style_t)"
//        start *yaml_node_t
"//            if (!PUSH(&context, tag_directives_copy, value))"
"//
//    if (tag_directives_start != tag_directives_end) {"
"//
//    if (!yaml_check_utf8(tag, strlen((char *)tag))) goto error"
// Set the preferred line break character.
//    assert(document.nodes.start[sequence-1].type == YAML_SEQUENCE_NODE)
//    assert(key > 0 && document.nodes.start + key <= document.nodes.top)
// Destroy an emitter object.
"//
//"
//            break;
//    yaml_char_t *end = start+length;
"//
//    if (!STACK_INIT(&context, items, INITIAL_STACK_SIZE)) goto error"
"//
//        case YAML_ANCHOR_TOKEN:"
"//
//    SCALAR_NODE_INIT(node, tag_copy, value_copy, length, style, mark, mark)"
"//            if (!yaml_check_utf8(tag_directive.handle,"
//        if (!((width == 1) ||
//        start *yaml_node_pair_t
//        style yaml_scalar_style_t)
//    for (tag_directive = document.tag_directives.start
//    tag_copy *yaml_char_t = NULL
//    if (!anchor_copy)
//            assert(tag_directive.handle)
"//
//static int"
//                            // Valid tag directives are expected.
//            octet = pointer[k];
"//        start_implicit int, end_implicit int)"
//            value.handle = NULL
// Create SEQUENCE-START.
"//
//YAML_DECLARE(yaml_node_t *)"
"//    STACK_DEL(&context, document.nodes)"
"//    } items = { NULL, NULL, NULL }"
// String read handler.
// * Create a document object.
"//
//YAML_DECLARE(int)"
//            tag_directive != document.tag_directives.end
"//    } tag_directives_copy = { NULL, NULL, NULL }"
// Set the output encoding.
//            value.handle = yaml_strdup(tag_directive.handle)
"//
//    if (!yaml_check_utf8(value, length)) goto error"
"//        tag_directives_end *yaml_tag_directive_t,"
"//        tag_directives_start *yaml_tag_directive_t,"
// Check if we can move the queue at the beginning of the buffer.
//                (octet & 0xF0) == 0xE0 ? octet & 0x0F :
// Create a new emitter object.
"//
//    context.error = YAML_NO_ERROR // Eliminate a compiler warning."
"//    memcpy(value_copy, value, length)"
// Set a string output.
"//
//    if (!tag) {"
// Set the indentation increment.
//                goto error
//        version_directive_copy.minor = version_directive.minor
// Set a file output.
"//
//    assert(document) // Non-NULL document is required."
//        top *yaml_node_t
"//                document.nodes.start[sequence-1].data.sequence.items, item))"
//    yaml_free(document.tag_directives.start)
//        yaml_free(value.prefix)
//    }
//        case YAML_TAG_DIRECTIVE_TOKEN:
// * Check 'reader.c' for more details on UTF-8 encoding.
//        value = (octet & 0x80) == 0x00 ? octet & 0x7F :
"//
//    return 1"
// *
"//
//    pair.key = key"
// Set a file input.
//                            // Valid value id is required.
//        top *yaml_node_item_t
//            && document.nodes.start + mapping <= document.nodes.top)
// * Destroy a token object.
"//
//    switch (token.type)"
// Create STREAM-END.
"//
///**"
"//
//    return 0"
//        switch (node.type) {
"//
//    while (pointer < end) {"
"//    } pairs = { NULL, NULL, NULL }"
"//
//    if (document.nodes.top != document.nodes.start) {"
// * Append a pair of a key and a value to a mapping node.
//        yaml_free(node.tag)
//                            // A sequence node is required.
//    assert(anchor) // Non-NULL anchor is expected.
"//        version_directive *yaml_version_directive_t,"
//                break
//        unsigned char octet;
//            yaml_free(token.data.tag.handle);
//                assert(0) // Should not happen.
"//
//        pointer += width;"
"//            if (!yaml_check_utf8(tag_directive.prefix,"
"//
//        default:"
//            case YAML_SCALAR_NODE:
"//
//    if (length < 0) {"
//            (width == 3 && value >= 0x800) ||
"//    mark yaml_mark_t = { 0, 0, 0 }"
//    {
//        if (pointer+width > end) return 0;
"//
//    SEQUENCE_NODE_INIT(node, tag_copy, items.start, items.end,"
"//
//        octet = pointer[0];"
// Set if unescaped non-ASCII characters are allowed.
// Create SCALAR.
"//                document.nodes.start[mapping-1].data.mapping.pairs, pair))"
// Create DOCUMENT-START.
//    assert((tag_directives_start && tag_directives_end) ||
"//    STACK_DEL(&context, tag_directives_copy)"
// Create MAPPING-END.
//        return document.nodes.start + index - 1
"//    STACK_DEL(&context, pairs)"
"//
//    ALIAS_EVENT_INIT(*event, anchor_copy, mark, mark)"
"//
//    return 1;"
"//
//    assert(document) // Non-NULL document object is expected."
"//
//    anchor_copy = yaml_strdup(anchor)"
// Create SEQUENCE-END.
//            case YAML_MAPPING_NODE:
"//                STACK_DEL(&context, node.data.mapping.pairs)"
// * Add a mapping node to a document.
//        end *yaml_node_pair_t
"//
//    pair yaml_node_pair_t"
//            (tag_directives_start == tag_directives_end))
// * Add a scalar node to a document.
"//
//    if (!STACK_INIT(&context, pairs, INITIAL_STACK_SIZE)) goto error"
// Set a string input.
//    value_copy = yaml_malloc(length+1)
//                        strlen((char *)tag_directive.handle)))
//    value_copy *yaml_char_t = NULL
//        top *yaml_node_pair_t
//    yaml_free(tag_copy)
//            tag_directive++) {
//    anchor_copy *yaml_char_t = NULL
"//    while (!STACK_EMPTY(&context, tag_directives_copy)) {"
// yaml_writer_write_handler uses emitter.output_writer to write the
//            if ((octet & 0xC0) != 0x80) return 0;
//        version_directive_copy.major = version_directive.major
//        for (tag_directive = tag_directives_start
"//                STACK_DEL(&context, node.data.sequence.items)"
//        error yaml_error_type_t
//        start *yaml_node_item_t
//    assert(document.nodes.start[mapping-1].type == YAML_MAPPING_NODE)
//        tag = (yaml_char_t *)YAML_DEFAULT_SCALAR_TAG
// Create a new parser object.
//        unsigned int width;
"//        sequence int, item int)"
// Create STREAM-START.
"//        tag *yaml_char_t, value *yaml_char_t, length int,"
//    pair.value = value
//    tag_copy = yaml_strdup(tag)
"//            style, mark, mark)"
// Destroy a parser object.
"//
//    memset(token, 0, sizeof(yaml_token_t));"
//        width = (octet & 0x80) == 0x00 ? 1 :
//                (octet & 0xF8) == 0xF0 ? 4 : 0;
// */
//            yaml_free(token.data.tag_directive.handle);
//    version_directive_copy *yaml_version_directive_t = NULL
//            value = (value << 6) + (octet & 0x3F);
"//
//    while (!STACK_EMPTY(&context, document.nodes)) {"
//        tag = (yaml_char_t *)YAML_DEFAULT_MAPPING_TAG
"//    } nodes = { NULL, NULL, NULL }"
//            (width == 2 && value >= 0x80) ||
//            (width == 4 && value >= 0x10000))) return 0;
//    yaml_free(value_copy)
// Set the canonical output style.
"//
//error:"
//        yaml_free(tag_directive.prefix)
//            yaml_free(token.data.scalar.value);
//    assert(sequence > 0
// Destroy an event object.
//            value.prefix = yaml_strdup(tag_directive.prefix)
//    yaml_char_t *pointer = start;
//                        strlen((char *)tag_directive.prefix)))
//    yaml_free(value.handle)
//            default:
// * Create ALIAS.
"//
//YAML_DECLARE(void)"
//        version_directive_copy = yaml_malloc(sizeof(yaml_version_directive_t))
//    if (!value_copy) goto error
//    tag_directive *yaml_tag_directive_t
"//
//    return document.nodes.top - document.nodes.start"
//        return 0
"//        if (!STACK_INIT(&context, tag_directives_copy, INITIAL_STACK_SIZE))"
//            && document.nodes.start + sequence <= document.nodes.top)
"//
//        case YAML_SCALAR_TOKEN:"
//                (octet & 0xE0) == 0xC0 ? 2 :
//            value.prefix = NULL
//    return NULL
//            case YAML_SEQUENCE_NODE:
"//            tag_directives_copy.start, tag_directives_copy.top,"
//        }
//        end *yaml_node_t
// Set the source encoding.
"//
//    if (!STACK_INIT(&context, nodes, INITIAL_STACK_SIZE)) goto error"
//            if (!value.handle || !value.prefix) goto error
//        end *yaml_node_item_t
//            yaml_free(token.data.anchor.value);
"//
//    if (!yaml_check_utf8(anchor, strlen((char *)anchor))) return 0"
// Create DOCUMENT-END.
// * Check if a string is a valid UTF-8 sequence.
//    yaml_free(version_directive_copy)
//            yaml_free(token.data.alias.value);
//            yaml_free(token.data.tag_directive.prefix);
//    assert(value) // Non-NULL value is expected.
//        size_t k;
//        tag = (yaml_char_t *)YAML_DEFAULT_SEQUENCE_TAG
//                            // Valid key id is required.
//        unsigned int value;
//            yaml_free(token.data.tag.suffix);
//    node yaml_node_t
//                            // Valid mapping id is required.
//    struct {
//                            // Valid sequence id is required.
// * Add a sequence node to a document.
// Create MAPPING-START.
//        top *yaml_tag_directive_t
//        end *yaml_tag_directive_t
// Reader read handler.
"//        node yaml_node_t = POP(&context, document.nodes)"
"//    STACK_DEL(&context, items)"
//        start *yaml_tag_directive_t
// * Get the root object.
"//
///*"
//        yaml_free(value.handle)
//        return document.nodes.start
"//
//    assert(event) // Non-NULL event object is expected."
"//
//    if (index > 0 && document.nodes.start + index <= document.nodes.top) {"
//    yaml_free(value.prefix)
//    assert(mapping > 0
//        if (!version_directive_copy) goto error
"//
//    yaml_free(document.version_directive)"
//                (octet & 0xF8) == 0xF0 ? octet & 0x07 : 0;
//    if (!tag_copy) goto error
//                (octet & 0xF0) == 0xE0 ? 3 :
//        yaml_free(tag_directive.handle)
"//        tag *yaml_char_t, style yaml_sequence_style_t)"
"//
//    MAPPING_NODE_INIT(node, tag_copy, pairs.start, pairs.end,"
"//    value yaml_tag_directive_t = { NULL, NULL }"
"//        value yaml_tag_directive_t = POP(&context, tag_directives_copy)"
//                yaml_free(node.data.scalar.value)
//    assert(value > 0 && document.nodes.start + value <= document.nodes.top)
//        if (!width) return 0;
//    } context
//    assert(document) // Non-NULL document object is expected.
"//
//    DOCUMENT_INIT(*document, nodes.start, nodes.end, version_directive_copy,"
"//
//        case YAML_ALIAS_TOKEN:"
//        tag_directive *yaml_tag_directive_t
//        length = strlen((char *)value)
// * Destroy a document object.
"//    STACK_DEL(&context, nodes)"
//    value_copy[length] = '\0'
//                (octet & 0xE0) == 0xC0 ? octet & 0x1F :
//                tag_directive != tag_directives_end; tag_directive ++) {
// emitted text.
//    assert(item > 0 && document.nodes.start + item <= document.nodes.top)
//            assert(tag_directive.prefix)
//        for (k = 1; k < width; k ++) {
"//            start_implicit, end_implicit, mark, mark)"
"//    if (!PUSH(&context, document.nodes, node)) goto error"
"//
//    if (version_directive) {"
"//
//    if (!PUSH(&context,"
"//
//        case YAML_TAG_TOKEN:"
//                            // A mapping node is required.
//            goto error
// * Get a document node.
// Set the preferred line width.
// * Append an item to a sequence node.
// String write handler.
"//        mapping int, key int, value int)"
// This will internally delete the e.event value.
// Fast path.
// emitted.
"// structures containing json.Number, which is a string under the hood. The"
"// Issue #352: When formatting, use the precision of the underlying value"
// timestamps.
"//
// The base 60 float notation in YAML 1.1 is a terrible idea and is unsupported"
"// tag when encoded unquoted. If it doesn't,"
"// is bogus. In practice parsers do not enforce the ""\.[0-9_]*"" suffix."
// fallback case - no number could be obtained
"// Repeating the interface here avoids a dependency on encoding/json, and also"
"// Although time.Time implements TextMarshaler,"
// purposes because YAML has special support for
// isBase60 returns whether s is in base 60 notation as defined in YAML 1.1.
// In this case the json.Number is a valid int64
"// supports other libraries like jsoniter, which use a similar datatype with"
// Check to see if it would resolve to a specific
// the time being for compatibility with other parsers.
// and encode it as base64.
// we don't want to treat it as a string for YAML
// the same interface. Detecting this interface is useful when dealing with
// jsonNumber is the interface of the encoding/json.Number datatype.
// if they explicitly specify a tag and a string containing
// there's no need to quote it.
"// From http://yaml.org/type/float.html, except the regular expression there"
"// order, when encoding this type."
// doneInit holds whether the initial stream_start_event has been
// In this case the json.Number is a valid float64
// Note: it's possible for user code to emit invalid YAML
// text that's incompatible with that tag.
"// in YAML 1.2 and by this package, but these should be marshalled quoted for"
// It can't be encoded directly as YAML so use a binary tag
// Do the full match.
"// encoder should prefer the use of Int64(), Float64() and string(), in that"
// Create a token and append it to the queue.
"//
	if parser.simple_key_allowed {"
// Consume the value.
// Add the BLOCK-SEQUENCE-START token if needed.
// #xA0
"//
// For scanning block collections, the following tokens are used (note that we"
//       ^^^
// Eat whitespaces and comments until we reach the next token.
"// If we don't determine the token type so far, it is an error."
"// indicators '?' and ':', which are used for denoting mapping keys and values,"
// Advance the pointer.
"// the current column is greater than the indentation level.  In this case,"
"//      TAG-DIRECTIVE(""!yaml"",""tag:yaml.org,2002:"")"
//      ---
"//          SCALAR(""key 2"",plain)"
"//      VERSION-DIRECTIVE(1,1)"
// A simple key is required at the current position if the scanner is in
// Scan the value of VERSION-DIRECTIVE.
// Consume the current line.
"// First, try to scan a handle."
// [Go] Convert this into more reasonable logic.
// Consume the major version number.
// Eat the following indentation spaces and line breaks.
"//
// The tokens FLOW-SEQUENCE-START, FLOW-SEQUENCE-END, FLOW-MAPPING-START, and"
// Eat whitespaces and comments to the end of the line.
"//
//          - item 1"
//            - item 3.2
// Erase the token object.
//          BLOCK-MAPPING-START
// the block context and the current column coincides with the indentation
"//          SCALAR(""item 3.2"",plain)"
// Scan the version number of VERSION-DIRECTIVE.
// PS (#x2029)
// Do we need to fold line breaks?
// Reset any potential simple key on the current flow level.
//            key 1: value 1
// Create the FLOW-ENTRY token and append it to the queue.
// Check that the indentation is greater than 0.
// indentation level.
// Scan indentation spaces and line breaks for a block scalar.  Determine the
"//
//      2. An explicit document:"
// Repeat while the next character is digit.
// It is a right double quote.
// Produce the FLOW-ENTRY token.
//      %YAML    1.1    # a comment \n
// Is it the flow entry indicator?
// Is it an anchor?
// A simple key may follow a block scalar.
"//
// Example:"
// Scan the leading line breaks and determine the indentation level if needed.
//          - key 1: value 1
// CR LF . LF
//          ? a complex key
// repeat KEY and VALUE here):
// are represented by the KEY and VALUE tokens.
"//
//          a simple key: a value   # The KEY token is produced here."
// Expect a whitespace or line break.
// Determine the indentation level if needed.
//      DOCUMENT-START
"//
// A simple key is a key which is not denoted by the '?' indicator.  Note that"
// Check for a document indicator.
"//
// The tokens BLOCK-ENTRY, KEY, and VALUE are used to represent the indicators"
// NEL (#x85)
// append or insert the specified token into the token queue.
"//          SCALAR(""value 1"",plain)"
// A special case: the '!' tag.  Set the handle to '' and the
// Loop through the indentation levels in the stack.
"//
//          &A [ *A ]"
// Is it a trailing whitespace?
// Is it a double-quoted scalar?
// Scan a quoted scalar.
// Check if the trailing character is '!' and copy it.
"//      TAG-DIRECTIVE(handle,prefix)    # The '%TAG' directive."
// Is it the flow sequence end indicator?
// CR|LF . LF
// Scan the value of a TAG-DIRECTIVE token.
//          - item 2
//          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Set the handle to '!'.
// The tag has either the '!suffix' or the '!handle!suffix' form.
//          - ? complex key
"//
// Note that if a YAML stream contains an implicit document (without '---'"
//          BLOCK-ENTRY
// LS (#x2028)
//      KEY                             # '?' or nothing (simple keys).
//            - item 2
"//          SCALAR(""a simple key"",plain)"
// Ensure that the tokens queue contains at least one token which can be
// Have we found a non-empty line?
"//      SCALAR(""key"",plain)"
//          FLOW-ENTRY
// Push the current indentation level to the stack and set the new level
// Ensure that the buffer contains the required number of characters.
"//
// Here the Scanning step is explained and implemented.  We start with the list"
"// and '...' indicators), no DOCUMENT-START and DOCUMENT-END tokens will be"
"//
//      %YAML   1.1"
// increase that precedes a block collection (cf. the INDENT token in Python).
// Set the chomping method and eat the indicator.
//      FLOW-SEQUENCE-END
// Create the FLOW-SEQUENCE-START of FLOW-MAPPING-START token.
// Create the BLOCK-ENTRY token and append it to the queue.
// Remove obsolete potential simple keys.
// Consume the content of the quoted scalar.
"// If the key is required, it is an error."
"//          ANCHOR(""A"")"
// Produce the TAG token.
"//      SCALAR(""item 1"",plain)"
"// rest is quite straightforward.  The issues are ""block collection start"" and"
//            a folded
// Decode the required number of characters.
// Consume the directive name.
"//
//      STREAM-START(encoding)"
// Copy the '!' character.
// Scan a tag handle.
// Ensure that the tokens queue contains enough tokens.
// It is an escape sequence.
"//
//      STREAM-START(encoding)          # The stream start."
"//
//      2. A flow mapping:"
// Set the initial indentation.
"//
//      VERSION-DIRECTIVE(major,minor)"
"//      '%', '@', '`'."
"//
//      STREAM-START(utf-8)"
"// Return true on success, false on failure (reader error or memory error)."
//          DOCUMENT-END
// Allow the BOM mark to start a line.
//      BLOCK-MAPPING-START
"//
//      key:"
// Is is an escaped single quote.
//      KEY
// Create the STREAM-START token and append it to the queue.
// Check if the scanner is in the block context.
// Eat '%'.
// Check for a comment.
// We have found a token.
// It is an escaped line break.
// Scan the tag.
// Is it the flow mapping start indicator?
// Increase the flow level.
"//
//          ---"
// Check for an indentation indicator.
//          --- a plain scalar
"//
//          'a scalar'"
"//          SCALAR(""a scalar"",single-quoted)"
// Copy all subsequent alphabetical and numerical characters.
"// LL(1) parser, as it is usually called)."
// Create the KEY token and insert it into the queue.
// Introduction
// Check the initial '!' character.
// sequence of parsing events.
// A simple key cannot follow a tag.
// Decode an URI-escape sequence corresponding to a single UTF-8 character.
// (cf. the DEDENT token in Python).  However YAML has some syntax pecularities
//            - item 3.1
//       ^^^^
// Fetch the next token from the queue.
"//
// Actually there are two issues of Scanning that might be called ""clever"", the"
// Check for a tab character messing the indentation.
//          BLOCK-SEQUENCE-START
// Append the token to the queue.
// It wasn't a handle after all.  Scan the rest of the tag.
// Scan a prefix.
// STREAM-START token.
//      FLOW-SEQUENCE-START             # '['
// Force new line.
// We have started.
// produced tokens.
"//
// Now, tokens:"
"//
// The following examples show flow collections:"
// A simple key is allowed at the beginning of the stream.
"// used to describe aliases, anchors, tag, and scalars:"
// NEL . LF
// flow collections:
// We are at the beginning of a non-empty line.
//          -
// Is it a TAG directive?
//           ^^^^^^
// Check if we are allowed to start a new entry.
"// In the block context, we may need to add the BLOCK-MAPPING-START token."
// An anchor or an alias could be a simple key.
// Scan the character value.
"// mapping.  In this case, the token BLOCK-SEQUENCE-START is not produced:"
// Copy a character to a string buffer and advance pointers.
// Reset the indentation level.
//          FLOW-SEQUENCE-END
"//
//      2. A tagged scalar:"
// Remove a potential simple key at the current flow level.
// Create a token.
// Scan the TAG directive value.
// Check if we just started scanning.  Fetch STREAM-START then.
// Check if we are allowed to start a complex value.
"// [Go] This was inlined: !cache(A, B) -> unread < B && !update(A, B)"
// Create the DOCUMENT-START or DOCUMENT-END token.
// Produce the VALUE token.
// Produce the FLOW-SEQUENCE-END or FLOW-MAPPING-END token.
// Check that there are no document indicators at the beginning of the line.
// Check for an blank character after the name.
//          --- |-
// The dispatcher for token fetchers.
"//
// The tokens BLOCK-SEQUENCE-START and BLOCK-MAPPING-START denote indentation"
// Copy the character.
//      - item 1    # BLOCK-SEQUENCE-START is NOT produced here.
// Do we need to join the lines by space?
// Initialize the simple key stack.
//          : - item 1
// Check if the tag is in the canonical form.
//      DOCUMENT-END
"//
//      2. Block mappings:"
"//      %TAG    !yaml!  tag:yaml.org,2002:  \n"
//      FLOW-MAPPING-END
// Check for a potential simple key for each flow level.
// Pop indentation levels from the indents stack until the current level
"//  - in the block context, but not at the beginning of the line or"
"// In the block context, extra checks are required."
"// BLOCK-MAPPING-START, and BLOCK-END are emitted by the Scanner:"
"// FLOW-MAPPING-END represent the indicators '[', ']', '{', and '}'"
// Eat '!<'
// No simple keys after the indicators ']' and '}'.
// Create the ALIAS or ANCHOR token and append it to the queue.
// indentation level if needed.
// line.
//      BLOCK-SEQUENCE-END              # '}'
//      VALUE
"// Produce the SCALAR(...,literal) or SCALAR(...,folded) tokens."
// produced.
// Consume a space or a tab character.
"//
//      1. A recursive sequence:"
"// is a straightforward implementation of a recursive-descendant parser (or,"
// Produce the ALIAS or ANCHOR token.
// It is a non-escaped non-blank character.
"//
//      DOCUMENT-START"
// Eat the indentation spaces and line breaks.
"//          SCALAR(""complex key"")"
// Unknown directive.
// Is it an alias?
// Check if it is a first line break.
"//          SCALAR(""item 2"",plain)"
"//          SCALAR(""a plain scalar"",plain)"
// Get the indentation level and eat the indicator.
"//          --- ""a double-quoted scalar"""
// Fetch the next token.
"//
//      FLOW-SEQUENCE-START"
"//      TAG(handle,suffix)"
// The set of characters that may appear in URI is as follows:
// Ensure that the buffer is initialized.
"//
// The Scanner transforms the input stream into a sequence of tokens, while the"
// Check indentation level.
"//          SCALAR(""a sequence"",plain)"
// Check if the number was present.
"//
func yaml_parser_scan_tag_directive_value(parser *yaml_parser_t, start_mark yaml_mark_t, handle, prefix *[]byte) bool {"
"// If it is the leading octet, determine the length of the UTF-8 sequence."
// Is it the flow sequence start indicator?
//          --- 'a single-quoted scalar'
"//
// We have already introduced the SCALAR token above.  The following tokens are"
"//          SCALAR(""a complex key"",plain)"
"//
//      1. A flow sequence:"
// Check if the trailing octet is correct.
"//
	//      '-', '?', ':', ',', '[', ']', '{', '}',"
// Check if the name is empty.
//      BLOCK-SEQUENCE-START            # '{'
// Check for EOF.
//          FLOW-MAPPING-START
"//
//      ALIAS(anchor)"
"// Produce the SCALAR(...,plain) token."
// Produce the FLOW-SEQUENCE-START or FLOW-MAPPING-START token.
//  - in the flow context
// Consume the token.
// Scan a plain scalar.
// Eat whitespaces.
//          STREAM-END
// needed.
"//
func yaml_parser_scan_directive_name(parser *yaml_parser_t, start_mark yaml_mark_t, name *[]byte) bool {"
// Is it a plain scalar?
// Check for indicators that may end a plain scalar.
// Consume blank characters.
// Simple keys are allowed after '-'.
// The token BLOCK-END denote indentation decrease that ends a block collection
"// In the block context, a new line may start a simple key."
// Check if we really need to fetch more tokens.
"//
//          --- # Implicit empty plain scalars do not produce tokens."
"//      %TAG    !yaml!  tag:yaml.org,2002:"
"//
//      1. Block sequences:"
//          'a scalar'
"//
//          [item 1, item 2, item 3]"
"//
	// if it is followed by a non-space character."
//      DOCUMENT-START                  # '---'
// Expect a whitespace.
// Check the indentation level against the current column.
// Is it a leading whitespace?
// Add the BLOCK-MAPPING-START token if needed.
"//          SCALAR(""a single-quoted scalar"",single-quoted)"
// The specification requires that a simple key
// Create a token and insert it into the queue.
"//
// Note that the VERSION-DIRECTIVE and TAG-DIRECTIVE tokens occupy a whole"
"//
		//  - is limited to a single line,"
// Get the next token.
"//
	// In the block context (and, for the '-' indicator, in the flow context"
"//          SCALAR(""a value"",plain)"
//      %YAML   1.1     # a comment \n
// Check the escape character.
// Copy a line break character to a string buffer and advance pointers.
"// too), it may also start with the characters"
//      BLOCK-END                       # Indentation decrease.
//      - item 2
// Scan a tag.
// Check if we need to fold the leading line break.
// block collection may start at the current line.  The following examples
//          : another value
// Check the character which ends the tag.
// Is it a directive?
//          BLOCK-END
//      BLOCK-END
//      '%'.
// We are finished.
//          FLOW-MAPPING-END
"// While we need more tokens to fetch, do it."
// Eat whitespaces and comments until the next token is found.
// illustrate this case:
// Create the VALUE token and append it to the queue.
// Scan a block scalar.
"//
//      1. Collections in a sequence:"
// A simple key cannot follow another simple key.
// level.
// Set the scanner error and return false.
// Create a TAG-DIRECTIVE token.
"//
	// If the current position may start a simple key, save it."
"//
	// A plain scalar may start with any non-blank characters except"
// Push the current indentation level to the stack and set the new
// Consume an arbitrary escape code.
// Scan the additional block scalar indicators.
"//          SCALAR(""item 3.1"",plain)"
"//          SCALAR(""item 1"",plain)"
// It is a right single quote.
// Tabs are allowed:
// Set the indentation level if it was specified.
"// Simple keys are allowed after ','."
// Remove any potential simple keys.
// end of the stream:
"//      SCALAR(value,style)"
//      STREAM-END
"//      '#', '&', '*', '!', '|', '>', '\'', '\""',"
//      %TAG    !   !foo
// Is it the end?
"//
//      2. Collections in a mapping:"
"//          SCALAR(""3.14"",double-quoted)"
//            key 2: value 2
// Is it the document start indicator?
"//              a simple key: a value,  # Note that the KEY token is produced."
//      BLOCK-ENTRY                     # '-'
"// directive, it's an error.  If it's a tag token, it must be a part of URI."
"//  after '-', '?', or ':' (complex value)."
// No tokens after STREAM-END or error.
"//      SCALAR(value,style)             # A scalar."
"//          SCALAR(""a mapping"",plain)"
// Check the value and write the character.
"//
	// The last rule is more restrictive than the specification requires."
// Produce a VERSION-DIRECTIVE or TAG-DIRECTIVE token.
// Eat the right quote.
// Create the TAG token and append it to the queue.
// Note that we change the 'simple_key_allowed' flag.
"//
// The next two tokens are responsible for tags:"
"//
// The following examples show how the tokens BLOCK-SEQUENCE-START,"
// Is it the value indicator?
"//          SCALAR(""a folded scalar"",folded)"
"//
	//      '0'-'9', 'A'-'Z', 'a'-'z', '_', '-', ';', '/', '?', ':', '@', '&',"
// Eat the rest of the line including any comments.
// Is it the document end indicator?
// of all the tokens produced by the Scanner together with short descriptions.
// A tag could be a simple key.
//      STREAM-END                      # The stream end.
//          'another scalar'
//      FLOW-MAPPING-START
// Check if we are at the end of the scalar.
"//
// Now it's time to review collection-related tokens. We will start with"
//      BLOCK-SEQUENCE-START            # Indentation increase denoting a block
// Check if the potential simple key to be removed is required.
//      ANCHOR(anchor)
//          a mapping:
"// ""simple keys"".  Both issues are explained below in details."
// Check if we are at the end of the line.
// Scan the suffix now.
"//          SCALAR(""key 1"",plain)"
//          ? a mapping
"//
//          {"
// Scan a handle.
"//
//      1. An implicit document:"
// parser transform the sequence of tokens produced by the Scanner into a
"//          SCALAR(""another scalar"",single-quoted)"
// Eat a comment until a line break.
"// In the flow context, do nothing."
//      FLOW-SEQUENCE-END               # ']'
// Advance the buffer pointer.
// Chomp the tail.
// Produce the DOCUMENT-START or DOCUMENT-END token.
"//      TAG-DIRECTIVE(handle,prefix)"
"//
//          !!float ""3.14""  # A good approximation."
// A simple key cannot follow an anchor or an alias.
//                ^
// Consume the content of the plain scalar.
// Check if a simple key may start at the current position and add it if
// Eat the left quote.
// Check if it is a URI-escape sequence.
// cannot contain simple keys anymore.
//          : key 1: value 1
"//
	//      '-', '?', ':'"
//            a literal scalar
// Create the YAML-DIRECTIVE or TAG-DIRECTIVE token.
// Get the octet.
// is able to point to the context.
"//          SCALAR(""a double-quoted scalar"",double-quoted)"
"//
//      3. Various scalar styles:"
// Check if we need to join whitespaces and breaks.
// Scan the directive name.
"//      FLOW-ENTRY                      # ','"
"//          SCALAR(""another value"",plain)"
// that makes detections of these tokens more complex.
// returned to the Parser.
"// Do the same as above, but in the opposite order."
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
"//
// YAML does not always require to start a new block collection from a new"
// Produce the BLOCK-ENTRY token.
"//          SCALAR(""yet another scalar"",single-quoted)"
// Reset any potential simple keys on the current flow level.
// suffix to '!'.
// Initialize the scanner and produce the STREAM-START token.
"//
// The following series of examples illustrate the usage of these tokens:"
"// It is an error for the '-' indicator to occur in the flow context,"
//          FLOW-SEQUENCE-START
// Is it the flow mapping end indicator?
//      ANCHOR(anchor)                  # '&anchor'
// A plain scalar could be a simple key.
// Produce the KEY token.
//          VALUE
// Keep the handle as ''
// Create the SCALAR token and append it to the queue.
//          'yet another scalar'
"// If it is a line break, eat it."
// Simple keys after ':' are allowed in the block context.
// Remove the simple key.
// Join the whitespaces or fold line breaks.
"//
//      BLOCK-SEQUENCE-START"
// [Go] Is this necessary?
// the Scanner still produce the KEY token whenever it encounters a simple key.
"//
// The following notes assume that you are familiar with the YAML specification"
// Append the remaining line breaks.
//      BLOCK-MAPPING-START             # sequence or a block mapping.
"// Produce the SCALAR(...,single-quoted) or SCALAR(...,double-quoted) tokens."
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Check if we are allowed to start a new key (not nessesary simple).
"// In the block context, additional checks are required."
// Create the FLOW-SEQUENCE-END of FLOW-MAPPING-END token.
// Check if any potential simple key may occupy the head position.
"//
//          - - item 1"
"//
// YAML also permits non-indented sequences if they are included into a block"
"// Check if it is, indeed, handle."
"//
// The document start and end indicators are represented by:"
"//          SCALAR(""complex value"")"
//          }
// Is it the block entry indicator?
//      VALUE                           # ':'
// Is it a tag?
// A simple key may follow the indicators '[' and '{'.
// but we let the Parser detect and report about it because the Parser
// The ':' indicator follows a complex key.
// ************
//      ALIAS(anchor)                   # '*anchor'
"// line.  If the current line contains only '-', '?', and ':' indicators, a new"
//  - is shorter than 1024 characters.
"//      SCALAR(""item 2"",plain)"
"//      TAG(handle,suffix)              # '!handle!suffix'"
// Queue is empty.
"//
	// Note that we don't copy the leading '!' character."
//          --- >-
// The indicators '[' and '{' may start a simple key.
// Is it a folded scalar?
// Eat the indentation spaces.
// LS|PS . LS|PS
"//          SCALAR(""value 2"",plain)"
// Ensure that the buffer contains at least 4 characters.  4 is the length
// Scan the VERSION directive value.
// Consume the minor version number.
// Check for a URI-escaped octet.
//            scalar
// Consume non-blank characters.
// Create a VERSION-DIRECTIVE token.
// [Go] Should really be returning breaks instead.
// Check for '>' and eat it.
// Remove the key from the stack.
// Create the KEY token and append it to the queue.
"//
// We pass the information about the input stream encoding with the"
//          ---
"//
// The following two tokens are ""virtual"" tokens denoting the beginning and the"
// Produce the STREAM-END token and shut down the scanner.
// Check for tab characters that abuse indentation.
//            : complex value
//          DOCUMENT-START
// Eat a line break.
// Reset the simple key on the next level.
"//
// The correspoding sequence of tokens:"
// Have we found a simple key?
"//          ALIAS(""A"")"
// Simple keys are allowed after '?' in the block context.
//          KEY
// Scan the block scalar content.
// of the longest indicators ('--- ' and '... ').
"//
func yaml_parser_scan_directive(parser *yaml_parser_t, token *yaml_token_t) bool {"
//              ^
"//
//      3. Several documents in a stream:"
"//
//          STREAM-START(utf-8)"
"//
//          ? a sequence"
"//          TAG(""!!"",""float"")"
// Is it the end of the stream?
// Eat the indicator '|' or '>'.
"//
//      Tokens:"
"//      TAG-DIRECTIVE(""!"",""!foo"")"
"//      VERSION-DIRECTIVE(major,minor)  # The '%YAML' directive."
// Reset simple keys.
// Eat the indicator character.
// Is it the key indicator?
"//
// In the following examples, we present whole documents together with the"
// Check for a chomping indicator.
// Is it a YAML directive?
// It's either the '!' tag or not really a tag handle.  If it's a %TAG
//            - item 1
// A simple key cannot follow a flow scalar.
"//
// Tokens:"
// Create the STREAM-END token and append it to the queue.
"// (http://yaml.org/spec/1.2/spec.html).  We mostly follow it, although in"
"//
// Scope:"
//          ...
// Pop the indentation level.
// Eat '.'.
"//          SCALAR(""item 3"",plain)"
// Is it a single-quoted scalar?
// Consume the tag value.
"// '-', '?', and ':' correspondingly."
// Increase the flow level and resize the simple key list if needed.
// Copy the head if needed.
// [Go] Make this logic more reasonable.
"//
// The process of transforming a YAML stream into a sequence of events is"
// Consume the line break.
// divided on two steps: Scanning and Parsing.
// Check the list of potential simple keys and remove the positions that
"//          SCALAR(""a literal scalar"",literal)"
// Copy the octet and move the pointers.
//      DOCUMENT-END                    # '...'
//      FLOW-ENTRY
// some cases we are less restrictive that it requires.
//      BLOCK-ENTRY
"//      '=', '+', '$', ',', '.', '!', '~', '*', '\'', '(', ')', '[', ']',"
"// becomes less or equal to the column.  For each indentation level, append"
//          a sequence:
"//
// The Scanner is rather clever and complicated. The Parser, on the contrary,"
// Scan a YAML-DIRECTIVE or TAG-DIRECTIVE token.
// Until the next token is not found.
// Is it a literal scalar?
// Check if the number is too long.
"// correspondingly.  FLOW-ENTRY represent the ',' indicator.  Finally the"
"//              ? a complex key: another value,"
// the BLOCK-END token.
// Decrease the flow level.
// Erase the event object.
"//
//                          (VALUE block_node_or_indentless_sequence?)?)*"
// Parse the productions:
//                          ((KEY block_node_or_indentless_sequence?)?
//                                      *** *
//                            *** *
// [Go] Shouldn't this be end_mark?
// because there was no way to track ownership of the data.
//                          *****
//                          BLOCK-END
// properties           ::= TAG ANCHOR? | ANCHOR TAG?
// indentless_sequence  ::= (BLOCK-ENTRY block_node?)+
"//
//"
// block_node           ::= ALIAS
//                          (flow_sequence_entry FLOW-ENTRY)*
// flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
// Parse directives.
// flow_node            ::= ALIAS
//                          (VALUE block_node_or_indentless_sequence?)?)*
//                          *           *** *
//              ************
// implicit_document    ::= block_node DOCUMENT-END*
//                    ********************  *********** *             *********
"//
func yaml_parser_parse_block_mapping_key(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {"
// flow_mapping         ::= FLOW-MAPPING-START
//                          FLOW-MAPPING-END
// Parse the stream end.
// flow_collection      ::= flow_sequence | flow_mapping
//                           *********** *
//                          | properties block_content?
//                          | properties (block_content | indentless_block_sequence)?
// Get the next event.
// flow_content         ::= flow_collection | SCALAR
// State dispatcher.
//                          *************************
"//
func yaml_parser_parse_document_end(parser *yaml_parser_t, event *yaml_event_t) bool {"
//                          ******************
// [Go] I suspect the copy is unnecessary. This was likely done
// Peek the next token in the token queue.
// Append a tag directive to the directives stack.
// block_content        ::= block_collection | flow_collection | SCALAR
// Generate an empty scalar event.
//                          ****************
//                            *
//                          *********
// Remove the next token from the queue (must be called after peek_token).
//                                                      ***** *
//                          *****************
// Empty
// flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
"//
// Parse the productions:"
//                                                    ***********
"//
func yaml_parser_parse_flow_sequence_entry_mapping_value(parser *yaml_parser_t, event *yaml_event_t) bool {"
// explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
//                          *******************
//                           *                   **********
//                          | properties flow_content?
"//
func yaml_parser_parse_flow_sequence_entry_mapping_key(parser *yaml_parser_t, event *yaml_event_t) bool {"
// Parse an explicit document.
"//
//                          BLOCK-END"
// Parse extra document end indicators.
//                                                                      *
"//
func yaml_parser_parse_block_sequence_entry(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {"
// flow_sequence        ::= FLOW-SEQUENCE-START
// block_node_or_indentless_sequence    ::=
// block_mapping        ::= BLOCK-MAPPING_START
//                                   *                  ***** *
//                          | flow_content
//                            ********** *
//                          (flow_mapping_entry FLOW-ENTRY)*
"//
// stream               ::= STREAM-START implicit_document? explicit_document* STREAM-END"
// [Go] Shouldn't this be token.end_mark?
// No events after the end of the stream or error.
//                                            ******
//                           ***** *
// The parser implements the following grammar:
//                          | indentless_block_sequence
"//
func yaml_parser_parse_flow_sequence_entry_mapping_end(parser *yaml_parser_t, event *yaml_event_t) bool {"
//                          | block_content | indentless_block_sequence
//                          *
//                                                               ******
//                          ALIAS
// Parse the production:
// Parse an implicit document.
//                          | block_content
// block_sequence       ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END
//                                     *************
// stream   ::= STREAM-START implicit_document? explicit_document* STREAM-END
"//
func yaml_parser_parse_flow_mapping_value(parser *yaml_parser_t, event *yaml_event_t, empty bool) bool {"
//                          FLOW-SEQUENCE-END
"//
func yaml_parser_parse_flow_mapping_key(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {"
// [Go] Some of the events below can be merged as they differ only on style.
"//
func yaml_parser_parse_flow_sequence_entry(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {"
// block_collection     ::= block_sequence | block_mapping
// Generate the next event.
// Set parser error.
//                            **********  *
//                          flow_sequence_entry?
"//
func yaml_parser_parse_document_content(parser *yaml_parser_t, event *yaml_event_t) bool {"
//                           *                  **********
"//
//                          ((KEY block_node_or_indentless_sequence?)?"
//                          flow_mapping_entry?
// block_sequence ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END
// Step backwards as earlier nodes take precedence.
"//
// If n holds a null value, prepare returns before doing anything."
// expect consumes an event from the event stream and
"// unmarshalling was already done by UnmarshalYAML, and if so whether"
// TODO(v3) Drop this.
// Perhaps we can use the value as a TextUnmarshaler to
// Happens when attempting to decode an empty buffer.
// timestamp-like values into interface{} will continue to
// TODO this could actually be allowed in some circumstances.
// checks that it's of the expected type.
"// Parser, produces a node tree out of a libyaml event stream."
// set its value.
// see a string and not a time.Time.
// d.prepare initializes and dereferences pointers and calls UnmarshalYAML
// We let any value be unmarshaled into TextUnmarshaler.
// okay
// its types unmarshalled appropriately.
// TODO DOes this make sense? When is out a Ptr except when decoding a nil value?
// if a value is found to implement it.
// No type hints. Will have to use a generic sequence.
"// For an alias node, alias holds the resolved alias."
"// peek peeks at the next event in the event stream,"
// ----------------------------------------------------------------------------
"// We've resolved to exactly the type we want, so use that."
"// reasons we set it as a string, so that code that unmarshals"
"// That might be more lax than we'd like, but the"
"// It returns the initialized and dereferenced out value, whether"
// puts the results into p.event and returns the event type.
// TextUnmarshaler itself should bowl out any dubious values.
// It looks like a timestamp but for backward compatibility
"// Decoder, unmarshals a node into a provided value."
// Scanner errors don't iterate line before returning error
"//     yaml.Marshal(&T{F: 1}} // Returns ""a: 1\nb: 0\n"""
// lowercased as the default key. Custom keys may be defined via the
"//
// If an error is returned by MarshalYAML, the marshaling procedure stops"
// Private field
// the provided data. The out parameter must not be nil.
// missed values.
// The Encoder should be closed after use to flush all data
"//
func Unmarshal(in []byte, out interface{}) (err error) {"
// UnmarshalStrict is like Unmarshal except that any fields that are found
//                  case the field will be included if that method returns true.
// is time.Time.
// Decode reads the next YAML-encoded value from its input
// The code in this section was copied from mgo/bson.
// used to tweak the marshalling process (see Marshal).
// following comma-separated options are used to tweak the marshalling process.
// of the generated document will reflect the structure of the value itself.
"//
// In addition, if the key is ""-"", the field is ignored."
"// Id holds the unique field identifier, so we can cheaply"
"//
//     omitempty    Only include the field if it's not set to the zero"
"//                  method (see the IsZeroer interface type), in which"
// is marshaled in place of the original value implementing Marshaler.
//                  sequences and maps).
//                  value for the type or to empty slices or maps.
// values to YAML.
"// ""yaml"" name in the field tag: the content preceding the first comma"
// Inline holds the field index if the field is part of an inlined struct.
// unmarshaled partially.
"//
//     flow         Marshal using a flow style (useful for structs,"
// SetStrict sets whether strict decoding behaviour is enabled when
"//
// See the documentation for Marshal for details about the conversion of Go"
"//
// See the documentation for Unmarshal for details about the"
// IsZeroer is used to check whether an object is zero to
"//     yaml.Unmarshal([]byte(""a: 1\nb: 2""), &t)"
// function parameter more than once if necessary.
"// tag: the content preceding the first comma is used as the key, and the"
"//
func Marshal(in interface{}) (out []byte, err error) {"
"// types. When this error is returned, the value is still"
"//
// The type of the decoded values should be compatible with the respective"
// YAML value into a field or variable. It is safe to call the unmarshal
//                  Zero valued structs will be omitted if all their public
// Maintain a mapping of keys to structure field indexes
"//
// The decoder introduces its own buffering and may read"
"//                  fields are zero, unless they implement an IsZero"
"// in the data that do not have corresponding struct members, or mapping"
"//         F int `yaml:""a,omitempty""`"
"// upper case first letter), and are unmarshalled using the field name"
// the yaml package will initialize it if necessary for unmarshalling
"//
// For example:"
// --------------------------------------------------------------------------
// behavior when being marshaled into a YAML document. The returned value
//                  not conflict with the yaml keys of other struct fields.
"// first letter), and are marshalled using the field name lowercased as the"
// Conflicting names result in a runtime error.
"//
package yaml"
// NewEncoder returns a new encoder that writes to w.
"//
//     `(...) yaml:""[<key>][,<flag1>[,<flag2>]]"" (...)`"
// data from r beyond the YAML values requested.
"//
// The following flags are currently supported:"
"// keys that are duplicates, will result in"
// the YAML document cannot be properly decoded into the requested
"// values. If an internal pointer within a struct is not initialized,"
// determine whether it should be omitted when marshaling
"// default key. Custom keys may be defined via the ""yaml"" name in the field"
//     var t T
// supported tag options.
"// contains an ,inline map, or -1 if there's none."
"//
// Struct fields are only unmarshalled if they are exported (have an"
"//
//   https://github.com/go-yaml/yaml"
// The Unmarshaler interface may be implemented by types to customize their
// The order of keys is preserved when encoding and decoding.
// The Marshaler interface may be implemented by types to customize their
// NewDecoder returns a new decoder that reads from r.
//     }
"//
// See the documentation of Marshal for the format of tags and a list of"
// Encode writes the YAML encoding of v to the stream.
"// with a ""---"" document separator, but the first will not."
"//                  they were part of the outer struct. For maps, keys must"
"//
// Maps and pointers (to a struct, string, int, etc) are accepted as out"
// structInfo holds details for the serialization of fields of
// MapItem is an item in a MapSlice.
// values in out. If one or more values cannot be decoded due to a type
// An Encoder writes YAML values to an output stream.
// and returns with the provided error.
// and assigns decoded values into the out value.
// to w.
//         B int
// check for field duplicates without maintaining an extra map.
"// mismatches, decoding continues partially until the end of the YAML"
// and stores it in the value pointed to by v.
// conversion of YAML into a Go value.
// MapSlice encodes and decodes as a YAML map.
"// If multiple items are encoded to the stream, the"
// with the omitempty flag. One notable implementation
"// Maps and pointers (to struct, string, int, etc) are accepted as the in value."
// second and subsequent document will be preceded
// InlineMap is the number of the field in the struct that
// a given struct.
//                  causing all of its fields or keys to be processed as if
"//
// Struct fields are only marshalled if they are exported (have an upper case"
"//
// The field tag format accepted is:"
// method receives a function that may be called to unmarshal the original
// A Decorder reads and decodes YAML values from an input stream.
// Marshal serializes the value provided into a YAML document. The structure
"// decoding items in the data (see UnmarshalStrict). By default, decoding is not strict."
// Package yaml implements YAML support for the Go language.
"//
//     inline       Inline the field, which must be a struct or a map,"
"//
//     type T struct {"
// behavior when being unmarshaled from a YAML document. The UnmarshalYAML
// Close closes the encoder by writing any remaining data.
// an error.
// A TypeError is returned by Unmarshal when one or more fields in
"// It does not write a stream terminating string ""...""."
"//
// Source code and other details for the project are available at GitHub:"
"// content, and a *yaml.TypeError is returned with details for all"
// Unmarshal decodes the first document found within the in byte slice
"// is used as the key, and the following comma-separated options are"
"//     yaml.Marshal(&T{B: 2}) // Returns ""b: 2\n"""
"// RFC3339Nano with short date fields and lower-case ""t""."
// are purposefully unsupported here. They're still quoted on
// Any data is accepted as a !!str or !!binary.
// Timestamp formats are defined at http://yaml.org/type/timestamp.html
// http://yaml.org/type/timestamp.html instead of using time.Parse.
// from the set of examples.
// This is a subset of the formats allowed by the regular expression
// Only try values as a timestamp if the value is unquoted or there's an explicit
// In map
// TODO This can easily be made faster and produce less garbage.
"// Int, float, or timestamp."
// defined at http://yaml.org/type/timestamp.html.
// Digit
// date only
"// the way out for compatibility with other parser, though."
// !!timestamp tag.
"// Notable exception: time.Parse cannot handle: ""2001-12-14 21:59:43.10 -5"""
// Quick check: all date formats start with YYYY-.
"// Otherwise, the prefix is enough of a hint about what it might be."
// as appropriate for the resulting length.
// Handle things we can lookup in a map.
// parseTimestamp parses s as a timestamp string and
// TODO write code to check all the formats supported by
// encodeBase64 encodes s as base64 that is broken up into multiple lines
// RCF3339Nano with short date fields.
// We've already checked the map above.
// space separated with no time zone
// Sign
// returns the timestamp and reports whether it succeeded.
"// Not in the map, so maybe a normal float."
// Float (potentially in map)
"// Base 60 floats are a bad idea, were dropped in YAML 1.2, and"
// Copy a line break character from a string into buffer.
// Expect STREAM-START.
// State dispatcher.
// [Go] Do we actually need to copy this given garbage collection
// [Go]: Why 'z'? Couldn't be the end of the string as that's the loop condition.
// Check if the next events represent an empty mapping.
// Check if a %YAML directive is valid.
// Flush the buffer if needed.
//  - 3 events for MAPPING-START
// Expect SEQUENCE-START.
// Increase the indentation level.
// Put a character to the output buffer.
// Write a scalar.
// Check if the next node can be expressed as a simple key.
// [Go] Allocate these slices elsewhere.
// Expect MAPPING-START.
// Check if a tag is valid.
// Check if the event data is valid.
// Copy a character from a string into buffer.
// Expect a block key node.
// Check if the document content is an empty scalar.
// Write a whole string into buffer.
// Expect a block item node.
// Check if a scalar is valid.
// Expect a flow key node.
// [Go] Allocate the slice elsewhere.
// Append a directive to the directives stack.
// and the lack of deallocating destructors?
// Check if the next events represent an empty sequence.
// Check if a %TAG directive is valid.
//  - 2 events for SEQUENCE-START
// Expect the root node.
// Expect ALIAS.
// [Go] Huh?
// Write an anchor.
// Check if an anchor is valid.
// Put a line break to the output buffer.
"//
// We accumulate extra"
// Set an emitter error and return false.
// Write a tag.
// Emit an event.
"//
func yaml_emitter_need_more_events(emitter *yaml_emitter_t) bool {"
// Expect a block value node.
// Expect a flow value node.
// Write the BOM character.
// Check if we need to accumulate more events before emitting.
// Expect a flow item node.
// Determine an acceptable scalar style.
// Expect SCALAR.
// Expect a node.
//  - 1 event for DOCUMENT-START
// Expect DOCUMENT-START or STREAM-END.
// Expect DOCUMENT-END.
"//
				// where U is the character value, W1 is the high surrogate"
// Check if the raw buffer contains an incomplete character.
// Set the reader error and return 0.
// Update the raw buffer.
"//
// The length is supposed to be significantly less that the buffer size."
//  W2 = 110111xxxxxxxxxx
//  W1 = 110110yyyyyyyyyy
// given length in the buffer. Not doing that means every single
//   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
// The UTF-16 encoding is not as simple as one might
//      #x9 | #xA | #xD | [#x20-#x7E]               (8 bit)
// Return if the buffer contains enough characters.
// every single check that calls this function to make sure the buffer
//   0000 0000-0000 007F | 0xxxxxxx
"// for that to be the case, and there are tests "
// Fill the raw buffer if necessary.
// are prohibited as they are reserved for use with UTF-16
"// On EOF, put NUL into the buffer and return."
// Get the character.
// Get the next character.
// This happens here due to the EOF above breaking early.
"//
				// A surrogate pair consists of two pseudo-characters:"
// Check for a low surrogate area.
// Decode the raw buffer.
"// Open the whole buffer for writing, and cut it before returning."
// Determine the encoding.
// Determine the input encoding if it is not known yet.
// naively think.  Check RFC 2781
// Move the raw pointers.
//      low surrogate area (0xDC00-0xDFFF)
// [Go] ACTUALLY! Read the documentation of this function above.
//   --------------------+------------------------------------
"// If the EOF flag is set and the raw buffer is empty, do nothing."
// Decode the leading octet.
"//
				// Normally, two subsequent bytes describe a Unicode"
// Generate the value of the surrogate pair.
// Finally put the character into the buffer.
// (http://www.ietf.org/rfc/rfc2781.txt).
// Move the unread characters to the beginning of the buffer.
// character.  However a special technique (called a
// Return if the raw buffer is full.
// surrogate pair) is used for specifying character
// 0000 0800-0000 FFFF . 1110xxxx 10xxxxxx 10xxxxxx
// Fill the buffer until it has enough characters.
// 0000 0000-0000 007F . 0xxxxxxx
// check that calls this function to make sure the buffer has a
"//
				// The following table (taken from the RFC) is used for"
// Check for incomplete UTF-16 character.
// Determine the input stream encoding by checking the BOM symbol. If no BOM is
// Ensure that we had enough bytes in the raw buffer.
// Check for incomplete surrogate pair.
"// Return true on success, false on failure."
// The leading octet is invalid.
"// found, the UTF-8 encoding is assumed. Return 1 on success, 0 on failure."
// Check if the octet is valid.
// (http://www.ietf.org/rfc/rfc3629.txt) for more details.
"//
				//    Char. number range |        UTF-8 octet sequence"
"//
				// The following formulas are used for decoding"
// decoding.
//   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
"// The fact we need to do this is pretty awful, but the description above implies"
// has a given length is Go) panicking; or C) accessing invalid memory.
// surrogate pairs.
//      high surrogate area (0xD800-0xDBFF)
//   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
// Check the range of the value.
// Byte order marks.
// [Go] This function was changed to guarantee the requested length size at EOF.
"// This is just broken. To return true, we need to have the"
// Decode a UTF-8 character.  Check RFC 3629
// values larger than 0xFFFF.
// we need to have the given length in the buffer. Not doing that means
// Check the length of the sequence against the value.
// Check for unexpected low surrogate area.
//  U' = yyyyyyyyyyxxxxxxxxxx   (0 <= U' <= 0x0F FF FF)
//      | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD]    (16 bit)
// and encoding characters using surrogate pairs:
// Decode the next character.
// Determine the length of the UTF-8 sequence.
"//
				//  U  = U' + 0x10000   (0x01 00 00 <= U <= 0x10 FF FF)"
// given length is Go) panicking; or C) accessing invalid memory.
// Check if the character is in the allowed range:
// Ensure that the buffer contains at least `length` characters.
// Call the read handler to fill the buffer.
// 0001 0000-0010 FFFF . 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
//      | [#x10000-#x10FFFF]                        (32 bit)
"// area, W2 is the low surrogate area."
//      (hexadecimal)    |              (binary)
"//
				// Additionally, the characters in the range 0xD800-0xDFFF"
// Return on EOF.
// Decode the octet.
// Check for a high surrogate area.
// Move the remaining bytes in the raw buffer to the beginning.
// 0000 0080-0000 07FF . 110xxxxx 10xxxxxx
// Check and decode the trailing octets.
"// [Go] Read the documentation of this function above. To return true,"
// just return
"// KNN returns items nearest to farthest. The dist param is the ""box distance""."
// Bounds returns the bounding box of the entire R-tree
// Count returns the number of items in the R-tree.
"// resusable fields, these help performance of common mutable operations."
// Search searches the tree for items in the input rectangle
// RTree is an R-tree
// for reinsertion path
// precalculate infinity
// root node
// choose distribution with minimum overlap
"// Complexity returns the complexity of the R-tree. The higher the value, the"
// go down
// clear tree
// Remove removes an item from the R-tree.
// go right
// for bulk loading
// for remove function
// Traverse iterates over the entire R-tree and includes all nodes and items.
// adjust bboxes along the given tree path
// more complex the tree. The value of 1 is the lowest.
// Scan iterates over the entire R-tree
// New creates a new R-tree
"// item found, remove the item and condense tree upwards"
// otherwise choose distribution with minimum area
"// go through the path, removing empty nodes and updating bboxes"
// Insert inserts an item
// item is only nil when bulk loading a node
// sort the items on a different axis than the previous level.
// Load bulk load items into the R-tree.
// save as is if tree is empty
// swap trees if inserted one is bigger
// reached leaf level; return leaf
// last part
// prefill the items
// split root if trees have the same height
// following equations are defined in the paper describing OMT
// last split
// sort by the initial axis
// build the root node. it's split differently from the subtrees.
// insert the small tree into the large tree at appropriate level
// Iterate over each user in the val tree
"// The ""values"" tree will be sorted on the Values field."
// Should see the results
"// The ""keys"" tree will be sorted on the Keys field."
// Both vals are equal so we should fall though
// Iterate over each user in the key tree
// and let the key comparison take over.
// Insert each user into both trees
// Create some items.
// Create a tree for keys and a tree for values.
// the 'start' should be greater than 'stop'. Setting 'includeStart' to true
"//   the original, shared nodes (old b.cow)"
// hold one of either a or b in the tree).
// We use our special-case 'remove' call with typ=maxItem to pull the
"// We then simply redo our remove call, and the second time (regardless of"
// and set it into where we pulled the item from.
"// item from it while keeping it at minItems, then calls remove to actually"
"//     most likely not stored in contiguous blocks, resulting in a higher"
// Copyright 2014 Google Inc.
"//   * Since interfaces can point to values anywhere in memory, values are"
// Copy children
// the original performance characteristics of the original tree.
// clear to allow GC
// AscendGreaterOrEqual calls the iterator for every value in the tree within
//   b) right sibling has node to spare
// associated Ascend* function will immediately return.
// ReplaceOrInsert adds the given item to the tree.  If an item in the tree
//   a) left sibling has node to spare
// Int implements the Item interface for integers.
//   * Due to the overhead of storing values as interfaces (each
// first index children. index must be less than or equal to length.
"// it.  If no such item exists, returns nil."
// efficiency differences when compared to equivalent C++ template code that
"// llrb.LLRB where possible.  Unlike gollrb, though, we currently don't"
"// Get looks for the key item in the tree, returning it.  It returns nil if"
"// [first, pivot), until iterator returns false."
"//   * len(children) == 0, len(items) unconstrained"
// Used for testing/debugging purposes.
// NewFreeList creates a new free list.
//     memory use.
// Steal from left child
"// will force the iterator to include the first item when it equals 'start',"
// get finds the given key in the subtree and returns it.
"// removal, and iteration."
// stores values in arrays within the node:
"//
// This implementation is designed to be a drop-in replacement to gollrb.LLRB"
"//
// It has a flatter structure than an equivalent red-black or other binary tree,"
// It is not meant for persistent storage solutions.
"// insertAt inserts a value into the given index, pushing all subsequent values"
"// [first, last], until iterator returns false."
"// These issues don't tend to matter, though, when working with strings or other"
"// ""greaterThan"" or ""lessThan"" queries."
//   the new out.cow nodes
// implementation written about there.
"// already equals the given one, it is removed from the tree and returned."
"// [lessOrEqual, greaterThan), until iterator returns false."
// current node
"//
// Within this tree, each node contains a slice of items and a (possibly nil)"
// in sorted order.
"//
// Changing data while traversing a cursor may result in unexpected items to"
// you may not use this file except in compliance with the License.
"// Clone clones the btree, lazily.  Clone should not be called concurrently,"
"// maybeSplitChild checks if a child should be split, and if so splits it."
// DescendRange calls the iterator for every value in the tree within the range
"//
	// There is a user-defined ctx argument that is equal to the ctx value which"
// context equivalent to a node's write context is allowed to modify that node.
"//
// The internal tree structure of b is marked read-only and shared between t and"
// pointers and also distribute their values across the heap.
// New creates a new B-Tree with the given degree.
// we want second split node
//   A) node has enough values that it can spare one
// but the original tree (t) and the new tree (t2) can be used concurrently
// copyOnWriteContext pointers determine node ownership... a tree with a write
"//
	// This must provide a strict weak ordering."
// growChildAndRemove grows child 'i' to make sure it's possible to remove an
// first index items. index must be less than or equal to length.
// once the Clone call completes.
// Cursor returns a new cursor used to traverse over items in the tree.
// Seek moves the cursor to provided item and returns that item.
// support storing multiple equivalent values.
// First moves the cursor to the first item in the tree and returns that item.
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
// Len returns the number of items currently in the tree.
// steal from right child
"// be found/replaced by insert, it will be returned."
// size is the maximum size of the returned free list.
// back.
// DeleteMin removes the smallest item in the tree and returns it.
// node's context is equal to the context of the tree that requested the write.
// If the item does not exist then the next item is returned.
"//
// When doing any write operation, we maintain the invariant that the current"
"// If no such item exists, returns nil."
"// tree's context, that node is modifiable in place.  Children of that node may"
"// In both cases, we need to handle the two subcases:"
//   * len(children) == len(items) + 1
// max returns the last item in the subtree.
// remove it.
//     number of cache misses.
"// split splits the given node at the given index.  The current node shrinks,"
"// The item exists at index 'i', and the child we've selected can give us a"
// copy.
// should have no performance degredation.  Write operations for both t and t2
"//     value needs to be stored as the value itself, then 2 words for the"
//   1) item is in this node
"// copies due to the aforementioned copy-on-write logic, but should converge to"
// You may obtain a copy of the License at
// Two Btrees using the same freelist are safe for concurrent write access.
// Item represents a single object in the tree.
// min returns the first item in the subtree.
// index.
"//     interface pointing to that value and its type), resulting in higher"
"// predecessor, since if we've gotten here it's got > minItems items in it."
// Next moves the cursor to the next item and returns that item.
// index of the next child/item.
// be returned. You must reposition your cursor after mutating data.
// items stores items in a node.
// and 2-4 children).
// that we hit case A.
// limitations under the License.
"// the tree.  When this function returns false, iteration will stop and the"
"// it, and must create a new, writable copy (IE: it's a Clone)."
// and this function returns the item that existed at that index and a new node
// removes largest item in the subtree
//   http://google-opensource.blogspot.com/2013/01/c-containers-that-save-memory-and-time.html
"// the range [pivot, last], until iterator returns false."
"//
// Since the node we're currently visiting on any write has the requesting"
// Less tests whether the current item is less than the given argument.
// containing all items/children after it.
//   B) node doesn't have enough values
// toRemove details what item to remove in a node.remove call.
"//
// New(2), for example, will create a 2-3-4 tree (each node contains 1-3 items"
"// Delete removes an item equal to the passed in item from the tree, returning"
"//
// btree implements an in-memory B-Tree for use as an ordered data structure."
"// [greaterOrEqual, lessThan), until iterator returns false."
// no nodes in the subtree exceed maxItems items.  Should an equivalent item be
"// [last, first], until iterator returns false."
"//
// BTree stores Item instances in an ordered structure, allowing easy insertion,"
"//
// nil cannot be added to the tree (will panic)."
"// insert inserts an item into the subtree rooted at this node, making sure"
//   the new b.cow nodes
// pop removes and returns the last element in the list.
//   c) we must merge
"//
// Most documentation says we have to do two sets of special casing:"
"// For the latter, we have to check:"
// merge with right child
// FreeList.
// Cursor represents an iterator that can traverse over all items in the tree
// Returns whether or not a split occurred.
// is set at time of the btree contruction.
// whenever one of b's original nodes would have been modified.  Read operations
// unable to find that item.
"// BTree has its own FreeList, but multiple BTrees can share the same"
"// thus creating a ""greaterOrEqual"" or ""lessThanEqual"" rather than just a"
// will initially experience minor slow-downs caused by additional allocs and
"// not share context, but before we descend into them, we'll make a mutable"
// AscendRange calls the iterator for every value in the tree within the range
"// whether we're in case 1 or 2), we'll have enough items and can guarantee"
// find returns the index where the given item should be inserted into this
// Package btree implements in-memory B-Trees of arbitrary degree.
// DescendGreaterThan calls the iterator for every value in the tree within
// which in some cases yields better memory usage and/or performance.
"// We do this by, before we descend into any node, creating a copy with the"
"// slice of children.  For basic numeric values or raw structs, this can cause"
"//
// Unless required by applicable law or agreed to in writing, software"
// removes smallest item in the subtree
"// t2.  Writes to both t and t2 use copy-on-write logic, creating new nodes"
//	continue
// truncate truncates this instance at index so that it contains only the
"//
//     http://www.apache.org/licenses/LICENSE-2.0"
// node and that the child is big enough to remove from.
"//
// Licensed under the Apache License, Version 2.0 (the ""License"");"
"//
// When ascending, the 'start' should be less than 'stop' and when descending,"
// maxItems returns the max number of items to allow per node.
"// If a node doesn't have enough items, we make sure it does (using a,b,c)."
// FreeList represents a free list of btree nodes. By default each
"// Max returns the largest item in the tree, or nil if the tree is empty."
// See some discussion on the matter here:
// forward.
"// Final recursive call.  Once we're here, we know that the item isn't in this"
// Last moves the cursor to the last item in the tree and returns that item.
// Ascend calls the iterator for every value in the tree within the range
// Less returns true if int(a) < int(b).
//   2) item is in child
// DescendLessOrEqual calls the iterator for every value in the tree within the range
// node is an internal node in a tree.
// minItems returns the min number of items to allow per node (ignored for the
"// Otherwise, nil is returned."
// See the License for the specific language governing permissions and
// list.  'found' is true if the item already exists in the list at the given
// remove removes an item from the subtree rooted at this node.
// Has returns true if the given key is in the tree.
// ItemIterator allows callers of Ascend* to iterate in-order over portions of
"// goroutines, but Read operations are."
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
"// trees, (http://github.com/petar/gollrb), an excellent and probably the most"
"// To simplify our code here, we handle cases #1 and #2 the same:"
"// no change, we want first split node"
// Create two entirely new copy-on-write contexts.
"// the range (pivot, last], until iterator returns false."
// Descend calls the iterator for every value in the tree within the range
"// If !a.Less(b) && !b.Less(a), we treat this to mean a == b (i.e. we can only"
// removes the given item
// NewWithFreeList creates a new B-Tree that uses the given node free list.
// iterate provides a simple method for iterating over elements in the tree.
// predecessor of item i (the rightmost leaf of our immediate left child)
// AscendLessThan calls the iterator for every value in the tree within the range
"// Either we had enough items to begin with, or we've done some"
"// heap-allocated structures, since C++-equivalent structures also must store"
"// [pivot, first], until iterator returns false."
// root node).
// children stores child nodes in a node.
"// Note, though, that this project is in no way related to the C++ B-Tree"
// A tree whose write context does not match a node's is not allowed to modify
// stuff.
// DeleteMax removes the largest item in the tree and returns it.
"// Min returns the smallest item in the tree, or nil if the tree is empty."
"// Its functions, therefore, exactly mirror those of"
// widely used ordered tree implementation in the Go ecosystem currently.
// correct context if the contexts don't match.
"// If we get to here, we have children."
"// removeAt removes a value at a given index, pulling all subsequent values"
"//
// Write operations are not safe for concurrent mutation by multiple"
// BTree is an implementation of a B-Tree.
// This operation effectively creates three trees:
"//
// It must at all times maintain the invariant that either"
"// merging/stealing, because we've got enough now and we're ready to return"
// Prev moves the cursor to the previous item and returns that item.
// Output:
"// To specify that numbers should sort numerically (""2"" < ""12"")"
"// 4: {""name"":{""first"":""Alan"",""last"":""Cooper""},""age"":28}"
// Open the data.db file. It will be created if it doesn't exist.
// continue
"// 5: {""name"":{""first"":""Sam"",""last"":""Anderson""},""age"":51}"
"// 1: {""name"":{""first"":""Tom"",""last"":""Johnson""},""age"":38}"
// Open a file that does not persist to disk.
"// 6: {""name"":{""first"":""Melinda"",""last"":""Prichard""},""age"":44}"
"// 2: {""name"":{""first"":""Janet"",""last"":""Prichard""},""age"":47}"
// To sort case-insensitive in French.
// and use a comma to represent a decimal point.
"// 3: {""name"":{""first"":""Carol"",""last"":""Anderson""},""age"":52}"
// ErrIndexExists is returned when an index already exists in the database.
// turn off persistence for pure in-memory
// Close all files
// The IndexRect is a default function that can be used for the rect
// map to see if there isn't already an item that matches the
// lock/unlock.
// readLoad reads from the reader and loads commands into the database.
// Shrink will make the database file smaller by removing redundant
// transactions can set and delete keys.
"// not opened with Open("":memory:"")."
// copy the index meta information
// Less determines if a b-tree item is less than another. This is required
// We reached this far so all of the items have been written to a new tmp
// readers and a single writer. Bunt is ideal for projects that need
// Desc is a helper function that changes the order of an index.
// The opt params may be used for additional functionality such as forcing
// less comparison function
// Increment the number of flushes. The background syncing uses this.
// The expires b-tree formula
// write the entry to disk.
"// range [first, pivot), until iterator returns false."
"// [first, last], until iterator returns false."
// a required key pattern
// produce a list of expired items that need removing
"// execute a disk sync, if needed"
// The database is already in the process of shrinking.
// initialize with empty trees
"// the range [greaterOrEqual, lessThan), until iterator returns false."
// intialize new index
"// will be replaced with the new one, and return the previous item."
// b-tree/r-tree context for itself.
"// This value can be Never, EverySecond, or Always."
"// close on error, ignore close error"
// Config represents database configuration options. These
// same bounds function that was passed to the CreateSpatialIndex() function.
// The less function compares if string 'a' is less than string 'b'.
// wrap a rtree specific iterator around the user-defined iterator.
"// 'Delete' method reports ""not found"" for"
// dbItemOpts holds various meta information about an item.
// Multiple read-only transactions can be opened at the same time but there can
// were performed on the transaction such as Set() and Delete().
// Rollback closes the transaction and reverts all mutable operations that
// Remove it from the exipres tree.
// late usage panics and it provides a hint to the garbage collector
// writable transactions have a writeContext object that
// matches on any one character.
// transactions while another one is in progress will result in blocking until
// rolled back and the that error will be return to the caller of Update().
// Delete removes an item from the database based on the item's key. If the item
// got an eof but also data. this should be an unexpected eof.
// the found value will be returned even if it is expired.
// we use a non-nil copy of the index without the data to indicate that the
"// Open("":memory:"")."
"// When an index is not nil, we will need to rebuilt that index"
// ErrInvalidOperation is returned when an operation cannot be completed.
// check to see if we've already deleted everything
"// Even though the item has been deleted, we still want to check"
// returned to the caller. A nil return value means that the item was not
// first we should read the number of parts that the of the command
// expires tree
// index should be rebuilt upon rollback.
// of RESP commands. For more information on RESP please read
// Thus min[0] must be less-than-or-equal-to max[0].
// AscendEqual calls the iterator for every item in the database that equals
// Flushing the buffer only once per transaction.
// Clear the db field to disable this transaction from future use.
"// an empty name index is designated for the main ""keys"" tree."
// The specified index must have been created by AddIndex() and the target
// IndexJSON provides for the ability to create an index on any JSON field.
// as specified by the less() function of the defined index.
// Match returns true if the specified key matches the pattern. This is a very
// SetOptions represents options that may be included with the Set() command.
// to generate a rect from a string.
// Remove it from the rtree index.
// the endpos is used to return to the end of the file when we are
// does this item expire?
// to note that the ctx parameter is used to help with determine which
// Package buntdb implements a low-level in-memory key/value store in pure Go.
// iterate through all keys and fill the index
// Intersects method.
// An item with the same key did not previously exist. Let's
// ErrInvalid is returned when the database file is an invalid format.
// less function to handle the content format and comparison.
// the item to be evicted at a specified time. When the return value
// View executes a function within a managed read-only transaction.
// The new item has eviction options. Add it to the
// percentage of the result of the previous shrunk file.
// Each committed record is written to disk
// Len returns the number of items in the database
// OnExpiredSync will be called inside the same transaction that is performing
// convert the string number to and int
"// represented by two arrays, min and max. Both arrays may have a length"
// values for keys and iterating through keys and values. Read/write
// There is support for up to 20 dimensions.
// finished reading the command
"// *not* nil, that means the entry should be reverted."
"// simple 2D points, it's the distance of the two 2D points squared."
// lock locks the database based on the transaction type.
// This compares the raw binary of the string.
// rollback entry with the item as the value. We need to check the
// cannot create an index without a name.
// options are used to change various behaviors of the database.
// IndexBinary is a helper function that returns true if 'a' is less than 'b'.
// does not exist or if the item has expired then ErrNotFound is returned.
// expiration.
// save the index
// EverySecond is used to sync data to disk every second.
// IndexString is a helper function that return true if 'a' is less than 'b'.
// AutoShrinkMinSize defines the minimum size of the aof file before
// Add new item to btree index.
// ErrTxClosed is returned when committing or rolling back a transaction
// IndexUint is a helper function that returns true if 'a' is less than 'b'.
// We're wrapping this in a function to get the benefit of a defered
"//
// Read-only transactions can only be rolled back, not committed."
// a tree of all item ordered by key
// DescendEqual calls the iterator for every item in the database that equals
"// the range [lessOrEqual, greaterThan), until iterator returns false."
// create a compound less function.
// the index trees.
// SyncPolicy represents how often data is synced to disk.
// The results of this operation will not be available to other
// the origin database
// This compares uint64s that are added to the database using the
// that is needed to fully remove the item with the matching key. If an item
// a shrink of the aof file when the size of the file is larger than the
// Everything went well. Lets Commit()
// Uint() conversion function.
"// in-memory databases using the "":memory:"". Database that persist to disk"
// The item does not exists or has expired. Let's assume that
"//
// Only a writable transaction can be used for this operation."
// doing ad-hoc searches inside a transaction.
"// When an index is not provided, the results will be ordered by the item key."
// load the database from disk
// This method is intended to be wrapped by Update and View
// SetConfig updates the database configuration.
"//
// Executing a manual commit or rollback from inside the function will result"
// indicates that expires manager is running.
// Point is a helper function that converts a series of float64s
// used for b-tree ordering.
// An error will be returned if the tx is closed or the index is not found.
// Expires indicates that the Set() key-value will expire
"// When the field is a string, the comparison will be case-sensitive."
// contains the items
// All transactions must be closed before closing the database.
"//
// Only a writable transaction can be used with this operation."
// createIndex is called by CreateIndex() and CreateSpatialIndex()
// value will be returned through the previousValue variable.
"// does not match the pattern, conintue"
"// b is uppercase, convert b to lowercase"
"// The item exists in the tree, but has expired. Let's assume that"
// AscendRange calls the iterator for every item in the database within
// Open opens a database at the provided path.
// when false mutable operations fail.
// create a rollback entry if there has not been a deleteAll call.
// Commit writes all changes to disk.
// we use nil to indicate that the index should be removed upon rollback.
// matching on keys when setting key/values.
// the underlying file
// that has already been committed or rolled back.
// AutoShrinkPercentage is used by the background process to trigger
// match where '*' matches on any number characters and '?' matches on
// for err is nil the operation succeeded. When the return value of
"// When an index is provided, the results will be ordered by the item values"
// expiresAt will return the time when the item will expire. When an item does
"// the range [pivot, last], until iterator returns false."
// TTL is how much time the key-value will exist in the database
"// [last, first], until iterator returns false."
// an automatic shrink can occur.
// sharing the same item.
// contains information about changes to the database.
"// the range [last, pivot), until iterator returns false."
// wrap a btree specific iterator around the user-defined iterator.
// There are some default less function that can be used such as
// TTL to an absolute time and bind it to the item.
// if it has expired. An expired item should not be returned.
"// will not be called. If this callback is present, then the deletion of the"
// Indexes returns a list of index names.
"// An error is returned when a write error occurs, or when a Commit() is called"
// get return an item or nil if not found.
// resize the read buffer
// It's pretty fast and you can lose 1 second of data if there
// Remove it from the btree index.
"//
// When a pattern is provided, the index will be populated with"
// backgroundManager runs continuously in the background and performs various
"// clearCopy creates a copy of the index, but with an empty dataset."
// Any failures below here is really bad. So just panic.
// The dist param is the distance of the bounding boxes. In the case of
// This is the recommended setting.
// delete from the map.
// This is a case-insensitive comparison. Use the IndexBinary() for comparing
// iterated through every item in the database and write to the buffer
// deleteFromDatabase removes and item from the database and indexes. The input
// Ascend calls the iterator for every item in the database within the range
// it allows for additional options.
// ErrDatabaseClosed is returned when the database is closed.
"//
// All transactions must be closed by calling Commit() or Rollback() when done."
// always clear out the commits
// unlock the database for more transactions.
// we must return the previous item to the caller.
// TTL returns the remaining time-to-live for an item.
// one final flush
// ErrShrinkInProcess is returned when a shrink operation is in-process.
// CreateIndexOptions is the same as CreateIndex except that it allows
// the caller is only interested in items that have not expired.
// DescendKeys allows for iterating through keys based on the specified pattern.
// Just copy all of the new commands that have occurred since we
// ReplaceSpatialIndex builds a new index and populates it with items.
// The lt param indicates that there is a lessThan limit.
// copy string
// DescendGreaterThan calls the iterator for every item in the database within
// SyncPolicy adjusts how often the data is synced to disk.
// Begin opens a new transaction.
// the item does not have `opts.ex` set to true.
// details for rolling back tx.
// The transaction has been committed when no error is returned.
// execute the search
// the current read/write transaction is completed.
// ReadConfig returns the database configuration.
// has been expired.
// An error will occur if an index with the same name already exists.
// DescendRange calls the iterator for every item in the database within
// any JSON field.
// rollbackInner handles the underlying rollback logic.
// function bound to the index
"// pivot, until iterator returns false."
// into the database overwriting the current one.
// http://redis.io/topics/protocol. The only supported RESP commands are DEL and
"// with the matching key was found in the database, it will be removed and"
"// For example, if this value is 100, and the last shrink process"
// ErrTxNotWritable is returned when performing a write operation on a
// index options
"// set the center param to false, which uses the box dist calc."
// in a panic.
// keys that match the specified pattern. This is a very simple pattern
// The rollback func does the heavy lifting.
// scan iterates through a specified index and calls user-defined iterator
"// descending order, these will be lessThan, greaterThan."
// same key.
// Returns ErrNotFound if the index is not found or there is no rect
// started the shrink process.
// AscendGreaterOrEqual calls the iterator for every item in the database within
// execute the scan on the underlying tree.
"// for ordering, inserting, and deleting items from a b-tree. It's important"
"// it's ok to get a ""not found"" because the"
// is represented by the rect string. This string will be processed by the
// cannot search on keys tree. just return nil.
// index represents a b-tree or r-tree index and also acts as the
// writeSetTo writes an item as a single DEL record to the a bufio Writer.
// to the caller of View().
// If the file does not exist then it will be created automatically.
// Never is used to disable syncing data to disk.
// SET.
// Insert the item into the keys tree.
// Let's release all references to nil. This will help both with debugging
// The desc param indicates that the iterator should descend.
// from a rect.
// Default number of btree degrees
// hardcoding 0666 as the default mode.
// initialize trees and indexes
// timeed-out item is the explicit responsibility of this callback.
// formula to use on an item. Each b-tree should use a different ctx when
// operations such as removing expired items and syncing to disk.
"// In the event that an error is returned, the transaction will be rolled back."
// a buffer to write to
// the database configuration
// details for committing tx.
// The gt param indicates that there is a greaterThan limit.
// This operation is not allowed during iterations such as Ascend* & Descend*.
"// has expired then ErrNotFound is returned. If ignoreExpired is true, then"
// flush when buffer is over 4MB
// AscendLessThan calls the iterator for every item in the database within the
// name of the index
// A previous item already exists in the database. Let's create a
// context for writable transactions.
// ErrPersistenceActive is returned when post-loading data from an database
// Intended to be called from Commit() and Rollback().
// read-only transaction can only roll back.
// before being evicted. The Expires field must also be set to true.
// store the index in the rollback map.
// Get returns a value for a key. If the item does not exist or if the item
// load reads entries from the append only database file and fills the database.
// doing ad-hoc compares inside a transaction.
// log entries. This operation does not block the database.
// ErrTxIterating is returned when Set or Delete are called while iterating.
// keyless item for scanning
// IndexRect is a helper function that converts string to a rect.
// can be snapshotted by simply copying the database file.
"// cannot drop the default ""keys"" index"
// use a buffered writer and flush every 4MB
// For commits we simply assign the item to the map. We use this map to
// to a rectangle for a spatial index.
// stack of iterators
// is a disaster.
// Rect converts a string to a rectangle.
// read-only transaction.
// exctx is a simple b-tree context for ordering by expiration.
// An invalid index will return an error.
// of a rect. IndexRect() is the reverse function and can be used
// We are going to open a new version of the aof file so that we do
// Always fall back to the key comparison. This creates absolute uniqueness.
// Close releases all database resources.
// optional meta information
// IndexFloat is a helper function that returns true if 'a' is less than 'b'.
"// the range [pivot, first], until iterator returns false."
"//
// Deprecated: Use Transactions"
// DeleteAll deletes all items from the database.
"// between 1 and 20, and both arrays must match in length. A length of 1 is a"
// Set inserts or replaces an item in the database based on the key.
// for too long.
// ErrInvalidSyncPolicy is returned for an invalid SyncPolicy value.
// Always is used to sync data after every write to disk.
// When a non-nil error is returned from the function that error will be return
// this could be an expensive process if the database has many
// // wrap a rtree specific iterator around the user-defined iterator.
// index with name already exists. error.
// The caller is requesting that this item expires. Convert the
// Add new item to rtree index.
// There's some more work to do by appending the new line from the aof
// OnExpired is used to custom handle the deletion option when a key
// Using an index
// rebuild rebuilds the index
// Nearby searches for rectangle items that are nearby a target rect.
// The values of min must be less than the values of max at the same dimension.
// Slow. Very safe.
// ReplaceIndex builds a new index and populates it with items.
// The default is EverySecond.
"// send expired event, if needed"
// insert into the rollback map if there has not been a deleteAll.
"// The database was opened with "":memory:"" as the path."
// when an aof shrink is in-process.
// a tree of items ordered by expiration
// problem in the future if we choose to use syscall file locking.
// the current time.Now().
// not expire `maxTime` is used.
"// The file format uses the Redis append only file format, which is and a series"
// we need to backup the live data in case of a rollback.
// This compares float64s that are added to the database using the
"// replaced is true, then the operaton replaced an existing item whose"
// database thus allowing for access to anything we need.
// to the tmp file and finally swap the files out.
// read each part of the command.
// write a flushdb if a deleteAll was called.
// It returns a helper function used by CreateIndex.
// a count of the number of disk flushes
// TTL stands for Time-To-Live.
"// When a non-nil error is returned from the function, the transaction will be"
"// If a previous index with the same name exists, that index will be deleted."
// case-sensitive strings.
// not an r-tree index. just return nil
// This is a long time in the future. It's an imaginary number that is
"// It persists to disk, is ACID compliant, and uses locking for multiple"
// managed calls a block of code that is fully contained in a transaction.
// genreate a less function
// An invalid rectangle will cause a panic.
// no less function
// A previous item was removed from the keys tree. Let's
// rollback when deleteAll is called
"// The start and stop params are the greaterThan, lessThan limits. For"
// All items belonging to the specified index will be returned in order of
"// There is no persistence, and no need to do anything here."
"// modTime is the modified time of the reader, should be no greater than"
// not change the seek position of the previous. This may cause a
// we are going to read items in as chunks as to not hold up the database
// Descend calls the iterator for every item in the database within the range
// A negative duration will be returned for items that do not have an
// insertIntoDatabase performs inserts an item in to the database and updates
// index was not found. return error
// when true Commit and Rollback panic.
// rollback the deleteAll if needed
// expired evaluates id the item has expired. This will always return false when
// expired items.
// create some limit items
// rollback.
// items or the index is complex.
"// both are uppercase, do nothing"
// when does this item expire?
"// resulted in a 100mb file, then the new aof file must be 200mb before"
// Open a standard view. This will take a full lock of the
// match matches the pattern to the key
// a shrink is triggered.
// rect is used by Intersects and Nearby
// wait just a bit before starting
// this is all that is needed to delete an index.
// transactions until the current transaction has successfully committed.
// create a rollback entry with a nil value. A nil value indicates
// multiple less functions specified.
// set when the database has been closed
"// item must only have the key field specified thus ""&dbItem{key: key}"" is all"
// AutoShrinkDisabled turns off automatic background shrinking
// Load loads commands from reader. This operation blocks all reads and writes.
// DEL
// alternate functionality.
"// writes, but not reads. This can be used for snapshots and backups for pure"
// fully delete this item from all indexes.
// only be one read/write transaction at a time. Attempting to open a read/write
// now reset the live database trees
// Unlock the database and allow for another writable transaction.
// GetRect returns the rect function for an index. This is handy for
// read the number of bytes of the part.
// the binary key and value
// GetLess returns the less function for an index. This is handy for
// initialize trees
"// one dimensional rectangle, and a length of 4 is a four dimension rectangle."
// read-only or read/write. Read-only transactions can be used for retrieving
"// When an item is not nil, we will need to reinsert that item"
// empty index means we will use the keys tree.
// SET
// execute the nearby search
// found in the database
"//
// The rect function converts a string to a rectangle. The rectangle is"
// read a single command.
"//
// All transactions must be committed or rolled-back when done."
// Ascend* and Descend* methods.
// IndexJSONCaseSensitive provides for the ability to create an index on
// CreateSpatialIndex builds a new index and populates it with items.
// check if an index with that name already exists.
// MaxTime from http://stackoverflow.com/questions/25065055#32620397
// unlock unlocks the database based on the transaction type.
// Tx represents a transaction on the database. This transaction can either be
// parameter.
// that the entry should be deleted on rollback. When the value is
// Save writes a snapshot of the database to a writer. This operation blocks all
// Transactions are used for all forms of data access to the DB.
// for additional options.
// that the strings may be textual or binary. It's up to the provided
"// IndexString, IndexBinary, etc."
// CreateIndex builds a new index and populates it with items.
// neither are uppercase
"// a dependable database, and favor speed over data size."
"// all indexes. If a previous item with the same key already exists, that item"
// do we write to disk
// finally re-create the indexes
// Returns ErrNotFound if the index is not found or there is no less
// DropIndex removes an index.
// function for each item encountered.
"// When the field is a string, the comparison will be case-insensitive."
// details for dropped indexes.
// any one character.
// CreateSpatialIndexOptions is the same as CreateSpatialIndex except that
// If this operation fails then the write did failed and we must
// Rect is helper function that returns a string representation
// the size of the last shrink aof size
// The caller returned an error. We must rollback.
// The index param tells the scanner to use the specified index tree. An
// rect from string function
"// a is uppercase, convert a to lowercase"
// It allows for indexes to create custom ordering. It's possible
// the deletion of expired items. If OnExpired is present then this callback
// AscendKeys allows for iterating through keys based on the specified pattern.
// initialize default configuration
// from a read-only transaction.
// start the background manager.
// 1000 items or 64MB buffer
// finished writing all of the current items.
// DB represents a collection of key-value pairs that persist on disk.
// the gatekeeper for all fields
// CaseInsensitiveKeyMatching allow for case-insensitive
// Note that this can only work for fully in-memory databases opened with
// The items are organized in an r-tree and can be retrieved using the
// Rect() is the reverse function and can be used to generate a string
// Float() conversion function.
// writeSetTo writes an item as a single SET record to the a bufio Writer.
// Intersects searches for rectangle items that intersect a target rect.
// do a sync but ignore the error
"// empty string for the index means to scan the keys, not the values."
// the underlying database.
// ErrNotFound is returned when an item or index is not in the database.
// nearest to farthest.
// IndexOptions provides an index with additional features or
// The faster and less safe method.
// IndexInt is a helper function that returns true if 'a' is less than 'b'.
// The items are ordered in an b-tree and can be retrieved using the
// DescendLessOrEqual calls the iterator for every item in the database within
// cannot load into databases that persist to disk
// simple pattern matcher where '*' matches on any number characters and '?'
// Update executes a function within a managed read/write transaction.
// values that the pattern can represent.
// Match returns true if str matches pattern. This is a very
// read the next runes
// IsPattern returns true if the string is a pattern.
"//
func Match(str, pattern string) bool {"
// done reading
// term:
// read the first rune ahead of time
"// 	c           matches character c (c != '*', '?', '\\')"
"// When the max cannot be determined, 'true' will be returned"
// 	'*'         matches any sequence of non-Separator characters
// and '?' matches on any one character.
// pattern:
// for infinite.
// 	{ term }
// Allowable parses the pattern and determines the minimum and maximum allowable
// simple wildcard match where '*' matches on any number characters
// 	'\\' c      matches character c
// 	'?'         matches any single non-Separator character
// Match provides a simple pattern matcher with unicode support.
// Default is 80
// here we try to create a single line array
// Ugly removes insignificant space characters from the input json byte slice
// and returns the compacted result.
// Default is false
// element is on it's own line with clear indentation.
// Indent is the nested indentation
// DefaultOptions is the default options for pretty formats.
// UglyInPlace removes insignificant space characters from the input json
// Pretty converts the input json into a more human readable format where each
// TerminalStyle is for terminals
// input json buffer to avoid allocations. Do not use the original bytes
// PrettyOptions is like Pretty but with customized options.
// Default is an empty string
// SortKeys will sort the keys alphabetically
// Style is the color style
// bad data. disable sorting
// Prefix is a prefix for all lines
// the colors. Passing nil to the style param will use the default
// Color will colorize the json. The style parma is used for customizing
// TerminalStyle.
// Width is an max column width for single line arrays
// Options is Pretty options
// slice upon return.
// Default is two spaces
// byte slice and returns the compacted result. This method reuses the
// Default is 80
// Prefix is a prefix for all lines
// Default is two spaces
// Default is false
// Width is an max column width for single line arrays
// Default is an empty string
// Indent is the nested indentation
// SortKeys will sort the keys alphabetically
// just copy min1
"//		return parseWKB(s, i)"
// just copy min2
// just balance the parens
// normalize
// do not increment the index
// Output:
// [100 0] [101 1]
// noop. Use zero for the Index value.
// not a map
// Or as one step
"// can be String, Number, True, False, Null, or JSON"
// holds the float64 number
// -9223372036854775808 to 9223372036854775807
"// index of raw value in original json, zero means index unknown"
// keep iterating
// 0 to 18446744073709551615
// holds the raw json
"// prints ""Elliotte"""
// holds the string
"//
//  if gjson.Get(json, ""name.last"").Exists(){"
//  }
"// the value of each item. If the result is not a JSON array or object, the"
// The dot and wildcard character can be escaped with '\'.
"//   #(first_name==""Murphy"").last"
// Exists returns true if value exists.
// prior to calling this function.
// @ugly modifier removes all whitespace.
"//  ""children.1""         >> ""Alex"""
// array containing one result.
// query
// Get searches json for the specified path.
"// expects that the lead character is a '""'"
// probably a valid number
// So for this query:
// nameOfLast returns the name of the last component
// whitespace
"//  ""children""           >> [""Sara"",""Alex"",""Jack""]"
"//
func Valid(json string) bool {"
"// both are uppercase, do nothing"
"//    ""friends"": ["
"//    ""age"":37,"
// GetBytes searches json for the specified path.
// ValidBytes returns true if the input is valid json.
"//    ""name"": {""first"": ""Tom"", ""last"": ""Anderson""},"
//   first_name   # path
"// inside selector string, balance quotes"
// String returns a string representation of the type.
"//   service_roles.#(==""one"")   # path"
// Str is the json string
// Value returns one of these types:
// split the left and right side of the path with the pipe character as
// start of the value part
// peek at the next byte and see if it's a '@' modifier
// use the Valid function first.
//   .last        # right
// Number is json number
// allow for exponential numbers
"//	[]interface{}, for JSON arrays"
// The caseSensitive paramater is used when the tokens are Strings.
// provide enough space to encode the largest utf8 possible
"//   ==""Murphy""   # middle"
"// The return values are (i int, res Result, ok bool)"
"//
func (t Result) Less(token Result, caseSensitive bool) bool {"
"//
// If working with bytes, this method preferred over ValidBytes(string(data))"
"// If working with bytes, this method preferred over Parse(string(data))"
"//      {""first"": ""Roger"", ""last"": ""Craig""}"
// the delimiter. This is a little tricky because we'll need to basically
"//
//	bool, for JSON booleans"
// part of the path into the c.pipe field and shorten the rp.
// ForEachLine iterates through lines of JSON as specified by the JSON Lines
// Map returns back an map of values. The result should be a JSON array.
"//      {""first"": ""James"", ""last"": ""Murphy""},"
"// Or,"
"// Invalid json will not panic, but it may return back unexpected results."
"// inside selector, balance brackets"
"//	map[string]interface{}, for JSON objects"
// the first '[' or '{' has already been read
// frac
// we expect it to be correct so just consume it
// String returns a string representation of the value.
// AddModifier binds a custom modifier command to the GJSON syntax.
// all types.
// True is a json true boolean
// ForEach iterates through values.
// When the value is found it's returned immediately.
// runeit returns the rune from the the \uXXXX
// try to directly convert the float64 to uint64
// this is slightly different from getting s string value
// Null is a null json value
"//  ""age""                >> 37"
// A Result is returned when the hit param is set.
// Num is the json number
// Uint returns an unsigned integer representation.
// break on whitespace and comma
"//
// Deprecated: Use encoder/json.Unmarshal instead"
// Float returns an float64 representation.
// then input expects that the path already starts with a '@'
// This operation is not thread safe and should be executed prior to
// Bool returns an boolean representation.
"// b is uppercase, convert b to lowercase"
// will be equal to the number of input paths.
// less than dash might have valid characters
"// bad query, end now"
"//
//  if !gjson.Valid(json) {"
"//
// A path is a series of keys searated by a dot."
// used for testing
// GetManyBytes searches json for the multiple paths.
// Get searches result for the specified path.
// take a quick peek for the pipe character. If found we'll split the piped
// now try to parse the raw string
// calculated result
// @reverse reverses array elements or root object members.
// A key may contain special wildcard characters '*' and '?'.
"// value of each item. If the result is an Array, the iterator will only pass"
"//		println(""value exists"")"
"//
// This function expects that the json is well-formed, and does not validate."
// because we don't need the outer quotes.
// Unmarshal loads the JSON data into the value pointed to by v.
"//  value := gjson.Get(json, ""name.last"")"
"// parseSubSelectors returns the subselectors belonging to a '[path1,path2]' or"
"//  ""children.#""         >> 3"
// @pretty modifier makes the json look nice.
// need another code
// The return value is a Result array where the number of items
"// If the result represents a non-existent value, then an empty array will be"
// Type is Result type
// GetMany searches json for the multiple paths.
// If you are consuming JSON from an unpredictable source then you may want to
// get next value
"//	string, for JSON string literals"
// False is a json false boolean
"//  ""friends.#.first""    >> [""James"",""Roger""]"
// parse_key_string
// sign
//   .cap                       # right
"//  ""name.last""          >> ""Anderson"""
//                              # middle
// ParseBytes parses the json and returns a result.
// just take the entire raw
"//   #(service_roles.#(==""one"")).cap"
// during the Unmarshal routine. Validation is enabled by default.
// execModifier parses the path to find a matching modifier function.
// ModifierExists returns true when the specified modifier exists.
// IsArray returns true if the result value is a JSON array.
"// returned. If the result is not a JSON array, the return value will be an"
// likely a ']' or '}'
// Parse parses the json and returns a result.
"//
// This function works almost identically to json.Unmarshal except  that"
// start of value part
// neither are uppercase
"//
func ValidBytes(json []byte) bool {"
"//  ""c?ildren.0""         >> ""Sara"""
// String is a json string
// go into escape mode. this is a slower path that
"//	Number, for JSON numbers"
"// To get the number of elements in an array or to access a child path, use"
// expects that the lead character is a '[' or '{'
// UnmarshalValidationEnabled provides the option to disable JSON validation
"//
//  {"
// append the last part
"//   path, op, middle, and right."
// The order when comparing two different type is:
// The result should be a JSON array or object.
// To access an array value use the index as the key.
"//  ""child*.2""           >> ""Jack"""
// could be a '+' or '-'. let's assume so.
// Package gjson provides searching for json strings.
"// iterated. If the result is an Object, the iterator will pass the key and"
// Valid returns true if the input is valid json.
// format (http://jsonlines.org/).
"// peek at the next byte and see if it's a '@', '[', or '{'."
"// If the result represents a non-existent value, then no values will be"
// Time returns a time.Time representation.
// parse the entire path.
"// which makes sure that the array ""friends"" has an element of"
// fallback to a standard conversion
"// squash the value, ignoring all nested arrays and objects."
"// a is uppercase, convert a to lowercase"
// using a subselector path
"//
func (t Result) Value() interface{} {"
// parse the compare op from the value
"//
//  Null < False < Number < String < True < JSON"
// Result represents a json value that is returned from Get().
// try to directly convert the float64 to int64
//    ]
"//	nil, for JSON null"
// IsObject returns true if the result value is a JSON object.
// Less return true if a token is less than another token.
// look for an escaped slash
// Type is the json type
//   friends.#(name)
// possible modifier
"// If working with bytes, this method preferred over Get(string(data), path)"
// Int returns an integer representation.
"// '{""field1"":path1,""field2"":path2}' type subSelection. It's expected that the"
// int
// JSON is a raw block of JSON
"// the query is only looking for existence, such as:"
// Raw is the raw json
// parseAny parses the next value from a json string.
// the '#' character.
// iterator will pass back one value equal to the result.
// gjson.Unmarshal will automatically attempt to convert JSON values to any Go
// splitQuery takes a query and splits it into three parts:
// Array returns back an array of values.
// exp
"// equally assigned to Go string, int, byte, uint64, etc. This rule applies to"
// strips off the escape character from the part.
// unescape unescapes a string
"// type. For example, the JSON string ""100"" or the JSON number 100 can be"
"//  	return errors.New(""invalid json"")"
"// Index of raw value in original json, zero means index unknown"
"//	float64, for JSON numbers"
"// first character in path is either '[' or '{', and has already been checked"
// using all other gjson function.
// Becomes
"// A path is in dot syntax, such as ""name.last"" or ""age""."
"//    ""children"": [""Sara"",""Alex"",""Jack""],"
// backtrack index by one
// Each line is returned as a GJSON Result.
"// ""name"" that exists"
// DisableModifiers will disable the modifier syntax
// of the resulting value. If the position cannot be found then Index zero is
// raw is nil
// Str is a substring of Raw.
// fillIndex finds the position of Raw data and assigns it to the Index field
// getBytes casts the input json bytes to a string and safely returns the
// results as uniquely allocated data. This operation is intended to minimize
// safely get the string headers
// create byte slice headers
// str is nil
// safely copy both the raw and str slice headers to strings
// substring the raw
// unsafe cast to string
"// str has data, safely copy the slice header to a string"
"// raw has data, safely copy the slice header to a string"
// used instead.
// safely copy the raw slice header
// copies and allocations for the large json string->[]byte.
"// raw input, right off the wire"
"// Read header, payload."
"// Similarly, a clientHello message encodes in"
// It implements the net.Conn interface.
// http://tools.ietf.org/html/rfc5077#section-3.2
// TLS record types.
// returning a block with those n bytes and a
// read until have enough.
"// No valid TLS record has a type of 0x80, however SSLv2 handshakes"
// this might not be a TLS client.
// else application data.  (We don't support renegotiation.)
// TLS parses the ClientHello message on conn and returns
"// well under a kilobyte.  If the length is >= 12 kB,"
// maximum ciphertext payload length
// A Conn represents a secured connection.
// handshake data waiting to be read
"// handshake data if handshake not yet completed,"
// is always < 256 bytes long. Therefore typ == 0x80 strongly suggests
// TLS handshake message types.
// Portions of the TLS code are:
// ClientHello is optionally followed by extension data
// or else returns an error.
// readFromUntil reads from r into b until b contains at least n bytes
// readRecord reads the next TLS record from the connection
// TLS CertificateStatusType (RFC 3546)
// start with a uint16 length where the MSB is set and the first record
"// resize resizes block to be n bytes, growing if necessary."
// it's probably not real.
"// First message, be extra suspicious:"
// block with the remainder.  the latter may be nil.
// A block is a simple data buffer.
"// Bail out before reading a full 'body', if possible."
// maximum plaintext payload length
"// If the version is >= 16.0, it's probably not real."
// http://tools.ietf.org/html/rfc4492#section-5.5.1
// http://tools.ietf.org/html/rfc4492#section-5.5.2
// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// quick case
// reserve makes sure that block contains a capacity of at least n bytes.
// license that can be found in the LICENSE file.
"// they are uint16s, the number must be even."
// TLS virtual hosting
// cipherSuiteLen is the number of bytes of cipher suite numbers. Since
// the record layer.
"// splitBlock splits a block after the first n bytes,"
// TLS extension numbers
// index for Read
// maximum handshake we support (protocol max is 16 MB)
"// a new, unread connection with metadata for virtual host muxing"
// an SSLv2 client.
// newBlock allocates a new block
// readHandshake reads the next handshake message from
// and updates the record layer state.
// Caller must be in sync with connection:
// Process message.
// record header length
// The current max version is 3.1.
// not IANA assigned
// until one is available.
// this is the function you apply to a net.Conn to get
// TLS SNI never includes the port
// look up the correct listener
// not listening for.
// Make sure we detect dead connections while we decide how to multiplex
// You must invoke this function if you do not want to handle the errors yourself.
// Closed is returned when the underlying connection is closed
"// HandleErrors is the default error handler for TLS muxers. At the moment, it simply"
// Addr returns the address of the bound listener used by the parent muxer.
"// connections and Close() it when finished. When you Close() a Listener,"
// recover from failures
// the HTTP Host header in new connections.
// all muxing errors are sent over this channel
// registry of name -> listener
// the parent muxer will stop listening for connections to the Listener's name.
// normalize the name
// BadRequest is returned when extraction of the vhost name fails
// XXX: include name in address?
// run is the VhostMuxer's main loop for accepting new connections from the wrapped listener
// protects the registry
// Listen begins multiplexing the underlying connection to send new
// Listen call.
// extract the name
// look for a matching wildcard
// NewHTTPMuxer begins muxing HTTP connections on the given listener by inspecting
// invoke this function if you do not want to handle the errors yourself.
// Close stops the parent muxer from listening for connections to the mux'd
// an error encountered when multiplexing a connection
// listener on which we mux connections
"//
// Listener implements the net.Listener interface, so you can Accept() new"
// The net.Conn may be nil if the wrapped listener returned an error from Accept()
// Accept returns the next mux'd connection for this listener and blocks
// Listener is returned by a call to Listen() on a muxer. A Listener
// NextError returns the next error encountered while mux'ing a connection.
// only receives connections that were made to the name passed into the muxer's
// handle muxes a connection accepted from the listener
// NotFound is returned when a vhost is not found
// a new virtual-host multiplexed connection
// Close closes the underlying listener
// Name returns the name of the virtual host this listener receives connections on.
// connections for the given name over the returned listener.
// a connection fails if it doesn't send enough data to mux after this timeout
// closes connections which are invalid or destined for virtual host names that it is
// XXX: respond with valid TLS close messages
// virtual host name.
// HandleErrors handles muxing errors by calling .NextError(). You must
// NewTLSMuxer begins muxing TLS connections by inspecting the SNI extension.
// new connections are multiplexed by applying this function
// You probably don't need access to the request body and this makes the API
"// a new, unread connection with metadata for virtual host muxing"
// Free sets Request to nil so that it can be garbage collected
// simpler by allowing you to call Free() optionally
// HTTP parses the head of the first HTTP request on conn and returns
// and make sure we don't read from it again
// allocate 1 KB up front to try to avoid resizing
// continue reading from the connection
// let the request buffer get garbage collected
// the raw connection
// update total read
// end of the request buffer
// all of the initial data that has to be read in order to vhost a connection is saved here
// ...
// Target Host: example.com
// Host: example.com
// User-Agent: ...
// vhostConn.ClientHelloMsg == nil (TLS)
// vhostConn.Request == nil (HTTP)
// look up the upstream host
// parse out the HTTP request and the Host header
// listen for connections to different domains
// vhostConn contains the entire request as if no bytes had been consumed
// accept a new connection
// GET / HTTP/1.1
// start multiplexing on it
// free up the muxing data
"// vhostConn.Host() == """""
"// vhost.Name is a virtual hostname like ""foo.example.com"""
// Copyright 2015 The Go Authors. All rights reserved.
// false if there is not.
"// If an error is waiting on the file descriptor, we should pretend"
"// This should not happen, but if it does, treat it as a wakeup."
"// This is an absolute mystery, and should never ever happen."
"// Create pipe; pipe[0] is the read end, pipe[1] the write end."
// Pipe for waking up
// There is data to read.
// File descriptor (as returned by the inotify_init() syscall)
// Create epoll fd
"// If there are no events, try again."
// +build linux
"// watcher, and we should wake up."
// You have to be woken up a LOT in order to get to 100!
// If an error is waiting on the pipe file descriptor.
"// I don't know whether epoll_wait returns the number of events returned,"
// Register inotify fd with epoll
// Close the write end of the poller.
// Create a new inotify poller.
"// something is ready to read, and let unix.Read pick up the error."
"// Returns true if something is ready to be read,"
// Wait using epoll.
// Register pipe fd with epoll
// Use of this source code is governed by a BSD-style
"// Buffer is full, poller will wake."
// license that can be found in the LICENSE file.
"// 3 possible events per fd, and 2 fds, makes a maximum of 6 events."
"// This creates an inotify handler, and an epoll handler."
"// This is a regular wakeup, so we have to clear the buffer."
"// Buffer is empty, someone else cleared our wake."
// or the total number of events ready.
"// Close all poller file descriptors, but not the one passed to it."
// I decided to catch both by making the buffer one larger than the maximum.
// This should never happen. More events were returned than should be possible.
// Epoll file descriptor
"// Write pipe descriptor was closed, by us. This means we're closing down the"
// +build freebsd openbsd netbsd dragonfly darwin
// The flags are interpreted as described in kevent(2).
// Make ./name and name equivalent
"// read retrieves pending events, or waits until an event occurs."
// Search for new files
// File descriptor (as returned by the kqueue() syscall).
"// or if it was watched before, but perhaps only a NOTE_DELETE (watchDirectoryFiles)"
// sendDirectoryEvents searches the directory for newly created files
// Get all files
// Send the event on the Events channel.
// addWatch adds name to the watched file set.
"// We already have a watch, but we can still override flags."
// Send create event
"// Channel for sending a ""quit message"" to the reader goroutine"
"// to the user, as that will just confuse them with an error about"
"// EINTR is okay, the syscall was interrupted before timeout expired."
// a path they did not explicitly watch themselves.
"// have gone missing, ignore the missing directory and let the"
// Store flags so this watch can be updated later
// cleanup
// Map file descriptors to path names for processing kqueue events.
// Map of watches added by user of the library.
// modification event first but the folder has been deleted and later
// keventWaitTime to block on each read from kevent
// watchDirectoryFiles to mimic inotify when adding a watch on a directory
// Hence the returns of nil on errors.
// NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.
// Double check to make sure the directory exists. This can happen when
// mark is as delete event
// Flush the events we received to the Events channel
"// Watch all events (except NOTE_EXTEND, NOTE_LINK, NOTE_REVOKE)"
// be no file events for broken symlinks.
// Copyright 2010 The Go Authors. All rights reserved.
// Look for a file that may have overwritten this.
// license that can be found in the LICENSE file.
// SetKevent converts int to the platform-specific types:
// sendFileCreatedEvent sends a create event if the file isn't already being tracked.
"// consistency, we will act like everything is fine. There will simply"
// the BSD version of fsnotify match Linux inotify which provides a
// receive the delete event
"// unlock before calling Remove, which also locks"
// mimic Linux providing delete events for subdirectories
"// send a ""quit"" message to the reader goroutine"
// only way the previous loop breaks is if w.done was closed so we need to async send to w.Errors.
// Keep track of if we know this file exists (to stop duplicate create events).
// durationToTimespec prepares a timeout value
// we do a rm -fr on a recursively watched folders and we receive a
// Get new events
// newEvent returns an platform-independent Event based on kqueue Fflags.
// watch file to mimic Linux inotify
// Map of watched file descriptors (key: path).
// make sure the directory exists before we watch for changes. When we
// create event for files created in a watched directory.
// Close removes all watches and closes the events channel.
"// See if there is a message on the ""done"" channel"
// like watchDirectoryFiles (but without doing another ReadDir)
// Don't watch sockets.
// kqueue creates a new kernel event queue and returns a descriptor.
// Don't watch named pipes.
// Remove stops watching the the named file or directory (non-recursively).
// Add starts watching the named file or directory (non-recursively).
// and sends them over the event channel. This functionality is to have
"// issue, and Windows can't do symlinks period (AFAIK). To  maintain"
// but preserve the flags used if currently watching subdirectory
"// Since these are internal, not much sense in propagating error"
"// Watch the directory if it has not been watched before,"
"// Watcher watches a set of files, delivering events to a channel."
"// do a recursive watch and perform rm -fr, the parent directory might"
// Move to next event
"// A timeout of nil blocks indefinitely, while 0 polls the queue."
// Event values that it sends down the Events channel.
// Follow Symlinks
"// Unfortunately, Linux can add bogus symlinks to watch list without"
// upcoming delete event remove the watch from the parent directory.
// Protects access to watcher data
// Use of this source code is governed by a BSD-style
// register events with the queue
// readEvents reads from kqueue and converts the received kevents into
"// For example, mv f1 f2 will delete f2, then create f2."
"// Returns the real path to the file which was added, if any, which may be different from the one passed in the case of symlinks."
// register the events
// copy paths to remove while locked
// Find all watched paths that are in this directory that are not external.
// Set to true when Close() is first called
// Map of watched directories to fflags used in kqueue.
// +build darwin
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// Copyright 2013 The Go Authors. All rights reserved.
// note: this constant is not defined on BSD
// Map access
// We successfully removed the watch if InotifyRmWatch doesn't return an
"// If the event happened to the watched directory or the watched file, the kernel"
"// readEvents reads from the inotify file descriptor, converts the"
// Watch descriptor (as returned by the inotify_add_watch() syscall)
// See if we have been closed.
// by another thread and we have not received IN_IGNORE event.
"// explicitly by inotify_rm_watch, implicitly when the file they are watching is deleted."
"// Channel for sending a ""quit message"" to the reader goroutine"
"// This is a sign to clean up the maps, otherwise we are no longer in sync"
"// the ""paths"" map."
"// channel. Such as events marked ignore by the kernel, or MODIFY events"
"// Certain types of events can be ""ignored"" and not sent over the Events"
// IN_DELETE_SELF occurs when the file/directory being watched is removed.
// Map of inotify watches (key: path)
// Wake up goroutine
// +build linux
"// If a signal interrupted execution, see if we've been asked to close, and try again."
// Buffer for a maximum of 4096 raw events
// NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.
// Remove stops watching the named file or directory (non-recursively).
// Channel to respond to Close
// TODO: Perhaps it's not helpful to return an error here in every case.
"// Send 'close' signal to goroutine, and set the Watcher to closed."
"// Point ""raw"" to the event in the buffer"
// Copyright 2010 The Go Authors. All rights reserved.
// inotify_rm_watch will return EINVAL if the file has been deleted;
// against files that do not exist.
// event was sent after the DELETE. This ignores that MODIFY and
// license that can be found in the LICENSE file.
"// Point ""bytes"" at the first byte of the filename"
// Map of watched paths (key: watch descriptor)
"// error, we need to clean up our internal state to ensure it matches"
// with the inotify kernel state which has already deleted the watch
// Number of bytes read with read()
// While the offset points to at least one whole event...
// the only two possible errors are:
"// doesn't append the filename to the event, but we would like to always fill the"
// If an error occurred while reading.
// assumes a DELETE will come or has come if the file doesn't exist.
// inotify flags of this watch (see inotify(7) for the list of valid flags)
// Close removes all watches and closes the events channel.
"// If the event is not a DELETE or RENAME, the file must exist."
// *Note*: this was put in place because it was seen that a MODIFY
// Add starts watching the named file or directory (non-recursively).
// Create inotify fd
// by calling inotify_rm_watch() below. e.g. readEvents() goroutine receives IN_IGNORE
// received events into Event objects and sends them via the Events channel
// Read was too short.
"// EINVAL, which is when fd is not an inotify descriptor or wd is not a valid watch descriptor."
"// unix.Read might have been woken up by Close. If so, we're done."
// automatically.
// Syscall errno
// watches and pathes are deleted in ignoreLinux() implicitly and asynchronously
// Fetch the watch.
// the inotify will already have been removed.
// If EOF is received. This should really never happen.
"// Watcher watches a set of files, delivering events to a channel."
// inotify's kernel state.
// Watch descriptors are invalidated when they are removed explicitly or implicitly;
// For poller.wait
// We don't know how many events we just read into the buffer
// so that EINVAL means that the wd is being rm_watch()ed or its file removed
"// ""Before Linux 3.8, reads from an inotify(7) file descriptor were not restartable"""
"// the ""Name"" field with a valid filename. We retrieve the path of the watch from"
// Move to the next event in the buffer
// http://man7.org/linux/man-pages/man7/signal.7.html :
// Use of this source code is governed by a BSD-style
// newEvent returns an platform-independent Event based on an inotify mask.
// Create epoll
// Wait for goroutine to close
// The filename is padded with NULL bytes. TrimRight() gets rid of those.
// Otherwise the event is ignored.
// Remove it from inotify.
// Ignore anything the inotify API says to ignore
// Send the events that are not ignored on the events channel
"// EBADF, which happens when w.fd is not a valid file descriptor of any kind."
// i-number
// Map access
// Remembers the old name while renaming a file
"// Watcher watches a set of files, delivering events to a channel."
// Watched directory was probably removed
// CancelIo was called on this handle
// Must run within the I/O thread.
// Map of watches (key: i-number)
// Options for AddWatch
// Inputs to the reader are sent on this channel
// +build windows
// Handle to completion port
// NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.
// In practice we can get away with just carrying on.
// In theory we should be building up a full packet.
// Close removes all watches and closes the events channel.
// received events into Event objects and sends them via the Events channel.
// Special events
"// readEvents reads from the I/O completion port, converts the"
// Move to the next event in the buffer
"// Point ""raw"" to the event in the buffer"
// Use of this source code is governed by a BSD-style
// Remove stops watching the the named file or directory (non-recursively).
// license that can be found in the LICENSE file.
// Events
// Add starts watching the named file or directory (non-recursively).
// Map of names being watched and their notify flags
// Directory path
"// Send ""quit"" message to the reader goroutine"
// Error!
// Copyright 2011 The Go Authors. All rights reserved.
// Directory itself is being watched with these notify flags
// The i/o succeeded but the buffer is full.
// Entry point to the I/O thread.
// Set to true when Close() is first called
// +build solaris
// Copyright 2010 The Go Authors. All rights reserved.
// NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.
// Use of this source code is governed by a BSD-style
"// Watcher watches a set of files, delivering events to a channel."
// Close removes all watches and closes the events channel.
// Remove stops watching the the named file or directory (non-recursively).
// license that can be found in the LICENSE file.
// Add starts watching the named file or directory (non-recursively).
// license that can be found in the LICENSE file.
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// +build freebsd openbsd netbsd dragonfly
// Use a buffer for efficient string concatenation
// Strip leading pipe
// Event represents a single file system notification.
// These are the generalized file operations that can trigger a notification.
// Relative path to the file or directory.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
"// ""file: REMOVE|WRITE|..."""
// Common errors that can be reported by a watcher
// +build !plan9
// File operation that triggered the event.
// Copyright 2012 The Go Authors. All rights reserved.
// Op describes a set of file operations.
// Package fsnotify provides a platform-independent interface for file system notifications.
// String returns a string representation of the event in the form
// Or just add them to New()
// Use handy standard colors
// disables colorized output
"// Mix up foreground and background colors, create new mixes!"
// Use it in your function
// Print with default helper functions
// Use your own io.Writer output
// Use helper functions
// These are using the default foreground colors
// Create SprintXxx functions to mix strings with other non-colorized strings:
// Don't forget to unset
// Mix up with multiple attributes
// Create a custom print function for convenience
// Create a new color object
// Windows supported too! Just don't forget to change the output to color.Output
// You can mix up parameters
// A newline will be appended automatically
// Mix up multiple attributes
// Foreground text colors
// colorized with color.Fprintln().
// Unset resets all escape attributes and clears the output. Usually should
// PrintfFunc returns a new function that prints the passed arguments as
// be called after Set().
// Spaces are added between operands when neither is a string.
// Spaces are always added between operands and a newline is appended.
// Black is a convenient helper function to print with black foreground. A
// Println formats using the default formats for its operands and writes to
// allows to reuse already created objects with required Attribute.
// HiWhiteString is a convenient helper function to return a string with hi-intensity white
// color.
// os.Stdout is used.
// HiYellow is a convenient helper function to print with hi-intensity yellow foreground.
// colorized with color.Println().
// wrap wraps the s string with the colors attributes. The string is ready to
// Base attributes
// code and still being able to output. Can be used for flags like
// protects colorsCache
"// sequence returns a formatted SGR sequence to be plugged into a ""\x1b[...m"""
// SprintFunc returns a new function that returns colorized strings for the
// HiRed is a convenient helper function to print with hi-intensity red foreground. A
// HiBlackString is a convenient helper function to return a string with hi-intensity black
// Cyan is a convenient helper function to print with cyan foreground. A
// Output defines the standard output of the print functions. By default
// New returns a newly created color object.
// colorized with color.Fprintf().
// RedString is a convenient helper function to return a string with red
// FprintfFunc returns a new function that prints the passed arguments as
// HiBlack is a convenient helper function to print with hi-intensity black foreground. A
// false or true based on the stdout's file descriptor referring to a terminal
// colorized with color.Print().
// WhiteString is a convenient helper function to return a string with white
// HiGreenString is a convenient helper function to return a string with hi-intensity green
// HiBlue is a convenient helper function to print with hi-intensity blue foreground. A
// It returns the number of bytes written and any write error encountered.
// Background text colors
// HiYellowString is a convenient helper function to return a string with hi-intensity yellow
// HiGreen is a convenient helper function to print with hi-intensity green foreground. A
// type *os.File.
"// string. Windows users should use this in conjunction with color.Output, example:"
"// Sprint is just like Print, but returns a string instead of printing it."
// Equals returns a boolean value indicating whether two colors are equal.
// Background Hi-Intensity text colors
// string. Windows users should use this in conjunction with color.Output.
// White is a convenient helper function to print with white foreground. A
"// Sprintln is just like Println, but returns a string instead of printing it."
// colorized with color.Printf().
"// and create custom color objects. Example: Add(color.FgRed, color.Underline)."
// output with the given SGR parameters until color.Unset() is called.
// PrintlnFunc returns a new function that prints the passed arguments as
// Fprintf formats according to a format specifier and writes to w.
// Fprintln formats using the default formats for its operands and writes to w.
// GreenString is a convenient helper function to return a string with green
// standard output. Spaces are added between operands when neither is a
// Fprint formats using the default formats for its operands and writes to w.
// A newline is appended to format by default.
// HiRedString is a convenient helper function to return a string with hi-intensity red
// be printed.
// HiBlueString is a convenient helper function to return a string with hi-intensity blue
// SprintlnFunc returns a new function that returns colorized strings for the
// Add is used to chain SGR parameters. Use as many as parameters to combine
// given arguments with fmt.Sprintln(). Useful to put into or mix into other
// appended. It returns the number of bytes written and any write error
// DisableColor(). Otherwise this method has no side effects.
// MagentaString is a convenient helper function to return a string with magenta
// FprintlnFunc returns a new function that prints the passed arguments as
"// Sprintf is just like Printf, but returns a string instead of printing it."
// YellowString is a convenient helper function to return a string with yellow
// HiMagentaString is a convenient helper function to return a string with hi-intensity magenta
// Green is a convenient helper function to print with green foreground. A
// Set sets the given parameters immediately. It will change the color of
// newline is appended to format by default.
// Foreground Hi-Intensity text colors
// DisableColor disables the color output. Useful to not change any existing
// HiCyanString is a convenient helper function to return a string with hi-intensity cyan
// colorized with color.Fprint().
// This is the standard fmt.Printf() method wrapped with the given color.
// or not. This is a global option and affects all colors. For more control
// Set sets the SGR sequence.
// standard output. Spaces are always added between operands and a newline is
// Blue is a convenient helper function to print with blue foreground. A
"// On Windows, users should wrap w with colorable.NewColorable() if w is of"
// Red is a convenient helper function to print with red foreground. A
// HiMagenta is a convenient helper function to print with hi-intensity magenta foreground.
// SprintfFunc returns a new function that returns colorized strings for the
// over each color block use the methods DisableColor() individually.
// Yellow is a convenient helper function to print with yellow foreground.
// Print formats using the default formats for its operands and writes to
// given arguments with fmt.Sprintf(). Useful to put into or mix into other
// colorsCache is used to reduce the count of created Color objects and
// Error defines a color supporting writer for os.Stderr.
// HiWhite is a convenient helper function to print with hi-intensity white foreground. A
"// an example output might be: ""1;36"" -> bold cyan"
"// if not return the global option, which is disabled by default"
// NoColor defines if the output is colorized or not. It's dynamically set to
// given arguments with fmt.Sprint(). Useful to put into or mix into other
// foreground.
// BlueString is a convenient helper function to return a string with blue
// BlackString is a convenient helper function to return a string with black
// Magenta is a convenient helper function to print with magenta foreground.
"//	fmt.Fprintf(color.Output, ""This is a %s"", put(""warning""))"
// HiCyan is a convenient helper function to print with hi-intensity cyan foreground. A
// CyanString is a convenient helper function to return a string with cyan
// Printf formats according to a format specifier and writes to standard output.
// Attribute defines a single SGR Code
// FprintFunc returns a new function that prints the passed arguments as
// check first if we have user setted action
// PrintFunc returns a new function that prints the passed arguments as
"// ""--no-color"". To enable back use EnableColor() method."
// Color defines a custom color object which is defined by SGR parameters.
"//
//	put := New(FgYellow).SprintFunc()"
// string. It returns the number of bytes written and any write error
// EnableColor enables the color output. Use it in conjunction with
// encountered. This is the standard fmt.Print() method wrapped with the given
// Create a custom print function for convenient
// Or just add them to New()
"// Mix up foreground and background colors, create new mixes!"
// Use handy standard colors.
// Use your own io.Writer output
// don't forget to unset
// More default foreground colors..
// a newline will be appended automatically
// use it in your function
// Mix up with multiple attributes
// You can mix up parameters
// Create a new color object
// disables colorized output
// Hi-intensity colors
// Mix up multiple attributes
// -- string Value
// GetString return the string value of a flag with the given name
// The argument p points to a string variable in which to store the value of the flag.
"// StringVar defines a string flag with specified name, default value, and usage string."
// The return value is the address of a string variable that stores the value of the flag.
"// StringP is like String, but accepts a shorthand letter that can be used after a single dash."
"// StringVarP is like StringVar, but accepts a shorthand letter that can be used after a single dash."
"// String defines a string flag with specified name, default value, and usage string."
// GetFloat32 return the float32 value of a flag with the given name
"// Float32 defines a float32 flag with specified name, default value, and usage string."
// The return value is the address of a float32 variable that stores the value of the flag.
"// Float32P is like Float32, but accepts a shorthand letter that can be used after a single dash."
"// Float32VarP is like Float32Var, but accepts a shorthand letter that can be used after a single dash."
// The argument p points to a float32 variable in which to store the value of the flag.
// -- float32 Value
"// Float32Var defines a float32 flag with specified name, default value, and usage string."
// The return value is the address of a uint8 variable that stores the value of the flag.
// GetUint8 return the uint8 value of a flag with the given name
// -- uint8 Value
"// Uint8P is like Uint8, but accepts a shorthand letter that can be used after a single dash."
// The argument p points to a uint8 variable in which to store the value of the flag.
"// Uint8Var defines a uint8 flag with specified name, default value, and usage string."
"// Uint8VarP is like Uint8Var, but accepts a shorthand letter that can be used after a single dash."
"// Uint8 defines a uint8 flag with specified name, default value, and usage string."
"// Uint64VarP is like Uint64Var, but accepts a shorthand letter that can be used after a single dash."
"// Uint64 defines a uint64 flag with specified name, default value, and usage string."
// -- uint64 Value
// The argument p points to a uint64 variable in which to store the value of the flag.
"// Uint64Var defines a uint64 flag with specified name, default value, and usage string."
"// Uint64P is like Uint64, but accepts a shorthand letter that can be used after a single dash."
// The return value is the address of a uint64 variable that stores the value of the flag.
// GetUint64 return the uint64 value of a flag with the given name
"// String defines a ""native"" format for this net.IP slice flag value."
"// If Set is called on a flag that already has a []net.IP assigned, the newly converted values will be appended."
// read flag arguments with CSV parser
// The argument p points to a []net.IP variable in which to store the value of the flag.
"// IPSliceVarP is like IPSliceVar, but accepts a shorthand letter that can be used after a single dash."
"// IPSliceVar defines a []net.IP flag with specified name, default value, and usage string."
// Type returns a string that uniquely represents this flag's type.
// The return value is the address of a []net.IP variable that stores the value of the flag.
"// Set converts, and assigns, the comma-separated IP argument string representation as the []net.IP value of this flag."
// The return value is the address of a []net.IP variable that stores the value of that flag.
"// IPSliceP is like IPSlice, but accepts a shorthand letter that can be used after a single dash."
"// IPSliceVar defines a ipSlice flag with specified name, default value, and usage string."
// remove all quote characters
// GetIPSlice returns the []net.IP value of a flag with the given name
"// IPSlice defines a []net.IP flag with specified name, default value, and usage string."
// parse ip values into slice
// -- ipSlice Value
// Emtpy string would cause a slice with one (empty) entry
// -- float64 Value
"// Float64VarP is like Float64Var, but accepts a shorthand letter that can be used after a single dash."
// The argument p points to a float64 variable in which to store the value of the flag.
"// Float64 defines a float64 flag with specified name, default value, and usage string."
"// Float64P is like Float64, but accepts a shorthand letter that can be used after a single dash."
// GetFloat64 return the float64 value of a flag with the given name
// The return value is the address of a float64 variable that stores the value of the flag.
"// Float64Var defines a float64 flag with specified name, default value, and usage string."
// The argument p points to an int32 variable in which to store the value of the flag.
"// Int32VarP is like Int32Var, but accepts a shorthand letter that can be used after a single dash."
// The return value is the address of an int32 variable that stores the value of the flag.
"// Int32P is like Int32, but accepts a shorthand letter that can be used after a single dash."
// -- int32 Value
// GetInt32 return the int32 value of a flag with the given name
"// Int32 defines an int32 flag with specified name, default value, and usage string."
"// Int32Var defines an int32 flag with specified name, default value, and usage string."
// Remember the default value as a string; it won't change.
// reflection.
"// Ex: if the golang flag was -v, allow both -v and --v to work"
// If the *flag.Flag.Name was a single character (ex: `v`) it will be accessiblei
// PFlagFromGoFlag will return a *pflag.Flag given a *flag.Flag
// character (ex: `verbose`) it will only be accessible via `--verbose`
// AddGoFlagSet will add the given *flag.FlagSet to the pflag.FlagSet
"// If the flag.Value happens to also be a pflag.Value, just use it directly."
// with both `-v` and `--v` in flags. If the golang flag was more than a single
// difference here is the addition of the Type method that returns a string
// Looks like golang flags don't set DefValue correctly  :-(
// Use of this source code is governed by a BSD-style
// We are just copying the boolFlag interface out of goflag as that is what
// license that can be found in the LICENSE file.
// flagValueWrapper implements pflag.Value around a flag.Value.  The main
// Copyright 2009 The Go Authors. All rights reserved.
// AddGoFlag will add the given *flag.Flag to the pflag.FlagSet
"// name of the type.  As this is generally unknown, we approximate that with"
"// they use to decide if a flag should get ""true"" when no arg is given."
// GetIPNet return the net.IPNet value of a flag with the given name
// IPNet adapts net.IPNet for use as a flag.
// The return value is the address of an net.IPNet variable that stores the value of the flag.
"// IPNetP is like IPNet, but accepts a shorthand letter that can be used after a single dash."
// The argument p points to an net.IPNet variable in which to store the value of the flag.
"// IPNet defines an net.IPNet flag with specified name, default value, and usage string."
"// IPNetVar defines an net.IPNet flag with specified name, default value, and usage string."
"// IPNetVarP is like IPNetVar, but accepts a shorthand letter that can be used after a single dash."
"// Int16P is like Int16, but accepts a shorthand letter that can be used after a single dash."
"// Int16 defines an int16 flag with specified name, default value, and usage string."
// The argument p points to an int16 variable in which to store the value of the flag.
// The return value is the address of an int16 variable that stores the value of the flag.
// GetInt16 returns the int16 value of a flag with the given name
// -- int16 Value
"// Int16Var defines an int16 flag with specified name, default value, and usage string."
"// Int16VarP is like Int16Var, but accepts a shorthand letter that can be used after a single dash."
"// Int8Var defines an int8 flag with specified name, default value, and usage string."
// -- int8 Value
"// Int8VarP is like Int8Var, but accepts a shorthand letter that can be used after a single dash."
// The argument p points to an int8 variable in which to store the value of the flag.
// GetInt8 return the int8 value of a flag with the given name
// The return value is the address of an int8 variable that stores the value of the flag.
"// Int8P is like Int8, but accepts a shorthand letter that can be used after a single dash."
"// Int8 defines an int8 flag with specified name, default value, and usage string."
// Arg returns the i'th command-line argument.  Arg(0) is the first remaining argument
// returns the error.
// special case above)
// are defined and before flags are accessed by the program.
// boolean flags only
// we do not want to lose arg in this case
"// Given ""a `name` to show"" it returns (""name"", ""a name to show"")."
// '--flag' (arg was required)
"// of strings by giving the slice the methods of Value; in particular, Set would"
// Now wrap the rest
// '--flag arg'
// allowing wrapN to go a bit over if that would fit in the
// Var defines a flag with the specified name and usage string. The type and
"// ShorthandLookup returns the Flag structure of the short handed flag,"
// continue to function but will not show up in help or usage messages. Using
// after all flags are defined and before flags are accessed by the program.
// mixed
// arguments after flags
// MarkHidden sets a flag to 'hidden' in your program. It will continue to
// By default it prints a simple header and calls PrintDefaults; for details about the
// Parsed returns true if the command-line flags have been parsed.
// defined and before flags are accessed by the program.
// ErrHelp is the error returned if the flag -help is invoked but no such flag is defined.
// Init sets the name and error handling property for a flag set.
// look up the flag that will also be translated. So it would be possible to create
// VisitAll visits the flags in lexicographical order or
// before the -- and which came after.
// used by cobra.Command bash autocomple code
// PrintDefaults prints to standard error the default values of all defined command-line flags.
// that are not hidden.
// A Flag represents the state of a flag.
"// If the shorthand of this flag is deprecated, this string is the new or now thing to use"
// ParseErrorsWhitelist defines the parsing errors that can be ignored
// one-letter abbreviated flag
// Wraps the string `s` to a maximum width `w` with leading indent
"// Handle first line, which is indented by the caller (or the"
// help message
"// ""--getUrl"" which may also be translated to ""geturl"" and everything will work."
"// It visits all flags, even those not set."
"// usage calls the Usage method for the flag set, or the usage function if"
// '-farg'
// The function is a variable that may be changed to point to a custom function.
// for all flags in the FlagSet. Wrapped to `cols` columns (0 for no
"// If output is nil, os.Stderr is used."
// after flags have been processed.
// '-f' (arg was required)
"// Parse parses flag definitions from the argument list, which should not"
// Remember the default value as a string; it won't change.
"// By default, the zero FlagSet uses an empty name and the"
// VisitAll visits the command-line flags in lexicographical order or
// failf prints to standard error a formatted error and usage message and
// default value (as text); if the flag is on the command line without any options
// Visit visits the command-line flags in lexicographical order or
// we should wrap the text.
// space between indent i and end of line width w into which
// NArg is the number of arguments remaining after flags have been processed.
"// lookup returns the Flag structure of the named flag, returning nil if none exists."
// Flags added to the FlagSet will be translated and then when anything tries to
// ContinueOnError error handling policy.
// If the user set the value (or if left to default)
// SetAnnotation allows one to set arbitrary annotations on a flag in the FlagSet.
// Parse parses the command-line flags from os.Args[1:].  Must be called
// remainder of the line.
// func to return a given type for a given flag name
"// Try to avoid short orphan words on the final line, by"
// Parsed reports whether f.Parse has been called.
// function but will not show up in help or usage messages.
// The arguments for fn are flag and value. Must be called after all flags are
// otherwise
"// Beginning in Go 1.7, duration zero values are ""0s"""
// This is sometimes used by spf13/cobra programs which want to generate additional
// avoid short orphan words on the final line).
// FlagUsages returns a string containing the usage information for all flags in
// accessed by the program. The return value will be ErrHelp if -help was set
// this flag will also print the given usageMessage.
// Splits the string `s` on whitespace into an initial substring up to
// license that can be found in the LICENSE file.
// string for a flag and returns it and the un-quoted usage.
// for how to write your own usage function.
// help/usage messages.
// `i` runes in length and the remainder. Will go `slop` over `i` if
// boolean flags
// This special character will be replaced with spacing once the
// include the command name.  Must be called after all flags in the FlagSet
// defaultIsZeroValue returns true if the default value for this flag represents
// UnknownFlags will ignore unknown flags errors and continue parsing rest of the flags
// Usage is the function called when an error occurs while parsing flags.
// Not enough space for sensible wrapping. Wrap as a block on
// found during arg parsing. This allows your program to know which args were
// '-f=arg arg ...'
// value as set
// '--flag' (arg was optional)
"// If a flag doesn't exist, it wasn't changed...."
// It visits only those flags that have been set.
"// Lookup returns the Flag structure of the named flag, returning nil if none exists."
"// a flag named ""getURL"" and have it translated to ""geturl"".  A user could then pass"
// Usage prints to standard error a usage message documenting all defined command-line flags.
// SetInterspersed sets whether to support interspersed option/non-option arguments.
// for the FlagSet (e.g. making '-' and '_' equivalent).
"// ParseAll parses flag definitions from the argument list, which should not"
// FlagUsagesWrapped returns a string containing the usage information
"// Lookup returns the Flag structure of the named command-line flag,"
// name as it appears on command line
"// typically holds a user-defined implementation of Value. For instance, the"
// SetOutput sets the destination for usage and error messages.
// The return value will be ErrHelp if -help was set but not defined.
// The field is a function (not a method) that may be changed to point to
// ErrorHandling defines how to handle flag parsing errors.
// ParseAll parses the command-line flags from os.Args[1:] and called fn for each.
// ArgsLenAtDash will return the length of f.Args at the moment when a -- was
// '--flag=arg'
// AddFlagSet adds one FlagSet to another. If a flag is already present in f
"// CommandLine is the default set of command-line flags, parsed from os.Args."
// decompose the comma-separated string into the slice.
// defaultUsage is the default function to print a usage message.
"// It panics, if len(name) > 1."
// a zero value.
// A FlagSet represents a set of defined flags.
// GetNormalizeFunc returns the previously set NormalizeFunc of a function which
// NormalizedName is a flag name that has been normalized according to rules
// Visit visits the flags in lexicographical order or
// ExitOnError will call os.Exit(2) if an error is found when parsing
"// SortFlags is used to indicate, if user wants to have sorted flags in"
// Happens only if flags are declared with identical names
"// otherwise, the default values of all defined flags in the set."
// (The default value is represented as a string.)
// Set sets the value of the named command-line flag.
// HasFlags returns a bool to indicate if the FlagSet has any flags defined.
// nil means stderr; use out() accessor
// Args returns the non-flag arguments.
// `i`. The first line is not indented (this is assumed to be done by
// returning nil if none exists.
// MarkShorthandDeprecated will mark the shorthand of a flag deprecated in your
"// If there are no back quotes, the name is an educated guess of the"
// Args returns the non-flag command-line arguments.
// the flag set is CommandLine.
// ParseErrorsWhitelist is used to configure a whitelist of errors
"// does no translation, if not set previously."
// the next line instead.
// Arg returns the i'th argument.  Arg(0) is the first remaining argument
// Only one back quote; use type name.
"// ""shorthands"" can be a series of shorthand letters of flags (e.g. ""-vvv"")."
"// NewFlagSet returns a new, empty flag set with the specified name,"
// HasAvailableFlags returns a bool to indicate if the FlagSet has any flags
// NFlag returns the number of command-line flags that have been set.
"// in primordial order if f.SortFlags is false, calling fn for each."
// bash completion information.
// but not defined.
// wrapping)
// sortFlags returns the flags as a slice in lexicographical sorted order.
// used by cobra.Command to allow flags to be hidden from help/usage text
// correct alignment is calculated
// ContinueOnError will return an err from Parse() if an error is found
// Ignore errors; CommandLine is set for ExitOnError.
// include the command name. The arguments for fn are flag and value. Must be
// allow interspersed option/non-option args
// '-f' (arg was optional)
"// type of the flag's value, or the empty string if the flag is boolean."
// caller could create a flag that turns a comma-separated string into a slice
// the flag from newSet will be ignored.
// AddFlag will add the flag to the FlagSet
// messages. Using this flag will also print the given usageMessage.
// --unknown=unknownval arg ...
"// len(args) when a '--' was located when parsing, or -1 if no --"
"// VarPF is like VarP, but returns the flag created"
// '-f arg'
// called after all flags in the FlagSet are defined and before flags are
"// If this flag is deprecated, this string is the new or now thing to use"
// default value (as text); for usage message
// SetNormalizeFunc allows you to add a function which can translate flag names.
// caller). Pass `w` == 0 to do no wrapping
// UnquoteUsage extracts a back-quoted name from the usage
"// ""--"" terminates the flags"
// a custom error handler.
// '-f=arg'
// Value is the interface to the dynamic value stored in a flag.
// the FlagSet
// NFlag returns the number of flags that have been set.
// Use of this source code is governed by a BSD-style
// program. It will continue to function but will not show up in help or usage
"// PrintDefaults prints, to standard error unless configured"
// error handling property and SortFlags set to true.
// maxlen + 2 comes from + 1 for the \x00 and + 1 for the (deliberate) off-by-one in maxlen-sidx
// PanicOnError will panic() if an error is found when parsing flags
"// value of the flag are represented by the first argument, of type Value, which"
// If still not enough space then don't even try to wrap.
// non-boolean flags
// because it serves (via godoc flag Usage) as the example
"// VarP is like Var, but accepts a shorthand letter that can be used after a single dash."
// NOTE: Usage is not just defaultUsage(CommandLine)
// Changed returns true if the flag was explicitly set during Parse() and false
// MarkDeprecated indicated that a flag is deprecated in your program. It will
// Set sets the value of the named flag.
// that encompasses the entire string (which allows the caller to
// Copyright 2009 The Go Authors. All rights reserved.
"// format of the output and how to control it, see the documentation for PrintDefaults."
"// Look for a back-quoted name, but avoid the strings package."
// only on flags without a default value
"// boolean flags, or flags with no option default values"
// non-boolean and flags without a 'no option default value'
// boolean or flags where the 'no option default value' is set
// hide a flag by specifying its name
// mixed
// deprecate a flag by specifying its name and a usage message
// deprecate a flag shorthand by specifying its flag name and a usage message
"// IntVar defines an int flag with specified name, default value, and usage string."
"// IntP is like Int, but accepts a shorthand letter that can be used after a single dash."
// The argument p points to an int variable in which to store the value of the flag.
"// Int defines an int flag with specified name, default value, and usage string."
// The return value is the address of an int variable that stores the value of the flag.
"// IntVarP is like IntVar, but accepts a shorthand letter that can be used after a single dash."
// -- int Value
// GetInt return the int value of a flag with the given name
"// DurationSliceVar defines a durationSlice flag with specified name, default value, and usage string."
// The return value is the address of a []time.Duration variable that stores the value of the flag.
// The argument p points to a duration[] variable in which to store the value of the flag.
// GetDurationSlice returns the []time.Duration value of a flag with the given name
"// DurationSlice defines a []time.Duration flag with specified name, default value, and usage string."
// The argument p points to a []time.Duration variable in which to store the value of the flag.
// Empty string would cause a slice with one (empty) entry
"// DurationSliceP is like DurationSlice, but accepts a shorthand letter that can be used after a single dash."
"// DurationSliceVarP is like DurationSliceVar, but accepts a shorthand letter that can be used after a single dash."
"// DurationSliceVar defines a duration[] flag with specified name, default value, and usage string."
// -- durationSlice Value
"// Count defines a count flag with specified name, default value, and usage string."
"// ""+1"" means that no specific value was passed, so increment"
// The argument p points to an int variable in which to store the value of the flag.
// -- count Value
// CountVar like CountVar only the flag is placed on the CommandLine instead of a given flag set
// The return value is the address of an int variable that stores the value of the flag.
"// CountVar defines a count flag with specified name, default value, and usage string."
// GetCount return the int value of a flag with the given name
// A count flag will add 1 to its value evey time it is found on the command line
// CountP is like Count only takes a shorthand for the flag name.
// CountVarP is like CountVar only take a shorthand for the flag name.
// GetUint32 return the uint32 value of a flag with the given name
// -- uint32 value
// The return value is the address of a uint32  variable that stores the value of the flag.
// The argument p points to a uint32  variable in which to store the value of the flag.
"// Uint32VarP is like Uint32Var, but accepts a shorthand letter that can be used after a single dash."
// The argument p points to a uint32 variable in which to store the value of the flag.
"// Uint32P is like Uint32, but accepts a shorthand letter that can be used after a single dash."
"// Uint32Var defines a uint32 flag with specified name, default value, and usage string."
"// Uint32 defines a uint32 flag with specified name, default value, and usage string."
"// BytesBase64VarP is like BytesBase64Var, but accepts a shorthand letter that can be used after a single dash."
"// BytesBase64P is like BytesBase64, but accepts a shorthand letter that can be used after a single dash."
"// BytesHex defines an []byte flag with specified name, default value, and usage string."
"// BytesHexP is like BytesHex, but accepts a shorthand letter that can be used after a single dash."
// Type implements pflag.Value.Type.
// String implements pflag.Value.String.
// The argument p points to an []byte variable in which to store the value of the flag.
// The return value is the address of an []byte variable that stores the value of the flag.
// BytesBase64 adapts []byte for use as a flag. Value of flag is Base64 encoded
"// BytesBase64 defines an []byte flag with specified name, default value, and usage string."
// Set implements pflag.Value.Set.
"// BytesHexVarP is like BytesHexVar, but accepts a shorthand letter that can be used after a single dash."
// GetBytesHex return the []byte value of a flag with the given name
"// BytesBase64Var defines an []byte flag with specified name, default value, and usage string."
// BytesHex adapts []byte for use as a flag. Value of flag is HEX encoded
"// BytesHexVar defines an []byte flag with specified name, default value, and usage string."
// GetBytesBase64 return the []byte value of a flag with the given name
"// Uint16Var defines a uint flag with specified name, default value, and usage string."
// -- uint16 value
"// Uint16P is like Uint16, but accepts a shorthand letter that can be used after a single dash."
// The argument p points to a uint variable in which to store the value of the flag.
"// Uint16 defines a uint flag with specified name, default value, and usage string."
// GetUint16 return the uint16 value of a flag with the given name
"// Uint16VarP is like Uint16Var, but accepts a shorthand letter that can be used after a single dash."
// The return value is the address of a uint  variable that stores the value of the flag.
// The argument p points to a uint  variable in which to store the value of the flag.
// -- net.IP value
// The argument p points to an net.IP variable in which to store the value of the flag.
// GetIP return the net.IP value of a flag with the given name
"// IP defines an net.IP flag with specified name, default value, and usage string."
"// IPVar defines an net.IP flag with specified name, default value, and usage string."
"// IPVarP is like IPVar, but accepts a shorthand letter that can be used after a single dash."
// The return value is the address of an net.IP variable that stores the value of the flag.
"// IPP is like IP, but accepts a shorthand letter that can be used after a single dash."
// ParseIPv4Mask written in IP form (e.g. 255.255.255.0).
// This function should really belong to the net package.
// so write a horrible parser for that as well  :-(
"// IPMaskP is like IPMask, but accepts a shorthand letter that can be used after a single dash."
"// IPMaskP is like IP, but accepts a shorthand letter that can be used after a single dash."
"// IPMaskVarP is like IPMaskVar, but accepts a shorthand letter that can be used after a single dash."
// -- net.IPMask value
// GetIPv4Mask return the net.IPv4Mask value of a flag with the given name
"// IPMask defines an net.IPMask flag with specified name, default value, and usage string."
// The return value is the address of an net.IPMask variable that stores the value of the flag.
// net.IPMask.String() actually outputs things like ffffff00
"// IPMaskVar defines an net.IPMask flag with specified name, default value, and usage string."
// The argument p points to an net.IPMask variable in which to store the value of the flag.
"// StringSlice defines a string flag with specified name, default value, and usage string."
// The argument p points to a []string variable in which to store the value of the flag.
// GetStringSlice return the []string value of a flag with the given name
// For example:
// will result in
// The return value is the address of a []string variable that stores the value of the flag.
// An empty string would cause a slice with one (empty) string
"// StringSliceVarP is like StringSliceVar, but accepts a shorthand letter that can be used after a single dash."
"// StringSliceVar defines a string flag with specified name, default value, and usage string."
"// Compared to StringArray flags, StringSlice flags take comma-separated value as arguments and split them accordingly."
"// StringSliceP is like StringSlice, but accepts a shorthand letter that can be used after a single dash."
"//   []string{""v1"", ""v2"", ""v3""}"
// -- stringSlice Value
"//   --ss=""v1,v2"" -ss=""v3"""
// GetStringToInt return the map[string]int value of a flag with the given name
// The value of each argument will not try to be separated by comma
// -- stringToInt Value
"// StringToInt defines a string flag with specified name, default value, and usage string."
"// StringToIntVar defines a string flag with specified name, default value, and usage string."
// The return value is the address of a map[string]int variable that stores the value of the flag.
// The argument p points to a map[string]int variable in which to store the values of the multiple flags.
// The argument p points to a map[string]int variable in which to store the value of the flag.
// An empty string would cause an empty map
"// StringToIntP is like StringToInt, but accepts a shorthand letter that can be used after a single dash."
"// StringToIntVarP is like StringToIntVar, but accepts a shorthand letter that can be used after a single dash."
"// Format: a=1,b=2"
"// IntSliceP is like IntSlice, but accepts a shorthand letter that can be used after a single dash."
// The return value is the address of a []int variable that stores the value of the flag.
"// IntSliceVarP is like IntSliceVar, but accepts a shorthand letter that can be used after a single dash."
// Empty string would cause a slice with one (empty) entry
// The argument p points to a []int variable in which to store the value of the flag.
// The argument p points to a int[] variable in which to store the value of the flag.
// GetIntSlice return the []int value of a flag with the given name
// -- intSlice Value
"// IntSlice defines a []int flag with specified name, default value, and usage string."
"// IntSliceVar defines a int[] flag with specified name, default value, and usage string."
"// IntSliceVar defines a intSlice flag with specified name, default value, and usage string."
"// BoolSliceVar defines a []bool flag with specified name, default value, and usage string."
// read flag arguments with CSV parser
"// BoolSliceP is like BoolSlice, but accepts a shorthand letter that can be used after a single dash."
"// BoolSliceVarP is like BoolSliceVar, but accepts a shorthand letter that can be used after a single dash."
// parse boolean values into slice
// -- boolSlice Value
"// BoolSlice defines a []bool flag with specified name, default value, and usage string."
// The return value is the address of a []bool variable that stores the value of the flag.
"// String defines a ""native"" format for this boolean slice flag value."
// GetBoolSlice returns the []bool value of a flag with the given name.
"// BoolSliceVar defines a boolSlice flag with specified name, default value, and usage string."
// Empty string would cause a slice with one (empty) entry
// remove all quote characters
"// If Set is called on a flag that already has a []bool assigned, the newly converted values will be appended."
// The argument p points to a []bool variable in which to store the value of the flag.
// Type returns a string that uniquely represents this flag's type.
"// Set converts, and assigns, the comma-separated boolean argument string representation as the []bool value of this flag."
"// supplied without ""=value"" text"
"// Bool defines a bool flag with specified name, default value, and usage string."
// -- bool Value
// GetBool return the bool value of a flag with the given name
"// BoolVar defines a bool flag with specified name, default value, and usage string."
// The return value is the address of a bool variable that stores the value of the flag.
"// BoolP is like Bool, but accepts a shorthand letter that can be used after a single dash."
// The argument p points to a bool variable in which to store the value of the flag.
"// BoolVarP is like BoolVar, but accepts a shorthand letter that can be used after a single dash."
// optional interface to indicate boolean flags that can be
// GetInt64 return the int64 value of a flag with the given name
"// Int64 defines an int64 flag with specified name, default value, and usage string."
// The argument p points to an int64 variable in which to store the value of the flag.
"// Int64VarP is like Int64Var, but accepts a shorthand letter that can be used after a single dash."
"// Int64Var defines an int64 flag with specified name, default value, and usage string."
"// Int64P is like Int64, but accepts a shorthand letter that can be used after a single dash."
// -- int64 Value
// The return value is the address of an int64 variable that stores the value of the flag.
// GetUintSlice returns the []uint value of a flag with the given name.
// The argument p points to a uint[] variable in which to store the value of the flag.
"// UintSliceP is like UintSlice, but accepts a shorthand letter that can be used after a single dash."
"// UintSliceVar defines a uintSlice flag with specified name, default value, and usage string."
// The return value is the address of a []uint variable that stores the value of the flag.
"// UintSliceVarP is like UintSliceVar, but accepts a shorthand letter that can be used after a single dash."
"// UintSliceVar defines a uint[] flag with specified name, default value, and usage string."
"// UintSlice defines a []uint flag with specified name, default value, and usage string."
// Empty string would cause a slice with one (empty) entry
// The argument p points to a []uint variable in which to store the value of the flag.
// -- uintSlice Value
"// UintSliceVarP is like the UintSliceVar, but accepts a shorthand letter that can be used after a single dash."
// GetUint return the uint value of a flag with the given name
// The argument p points to a uint variable in which to store the value of the flag.
"// UintVar defines a uint flag with specified name, default value, and usage string."
"// UintVarP is like UintVar, but accepts a shorthand letter that can be used after a single dash."
// -- uint Value
// The return value is the address of a uint  variable that stores the value of the flag.
"// Uint defines a uint flag with specified name, default value, and usage string."
"// UintP is like Uint, but accepts a shorthand letter that can be used after a single dash."
// The argument p points to a uint  variable in which to store the value of the flag.
// The value of each argument will not try to be separated by comma
// An empty string would cause an empty map
// The argument p points to a map[string]string variable in which to store the value of the flag.
"// StringToStringVarP is like StringToStringVar, but accepts a shorthand letter that can be used after a single dash."
// The argument p points to a map[string]string variable in which to store the values of the multiple flags.
"// StringToStringP is like StringToString, but accepts a shorthand letter that can be used after a single dash."
"// StringToStringVar defines a string flag with specified name, default value, and usage string."
"// StringToString defines a string flag with specified name, default value, and usage string."
// -- stringToString Value
// The return value is the address of a map[string]string variable that stores the value of the flag.
// GetStringToString return the map[string]string value of a flag with the given name
"// Format: a=1,b=2"
// The argument p points to a time.Duration variable in which to store the value of the flag.
"// Duration defines a time.Duration flag with specified name, default value, and usage string."
// -- time.Duration Value
// The return value is the address of a time.Duration variable that stores the value of the flag.
"// DurationVar defines a time.Duration flag with specified name, default value, and usage string."
"// DurationVarP is like DurationVar, but accepts a shorthand letter that can be used after a single dash."
// GetDuration return the duration value of a flag with the given name
"// DurationP is like Duration, but accepts a shorthand letter that can be used after a single dash."
"// StringArrayP is like StringArray, but accepts a shorthand letter that can be used after a single dash."
// An empty string would cause a array with one (empty) string
// The argument p points to a []string variable in which to store the value of the flag.
// The return value is the address of a []string variable that stores the value of the flag.
// GetStringArray return the []string value of a flag with the given name
// The value of each argument will not try to be separated by comma. Use a StringSlice for that.
"// StringArrayVar defines a string flag with specified name, default value, and usage string."
"// StringArray defines a string flag with specified name, default value, and usage string."
// The argument p points to a []string variable in which to store the values of the multiple flags.
"// StringArrayVarP is like StringArrayVar, but accepts a shorthand letter that can be used after a single dash."
// -- stringArray Value
// ResetLogCounters resets the invocation counters for all levels.
"//
// Use of this source code is governed by an MIT-style"
// LogCountForLevelsGreaterThanorEqualTo returns the number of log invocations
// LogCountForLevel returns the number of log invocations for a given threshold.
// license that can be found in the LICENSE file.
// Copyright © 2016 Steve Francia <spf@spf13.com>.
// greater than or equal to a given threshold.
// not printed to the terminal. 
// it. It will be printed to the terminal as well as logged under the
// discarded.
// This error isn’t going to materially change the behavior of the
"// Information that’s relevant to what’s happening, but not very"
// This is a pretty serious error and the user should know about
"// expects. Under the default thresholds, Warn will be logged, but"
// default thresholds.
// important for the user. Under the default thresholds this will be
"// application, but it’s something that may not be what the user"
// Level returns the current global output threshold.
// ResetLogCounters resets the invocation counters for all levels.
// greater than or equal to a given threshold.
// SetStdoutThreshold set the standard output threshold for the default notepad.
// GetStdoutThreshold returns the Treshold for the stdout logger.
"//
// Use of this source code is governed by an MIT-style"
// Info by default.
// SetLogThreshold set the log threshold for the default notepad. Trace by default.
// LogCountForLevelsGreaterThanorEqualTo returns the number of log invocations
// LogCountForLevel returns the number of log invocations for a given threshold.
"// SetFlags set the flags for the default logger. ""log.Ldate | log.Ltime"" by default."
// license that can be found in the LICENSE file.
// Copyright © 2016 Steve Francia <spf@spf13.com>.
// Level returns the current global log threshold.
// GetStdoutThreshold returns the defined Treshold for the log logger.
// SetLogOutput set the log output for the default notepad. Discarded by default.
// SetPrefix set the prefix for the default logger. Empty by default.
"// logging with the standard extra information (date, file, etc)."
// SetFlags choose which flags the logger will display (after prefix and message
// SetPrefix changes the prefix used by the notepad. Prefixes are displayed between
// log file.
// GetStdoutThreshold returns the Treshold for the stdout logger.
// for performance.
// NewNotepad create a new notepad.
// SetStdoutThreshold changes the threshold above which messages are written to the
// One per Threshold
"// counter doesn't care about prefix and flags, so don't use them"
// GetStdoutThreshold returns the defined Treshold for the log logger.
// SetLogThreshold changes the threshold above which messages are written to the
// standard output.
// level). See the package log for more informations on this.
// license that can be found in the LICENSE file.
// Notepad is where you leave a note!
// Copyright © 2016 Steve Francia <spf@spf13.com>.
// brackets at the beginning of the line. An empty prefix won't be displayed at all.
// Feedback writes plainly to the outHandle while
// SetLogOutput changes the file where log messages are written.
// init creates the loggers for each level depending on the notepad thresholds.
"//
// Use of this source code is governed by an MIT-style"
// => replace with a new map
"// from the file system, or a remote key/value store."
// nested map: recursively insensitivise
"// if so, create a copy and lower-case the keys recursively."
"// a new map is created and inserted, and the search continues from there:"
// continue search from here
"// copyAndInsensitiviseMap behaves like insensitiviseMap, but creates a copy of"
// update map
// nested map: cast and recursively insensitivise
"// sequence ""path""."
"// via flags, ENVIRONMENT variables, configuration files retrieved"
"// The last value is expected to be another map, and is returned."
"// the initial map ""m"" may be modified!"
// license that can be found in the LICENSE file.
// toCaseInsensitiveValue checks if the value is a  map;
// intermediate key does not exist
"// deepSearch scans deep maps, following the key indexes listed in the"
// any map it makes case insensitive.
// Viper is a application configuration system.
// Copyright © 2014 Steve Francia <spf@spf13.com>.
"//
// Use of this source code is governed by an MIT-style"
// parseSizeInBytes converts strings like 1GB or 12 mb into an unsigned integer number of bytes
// => create it and continue from there
"//
// In case intermediate keys do not exist, or map to a non-map value,"
// It believes that applications can be configured a variety of ways
// Check if File / Directory Exists
// intermediate key is a value
// Error returns the formatted configuration error.
// ConfigParseError denotes failing to parse configuration file.
// remove old key (not lower-cased)
// to implement a signal to notify the system of the changes
// ...
// Need to explicitly set this to json
// Handle errors reading the config file
// unmarshal config
// name of config file (without extension)
"// or viper.SetConfigType(""YAML"")"
// Find and read the config file
// optionally look for config in the working directory
// same result as next line
// any approach to require this configuration into your program.
// open a goroutine to watch remote changes forever
"// currently, only tested with etcd support"
// 13
"// this would be ""steve"""
// case-insensitive Setting & Getting
"// alternatively, you can create a new viper instance."
// 8080
// call multiple times to add many search paths
// retrieve values from viper instead of pflag
"// returns ""0.0.0.0"""
// same result as prior line
// read from remote config the first time.
// retrieve value from viper
"// using standard library ""flag"" package"
// will be uppercased automatically
"// because there is no file extension in a stream of bytes,  supported extensions are ""json"", ""toml"", ""yaml"", ""yml"", ""properties"", ""props"", ""prop"""
// typically done outside of the app
// myhostname.com
// path to look for the config file in
// unmarshal new config into our runtime config struct. you can also use channel
"// (returns ""127.0.0.1"")"
// delay after each request
"// because there is no file extension in a stream of bytes, supported extensions are ""json"", ""toml"", ""yaml"", ""yml"", ""properties"", ""props"", ""prop"""
// true
// ValueString returns the value of the flag as a string.
// that implements FlagValueSet.
// VisitAll iterates over all *pflag.Flag inside the *pflag.FlagSet.
// ValueType returns the type of the flag as a string.
// to bind a set of flags to viper.
// FlagValue is an interface that users can implement
// HasChanges returns whether the flag has changes or not.
// Name returns the name of the flag.
// FlagValueSet is an interface that users can implement
// to bind different flags to viper.
// pflagValue is a wrapper aroung *pflag.flag
// pflagValueSet is a wrapper around *pflag.ValueSet
// that implements FlagValue
// GetSizeInBytes returns the size of the value associated with the given key
// GetUint64 returns the value associated with the key as an unsigned integer.
// and read it in the remote configuration registry.
"//		mapstructure.StringToSliceHookFunc("",""),"
// GetInt returns the value associated with the key as an integer.
"// in the environment, when automatic env is on."
// can use it in their testing as well.
// BindPFlag binds a specific key to a pflag (as used by cobra).
"// is set via an environment variable to ""a b c"", a call to the Get function"
"// add all paths, by order of descending priority to ensure correct shadowing"
"//
func BindPFlag(key string, flag *pflag.Flag) error { return v.BindPFlag(key, flag) }"
// GetStringMapStringSlice returns the value associated with the key as a map to a slice of strings.
// AllSettings merges all settings and returns them as a map[string]interface{}.
// SetConfigType sets the type of the configuration returned by the
"// ReadConfig will read a configuration file, setting existing keys to nil if the"
// mapstructure.DecoderConfig options
"// last item, no need to check shadowing"
"//
func BindFlagValue(key string, flag FlagValue) error { return v.BindFlagValue(key, flag) }"
"// even if it hasn't been registered, if automaticEnv is used,"
// A DecoderConfigOption can be passed to viper.Unmarshal to configure
// Returns the first path that exists (and is a config file).
// 2 - if the real path to the config file changed (eg: k8s ConfigMap replacement)
// ConfigMarshalError happens when failing to marshal the configuration.
// scan intermediate paths
"// of key paths (used as a set, easier to manipulate than a []string):"
// This will only be used if the configuration read is a properties file.
"//
// For example, if a key has a default value of []string{} and the same key"
// Delimiter that separates a list of keys
"// function searches for, and prioritizes, merged path elements."
// on its path in the map.
"// If alias passed in, then set the proper default"
// 'Errors' channel is not closed
// set innermost value
// Nested case
"// mergeFlatMap merges the given maps, excluding values of the second map"
"// e.g., if ""foo.bar"" has a value in the environment, it “shadows”"
// not match it.
// flattenAndMergeMap recursively flattens the given map into a map[string]bool
"// not found, no need to add more path elements"
"// name, we'll never be able to get that value using the original"
// Type assertion is safe here since it is only reached
// DecodeHook returns a DecoderConfigOption which overrides the default
// add key
"// SetConfigFile explicitly defines the path, name and extension of the config file."
// searchMapWithPathPrefixes recursively searches for a value for path in source map.
// PFlag override next
"// from the file system, or a remote key/value store."
"//  	""secret"": ""defaultsecret"""
// you should set path to /configs and set config name (SetConfigName()) to
// SetEnvKeyReplacer sets the strings.Replacer on the viper object
"// name, so move the config value to the new realkey."
// Example (where serverCmd is a Cobra instance):
"// parentVal is a regular value which shadows ""path"""
"// AllKeys returns all keys holding a value, regardless of where they are set."
// InConfig checks to see if the given key (or an alias) is in the config file.
// Copyright © 2014 Steve Francia <spf@spf13.com>.
// 4. config file
// AddConfigPath adds a path for Viper to search for the config file in.
"// UnmarshalExact unmarshals the config into a Struct, erroring if a field is nonexistent"
// The priority of the sources is the following:
// used to access a nested value in one go
// configuration filetype.
// check any Get request
// env
// getEnv is a wrapper around os.Getenv which replaces characters in the original
// BindEnv binds a Viper key to a ENV variable.
// Will be used instead of values obtained via
// Set is case-insensitive for a key.
// isPathShadowedInAutoEnv makes sure the given path is not shadowed somewhere
// Error returns the formatted remote provider error.
// The filesystem to read config from.
"//
//  Defaults : {"
// SafeWriteConfig writes current configuration to file only if the file does not exist.
//  Config : {
"//		""endpoint"": ""https://localhost"""
// GetViper gets the global Viper instance.
// Name of file to look for inside the path
// Set() override first
"// - if a path is shadowed by an earlier value in the initial shadow map,"
// shadowed by values from the first map.
// 2. flags
// Default next
//  }
// GetBool returns the value associated with the key as a boolean.
// key/value store
// Fast path
// Useful for mapping an environmental variable to a key that does
// if the type of `next` is the same as the type being asserted
"// ""myapp"""
"//
//	 serverCmd.Flags().Int(""port"", 1138, ""Port to run Application server on"")"
"// search for path prefixes, starting from the longest one"
// The resulting set of paths is merged to the given shadow set at the same time.
// RemoteProvider stores the configuration necessary
// 3. env. variables
"//
//   []string {""a"", ""b"", ""c""}"
"// flags, config file, ENV, default, or key/value store."
// UnsupportedConfigError denotes encountering an unsupported
"// path is shadowed, continue"
// MergeConfigMap merges the configuration from the map given with an existing config.
// we have to watch the entire directory to pick up renames/atomic saves in a cross-platform way
"//		""user"": ""root"","
// A set of paths to look for the config file in
// Store read properties on the object so that we can write back in order with comments.
// of time.Duration values & string slices
// Viper will check to see if an alias exists first.
"// If only a key is provided, it will use the env key matching the key, uppercased."
"//
// While searchMap() considers each path element as a single map key, this"
// in the destination struct.
// ReadInConfig will discover and load the configuration file from disk
"// Nested keys are returned with a v.keyDelim (= ""."") separator"
// Set sets the value for the key in the override register.
// Debug prints all configuration registries for debugging
// GetString returns the value associated with the key as a string.
// Error returns the formatted configuration error.
// Optional secretKeyring to unencrypt encrypted values
"// now, wait for event loop to end in this go-routine..."
"// BindPFlags binds a full flag set to the configuration, using each flag's long"
// Returns nil if not found.
"// AllowEmptyEnv tells Viper to consider set,"
// Viper will check in the following order:
"// should not happen, since AllKeys() returns only keys holding a value,"
"//
// Get returns an interface. For a specific value use one of the Get____ methods."
// 6. defaults
// EnvPrefix will be used when set when env name is not provided.
// searchMap recursively searches for a value for path in source map.
// ReadRemoteConfig attempts to get configuration from a remote source
// Sub returns new Viper instance representing a sub tree of this instance.
"//
// Otherwise the Get function would return:"
// opposed to the value returned based on the normal fetch logic.
// IsSet is case-insensitive for a key.
"// Default only used when no value is provided by the user via flag, config or ENV."
// RemoteConfigError denotes encountering an error while trying to
//  Env : {
// in bytes.
// convert set of paths to list
"//  	""user"": ""default"","
"// variables that start with ""SPF_""."
// SetConfigName sets name for the config file.
"// via flags, ENVIRONMENT variables, configuration files retrieved"
// 1 - if the config file was modified or created
// SetFs sets the filesystem to use to read configuration.
// This enables one to change a name without breaking the application
"//  	""user"": ""root"""
// SetConfigPermissions sets the permissions for the config file.
// scan keys
// (camel case to snake case for JSON keys perhaps)
"// - each path is merged into a single key string, delimited with v.keyDelim (= ""."")"
// Should probably be an unexported function.
// unify input map
"// maintains a set of configuration sources, fetches"
"// e.g., if in the source, ""foo"" is defined with a sub-key ""bar"", and ""foo.bar"""
// SafeWriteConfigAs writes current configuration to a given filename if it does not exist.
// endpoint is the url.  etcd requires http://ip:port  consul requires ip:port
// GetStringMap returns the value associated with the key as a map of interfaces.
// 5. key/value store
// Viper will use this and not check any of the config paths.
// GetInt64 returns the value associated with the key as an integer.
// A set of remote providers to search for the configuration
"// keys set in config, default & flags"
// UnsupportedRemoteProviderError denotes encountering an unsupported remote
// Note that the map given may be modified.
// Marshal a map into Writer.
"//  	""endpoint"": ""https://localhost"""
// ConfigFileUsed returns the file used to populate the config registry.
// would return a string slice for the key if the key's type is inferred by
// UnmarshalKey takes a single key and unmarshals it into a Struct.
// isPathShadowedInFlatMap makes sure the given path is not shadowed somewhere
"//       ""foo.bar.baz"" in a lower-priority map"
// if we alias something that exists in one of the maps to another
// In the public interface for the viper package so applications
// It believes that applications can be configured a variety of ways
"//
// This should be useful only at config level (other maps may not contain dots"
// check just in case anything changes
// SupportedRemoteProviders are universally supported remote providers.
"// override, flag, env, config file, key/value store, default"
// secretkeyring is the filepath to your openpgp secret keyring.  e.g. /etc/secrets/myring.gpg
// SetTypeByDefaultValue enables or disables the inference of a key value's
// 'Events' channel is closed
"// provider is a string value, ""etcd"" or ""consul"" are currently supported."
"// values to populate those, and provides them according"
// on the fields of the structure are properly set.
"// and key/value stores, searching in one of the defined paths."
// SetDefault sets the default value for this key.
// AddRemoteProvider adds a remote configuration source.
// GetDuration returns the value associated with the key as a duration.
"//		mapstructure.StringToTimeDurationHookFunc(),"
//   it is skipped.
// New returns an initialized Viper instance.
// key does not exist in the file.
// Viper is a application configuration system.
// GetStringSlice returns the value associated with the key as a slice of strings.
"// remote source, e.g. ""json""."
// purposes.
"//
// Use of this source code is governed by an MIT-style"
// default
// GetFloat64 returns the value associated with the key as a float64.
// Does not include extension.
// Viper is a prioritized configuration registry. It
// BindFlagValue binds a specific key to a FlagValue.
// Can be called multiple times to define multiple search paths.
"// done initalizing the watch in this go routine, so the parent routine can move on..."
// Sub is case-insensitive for a key.
// GetTime returns the value associated with the key as time.
// AutomaticEnv has Viper check ENV variables for all.
// Get has the behavior of returning the value associated with the first
// Unmarshal unmarshals the config into a Struct. Make sure that the tags
// place from where it is set. Viper will check in the following order:
"//
//	{"
// SetEnvPrefix defines a prefix that ENVIRONMENT variables will use.
"// rewriting keys many things, Ex: Get('someKey') -> some_key"
// flag
// we only care about the config file with the following cases:
"// is also defined, this latter value is returned for path [""foo"", ""bar""]."
// K/V store next
"// flag, env, config file, key/value store, default."
"// Intended for testing, will reset all to default settings."
// MergeInConfig merges a new configuration with an existing config.
"// DecoderConfig.DecodeHook value, the default is:"
// but empty environment variables as valid values instead of falling back.
// type when the Get function is used based upon a key's default value as
"// If alias passed in, then set the proper override"
"//		""secret"": ""somesecretkey"","
// GetUint returns the value associated with the key as an unsigned integer.
//	)
// can be provided.
// mergeMaps merges two maps. The `itgt` parameter is for handling go-yaml's
// 1. overrides
// Error returns the formatted remote provider error
// IsSet checks to see if the key has been set in any of the data locations.
// WriteConfigAs writes current configuration to a given filename.
"// got a value but nested key expected, return ""nil"" for not found"
// instead of using a `string` as the key for nest structures beyond one level
"// E.g. if your prefix is ""spf"", the env registry will look for env"
"// Given a key, find the value."
// `map[string]interface{}` instead.
// get the flag's value even if the flag's value has not changed
// in their keys).
// WriteConfig writes the current configuration to a file.
"// if the requested key is an alias, then return the proper key"
// Unmarshal a Reader into a map.
"//
//   ""a b c"""
// not found
"//	 Viper.BindFlagValue(""port"", serverCmd.Flags().Lookup(""port""))"
// prefix is shadowed => nothing more to flatten
// make sure that the go routine above fully ended before returning
// provider. Currently only etcd and Consul are supported.
"// got a value but nested key expected, do nothing and look for next prefix"
"//
// For example, if values from the following sources were loaded:"
"//	 Viper.BindPFlag(""port"", serverCmd.Flags().Lookup(""port""))"
// SetDefault is case-insensitive for a key.
// Config file next
// overrides
// Get can retrieve any value given the key to use.
// GetUint32 returns the value associated with the key as an unsigned integer.
// recursively merge to shadow map
// immediate value
// path is the path in the k/v store to retrieve configuration
// compute the path through the nested maps to the nested value
// ENV variables are case sensitive.
// GetInt32 returns the value associated with the key as an integer.
// Search all configPaths for any config file.
// keys.
"//
// The resulting config will have the following values:"
// Aliases provide another accessor for the same key.
// license that can be found in the LICENSE file.
// TODO: should getEnv logic be moved into find(). Can generalize the use of
// MergeConfig merges a new configuration with an existing config.
// key. This allows env vars which have different keys than the config object
"// start from the list of keys, and construct the map one value at a time"
// Env override next
// Retrieve the first found remote configuration.
// To retrieve a config file called myapp.json from /configs/myapp.json
"//  	""secret"": ""somesecretkey"""
// AddSecureRemoteProvider adds a remote configuration source.
// insistence on parsing nested structures as `map[interface{}]interface{}`
// recursively build nested maps
// deep. Both map types are supported as there is a go-yaml fork that uses
// Remote Providers are searched in the order they are added.
// Note: This assumes that the path entries and map keys are lower cased.
// Secure Remote Providers are implemented with github.com/xordataexchange/crypt
// GetStringMapString returns the value associated with the key as a map of strings.
// Get is case-insensitive for a key.
// the default value and the Get function would return:
// A wrapper around mapstructure.Decode that mimics the WeakDecode functionality
// defaultDecoderConfig returns default mapsstructure.DecoderConfig with suppot
// pull the configuration from the remote provider.
// ConfigFileNotFoundError denotes failing to find configuration file.
// to connect to a remote key/value store.
// config
"// last chance: if no other value is returned and a flag does exist for the value,"
// For backward compatibility reasons this is false by default.
"//
//  mapstructure.ComposeDecodeHookFunc("
//	}
// TODO(bep) this branch isn't covered by a single test.
// Each item takes precedence over the item below it:
// scan paths
// name as the config key.
"// BindFlagValues binds a full FlagValue set to the configuration, using each flag's long"
// SupportedExts are universally supported extensions.
// Note: this assumes a lower-cased key given.
// Secure Remote Providers are searched in the order they are added.
// to the source's priority.
"// RemoteConfig is optional, see the remote package"
"//  	""secret"": """","
// in a sub-path of the map.
"// e.g., if ""foo.bar"" has a value in the given map, it “shadows”"
// isPathShadowedInDeepMap makes sure the given path is not shadowed somewhere
"//
// Note: This assumes that the path entries and map keys are lower cased."
// indirect
// limitations under the License.
// TODO(niemeyer): Should other magic characters be added here?
// chop off trailing separator
"// Licensed under the Apache License, Version 2.0 (the ""License"");"
"// The only possible returned error is ErrBadPattern, when pattern"
// is malformed.
// and appends them to matches. If the directory cannot be
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"//
// Glob ignores file system errors such as I/O errors reading directories."
// See the License for the specific language governing permissions and
// as in Match. The pattern may describe hierarchical names such as
// http://www.apache.org/licenses/LICENSE-2.0
// glob searches for files matching pattern in the directory dir
// added in lexicographical order.
"// opened, it returns the existing matches. New matches are"
// /usr/*/bin/ed (assuming the Separator is '/').
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
// built-ins from that package.
// Lstat not supported by a ll filesystems.
// nothing
// if there is no matching file. The syntax of patterns is the same
"//
// Unless required by applicable law or agreed to in writing, software"
// recognized by Match.
// You may obtain a copy of the License at
// Copyright © 2014 Steve Francia <spf@spf13.com>.
// you may not use this file except in compliance with the License.
// Glob returns the names of all files matching pattern or nil
// hasMeta reports whether path contains any of the magic characters
"//
// This was adapted from (http://golang.org/pkg/path/filepath) and uses several"
// Copyright 2009 The Go Authors. All rights reserved.
// limitations under the License.
"//
// Licensed under the Apache License, Version 2.0 (the ""License"");"
// 	}
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
// See the License for the specific language governing permissions and
"// 	if x, ok := fs.(*MemMapFs); ok {"
// http://www.apache.org/licenses/LICENSE-2.0
"// Root should always exist, right?"
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
// 		x.List()
// func debugMemMapList(fs Fs) {
// Handle some relative paths
"//
// Unless required by applicable law or agreed to in writing, software"
"// Only return ErrFileExists if it's a file, not a directory."
// You may obtain a copy of the License at
// Copyright © 2014 Steve Francia <spf@spf13.com>.
// you may not use this file except in compliance with the License.
// }
// TODO: what about windows?
// limitations under the License.
"//
// Licensed under the Apache License, Version 2.0 (the ""License"");"
// DirExists checks if a path exists and is a directory.
// Takes a reader and a path and writes the content
// IsEmpty checks if a given file or directory is empty.
// if subPath is not empty then it will be created recursively with mode 777 rwx rwx rwx
// Copyright ©2015 Steve Francia <spf@spf13.com>
// Check if a file contains any of the specified byte slices.
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
// See the License for the specific language governing permissions and
// IsDir checks if a given path is a directory.
// Mn: nonspacing marks
// readerContains reports whether any of the subslices is within r.
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
// preserve windows backslash :-(
// Rewrite string to remove non-standard path characters
"// rwx, rw, r"
// Transform characters with accents into plain forms.
// Same as WriteReader but checks to see if file/directory already exists.
// Portions Copyright ©2015 The Hugo Authors
"//
// Unless required by applicable law or agreed to in writing, software"
// shift left to catch overlapping matches
// You may obtain a copy of the License at
"//
//     http://www.apache.org/licenses/LICENSE-2.0"
// GetTempDir returns the default temp directory with trailing slash
// Check if a file or directory exists.
// you may not use this file except in compliance with the License.
// Portions Copyright 2016-present Bjørn Erik Pedersen <bjorn.erik.pedersen@gmail.com>
// Filepath separator defined by os.Separator.
// Check if a file contains a specified byte slice.
// limitations under the License.
"//
// Licensed under the Apache License, Version 2.0 (the ""License"");"
// You may obtain a copy of the License at
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
// +build !netbsd
// you may not use this file except in compliance with the License.
// +build !freebsd
// See the License for the specific language governing permissions and
// http://www.apache.org/licenses/LICENSE-2.0
// +build !openbsd
// Copyright © 2016 Steve Francia <spf@spf13.com>.
"//
// Unless required by applicable law or agreed to in writing, software"
// +build !darwin
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
// +build !dragonfly
// for writing.
// Create the file on the overlay
// The UnionFile implements the afero.File interface and will be returned
// when reading a directory present at least in the overlay or opening a file
// from the overlay will be used.
// single view.
// First make sure the directory exists
// Readdir() and Readdirnames() merge the file os.FileInfo / names from the
// -> cache would be useless ;-)
"//
// The calls to"
"// advance the file position also in the base file, the next"
"// the operations will be done in both layers, starting with the overlay. A"
// only overwrite err in case the seek fails: we need to
"// If anything fails, clean up the file"
// FIXME?
"// the overlay first, we'd get a cacheStale the next time we access this file"
// successful read in the overlay will move the cursor position in the base layer
"// hmm, do we have fixed size files where a write may hit the EOF mark?"
"//
// When opening files for writing (Create() / OpenFile() with the right flags)"
"// base and the overlay - for files present in both layers, only those"
// It takes the FileInfo slices from the layer and the base and returns a
// call may be a write at this position (or a seek with SEEK_CUR)
// Readdir will weave the two directories together and
// return a single view of the overlayed directories
// by the number of bytes read.
"// first close base, so we have a newer timestamp in the overlay. If we'd close"
// DirsMerger is how UnionFile weaves two directories together.
// report an eventual io.EOF to the caller
// limitations under the License.
"//
// Licensed under the Apache License, Version 2.0 (the ""License"");"
// to be reported.
// to remove the file when no longer needed.
"// and writing, and returns the resulting *File."
// Random number state.
// constants from Numerical Recipes
// TempFile to a minimum.
"// A successful call returns err == nil, not err == EOF. Because ReadAll is"
// will not choose the same file.  The caller can use f.Name()
"// new directory.  If dir is the empty string, TempDir uses the"
// Copyright ©2015 The Go Authors
// a list of sorted directory entries.
// WriteFile writes data to a file named by filename.
// Copyright ©2015 Steve Francia <spf@spf13.com>
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
// byName implements sort.Interface.
// ReadDir reads the directory named by dirname and returns
"// If the buffer overflows, we will get bytes.ErrTooLarge."
"// read, so let's try it but be prepared for the answer to be wrong."
"// wrong, we'll either waste some space off the end or reallocate as needed, but"
// See the License for the specific language governing permissions and
"// As initial capacity for readAll, use n + a little extra in case Size is zero,"
// Multiple programs calling TempDir simultaneously
// for temporary files (see os.TempDir).
"// defined to read from src until EOF, it does not treat an EOF from Read"
"// with a name beginning with prefix, opens the file for reading"
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
// TempDir creates a new temporary directory in the directory dir
// ReadFile reads the file named by filename and returns the contents.
// and to avoid another allocation after Read has filled the buffer.  The readAll
// as an error to be reported.
// TempFile creates a new temporary file in the directory dir
// in the overwhelmingly common case we'll get it just right.
// Return that as an error. Any other panic remains.
// call will read into its allocated internal buffer cheaply.  If the size was
"// reads the whole file, it does not treat an EOF from Read as an error"
// We generate random temporary file names so that there's a good
"// If dir is the empty string, TempFile uses the default directory"
"//
// Unless required by applicable law or agreed to in writing, software"
// readAll reads from r until an error or EOF and returns the data it read
"// Don't preallocate a huge buffer, just in case."
// will not choose the same directory.  It is the caller's responsibility
// with a name beginning with prefix and returns the path of the
// ReadAll reads from r until an error or EOF and returns the data it read.
// You may obtain a copy of the License at
// to remove the directory when no longer needed.
"//
//     http://www.apache.org/licenses/LICENSE-2.0"
// otherwise WriteFile truncates it before writing.
// you may not use this file except in compliance with the License.
// to find the pathname of the file.  It is the caller's responsibility
// default directory for temporary files (see os.TempDir).
"// A successful call returns err == nil, not err == EOF. Because ReadFile"
// It's a good but not certain bet that FileInfo will tell us exactly how much to
// from the internal buffer allocated with a specified capacity.
// chance the file doesn't exist yet - keeps the number of tries in
// Multiple programs calling TempFile simultaneously
"// If the file does not exist, WriteFile creates it with permissions perm;"
// limitations under the License.
"//
// Licensed under the Apache License, Version 2.0 (the ""License"");"
// +build darwin openbsd freebsd netbsd dragonfly
// You may obtain a copy of the License at
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
// you may not use this file except in compliance with the License.
// See the License for the specific language governing permissions and
// http://www.apache.org/licenses/LICENSE-2.0
// Copyright © 2016 Steve Francia <spf@spf13.com>.
"//
// Unless required by applicable law or agreed to in writing, software"
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
// limitations under the License.
"//
// Licensed under the Apache License, Version 2.0 (the ""License"");"
// You may obtain a copy of the License at
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
// Copyright © 2014 Steve Francia <spf@spf13.com>.
// you may not use this file except in compliance with the License.
// See the License for the specific language governing permissions and
// http://www.apache.org/licenses/LICENSE-2.0
"//
// Unless required by applicable law or agreed to in writing, software"
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
// create test files and directories
// err = syscall.ENOENT
// err = syscall.EPERM
"//
// For cache times greater than 0, the modification time of a file is"
"// states: ""The underlying filesystem may truncate or round the values to a"
"//
// This caching union will forward all write calls also to the base file"
// resolution of a second for timestamps... or as the godoc for os.Chtimes()
"// filter - Note: this will also make the overlay read-only, for writing files"
"// not present in the overlay, unknown if it exists in the base:"
// checked. Note that a lot of file system implementations only allow a
"// If the cache duration is 0, cache time will be unlimited, i.e. once"
"// less precise time unit."""
"// cacheStale has base, cacheHit and cacheLocal the layer os.FileInfo"
// remember if the file did not exist before
"// oops, what if O_TRUNC was set and file opening in the layer failed...?"
// going through this union
"// present in the overlay and in base, base file is newer:"
"// a file is in the layer, the base will never be read again for this file."
"// present in the overlay - with cache time == 0 it may exist in the base,"
"// oops, see comment about OS_TRUNC above, should we remove? then we have to"
// with cacheTime > 0 it exists in the base and is same age or newer in the
// overlay
"// the dirs from cacheHit, cacheStale fall down here:"
"// yes, MkdirAll... we cannot assume it exists in the cache"
"// in the overlay, use the overlay Fs directly, not via the union Fs."
"// system first. To prevent writing to the base Fs, wrap it in a read-only"
// happens if someone writes directly to the overlay without
// by the union which are the intersection of the following...
// ...or os.ErrNotExist?
// A. It's a file or non-readable in the base (return just the overlay)
"// Overlay is a directory, base state now matters."
// will be removed.
// Since the overlay overrides the base we check that first
// If either have errors at this point something is very wrong. Return nil and the errors
"// If base is file or nonreadable, return overlay"
// be made in the overlay: Changing an existing file in the base layer which
// Base state has 3 states to check but 2 outcomes:
// includes also calls to e.g. Chtimes() and Chmod()).
// a possibly writeable layer on top. Changes to the file system will only
"//
// Reading directories is currently only supported via Open(), not OpenFile()."
// This function handles the 9 different possibilities caused
// Removing files present only in the base layer is not permitted. If
"// is not present in the overlay will copy the file to the overlay (""changing"""
// Returns true if the file is not in the overlay
"// a file is present in the base layer and the overlay, only the overlay"
"//  base:  doesn't exist, exists as a file, and exists as a directory"
"//  layer: doesn't exist, exists as a file, and exists as a directory"
// The CopyOnWriteFs is a union filesystem: a read only base file system with
// B. It's an accessible directory in the base (return a UnionFile)
"// If overlay is a file, return it (base state irrelevant)"
// Both base & layer are directories
// Renaming files present only in the base layer is not permitted
"// If overlay doesn't exist, return the base (base state irrelevant)"
// Return union file (if opens are without error)
// limitations under the License.
"//
// Licensed under the Apache License, Version 2.0 (the ""License"");"
"// if the filesystem supports it, use Lstat, else use fs.Stat"
// readDirNames reads the directory named by dirname and returns
// Copyright ©2015 The Go Authors
// Copyright ©2015 Steve Francia <spf@spf13.com>
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
// See the License for the specific language governing permissions and
// and directories are filtered by walkFn. The files are walked in lexical
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
"// order, which makes the output deterministic but means that for very"
// large directories Walk can be inefficient.
"// walk recursively descends path, calling walkFn"
// a sorted list of directory entries.
"//
// Unless required by applicable law or agreed to in writing, software"
"// Walk walks the file tree rooted at root, calling walkFn for each file or"
// Walk does not follow symbolic links.
// You may obtain a copy of the License at
// adapted from https://golang.org/src/path/filepath/path.go
"//
//     http://www.apache.org/licenses/LICENSE-2.0"
// you may not use this file except in compliance with the License.
"// directory in the tree, including root. All errors that arise visiting files"
"//
type RegexpFs struct {"
"// files matching the given regexp will be allowed, all others get a ENOENT error ("
"// ""No such file or directory"")."
// The RegexpFs filters files (not directories) by regular expression. Only
// Not much to do here;
// treated as non existing file.
// vim: ts=4 sw=4 noexpandtab nolist syn=go
// The BasePathFs restricts all operations to a given path within an Fs.
// the virtual file paths all look absolute on *nix.
// else the given file with the base path prepended
// the base path before calling the base Fs.
"// on a file outside the base path it returns the given file name and an error,"
// The given file name to the operations on this Fs will be prepended with
// Any file name (after filepath.Clean()) outside this base path will be
"// We could strip out the base part, but that would not be very portable."
// reveal the real path on errors.
"//
// Note that it does not clean the error messages on return, so you may"
// On Windows a common mistake would be to provide an absolute OS path
// limitations under the License.
"//
// Licensed under the Apache License, Version 2.0 (the ""License"");"
"// In addtion to the FileInfo, it will return a boolean telling whether Lstat was called or not."
// You may obtain a copy of the License at
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
// you may not use this file except in compliance with the License.
// Else it will call Stat.
// Copyright © 2018 Steve Francia <spf@spf13.com>.
// See the License for the specific language governing permissions and
"// It will call Lstat if the filesystem iself is, or it delegates to, the os filesystem."
// http://www.apache.org/licenses/LICENSE-2.0
"//
// Unless required by applicable law or agreed to in writing, software"
// filesystems saying so.
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
// Lstater is an optional interface in Afero. It is only implemented by the
// limitations under the License.
"//
// Licensed under the Apache License, Version 2.0 (the ""License"");"
"// uses the operating system filesystem, one that uses memory to store files"
// Rename renames a file.
// happens.
"// Remove removes a file identified by name, returning an error, if any"
// (cross platform) and an interface that should be implemented if you want to
// MkdirAll creates a directory path and all parents that does not exist
// RemoveAll removes a directory path and any children it contains. It
// Fs is the filesystem interface.
// as an abstraction layer.
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"// Open opens a file, returning it or an error, if any happens."
// See the License for the specific language governing permissions and
// provide your own filesystem.
// http://www.apache.org/licenses/LICENSE-2.0
// The name of this FileSystem
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
"// Stat returns a FileInfo describing the named file, or an error, if any"
// File represents a file in the filesystem.
"// error, if any happens."
"// Create creates a file in the filesystem, returning the file and an"
// Copyright 2013 tsuru authors. All rights reserved.
"//
// Any simulated or real filesystem should implement this interface."
"//
// Unless required by applicable law or agreed to in writing, software"
// does not fail if the path does not exist (return nil).
// yet.
// You may obtain a copy of the License at
// Copyright © 2014 Steve Francia <spf@spf13.com>.
// you may not use this file except in compliance with the License.
// Afero also provides a few implementations that are mostly interoperable. One that
"// Mkdir creates a directory in the filesystem, return an error if any"
// OpenFile opens a file using the given flags and the given mode.
"// Package afero provides types and methods for interacting with the filesystem,"
// limitations under the License.
"//
// Licensed under the Apache License, Version 2.0 (the ""License"");"
// You may obtain a copy of the License at
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
// Copyright © 2014 Steve Francia <spf@spf13.com>.
// a nil value of type *os.File or nil won't be nil
// you may not use this file except in compliance with the License.
"// while this looks strange, we need to return a bare nil (of type nil) not"
// See the License for the specific language governing permissions and
// Copyright 2013 tsuru authors. All rights reserved.
// http://www.apache.org/licenses/LICENSE-2.0
"//
// For details in any method, check the documentation of the os package"
"//
// Unless required by applicable law or agreed to in writing, software"
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
// OsFs is a Fs implementation that uses functions provided by the os package.
// (http://golang.org/pkg/os/).
// limitations under the License.
"//
// Licensed under the Apache License, Version 2.0 (the ""License"");"
// You may obtain a copy of the License at
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
// implement sort.Interface for []*FileData
// you may not use this file except in compliance with the License.
// See the License for the specific language governing permissions and
// http://www.apache.org/licenses/LICENSE-2.0
"//
// Unless required by applicable law or agreed to in writing, software"
// Copyright © 2015 Steve Francia <spf@spf13.com>.
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
// limitations under the License.
"//
// Licensed under the Apache License, Version 2.0 (the ""License"");"
// You may obtain a copy of the License at
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
// Implements os.FileInfo
// you may not use this file except in compliance with the License.
// See the License for the specific language governing permissions and
// Copyright 2013 tsuru authors. All rights reserved.
// http://www.apache.org/licenses/LICENSE-2.0
"//
// Unless required by applicable law or agreed to in writing, software"
// Copyright © 2015 Steve Francia <spf@spf13.com>.
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
// atomic requires 64-bit alignment for struct field access
// limitations under the License.
"//
// Licensed under the Apache License, Version 2.0 (the ""License"");"
// You may obtain a copy of the License at
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
// Copyright © 2014 Steve Francia <spf@spf13.com>.
// you may not use this file except in compliance with the License.
// See the License for the specific language governing permissions and
// http://www.apache.org/licenses/LICENSE-2.0
"//
// Unless required by applicable law or agreed to in writing, software"
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
// ToUint32E casts an interface to a uint32 type.
// ToFloat64E casts an interface to a float64 type.
// as necessary to reach the base type (or nil).
"// indirectToStringerOrError returns the value, after dereferencing as many times"
// ToBoolSliceE casts an interface to a []bool type.
// ToSliceE casts an interface to a []interface{} type.
// RFC3339 without T or timezone hh:mm colon
// ToUint16E casts an interface to a uint16 type.
// ToStringSliceE casts an interface to a []string type.
// as necessary to reach the base type (or nil) or an implementation of fmt.Stringer
"// predefined list of formats.  If no suitable format is found, an error is"
// From html/template/content.go
// ToInt8E casts an interface to an int8 type.
// the object passed as pointer.
// ToInt32E casts an interface to an int32 type.
// ToStringE casts an interface to a string type.
// ToStringMapBoolE casts an interface to a map[string]bool type.
// ToUint8E casts an interface to a uint type.
// ToStringMapInt64E casts an interface to a map[string]int64{} type.
// Time.String()
// returned.
// ToUintE casts an interface to a uint type.
// ToInt16E casts an interface to an int16 type.
// ToFloat32E casts an interface to a float32 type.
// license that can be found in the LICENSE file.
"// or error,"
// ToStringMapE casts an interface to a map[string]interface{} type.
// ToInt64E casts an interface to an int64 type.
// ToDurationSliceE casts an interface to a []time.Duration type.
// ToStringMapIntE casts an interface to a map[string]int{} type.
// ToStringMapStringSliceE casts an interface to a map[string][]string type.
// ToStringMapStringE casts an interface to a map[string]string type.
// RFC3339 without timezone hh:mm colon
// RFC3339 without T
// ToUint64E casts an interface to a uint64 type.
// StringToDate attempts to parse a string into a time.Time type using a
// Copyright © 2014 Steve Francia <spf@spf13.com>.
"//
// Use of this source code is governed by an MIT-style"
// Copyright 2011 The Go Authors. All rights reserved.
// Avoid creating a reflect.Value if it's not a pointer.
// ToIntSliceE casts an interface to a []int type.
// ToTimeE casts an interface to a time.Time type.
// iso8601 without timezone
// ToIntE casts an interface to an int type.
// jsonStringToObject attempts to unmarshall a string as JSON into
"// indirect returns the value, after dereferencing as many times"
// ToDurationE casts an interface to a time.Duration type.
// ToBoolE casts an interface to a bool type.
// ToDuration casts an interface to a time.Duration type.
// ToUint8 casts an interface to a uint8 type.
// ToTime casts an interface to a time.Time type.
// ToStringMapString casts an interface to a map[string]string type.
// ToString casts an interface to a string type.
// ToUint32 casts an interface to a uint32 type.
// ToSlice casts an interface to a []interface{} type.
// ToUint16 casts an interface to a uint16 type.
// ToInt16 casts an interface to an int16 type.
// ToStringMapBool casts an interface to a map[string]bool type.
// ToStringMapStringSlice casts an interface to a map[string][]string type.
// ToFloat64 casts an interface to a float64 type.
// ToUint casts an interface to a uint type.
// ToDurationSlice casts an interface to a []time.Duration type.
// ToBoolSlice casts an interface to a []bool type.
// ToUint64 casts an interface to a uint64 type.
// ToInt casts an interface to an int type.
// ToStringMapInt64 casts an interface to a map[string]int64 type.
// ToStringSlice casts an interface to a []string type.
// ToStringMapInt casts an interface to a map[string]int type.
// ToBool casts an interface to a bool type.
// ToStringMap casts an interface to a map[string]interface{} type.
// Package cast provides easy and safe casting in Go.
// license that can be found in the LICENSE file.
// ToInt64 casts an interface to an int64 type.
// ToIntSlice casts an interface to a []int type.
// Copyright © 2014 Steve Francia <spf@spf13.com>.
// ToInt32 casts an interface to an int32 type.
"//
// Use of this source code is governed by an MIT-style"
// ToFloat32 casts an interface to a float32 type.
// ToInt8 casts an interface to an int8 type.
// 1
"// ""mayonegg"""
"// ""8"""
"// ""8.31"""
"// """""
"// ""one more time"""
// 8
"// ""one time"""
// 0
// indirect
// strict slash is ignored for that route because the redirect behavior can't
// on the request itself.
// request will be made as a GET by most clients. Use middleware or client settings
// Helpers
// was renamed to Get() and remains here for backwards compatibility.
// Router.
// put the trailing slash back if necessary.
// See Route.Methods().
// If value was defined as an empty string we only check that the
// See Route.Path() and Route.Handler().
// HandleFunc registers a new route with a matcher for the URL path.
"// If true, ""/path/foo%2Fbar/to"" will match the path ""/path/{var}/to"""
// See Route.Schemes().
// Configurable Handler to be used when no route matches.
// configuration shared with `Route`
// to modify this behaviour as needed.
// PathPrefix registers a new route with a matcher for the URL path prefix.
// See Route.Host().
// will be filled in the match argument's MatchErr field. If the match failure type
// Host registers a new route with a matcher for the URL host.
// GetRoute returns a route registered with the given name. This method
// common route configuration shared between `Router` and `Route`
// The scheme used when building URLs.
// route inherit the original StrictSlash setting.
// matchMapWithString returns true if the given key/value pairs exist in a given map.
// requests:
// become /fetch/http/xkcd.com/534
// Slice of middlewares to be called after a match is found
"// Vars returns the route variables for the current request, if any."
// Configurable Handler to be used when the request method does not match the route.
// BuildVarsFunc registers a new route with a custom function for modifying
"// routes with a non-idempotent method (e.g. POST, PUT), the subsequent re-directed"
"// If true, when the path pattern is ""/path/"", accessing ""/path"" will"
// the request method and route method
"//
// If the request matches a route of this router or one of its subrouters the Route,"
"//
// When false, the path will be cleaned, so /fetch/http://xkcd.com/534/ will"
// Handle registers a new route with a matcher for the URL path.
"// after the handler returns, unless the KeepContext option is set on the"
// List of matchers.
// See Route.Headers().
"// At every invocation, it is given the current route, and the current router,"
// methodNotAllowedHandler returns a simple request handler
// Context
// MatcherFunc registers a new route with a custom matcher function.
// See Route.MatcherFunc().
// see the path as specified in the route.
// mapFromPairsToRegex converts variadic string parameters to a
// Copyright 2012 The Gorilla Authors. All rights reserved.
"// then this function returns false. If available, a reason for the match failure"
// http://code.google.com/p/go/issues/detail?id=5252
// to the routes.
"//
// This will send all incoming requests to the router."
// because the matched route is stored in the request context which is cleared
// See Route.Queries().
// and a list of ancestor routes that lead to the current route.
// StrictSlash defines the trailing slash behavior for new routes. The initial
// are explored depth-first.
// SkipClean defines the path cleaning behaviour for new routes. The initial
// Router registers routes to be matched and dispatches a handler.
// initialize a route with a copy of the parent router's configuration
"//
// If the request does not match any of this router's or its subrouters' routes"
// See Route.PathPrefix().
// It is set to ErrMethodMismatch if there is a mismatch in
// ErrMethodMismatch is returned when the method in the request does not match
// in the tree. The routes are walked in the order they were added. Sub-routers
// that replies to each request with a status code 405.
// Clean path to canonical form and redirect.
// Headers registers a new route with a matcher for request header values.
// this route and vice versa.
// mapFromPairsToString converts variadic string parameters to a
"//         http.Handle(""/"", router)"
"//
// When true, if the route path is ""/path/"", accessing ""/path"" will perform a redirect"
"//
// If not called, the router will match the unencoded path to the routes."
// license that can be found in the LICENSE file.
"// For eg. ""/path/foo%2Fbar/to"" will match the path ""/path/foo/bar/to"""
// Methods registers a new route with a matcher for HTTP methods.
// matchMapWithRegex returns true if the given key/value pairs exist in a given map compiled against
// ----------------------------------------------------------------------------
// slash. This is helpful if you have a route like: /fetch/http://xkcd.com/534/
"//
// The re-direct is a HTTP 301 (Moved Permanently). Note that when this is set for"
// router that walk is about to descend down to should be skipped.
"// If true, when the path pattern is ""/path//to"", accessing ""/path//to"""
// Check if key exists.
// UseEncodedPath tells the router to match the encoded original path
// Queries registers a new route with a matcher for URL query values.
"//
// It implements the http.Handler interface, so it can be registered to serve"
// Borrowed from the net/http package.
// string to string map.
"//
//     func main() {"
// Manager for the variables from host and path.
// WalkFunc is the type of the function called for each route visited by Walk.
// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.
"// Walk walks the router and all its sub-routers, calling walkFn for each route"
// MatchErr is set to appropriate matching error
// RouteMatch stores information about a matched route.
// Routes by name for URL building.
"// Handler, and Vars fields of the the match argument are filled and this function"
"// For eg. ""/path/foo%2Fbar/to"" will match the path ""/path/{var}/to""."
"// to the former and vice versa. In other words, your application will always"
"//
	// Deprecated: No effect when go1.7+ is used, since the context is stored"
"//
// When true, if the route path is ""/path//to"", it will remain with the double"
// will not redirect
// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
// See Route.Name().
//     }
// ErrNotFound is returned when no route match is found.
// path.Clean removes trailing slash except for root;
// the count is not an even number.
// NewRouter returns a new router instance.
// Match attempts to match the given request against the router's registered routes.
// mux.Vars(request).
// uniqueVars returns an error if two slices contain duplicated strings.
"// If true, do not clear the request context after handling the request."
"// checkPairs returns the count of strings passed in, and an error if"
// returns an effective deep copy of `routeConf`
"//
// When there is a match, the route variables can be retrieved calling"
// See Route.Path() and Route.HandlerFunc().
"// (eg: not found) has a registered handler, the handler is assigned to the Handler"
// Get returns a route registered with the given name.
// ServeHTTP dispatches the handler registered in the matched route.
"// be determined from a prefix alone. However, any subrouters created from that"
// key exists. Otherwise we also check for equality.
// string to regex map.
// SkipRouter is used as a return value from WalkFuncs to indicate that the
// See Route.Path().
// field of the match argument.
"// Routes to be matched, in order."
// route variables before building a URL.
// the method defined against the route.
"//
// Special case: when a route sets a path prefix using the PathPrefix() method,"
"//
// Or, for Google App Engine, register it in a init() function:"
// Route factories
// matchInArray returns true if the given string value is in the array.
// Schemes registers a new route with a matcher for URL schemes.
// the given regex
// Build middleware chain if no error was found
"//
//     func init() {"
// returns true.
// Use of this source code is governed by a BSD-style
// methodNotAllowed replies to the request with an HTTP status code 405.
// Closest match for a router (includes sub-routers)
// value is false.
"// cleanPath returns the canonical path for p, eliminating . and .. elements."
"//
// When false, if the route path is ""/path"", accessing ""/path/"" will not match"
// NewRoute registers an empty route.
// Name registers a new route with a name.
// Path registers a new route with a matcher for the URL path.
// redirect to the former and vice versa.
"// CurrentRoute returns the matched route for the current request, if any."
"//
//     var router = mux.NewRouter()"
// This only works when called inside the handler of the matched route
// value is false. Users should be careful about which routes are not cleaned
// Good practice to set timeouts to avoid Slowloris attacks.
// Do stuff here
// Bind to a port and pass our router in
"// Doesn't block if no connections, but will otherwise wait"
// endpoints.go
// Check the status code is what we expect.
// We found the token in our map
"// url.String() will be ""http://news.example.com/articles/technology/42?filter=gorilla"""
// Add your routes as needed
"// Create a request to pass to our handler. We don't have any query parameters for now, so we'll"
// Routes consist of a path and a handler function.
// endpoints_test.go
// for a route variable it doesn't know about.
// Pass our instance of gorilla/mux in.
// This will serve files under http://localhost:8000/static/<filename>
"// In the future we could report back on the status of our DB, or our cache"
// Write an error and stop the handler chain
// directly and pass in our Request and ResponseRecorder.
// Define our struct
// Matches a dynamic subdomain.
// pass 'nil' as the third parameter.
"// In this case, our MetricsHandler returns a non-200 response"
"// ""/products/{key}/"""
"// ""http://news.example.com/articles/technology/42"""
// Create a deadline to wait for.
"// Optionally, you could run srv.Shutdown in a goroutine and block on"
// to finalize based on context cancellation.
// until the timeout deadline.
// A route with a route variable:
// A very simple health check.
// We'll accept graceful shutdowns when quit via SIGINT (Ctrl+C)
"// ""http://news.example.com/"""
// Block until we receive our signal.
"// ""/products/"""
// Initialize it somewhere
"// Middleware function, which will be called for each request"
// Pass down the request to the next middleware (or final handler)
// IMPORTANT: you must specify an OPTIONS method matcher for the middleware to set CORS headers
// Need to create a router that we can pass the request through so that the vars will be added to the context
"// ""/products/{key}/details"""
"// ""/articles/technology/42"""
"// Only matches if domain is ""www.example.com""."
// Run our server in a goroutine so that it doesn't block.
"// SIGKILL, SIGQUIT or SIGTERM (Ctrl+/) will not be caught."
"// Our handlers satisfy http.Handler, so we can call their ServeHTTP method"
"// (e.g. Redis) by performing a simple PING, and include them in the response."
// We create a ResponseRecorder (which satisfies http.ResponseWriter) to record the response.
// Check the response body is what we expect.
// Good practice: enforce timeouts for servers you create!
"// Call the next handler, which can be another middleware in the chain, or the final handler."
// <-ctx.Done() if your application should wait for other services
// Copyright 2012 The Gorilla Authors. All rights reserved.
// Do stuff here
"// url.String() will be ""http://news.domain.com/articles/technology/42?filter=gorilla"""
"// ""http://news.domain.com/articles/technology/42"""
"// ""http://news.domain.com/"""
// We found the token in our map
// This will serve files under http://localhost:8000/static/<filename>
// Define our struct
// Matches a dynamic subdomain.
"// ""/products/{key}/"""
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
"// ""/products/"""
// Initialize it somewhere
"// Middleware function, which will be called for each request"
"// ""/products/{key}/details"""
"// ""/articles/technology/42"""
"// Only matches if domain is ""www.example.com""."
// Good practice: enforce timeouts for servers you create!
"// Call the next handler, which can be another middleware in the chain, or the final handler."
"// HeadersRegexp accepts a sequence of key/value pairs, where the value has regex"
// Subrouter creates a subrouter for the route.
// schemeMatcher matches the request against URL schemes.
// URL building
"//
//     url, err := r.Get(""article"").URL(""category"", ""technology"", ""id"", ""42"")"
// Match everything.
// BuildVarsFunc adds a custom function to be used to modify build variables
// URL builds a URL for the route.
// the tpl argument.
// An error will be returned if the route does not define queries.
"// non-nil MatchErr and be skipped, even when there was a"
"// It accepts a sequence of one or more methods to be matched, e.g.:"
"//     r.Path(""/products/"").Handler(ProductsHandler)"
// headerMatcher matches the request against header values.
"// template must start with a ""/""."
"//
//     ""/articles/technology/42"""
"// ""global"" reference to all named routes"
// GetQueriesRegexp returns the expanded regular expressions used to match the
// Methods --------------------------------------------------------------------
"//     url, err := r.Get(""article"").URL(""subdomain"", ""news"","
// Name -----------------------------------------------------------------------
// Headers adds a matcher for request header values.
// Use the start and end of string anchors (^ and $) to match an exact value.
// route queries.
// HandlerFunc sets a handler function for the route.
// functions (which can modify route variables before a route's URL is built).
"//
			// This prevents subsequent matching subrouters from failing to"
// doesn't match.
"//     r.Queries(""foo"", ""bar"", ""id"", ""{id:[0-9]+}"")"
"//
// Here, the routes registered in the subrouter won't be tested if the host"
"//
// The above route will only match if both request header values match."
"// Name sets the name for the route, used to build URLs."
// prepareVars converts the route variable pairs into a map. If the route has a
"//
// - {name:pattern} matches the given regexp pattern."
"//
// The above route will only match if the URL contains the defined queries"
// MatcherFunc adds a custom function to be used as request matcher.
// GetPathTemplate returns the template used to build the
// Handler --------------------------------------------------------------------
// compose the old and new functions
// Copyright 2012 The Gorilla Authors. All rights reserved.
// to Subrouters.
"//     r.Host(""www.example.com"")"
"//
// Note that it does not treat slashes specially (""/foobar/"" will be matched by"
"// BuildVarsFunc, it is invoked."
// URLPath builds the path part of the URL for a route. See Route.URL().
// The name used to build URLs.
// initialize a subrouter with a copy of the parent route's configuration
// Matchers
// It accepts a template with zero or more URL variables enclosed by {}.
// Schemes adds a matcher for URL schemes.
// GetMethods returns the methods the route matches against
// Error resulted from building a route.
"// GetName returns the name for the route, if any."
// Path -----------------------------------------------------------------------
"//
// For example:"
"//
// It will test the inner routes only if the parent route matched. For example:"
"//
// All variables defined in the route are required, and their values must"
"//     r.HeadersRegexp(""Content-Type"", ""application/(text|json)"","
// BuildOnly sets the route to never match: it is only used to build URLs.
"//
// It accepts a sequence of key/value pairs for the route variables. For"
// Host adds a matcher for the URL host.
"//     s := r.Host(""www.example.com"").Subrouter()"
"// It accepts a sequence of schemes to be matched, e.g.: ""http"", ""https""."
// methodMatcher matches the request against HTTP methods.
// license that can be found in the LICENSE file.
"//     s.HandleFunc(""/products/{key}"", ProductHandler)"
// ----------------------------------------------------------------------------
// template is a prefix of the full URL path. See Route.Path() for details on
// Variables can define an optional regexp pattern to be matched:
"// the prefix ""/foo"") so you may want to use a trailing slash here."
// An error will be returned if the route does not define a path.
// Route stores information to match a request and build URLs.
"//                                      ""category"", ""technology"","
"//
// Variable names must be unique in a given route. They can be retrieved"
// Ignore ErrNotFound errors. These errors arise from match call
"//
// This also works for host variables:"
// config possibly passed in from `Router`
// SkipClean reports whether path cleaning is enabled for this route via
"//
//     // url.String() will be ""http://news.domain.com/articles/technology/42"""
// Request handler for the route.
// GetQueriesTemplates returns the templates used to build the
// Methods adds a matcher for HTTP methods.
// query matching.
"//     r.Host(""{subdomain}.domain.com"")."
// with a PathPrefix matcher.
"//               ""X-Requested-With"", ""XMLHttpRequest"")"
// Handler sets a handler for the route.
"// GetError returns an error resulted from building the route, if any."
// Match returns the match for a given request.
// addRegexpMatcher adds a host or path matcher and builder to a route.
// Host -----------------------------------------------------------------------
"//     r.Host(""{subdomain:[a-z]+}.domain.com"")"
// GetPathRegexp returns the expanded regular expression used to match route path.
// support. For example:
// Schemes --------------------------------------------------------------------
"// example, given this route:"
// It accepts a template with zero or more URL variables enclosed by {}. The
// GetHostTemplate returns the template used to build the
// MatcherFunc is the function signature used by custom matchers.
"//
// Also note that the setting of Router.StrictSlash() has no effect on routes"
// Query ----------------------------------------------------------------------
// addMatcher adds a matcher to the route.
"//
// The route must have a host defined."
"//
// The above route will only match if both the request header matches both regular expressions."
"//
// ...which will return an url.URL with the following path:"
"//
// The route must have a path defined."
"// values, e.g.: ?foo=bar&id=42."
// MatcherFunc ----------------------------------------------------------------
// Path adds a matcher for the URL path.
"//       HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)."
"//
// - {name} matches anything until the next dot."
"//     s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)"
"// If the value is an empty string, it will match any value if the key is set."
// Queries adds a matcher for URL query values.
// An error will be returned if the route does not have queries.
// Then override the mis-matched handler
// Route attributes
"//
// - {name} matches anything until the next slash."
"// run middleware. If not ignored, the middleware would see a"
"//
//     r := mux.NewRouter()"
// An error will be returned if the route does not define a host.
"//
// If the value is an empty string, it will match any value if the key is set."
// Set variables.
"// We found a route which matches request method, clear MatchErr"
// BuildVarsFunc is the function signature used by custom build variable
// before a route's URL is built.
// matcher types try to match a request.
"//     r.Host(""{subdomain}.domain.com"")"
// route match.
// It is an error to call Name more than once on a route.
"// GetHandler returns the handler for the route, if any."
"//     r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)."
// against third-party services.
// headerRegexMatcher matches the request against the route given a regex for the header
"//     s.HandleFunc(""/products/"", ProductsHandler)"
"// If true, this route never matches: it is only used to build URLs."
// Router.SkipClean.
// PathPrefix adds a matcher for the URL path prefix. This matches if the given
// This is useful for building simple REST API documentation and for instrumentation
"// ""GET"", ""POST"", ""PUT""."
// matching route.
// It accepts a sequence of key/value pairs to be matched. For example:
// PathPrefix -----------------------------------------------------------------
// Subrouter ------------------------------------------------------------------
// Use of this source code is governed by a BSD-style
"//                                      ""id"", ""42"")"
// BuildVarsFunc --------------------------------------------------------------
// calling mux.Vars(request).
// An error will be returned if route does not have methods.
"//
// Variables can define an optional regexp pattern to be matched:"
// It accepts a sequence of key/value pairs. Values may define variables.
// For example:
// Match matches the route against the request.
//       Handler(ArticleHandler)
"//
// ...a URL for it can be built using:"
"//     r.Path(""/articles/{category}/{id:[0-9]+}"")."
// conform to the corresponding patterns.
"//       Name(""article"")"
// Headers --------------------------------------------------------------------
"//     r.Headers(""Content-Type"", ""application/json"","
"//     r.Path(""/products/{key}"").Handler(ProductsHandler)"
"// Yay, we have a match. Let's collect some info about it."
// URLHost builds the host part of the URL for a route. See Route.URL().
// Middleware allows MiddlewareFunc to implement the middleware interface.
// on requests for routes that have an OPTIONS method matcher to all the method matchers on
// the route. Routes that do not explicitly handle OPTIONS requests will not be processed
// by the middleware. See examples for usage.
"// Typically, the returned handler is a closure which does something with the http.ResponseWriter and http.Request passed"
"// useInterface appends a middleware to the chain. Middleware can be used to intercept or otherwise modify requests and/or responses, and are executed in the order that they are applied to the Router."
// CORSMethodMiddleware automatically sets the Access-Control-Allow-Methods response header
"// Use appends a MiddlewareFunc to the chain. Middleware can be used to intercept or otherwise modify requests and/or responses, and are executed in the order that they are applied to the Router."
// getAllMethodsForRoute returns all the methods from method matchers matching a given
// request.
// MiddlewareFunc is a function which receives an http.Handler and returns another http.Handler.
// middleware interface is anything which implements a MiddlewareFunc named Middleware.
"// to it, and then calls the handler passed as parameter to the MiddlewareFunc."
// routeRegexpGroup groups the route matchers that carry variables.
// Copyright 2012 The Gorilla Authors. All rights reserved.
"// a ""reverse"" template to build URLs and compile regexps to validate variable"
// Build the reverse template.
// getURLQuery returns a single query parameter from a request URL.
// value pair for the routeRegexp.
"// The URL is checked against the full regexp, instead of checking"
// values used in URL building.
"//
// It will extract named variables, assemble a regexp to be matched, create"
// Match matches the regexp against the URL host or path.
// braceIndices returns the first level curly brace indices from a string.
"// newRouteRegexp parses a route template and returns a routeRegexp,"
// Backup the original.
// url builds a URL part using the given values.
// According to section 14.23 of RFC 2616 the Host header
// getHost tries its best to return the request host.
"//
// Previously we accepted only Python-like identifiers for variable"
// varGroupName builds a capturing group name for the indexed variable.
"// name and pattern can't be empty, and names can't contain a colon."
// It returns an error in case of unbalanced braces.
// Done!
// Name or pattern can't be empty.
// routeRegexp stores a regexp to match a host or path and information to
// Variable regexps (validators).
// Append variable name and compiled pattern.
// Reverse template.
// The type of match
// Store host variables.
// routeRegexpGroup
// Only match strict slash if not matching
// Use of this source code is governed by a BSD-style
// Now let's parse it.
// Options for matching
// Check if it is well-formed.
// license that can be found in the LICENSE file.
// Add the default pattern if the query value is empty
// Don't be strict on the port match
// ----------------------------------------------------------------------------
"// message, we check individual regexps if the URL doesn't match."
// Wildcard host-port (no strict port match in hostname)
"// used to match a host, a path or a query string."
// setMatch extracts the variables from the URL once a route matches.
// collect and validate route variables.
// Expanded regexp.
"// names ([a-zA-Z_][a-zA-Z0-9_]*), but currently the only restriction is that"
// Check for capturing groups which used to work in older versions
// Build the regexp pattern.
// individual variables. This is faster but to provide a good error
// Add the remaining.
"// For a URL with foo=bar&baz=ding, we return only the relevant key"
// Store path variables.
// Check if we should redirect.
// Set all values we are interested in.
// can include the port number if the default value of 80 is not used.
// Set a flag for strictSlash.
// The unmodified template.
// Variable names.
// Compile full regexp.
// Store query string variables.
// Copyright 2012 The Gorilla Authors. All rights reserved.
// copy is returned.
"//
// This API should only be used for testing purposes; it provides a way to"
"// can be set by making a route that captures the required variables,"
// starting a server and sending the request to that server.
"// inject variables into the request context. Alternatively, URL variables"
// Use of this source code is governed by a BSD-style
"// SetURLVars sets the URL variables for the given request, to be accessed via"
// license that can be found in the LICENSE file.
"// mux.Vars for testing route behaviour. Arguments are not modified, a shallow"
// Copyright 2016 Michal Witkowski. All Rights Reserved.
// establish arbitrary TCP connections (as long as your proxy allows them) through a HTTP(S) CONNECT point.
"// Dial is an implementation of net.Dialer, and returns a TCP connection handle to the host that HTTP CONNECT reached."
// port 9090 using TLS for connectivity.
"// Retry request with auth, if available."
// Package http_dialer provides HTTP(S) CONNECT tunneling net.Dialer. It allows you to
"// The first parameter is a proxy URL, for example https://foo.example.com:9090 will use foo.example.com as proxy on"
"// Optional customization parameters are available, e.g.: WithTls, WithDialer, WithConnectionTimeout"
// WithDialer allows the customization of the underlying net.Dialer used for establishing TCP connections to the proxy.
// WithConnectionTimeout customizes the underlying net.Dialer.Timeout.
// WithProxyAuth allows you to add ProxyAuthorization to calls.
// This is weird
"// Doesn't matter, discard this bufio."
// WithTls sets the tls.Config to be used (e.g. CA certs) when connecting to an HTTP proxy over TLS.
// HttpTunnel represents a configured HTTP Connect Tunnel dialer.
// See LICENSE for licensing terms.
// New constructs an HttpTunnel to be used a net.Dial command.
// Copyright 2016 Michal Witkowski. All Rights Reserved.
"// Type represents what kind of Authorization, e.g. ""Bearer"", ""Token"", ""Digest""."
"// Initial allows you to specify an a-priori ""Proxy-Authenticate"" response header, attached to first request,"
// TODO(mwitkow): Implement realm lookup in AuthBasicWithRealm.
"// response to ""Proxy-Authorization"" request header challenge."
"// ProxyAuthorization allows for plugging in arbitrary implementations of the ""Proxy-Authorization"" handler."
"// ChallengeResponse returns the content of the ""Proxy-Authenticate"" response header, that has been chose as"
// header is added.
"// challenge can be realm=""proxy.com"""
"// so you don't need to wait for an additional challenge. If empty string is returned, ""Proxy-Authenticate"""
"// AuthBasic returns a ProxyAuthorization that implements ""Basic"" protocol while ignoring realm challanges."
// See LICENSE for licensing terms.
// Error implements the error interface and can represents multiple
// return value more useful with the errwrap and go-multierror libraries.
// errors that occur in the course of a single decode.
// WrappedErrors implements the errwrap.Wrapper interface to make this
"//
// Note that this is significantly different from the WeaklyTypedInput option"
// strings to net.IP
// Create variables here so we can reference them with the reflect pkg
// ComposeDecodeHookFunc creates a single DecodeHookFunc that
// that took reflect.Kind instead of reflect.Type.
// the decoder.
// StringToSliceHookFunc returns a DecodeHookFunc that converts
// typedDecodeHook takes a raw DecodeHookFunc (an interface{}) and turns
// StringToTimeHookFunc returns a DecodeHookFunc that converts
// of the DecoderConfig.
// string to []string by splitting on the given sep.
// strings to time.Duration.
// Modify the from kind to be correct with the new data
"//
// The composed funcs are called in order, with the result of the"
// WeaklyTypedHook is a DecodeHookFunc which adds support for weak typing to
// StringToTimeDurationHookFunc returns a DecodeHookFunc that converts
// automatically composes multiple DecodeHookFuncs.
// StringToIPNetHookFunc returns a DecodeHookFunc that converts
// StringToIPHookFunc returns a DecodeHookFunc that converts
"// it into the proper DecodeHookFunc type, such as DecodeHookFuncType."
// previous transformation.
// strings to net.IPNet
// Fill in the variables into this interface and the rest is done
// strings to time.Time.
// automatically using the reflect package.
// DecodeHookExec executes the given decode hook. This should be used
// Convert it by parsing
// since it'll naturally degrade to the older backwards compatible DecodeHookFunc
// that are squashed.
// source and target types.
// A Decoder takes a raw interface value and turns it into structured
"// If the data is nil, then we don't set anything, unless ZeroFields is set"
"// it. If this is false, a map will be merged."
// map[string]interface{} into a native Go structure.
// again.
"// Kinds) and are generally a richer thing to use, but Kinds are simpler"
"// data transformations. See ""DecodeHook"" in the DecoderConfig"
// error.
// Decode decodes the given raw interface to the target pointer specified
"// Finally, set the value to the slice we built up"
// Check input type and based on the input type jump to the proper func
//   - strings to int/uint (base implied by prefix)
"// and ""lift"" it into it. i.e. a string becomes a string slice."
// Next get the actual value of this field and verify it is assignable
// Next decode the data into the proper type
//   - negative numbers to overflowed uint values (base 10)
"// WeakDecodeMetadata is the same as Decode, but is shorthand to"
"// If ErrorUnused is true, then it is an error for there to exist"
"// DecodeHook, if set, will be called before any decoding and any"
// Empty maps turn into empty slices
// Result is a pointer to the struct that will contain the decoded
"// anything goes wrong. Unlike the basic top-level Decode method, you can"
// value.
"// This decodes a basic type (bool, int, string, etc.) and sets the"
"// If we had errors, return those"
// more finely control how the Decoder behaves using the DecoderConfig
// enable both WeaklyTypedInput and metadata collection. See
// Create an element of the concrete (non pointer) type and decode
// By default we overwrite keys in the current map
"// If the name is empty string, then we're at the root, and we"
// We need to check here if input is a typed nil. Typed nils won't
// the values before they're set down onto the resulting struct.
// but have a promise to not break backwards compat so we now support
// the output structure. output must be a pointer to a map or struct.
//     if the target type is an int slice.
// Not the most efficient way to do this but we can optimize later if
// then we just set it directly instead of recursing into the structure.
// Decode takes an input structure and uses reflection to translate it to
// enable metadata collection. See DecoderConfig for more info.
"//   - string to bool (accepts: 1, t, T, TRUE, true, True, 0, f, F,"
"// If WeaklyTypedInput is true, the decoder will make the following"
// All other types we try to convert to the array type
// and allows customization of various aspects of decoding.
"// other structs, etc. and the decoder will properly decode nested"
// Do a slower search by iterating over each key and
// to true.
// Special case for BC reasons (covered by tests)
//   - slice of maps to a merged map
//   - single values are converted to slices if required. Each
"// field is unexported, then ignore it."
// If we reached this point then we weren't able to decode it
"// ZeroFields, if set to true, will zero fields before writing them."
"// If we can't set the field, then it is unexported or something,"
// Create slice of maps of other sizes
// Not a string key
// Delete the key we're using from the unused map so we stop tracking
// WeakDecode is the same as Decode but is shorthand to enable
// to be the zero value.
// into that. Then set the value of the pointer to this type.
// Just re-try this function with data as a slice.
"// value to ""data"" of that type."
"// If the type of the value to write to and the data match directly,"
"//
	// If an error is returned, the entire decode will fail with that"
// Get the StructField first since this is a cheap operation. If the
// DecoderConfig is the configuration that is used to create a new decoder
"// If the input data is empty, then we just match what the input data is."
// Either is accepted. Types are a superset of Kinds (Types can return
"//
// The type should be DecodeHookFuncType or DecodeHookFuncKind."
// and we just continue onwards.
"// ""weak"" conversions:"
// Check input type
"// we started with Kinds and then realized Types were the better solution,"
// Empty maps turn into empty arrays
// is tedious or difficult to get otherwise.
// the source and target types.
// both.
"// and ""lift"" it into it. i.e. a string becomes a string array."
// Decodes an unknown data type into a specific reflection value.
// mark the key as used if we're tracking metainput.
// First decode the key into the proper type
// type conversion (if WeaklyTypedInput is on). This lets you modify
// structure. The top-level Decode method is just a convenience that sets
"//     FALSE, false, False. Anything else is an error)"
// Accumulate errors
// Set the built up map to the value
// to the map value.
"// If we reached here, then we successfully decoded SOMETHING, so"
"//
	WeaklyTypedInput bool"
"// If the input data is a pointer, and the assigned type is the dereference"
// by the configuration.
"//
// The reason DecodeHookFunc is multi-typed is for backwards compatibility:"
// struct.
// weren't decoded since there was no matching field in the result interface
"// DecodeMetadata is the same as Decode, but is shorthand to"
"// for fieldType, field := range fields {"
// This should never happen
"//
// The Go structure can be arbitrarily complex, containing slices,"
"// Make a new array to hold our result, same size as the original data."
// doing case-insensitive search.
// keys in the original map that were unused in the decoding process
// All other types we try to convert to the slice type
"// If the map is nil or we're purposely zeroing fields, make a new map"
// Set to empty allocated value
// Package mapstructure exposes functionality to convert an arbitrary
// Metadata is the struct that will contain extra metadata about
// DecoderConfig for more info.
"// Make a new slice to hold our result, same size as the original data."
// DecodeHookFuncKind is a DecodeHookFunc which knows only the Kinds of the
//   - numbers to string (base 10)
"// match the ""input == nil"" below so we check that here."
// Accumulate any errors
"//     element is weakly decoded. For example: ""4"" can become []int{4}"
// Compile the list of all the fields that we're going to be decoding
// we want to. To convert from struct to struct we go to map first
"// If the input value is empty, then don't allocate since non-nil != nil"
"// the decoding. If this is nil, then no metadata will be tracked."
// up the most basic Decoder.
"// If there were errors, we return those"
// maps and so on into the proper structures in the native Go struct.
// Slice and array we use the normal logic
//   - int to bool (true if value != 0)
// Add the unused keys to the list of unused keys if we're tracking metadata
// as an intermediary.
// don't dot-join the fields.
//   - empty array = empty map and vice versa
"// Finally, set the value to the array we built up"
"// We have a DecodeHook, so let's pre-process the input."
// Example: *string to string
// NewDecoder returns a new decoder for the given configuration. Once
"// a decoder has been returned, the same configuration must not be used"
"// defaults to ""mapstructure"""
// Determine the name of the key in the map
// There was no matching key in the map for the value in
// The tag name that mapstructure reads for field names. This
// if you only need those.
"// If the input data is nil, then we want to just set the output"
"// this is an embedded struct, so handle it differently"
// (extra keys).
"// Normal struct field, store it away"
"//
	//   - bools to string (true = ""1"", false = ""0"")"
"// of that exact pointer, then indirect it so that we can assign it."
// Metadata contains information about decoding a structure that
// WeaklyTypedInput. See DecoderConfig for more info.
"// If the input value is invalid, then we just set the value"
// Make a new map to hold our result
// DecodeHookFunc is the callback function that can be used for
"//   - bools to int/uint (true = 1, false = 0)"
"// If ""squash"" is specified in the tag, we squash the field down."
// There can be more than one struct if there are embedded structs
"// data, keeping track of rich error information along the way in case"
// the struct. Just ignore.
// from all the structs.
// This slice will keep track of all the structs we'll be decoding.
// DecodeHookFuncType is a DecodeHookFunc which has complete information about
// pointer to be nil as well.
// See the examples to see what the decoder is capable of.
// Unused is a slice of keys that were found in the raw value but
// Keys are the keys of the structure which were successfully decoded
"// For example, a map will be emptied before decoded values are put in"
// Search in runes from front to end
// Search in runes from end to front
// Caller type for dynamic completion
// -----------------------------------------------------------------------------
// register sig for width changed
// receive width
// exit raw
// receive isTerminal
// only process one action in one read
// To provides same behavior as unix terminal.
// +build windows
// RawReader translate input record to ANSI escape sequence.
// keyup
// _
// move forward
// move prev
// keyword
"// 	rl, err := readline.New(""> "")"
"// prompt supports ANSI escape sequence, so we can color some characters even in windows"
// 		panic(err)
// readline will persist historys to file where HistoryFile specified
// Any key press will pass to Listener
"//
// gives"
// 	defer rl.Close()
// it use in IM usually.
// enable case-insensitive history searching
// private fields
"//
// example:"
// 	}
// HistoryEnable the save of the commands into the history (default on)
// 	if err != nil {
// Readline is a pure go implementation for GNU-Readline kind library.
// we must make sure that call Close() before process exit.
// switch VimMode in runtime
// change history persistence in runtime
"//  i.WriteStdin([]byte(""test""))"
"// specify the max length of historys, it's 500 by default, set it to -1 to disable history"
"//
// > test[cursor]"
// same as readline
"//
// 	for {"
// readline will refresh automatic when write through Stdout()
"// NOTE: Listener will be triggered by (nil, 0, 0) immediately"
"//
package readline"
//  i := readline.New()
// 		println(line)
// erase the editing line after user submited it
// AutoCompleter will called once user press TAB
"// If VimMode is true, readline will in vim.insert mode by default"
// filter input runes (may be used to disable CtrlZ or for translating some keys to different actions)
// 			break
// 		if err != nil { // io.EOF
// HistoryDisable the save of the commands into the history
// -> output = new (translated) rune and true/false if continue with processing this one
"//  _, _= i.Readline()"
// ie :
"// 		line, err := rl.Readline()"
// WriteStdin prefill the next Stdin fetch
// force use interactive even stdout is not a tty
"// err is one of (nil, io.EOF, readline.ErrInterrupt)"
// we can generate a config by `i.GenPasswordConfig()`
// Next time you call ReadLine() this value will be writen before the user input
// 		}
// turn off
// invalid operation
// GetSize returns the dimensions of the given terminal.
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
"// +build darwin dragonfly freebsd linux,!appengine netbsd openbsd"
// +build darwin dragonfly freebsd netbsd openbsd
// license that can be found in the LICENSE file.
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// 46: Cyan
// 40: Black
// 43: Yellow
// 44: Blue
// left
// +build windows
// 33: Yellow
// 31: Red
// 30: Black
// 42: Green
// 45: Magenta
// down
// unknown code treat as reset
// 32: Green
// 34: Blue
// right
// 41: Red
// set title
// 35: Magenta
// 37: White
// 47: White
// up
// 36: Cyan
// Restore restores the terminal connected to the given file descriptor to a
// mode and returns the previous state of the terminal so that it can be
"// 	defer terminal.Restore(0, oldState)"
// commonly found on UNIX systems.
// restored.
// 	}
// 	if err != nil {
"//
// 	oldState, err := terminal.MakeRaw(0)"
// is commonly used for inputting passwords and other sensitive data. The slice
// +build windows
// ReadPassword reads a line of input from a terminal without local echo.  This
"// Package terminal provides support functions for dealing with terminals, as"
// 	        panic(err)
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// GetState returns the current state of a terminal which may be useful to
// restore the terminal after a signal.
// GetSize returns the dimensions of the given terminal.
"//
// Putting a terminal into raw mode is the most common requirement:"
// Copyright 2011 The Go Authors. All rights reserved.
// MakeRaw put the terminal connected to the given file descriptor into raw
// IsTerminal returns true if the given file descriptor is a terminal.
// previous state.
// returned does not include the \n.
"//   DoTree([a, a1, ], 0) [a11]"
// |- a2
"//   DoTree([a], 1) [a]"
// a
// input:
"//   DoTree([a, a1, a], 1) [a11]"
"//   DoTree([a, ], 0) [a1, a2]"
"//   DoTree([a, a1], 2) [a1]"
// b
"//   DoTree([a, a], 1) [a1, a2]"
"//   DoTree([], 0) [a, b]"
// |--- a11
// |- a1
// Example:
// -1 to avoid reach the end of line
// move back
// only Aggregate candidates in non-complete mode
"//   Do(""g"", 1) => [""o"", ""it"", ""it-shell"", ""rep""], 1"
"//   Do(""gi"", 2) => [""t"", ""t-shell""], 2"
"// Completer need to pass all the candidates, and how long they shared the same characters in line"
// Readline will pass the whole line and current offset to it
"//   [go, git, git-shell, grep]"
"//   Do(""git"", 3) => ["""", ""-shell""], 3"
// -----------------------------------------------------------------------------
// errno 0 means everything is ok :)
"// It will run a ticker until a long duration is occurs,"
// which means this process is resumed.
// translate EscX to Meta+X
// calculate how many lines for N character
// print a linked list to Debug()
// translate Esc[X
// WaitForResume need to call before current process got suspend.
// append log info to another file
// +build windows
// ClearScreen clears the console screen
// get width of the terminal
// only called by newOpHistory
"// fd is write only, just satisfy what we need."
// just report the error
// Enable the current history
// set current to last item
"// err only can be a IO error, just report"
// push a new one to commit current command
// Disable the current history
// save history
// if just use last command without modify
// replace history file
// ignore the empty line
// history deactivated
// move history item to current command
// just clean lastest history
// let's flush them by sending CharEnter.
"// so if we use it next time, we need to reopen it by `InitHistory()`"
"// if err is not nil, it just mean it fail to write to file"
"// if stdin got io.EOF and there is something left in buffer,"
// print prompt
// And we will got io.EOF int next loop.
// it will cause null history
// trim \n
// io.EOF
// ignore IO error
// other things goes fine.
// SetHistoryPath will close opHistory which already exists
// ignore this rune
// treat as EOF
// to refresh the line
// syscall.TCSETS
"// them from the syscall package as some syscall packages, even"
// syscall.TCGETS
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// Copyright 2013 The Go Authors. All rights reserved.
"// These constants are declared here, rather than importing"
"// on linux, for example gccgo, do not declare them."
// For OSX it need to send to parent's pid
// -----------------------------------------------------------------------------
"// +build darwin dragonfly freebsd linux,!appengine netbsd openbsd solaris"
// get width of the terminal
// ClearScreen clears the console screen
// For Linux it need to send to myself
"// SuspendMe use to send suspend signal to myself, when we in the raw mode."
// Restore restores the terminal connected to the given file descriptor to a
// mode and returns the previous state of the terminal so that it can be
"// 	defer terminal.Restore(0, oldState)"
// This attempts to replicate the behaviour documented for cfmakeraw in
"// +build darwin dragonfly freebsd linux,!appengine netbsd openbsd solaris"
// commonly found on UNIX systems.
// restored.
// 	}
// 	if err != nil {
"//
// 	oldState, err := terminal.MakeRaw(0)"
// is commonly used for inputting passwords and other sensitive data. The slice
// ReadPassword reads a line of input from a terminal without local echo.  This
// State contains the state of a terminal.
"// Package terminal provides support functions for dealing with terminals, as"
// newState.Oflag &^= syscall.OPOST
// 	        panic(err)
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// GetState returns the current state of a terminal which may be useful to
// restore the terminal after a signal.
"//
// Putting a terminal into raw mode is the most common requirement:"
// Copyright 2011 The Go Authors. All rights reserved.
// the termios(3) manpage.
// MakeRaw put the terminal connected to the given file descriptor into raw
// IsTerminal returns true if the given file descriptor is a terminal.
// previous state.
// returned does not include the \n.
// +build solaris
// GetSize returns the dimensions of the given terminal.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// Copyright 2013 The Go Authors. All rights reserved.
// cursor position
// TODO: move back
"// up one line, go to the start of the line and move cursor right to the end (r.width)"
// goto start
// move input to the left of one
// just like ^k :)
"// if we are at the end of a word already, go to next"
"// already at the end, so do nothing"
// keep going until at the end of a word
// WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
// FOCUS_EVENT_RECORD        FocusEvent;
// +build windows
// MOUSE_EVENT_RECORD        MouseEvent;
// KEY_EVENT_RECORD          KeyEvent;
// MENU_EVENT_RECORD         MenuEvent;
// return rune(0) if meet EOF
// WriteStdin prefill the next Stdin fetch
"// SleepToResume will sleep myself, and return only if I'm resumed."
// offset
// Next time you call ReadLine() this value will be writen before the user input
"// Read will read from the local buffer and if no data, read from stdin"
// so the `AddHistory` will return nil error forever.
// global instance will not submit history automatic
// NewFillableStdin gives you FillableStdin
// raise error only if `SetHistoryPath` is set with a non-empty path
// and try to persist history into disk
// set auto completer to global instance
// let readline load history from filepath
// reading into the real stdin
// FillableStdin is a stdin reader which can prepend some data before
// readline with global configs
"// set fp to """" to prevent readline persisting history to disk"
// add history to global instance manually
// +build windows
"// For polls the given function 'f', once every 'interval', up to 'timeout'."
// NewClient creates a new ACME client on behalf of the user.
// The client will depend on the ACME directory located at CADirURL for the rest of its actions.
// Client is the user-friendly way to ACME
// GetToSURL returns the current ToS URL from the Directory
// GetExternalAccountRequired returns the External Account Binding requirement of the Directory
// A private key of type keyType (see KeyType constants) will be generated when requesting a new certificate if one isn't provided.
// return nil. If there is an error creating a *x509.CertPool from the provided
// variable. If the caCertificatesEnvVar is not set then initCertPool will
// LEDirectoryProduction URL to the Let's Encrypt production
// LEDirectoryStaging URL to the Let's Encrypt staging
// specify the CA server name that can be used to
// the system-wide trusted root list.
// specify the path to PEM encoded CA Certificates that can be used to
// caCertificatesEnvVar value then initCertPool will panic.
// found in the filepath specified in the caCertificatesEnvVar OS environment
// caServerNameEnvVar is the environment variable name that can be used to
// caCertificatesEnvVar is the environment variable name that can be used to
// initCertPool creates a *x509.CertPool populated with the PEM certificates
// createDefaultHTTPClient Creates an HTTP client with a reasonable timeout value
// authenticate an ACME server with a HTTPS certificate not issued by a CA in
// and potentially a custom *x509.CertPool
// based on the caCertificatesEnvVar environment variable (see the `initCertPool` function)
"// website (optional, string):"
// The hostnames that the ACME server recognizes as referring to itself
// Challenge statuses
"// The time at which the server validated this challenge,"
"// Including this field in a new-account request,"
"// and MUST NOT include base64 padding characters (""="")."
"// error (optional, object):"
"// Possible values are: ""valid"", ""deactivated"", and ""revoked""."
"// finalize (required, string):"
"// reason (optional, int):"
// as described in Section 7.1.2.1.
// Directory the ACME directory object.
// This allows a client to look up an account URL based on an account key (see Section 7.3.1).
// https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-7.1.6
// Meta the ACME meta object (related to Directory).
"// The value ""deactivated"" should be used to indicate client-initiated deactivation"
"// It MUST NOT contain any characters outside the base64url alphabet,"
// The result of a successful finalization will be the population of the certificate URL for the order.
"// onlyReturnExisting (optional, boolean):"
// An HTTP or HTTPS URL locating a website providing more information about the ACME server.
"// then the CA requires that all new- account requests include an ""externalAccountBinding"" field"
// - https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-7.1.2
"// identifier (required, object):"
// A URL that a CSR must be POSTed to once all of the order's authorizations are satisfied to finalize the order.
// Challenge the ACME challenge object.
// Authorization the ACME authorization object.
"// Error that occurred while the server was validating the challenge, if any,"
"// (Note: Because this field uses base64url, and does not include headers, it is different from PEM.)"
// - https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-7.3
"// The requested value of the notAfter field in the certificate,"
// - https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-7.6
"// For example, the server may wish to notify the client about server-initiated revocation or certificate expiration."
"// This field is REQUIRED for objects with ""valid"" in the ""status"" field."
// in the date format defined in [RFC3339].
"// notAfter (optional, string):"
// A URL for the certificate that has been issued in response to this order
"// externalAccountBinding (optional, object):"
"// The timestamp after which the server will consider this authorization invalid,"
// structured as a problem document [RFC7807].
// A URL identifying the current terms of service.
"// For pending orders,"
// - https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-7.1.4
"// certificate (optional, string):"
// - https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-7.1.5
// Each array entry is an object with parameters required to validate the challenge.
// The identifier that the account is authorized to represent
"// url (required, string):"
"// Possible values are: ""pending"", ""ready"", ""processing"", ""valid"", and ""invalid""."
"// type (required, string):"
// Each entry is a URL from which an authorization can be fetched with a POST-as-GET request.
"// This field is REQUIRED if the ""status"" field is ""valid""."
"// If this field is present and set to ""true"","
// For authorizations created as a result of a newOrder request containing a DNS identifier
// Multiple errors can be indicated by using subproblems Section 6.7.1.
"// For invalid authorizations, the challenge that was attempted and failed."
// ExtendedChallenge a extended Challenge.
"// The error that occurred while processing the order, if any."
// The status of this order.
"// notBefore (optional, string):"
"// For information on supported URL schemes, see Section 7.3"
// The authorizations required are dictated by server policy
// This value MUST have at least 128 bits of entropy.
"// The timestamp after which the server will consider this order invalid,"
// - https://tools.ietf.org/html/rfc5280#section-5.3.1
// The problem document detail SHOULD indicate which reasonCodes are allowed.
// RevokeCertMessage a certificate revocation message
// One of the revocation reasonCodes defined in Section 5.3.1 of [RFC5280] to be used when generating OCSP responses and CRLs.
"// caaIdentities (optional, array of string):"
// Each string MUST represent the same sequence of ASCII code points
"// status (required, string):"
// https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-8.4
// This field is not updateable by the client.
"// with a value of true, indicates the client's agreement with the terms of service."
// https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-8.1
"// externalAccountRequired (optional, boolean):"
// See [RFC4086] for additional information on randomness requirements.
"// the authorizations that the client needs to complete before the requested certificate can be issued (see Section 7.5),"
// - https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-7.1.1
// Contains the value of the response header `Retry-After`
// and there may not be a 1:1 relationship between the order identifiers and the authorizations required.
// https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-8.3
// including unexpired authorizations that the client has completed in the past for identifiers specified in the order.
// ExtendedAccount a extended Account.
// ExtendedOrder a extended Order.
"// orders (required, string):"
// and a server should consider any one of the challenges sufficient to make the authorization valid.
"// If a request contains a disallowed reasonCode the server MUST reject it with the error type ""urn:ietf:params:acme:error:badRevocationReason""."
// - https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-7.4
// - https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-7.1.3
// CSRMessage Certificate Signing Request
"// token (required, string):"
"// For final orders (in the ""valid"" or ""invalid"" state), the authorizations that were completed."
// A CSR encoding the parameters for the certificate being requested [RFC2986].
// If this field is not set the server SHOULD omit the reasonCode CRL entry extension when generating OCSP responses and CRLs.
// An optional field for binding the new account with an existing non-ACME account (see Section 7.3.4).
"// validated (optional, string):"
// The CSR is sent in the base64url-encoded version of the DER format.
"// contact (optional, array of string):"
// Package acme contains all objects related the ACME endpoints.
// The URL to which a response can be posted.
// associating the new account with an external account.
// Contains the value of the response header `Location`
"// A URL from which a list of orders submitted by this account can be fetched via a POST-as-GET request,"
// An array of identifier objects that the order pertains to.
"// Contains the value of the response header `Link` rel=""up"""
"// This field is REQUIRED for objects with ""pending"" or ""valid"" in the status field."
// Identifier the ACME identifier object.
"// authorizations (required, array of string):"
"// A client should attempt to fulfill one of these challenges,"
// encoded in the format specified in RFC 3339 [RFC3339].
"// termsOfService (optional, string):"
// This allows clients to determine the correct issuer domain name to use when configuring CAA records.
"// identifiers (required, array of object):"
"// The certificate to be revoked, in the base64url-encoded version of the DER format."
"// termsOfServiceAgreed (optional, boolean):"
"// The order URL, contains the value of the response header `Location`"
"// Possible values are: ""pending"", ""valid"", ""invalid"", ""deactivated"", ""expired"", and ""revoked""."
"// (Note: Because this field uses base64url, and does not include headers, it is different from PEM.)."
// Account the ACME account Object.
"// For valid authorizations, the challenge that was validated."
"// challenges (required, array of objects):"
"// The requested value of the notBefore field in the certificate,"
"// with a value that contained a wildcard prefix this field MUST be present, and true."
"// csr (required, string):"
// The type of challenge encoded in the object.
"// A challenge object with an error MUST have status equal to ""invalid""."
// https://tools.ietf.org/html/draft-ietf-acme-acme-16
"// certificate (required, string):"
// for the purposes of CAA record validation as defined in [RFC6844].
// A random value that uniquely identifies the challenge.
"// whereas ""revoked"" should be used to indicate server- initiated deactivation. (See Section 7.1.6)"
// - https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-9.7.7
// This field is structured as a problem document [RFC7807].
// The server MAY disallow a subset of reasonCodes from being used by the user.
"// The status of this challenge. Possible values are: ""pending"", ""processing"", ""valid"", and ""invalid""."
"// If this field is present with the value ""true"","
"// For pending authorizations, the challenges that the client can fulfill in order to prove possession of the identifier."
// The status of this account.
// An array of URLs that the server can use to contact the client for issues related to this account.
// - https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-8
"// expires (optional, string):"
"// that the server will expect to see as the ""Issuer Domain Name"" in a CAA issue or issuewild property tag."
"// wildcard (optional, boolean):"
// The status of this authorization.
// Order the ACME order Object.
// then the server MUST NOT create a new account if one does not already exist.
// Errors types
// additional values to have a better error message (Not defined by the RFC)
// ProblemDetails the problem details object
"// SubProblem a ""subproblems"""
// NonceError represents the error which is returned
// if the nonce sent by the client was not accepted by the server.
// - https://tools.ietf.org/html/rfc7807#section-3.1
// - https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-6.7.1
// - https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-7.3.3
// New Creates a challenge.
// Challenge initiation is done by sending a JWS payload containing the trivial JSON object `{}`.
// We use an empty struct instance as the postJSON payload here to achieve this result.
// Get Gets a challenge.
// NewEAB Creates a new account with an External Account Binding.
// New Creates a new account.
// Deactivate Deactivates an account.
// Get Retrieves an account.
// Get Gets an authorization.
// Deactivate Deactivates an authorization.
// in the response headers of a new certificate.
"// get Returns the certificate and the ""up"" link."
// See https://community.letsencrypt.org/t/acme-v2-no-up-link-in-response/64962
"// To do this, we append the issuer cert to the issued cert."
"// If we fail to acquire the issuer cert, return the issued certificate - do not fail."
// getIssuerFromLink requests the issuer certificate
// maxBodySize is the maximum size of body that we will read.
"// The issuer certificate link may be supplied via an ""up"" link"
// Revoke Revokes a certificate.
// 'bundle' is only applied if the issuer is provided by the 'up' link.
// Get issuerCert from bundled response from Let's Encrypt
"// If bundle is true, we want to return a certificate bundle."
// See https://tools.ietf.org/html/draft-ietf-acme-acme-12#section-7.4.2
// Get Returns the certificate and the issuer certificate.
// getRetryAfter get the value of the header Retry-After
// getLocation get the value of the header Location
// getLink get a rel into the Link header
// New Creates a new Core.
// into the provided respBody object.
// https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-6.3
// GetKeyAuthorization Gets the key authorization
// Retry if the nonce was invalidated
"// during tests, allow to support ~90% of bad nonce with a minimum of attempts."
// nonceErr is ignored to keep the root error.
"// postAsGet performs an HTTP POST (""POST-as-GET"") request."
"// post performs an HTTP POST request and parses the response body as JSON,"
// Reuse a single struct instead of allocating one for each service on the heap.
// Core ACME/LE core API.
// UpdateForCSR Updates an order for a CSR.
// Get Gets an order.
// New Creates a new order.
// NewJWS Create a new JWS.
// SetKid Sets a key identifier.
// GetKeyAuthorization Gets the key authorization for a token.
// unpad the base64URL
// Key identifier
// Generate the Key Authorization for the challenge
// JWS Represents a JWS.
// SignContent Signs a content with the JWS.
// SignEABContent Signs an external account binding content with the JWS.
// Manager Manages nonces.
// NewManager Creates a new Manager.
// GetFromResponse Extracts a nonce from a HTTP response.
// Pop Pops a nonce.
// Nonce implement jose.NonceSource
// Push Pushes a nonce.
// NewDoer Creates a new Doer.
// formatUserAgent builds and returns the User-Agent string to use in requests.
// Post performs a POST request with a proper User-Agent string.
// The response body (resp.Body) is already closed when this function returns.
// Check for errors we handle specifically
"// If ""response"" is not provided, callers should close resp.Body when done reading from it."
// Get performs a GET request with a proper User-Agent string.
// Head performs a HEAD request with a proper User-Agent string.
// ourUserAgent is the User-Agent of this underlying library package.
// values: detach|release
// CODE GENERATED AUTOMATICALLY
// THIS FILE MUST NOT BE EDITED BY HAND
// NOTE: Update this with each tagged release.
// ourUserAgentComment is part of the UA comment linked to the version status of this underlying library package.
// Register the current account to the ACME server.
// RegisterWithExternalAccountBinding Register the current account to the ACME server.
// Location: header is not returned so this needs to be populated off of existing URI
"// WARNING: will be remove in the future (acme.ExtendedAccount), https://github.com/go-acme/lego/issues/855."
// and return its registration resource.
// QueryRegistration runs a POST request on the client's registration and returns the result.
// ResolveAccountByKey will attempt to look up an account using the given account key
"//
// This is similar to the Register function,"
// of which the client needs to keep track itself.
// Log the URL here instead of the email as the email may not be set
// FIXME seems impossible
// Resource represents all important information about a registration
// DeleteRegistration deletes the client's user registration from the ACME server.
// but acting on an existing registration link and resource.
// User interface is to be implemented by users of this library.
// It is used by the client type to get user specific information.
// OCSPGood means that the certificate is valid.
// ParsePEMBundle parses a certificate bundle from top to bottom and returns
// Constants for OCSP must staple
// The certificate has to be PEM encoded. Any other encodings like DER will fail.
// Check for SAN certificate
// Constants for all key types we support.
// OCSPRevoked means that the certificate has been deliberately revoked.
// a slice of x509 certificates. This function will error if no certificates are found.
// Duplicate; skip this name
// KeyType represents the key algo as well as the key size or curve to use.
// loop over the SubjectAltName DNS names
// ParsePEMCertificate returns Certificate from a PEM encoded certificate.
// Name is unique
// from a DER encoded certificate
// OCSPUnknown means that the OCSP responder doesn't know about the certificate.
// OCSPServerFailed means that the OCSP responder failed to process the request.
// Logger is an optional custom logger.
// Fatalf writes a log entry.
// StdLogger interface for Standard Logger.
// Fatal writes a log entry.
// Warnf writes a log entry.
// Printf writes a log entry.
// Print writes a log entry.
// Infof writes a log entry.
// Println writes a log entry.
"// It uses Logger if not nil, otherwise it uses the default log.Logger."
"// limited on the ""new-reg"", ""new-authz"" and ""new-cert"" endpoints."
// be careful to not return an empty failures map;
"// From the documentation the limitation is 20 requests per second,"
"// even if empty, they become non-nil error values"
// but using 20 as value doesn't work but 18 do
// overallRequestLimit is the overall number of request per second
// obtainError is returned when there are specific errors available per domain.
"// If there's no OCSP server listed in the leaf cert, there's nothing to do."
"// if the certificate is available right away, short cut!"
"//
// The returned Resource will not have the PrivateKey and CSR fields populated as these will not be available."
"// PrivateKey, Certificate and IssuerCertificate are all"
"//
// If bundle is true, the Certificate field in the returned Resource includes the issuer certificate."
// and use that if it's defined.
// We always need to request a new certificate to renew.
"// SRV CRT -> CA. We need to pull the leaf and issuer certs out of it,"
"//
// The domains are inferred from the CommonName and SubjectAltNames, if any."
// Get attempts to fetch the certificate at the supplied URL.
// Please be aware that this function will return a new certificate in ANY case that is not an error.
// Determine certificate name(s) based on the authorization resources
"// If one domain in the list fails, the whole certificate will fail."
"//
// For private key reuse the PrivateKey property of the passed in Resource should be non-nil."
"//
// If the []byte and/or ocsp.Response return values are nil, the OCSP status may be assumed OCSPUnknown."
"//
// The returned []byte can be passed directly into the OCSPStaple property of a tls.Certificate."
// Parse the returned cert bundle so that we can grab the domain from the common name.
"//
// https://tools.ietf.org/html/rfc5280#section-7"
// Resource represents a CA issued certificate.
// because it would still be a non-nil error value
"// TODO: build fallback. If this fails, check the remaining array entries."
// start with the common name
"//
// A new private key is generated for every invocation of the function Obtain."
// all other domains are added using the Subject Alternate Names extension.
"// Do not return an empty failures map,"
//   Clients SHOULD NOT make any assumptions about the sort order of
"//
// If the renewal process succeeds, the new certificate will ge returned in a new CertResource."
// checkResponse checks to see if the certificate is ready and a link is contained in the response.
// Renew takes a Resource and tries to renew the certificate.
//   MUST be encoded according to the rules in Section 7 of [RFC5280].
// TODO: should the CSR be customizable?
// The domain name MUST be encoded
// depending on the options supplied to create it.
// If this parameter is non-nil it will be used instead of generating a new one.
// already PEM encoded and can be directly written to disk.
// ObtainForCSR tries to obtain a certificate matching the CSR passed into it.
// figure out what domains it concerns
// Certifier A service to obtain/renew/revoke certificates.
"//
// The certRes input should already have the Domain (common name) field populated."
// Obtain tries to obtain a single certificate using all domains passed into it.
// The input may be a bundle or a single certificate.
// If the server does not provide us with a new cert on a GET request to the CertURL
"// Do not return an empty failures map, because"
"// If any challenge fails, return. Do not generate partial SAN certificates."
// If you do not want that you can supply your own private key in the privateKey parameter.
// Input certificate is PEM encoded.
"// GetOCSP takes a PEM encoded cert or cert bundle returning the raw OCSP response,"
"// If the bundle only contains the issued certificate,"
// https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-7.1.4
// says:
"//
// If bundle is true, the certificate will be bundled with the issuer's cert."
// which should always be the first two certificates.
// this function will try to get the issuer certificate from the IssuingCertificateURL in the certificate.
//   object.
"//   ""identifiers"" or ""authorizations"" elements in the returned order"
"//
// The first domain in domains is used for the CommonName field of the certificate,"
"// ACME draft Section 7.4 ""Applying for Certificate Issuance"""
// Finally kick off the OCSP request.
// NewCertifier creates a Certifier.
"//   in the form in which it would appear in a certificate.  That is, it"
"//
// If so, loads it into certRes and returns true."
// The private key for this CSR is not required.
// This is just meant to be informal for the user.
// We want it ordered right SRV CRT -> CA
// https://tools.ietf.org/html/draft-ietf-acme-acme-12#section-7.4
"//
// If bundle is true, the []byte contains both the issuer certificate and your issued certificate as a bundle."
// Revoke takes a PEM encoded certificate or bundle and tries to revoke it at the CA.
"// Start by checking to see if the certificate was based off a CSR,"
// Decode it here as we may need the decoded cert later on in the renewal process.
// The URL is the same as what would normally be supplied at the Resource's CertURL.
"// the parsed response, and an error, if any."
// it would still be a non-nil error value
// ObtainRequest The request to obtain certificate.
"// And if we have only one certificate so far, we need to get the issuer cert."
"//
// This function will never return a partial certificate."
// We expect the certificate slice to be ordered downwards the chain.
// this function will start a new-cert flow where a new certificate gets generated.
// Insert it into the slice on position 0
"// Certificate may be a certificate bundle,"
"// If the cert is not yet ready, it returns false."
// Add the CSR to the certificate so that it can be used for renewals.
// maxBodySize is the maximum size of body that we will read.
// Note: ChallengePath returns the URL path to fulfill this challenge
"// HTTP01 is the ""http-01"" ACME challenge https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-8.3"
// Type is a string that identifies a particular challenge type and version of ACME challenge.
"// DNS01 is the ""dns-01"" ACME challenge https://tools.ietf.org/html/draft-ietf-acme-acme-16#section-8.4"
"// TLSALPN01 is the ""tls-alpn-01"" ACME challenge https://tools.ietf.org/html/draft-ietf-acme-tls-alpn-05"
// Note: GetRecord returns a DNS record which will fulfill this challenge
// package. The interval value is the time between checks.
// be solved. CleanUp will be called by the challenge if Present ends
"// Provider provides a Timeout method, then the return values"
// ProviderTimeout allows for implementing a
// in a non-error state.
// Provider where an unusually long timeout is required when
// of the Timeout method will be used when appropriate by the acme
// checking for DNS record propagation. If an implementor of a
"//
// The default values used for timeout and interval are 60 seconds and"
// provider. Present presents the solution to a challenge available to
// Provider enables implementing a custom challenge
// 2 seconds respectively. These are used when no Timeout method is
// defined for the Provider.
"// waiting for an ACME challenge to be satisfied, such as when"
"// we don't want any lingering connections, so disable KeepAlives."
// Other webservers might use different names;
"//
// When the server runs behind a proxy server, this is not the correct place to look at;"
"// the ""any"" interface and port 80 respectively."
// CleanUp closes the HTTP server and removes the token from `ChallengePath(token)`
"// - ""Forwarded"" will look for a Forwarded header, and inspect it according to https://tools.ietf.org/html/rfc7239"
// ProviderServer implements ChallengeProvider for `http-01` challenge
// Present starts a web server and makes the token available at `ChallengePath(token)` for web requests.
// you want only to use the default values.
"// and RFC7239 has standadized a new header named ""Forwarded"" (with slightly different semantics)."
"// Apache and NGINX have traditionally moved the original Host header into a new header named ""X-Forwarded-Host""."
// NewProviderServer creates a new ProviderServer on the selected interface and port.
// - any other value will check the header value with the same name
"//
// The exact behavior depends on the value of headerName:"
"// - """" (the empty string) and ""Host"" will restore the default and only check the Host header"
"// By default, s matches the ""Host"" header value to the domain name."
// SetProxyHeader changes the validation of incoming requests.
// Setting iface and / or port to an empty string will make the server fall back to
"// We only respond with the keyAuth, when we're receiving a GET requests with"
// It may be instantiated without using the NewProviderServer function if
// Once httpServer is shut down
// The incoming request must will be validated to prevent DNS rebind attacks.
"// the ""Host"" header matching the domain (the latter is configurable though SetProxyHeader)."
// ChallengePath returns the URL path for the `http-01` challenge
// Generate the Key Authorization for the challenge
"//
// The most simple check involves finding the domain in the HTTP Host header;"
// this is what hostMatcher does.
// when the http01.ProviderServer operates behind a RFC7239 compatible proxy.
// is equal to
// end of forwarded-element
"// This step is part of DNS rebind attack prevention,"
"//   X-Header: a, b"
// hostMatcher checks whether the specified (*net/http.Request).Header value starts with a domain name.
// valid token character or whitespace
// or the appropriate header name for other proxy servers.
// or when it operates behind a transparent proxy.
// meaning that
// parsing requires some form of state machine
// https://tools.ietf.org/html/rfc7239
// This is primarily used to create meaningful error messages.
//   X-Header: a
// in the HTTP request coming from the ACME validation servers.
// A domainMatcher tries to match a domain (the one we're requesting a certificate for)
"//
// RFC7239 has standardized the different forwarding headers into a single header named Forwarded."
// end of token
//   X-Header: b
// end of forwarded-pair
// matches checks whether the request is valid for the given domain.
// See https://tools.ietf.org/html/rfc7239 for details.
// start of quoted-string
// where the webserver matches incoming requests to a list of domain the server acts authoritative for.
"// Use it, when the http01.ProviderServer is directly reachable from the internet,"
"//
// In many (reverse) proxy setups, Apache and NGINX traditionally move the Host header to a new header named X-Forwarded-Host."
"// The header value has a different format, so you should use forwardedMatcher"
"//
// Note: RFC7239 also reminds us, ""that an HTTP list [...] may be split over multiple header fields"" (section 7.1),"
// hostMatcher checks whether (*net/http).Request.Host starts with a domain name.
"// Use arbitraryMatcher(""X-Forwarded-Host"") in this case,"
"//
// All matcher implementations (explicitly not excluding arbitraryMatcher!)"
// have in common that they only match against the first value in such lists.
// name returns the header name used in the check.
"// forwardedMatcher checks whether the Forwarded header contains a ""host"" element starting with a domain name."
// Returns the interval between each iteration.
// Present prints instructions for manually creating the TXT record
// NewDNSProviderManual returns a DNSProviderManual instance.
// DNSProviderManual is an implementation of the ChallengeProvider interface
// CleanUp prints instructions for manually removing the TXT record
// Sequential All DNS challenges for this provider will be resolved sequentially.
// checkAuthoritativeNss queries each of the given nameservers for the expected TXT record.
"// the main check, put it in a loop, etc."
// checkDNSPropagation checks if the expected TXT record has been propagated to all authoritative nameservers.
// Deprecated: use WrapPreCheck instead.
// PreCheckFunc checks DNS propagation before notifying ACME that the DNS challenge is ready.
// Prevent race condition
// AddPreCheck Allow to define checks before notifying ACME that the DNS challenge is ready.
// WrapPreCheck Allow to define checks before notifying ACME that the DNS challenge is ready.
// require the TXT record to be propagated to all authoritative name servers
// Initial attempt to resolve at the recursive NS
// checks DNS propagation before notifying ACME that the DNS challenge is ready.
// WrapPreCheckFunc wraps a PreCheckFunc in order to do extra operations before or after
// Update FQDN with CNAME if any
// PreSolve just submits the txt record to the dns provider.
"// It does not validate record propagation, or do anything at all with the acme server."
// CondOption Conditional challenge option.
// base64URL encoding without padding
// DefaultPollingInterval default polling interval
// NoOp options
// Challenge implements the dns-01 challenge
// CleanUp cleans the challenge.
// Generate the Key Authorization for the challenge
// GetRecord returns a DNS record which will fulfill the `dns-01` challenge
// DefaultPropagationTimeout default propagation timeout
// Check if the domain has CNAME then return that
// DefaultTTL default TTL
// UnFqdn converts the fqdn into a name removing the trailing dot.
// ToFqdn converts the name into a fqdn appending a trailing dot.
"// If the TCP request succeeds, the err will reset to nil"
// dnsTimeout is used to override the default DNS timeout of 10 seconds.
// dnsMsgContainsCNAME checks for a CNAME answer in msg
// FindZoneByFqdn determines the zone apex for the given fqdn
// by recursing up the domain labels until the nameserver returns a SOA record in the answer section.
// FindZoneByFqdnCustom determines the zone apex for the given fqdn
// So we skip a domain when a CNAME is found.
// getNameservers attempts to get systems nameservers before falling back to the defaults
// NXDOMAIN
// recursiveNameservers are used to pre-check DNS propagation
// Check if we got a SOA RR in the answer section
// ensure all servers have a port number
// CNAME records cannot/should not exist at the root of a zone.
// ClearFqdnCache clears the cache of fqdn to zone mappings. Primarily used in testing.
// Do we have it cached?
// lookupNameservers returns the authoritative nameservers for the given fqdn.
// Any response code other than NOERROR and NXDOMAIN is treated as error
// Reference: https://tools.ietf.org/html/draft-ietf-acme-tls-alpn-05#section-5.1
// Reference: https://tools.ietf.org/html/draft-ietf-acme-tls-alpn-05#section-3
// Encode the private key into a PEM format. We'll need to use it to generate the x509 keypair.
// ChallengeCert returns a certificate with the acmeValidation-v1 extension
"// Generate the PEM certificate using the provided private key, domain, and extra extensions."
// Generate a new RSA key for the certificates.
"// ChallengeBlocks returns PEM blocks (certPEMBlock, keyPEMBlock) with the acmeValidation-v1 extension"
// and domain name for the `tls-alpn-01` challenge.
// Compute the SHA-256 digest of the key authorization.
// Solve manages the provider to validate and solve the challenge.
// (marked as critical such that it won't be used by non-ACME software).
// Generate the Key Authorization for the challenge
// idPeAcmeIdentifierV1 is the SMI Security for PKIX Certification Extension OID referencing the ACME extension.
// Add the keyAuth digest as the acmeValidation-v1 extension
// ACMETLS1Protocol is the ALPN Protocol ID for the ACME-TLS/1 Protocol.
// Shut the server down when we're finished.
// https://tools.ietf.org/html/draft-ietf-acme-tls-alpn-01#section-5.2
// if you want only to use the default values.
// defaultTLSPort is the port that the ProviderServer will default to
// Generate the challenge certificate using the provided keyAuth and domain.
// Present generates a certificate with a SHA-256 digest of the keyAuth provided
// Create the listener with the created tls.Config.
// so that the protocol negotiation can succeed. Reference:
// NewProviderServer creates a new ProviderServer on the selected interface and port.
// ProviderServer implements ChallengeProvider for `TLS-ALPN-01` challenge.
// We must set that the `acme-tls/1` application level protocol is supported
"// Server was created, close it."
// as the acmeValidation-v1 extension value to conform to the ACME-TLS-ALPN spec.
// when no other port is provided.
// Place the generated certificate with the extension into the TLS config
// CleanUp closes the HTTPS server.
// It may be instantiated without using the NewProviderServer
// Setting iface and / or port to an empty string will make the server fall back to
"// the ""any"" interface and port 443 respectively."
// so that it can serve the correct details.
// Fallback to port 443 if the port was not provided.
// obtainError is returned when there are specific errors available per domain.
// SetTLSALPN01Provider specifies a custom provider p that can solve the given TLS-ALPN-01 challenge.
// https://github.com/letsencrypt/boulder/blob/master/docs/acme-divergences.md#section-82
// SetDNS01Provider specifies a custom provider p that can solve the given DNS-01 challenge.
// SetHTTP01Provider specifies a custom provider p that can solve the given HTTP-01 challenge.
// The ACME server MUST return a Retry-After.
"// If it doesn't, we'll just poll hard."
"// After the path is sent, the ACME server will access our server."
// Remove Remove a challenge type from the available solvers.
// Repeatedly check the server for an updated status on our request.
// Boulder does not implement the ability to retry challenges or the Retry-After header.
// Allow to have a deterministic challenge order
// Checks all challenges from the server in order and returns the first matching solver.
// Solve challenge
// Boulder might recycle recent validated authz (see issue #267)
// already failed in previous loop
// This saves quite a bit of time vs creating the records and solving them serially.
"// Be careful not to return an empty failures map,"
// Then solves the challenges in series and returns.
// Clean all created TXT records
// an authz with the solver we have chosen and the index of the challenge associated with it
// Solve Looks through the challenge combinations to find a solvable match.
// Clean challenge
"// Loop through the resources, basically through the domains."
"// Interface for challenges like dns, where we can set a record in advance for ALL challenges."
// Finally solve all challenges for real
// for even an empty obtainError is a non-nil error value
// Submit the challenge
"// For all valid preSolvers, first submit the challenges so they have max time to propagate"
"// Interface for challenges like dns, where we can solve all the challenges before to delete them."
// First pass just selects a solver for each authz.
// Interface for all challenge solvers to implement.
// KeepDestinationHeaders indicates the proxy should retain any headers present in the http.Response before proxying
// http.ResponseWriter will take care of filling the correct response length
"// Setting it now, might impose wrong value, contradicting the actual new"
// setting Verbose to true will log information on each request sent to the proxy
// and return canned response instead.
// https://jdebp.eu./FGA/web-proxy-connection-header.html
// the Content-Length header should be set.
// see http://golang.org/src/pkg/sync/atomic/doc.go#L41
// We keep the original body to remove the header only if things changed.
// non-nil resp means the handler decided to skip sending the request
// and would wrap the response body with the relevant reader.
//   The Connection general-header field allows the sender to specify
//   options that are desired for that particular connection and MUST NOT
"// NewProxyHttpServer creates and returns a proxy server, logging to stderr by default"
// http://www.w3.org/Protocols/rfc2616/rfc2616.txt
// body the user returned.
// 14.10 Connection
// session variable must be aligned in i386
// if nil Tr.Dial will be used
"// Connection, Authenticate and Authorization are single hop Header:"
"// If no Accept-Encoding header exists, Transport will add the headers it can accept"
// ConnectDial will be used to create TCP connections for CONNECT requests
"// Standard net/http function. Shouldn't be used directly, http.Serve will use it."
"// curl can add that, see"
// this must be reset when serving a request with the client
//   be communicated by proxies over further connections.
// The basic proxy type. Implements http.Handler.
"// This will prevent problems with HEAD requests where there's no body, yet,"
// TODO: Allow Server.Close() mechanism to shut down this connection as nicely as possible
"// Since we don't know the length of resp, return chunked encoded response"
"// If found a result, break the loop immediately"
// TODO: use a more reasonable scheme
// Force connection close otherwise chrome will keep CONNECT tunnel open forever
"// Okay to use and discard buffered reader here, because"
// Read response.
// always use 1.1 to support chunked encoding
// still handling the request even after hijacking the connection. Those HTTP CONNECT
// Bug fix which goproxy fails to provide request
"// this goes in a separate goroutine, so that the net/http server won't think we're"
// information URL in the context when does HTTPS MITM
// TLS server will not speak until spoken to.
"// request can take forever, and the server will be stuck when ""closed""."
"// since we're converting the request, need to carry over the original connecting IP as well"
"// That is, the proxy will create a TLS connection with the client, another TLS"
// The request and responses sent in this Man In the Middle channel are filtered
// and RespHandlers)
// to the client.
"// skip sending any requests, and will simply return the response `resp`"
"// to the destination server. If it returns nil,resp the proxy will"
"// FuncRespHandler.Handle(req,ctx) <=> FuncRespHandler(req,ctx)"
"// all the HttpsHandlers the proxy has, and if one returns true, the connection is"
// A wrapper that would convert a function to a HttpsHandler interface type
"// connection with the destination the client wished to connect to, and would"
// The proxy server will send to the client the response returned by the RespHandler.
// FuncHttpsHandler should implement the RespHandler interface
"// after the proxy have sent the request to the destination server, it will"
// A wrapper that would convert a function to a ReqHandler interface type
"// When a client send a CONNECT request to a host, the request is filtered through"
// sniffed using Man in the Middle attack.
// send back and forth all messages from the server to the client and vice versa.
"// In case of error, resp will be nil, and ctx.RoundTrip.Error will contain the error"
"// ""filter"" the response through the RespHandlers it has."
"// FuncReqHandler.Handle(req,ctx) <=> FuncReqHandler(req,ctx)"
"// ReqHandler will ""tamper"" with the request coming to the proxy server"
// through the usual flow (request and response filtered through the ReqHandlers
"// If Handle returns req,nil the proxy will send the returned request"
// A wrapper that would convert a function to a RespHandler interface type
//		if c.Sum(nil) == passHash {
// DoFunc is equivalent to proxy.OnRequest().Do(FuncReqHandler(f))
"// the request, only if all the given ReqCondition matched."
// connection.
"// UrlIs(""google.com/"",""foo"") will match requests 'GET /' to 'google.com', requests `'GET google.com/' to"
// and will replace the body of the original response with the resulting byte array.
//		c := sha1.New()
// Typical usage:
// to one of the given strings.
"//		io.WriteString(c,ctx.Req.Header.Get(""X-GoProxy-Auth""))"
// with or without the host prefix.
"// UrlIs returns a ReqCondition, testing whether or not the request URL is one of the given strings"
"// any host, and requests of the form 'GET foo'."
// ReqCondition.HandleReq will decide whether or not to use the ReqHandler on an HTTP request
// ProxyConds is used to aggregate RespConditions for a ProxyHttpServer.
"// to a byte array in memory, would run the user supplied f function on the byte arra,"
// SrcIpIs returns a ReqCondition testing whether the source IP of the request is one of the given strings
"// HandleConnect is used when proxy receives an HTTP CONNECT request,"
"//	// given request to the proxy, will test if cond1.HandleReq(req,ctx) && cond2.HandleReq(req,ctx) are true"
"//	// if they are, will call handler.Handle(req,ctx)"
"//	proxy.OnRequest(UrlIs(""example.com/foo""),UrlMatches(regexp.MustParse(`.*\.exampl.\com\./.*`)).Do(...)"
//		HandleConnect(goproxy.AlwaysReject)
"// forwarding all bytes from the client to the remote host, ConnectReject will close the connection with the"
"// for example, accepting CONNECT request if they contain a password in header"
"// AlwaysReject is a HttpsHandler that drops any CONNECT request, for example, this code will disallow"
// requests to url 'http://host/x'
"//			return OkConnect, host"
"//		return RejectConnect, host"
//				// if cond1.HandleResp(resp) && cond2.HandleResp(resp)
// it'll then use the HttpsHandler to determine what should it
// connections to hosts on any other port than 443
"//	io.WriteString(h,password)"
// to be usable as RespCondition.
// any of the given regular expressions.
// IsLocalHost checks whether the destination host is explicitly local host
// handle the request if all conditions on the HTTP request are met.
"// OnResponse is used when adding a response-filter to the HTTP proxy, usual pattern is"
"// before sending it to the proxy client. Note that resp might be nil, in case there was an"
"//	proxy.OnRequest(goproxy.ReqHostIs(""www.google.com"")).HandleConnect(goproxy.AlwaysMitm)"
// UrlMatches returns a ReqCondition testing whether the destination URL
"// (buggy, there can be IPv6 addresses it doesn't catch)"
// struct returned will determine what to do with this request. ConnectAccept will simply accept the request
"// ProxyConds.Do will register the RespHandler on the proxy, h.Handle(resp,ctx) will be called on every"
// RespCondition.HandleReq will decide whether or not to use the RespHandler on an HTTP response
//	proxy.OnRequest().HandleConnect(goproxy.AlwaysReject) // rejects all CONNECT requests
"// Upon calling ProxyConds.Do, it will register a RespHandler that would"
"// You will use the ReqProxyConds struct to register a ReqHandler, that would filter"
"// do with this request. The handler returns a ConnectAction struct, the Action field in the ConnectAction"
"// ReqHostIs returns a ReqCondition, testing whether the host to which the request is directed to equal"
// in the Middle attack to eavesdrop the connection. All regular handler will be active on this eavesdropped
//		}
"// ReqProxyConds aggregate ReqConditions for a ProxyHttpServer. Upon calling Do, it will register a ReqHandler that would"
"// ReqProxyConds.Do will register the ReqHandler on the proxy,"
"// ReqConditionFunc.HandleReq(req,ctx) <=> ReqConditionFunc(req,ctx)"
"// has the given prefix, with or without the host."
// ContentTypeIs returns a RespCondition testing whether the HTTP response has Content-Type header equal
// DstHostIs returns a ReqCondition testing wether the host in the request url is the given string
"// For example UrlHasPrefix(""host/x"") will match requests of the form 'GET host/x', and will match"
// before sending it to the remote server
"//	proxy.OnResponse(cond1,cond2).Do(handler) // handler.Handle(resp,ctx) will be used"
//	passHash := h.Sum(nil)
"// ProxyHttpServer.OnRequest Will return a temporary ReqProxyConds struct, aggregating the given condtions."
"// RespConditionFunc.HandleResp(resp,ctx) <=> RespConditionFunc(resp,ctx)"
// aggregated in the ReqProxyConds are met. Typical usage:
// will use the default tls configuration.
"// of the request matches the given regexp, with or without prefix"
// ProxyConds.DoFunc is equivalent to proxy.OnResponse().Do(FuncRespHandler(f))
// error sending the request.
"//	proxy.OnRequest(cond1,cond2).Do(handler)"
// to one of the given strings
"//	proxy.OnRequest(goproxy.Not(goproxy.ReqHostMatches(regexp.MustCompile("":443$"")))."
"// HandleConnectFunc is equivalent to HandleConnect,"
"// ReqHostMatches returns a ReqCondition, testing whether the host to which the request was directed to matches"
//	})
// HandleBytes will return a RespHandler that read the entire body of the request
"// The ConnectAction struct contains possible tlsConfig that will be used for eavesdropping. If nil, the proxy"
// ReqConditionFunc cannot test responses. It only satisfies RespCondition interface so that
// handle the HTTP response from remote server if all conditions on the HTTP response are met.
"//	proxy.OnRequest().Do(handler) // will call handler.Handle(req,ctx) on every request to the proxy"
"// AlwaysMitm is a HttpsHandler that always eavesdrop https connections, for example to"
"// eavesdrop all https connections to www.google.com, we can use"
"// client, and ConnectMitm, will assume the underlying connection is an HTTPS connection, and will use Man"
// Not returns a ReqCondition negating the given ReqCondition
// the ReqHandler will handle the HTTP request if all the conditions
// UrlHasPrefix returns a ReqCondition checking wether the destination URL the proxy client has requested
// request that matches the conditions aggregated in pcond.
"//	proxy.OnRequest().HandleConnectFunc(func(host string, ctx *ProxyCtx) (*ConnectAction, string) {"
// Add handlers to respHandlers
// Add handlers to httpsHandlers 
// The correct way to manipulate the HTTP request using URL.Path as condition is:
// Add handlers to reqHandlers
"// handler called after proxy receives HTTP Response from destination host, and before proxy forward "
"// only got the URL.Hostname and URL.Port during the HTTP CONNECT phase if the scheme is HTTPS, which is"
// with destination host
// the Response to the client.
"// This will NOT reject the HTTPS request with URL ending with gif, due to the fact that proxy "
// This rejects the HTTPS request to *.reddit.com during HTTP CONNECT phase
// quiet common these days.
"// handler called after receiving HTTP CONNECT from the client, and before proxy establish connection "
// handler called before proxy send HTTP request to destination host
"// TODO(elazar): instead of this ugly hack, just encode the certificate and hash the binary form."
// Use the provided ca and not the global GoproxyCa for certificate generation.
// Avoid deterministic random numbers
