"(!AddSummaryTableRowInfo(tableRow, dllName, hookCount"
"(!EnumProcesses(processes, sizeof(processes"
"(!ReadFile(hFile, pDllImageBase, dwFileLen, &dwNumberOfBytesRead, NULL"
"(!ReadProcessMemory(hProcess, processBasicInformation.PebBaseAddress, &peb, sizeof(PEB"
"(""%02X"", *((PBYTE"
"(""Capstone initialization failed.\n"""
"(""\n"""
"(""\t[+] Function %s HOOKED!\n\n"", functionName"
"(""\t\t(ERROR: Failed to disassemble given code!"
"(""\t\t0x%llX:\t%s\t\t%s\n"", insn[j].address, insn[j].mnemonic, insn[j].op_str"
"(""{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}"""
"(&peb, hProcess, row, verbose, printDisass"
"(&table, verbose"
"(DWORD i = 0; i < ntHeaders->FileHeader.NumberOfSections; i++, sectionHeader++"
"(DWORD* pids, SIZE_T pidListSize, LPSUMMARY_TABLE table, BOOL verbose, BOOL printDisass"
"(HANDLE hFile, DWORD dwFileLen"
"(HANDLE remoteProcess, LDR_DATA_TABLE_ENTRY ldrEntry"
"(HANDLE remoteProcess, PEB_LDR_DATA ldr, LDR_DATA_TABLE_ENTRY* ldrEntry"
"(L""%s"", banner"
"(L""%ws PID: %d has %d hooked functions\n"", (row->TotalHooks > 0 ? L""[+]"" : L""[-]"""
"(L""---\n[*] Working on process %d of %llu with PID: %d\n"", count+1, pidListSize, pids[count]"
"(L""Invalid PID.\n\n"""
"(L""Options:\n"""
"(L""Usage: HookSentry.exe [-a|-p <PID>|-v]\n"""
"(L""[!!!] out of memory\n"""
"(L""[!] (PID: %d"
"(L""[!] Error reading file. Error: %lu\n"", GetLastError("
"(L""[!] out of memory\n"""
"(L""[*] %d active processes found\n"", cbProcesses"
"(L""[*] Full system scan requested (could take a while"
"(L""[*] Selected current process.\n"""
"(L""[-] Failed to enumerate processes.\n"""
"(L""[-] Handle on process %d not obtained. Error: %lu\n"", pids[count], GetLastError("
"(L""[-] NtQueryInformationProcess call failed.\n"""
"(L""[-] ReadProcessMemory - Error: %lu.\n"", GetLastError("
"(L""\n"""
"(L""\n\n*** SUMMARY ***\n\n"""
"(L""\n\t\tFunction on disk:\n\n"""
"(L""\t%s contains %d hooks\n"", dllInfo->DllFullPath, dllInfo->HooksCount"
"(L""\t%s skipped.\n"", dllInfo->DllFullPath"
"(L""\t-a, --all: Analyze all active processes\n"""
"(L""\t-d, --disass: Display disassembled code\n"""
"(L""\t-h, --help: Show this message\n"""
"(L""\t-p <PID>, --pid <PID>: Analyze the process with PID <PID>\n"""
"(L""\t-v, --verbose: Enable verbose output\n"""
"(L""\t\tFunction in memory:\n\n"""
"(LPSUMMARY_TABLE lpSummaryTable, BOOL verbose"
"(LPSUMMARY_TABLE lpSummaryTable, DWORD dwPid"
"(LPSUMMARY_TABLE_ROW lpSummaryTableRow, PWSTR pszDllFullPath, DWORD dwHooksCount"
"(NtQueryInformationProcess(hProcess, ProcessBasicInformation, &processBasicInformation, sizeof(PROCESS_BASIC_INFORMATION"
"(PCHAR, pDllImageBase, RvaToFileOffset(ntHeader, iNames[numberOfNames - 1]"
"(PDWORD, pDllImageBase, RvaToFileOffset(ntHeader, exportDirectory->AddressOfFunctions"
"(PDWORD, pDllImageBase, RvaToFileOffset(ntHeader, exportDirectory->AddressOfNames"
"(PIMAGE_NT_HEADERS ntHeaders, DWORD rva"
"(PIMAGE_NT_HEADERS, pDllImageBase, dosHeader->e_lfanew"
"(PPEB peb, HANDLE remoteProcess, LPSUMMARY_TABLE_ROW tableRow, BOOL verbose, BOOL printDisass"
"(PPEB peb, HANDLE remoteProcess, PEB_LDR_DATA* ldr"
"(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pids[count]"
"(PVOID startAddr, SIZE_T size, DWORD64 vaAddr"
"(PVOID, ldrEntry.DllBase, vaFunctionAddress"
"(PVOID, pDllImageBase, RvaToFileOffset(ntHeader, vaFunctionAddress"
"(PWORD, pDllImageBase, RvaToFileOffset(ntHeader, exportDirectory->AddressOfNameOrdinals"
"(TYPE, BASE, RVA"
"(ULONG_PTR, pDllImageBase, RvaToFileOffset(ntHeader, exportTableVA"
"(_wcsnicmp(dllName, SYSTEM_DLL_PATH, wcslen(SYSTEM_DLL_PATH"
"(argv[i], L""--all"""
"(argv[i], L""--disass"""
"(argv[i], L""--help"""
"(argv[i], L""--pid"""
"(argv[i], L""--verbose"""
"(csHandle, (BYTE*"
"(cs_open(CS_ARCH_X86, CS_MODE_64, &csHandle"
"(dllName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL"
"(dllName, ldrEntry.FullDllName.MaximumLength, ldrEntry.FullDllName.Buffer, ldrEntry.FullDllName.MaximumLength"
"(hFile, NULL"
"(hFile, dwFileLen"
"(iFunctionAddress, 15, vaFunctionAddress"
"(insn, count"
"(int argc, wchar_t* argv[]"
"(lib, ""capstone.lib"""
"(lib, ""ntdll"""
"(lib, ""psapi"""
"(lpSummaryTable->Rows, (lpSummaryTable->RowsCount + 1"
"(lpSummaryTableRow->DllInfos, (lpSummaryTableRow->DllsCount + 1"
"(mFunctionAddress, 15, vaFunctionAddress"
"(memcmp(mFunctionAddress, iFunctionAddress, 15"
"(or ""Your"""
"(peb, remoteProcess, &ldr"
"(pids, 1, &table, verbose, disass"
"(processes, cbProcesses, &table, verbose, disass"
"(remoteProcess, (PLDR_DATA_TABLE_ENTRY"
"(remoteProcess, ldr, &ldrEntry"
"(remoteProcess, ldr.Reserved2[1], ldrEntry, sizeof(LDR_DATA_TABLE_ENTRY"
"(remoteProcess, ldrEntry"
"(remoteProcess, ldrEntry.FullDllName.Buffer, dllName, ldrEntry.FullDllName.MaximumLength, NULL"
"(remoteProcess, mFunctionAddress, mFunctionContent, 15, NULL"
"(remoteProcess, peb->Ldr, ldr, sizeof(PEB_LDR_DATA"
"(table, pids[count]"
"(the ""License"""
"(verbose, ..."
"(verbose, L""[*] %s not a system library. skipped.\n"", dllName"
"(verbose, L""[*] Working on: %s\n"", dllName"
"(wcscmp(argv[i], L""-a"""
"(wcscmp(argv[i], L""-d"""
"(wcscmp(argv[i], L""-h"""
"(wcscmp(argv[i], L""-p"""
"(wcscmp(argv[i], L""-v"""
(!fullScan && pid == 0
(!fullScan && pid > 0
(!hFile || hFile == INVALID_HANDLE_VALUE
(!hProcess
(&csHandle
(&table
('$(UserRootDir
((ULONG_PTR
()
(*(BYTE*
(0
(1
(50%
(;;
(AdditionalIncludeDirectories
(Configuration
(DLL_INFO
(DWORD
(DWORD count = 0; count < pidListSize; count++
(DWORD i = 0; i < lpSummaryTable->RowsCount; i++
(DWORD j = 0; j < row->DllsCount; j++
(DWORD k = 0; k < row->DllsCount; k++
(GetProcessHeap(
(LDR_DATA_TABLE_ENTRY
(LPDLL_INFO
(LPSUMMARY_TABLE lpSummaryTable
(LPSUMMARY_TABLE_ROW
(MonoDevelop/Xamarin Studio
(PEB_LDR_DATA*
(PIMAGE_DATA_DIRECTORY
(PIMAGE_DOS_HEADER
(PIMAGE_EXPORT_DIRECTORY
(PLDR_DATA_TABLE_ENTRY
(PTVS
(PWSTR
(Platform
(PreprocessorDefinitions
(ProjectConfigurationPlatforms
(SUMMARY_TABLE_ROW
(SolutionConfigurationPlatforms
(SolutionDir
(SolutionProperties
(TYPE
(UserRootDir
(VCTargetsPath
(VSHistory
(Xamarin productivity tool
([0-9]
([0-9][0-9]
(_
(__VA_ARGS__
(a
(an example is provided in the Appendix below
(argv[i + 1]
(b
(c
(contains which files were open etc.
(count > 0
(cross platform F# VS Code tools
(d
(dllInfo->HooksCount == -1
(dllName
(dllName == NULL
(dwFileLen == INVALID_FILE_SIZE
(except as stated in this section
(fullScan
(hFile
(hProcess
(hookCount > 0
(https://github.com/github/gitignore/pull/1529#issuecomment-104372622
(https://github.com/github/gitignore/pull/2483#issue-259490424
(i
(ii
(iii
(including negligence
(int i = 0; i < argc; i++
(int i = 0; i <= size; i++
(ldr.Reserved2[1]
(ldrEntry.DllBase == NULL
(ldrEntry.FullDllName.MaximumLength
(ldrEntry.Reserved1[0]
(lpSummaryTable->Rows
(lpSummaryTable->Rows == NULL
(lpSummaryTableRow->DllInfos == NULL
(ntHeaders
(numberOfNames > 0
(or bind by name
(or derived from
(pDllImageBase == NULL
(peb->Ldr
(pid == 0
(printDisass
(remoteProcess != NULL
(row == NULL
(row->DllInfos
(row->DllInfos[j].DllFullPath
(rva >= sectionAddress && rva < sectionAddress + sectionSize
(s
(sass
(size_t j = 0; j < count; j++
(verbose
(with potential passwords
(working project files containing files to include in project
