COPY . .
COPY --from=builder /go/croc/croc /go/croc/croc-entrypoint.sh /
EXPOSE 9012
EXPOSE 9013
USER nobody
EXPOSE 9011
EXPOSE 9009
WORKDIR /go/croc
EXPOSE 9010
"CMD [""relay""]"
"ENTRYPOINT [""/croc-entrypoint.sh""]"
FROM golang:1.22-alpine as builder
FROM alpine:latest
"RUN go build -v -ldflags=""-s -w"""
RUN apk add --no-cache git gcc musl-dev
wget -qO- https://getcroc.schollz.com 
stdout
 that are interrupted
"). A set of options (like custom relay, ports, and code phrase) can be set using "
"), but you must have a minimum of "
choco install croc
emerge net-misc/croc
 Using 
"On Windows you can install the latest release with [Scoop](https://scoop.sh/), [Chocolatey](https://chocolatey.org), or [Winget](https://learn.microsoft.com/en-us/windows/package-manager/): "
go install github.com/schollz/croc/v10@latest
"    width=""408px"" border=""0"" alt=""croc"">"
 will be excluded from the transfer.
end-to-end encryption
" with the secret as an environment variable. For example, to receive with the secret "
"croc send --text ""hello world"""
 of the following:
"On Linux, macOS, and Windows you can install from [conda-forge](https://github.com/conda-forge/croc-feedstock/) globally with ["
 Install
stderr
.venv
"Available curves are P-256, P-348, P-521 and SIEC. P-256 is the default curve."
 (using PAKE)
 to transfer data (using a relay)
sudo port install croc
<br>
"Note, when sending, you only need to include the first port (the communication port). The subsequent ports for data transfer will be transmitted back to the user from the relay."
- enables easy 
The code phrase is used to establish password-authenticated key agreement ([PAKE](https://en.wikipedia.org/wiki/Password-authenticated_key_agreement)) which generates a secret key for the sender and recipient to use for end-to-end encryption.
croc send --code [code-phrase] [file(s)-or-folder]
--remember
winget install schollz.croc
You can send files using your relay by entering 
or into a particular environment with [
curl https://getcroc.schollz.com 
 in the process list of a multi-user system and not leak the secret.
pixi
On Android there is a 3rd party F-Droid app [available to download](https://f-droid.org/en/packages/com.github.howeyc.crocgui/).
not needed
You can exclude folders from being sent by using the 
"Or, you can [install Go](https://golang.org/dl/) and build from source (requires Go 1.17"
"<a href=""https://github.com/schollz/croc/releases/latest""><img src=""https://img.shields.io/badge/version-v10.2.1-brightgreen.svg"
sudo port selfupdate
croc code-phrase
" has gone through many iterations, and I am awed by all the great contributions! If you feel like contributing, in any way, by all means you can send an Issue, a PR, or ask a question."
nix-env -i croc
croc --classic
 Send text
In this case 
On macOS you can install the latest release with [Homebrew](https://brew.sh/): 
xxhash
"style=flat-square"" alt=""Version""></a>"
use proxy
](https://pixi.sh/):
croc --yes --overwrite <code>
--socks5
- can 
For more information about 
--relay
any two computers
resuming transfers
 Allow overwriting without prompt
brew install croc
pacman -S croc
You can send with your own code phrase (must be more than 6 characters).
"croc --pass YOURPASSWORD --relay ""myreal.example.com:9009"" send [filename]"
"Download [the latest release for your system](https://github.com/schollz/croc/releases/latest), or install a release from the command-line:"
scoop install croc
"croc send --exclude ""node_modules,.venv"" [folder]"
 so it will not interfere with the message going to 
By default it uses TCP ports 9009-9013. Make sure to open those up. You can customize the ports (e.g. 
 to change the relay that you are using if you want to custom host your own.
--pass FILEWITHPASSWORD
--exclude
"croc relay --ports 1111,1112"
" flag (recipient only). For example, receive a file to automatically overwrite:"
 Self-host relay
If it's easier you can also run a relay with Docker:
" will automatically use the stdin data and send and assign a filename like ""croc-stdin-123456789"". To receive to "
 Custom code phrase
On Gentoo you can install with 
apk add bash coreutils
croc --curve p521 <codephrase>
" algorithm which is even faster, but since it samples files (versus reading the whole file) it can mistakenly determine that a file is the same on the two computers transferring - though this is only a problem if you are syncing files versus sending a new file to a computer."
- provides 
All of the other text printed to the console is going to 
On macOS you can also install the latest release with [MacPorts](https://macports.org/): 
 when they receive the text so it will be displayed.
pacman
- local server or port-forwarding 
This will show only 
imohash
 croc
You can pipe to 
You can choose from several different elliptic curves to use for encryption by using the 
dnf install croc
For a single-user system the default behavior can be permanently enabled by running
"Exclusions work by excluding any absolute path that contains the string. So in the above example, any folder named "
 receiving is slightly different to avoid [leaking the secret via the process name](https://nvd.nist.gov/vuln/detail/CVE-2023-43621). On these systems you will need to run 
"To send a file, simply do: "
" you can instead pass a file with the password, e.g. "
 transfers
cat [filename] 
", see [my blog post](https://schollz.com/software/croc6) or read a [recent interview I did](https://console.substack.com/p/console-91)."
 Acknowledgements
"Sometimes you want to send URLs or short text. In addition to piping, you can easily send text with "
"<a href=""https://github.com/schollz/croc/actions/workflows/ci.yml""><img"
Be sure to include the password for the relay otherwise any requests will be rejected. 
On FreeBSD you can install with 
 folders or 
portage
multiple file
 Usage
 croc send
". For example, you can send via a tor relay:"
 Excluding folders
"    src=""https://user-images.githubusercontent.com/6550035/46709024-9b23ad00-cbf6-11e8-9fb2-ca8b20b7dbec.jpg"""
CROC_SECRET=
", like tor"
 is the only CLI file-transfer tool that does 
](https://docs.conda.io/projects/conda/):
pkg install croc
"croc --socks5 ""127.0.0.1:9050"" send SOMEFILE"
"Status""></a> "
 Change hash algorithm
This will automatically tell the receiver to use 
croc relay
" flag with a string of comma-delimited exclusions. For example, if you want to send a folder but exclude any "
 folders:
You can use a proxy as your connection to the relay by adding a proxy address with 
On Fedora you can install with 
 Change encryption curve
docker run -d -p 9009-9013:9009-9013 -e CROC_PASS='YOURPASSWORD' schollz/croc
--overwrite
 Self-host relay (docker)
 algorithm which is fast and thorough. If you want to optimize for speed you can use the 
" is a tool that allows any two computers to simply and securely transfer files and folders. AFAIK, "
Note: when including 
 on Linux or Mac OS
cross-platform
You can choose from several different hash algorithms. The default is the 
 uses a public relay but you can also run your own relay:
 ports for the relay. The first port is for communication and the subsequent ports are used for the multiplexed data transfer.
![Example](src/install/customization.gif)
"Thanks [@warner](https://github.com/warner) for the [idea](https://github.com/warner/magic-wormhole), [@tscholl2](https://github.com/tscholl2) for the [encryption gists](https://gist.github.com/tscholl2/dc7dc15dc132ea70a98e8542fefffa28), [@skorokithakis](https://github.com/skorokithakis) for [code on proxying two connections](https://www.stavros.io/posts/proxying-two-connections-go/). Finally thanks for making pull requests [@maximbaz](https://github.com/maximbaz), [@meyermarcel](https://github.com/meyermarcel), [@Girbons](https://github.com/Girbons), [@techtide](https://github.com/techtide), [@heymatthew](https://github.com/heymatthew), [@Lunsford94](https://github.com/Lunsford94), [@lummie](https://github.com/lummie), [@jesuiscamille](https://github.com/jesuiscamille), [@threefjord](https://github.com/threefjord), [@marcossegovia](https://github.com/marcossegovia), [@csleong98](https://github.com/csleong98), [@afotescu](https://github.com/afotescu), [@callmefever](https://github.com/callmefever), [@El-JojA](https://github.com/El-JojA), [@anatolyyyyyy](https://github.com/anatolyyyyyy), [@goggle](https://github.com/goggle), [@smileboywtu](https://github.com/smileboywtu), [@nicolashardy](https://github.com/nicolashardy), [@fbartels](https://github.com/fbartels), [@rkuprov](https://github.com/rkuprov), [@hreese](https://github.com/hreese), [@xenrox](https://github.com/xenrox) and [Ipar](https://github.com/lpar)!"
 Use pipes - stdin and stdout
" transfers (Windows, Linux, Mac)"
--help
" flag. Only the recipient can choose the curve. For example, receive a file using the P-521 curve:"
On Arch Linux you can install the latest release with 
--yes
"On Linux and Mac OS, the sending "
conda
croc --yes [code-phrase] > out
croc
 with ipv4 fallback
--pass YOURPASSWORD
On Unix you can install the latest release with [Nix](https://nixos.org/nix):
On Alpine Linux you have to install dependencies first:
croc send --hash imohash SOMEFILE
On Termux you can install with 
"By default, croc will prompt whether to overwrite a file. You can automatically overwrite files by using the "
pixi global install croc
"The relay is needed to staple the parallel incoming and outgoing connections. By default, "
 bash
  will automatically approve the transfer and pipe it out to 
"Then to receive the file (or folder) on another computer, you can just do "
node_modules
 or 
 License
bash
conda install --channel conda-forge croc
"croc --relay ""myrelay.example.com:9009"" send [filename]"
There are a number of configurable options (see 
 at you can always just use the 
 Use a proxy
"<p align=""center"">"
"<p align=""center"">This project is supported by <a href=""https://github.com/sponsors/schollz"">Github sponsors</a>.</p>"
<img
Sending 'file-or-folder' (X MB)
Code is: code-phrase
Run this command again to disable classic mode.
--curve
- allows 
and confirming. 
ipv6-first
"src=""https://github.com/schollz/croc/actions/workflows/ci.yml/badge.svg"" alt=""Build"
$ croc send [file(s)-or-folder]
!/bin/sh
set -e
 then
"if [ -n ""$CROC_PASS"" ]"
"exec /croc ""$@"""
"    set -- --pass ""$CROC_PASS"" ""$@"""
"THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR"
"in the Software without restriction, including without limitation the rights"
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER"
MIT License
"Permission is hereby granted, free of charge, to any person obtaining a copy"
"furnished to do so, subject to the following conditions:"
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,"
"of this software and associated documentation files (the ""Software""), to deal"
SOFTWARE.
Copyright (c) 2017-2025 Zack
"copies of the Software, and to permit persons to whom the Software is"
copies or substantial portions of the Software.
The above copyright notice and this permission notice shall be included in all
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell"
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,"
archives:
    tap:
project_name: croc
        format: zip
    - CGO_ENABLED=0
      - README.md
      netbsd: NetBSD
scoop:
  ignore:
    - arm
      arm64: ARM64
 Wether its enabled or not.
  env:
    test: 
    
  goarch:
      - bash_autocomplete
"    vendor: ""schollz.com"""
      linux: Linux
      arm: ARM
    format: tar.gz
    folder: Formula
announce:
      - zsh_autocomplete
    - windows
    format_overrides:
  twitter:
    - freebsd
    - goos: darwin
    replacements:
"  homepage: ""https://schollz.com/software/croc/"""
  goarm:
      freebsd: FreeBSD
      goarch: arm
    - linux
"      bin.install ""croc"""
 Defaults to false.
      darwin: macOS
      amd64: 64bit
    - amd64
    owner: schollz
    - openbsd
"      system """
      owner: schollz
    install: 
    - dragonfly
    - 386
    name: scoop-bucket
"    license: ""MIT"""
    - goos: freebsd
"    maintainer: ""Zack Scholl <zack.scholl@gmail.com>"""
"{bin}/croc --version"""
  goos:
      name: homebrew-tap
      386: 32bit
build:
    - 7
      windows: Windows
"    file_name_template: ""{{.ProjectName}}_{{.Version}}_{{.Os}}-{{.Arch}}"""
      goarch: 386
"  ldflags: -s -w -X main.Version=""v{{.Version}}-{{.Date}}"""
    enabled: false
"    homepage: ""https://schollz.com/software/croc/"""
  bucket:
"    description: ""A simple, secure, and fast way to transfer data."""
      - LICENSE
"  description: ""croc is a tool that allows any two computers to simply and securely transfer files and folders."""
    - arm64
nfpms:
  binary: croc
    files:
    - netbsd
"    name_template: ""{{.ProjectName}}_{{.Version}}_{{.Os}}-{{.Arch}}"""
  main: main.go
      - goos: windows
      openbsd: OpenBSD
      - deb
    - darwin
      dragonfly: DragonFlyBSD
brews:
    formats:
"    description: ""croc is a tool that allows any two computers to simply and securely transfer files and folders."""
  license: MIT
github.com/schollz/logger v1.2.0 h1:5WXfINRs3lEUTCZ7YXhj0uN
github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0
github.com/russross/blackfriday/v2 v2.0.1/go.mod h1:
github.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
golang.org/x/net v0.34.0/go.mod h1:di0qlW3YNM5oh6GqDGQr92MyTozJPmybPK4Ev/Gm31k=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug
golang.org/x/text v0.7.0/go.mod h1:mrYo
github.com/schollz/progressbar/v3 v3.18.0/go.mod h1:IsO3lpbaGuzh8zIMzgY3
B6ybOBKMaSxLj6P6oBDfU=
golang.org/x/term v0.20.0/go.mod h1:8UkIAJTvZgivsXaD6/pH6U9ecQzZ45awqEOzuCvwpFY=
github.com/magisterquis/connectproxy v0.0.0-20200725203833-3582e84f0c9b h1:xZ59n7Frzh8CwyfAapUZLSg
golang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4
golang.org/x/time v0.9.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=
golang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=
github.com/chengxilo/virtualterm v1.0.4 h1:Z6IpERbRVlfB8WkOmtbHiDbBANU7cimRIof7mk9/PwM=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/chzyer/readline v1.5.1 h1:upd/6fQk4src78LMRzh5vItIt361/o4uq553V8B5sGI=
golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
github.com/schollz/pake/v3 v3.0.5 h1:MnZVdI987lkjln9BSx/zUb724TZISa2jbO
golang.org/x/crypto v0.32.0/go.mod h1:ZnnJkOaASj8g0AjIduWNlq2NRxL0PlBrbKVyZ6V/Ugc=
github.com/sabhiram/go-gitignore v0.0.0-20210923224102-525f6e181f06 h1:OkMGxebDjyw0ULyrTYWeN0UNCCkmCWfjPnIA2W6oviI=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
rwdDfMAkV7OtwuqBVzrE8GR6GFx
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
nxYbc=
github.com/schollz/logger v1.2.0/go.mod h1:P6F4/dGMGcx8wh
3BoSGCbBAcpTsTg=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
github.com/minio/highwayhash v1.0.3/go.mod h1:GGYsuwP/fPD6Y9hMiXuapVvlIUEhFhMTh0rxU3ik1LQ=
wExME=
github.com/tscholl2/siec v0.0.0-20240310163802-c2c6f6198406/go.mod h1:KL9
8e9klMJ9c=
golang.org/x/net v0.34.0 h1:Mb7Mrk043xzHgnRM88suvJFwzVrRfHEHJEl5/71CKw0=
/6zg
golang.org/x/term v0.5.0/go.mod h1:jMB1sMXY
golang.org/x/time v0.9.0 h1:EsRrnYcQiGH
wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
8k2iDTWaHskEEV5NiAxGrdsCL36VU=
github.com/kalafut/imohash v1.1.0/go.mod h1:6cn9lU0Sj8M4eu9UaQm1kR/5y3k/ayB68yntRhGloL4=
github.com/chengxilo/virtualterm v1.0.4/go.mod h1:DyxxBZz/x1iqJjFxTFcr6/x
github.com/tscholl2/siec v0.0.0-20240310163802-c2c6f6198406 h1:sDWDZkwYqX0jvLWstKzFwh
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px
golang.org/x/sync v0.6.0/go.mod h1:Czt
Hm0VOH/i9J2
golang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62
github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75
github.com/skip2/go-qrcode v0.0.0-20200617195104-da1b6568686e/go.mod h1:XV66xRDqSt
golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5
golang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz
golang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
golang.org/x/sync v0.10.0/go.mod h1:Czt
golang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=
f6Lvsy/wHu
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/term v0.12.0/go.mod h1:owVbMEjm3cBLCHdkQu9b1opXd4ETQWc3BhuQGKgXgvU=
kG1zrNEd4vnNpEBY/mwEMd/vn6AM=
golang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT
abF5XlKShorW5LRoQ=
golang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4
2E5dAYhXwXZwtnZ6UAqBI28
QYcTipZLbtDg=
17Eiy94tnKShWo=
SDo693bJlVdllGtEeKM=
zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=
golang.org/x/telemetry v0.0.0-20240228155512-f48c80bd79b2/go.mod h1:TeRTkGYfJXctD9OcfyVLyj2J3IxLnKwHJR8f4D8a3YE=
J8l4C8GjO0Y9S69eFvNsec=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E
github.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=
golang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=
tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=
golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
uEAv1htQ0V83Z9Rj
github.com/cpuguy83/go-md2man/v2 v2.0.6/go.mod h1:oOW0eioCTA6cOiMLiUPZOpcVxMig6NIQQ7OS05n1F4g=
github.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0
Abc=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5
5FfbgvV4AP7qEZstoyrHB0DzarOQ4ZY=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
golang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR
golang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
github.com/schollz/peerdiscovery v1.7.6/go.mod h1:iTa0MWSPy49jJ2HcXL5oSSnFsd6olEUorAFljxbnj2I=
github.com/chzyer/test v1.0.0 h1:p3BQDXSxOhOG0P9z6/hGnII4LGiEPOYBhs8asl/fC04=
github.com/twmb/murmur3 v1.1.5/go.mod h1:Qq/R7NUyOfr65zD
5A1VGuI=
golang.org/x/sys v0.0.0-20220310020820-b874c991c1a5/go.mod h1:oPkhp1MJrh7nUepCBck5
phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
github.com/mitchellh/colorstring v0.0.0-20190213212951-d06e56a500db/go.mod h1:l0dey0ia/Uv7NcFFVbCLtqEBQbrT4OCwCSKTEv6enCw=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E
GTGFMVlhk3ULuV0y9ZmzeVGR4mloJI3M=
3quACPkgCx/L
73PCFmPWxNTLm
golang.org/x/net v0.6.0/go.mod h1:2Tu9
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/term v0.28.0/go.mod h1:Sw/lC2IAUZ92udQNf3WodGtn4k/XoLyZoh8v/8uiwek=
EgEM=
golang.org/x/crypto v0.13.0/go.mod h1:y6Z2r
c5H38=
github.com/minio/highwayhash v1.0.3 h1:kbnuUMoHYyVl7szWjSxJnxw11k2U709jqFPPmIUyD6Q=
mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5
github.com/denisbrodbeck/machineid v1.0.1 h1:geKr9qtkB876mXguW2X6TU4ZynleN6ezuMSRhl4D7AQ=
rp2Bjs=
github.com/chzyer/logex v1.2.1/go.mod h1:JLbx6lG2kDbNRFnfkgvh4eRJRPX1QCoOIWomwysCBrQ=
gdHgsdTPH6ImJMIp436vR6MPtH8gP05QzM=
github.com/denisbrodbeck/machineid v1.0.1/go.mod h1:dJUwb7PTidGDeYyUBmXZ2GphQBbjJCrnectwCyxcUSI=
0bjPO0LkuOLi4/5GtJWs/s=
github.com/twmb/murmur3 v1.1.8 h1:8Yt9taO/WN3l08xErzjeschgZU2QSrwm1kclYq
vZkEQ=
b79XXUwfKfcPLepksvw2tcLE/Ct21YObkaSkeBlk=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:
Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=
github.com/twmb/murmur3 v1.1.8/go.mod h1:Qq/R7NUyOfr65zD
golang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI
golang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2
golang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
github.com/mitchellh/colorstring v0.0.0-20190213212951-d06e56a500db h1:62I3jR2EmQ4l5rM/4FEfDWcRD
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5
49Oc5Mq64VQ=
ubr1JZdaKjgAaHr
mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=
6Q5IHKsJLwP7exErjN6lyyq3OSQ=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5
aqLLLmKrsjNrUguwk=
github.com/tscholl2/siec v0.0.0-20210707234609-9bdfc483d499/go.mod h1:KL9
github.com/chzyer/logex v1.2.1 h1:XHDu3E6q
golang.org/x/net v0.15.0/go.mod h1:idbUs1IY1
golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF
github.com/kalafut/imohash v1.1.0 h1:Lldcmx0SXgMSoABB2WBD8mTgf0OlVnISn2Dyrfg2Ep8=
0aRg=
github.com/chzyer/readline v1.5.1/go.mod h1:Eh
pYhQNaVg65BgSkCP/f7U=
ePHsJ1keEjQtpvf9HHw0f4ZeJ0TLRsxhunSI2hYJSs=
golang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54
golang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=
gXH5m63YEaFCMpDHhpI=
github.com/schollz/cli/v2 v2.2.1 h1:ou22Mj7ZPjrKz
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0
golang.org/x/sync v0.7.0/go.mod h1:Czt
golang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW
i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
C64Yfv1cQ7kz7rIZviUmN
github.com/schollz/progressbar/v3 v3.18.0 h1:uXdoHABRFmNIjUfte/Ex7WtuyVslrw2wVPQmCN62HpA=
dPj6BvgQ=
github.com/schollz/peerdiscovery v1.7.6 h1:HJjU1cXcNGfZgenC/vbry9F6CH9B8f
IJeTBvfc=
golang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5
eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ
jr3Dg1NNxqwp
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
kqSMx2CaBsrgA7czyZG/E6dU=
github.com/skip2/go-qrcode v0.0.0-20200617195104-da1b6568686e h1:MRM5ITcdelLK2j1vwZ3Je0FKVCfqOLp5zO6trqMLYs0=
golang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
ECip1KBveYUHfp
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/text v0.3.7/go.mod h1:u
pc6Ldnwhi/IjpwHt7yyuwOQ=
github.com/magisterquis/connectproxy v0.0.0-20200725203833-3582e84f0c9b/go.mod h1:uDd4sYVYsqcxAB8j
github.com/chzyer/test v1.0.0/go.mod h1:2JlltgoNkt4TW/z9V/IzDdFaMTM2JPIi26O1pF38GC8=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI
rkHYY13jYWTU97c=
golang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
github.com/cpuguy83/go-md2man/v2 v2.0.0-20190314233015-f79a8a8ca69d/go.mod h1:maD7wRr/U5Z6m/iR4s
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
github.com/sabhiram/go-gitignore v0.0.0-20210923224102-525f6e181f06/go.mod h1:
aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS
golang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs
github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r
github.com/cpuguy83/go-md2man/v2 v2.0.6 h1:XJtiaUW6dEEqVuZiMTn1ldk455QWwEIsMIJlo5vtkx0=
tCytEncXBa1pR6FjbTsOJnw=
golang.org/x/crypto v0.32.0 h1:euUpcYgM8WcP71gNpTqQCn6rC2t6ULUPiOzfWaXVVfc=
github.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/sys v0.21.0/go.mod h1:/VUhepiaJMQUp4
github.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=
e2cm9otk0dWdXHAEo=
Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
qukjizvITLm3Ca2m0Ho=
golang.org/x/mod v0.15.0/go.mod h1:hTbmBsO62
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
golang.org/x/term v0.28.0 h1:/Ts8HFuMR2E6IP/jlo7QVLZHggjKQbhu/7H0LJFr3Gg=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b
3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm
golang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=
jSpqN0iwWCOK1q10rlY=
E42TnysNCUPdjciGhY=
golang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=
Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/schollz/cli/v2 v2.2.1/go.mod h1:My6bfphRLZUhZdlFUK8scAxMWHydE7k4s2ed2Dtnn
github.com/schollz/pake/v3 v3.0.5/go.mod h1:OGbG6htRwSKo6V8R5tg61ufpFmZM1b/PrrSp6g2ZLLc=
Q7uhL6IJCs/r1kxib1HV4bgOMg=
/croc
zsh_autocomplete
 Binaries
dist
.idea/
src/utils/bigfile.test
.vscode/
test1/
croc-stdin
bash_autocomplete
/croc.exe
// Wait for a termination signal
//go:generate go run src/install/updateversion.go
"""github.com/schollz/croc/v10/src/cli"""
runtime.GC() // get up-to-date statistics
// }()
"""syscall"""
if err := pprof.WriteHeapProfile(f)
for {
import (
func main() {
 time.Second)
"""github.com/schollz/croc/v10/src/utils"""
"fmt.Println(""wrote profile"")"
utils.RemoveMarkedFiles()
os.Exit(0)
_ = <-sigs
fmt.Println(err)
// Exit the program gracefully
// go func() {
go func() {
"//go:generate git commit -am ""bump $VERSION"""
"signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)"
if err := cli.Run()
"f, err := os.Create(""croc.pprof"")"
time.Sleep(3 
"""os"""
 err != nil {
"""fmt"""
panic(err)
"// ""github.com/pkg/profile"""
os.Exit(1)
f.Close()
"//go:generate git tag -af v$VERSION -m ""v$VERSION"""
if err != nil {
package main
"""os/signal"""
"sigs := make(chan os.Signal, 1)"
// Create a channel to receive OS signals
script:
  - env GO111MODULE=on go build -v
  - dev
install: true
  - win
env:
  - env GO111MODULE=on go test -v -cover github.com/schollz/croc/v10/src/tcp
language: go
  - env GO111MODULE=on go test -v -cover github.com/schollz/croc/v10/src/croc
  - env GO111MODULE=on go test -v -cover github.com/schollz/croc/v10/src/crypt
  - tip
  - env GO111MODULE=on go test -v -cover github.com/schollz/croc/v10/src/compress
  - env GO111MODULE=on go test -v -cover github.com/schollz/croc/v10/src/utils
  except:
branches:
"  - ""PATH=/home/travis/gopath/bin:$PATH"""
  - env GO111MODULE=on go test -v -cover github.com/schollz/croc/v10/src/comm
[Unit]
After=network.target
Description=croc relay
ExecStart=/usr/bin/croc relay
[Service]
Type=simple
WantedBy=multi-user.target
[Install]
CapabilityBoundingSet=CAP_NET_BIND_SERVICE
DynamicUser=yes
github.com/tscholl2/siec v0.0.0-20240310163802-c2c6f6198406 // indirect
github.com/russross/blackfriday/v2 v2.1.0 // indirect
github.com/minio/highwayhash v1.0.3
github.com/cespare/xxhash/v2 v2.3.0
module github.com/schollz/croc/v10
github.com/rivo/uniseg v0.4.7 // indirect
github.com/chzyer/readline v1.5.1
github.com/davecgh/go-spew v1.1.1 // indirect
golang.org/x/crypto v0.32.0
github.com/schollz/progressbar/v3 v3.18.0
github.com/magisterquis/connectproxy v0.0.0-20200725203833-3582e84f0c9b
github.com/twmb/murmur3 v1.1.8 // indirect
github.com/stretchr/testify v1.9.0
golang.org/x/time v0.9.0
github.com/skip2/go-qrcode v0.0.0-20200617195104-da1b6568686e
require (
github.com/mitchellh/colorstring v0.0.0-20190213212951-d06e56a500db // indirect
github.com/cpuguy83/go-md2man/v2 v2.0.6 // indirect
golang.org/x/net v0.34.0
github.com/pmezard/go-difflib v1.0.0 // indirect
golang.org/x/term v0.28.0
toolchain go1.23.1
gopkg.in/yaml.v3 v3.0.1 // indirect
golang.org/x/sys v0.29.0
go 1.22
github.com/denisbrodbeck/machineid v1.0.1
github.com/schollz/cli/v2 v2.2.1
github.com/schollz/logger v1.2.0
github.com/sabhiram/go-gitignore v0.0.0-20210923224102-525f6e181f06
github.com/kalafut/imohash v1.1.0
github.com/schollz/pake/v3 v3.0.5
github.com/schollz/peerdiscovery v1.7.6
"""path"""
s   string
"fname, err := getConfigFile(true)"
} else {
"if flag == ""--remember"" {"
defer cancel()
"""[2620:119:35::35]"",      // Cisco OpenDNS"
return
 i < len(publicDNS)
// Create a context with a 500 millisecond timeout
"DEFAULT_RELAY6     = ""croc6.schollz.com"""
net.Resolver{
// TCP_BUFFER_SIZE is the maximum packet size
"fname = path.Join(configFile, ""internal-dns"")"
"DEFAULT_PORT       = ""9009"""
ipaddress = (<-result).s
// Use the context with timeout in the LookupHost function
"""8.8.8.8"",                // Google"
"""time"""
"func localLookupIP(address string) (ipaddress string, err error) {"
"addr, err = lookup(DEFAULT_RELAY6)"
go func(dns string) {
"""8.26.56.26"",             // Comodo"
"return d.DialContext(ctx, network, dns"
"err = fmt.Errorf(""failed to resolve %s: all DNS servers exhausted"", address)"
var addr string
"""208.67.220.220"",         // Cisco OpenDNS"
INTERNAL_DNS = true
"DEFAULT_RELAY6 = """""
"if flag == ""--internal-dns"" {"
"fname, err := getConfigFile(false)"
"func lookup(address string) (ipaddress string, err error) {"
"""9.9.9.9"",                // Quad9"
r := 
"""8.8.4.4"",                // Google"
// remoteLookupIP returns a host's IP address based on a remote DNS server.
"""[2606:4700:4700::1001]"", // Cloudflare"
"""[2620:119:53::53]"",      // Cisco OpenDNS"
break
"DEFAULT_RELAY6 = net.JoinHostPort(addr, DEFAULT_PORT)"
type Result struct {
"""[2620:fe::fe]"",          // Quad9"
"ctx, cancel := context.WithTimeout(context.Background(), 500"
"for _, dns := range publicDNS {"
}(dns)
"configFile, err := utils.GetConfigDir(requireValidPath)"
ipaddress = ip[0]
"""[2001:4860:4860::8888]"", // Google"
"func remoteLookupIP(address, dns string) (ipaddress string, err error) {"
"""1.0.0.1"",                // Cloudflare"
"""os"""
f.Close()
if err != nil {
"""context"""
"log.Tracef(""Default ipv6 relay: %s"", addr)"
net.Resolver{}
"ip, err := r.LookupHost(ctx, address)"
d := new(net.Dialer)
"if ipaddress != """" {"
INTERNAL_DNS = utils.Exists(fname)
import (
"log.Tracef(""Resolved %s to %s using %s"", address, r.s, dns)"
result <- r
"PreferGo: true,"
if err == nil {
"""github.com/schollz/croc/v10/src/utils"""
if !INTERNAL_DNS {
"log.Tracef(""Resolved %s to %s"", address, ipaddress)"
"""208.67.222.222"",         // Cisco OpenDNS"
"r.s, r.err = remoteLookupIP(address, dns)"
var (
"DEFAULT_RELAY = net.JoinHostPort(addr, DEFAULT_PORT)"
func init() {
"for _, flag := range os.Args {"
var r Result
"result := make(chan Result, len(publicDNS))"
for i := 0
"""149.112.112.112"",        // Quad9"
"""fmt"""
INTERNAL_DNS       = false
"addr, err = lookup(DEFAULT_RELAY)"
"""[2606:4700:4700::1111]"", // Cloudflare"
"DEFAULT_RELAY = """""
"DEFAULT_PASSPHRASE = ""pass123"""
package models
// Resolve a hostname to an IP address using DNS.
return localLookupIP(address)
"log ""github.com/schollz/logger"""
doRemember = true
"log.Tracef(""Using local DNS to resolve %s"", address)"
time.Millisecond)
const TCP_BUFFER_SIZE = 1024 
err error
var err error
"DEFAULT_RELAY      = ""croc.schollz.com"""
"""1.1.1.1"",                // Cloudflare"
"""8.20.247.20"",            // Comodo"
"""net"""
if doRemember {
"""[2001:4860:4860::8844]"", // Google"
""":53"")"
"Dial: func(ctx context.Context, network, _ string) (net.Conn, error) {"
"log.Trace(""Using internal DNS: "", INTERNAL_DNS)"
// publicDNS are servers to be queried if a local lookup fails
"func getConfigFile(requireValidPath bool) (fname string, err error) {"
"log.Tracef(""Default ipv4 relay: %s"", addr)"
// DEFAULT_RELAY is the default relay used (can be set using --relay)
"""[2620:fe::fe:9]"",        // Quad9"
doRemember := false
"f, _ := os.Create(fname)"
"log.SetLevel(""info"")"
log.SetOutput(os.Stderr)
var publicDNS = []string{
// save in config file
// localLookupIP returns a host's IP address using the local DNS configuration.
"assert.Equal(t, []byte(""hello, c1""), data)"
"_, _, _, err = ConnectToTCPServer(""127.0.0.1:8381"", ""pass123"", ""testRoom"", 1"
"c2, _, _, err := ConnectToTCPServer(""127.0.0.1:8381"", ""pass123"", ""testRoom"")"
"log ""github.com/schollz/logger"""
testing.T) {
time.Minute)
"err = PingServer(""127.0.0.1:8333"")"
"err := PingServer(""127.0.0.1:8381"")"
testing.B) {
time.Sleep(100 
continue
"assert.Nil(t, err)"
 time.Millisecond)
import (
for {
"log.SetLevel(""trace"")"
c.Close()
"c1, banner, _, err := ConnectToTCPServer(""127.0.0.1:8381"", ""pass123"", ""testRoom"", 1"
"assert.NotNil(t, err)"
func TestTCP(t 
"""github.com/stretchr/testify/assert"""
"data, err = c2.Receive()"
break
"go Run(""debug"", ""127.0.0.1"", ""8283"", ""pass123"", ""8284"")"
"_, _, _, err = ConnectToTCPServer(""127.0.0.1:8381"", ""pass123"", ""testRoom"")"
var data []byte
"assert.Nil(t, c1.Send([]byte(""hello, c2"")))"
"if bytes.Equal(data, []byte{1}) {"
time.Sleep(300 
c1.Close()
b.ResetTimer()
func BenchmarkConnection(b 
"assert.Equal(t, []byte(""hello, c2""), data)"
time.Sleep(timeToRoomDeletion)
"""time"""
time.Nanosecond)
// try sending data
for i := 0
"""testing"""
"log.SetLevel(""error"")"
"c, _, _, _ := ConnectToTCPServer(""127.0.0.1:8283"", ""pass123"", fmt.Sprintf(""testroom%d"", i), 1"
"assert.Equal(t, banner, ""8382"")"
 i < b.N
"""fmt"""
"data, err = c1.Receive()"
package tcp
 time.Millisecond
"assert.Nil(t, c2.Send([]byte(""hello, c1"")))"
"go RunWithOptionsAsync(""127.0.0.1"", ""8381"", ""pass123"", WithBanner(""8382""), WithLogLevel(""debug""), WithRoomTTL(timeToRoomDeletion))"
"""bytes"""
timeToRoomDeletion := 100 
func WithLogLevel(level string) serverOptsFunc {
s.banner = banner[0]
"for _, ss := range s {"
s.roomCleanupInterval = interval
import (
return func(s 
"var availableLogLevels = []string{""info"", ""error"", ""warn"", ""debug"", ""trace""}"
func WithRoomTTL(ttl time.Duration) serverOptsFunc {
type serverOptsFunc func(s 
s.roomTTL = ttl
return true
return nil
// TODO: maybe export from logger library
s.debugLevel = level
func WithBanner(banner ...string) serverOptsFunc {
if len(banner) > 0 {
"return fmt.Errorf(""invalid log level specified: %s"", level)"
server) error {
if e == ss {
"""time"""
return false
"if !containsSlice(availableLogLevels, level) {"
"""fmt"""
package tcp
"func containsSlice(s []string, e string) bool {"
func WithRoomCleanupInterval(interval time.Duration) serverOptsFunc {
server) error
"log.Debug(""rooms ready"")"
log.Error(err)
"log.Debugf(""checking connection of room %s for %"
"v"", room, c)"
"}(s.port, connection)"
ip := net.ParseIP(s.host)
s := new(server)
// have exceeded their allocated TTL.
"B, err := pake.InitCurve(weakKey, 1, ""siec"")"
func chanFromConn(conn net.Conn) chan []byte {
err = s.run()
connection.Close()
if len(s.password) > 2 {
"roomBytes, err := crypt.Decrypt(enc, strongKeyForEncryption)"
"log.Debugf(""strongkey: %x"", strongKey)"
"func RunWithOptionsAsync(host, port, password string, opts ...serverOptsFunc) error {"
"}(otherConnection, c, "
err = c.Send(salt)
if b2 == nil {
"return RunWithOptionsAsync(host, port, password, WithBanner(banner...), WithLogLevel(debugLevel))"
c <- res
"bSend, err := crypt.Encrypt([]byte(banner"
room = pingRoom
if len(banner) == 0 {
"res := make([]byte, n)"
"log.Warnf(""can't set read deadline: %v"", err)"
"if !bytes.Equal(data, []byte(""ok"")) {"
server) run() (err error) {
"bSend, err = crypt.Encrypt([]byte(""room full""), strongKeyForEncryption)"
host       string
err = c.Send(A.Bytes())
// deleteOldRooms checks for rooms at a regular interval and removes those that
s.host = host
"s.rooms.rooms[room] = roomInfo{first: nil, second: nil}"
"v"", s.rooms.rooms[room])"
select {
package tcp
if err != nil {
"""bytes"""
"data, err := crypt.Decrypt(enc, strongKeyForEncryption)"
log.Debug(errSend)
s.stopRoomCleanup = make(chan struct{})
"""github.com/schollz/croc/v10/src/comm"""
if s.rooms.rooms[room].first != nil 
Read()s from the socket to the channel.
"first:  c,"
"network = ""tcp6"""
comm.Comm
"addr = strings.Replace(addr, ""127.0.0.1"", ""0.0.0.0"", 1)"
s.rooms.rooms[room] = roomInfo{
case b2 := <-chan2:
sync.WaitGroup) {
// ConnectToTCPServer will initiate a new connection
"c, err := comm.NewConnection(address, 300"
rooms      roomMap
"const pingRoom = ""pinglkasjdlfjsaldjf"""
 err != nil {
"maskedPassword = fmt.Sprintf(""%c"
if err = c.Send(enc)
if room == pingRoom {
if errCommunication != nil {
for {
 time.Second)
deleteIt := false
if b1 == nil {
"server, err := net.Listen(network, addr)"
"return """", fmt.Errorf(""send error: %w"", err)"
"// to the specified address, room with optional time limit"
"comm.Comm) (room string, err error) {"
// receive salt
"log.Debug(""exiting"")"
"c, err = comm.NewConnection(address)"
"Bbytes, err := c.Receive()"
ip = tcpIP.IP
// transfers data from one to the other.
} else {
log.SetLevel(s.debugLevel)
type roomMap struct {
"func pipe(conn1 net.Conn, conn2 net.Conn) {"
"log.Debugf(""deleting room: %s"", room)"
"connection, err := server.Accept()"
c <- nil
return s
if ip.To4() != nil {
for room := range s.rooms.rooms {
""") {"
"comm.Comm, wg "
"""time"""
s.stopRoomCleanup <- struct{}{}
"passwordBytesEnc, err := c.Receive()"
""")[1]"
// send salt
"v"", room)"
"opened: s.rooms.rooms[room].opened,"
server) deleteRoom(room string) {
"return fmt.Errorf(""problem accepting connection: %w"", err)"
"err = fmt.Errorf(""bad password"")"
room = string(roomBytes)
deleteIt = true
"log.Debugf(""room: %"
break
"go func(port string, connection net.Conn) {"
return err
chan1 := chanFromConn(conn1)
"c.Send([]byte(""pong""))"
"log.Debugf(""sending '%s'"", banner)"
"c.Connection().RemoteAddr().String()), strongKeyForEncryption)"
"log.Debug(""sending back pong"")"
// send ok to tell client they are connected
"second: c,"
"tcpIP, err = net.ResolveIPAddr(""ip"", s.host)"
defer s.rooms.Unlock()
if ip == nil {
"log.Debugf(""client %s connected"", connection.RemoteAddr().String())"
// establish secure password with PAKE for communication with relay
server) start() (err error) {
if err := conn.SetReadDeadline(time.Now().Add(3 
opened time.Time
if strings.TrimSpace(string(passwordBytes)) != s.password {
"strongKeyForEncryption, salt, err := crypt.New(strongKey, nil)"
"log.Debug(""sending password"")"
s.roomTTL = DEFAULT_ROOM_TTL
roomTTL             time.Duration
var wg sync.WaitGroup
server) stopRoomDeletion() {
return nil
s := newDefaultServer()
"v"", errCommunication)"
// start piping
"log.Errorf(""write error on channel 2: %v"", err)"
banner := s.banner
"for _, room := range roomsToDelete {"
net.IPAddr
debugLevel string
if len(timelimit) > 0 {
"if s.host != """" {"
"log.Debug(""room cleanup stopped"")"
if time.Since(s.rooms.rooms[room].opened) > s.roomTTL {
// get PAKE connection with server to establish strong key to transfer info
ticker.Stop()
"log.Debugf(""got ping"")"
"enc, _ := crypt.Encrypt([]byte(err.Error()), strongKeyForEncryption)"
"passwordBytes, err := crypt.Decrypt(passwordBytesEnc, strongKeyForEncryption)"
"""strings"""
" %s"", room)"
wg.Add(1)
"log.Debugf(""waiting for password"")"
"%c"", s.password[0], s.password[len(s.password)-1])"
"log.Debug(""waiting for room confirmation"")"
""")[0]"
s.rooms.rooms[room].first.Close()
"if _, err := conn1.Write(b2)"
err := opt(s)
"addr := net.JoinHostPort(s.host, s.port)"
"strongKeyForEncryption, _, err := crypt.New(strongKey, salt)"
return s.start()
server) deleteOldRooms() {
case <-ticker.C:
rooms map[string]roomInfo
return c
 s.rooms.rooms[room].second != nil {
return
full   bool
"enc, err := c.Receive()"
"log.Debugf(""Abytes: %s"", Abytes)"
second 
// RunWithOptionsAsync asynchronously starts a TCP listener.
// Mask our password in logs
"log.Debug(""stop room cleanup fired"")"
"log.Debug(""done piping"")"
"bSend, err = crypt.Encrypt([]byte(""ok""), strongKeyForEncryption)"
"bSend, err := crypt.Encrypt([]byte(password), strongKeyForEncryption)"
time.Sleep(1 
"log.Debug(""all set"")"
"network := ""tcp"""
s.rooms.rooms[room].second.Close()
s.port = port
err = B.Update(Abytes)
"// chanFromConn creates a channel from a Conn object, and sends everything it"
// tell the client that they got the room
s.rooms.Unlock()
 time.Hour))
"log.Debugf(""pinging %s"", address)"
 addr)
"log.Debugf(""room %s has 1"", room)"
"log.Debug(""waiting for first ok"")"
var tcpIP 
ticker := time.NewTicker(s.roomCleanupInterval)
"log.Debug(""room is gone"")"
"bSend, err = crypt.Encrypt([]byte(room), strongKeyForEncryption)"
"err = c.Send([]byte(""ping""))"
"A, err := pake.InitCurve(weakKey, 0, ""siec"")"
"server) clientCommunication(port string, c "
"opened: time.Now(),"
err = A.Update(Bbytes)
"err = fmt.Errorf(""bad response: %s"", string(data))"
"strongKey, err := A.SessionKey()"
"""sync"""
import (
if deleteIt {
func newDefaultServer() 
"banner = strings.Split(string(data), """
go func() {
if s.rooms.rooms[room].second != nil {
"""fmt"""
// tell the sender everything is ready
first  
"err = fmt.Errorf(""got bad response: %s"", data)"
"// Run starts a tcp listener, run async"
wg.Done()
"log.Infof(""starting TCP server on "" "
"salt, err := c.Receive()"
"b, err := c.Receive()"
type server struct {
"""net"""
var roomsToDelete []string
port       string
case <-s.stopRoomCleanup:
"data, err = crypt.Decrypt(enc, strongKeyForEncryption)"
"if !strings.Contains(string(data), """
if errSend != nil {
func (s 
"pipe(com1.Connection(), com2.Connection())"
s.password = password
server {
"func ConnectToTCPServer(address, password, room string, timelimit ...time.Duration) (c "
"roomsToDelete = append(roomsToDelete, room)"
"var weakKey = []byte{1, 2, 3}"
sync.Mutex
"addr = net.JoinHostPort(ip.String(), s.port)"
s.roomCleanupInterval = DEFAULT_ROOM_CLEANUP_INTERVAL
"func Run(debugLevel, host, port, password string, banner ...string) (err error) {"
case b1 := <-chan1:
go s.deleteOldRooms()
errSend := s.rooms.rooms[room].first.Send([]byte{1})
"log.Debugf(""room %s has 2"", room)"
"c := make(chan []byte, 1)"
"delete(s.rooms.rooms, room)"
"if _, ok := s.rooms.rooms[room]"
s.debugLevel = DEFAULT_LOG_LEVEL
"copy(res, b[:n])"
"log.Debugf(""strong key: %x"", strongKey)"
s.deleteRoom(room)
banner     string
type roomInfo struct {
// spawn a new goroutine whenever a client connects
"network = ""tcp4"""
// pipe creates a full-duplex pipe between the two sockets and
"maskedPassword := """""
"full:   true,"
"room, errCommunication := s.clientCommunication(port, c)"
defer s.stopRoomDeletion()
"ipaddr = strings.Split(string(data), """
"log.Debug(""waiting for answer"")"
"for _, opt := range opts {"
maskedPassword = s.password
chan2 := chanFromConn(conn2)
s.rooms.rooms = make(map[string]roomInfo)
// create the room if it is new
stopRoomCleanup chan struct{}
"return fmt.Errorf(""error listening on %s: %w"", addr, err)"
wg.Wait()
 !ok {
// wait for client to tell me which room they want
"""github.com/schollz/croc/v10/src/models"""
"comm.Comm, banner string, ipaddr string, err error) {"
"log.Debugf(""room cleaned up: %s"", room)"
"go func(com1, com2 "
"log.Debug(""starting pipes"")"
password   string
roomCleanupInterval time.Duration
"banner = ""ok"""
"first:  s.rooms.rooms[room].first,"
defer server.Close()
otherConnection := s.rooms.rooms[room].first
"if bytes.Equal(Abytes, []byte(""ping"")) {"
"log.Debugf(""sending room"
c := comm.New(connection)
func PingServer(address string) (err error) {
"return fmt.Errorf(""no pong"")"
if n > 0 {
"Abytes, err := c.Receive()"
log.Debug(err)
if s.rooms.rooms[room].full {
"enc, err = c.Receive()"
"log ""github.com/schollz/logger"""
s.rooms.Lock()
err = c.Send(bSend)
time.Millisecond)
"log.Debugf(""err: %"
"b := make([]byte, models.TCP_BUFFER_SIZE)"
// delete room
"return fmt.Errorf(""could not apply optional configurations: %w"", err)"
"if bytes.Equal(b, []byte(""pong"")) {"
err = c.Send(B.Bytes())
"""github.com/schollz/pake/v3"""
"c, err = comm.NewConnection(address, timelimit[0])"
"strongKey, err := B.SessionKey()"
// Copy the buffer so it doesn't get changed while read by the recipient.
"// newDefaultServer initializes a new server, with some default configuration options"
// check connection
"if _, err := conn2.Write(b1)"
"n, err := conn.Read(b)"
"log.Errorf(""write error on channel 1: %v"", err)"
"// second connection is the sender, time to staple connections"
"""github.com/schollz/croc/v10/src/crypt"""
if s.rooms.rooms[room].first != nil {
"log.Debugf(""relay-%s: %s"", connection.RemoteAddr().String(), errCommunication.Error())"
"log.Debugf(""starting with password '%s'"", maskedPassword)"
package tcp
"import ""time"""
const (
DEFAULT_ROOM_TTL              = 3 
DEFAULT_ROOM_CLEANUP_INTERVAL = 10 
 time.Minute
"DEFAULT_LOG_LEVEL             = ""debug"""
 time.Hour
"sender, _ := New(Options{"
"""path"""
"for _, file := range filesInfo {"
"Debug:         true,"
"sender, err := New(Options{"
"file, err := os.Create("".gitignore"")"
"// This ""test"" will make sure"
} else {
"log.SetLevel(""trace"")"
"s, err := filepath.EvalSymlinks(path.Join(pathName, ""README.link""))"
defer os.Remove(tmpfile.Name()) // clean up
"""github.com/schollz/croc/v10/src/tcp"""
"DisableLocal:  true,"
func TestCrocIgnoreGit(t 
"for _, file := range []string{""README.md"", ""./README.md""} {"
"RelayAddress:  ""doesntexistok.com:8381"","
"SharedSecret:  ""8123-testingthecroc2"","
"go tcp.Run(""debug"", ""127.0.0.1"", ""8283"", ""pass123"")"
"t.Errorf(""receive failed: %v"", err)"
"""time"""
" s != "".."
"RelayPorts:    []string{""8281""},"
func TestCleanUp(t 
wg.Add(2)
"filesInfo, emptyFolders, totalNumberFolders, errGet := GetFilesInfo([]string{""../../LICENSE"", ""touched""}, false, false, []string{})"
time.Sleep(1 
package croc
"IsSender:      true,"
"log.Errorf(""error creating file"")"
"if _, err = tmpfile.Write(content)"
"os.Symlink(""../../README.md"", filepath.Join(pathName, ""README.link""))"
err = os.Remove(file)
"log.Debug(""setting up receiver"")"
"Overwrite:     true,"
"NoPrompt:      true,"
"log.Errorf(""error writing to file"")"
func TestCrocLocal(t 
testing.T) {
"go tcp.Run(""debug"", ""127.0.0.1"", ""8282"", ""pass123"")"
"t.Errorf(""send failed: %v"", err)"
"t.Errorf(""test failed, should ignore LICENSE"")"
"log.Debug(""Full cleanup"")"
"defer os.Remove("".gitignore"")"
"tmpfile, err := os.CreateTemp("""", ""example"")"
"assert.NotNil(t, err)"
"if s != ""../../README.md"" "
"log.Debugf(""%s was already purged."", file)"
"log.Debugf(""%s was already purged."", folder)"
"// due to how files are ignored in this function, all we have to do to test is make sure LICENSE doesn't get included in FilesInfo."
"log.Debugf(""Successfully purged %s"", folder)"
"os.MkdirAll(pathName, 0o755)"
err = os.RemoveAll(folder)
"err := sender.Send(filesInfo, emptyFolders, totalNumberFolders)"
"if operatingSystem == ""windows"" {"
"if strings.Contains(file.Name, ""LICENSE"") {"
wg.Wait()
// windows allows files to be deleted only if they
"defer os.RemoveAll(""./testEmpty"")"
func TestCrocSymlink(t 
"""testing"""
"""os"""
"pathName := ""../../testEmpty"""
// are not open by another program so the remove actions
"RelayPassword: ""pass123"","
"SharedSecret:  ""8124-testingthecroc"","
if err != nil {
"defer os.Remove(""README.md"")"
"filesInfo, _, _, errGet := GetFilesInfo([]string{""../../LICENSE"", "".gitignore"", ""croc.go""}, false, true, []string{})"
defer os.RemoveAll(pathName)
"RelayPorts:    []string{""8181"", ""8182""},"
"go tcp.Run(""debug"", ""127.0.0.1"", ""8285"", ""pass123"")"
"err = sender.Send(filesInfo, emptyFolders, totalNumberFolders)"
time.Sleep(100 
"""sync"""
import (
var wg sync.WaitGroup
"log.Debugf(""The operating system is %s"", operatingSystem)"
if errGet != nil {
"filesInfo, emptyFolders, totalNumberFolders, errGet := GetFilesInfo([]string{tmpfile.Name()}, false, false, []string{})"
if err == nil {
"t.Errorf(""symlink transfer failed: %s"", err.Error())"
"content := []byte(""temporary file's content"")"
"filesInfo, emptyFolders, totalNumberFolders, errGet := GetFilesInfo([]string{""../../README.md""}, false, false, []string{})"
Debug(false)
"pathName := ""../link-in-folder"""
func init() {
"RelayAddress:  ""127.0.0.1:8281"","
"receiver, err := New(Options{"
"Stdout:        false,"
go func() {
"Curve:         ""siec"","
err := receiver.Receive()
"defer os.RemoveAll(""./link-in-folder"")"
 err != nil {
"log.SetLevel(""warn"")"
"go tcp.Run(""debug"", ""127.0.0.1"", ""8281"", ""pass123"", ""8282,8283,8284,8285"")"
"GitIgnore:     false,"
"DisableLocal:  false,"
"IsSender:      false,"
"Stdout:        true,"
operatingSystem := runtime.GOOS
log.Debug(err)
"defer os.Remove(""touched"")"
wg.Done()
"log ""github.com/schollz/logger"""
"RelayPorts:    []string{""8381"", ""8382""},"
"""runtime"""
"RelayAddress:  ""127.0.0.1:8181"","
"SharedSecret:  ""8123-testingthecroc"","
"log.Debugf(""Successfully purged %s"", file)"
 time.Millisecond)
 time.Second)
var err error
"t.Errorf(""symlink failed to transfer in folder"")"
"""github.com/stretchr/testify/assert"""
"t.Errorf(""failed to get minimal info: %v"", errGet)"
time.Sleep(300 
func TestCrocReadme(t 
"os.Create(""touched"")"
log.Debug(s)
"filesInfo, emptyFolders, totalNumberFolders, errGet := GetFilesInfo([]string{pathName}, false, false, []string{})"
"""strings"""
"README.md"" {"
"log.Debug(""setting up sender"")"
if err = tmpfile.Close()
"defer os.Remove(""LICENSE"")"
"for _, folder := range []string{""./testEmpty"", ""./link-in-folder""} {"
err = receiver.Receive()
"go tcp.Run(""debug"", ""127.0.0.1"", ""8284"", ""pass123"")"
panic(err)
func TestCrocError(t 
// from the above tests will not always do a good clean up
"_, err = file.WriteString(""LICENSE"")"
func TestCrocEmptyFolder(t 
"""path/filepath"""
var errHash error
"""encoding/json"""
if c.TotalNumberOfContents > 1 {
"v"", fileInfo.Name, fileHash, fileInfo.Hash, errHash)"
"_, err = c.CurrentFile.WriteAt(data[8:], positionInt64)"
if len(c.Options.ThrottleUpload) > 1 
"""strconv"""
os.ModeSymlink != 0 {
"log.Debug(""establishing connection"")"
c.Options.RelayPorts = []string{c.Options.RelayPorts[0]}
RelayAddress6    string
Debug            bool
files[path] = true
"time.Millisecond),"
 c.Options.IsSender {
roomNameBytes := sha256.Sum256([]byte(c.Options.SharedSecret[:4] 
"log.Debug(""asking to overwrite"")"
"""github.com/denisbrodbeck/machineid"""
if a > b {
"for _, ip := range ips {"
MachineID                 string
if conn == nil 
 errRecipientFile == nil 
// time.Sleep(100 
data = compress.Decompress(data)
"description = "" "" "
"fmt.Sprintf(""%s-%d"", c.Options.RoomName, j),"
if err := c.fread.Close()
rt = rate.Every(time.Second / time.Duration(uploadLimit))
if c.FilesToTransfer != nil {
// it can be preset by the local relay
"prompt = fmt.Sprintf("""
CurrentFileIsClosed    bool
"n"", path.Join(fileInfo.FolderRemote, fileInfo.Name))"
if errIps != nil {
log.Error(errCreate)
"c.Pake, err = pake.InitCurve([]byte(c.Options.SharedSecret[5:]), 1, string(m.Bytes2))"
"""encoding/hex"""
err = nil
"c.CurrentFile, errOpen = os.OpenFile("
c.ExternalIP = externalIP
Options                         Options
 zipfolder {
if err == nil 
"for _, localIP := range localIps {"
"v, localIPparsed: %"
c.conn[0] = nil
"""bytes"""
c.longestFilename = len(fi.Name)
"// log.Debug(len(c.CurrentFileChunks), c.TotalChunksTransferred, c.TotalSent, c.FilesToTransfer[c.FilesToTransferCurrentNum].Size)"
"""github.com/schollz/croc/v10/src/comm"""
"log.Debugf(""Throttling Upload to %"
"FolderRemote: ""./"","
"n"", newFolder)"
 models.TCP_BUFFER_SIZE / 2)
"HashAlgorithm:          c.Options.HashAlgorithm,"
"kB, pakeError = B.SessionKey()"
// recipient wants to try to connect to local ips
"description := fmt.Sprintf(""%-"
"width, _, err := term.GetSize(int(os.Stdout.Fd()))"
"address = net.JoinHostPort(host, port)"
dmux.Lock()
Pake                            
c.Step1ChannelSecured = true
// look for peers first
"if !strings.HasSuffix(absPathWithSeparator, string(os.PathSeparator)) {"
"Type:  message.TypeFileInfo,"
if errCreate != nil {
"ipRequest        = []byte(""ips"
if gitErr == nil {
if gitIgnore.MatchesPath(path) {
"MulticastAddress: c.Options.MulticastAddress,"
"server,"
"json:""h,omitempty"""
"c.limiter = rate.NewLimiter(rt, minBurstSize)"
if !c.Options.IsSender {
c.FilesToTransfer[i].FolderRemote = filepath.Clean(fi.FolderRemote)
"log.Debug(""ready"")"
"cmd = exec.Command(""wl-copy"")"
"serverTry := net.JoinHostPort(ip, port)"
"if math.Mod(curi, float64(len(c.Options.RelayPorts))) == float64(i) {"
c.Options.NoCompress = senderInfo.NoCompress
c.CurrentFileChunks = []int64{}
c.TotalChunksTransferred
"log.Trace(""waiting for bytes"")"
 file.IsDir() {
if isEmptyFolder {
"v"", c.limiter.Limit())"
"MachineID:                 machID,"
NoCompress             bool
rNo files transferred.
"models.TCP_BUFFER_SIZE/2,"
= uint64(n)
"IPVersion: peerdiscovery.IPv6,"
"var host, port string"
"EmptyFoldersToTransfer: c.EmptyFoldersToTransfer,"
// get list of local ips
func New(ops Options) (c 
"log.Debugf(""error from errchan: %v"", err)"
"json:""e,omitempty"""
case message.TypeCloseRecipient:
"data, err = crypt.Encrypt([]byte(ipRequest), kA)"
if !c.Step1ChannelSecured {
if len(description) > width {
choice := strings.ToLower(utils.GetInput(prompt))
"pathToFile,"
""") {"
var fileHash []byte
c.conn[0] = conn
SendingText      bool
// is weird
"log.Debugf(""connected as %s -> %s"", c.ExternalIP, c.ExternalIPConnected)"
"Type:    message.TypeError,"
CurrentFileChunkRanges    []int64
err = c.transfer()
"fmt.Fprintf(os.Stderr, ""Send to machine '%s'"
"err = fmt.Errorf(""found no addresses to connect"")"
"if err = json.Unmarshal(data, "
" strings.Contains(err.Error(), ""pake not successful"") {"
"log.Errorf(""handshake send error: %v"", err)"
"c.Options.RelayAddress = """""
"n"", c.EmptyFoldersToTransfer[i].FolderRemote)"
"log.Debug(""generating salt"")"
"progressbar.OptionSetDescription("" ""),"
// Support wildcard
"log.Debugf(""file %d info: %"
= fileInfo.Size
"} else if bytes.Equal(data, []byte{1}) {"
 !c.Options.IsSender {
chunkMap               map[uint64]struct{}
"return true, fmt.Errorf(""refused files"")"
"log.Debug(""sender sending pake"
 c.Options.RelayPassword 
 recipientFileInfo.Size() == fileInfo.Size {
"err = fmt.Errorf(""could not connect"")"
err = errCreate
"data, err = c.conn[0].Receive()"
"// only ""pake"" messages should be unencrypted"
// check to see if this is a chunk that the recipient wants
absPathWithSeparator 
 ignoredDir {
MachineID              string
// }
rYour machine ID is '%s'
"return true, fmt.Errorf(""invalid path detected: '%s'"", fi.FolderRemote)"
"Name:         info.Name(),"
var host string
"dataToSend, err = crypt.Encrypt("
time.Sleep(r.Delay())
if stat.IsDir() {
cmd.Stdin = bytes.NewReader([]byte(str))
"if fileInfo.Symlink != """" {"
"v"", conn)"
"log.Debugf(""sending recipient ready with %d chunks"", len(c.CurrentFileChunks))"
"stat, _ := c.CurrentFile.Stat()"
"bips, errIps := json.Marshal(ips)"
"gitIgnore, gitErr := ignore.CompileIgnoreFile(wd.Name())"
"for i, fileInfo := range c.FilesToTransfer {"
"cmd = exec.Command(""pbcopy"")"
FilesToTransferCurrentNum int
// Options specifies user specific options
var done bool
"Bytes:  c.Pake.Bytes(),"
rSending %s (%s)
"ModTime:      info.ModTime(),"
log.Debug(errConn)
var errRead error
"log.Debugf(""dataMessage kA: %x"", kA)"
"""strings"""
"showReceiveCommandQrCode(fmt.Sprintf(""%[1]s"", c.Options.SharedSecret))"
os.Remove(file.Name)
// if usage.Available() < uint64(totalSize) {
err = A.Update(dataMessage.Bytes)
"newFolder, _ := filepath.Split(fileInfo.FolderRemote)"
c.mutex.Lock()
"machid, _ := machineid.ID()"
"err = os.MkdirAll(fileInfo.FolderRemote, os.ModePerm)"
"Client) Send(filesInfo []FileInfo, emptyFoldersToTransfer []FileInfo, totalNumberFolders int) (err error) {"
" (y/N) (use --overwrite to omit) "", path.Join(fileInfo.FolderRemote, fileInfo.Name))"
"log.Tracef(""data: %"
" (y/N) "", c.EmptyFoldersToTransfer[i].FolderRemote)"
 c.Options.Ask 
c.finishedNum
 len(ipv6discoveries) > 0 {
"portToUse := string(bytes.TrimPrefix(discoveries[i].Payload, []byte(""croc"")))"
type FileInfo struct {
defer func() {
if len(fileInfo.Name) > c.longestFilename {
 fileInfo.Name
if c.FilesToTransfer == nil {
Location int64  
"n"", fname, utils.ByteCountDecimal(totalFilesSize))"
"""github.com/schollz/croc/v10/src/tcp"""
if usableChunk {
"fmt.Fprintf(os.Stderr, "
"return true, err"
"utils.ZipDirectory(dest, fpath)"
limiter                
"log.Debugf(""error getting symlink: %s"", err.Error())"
// ask the sender for their local ips and port
"Client) processMessage(payload []byte) (done bool, err error) {"
"err = fmt.Errorf(""peer error: %s"", m.Message)"
if errRecipientFile == nil 
c.bar.Add64(bytesDone)
"_, errExists := os.Stat(c.EmptyFoldersToTransfer[i].FolderRemote)"
if os.IsNotExist(errExists) {
"gitObj, gitObjErr := ignore.CompileIgnoreFile(filepath.Join(path, "".gitignore""))"
"""github.com/skip2/go-qrcode"""
SuccessfulTransfer        bool
 ignoreGit {
"if strings.Contains(c.Options.IP, ""."") {"
"Limit:     -1,"
"choice := strings.ToLower(utils.GetInput(""""))"
"if strings.HasPrefix(fname, ""'croc-stdin-"") {"
"log.Debug(""finished"")"
FolderSource string      
if subErr == nil {
c.CurrentFileChunkRanges = utils.MissingChunks(
"if choice != """" "
"log.Debugf(""banner: %s"", banner)"
c.mutex.Unlock()
time.Sleep(500 
conn []
"c.Options.RelayAddress = ""127.0.0.1"""
"""io"""
bar             
"json:""md,omitempty"""
n%s %s (%s) from '%s'
var fullPath string
"""math"""
"c.FilesToTransfer[i].Name, err = utils.RandomFileName()"
"Type: message.TypeCloseRecipient,"
"v"", i, c.FilesToTransfer[i])"
err = gitObjErr
"abs, absErr := filepath.Abs(path)"
if errGlob != nil {
"log.Tracef(""got ipRequest"")"
curi := float64(0)
"log.Debugf(""%s is not a local IP, skipping"", ip)"
fpath = filepath.Dir(fpath)
"log.Errorf(""ips send error: %v"", err)"
if file.TempFile {
" strings.Contains(err.Error(), ""bad password"") {"
"Bytes2: []byte(c.Options.Curve),"
"json:""b,omitempty"""
"firstPort, _ := strconv.Atoi(c.Options.RelayPorts[0])"
if c.numfinished == len(c.Options.RelayPorts) {
"case ""windows"":"
"_, err = f.Readdirnames(1)"
var discoveries []peerdiscovery.Discovered
if !finished {
// RemoteFileRequest requests specific bytes
"v, ipv4Net: %"
c.bar = progressbar.NewOptions64(
// for every file that will be transferred
c.Options.RelayAddress = serverTry
"Client, err error) {"
"err = json.Unmarshal(data, "
err = err1
"log.Debugf(""%s is symlink"", fileInfo.Name)"
 c.Key == nil {
// initialize curve based on the recipient's choice
 !c.Step2FileInfoTransferred 
os.File
"case ""m"", ""M"":"
" strings.Contains(err.Error(), ""unexpected end of JSON input"") {"
EmptyFoldersToTransfer []FileInfo
"s"", c.longestFilename, c.FilesToTransfer[i].Name)"
if c.Options.RelayPassword != models.DEFAULT_PASSPHRASE {
"progressbar.OptionShowBytes(true),"
"data, _ := conn.Receive()"
"func isEmptyFolder(folderPath string) (bool, error) {"
 file.Name)
"Type:    message.TypeExternalIP,"
compress.Compress(
if absErr != nil {
"err = os.Symlink(fileInfo.Symlink, pathToFile)"
RoomName         string
go c.broadcastOnLocalNetwork(true)
"TimeLimit: timeLimit,"
"FilesToTransfer:        c.FilesToTransfer,"
timeLimit = 30 
package croc
wgDiscovery.Add(2)
folderForFileBase := filepath.Base(folderForFile)
"host, _, err = net.SplitHostPort(c.Options.RelayAddress)"
" "" "")"
"file, fileErr := os.Stat(path)"
"json:""c,omitempty"""
log.Debug(byteToDo)
"data, errConn := conn.Receive()"
if errStopTransfer != nil {
"log.Debug(""close-sender received..."")"
CurrentFile            
"log.Errorf(""can't generate random numbers: %v"", rerr)"
// connect to the relay for messaging
"posByte := make([]byte, 8)"
 !c.Step2FileInfoTransferred {
"v"", ipv4Addr, ipv4Net, errNet)"
pos := uint64(0)
log.Debug(bytesDone)
if !info.IsDir() {
err = c.sendCollectFiles(filesInfo)
"v"", conn, data)"
absPathWithSeparator := filepath.Dir(absPath)
"done, err = c.processMessageFileInfo(m)"
"n"", c.ExternalIPConnected)"
"c.FilesToTransfer[i].Symlink, err = os.Readlink(fullPath)"
"Client) processExternalIP(m message.Message) (done bool, err error) {"
"qrCode, err := qrcode.New(command, qrcode.Medium)"
if c.Options.OnlyLocal 
c.EmptyFoldersToTransfer = emptyFoldersToTransfer
// Create a hash of part of the shared secret to use as the room name
 c.Options.SendingText {
"case ""darwin"":"
if err = c.conn[0].Send(handshakeRequest)
PathToFiles      []string
"c.fread, err = os.Open(pathToFile)"
"rsecuring channel..."")"
"log.Debug(""assume ipv6"")"
"c.Options.HashAlgorithm = ""xxhash"""
"v"", discoveries)"
"ips, err = utils.GetLocalIPs()"
if errRead == io.EOF {
"if _, ok := c.FilesHasFinished[i]"
utils.MarkFileForRemoval(dest)
"string(os.PathSeparator)), string(os.PathSeparator), ""/"") "
"// Name: info.Name(),"
case message.TypeFileInfo:
"log.Debugf(""ip: %"
"if bytes.Equal(data, handshakeRequest) {"
err = c.createEmptyFolder(i)
ips)
var position uint64
fmt.Print(string(b))
"// if a non-""pake"" message is received unencrypted something"
"log.Debugf(""using hash algorithm: %s"", c.Options.HashAlgorithm)"
log.Debug(err)
if c.SuccessfulTransfer {
"593 - sanitize the sender paths and prevent "".."" from being used"
if kB != nil {
// Receive will receive a file
"if choice != ""y"" "
"discoveries, err := peerdiscovery.Discover(settings)"
finished := true
"progressbar.OptionSetWidth(20),"
"log.Debugf(""%s %"
 description
"cmd = exec.Command(""xclip"", ""-selection"", ""clipboard"")"
if done {
percentDone := 100 - float64(len(missingChunks)
"json:""s,omitempty"""
if len(ips) > 1 {
if !c.Options.IsSender 
c.Options.HashAlgorithm = senderInfo.HashAlgorithm
 i < len(c.EmptyFoldersToTransfer)
c.setBar()
 errExists == nil {
"kA, err = A.SessionKey()"
" newFolder != ""./"" {"
"Type: message.TypeCloseSender,"
// This function retrieves the important file information
"log.Trace(""got pake1"")"
exec.Cmd
"log.Debugf(""discoveries: %"
"n"", file.Name)"
"log.Debugf(""got error receiving: %v"", err)"
// not really an error because it will try to connect over the actual relay
curi
if i < c.FilesToTransferCurrentNum {
"panic(""Could not parse given Upload Limit"")"
// send / receive information of all files
"log.Debugf(""current file chunks: %"
"log.Debugf(""Limiting Upload for %d"", r.Delay())"
"log.Debugf(""generated key = %"
return filepath.SkipDir
return description
Client) transferOverLocalRelay(errchan chan<- error) {
Symlink      string      
"log.Debugf(""could not ping: %"
r%s %s (%s)
c.Options.RoomName = hex.EncodeToString(roomNameBytes[:])
Client) sendCollectFiles(filesInfo []FileInfo) (err error) {
"func(pathName string, info os.FileInfo, err error) error {"
ignoredPaths := make(map[string]bool)
Stdout           bool
c.numfinished = 0
c.firstSend = true
"// if no files are to be transferred, then we can end the file transfer process"
" !strings.HasPrefix(fileInfo.Name, ""croc-stdin-"") "
" (Y/n) "", remoteFile.MachineID)"
"data, err := c.conn[i"
totalNumberFolders
c.CurrentFileChunks = utils.ChunkRangesToChunks(c.CurrentFileChunkRanges)
"c.CurrentFile, errOpen = os.Create(pathToFile)"
if fInfo.IsIgnored {
Delay:     20 
var decryptErr error
"// log.Debugf(""sending chunk %d"", pos)"
// remove symlink if it exists
copyToClipboard(c.Options.SharedSecret)
if err != nil {
"r := c.limiter.ReserveN(time.Now(), n)"
"v"", m)"
err = absErr
// generate key
"Size:         info.Size(),"
if pakeError == nil {
"""crypto/rand"""
progressbar.OptionThrottle(100
"""github.com/schollz/croc/v10/src/utils"""
paths = []string{strings.ToLower(path)}
"log.Debugf(""purging error: %s"", err)"
" ""/"","
positionInt64 := int64(position)
// Default port to :9009
"c.Key, _, err = crypt.New(key, salt)"
"err = fmt.Errorf(""could not connect to %s: %w"", c.Options.RelayAddress, err)"
// reset to the local port
"case ""linux"":"
len(c.EmptyFoldersToTransfer) == 0 {
if fileInfo.Mode
rSending %s and %s (%s)
bytesDone := c.FilesToTransfer[c.FilesToTransferCurrentNum].Size - byteToDo
"utils.UnzipDirectory(""."", file.Name)"
"rSending %d files (%s)"", i, utils.ByteCountDecimal(totalFilesSize))"
"""github.com/schollz/croc/v10/src/compress"""
"folderName := fmt.Sprintf(""%d folders"", c.TotalNumberFolders)"
"log.Tracef(""%d receiving data"", i)"
Client) updateIfRecipientHasFileInfo() (err error) {
"log.Debugf(""starting sending over comm %d"", i)"
"Limit:            1,"
"log.Debug(""beginning sending comms"")"
"debugString = ""debug"""
"log.Debugf(""pathToFile: %s"", pathToFile)"
// TODO: do the last finishing stuff
go c.transferOverLocalRelay(errchan)
finished = false
c.Step3RecipientRequestFile = false
"log.Debug(""sending ips"
n%s already has some content in it. 
"action := ""Accept"""
"_, subErr := os.Stat(filepath.Join(path, "".gitignore""))"
"log.Debugf(""could not connect to "" "
if ignoreGit {
    croc %[2]s%[1]s
if fileErr == nil 
"log.Debugf(""discovery %d has payload: %"
"v"", c.longestFilename)"
"} else if dataMessage.Kind == ""pake1"" {"
Client) createEmptyFolder(i int) (err error) {
"uploadLimit, err = strconv.ParseInt(c.Options.ThrottleUpload, 10, 64)"
c.Step4FileTransferred = false
"width = max(20, width-60)"
// get position
nSending (->%s)
case message.TypeExternalIP:
c.numberOfTransferredFiles
if err := cmd.Run()
"Name:         stat.Name(),"
"done, err = c.processMessage(data)"
" fileInfo.Symlink != """" {"
if fileInfo.Size == 0 
ThrottleUpload   string
"Client) processMessageFileInfo(m message.Message) (done bool, err error) {"
"if c.Options.RelayAddress == ""127.0.0.1"" {"
err = errAbs
if errHash != nil {
CurrentFileChunks      []int64
c.setupLocalRelay()
"data, err = crypt.Decrypt(data, kA)"
if len(openPorts) < len(c.Options.RelayPorts) {
"log.Debugf(""port: [%s]"", c.Options.RelayPorts[i])"
Debug(c.Options.Debug)
if ipv4Net.Contains(localIPparsed) {
if finished {
durations := []time.Duration{200 
return err
"paths = append(paths, fname)"
return b
c.TotalNumberFolders = totalNumberFolders
"""os"""
"log.Debugf(""Removing %s"
= 1 {
"log.Debug(""closing file"")"
"FolderSource: filepath.Dir(absPath),"
// setup the progressbar
"log.Debug(""sending close-recipient"")"
"if bytes.Equal(data, ipRequest) {"
Key                             []byte
var wg sync.WaitGroup
"if strings.Contains(fname, """
// check ip version
"flags.WriteString(""--relay "" "
c.Options.Stdout = true
"if !bytes.Equal(fileHash, fileInfo.Hash) {"
if !c.Options.DisableLocal {
defer wg.Done()
" (y/N)   (use --overwrite to omit) "", path.Join(fileInfo.FolderRemote, fileInfo.Name), percentDone)"
err = c.updateState()
"return false, nil"
var ignoredDir bool
"func isChild(parentPath, childPath string) bool {"
"log.Debugf(""receiver connection established: %"
"log.Debugf(""got error processing: %v"", err)"
// // check the totalSize does not exceed disk space
n = models.TCP_BUFFER_SIZE / 2
if truncate {
 !c.Options.SendingText {
"// returns a hashmap Key: Absolute filepath, Value: boolean (true=ignore)"
// add two things to the error channel
c.recipientGetFileReady(finished)
"if _, errExists := os.Lstat(pathToFile)"
 1024
"bips, errIps = crypt.Encrypt(bips, kB)"
v] got weird bytes: %
"log.Warnf(""error removing %s: %v"", pathToFile, err)"
= string(os.PathSeparator)
dataMessage := SimpleMessage{
"Payload:   []byte(""ok""),"
"// description = """""
func formatDescription(description string) string {
"log.Debug(""disabling compression"")"
err = c.conn[i
"log.Debug(""creating symlink"")"
"if strings.HasSuffix(absPathWithSeparator, string(os.PathSeparator)"
"// // c.spinner.Suffix = "" waiting for recipient..."""
"return true, fmt.Errorf(""not enough disk space"")"
" choice == ""yes"" {"
Client) updateState() (err error) {
 time.Second}
" choice != ""y"" "
"c.Pake, err = pake.InitCurve([]byte(c.Options.SharedSecret[5:]), 0, c.Options.Curve)"
Delay:            20 
pake.Pake
if c.FilesToTransfer[i].Size == 0 {
"Mode:         stat.Mode(),"
"progressbar.OptionShowCount(),"
go c.sendData(i)
"Size:         stat.Size(),"
1].Receive()
"Type:  message.TypeRecipientReady,"
"v '%s'"", data, data)"
ignoredDir = false
"for _, path := range paths {"
fread                    
done = true
"fmt.Fprintf(os.Stderr, """
TotalChunksTransferred int
"v"", c.conn[0])"
" folderForFileBase != """" {"
"err = fmt.Errorf(""could not truncate %s: %w"", pathToFile, err)"
"progressbar.OptionSetDescription(formatDescription(description)),"
log.Debug(c.FilesToTransfer)
TotalFilesIgnored         int
mutex                    
 string(os.PathSeparator) 
"c.FilesToTransfer[c.FilesToTransferCurrentNum].Name,"
"1], _, _, err = tcp.ConnectToTCPServer("
readingPos 
err = errStopTransfer
// listen for incoming messages and process them
var cmd 
"err = fmt.Errorf(""could not connect to 127.0.0.1:%s: %w"", c.Options.RelayPorts[0], err)"
"log.Debugf(""finished with %d"", i)"
if c.SuccessfulTransfer 
 i < len(c.Options.RelayPorts)
KeepPathInRemote bool
"err = fmt.Errorf(""problem with decoding: %w"", err)"
"IsIgnored:    ignoredPaths[absPath],"
err = <-errchan
TotalNumberFolders        int
Bytes []byte
if wdErr == nil {
"debugString := ""warn"""
"c.bar = progressbar.NewOptions64(1,"
593 - disallow specific folders like .ssh
"progressbar.OptionSetRenderBlankState(true),"
rYour machine id is '%s'.
"func GetFilesInfo(fnames []string, zipfolder bool, ignoreGit bool, exclusions []string) (filesInfo []FileInfo, emptyFolders []FileInfo, totalNumberFolders int, err error) {"
"A, err = pake.InitCurve([]byte(c.Options.SharedSecret[5:]), 0, c.Options.Curve)"
var kA []byte
"action = ""Display"""
"err = fmt.Errorf(""code is too short"")"
"dataMessage.Kind = ""pake2"""
import (
var ips []string
if c.EmptyFoldersToTransfer != nil {
"log.Tracef(""error marshalling ips: %v"", errIps)"
usableChunk = false
"host, port, _ := net.SplitHostPort(address)"
if bytesDone > 0 {
= fi.Size
var readingPos int64
"var ipaddr, banner string"
"json:""fs,omitempty"""
ZipFolder        bool
"B, _ := pake.InitCurve([]byte(c.Options.SharedSecret[5:]), 1, c.Options.Curve)"
"if strings.HasPrefix(fi.Name, ""croc-stdin-"") "
if byteToDo > 0 {
"paths = append(paths, strings.ToLower(path))"
" time.Millisecond, 5 "
"TempFile:     true,"
"b, _ := os.ReadFile(pathToFile)"
"log.Tracef(""[%"
longestFilename int
continue
"address := net.JoinHostPort(discoveries[i].Address, portToUse)"
if errHash == nil 
"if folder == ""./"" {"
"log.Trace(""got handshake"")"
if !c.firstSend {
" choice != ""yes"" {"
var err error
"json:""l,omitempty"""
"""net"""
"errChmod := os.Chmod(pathToFile, c.FilesToTransfer[c.FilesToTransferCurrentNum].Mode.Perm())"
var data []byte
settings.MulticastAddress = c.Options.MulticastAddress
NoCompress       bool
"c.Options.RelayAddress6 = """""
"// if kB not null, then use it to decrypt"
quit                     chan bool
"// usage := diskusage.NewDiskUsage(""."")"
 c.TotalSent == c.FilesToTransfer[c.FilesToTransferCurrentNum].Size) {
"log.Debugf(""hashed %s to %x using %s"", fileInfo.Name, fileHash, c.Options.HashAlgorithm)"
HashAlgorithm          string
// purge errors that come from successful transfer
" strings.Contains(err.Error(), ""EOF"") "
"log.Debugf(""ipv4Add4: %"
var senderInfo SenderInfo
"log.Errorf(""bad relay address %s"", c.Options.RelayAddress)"
"""path/filepath"""
err = c.updateIfRecipientHasFileInfo()
timeLimit = -1 
"case ""g"", ""G"":"
sync.Mutex
fmt.Println(qrCode.ToSmallString(false))
"""github.com/schollz/progressbar/v3"""
err = c.Pake.Update(m.Bytes)
if newFolder != c.LastFolder 
// Chunk contains information about the
r%s %s and %s (%s)
// prepend the port that is being listened to
c.bar.Add(n)
c.Options.RelayPorts[i] = fmt.Sprint(port)
"v"", localIP, localIPparsed)"
 c.Step1ChannelSecured 
"log.Errorf(""can't create %s: %v"", folderForFile, err)"
c.FilesToTransferCurrentNum = i
"log.Tracef(""dataMessage: %s"", dataMessage)"
log.Debug(c.FilesToTransfer[c.FilesToTransferCurrentNum].Size)
fullPath = filepath.Clean(fullPath)
errchan <- c.transfer()
c.mutex = 
"conn, banner, ipaddr, err := tcp.ConnectToTCPServer(""127.0.0.1:"""
"log.Debugf(""received external IP: %"
if m.Type != message.TypePAKE 
 (!usingLocal 
// start initiating the process to receive a new file
"json:""m,omitempty"""
"for i, port := range openPorts {"
" time.Millisecond,"
// c.spinner.Stop()
if n == 0 {
"Bytes2: salt,"
"FolderRemote: strings.ReplaceAll(strings.TrimPrefix(pathName,"
nResume '%s' (%2.1f%%)
SendingText            bool
" (Y/n) "", machID, action, fname, utils.ByteCountDecimal(totalSize), senderInfo.MachineID)"
Client) Receive() (err error) {
"comm.Comm, 16)"
c.chunkMap[uint64(chunk)] = struct{}{}
"localIps, _ := utils.GetLocalIPs()"
"log.Debugf(""data: %s"", data)"
"log.Debugf(""got error from processing message: %v"", err)"
if gitObj.MatchesPath(info.Name()) {
"log.Debug(""exchanged header message"")"
c.bar.Finish()
"log.Debug(""sending close-sender"")"
"fmt.Fprintf(os.Stderr, ""connecting..."")"
var A 
"log.Trace(""got ping"")"
pos 
c.TotalSent = 0
// connect to the server
NoMultiplexing   bool
var n int
"errchan := make(chan error, 1)"
wg.Add(len(c.Options.RelayPorts))
Curve            string
Mode         os.FileMode 
var dmux sync.Mutex
"func max(a int, b int) int {"
 c.Step3RecipientRequestFile 
senderInfo)
"for i, fi := range c.FilesToTransfer {"
"c.FilesToTransfer[i].Hash, err = utils.HashFile(fullPath, c.Options.HashAlgorithm, fileInfo.Size > 1e7)"
"if _, ok := c.chunkMap[pos]"
"log ""github.com/schollz/logger"""
"log.Tracef(""sending ips: %"
"fname = fmt.Sprintf(""'%s'"", c.FilesToTransfer[0].Name)"
"json:""n,omitempty"""
"log.Debugf(""localIP: %"
"paths = append(paths, matches...)"
"ips = append([]string{c.Options.RelayPorts[0]}, ips...)"
"return fmt.Errorf(""dataMessage %s pake failed"", ipRequest)"
err = errGlob
totalFilesSize 
panic(errRead)
"uploadLimit, err = strconv.ParseInt(upload, 10, 64)"
func Debug(debug bool) {
" c.Options.IP != """" {"
} else if !c.Options.IsSender {
Client) fmtPrintUpdate() {
defer wgDiscovery.Done()
c.SuccessfulTransfer = true
"for _, file := range c.FilesToTransfer {"
"absPathWithSeparator = strings.TrimSuffix(absPathWithSeparator, string(os.PathSeparator))"
"errchan <- fmt.Errorf(""gracefully refusing using the public relay"")"
log.Error(err)
"if strings.Contains(err.Error(), ""could not secure channel"") {"
1].Send(dataToSend)
fullPath = fileInfo.FolderSource 
"// probably can't find, its okay"
if debug {
host = address
"err = fmt.Errorf(""password mismatch"")"
Hash         []byte      
 !c.Options.OnlyLocal {
err = c.recipientInitializeFile()
"""golang.org/x/term"""
"log.Debug(""received pake payload"")"
"v"", errPing)"
"ignore ""github.com/sabhiram/go-gitignore"""
if useipv6 {
usingLocal = true
"log.Debugf(""working on file %d"", c.FilesToTransferCurrentNum)"
"if strings.Contains(c.FilesToTransfer[i].FolderRemote, "".."
// throttle the reading
NoPrompt         bool
err = errStat
c.Options.SendingText = senderInfo.SendingText
"CurrentFileChunkRanges:    c.CurrentFileChunkRanges,"
port := ips[0]
c.Options.RelayAddress = c.Options.IP
var kB []byte
"if strings.Contains(c.FilesToTransfer[i].FolderRemote, ""../"") {"
"r                                 "")"
Client) setBar() {
if errHash != nil 
"Type: message.TypeFinished,"
if percentDone < 99 {
"conn, banner2, externalIP, errConn := tcp.ConnectToTCPServer(serverTry, c.Options.RelayPassword, c.Options.RoomName, 500"
"if err := os.MkdirAll(folderForFile, os.ModePerm)"
"fname = ""text message"""
// Debug toggles debug mode
 unit {
"json:""fr,omitempty"""
"if isChild(current, path) "
"log.Errorf(""dataMessage send error: %v"", err)"
type Chunk struct {
"fileInfo.Size,"
// only get local ips if the local is enabled
Client) receiveData(i int) {
"log.Debug(""got ping"")"
"panic(""not enough open ports to run local relay"")"
"key, err := c.Pake.SessionKey()"
"if c.Options.HashAlgorithm == """" {"
log.Error(errChmod)
Step5CloseChannels        bool
var timeLimit time.Duration
if info.IsDir() 
"Bytes: bRequest,"
 err != nil {
var remoteFile RemoteFileRequest
progressbar.ProgressBar
c.FilesToTransferCurrentNum = remoteFile.FilesToTransferCurrentNum
type Client struct {
type Options struct {
c.CurrentFileChunkRanges = []int64{}
"log.Debug(""skipping discovery"")"
Client) broadcastOnLocalNetwork(useipv6 bool) {
"log.Debugf(""trying connection to %s"", address)"
c.conn[0].Close()
"if !bytes.HasPrefix(discoveries[i].Payload, []byte(""croc"")) {"
if err == io.EOF {
position)
func (c 
Overwrite        bool
nReceiving (<-%s)
if errRead != nil {
nOverwrite '%s'
"""github.com/schollz/croc/v10/src/message"""
"log.Debugf(""TEST FLAG ENABLED, TESTING LOCAL IPS"")"
if c.Options.ShowQrCode {
go c.broadcastOnLocalNetwork(false)
"emptyFile, errCreate := os.Create(pathToFile)"
// helper function to walk each subfolder and parses against an ignore file.
"n, errRead = c.fread.ReadAt(data, readingPos)"
 !c.Step1ChannelSecured {
"if strings.Contains(c.FilesToTransfer[i].FolderRemote, "".ssh"") {"
"path.Join(fileInfo.FolderRemote, fileInfo.Name),"
"log.Debugf(""hashes are equal %x == %x"", fileHash, fileInfo.Hash)"
"ipv6discoveries, err1 := peerdiscovery.Discover(peerdiscovery.Settings{"
"log.Debugf(""banner: %s"", banner2)"
c.numfinished
"log.Debug(""start sending data!"")"
if decryptErr != nil {
"log.Debugf(""error copying to clipboard: %v"", err)"
"hashExtra := ""croc"""
"data, err = crypt.Decrypt(data, c.Key)"
// recipient sets the file
dataMessage.Bytes = B.Bytes()
// quit with c.quit <- true
var wgDiscovery sync.WaitGroup
"done, err = c.processExternalIP(m)"
// recipient will look for peers first
"c.FilesToTransfer[c.FilesToTransferCurrentNum].FolderSource,"
errPing := tcp.PingServer(address)
"log.Errorf(""error closing file: %v"", err)"
// initialize throttler
"if address == """" {"
"log.Debug(""sending external IP"")"
c.chunkMap = make(map[uint64]struct{})
IP               string
" (Y/n) "", action, fname, utils.ByteCountDecimal(totalSize))"
"err = json.Unmarshal(m.Bytes, "
c.TotalSent 
"TotalNumberFolders:     c.TotalNumberFolders,"
Step1ChannelSecured       bool
 c.Options.RelayAddress 
 i < len(discoveries)
c.FilesToTransfer = senderInfo.FilesToTransfer
break
"fmt.Fprintf(os.Stderr, ""Skipping '%s'"
"for _, fpath := range paths {"
"absPath, errAbs := filepath.Abs(fpath)"
"machID, _ := machineid.ID()"
"log.Debugf(""local connection established: %"
var rt rate.Limit
// return if no error
c.bar.Add(len(data[8:]))
"} else if bytes.Equal(data, handshakeRequest) {"
isIPset = true
string(os.PathSeparator)) {
"log.Debugf(""host: '%s', port: '%s'"", host, port)"
if err = c.conn[0].Send(data)
// Issue 
return nil
if c.Options.Stdout 
"c.Options.RelayPorts[0], c.Options.RelayPassword, c.Options.RoomName)"
"for i, address := range []string{c.Options.RelayAddress6, c.Options.RelayAddress} {"
fpath 
// Read file
HashAlgorithm    string
"log.Debugf(""connecting to %s"", server)"
// fnames: the relative/absolute paths of files/folders that will be transferred
"n"", c.finishedNum, c.TotalNumberOfContents)"
"json:""ig,omitempty"""
"log.Debugf(""%"
if len(fi.Name) > c.longestFilename {
"for _, port := range c.Options.RelayPorts {"
"errOpen = fmt.Errorf(""could not create %s: %w"", pathToFile, errOpen)"
 err == nil {
settings := peerdiscovery.Settings{
// c.spinner.Start()
default:
if errOpen != nil {
"host, port, _ = net.SplitHostPort(address)"
if errPing == nil {
"absPath, errAbs = filepath.Abs(dest)"
"nDo you want"""
"c.FilesToTransfer[c.FilesToTransferCurrentNum].Size,"
if err != nil 
go c.receiveData(j)
if pakeError = conn.Send(data)
Step4FileTransferred      bool
Ask                    bool
"log.Debugf(""all discoveries: %"
"Bytes:   m.Bytes,"
c.CurrentFileIsClosed = false
if c.numberOfTransferredFiles
"gitWalk(abs, gitObj, ignoredPaths)"
TimeLimit: 200 
strings.Builder{}
Client) updateIfSenderChannelSecured() (err error) {
"v"", ips)"
// setup the progressbar and takedown the progress bar for empty files
// update the pake
"log.Debugf(""pake error: %s"", err.Error())"
TimeLimit:        200 
"err = filepath.Walk(absPath,"
// TODO: determine the missing chunks
case message.TypeCloseSender:
totalFilesSize := int64(0)
".."") {"
"fmt.Fprint(os.Stderr, """
"return !strings.HasPrefix(relPath, "".."")"
"data := make([]byte, models.TCP_BUFFER_SIZE/2)"
RelayPorts       []string
c.TotalNumberFolders = senderInfo.TotalNumberFolders
"if strings.Contains(err.Error(), ""refusing files"") "
// close if not closed already
"log.Debugf(""error closing %s: %v"", c.CurrentFile.Name(), err)"
"recipientFileInfo, errRecipientFile := os.Lstat(path.Join(fileInfo.FolderRemote, fileInfo.Name))"
"ModTime:      stat.ModTime(),"
func copyToClipboard(str string) {
"Message: ""refusing files"","
"m, err := message.Decode(c.Key, payload)"
"prompt := fmt.Sprintf("""
c.longestFilename = len(fileInfo.Name)
RelayAddress     string
(For Windows)
= len(c.EmptyFoldersToTransfer)
portToUse = models.DEFAULT_PORT
err = c.processMessagePake(m)
truncate = true
models.TCP_BUFFER_SIZE/2)/float64(fileInfo.Size)
 len(discoveries) > 0 {
"log.Debugf(""Successful closing %s"", c.CurrentFile.Name())"
"""sync"""
"err = c.createEmptyFileAndFinish(fileInfo, i)"
err = func() (err error) {
if err == nil {
"c.Options.RelayPassword,"
port = models.DEFAULT_PORT
"log.Tracef(""error encrypting ips: %v"", errIps)"
func init() {
 (c.TotalChunksTransferred == len(c.CurrentFileChunks) 
"""fmt"""
"for _, chunk := range c.CurrentFileChunks {"
c.CurrentFileIsClosed = true
(For Linux/OSX)
remoteFile)
settings.IPVersion = peerdiscovery.IPv6
"fmt.Fprintf(os.Stderr, ""%s"
"// recipient requests the file and chunks (if empty, then should receive all chunks)"
"discoveries = append(discoveries, ipv4discoveries...)"
"bRequest, _ := json.Marshal(RemoteFileRequest{"
"""runtime"""
filepath.Dir(absPath)
"log.Tracef(""dataMessage kB: %x"", kB)"
"fmt.Fprintf(os.Stderr, "" %d/%d"
type TransferOptions struct {
"errStopTransfer := message.Send(c.conn[0], c.Key, message.Message{"
Size         int64       
 time.Second
c.ExternalIPConnected = c.Options.RelayAddress
"progressbar.OptionSetVisibility(!c.Options.SendingText),"
var conn 
"if _, rerr := rand.Read(salt)"
case message.TypeRecipientReady:
byteToDo := int64(len(c.CurrentFileChunks) 
Client) processMessagePake(m message.Message) (err error) {
"v"", i, discoveries[i])"
if c.TotalNumberFolders > 0 {
if errConn != nil {
Code is: %[1]s
"folder, _ := filepath.Split(c.FilesToTransfer[c.FilesToTransferCurrentNum].FolderRemote)"
"// if the files are the same size, then look for missing chunks"
return false
" dataMessage.Kind != ""pake2"" {"
c.conn[j
// copy dataDecrypt to data
"Message: c.ExternalIP,"
"return false, err"
 len(c.FilesToTransfer) > 0 
TempFile     bool        
"isEmptyFolder, _ := isEmptyFolder(pathName)"
"Type:   message.TypePAKE,"
"Bytes: b,"
"c.conn[0], banner, c.ExternalIP, err = tcp.ConnectToTCPServer(address, c.Options.RelayPassword, c.Options.RoomName, durations[i])"
 !c.Options.DisableLocal 
"n"", fname, utils.ByteCountDecimal(totalSize))"
"log.Debugf(""successfully pinged '%s'"", address)"
FolderRemote string      
"err = filepath.Walk(path, func(path string, info os.FileInfo, err error) error {"
OnlyLocal        bool
c.Options = ops
 !isIPset) {
"err = fmt.Errorf(""unencrypted communication rejected"")"
if !c.Options.OnlyLocal {
SharedSecret     string
 len(ipv4discoveries) > 0 {
// New establishes a new connection for transferring files between two instances.
MulticastAddress string
ignoredDir = false // Skip applying ignore rules for root directory
"v"", c.CurrentFileChunks)"
description = c.FilesToTransfer[c.FilesToTransferCurrentNum].Name
salt = m.Bytes2
"= ""/"""
"json.Unmarshal(data, "
"Payload:          []byte(""ok""),"
 !c.Step4FileTransferred {
" ""..."""
truncate = stat.Size() != c.FilesToTransfer[c.FilesToTransferCurrentNum].Size
 c.Step3RecipientRequestFile {
"// if we don't use an external relay, the broadcast messages need to be sent continuously"
"if portToUse == """" {"
// send / receive information of current file
"FolderSource: filepath.Dir(pathName),"
var truncate bool // default false
if err1 == nil 
log.Debug(errHash)
"fname = ""'text'"""
"""github.com/schollz/peerdiscovery"""
wg.Wait()
"ExternalIP, ExternalIPConnected string"
// find the next file to transfer and send that number
"err = fmt.Errorf(""pake not successful: %w"", err)"
"cmd = exec.Command(""clip"")"
// tcp connections
if errFileName != nil {
"n"", machid)"
IsSender         bool
"json:""sy,omitempty"""
"log.Debugf(""local connection established to %s"", serverTry)"
switch unit := string(c.Options.ThrottleUpload[len(c.Options.ThrottleUpload)-1:])
return a
"data, _ = json.Marshal(dataMessage)"
var current string
"if choice == ""y"" "
 !isIPset {
"binary.LittleEndian.PutUint64(posByte, pos)"
"errFileName := utils.ValidFileName(path.Join(c.FilesToTransfer[i].FolderRemote, fi.Name))"
"conn, banner, ipaddr, err = tcp.ConnectToTCPServer(address, c.Options.RelayPassword, c.Options.RoomName, durations[i])"
for i := 0
"ipv4Addr, ipv4Net, errNet := net.ParseCIDR(fmt.Sprintf(""%s/24"", ip))"
if !isEmpty {
if n > 0 {
c.conn = make([]
"err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {"
time.Millisecond)
"v"", fileInfo)"
"MachineID:              machID,"
Name         string      
"log.Tracef(""kB: %x"", kB)"
case message.TypeError:
emptyFile.Close()
"if bytes.Equal(data, []byte{1}) {"
"""github.com/schollz/pake/v3"""
if ignoredPaths[pathName] {
// SenderInfo lists the files to be transferred
"Mode:         info.Mode(),"
"if port == """" {"
numfinished              int
c = new(Client)
// setup basic info
if !c.Options.DisableLocal 
case message.TypePAKE:
"""github.com/schollz/croc/v10/src/crypt"""
usableChunk := true
IsCompressed bool        
"log.Debugf(""got error from updating state: %v"", err)"
"c.Key,"
"""path"""
"salt"")"
// Issues 
Exclude          []string
"fname := fmt.Sprintf(""%d files"", len(c.FilesToTransfer))"
c.FilesToTransfer = filesInfo
os.Remove(pathToFile)
if stat.IsDir() 
595 - disallow filenames with invisible characters
 !c.Options.SendingText 
"NoCompress:             c.Options.NoCompress,"
"""os/exec"""
"for _, fname := range fnames {"
"log.Debugf(""longestFilename: %"
"if c.ExternalIPConnected == """" {"
current = path
files[path] = false
c.Options.RelayAddress = address
haveLocalIP := false
"return true, nil"
if errOpen == nil {
" "".zip"""
"salt = make([]byte, 8)"
case message.TypeFinished:
"err = fmt.Errorf(""room (secure channel) not ready, maybe peer disconnected"")"
"os.O_WRONLY, 0o666)"
"log.Debugf(""touching file with folder / name"")"
"Kind:  ""pake1"","
Bytes    []byte 
"v] had error: %s"", conn, errConn.Error())"
 1024 
"TempFile:     false,"
= int64(n)
RelayPassword    string
"append(posByte, data[:n]...),"
c.FilesHasFinished[c.FilesToTransferCurrentNum] = struct{}{}
 ok {
"delete(c.chunkMap, pos)"
= len(c.FilesToTransfer)
"err = message.Send(c.conn[0], c.Key, message.Message{"
rReceiving %s (%s) 
IsEncrypted  bool        
minBurstSize := models.TCP_BUFFER_SIZE
"log.Debugf(""got host '%v' and port '%v'"", host, port)"
comm.Comm
"// if recipient, initialize with sending pake information"
"return true, errFileName"
// FileInfo registers the information about the file
"log.Debugf(""hashes are not equal %x != %x"", fileHash, fileInfo.Hash)"
if !truncate {
if errAbs != nil {
"if strings.Contains(c.FilesToTransfer[i].FolderRemote, """
if gitObjErr != nil {
"log.Tracef(""decrypted: %s"", data)"
var (
if !utils.Exists(fileInfo.FolderRemote) {
"""encoding/binary"""
FilesHasFinished          map[int]struct{}
if c.Options.Ask 
"func gitWalk(dir string, gitObj "
fInfo := FileInfo{
dest := filepath.Base(fpath) 
"log.Debug(""attempt to discover peers"")"
    CROC_SECRET=%[1]q croc %[2]s
if !c.CurrentFileIsClosed 
"discoveries = append(discoveries, ipv6discoveries...)"
"log.Debugf(""ips unmarshal error: %v"", err)"
for {
"folderForFile, _ := filepath.Split(pathToFile)"
numberOfTransferredFiles int
"if fpath[len(fpath)-1:] != ""/"" {"
}(port)
var dataToSend []byte
missingChunks := utils.ChunkRangesToChunks(utils.MissingChunks(
dmux.Unlock()
firstSend       bool
"if strings.Contains(c.FilesToTransfer[i].FolderRemote, ""/.."") {"
"log.Debugf(""could not establish '%s'"", address)"
"""golang.org/x/time/rate"""
} else {
// broadcast on ipv6
GitIgnore        bool
CurrentFileChunkRanges []int64
"log.Debug(""finished receiving!"")"
LastFolder             string
"json:""tf,omitempty"""
if len(c.chunkMap) != 0 {
Ask              bool
data = dataDecrypt
"flags.WriteString(""--pass "" "
if c.Options.SendingText {
"""time"""
ShowQrCode       bool
Client) setupLocalRelay() {
"log.Tracef(""error getting local ips: %v"", err)"
"FolderRemote: strings.ReplaceAll(remoteFolder, string(os.PathSeparator), ""/"") "
c.TotalNumberOfContents 
" (Y/n) "", action, fname, folderName, utils.ByteCountDecimal(totalSize))"
ips = ips[1:]
"// the file exists, but is same size, so hash it"
"log.Debugf(""checking %"
IgnoreStdin      bool
"SendingText:            c.Options.SendingText,"
"remoteFolder := strings.TrimPrefix(filepath.Dir(pathName), absPathWithSeparator)"
"ipv4discoveries, err1 := peerdiscovery.Discover(peerdiscovery.Settings{"
"filesInfo = append(filesInfo, fInfo)"
totalSize := int64(0)
if !haveLocalIP {
ignoredPaths[abs] = true
"log.Debug(""converting to chunk range"")"
"handshakeRequest = []byte(""handshake"")"
c.quit = make(chan bool)
return errOpen
finishedNum              int
if c.Options.NoMultiplexing {
"log.Debugf(""connected to %s"", server)"
// TransferOptions for sending
if len(c.Options.SharedSecret) < 6 {
var dataDecrypt []byte
"""crypto/sha256"""
"c.Options.RelayPorts = strings.Split(banner, "","")"
TestFlag         bool
c.EmptyFoldersToTransfer = senderInfo.EmptyFoldersToTransfer
log.Error(errOpen)
c.TotalNumberOfContents = 0
switch runtime.GOOS {
if err = conn.Send(bips)
"v"", c.FilesToTransfer[i])"
description = c.FilesToTransfer[i].Name
rbuf := bytes.NewReader(data[:8])
"log.SetLevel(""warn"")"
uploadLimit = uploadLimit 
"Client) createEmptyFileAndFinish(fileInfo FileInfo, i int) (err error) {"
"case ""k"", ""K"":"
"fileHash, errHash = utils.HashFile(path.Join(fileInfo.FolderRemote, fileInfo.Name), c.Options.HashAlgorithm)"
if c.Options.IsSender 
if errStat != nil {
c.ExternalIPConnected = m.Message
// generate salt and send it back to recipient
= int64(len(data[8:]))
type SenderInfo struct {
"fmt.Println(""Removing "" "
// steps involved in forming relationship
c.FilesHasFinished = make(map[int]struct{})
"log.Debugf(""connection established: %"
// Client holds the state of the croc transfer
c.LastFolder = newFolder
if int(uploadLimit) > minBurstSize {
"FilesToTransferCurrentNum: c.FilesToTransferCurrentNum,"
err := c.CurrentFile.Truncate(c.FilesToTransfer[c.FilesToTransferCurrentNum].Size)
"s"", c.longestFilename, c.FilesToTransfer[c.FilesToTransferCurrentNum].Name)"
if c.Options.TestFlag {
type RemoteFileRequest struct {
errchan <- err
minBurstSize = int(uploadLimit)
return
pakeError = B.Update(dataMessage.Bytes)
 filepath.Base(path) == filepath.Base(dir) {
c.Step4FileTransferred = true
err = c.updateIfSenderChannelSecured()
DisableLocal     bool
TotalNumberOfContents     int
defer f.Close()
"log.Errorf(""error sending: %v"", err)"
banner = banner2
"log.Errorf(""filepath error"")"
localIPparsed := net.ParseIP(localIP)
c.Step3RecipientRequestFile = true
switch m.Type {
Client) recipientInitializeFile() (err error) {
" c.Options.RelayPorts[0]),"
"IsIgnored:    ignoredPaths[pathName],"
func showReceiveCommandQrCode(command string) {
 hashExtra))
 senderInfo.Ask {
isIPset := false
"x with salt %x"", c.Key, salt)"
FilesToTransfer           []FileInfo
"emptyFolders = append(emptyFolders, FileInfo{"
TotalSent              int64
"if strings.Count(c.Options.IP, "":"") >= 2 {"
"c.FilesToTransfer[c.FilesToTransferCurrentNum].FolderRemote,"
var salt []byte
progressbar.OptionOnCompletion(func() {
"fmt.Print("""
"err = os.MkdirAll(c.EmptyFoldersToTransfer[i].FolderRemote, os.ModePerm)"
On the other computer run:
rate.Limiter
upload := c.Options.ThrottleUpload[:len(c.Options.ThrottleUpload)-1]
go func() {
"n"", fname, folderName, utils.ByteCountDecimal(totalFilesSize))"
"log.Tracef(""error decrypting: %v: '%s'"", decryptErr, data)"
"progressbar.OptionSetWriter(os.Stderr),"
"log.Errorf(""dataMessage error sending: %v"", err)"
c.TotalNumberOfContents = len(filesInfo)
"err = binary.Read(rbuf, binary.LittleEndian, "
"b, err = json.Marshal(SenderInfo{"
"matches, errGlob := filepath.Glob(fname)"
durations := []time.Duration{100 
if !c.Options.NoPrompt 
"func recursiveFiles(path string) (paths []string, err error) {"
usingLocal := false
"fmt.Fprintf(os.Stderr, ""Code copied to clipboard"
// needed bytes
if len(c.FilesToTransfer) == 1 {
"pathToFile := path.Join(fileInfo.FolderRemote, fileInfo.Name)"
 c.SuccessfulTransfer {
""" to overwrite it with an empty folder"
var errOpen error
pathToFile := path.Join(
// secure ipRequest
"v, err: %"
"err = fmt.Errorf(""could not secure channel"")"
Kind  string
panic(err)
c.Step2FileInfoTransferred = true
"ignore.GitIgnore, files map[string]bool) {"
"relPath, err := filepath.Rel(parentPath, childPath)"
// initialize pake for recipient
", c.Options.SharedSecret, flags.String())"
wgDiscovery.Wait()
"log.Debugf(""ips data: %s"", data)"
if !c.CurrentFileIsClosed {
"log.Debugf(""using curve %s"", string(m.Bytes2))"
var banner string
var b []byte
// Send will send the specified file
"Ask:                    c.Options.Ask,"
sync.Mutex{}
"v is a local IP"", ip)"
totalSize 
 !c.Options.Overwrite 
if c.Options.RelayAddress != models.DEFAULT_RELAY 
"log.Debug(""assume ipv4"")"
type SimpleMessage struct {
"if folderForFileBase != ""."" "
"if c.Options.IP != """" {"
"fname = ""'stdin'"""
"isEmpty, _ := isEmptyFolder(c.EmptyFoldersToTransfer[i].FolderRemote)"
c.CurrentFileChunkRanges = remoteFile.CurrentFileChunkRanges
ignoredDir = true
if errChmod != nil {
// setup the relay locally
"errchan = make(chan error, 2)"
IsIgnored    bool        
"err := tcp.Run(debugString, ""127.0.0.1"", portStr, c.Options.RelayPassword, strings.Join(c.Options.RelayPorts[1:], "",""))"
if c.Options.OnlyLocal {
c.ExternalIP = ipaddr
var paths []string
if c.Options.Ask {
Client) transfer() (err error) {
"openPorts := utils.FindOpenPorts(""127.0.0.1"", firstPort, len(c.Options.RelayPorts))"
host = c.Options.RelayAddress
for i := range c.FilesToTransfer {
var pakeError error
if c.Options.IsSender {
// create channel for quitting
"log.Debugf(""error: %s"", err.Error())"
FilesToTransfer        []FileInfo
"log.Debug(""switching to local"")"
"dataDecrypt, decryptErr = crypt.Decrypt(data, kB)"
"server := net.JoinHostPort(host, c.Options.RelayPorts[j])"
c.Options.RelayAddress6 = c.Options.IP
if c.Options.NoCompress {
if fInfo.IsIgnored 
 !ok {
flags := 
Client) sendData(i int) {
"""github.com/schollz/croc/v10/src/models"""
go func(j int) {
"log.Debugf(""hashed %s to %x using %s"", fullPath, c.FilesToTransfer[i].Hash, c.Options.HashAlgorithm)"
if !c.Options.NoCompress {
EmptyFoldersToTransfer    []FileInfo
totalNumberFolders = 0
// connects to the other ports of the server for transfer
"wd, wdErr := os.Stat("".gitignore"")"
go func(portStr string) {
"log.Debug(""no multiplexing"")"
var uploadLimit int64
"stat, errStat = os.Lstat(dest)"
haveLocalIP = true
"if os.Getenv(""XDG_SESSION_TYPE"") == ""wayland"" {"
"log.Debugf(""instead of handshake got: %s"", data)"
"Limit:     1,"
if c.limiter != nil {
 serverTry)
TotalNumberFolders     int
if c.Options.TestFlag 
ModTime      time.Time   
// and try to connect to them
if c.Options.Debug {
" !bytes.Equal(fileHash, fileInfo.Hash) {"
if err = c.CurrentFile.Close()
"Payload:   []byte(""croc"" "
c.fmtPrintUpdate()
dataMessage)
c.CurrentFile.Close()
 time.Millisecond)
}(i)
"log.SetLevel(""debug"")"
var dataMessage SimpleMessage
description = description[:(width-3)] 
Step2FileInfoTransferred  bool
"stat, errStat := os.Lstat(fpath)"
// broadcast on ipv4
// and continue if it doesn't find any within 100 ms
if err = os.Remove(pathToFile)
"Bytes: A.Bytes(),"
Step3RecipientRequestFile bool
"// if there are empty files, show them as already have been transferred now"
Client) recipientGetFileReady(finished bool) (err error) {
"f, err := os.Open(folderPath)"
"  message=""${1}"""
                 0 = Created the directory
          NAME:  extract_file
"                 0, then attempt to use sudo (unless on android)."
"    print_message ""== Architecture detected as ${croc_arch}"" ""info"""
 (_) 
" elif [[ ""${autocomplete_install_rcode}"" == ""20"" ]]"
 '__/ _ 
"  elif [[ ""${install_file_rcode}"" == ""1"" ]]"
      if command -v sudo >/dev/null 2>
"PREFIX=""${PREFIX:-}"""
                 1 = Something done broke
"  zsh_autocomplete_file=""zsh_autocomplete"""
                 integrity.  Tries multiple tools before failing.
                 20 = Could not find mkdir command
"__,_"
"  checksum_check_rcode=""${"
  green='
"  croc_dl_ext=""tar.gz"""
"    if [[ ""${uname_out}"" == """" ]]"
      return 1
"  echo ""${help_message}"""
  local yellow
                 Not really 100% sure this is how to install croc in cygwin.
" Not all sha256sum versions seem to have --ignore-missing, so filter the checksum file"
          exit 0
                 1 = File not installed
 (__
"  zsh_autocomplete_prefix=""/etc/zsh"""
                 21 = Could not find sudo command
         USAGE: curl https://getcroc.schollz.com 
          
  if command -v sha256sum >/dev/null 2>
"    echo ""${shasum_c}"""
             
      
" ) croc_os=""Windows"""
"  croc_base_url=""https://github.com/schollz/croc/releases/download"""
create_prefix() {
          NAME:  install_file_cygwin
" if [[ ""${autocomplete_install_rcode}"" == ""0"" ]] "
 CALL MAIN
"  ext=""${3}"""
    fi
"if [[ -n ""${ANDROID_ROOT}"" "
      Prefix to install croc into.  Directory must already exist.
"    print_message ""== Failed to extract ${croc_file}"" ""error"""
"  elif [[ ""${download_checksum_file_rcode}"" == ""1"" ]]"
                 20 = Failed to find mktemp
  local url
"      echo ""${tempdir}"""
"  elif [[ ""${extract_file_rcode}"" == ""1"" ]]"
"      Prints this helpful message and exit."""
   DESCRIPTION:  Installs a file into a location using 'install'.  If EUID not
"  croc_arch=""$(determine_arch)"""
  if command -v mkdir >/dev/null 2>
"    shasum_c=""Expected: ${shasum_1}, Got: ${shasum_2}"""
"      install -C -b -B '_old' -m 755 ""${file}"" ""${prefix}"""
  local dir
  -h
  local zsh_autocomplete_file
  local ext
print_banner() {
                      Prefix to install croc into.  Defaults to /usr/local/bin
"    if [[ ""${tempdir_rcode}"" == ""0"" ]]"
"            autocomplete_install_rcode=""${"
"  elif [[ ""${download_checksum_file_rcode}"" == ""20"" ]]"
"  if [[ ""${rcode}"" -gt ""0"" ]]"
       RETURNS:  Return code of the tool used to make the directory
    PARAMETERS:  $1 = file to install
"  croc_arch_rcode=""${"
"        rcode=""${"
"    if [[ ""${shasum_1}"" == ""${shasum_2}"" ]]"
"    print_message ""== 'mktemp' not found in path. Is it installed"
"  elif [[ ""${croc_arch_rcode}"" == ""1"" ]]"
       RETURNS:  0 = OS Detected. Also prints detected os to stdout
"      print_message ""== Failed to find sudo in path"" ""error"""
"    print_message ""== Downloaded croc archive into ${tmpdir}"" ""info"""
extract_file() {
   DESCRIPTION:  Prints out a help message
"  elif [[ ""${extract_file_rcode}"" == ""20"" ]]"
"  elif [[ ""${install_file_rcode}"" == ""20"" ]]"
  elif command -v shasum >/dev/null 2>
"       ""i686"" ) croc_arch=""32bit"""
install_file_freebsd() {
  -p INSTALL_PREFIX
"  if [[ ""${download_checksum_file_rcode}"" == ""0"" ]]"
" elif [[ ""${autocomplete_install_rcode}"" == ""1"" ]]"
                 $2 = location to extract file into
"                 EUID not 0, then attempt to use sudo."
                Default prefix = /usr/local/bin
"  cd ""${dir}"" "
    else
===============================================================================
  local croc_checksum_file
"main ""${INSTALL_PREFIX}"""
  local help_message
${PREFIX}/bin' on Termux for Android)
nPROG=croc
"  elif [[ ""${checksum_check_rcode}"" == ""1"" ]]"
"                 tar -xf ""${file}"" -C ""${dir}"""
"    print_message ""== Failed to verify checksum of ${tmpdir}/${croc_file}"" ""error"""
    exit 1
"    print_message ""== Failed to change into working directory ${tmpdir}"" ""error"""
"    print_message ""== Failed to create temp dir at ${tmpdir}"" ""error"""
"   print_message ""== Installed autocompletions for $(basename ""${SHELL}"")"" ""ok"""
  local create_prefix_rcode
  nc='
""" ""error"""
"  dir=""${2}"""
          NAME:  install_file_linux
       RETURNS:  0 = Arch Detected. Also prints detected arch to stdout
"     ""armv8l"" ) croc_arch=""ARM"""
checksum_check() {
"                as root), install, mktemp, sha256sum/shasum/sha256"
      REVISION: 0.9.2
   DESCRIPTION: croc Installer Script.
"  tmpdir_rcode=""${"
       RETURNS:  Formatted Message to stdout
  local filename
  exit 0
       RETURNS:  0 = Created temp dir. Also prints temp file path to stdout
determine_arch() {
"    print_message ""== Failed to find 'unzip' in path"" ""error"""
"                 rcode=""${"
"   print_message ""== Install attempt returned an unexpected value of ${autocomplete_install_rcode}"" ""error"""
  if command -v mktemp >/dev/null 2>
      Default = /usr/local/bin ('
"      rcode=""1"""
____
"  croc_file=""${croc_bin_name}_v${croc_version}_${croc_os}-${croc_arch}.${croc_dl_ext}"""
"                 $2 = Severity. info, ok, error, warn"
          NAME:  create_prefix
"    print_message ""== Install attempt returned an unexpected value of ${install_file_rcode}"" ""error"""
"      install -m 755 ""${prefix}"" ""${file}"""
                 $2 = location to install file into
          NAME:  determine_os
 FUNCTIONS
"  return ""${rcode}"""
"  download_checksum_file_rcode=""${"
"  print_message ""== Install prefix set to ${prefix}"" ""info"""
    PARAMETERS:  $1 = Message to print
"   ""error"" ) echo -e ""${red}${message}${nc}"""
"                print_message ""== Cygwin is currently unsupported."" ""error"""
31m'
  local severity
       
  local template
"    print_message ""== Failed to download croc archive"" ""error"""
"    curl -fsSL ""${url}"" -o ""${dir}/${filename}"""
                 ...at least that is the hope...
"     ""Darwin"" ) croc_os=""macOS"""
"  if [[ ""${install_file_rcode}"" == ""0"" ]] "
"  INSTALL_PREFIX=""/usr/local/bin"""
  local croc_version
"    print_message ""== 'uname' not found in path. Is it installed"
"       RETURNS:  If curl or wget found, returns the return code of curl or wget"
"    print_message ""== Failed to locate curl or wget"" ""error"""
 Termux on Android has ${PREFIX} set which already ends with '/usr'
"        rcode=""21"""
"    rcode=""${"
"  file=""${1}"""
"  prefix=""${1}"""
"  elif [[ ""${tmpdir_rcode}"" == ""1"" ]]"
  local red
  local rcode
"                 unzip ""${file}"" -d ""${dir}"""
"  case ""${ext}"" in"
       RETURNS:  0 = All good
       RETURNS:  0 = checkusm verified
  cd - >/dev/null 2>
"    print_message ""== Failed to locate 'sudo' command"" ""error"""
"  echo ""${croc_url}"" ""${tmpdir}"" ""${croc_file}"""
"  croc_version=""10.2.1"""
 esac
" -n ""${PREFIX}"" ]]"
       CREATED: 08/10/2019 16:41
                 20 = 'uname' not found in path
"    grep ""$(basename ""${file}"")"" ""${checksum_file}"" > filtered_checksum.txt"
          NAME:  install_file_freebsd
          NAME:  download_file
  local tmpdir
done
             / ___
"            print_message ""== You will need to add the following to your "
"    'p' ) INSTALL_PREFIX=""${OPTARG}"""
"  filename=""${3}"""
    PARAMETERS:  $1 = Directory template
  local checksum_check_rcode
                 1 = Unknown arch
                exit 1
"    ""zsh"" ) install_file_linux ""${tmpdir}/${zsh_autocomplete_file}"" ""${zsh_autocomplete_prefix}/zsh_autocomplete_croc"""
  local bash_autocomplete_file
---  FUNCTION  ----------------------------------------------------------------
"      rcode=""0"""
"      install -C -b -S '_old' -m 755 -t ""${prefix}"" ""${file}"""
       RETURNS:  0
"   ""bash"" ) install_file_linux ""${tmpdir}/${bash_autocomplete_file}"" ""${bash_autocomplete_prefix}/croc"""
"    ""aarch64"" ) croc_arch=""ARM64"""
"    tempdir_rcode=""${"
"    shasum_c=""$(sha256sum -c ""filtered_checksum.txt"")"""
"  elif [[ ""${download_file_rcode}"" == ""20"" ]]"
     /
   DESCRIPTION:  Makes a temp dir using mktemp if available
"      elif [[ ""${ANDROID_ROOT}"" != """" ]]"
33m'
                 >0 = Failed to create directory  
"                croc_dl_ext=""zip"""
"    wget --quiet  ""${url}"" -O ""${dir}/${filename}"""
               fi
    PARAMETERS:  none
!/bin/bash - 
"      ""ok"" ) echo -e ""${green}${message}${nc}"""
      fi
                 $2 = location to download file into on host system
"  [ ! -d ""${bash_autocomplete_prefix}/croc"" ] "
                This script installs croc into a specified prefix.
  cat <<-'EOF'
"    print_message ""== Unknown return code returned while checking checksum of ${tmpdir}/${croc_file}. Returned ${checksum_check_rcode}"" ""error"""
  local download_file_rcode
"  case ""${severity}"" in"
  local tmpdir_rcode
"      ""amd64"" ) croc_arch=""64bit"""
"    if [[ ""${EUID}"" == ""0"" ]]"
              ____
"    shasum_c=""$(shasum -a 256 -c ""filtered_checksum.txt"")"""
 DEFAULTS
  local install_file_rcode
 Treat unset variables as an error
"      ""arm64"" ) croc_arch=""ARM64"""
      return 0
"  case ""${croc_arch}"" in"
                 1 = checksum verification failed
  local file
          NAME:  checksum_check
"  severity=""${2}"""
  __/ 
  local extract_file_rcode
                  Issues: https://github.com/schollz/croc/issues
/ _ 
"    ""tar.gz"" ) if command -v tar >/dev/null 2>"
               else
           
"    elif [[ ""${create_prefix_rcode}"" == ""21"" ]]"
=================================================
"        sudo install -m 755 ""${file}"" ""${prefix}"""
"    print_message ""== Installed ${croc_bin_name} to ${prefix}/"" ""ok"""
e[0m'
" With sha256 on FreeBSD, we don't get to --ignore-missing, so filter the checksum file"
"        sudo mkdir -p ""${prefix}"""
"  REQUIREMENTS: bash, uname, tar/unzip, curl/wget, sudo (if not run"
                 20 = failed to determine tool to use to check checksum
"  elif [[ ""${install_file_rcode}"" == ""21"" ]]"
                wget -qO- https://getcroc.schollz.com 
    PARAMETERS:  $1 = file to extract
  local croc_os
_ __ _
  local prefix
"    uname_out=""$(uname)"""
  local autocomplete_install_rcode
32m'
  local croc_bin_name
"  elif [[ ""${croc_os_rcode}"" == ""1"" ]]"
  local download_checksum_file_rcode
" With shasum on FreeBSD, we don't get to --ignore-missing, so filter the checksum file"
         NOTES: Homepage: https://schollz.com/software/croc
"    shasum_1=""$(sha256 -q ""${file}"")"""
"                 0, then attempt to use sudo."
"  print_message ""== Installation complete"" ""ok"""
                 $3 = working directory
 __/ _
  local croc_dl_ext
   DESCRIPTION:  Creates the install prefix (and any parent directories). If
-------------------------------------------------------------------------------
nsource /etc/zsh/zsh_autocomplete_croc
"  extract_file_rcode=""${"
"   print_message ""== Failed to install ${bash_autocomplete_file}"" ""error"""
       RETURNS:  0 = File Installed
"    rcode=""20"""
  local tempdir_rcode
"       ""zip"" ) if command -v unzip >/dev/null 2>"
 ___ _ __
"  croc_bin_name=""croc"""
  fi
  yellow='
make_tempdir() {
___/
==================================================
  elif command -v sha256 >/dev/null 2>
  local croc_url
          NAME:  determine_arch
"OPTS=""hp:"""
"    print_message ""== Failed to download croc checksums"" ""error"""
print_help() {
n_CLI_ZSH_AUTOCOMPLETE_HACK=1
"    print_message ""== Install prefix already exists. No need to create it."" ""info"""
"  croc_os_rcode=""${"
"   print_message ""== Failed to locate 'install' command"" ""error"""
install_file_linux() {
   DESCRIPTION:  Attempts to determine host os using uname
    PARAMETERS:  $1 = url of file to download
                 tool to use by checking file extension.
determine_os() {
"  if [[ ""${download_file_rcode}"" == ""0"" ]]"
"  elif [[ ""${checksum_check_rcode}"" == ""30"" ]]"
"  help_message=""Usage:"
"      echo ""${uname_out}"""
"  download_file ""${croc_url}"" ""${tmpdir}"" ""${croc_file}"""
"  case ""${croc_os}"" in"
"    if [[ ""${create_prefix_rcode}"" == ""0"" ]]"
      else
"     ""armv9l"" ) croc_arch=""ARM"""
"n"" ""info"""
"      mkdir -p ""${prefix}"""
"    print_message ""== Failed to locate 'install' command"" ""error"""
" elif [[ ""${autocomplete_install_rcode}"" == ""21"" ]]"
"  prefix=""${2}"""
"  tmpdir=""$(make_tempdir ""${croc_bin_name}"")"""
"  croc_checksum_url=""${croc_base_url}/v${croc_version}/${croc_checksum_file}"""
"  download_file_rcode=""${"
print_message() {
                 20 = Failed to determine which tool to use
"  elif [[ ""${extract_file_rcode}"" == ""30"" ]]"
"  croc_url=""${croc_base_url}/v${croc_version}/${croc_file}"""
                 1 = Unknown OS
___/ 
"  extract_file ""${tmpdir}/${croc_file}"" ""${tmpdir}/"" ""${croc_dl_ext}"""
"  elif [[ ""${extract_file_rcode}"" == ""31"" ]]"
    PARAMETERS:  1 = prefix
  local bash_autocomplete_prefix
"    print_message ""== Checksum of ${tmpdir}/${croc_file} verified"" ""ok"""
" ) croc_arch=""unknown"""
"    ""macOS"" ) install_file_freebsd ""${tmpdir}/${croc_bin_name}"" ""${prefix}/"""
"   print_message ""== Failed to locate 'sudo' command"" ""error"""
"  echo ""${help_header}"""
    return 20
"    print_message ""== OS detected as ${croc_os}"" ""info"""
  local green
  local message
  local croc_arch
  local croc_arch_rcode
"    print_message ""== Failed to install ${croc_bin_name}"" ""error"""
"  INSTALL_PREFIX=""${PREFIX}/bin"""
  print_banner
"  ""FreeBSD"" ) install_file_freebsd ""${tmpdir}/${croc_bin_name}"" ""${prefix}/"""
  local tempdir
"  file=""${2}"""
"            print_message """
                 20 = Could not find install command
"    uname_out=""$(uname -m)"""
"    print_message ""== OS not detected"" ""error"""
                 $3 = extension
"    print_message ""== Return code of download tool returned an unexpected value of ${download_file_rcode}"" ""error"""
    'h' ) print_help
  local uname_out
_ __ ___   ___
  local checksum_file
"  bash_autocomplete_prefix=""/etc/bash_completion.d"""
   DESCRIPTION:  Attempt to verify checksum of downloaded file to ensure
       ___           _        _ _
   DESCRIPTION:  Put it all together in a logical way
"        sudo install -C -b -S '_old' -m 755 ""${file}"" ""${prefix}"""
"  bash_autocomplete_file=""bash_autocomplete"""
   DESCRIPTION:  Prints a message all fancy like
"  if [[ ""${checksum_check_rcode}"" == ""0"" ]]"
"      print_message ""== Failed to find mkdir in path"" ""error"""
 '_ 
 return 30
"      print_message ""== Created install prefix at ${prefix}"" ""info"""
_ __  ___
"  checksum_check ""${tmpdir}/${croc_checksum_file}"" ""${tmpdir}/${croc_file}"" ""${tmpdir}"""
  local croc_base_url
set -o nounset                              
"/.zshrc to enable autocompletion"" ""info"""
"    create_prefix_rcode=""${"
 / __
  local shasum_1
"    shasum_2=""$(awk '{print $1}' filtered_checksum.txt)"""
"    print_message ""== Failed to find tool to verify sha256 sums"" ""error"""
"    print_message ""== Architecture not detected"" ""error"""
"       OPTIONS: -p, --prefix ""${INSTALL_PREFIX}"""
install_file_cygwin() {
    
"ANDROID_ROOT=""${ANDROID_ROOT:-}"""
  local shasum_2
"    print_message ""== Created temp dir at ${tmpdir}"" ""info"""
          NAME:  main
download_file() {
               
          FILE: default.txt
  red='
                 30 = Failed to find tool in path
   DESCRIPTION:  Prints a banner
"  croc_checksum_file=""${croc_bin_name}_v${croc_version}_checksums.txt"""
                 OR
                 30 = failed to change into or go back from working dir
"    ""Linux"" ) install_file_linux ""${tmpdir}/${croc_bin_name}"" ""${prefix}/"""
"        install -C -b -S '_old' -m 755 -t ""${prefix}"" ""${file}"""
  if command -v curl >/dev/null 2>
  elif command -v wget >/dev/null 2>
   DESCRIPTION:  Downloads a file into the specified directory.  Attempts to
   DESCRIPTION:  Extracts a file into a location.  Attempts to determine which
"    print_message ""== Unknown error returned from extraction attempt"" ""error"""
" ) print_message ""Unknown option ${OPTARG}"" ""warn"""
   DESCRIPTION:  Attempt to determine architecture of host
"    print_message ""== Downloaded croc checksums file into ${tmpdir}"" ""info"""
        
" case ""$(basename ${SHELL})"" in"
  local croc_file
 else
"  help_header=""croc Installer Script"""
          NAME:  print_banner
"        croc_os=""Linux"""
"  if [[ ! -d ""${prefix}"" ]]"
"        sudo install -C -b -B '_old' -m 755 ""${file}"" ""${prefix}"""
          NAME:  make_tempdir
          NAME:  print_message
  local nc
 to only include the file we downloaded.
"  dir=""${3}"""
" ) rcode=""20"""
"    elif [[ ""${create_prefix_rcode}"" == ""20"" ]]"
      exit 1
          NAME:  print_help
"    print_message ""== Extracted ${croc_file} to ${tmpdir}/"" ""info"""
       RETURNS:  Return code of the tool used to extract the file
"  if [[ ""${croc_os_rcode}"" == ""0"" ]]"
"    print_message ""== Return code of download tool returned an unexpected value of ${download_checksum_file_rcode}"" ""error"""
"  if [[ ""${croc_arch_rcode}"" == ""0"" ]]"
"    tempdir=""$(mktemp -d -t ""${template}"")"""
"  elif [[ ""${checksum_check_rcode}"" == ""20"" ]]"
"    create_prefix ""${prefix}"""
"""BusyBox"""
  local shasum_c
"                 rcode=""30"""
"      print_message ""== Failed to create the install prefix: ${prefix}"" ""error"""
"    ""CYGWIN"""
          BUGS: ...hopefully not.  Please report.
    PARAMETERS:  $1 = prefix
"              install_file_rcode=""${"
  local help_header
  if command -v install >/dev/null 2>
"  case ""${optchar}"" in"
"    ""warn"" ) echo -e ""${yellow}${message}${nc}"""
  esac
"  download_file ""${croc_checksum_url}"" ""${tmpdir}"" ""${croc_checksum_file}"""
"  url=""${1}"""
"  if [[ ""${tmpdir_rcode}"" == ""0"" ]]"
"  ""Windows"" ) install_file_cygwin ""${tmpdir}/${croc_bin_name}"" ""${prefix}/"""
" Also sha256 -c option seems to fail, so fall back to an if statement"
main() {
                 1 = Failed to create temp dir
  local zsh_autocomplete_prefix
"while getopts ""${OPTS}"" optchar"
" mkdir -p ""${bash_autocomplete_prefix}/croc"" >/dev/null 2>"
"    print_message ""== Failed to find 'tar' in path"" ""error"""
"  template=""${1}.XXXXXX"""
  else
"     ""x86_64"" ) croc_arch=""64bit"""
")      autocomplete_install_rcode=""1"""
"                 rcode=""31"""
 '__
  if command -v uname >/dev/null 2>
            
"      rcode=""${"
"     ""armv7l"" ) croc_arch=""ARM"""
"    print_message ""== Failed to determine which extraction tool to use"" ""error"""
"  echo """""
"                 use curl, then wget.  If neither is found, fail."
else
"  checksum_file=""${1}"""
"    ""info"" ) echo -e ""${nc}${message}${nc}"""
"  if [[ ""${extract_file_rcode}"" == ""0"" ]]"
"  croc_os=""$(determine_os)"""
 bash
  ARGUMENT PARSING
/ __
                 20 = Could not find curl and wget
  local croc_os_rcode
                 $2 = location of file to check
"  elif [[ ""${download_file_rcode}"" == ""1"" ]]"
 then
    PARAMETERS:  $1 = path to checksum file
"err = replaceInFile(""src/cli/cli.go"", "
= len(start)
", versionNew"
"func GetStringInBetween(str string, start string, end string) (result string) {"
"fmt.Sprintf(""%s%s%s"", start, oldVersion, end),"
if e == -1 {
" os.Getenv(""VERSION"")"
import (
"versionHash, err := exec.Command(""git"", ""rev-parse"", ""--short"", ""HEAD"").Output()"
func main() {
"fmt.Printf(""updated cli.go to version %s"
"n"", strings.Split(versionNew, ""-"")[0])"
"b, err := os.ReadFile(fname)"
"err = fmt.Errorf(""nothing"")"
"s := strings.Index(str, start)"
return
"fmt.Printf(""updated README to version %s"
newF := strings.Replace(
"err = os.WriteFile(fname, []byte(newF), 0o644)"
if s == -1 {
"Version = """
if err == nil {
"fmt.Printf(""updated default.txt to version %s"
versionHashNew := strings.TrimSpace(string(versionHash))
"""strings"""
"versionNew := ""v"" "
"""os/exec"""
fmt.Println(err)
"fmt.Sprintf(""%s%s%s"", start, replacement, end),"
return str[s:e]
versionHashNew)
"err = replaceInFile(""README.md"", "
"func replaceInFile(fname, start, end, replacement string) (err error) {"
"if oldVersion == """" {"
"oldVersion := GetStringInBetween(string(b), start, end)"
"""os"""
// GetStringInBetween Returns empty string if no start string found
"""fmt"""
", strings.Split(versionNew, ""-"")[0])"
"n"", versionNew)"
"err = replaceInFile(""src/install/default.txt"", "
func run() (err error) {
", strings.Split(versionNew, ""-"")[0][1:])"
"n"", strings.Split(versionNew, ""-"")[0][1:])"
if err != nil {
"string(b),"
"e := strings.Index(str[s:], end)"
package main
err := run()
"croc_version="""
version-
fmt.Println(versionNew)
fmt.Println(versionHashNew)
  fi
"  if [[ ""$cur"" == ""-"""
"words[@]-1} ${cur} --generate-bash-completion)}"")"
compdef $PROG
    _describe 'values' opts
 then
"  if [[ ""${opts[1]}"" != """" ]]"
  else
  local cur
  return
"    opts=(""${(@f)$(_CLI_ZSH_AUTOCOMPLETE_HACK=1 ${words[@]:0:"
compdef _cli_zsh_autocomplete $PROG
  cur=${words[-1]}
_cli_zsh_autocomplete() {
"words[@]-1} --generate-bash-completion)}"")"
  local -a opts
    _files
: ${PROG:=$(basename ${BASH_SOURCE})}
_cli_bash_autocomplete() {
    COMPREPLY=()
"    if [[ ""$cur"" == ""-"""
      opts=$( ${COMP_WORDS[@]:0:$COMP_CWORD} ${cur} --generate-bash-completion )
"  if [[ ""${COMP_WORDS[0]}"" != ""source"" ]]"
"    cur=""${COMP_WORDS[COMP_CWORD]}"""
    fi
unset PROG
    local cur opts base
 then
"    COMPREPLY=( $(compgen -W ""${opts}"" -- ${cur}) )"
complete -o bashdefault -o default -o nospace -F _cli_bash_autocomplete $PROG
  fi
    else
    return 0
      opts=$( ${COMP_WORDS[@]:0:$COMP_CWORD} --generate-bash-completion )
release:
"git tag -af v${VERSION} -m ""v${VERSION}"""
cp zsh_autocomplete ../../
test:
 go generate
"git commit -am ""bump ${VERSION}"""
cp bash_autocomplete ../../
 VERSION=8.X.Y make release
git push
 goreleaser release --skip-publish
 ./src/install/upload-src-tarball.sh
 go run src/install/updateversion.go
 ./src/install/prepare-sources-tarball.sh
cd ../../ 
git push --tags
 goreleaser release
"filename=""dist/croc_${VERSION}_src.tar.gz"""
 set -x
!/bin/bash
 Read asset tags.
1/')
" { echo ""Error: Invalid repo, token or network issue!"""
0-9.]
"CURL_ARGS=""-LJO"
" grep 'Version = ""v' "
 tr -cd '[[:alnum:]]=')
" { echo ""Error: Failed to get release id for tag: $tag"""
([0-9.]
 Define variables.
"GH_ASSET=""https://uploads.github.com/repos/$owner/$repo/releases/$id/assets"
set -e
done
"tag=""v${VERSION}"""
"curl -o /dev/null -sH ""$AUTH"" $GH_REPO "
"curl ""$GITHUB_OAUTH_BASIC"" --data-binary @""$filename"" -H ""Authorization: token $GITHUB_TOKEN"" -H ""Content-Type: application/octet-stream"" $GH_ASSET"
 sed 's/[
 Validate settings.
  exit 1
 grep -w id 
" grep -m 1 ""id.:"" "
"AUTH=""Authorization: token $GITHUB_TOKEN"""
 Upload asset
echo $VERSION
 tr : = 
"[ ""$id"" ] "
"GH_API=""https://api.github.com"""
"echo ""Uploading asset... """
CONFIG=$@
"response=$(curl -sH ""$AUTH"" $GH_TAGS)"
 Get ID of the asset based on given filename.
for line in $CONFIG
VERSION=$(cat ./src/cli/cli.go 
"[ ""$TRACE"" ] "
xargs=$(which gxargs 
"if [[ ""$tag"" == 'LATEST' ]]"
"  eval ""$line"""
"repo=""croc"""
 awk 'length($0)<100' >
"name=$(basename $filename)"""
 Construct url
"GH_TAGS=""$GH_REPO/releases/tags/$tag"""
" echo ""$response"" "
"  GH_TAGS=""$GH_REPO/releases/latest"""
"owner=""schollz"""
 then
 which xargs)
"GH_REPO=""$GH_API/repos/$owner/$repo"""
"eval $(echo ""$response"" "
 Validate token.
"WGET_ARGS=""--content-disposition --auth-no-challenge --no-cookie"""
 exit 1
 Check dependencies.
git clone -b v${VERSION} --depth 1 https://github.com/schollz/croc $tmp/croc-${VERSION}
!/bin/bash
tmp=$(mktemp -d)
 go mod tidy 
 tar -cvzf croc_${VERSION}_src.tar.gz croc-${VERSION})
 go mod vendor)
mv $tmp/croc_${VERSION}_src.tar.gz dist/
(cd $tmp 
(cd $tmp/croc-${VERSION} 
echo $VERSION
"func Decode(key []byte, b []byte) (m Message, err error) {"
if key != nil {
"""encoding/json"""
"log ""github.com/schollz/logger"""
"json:""m,omitempty"""
func (m Message) String() string {
"comm.Comm, key []byte, m Message) (err error) {"
"""github.com/schollz/croc/v10/src/comm"""
"json:""n,omitempty"""
"log.Debugf(""read %s message (unencrypted)"", m.Type)"
Type    Type   
"""github.com/schollz/croc/v10/src/compress"""
// Encode will convert to bytes
"TypeFileInfo       Type = ""fileinfo"""
"TypeError          Type = ""error"""
// Send will send out
} else {
import (
// Message is the possible payload for messaging
"TypeRecipientReady Type = ""recipientready"""
"b, err = crypt.Decrypt(b, key)"
"err = json.Unmarshal(b, "
"TypePAKE           Type = ""pake"""
return
"TypeCloseSender    Type = ""close-sender"""
Message string 
type Type string
"b, err = json.Marshal(m)"
if err == nil {
package message
type Message struct {
b = compress.Compress(b)
Bytes2  []byte 
"TypeExternalIP     Type = ""externalip"""
"b, _ := json.Marshal(m)"
"log.Debugf(""read %s message (encrypted)"", m.Type)"
"mSend, err := Encode(key, m)"
"json:""b2,omitempty"""
"log.Debugf(""writing %s message (encrypted)"", m.Type)"
Bytes   []byte 
"b, err = crypt.Encrypt(b, key)"
"TypeCloseRecipient Type = ""close-recipient"""
b = compress.Decompress(b)
return string(b)
"""github.com/schollz/croc/v10/src/crypt"""
err = c.Send(mSend)
// Type is a message type
"json:""t,omitempty"""
if err != nil {
// Decode will convert from bytes
func Send(c 
const (
"json:""b,omitempty"""
Num     int    
"func Encode(key []byte, m Message) (b []byte, err error) {"
"TypeFinished       Type = ""finished"""
"log.Debugf(""writing %s message (unencrypted)"", m.Type)"
"assert.Equal(t, m, m2)"
"log ""github.com/schollz/logger"""
fmt.Println(string(salt))
testing.T) {
"""github.com/schollz/croc/v10/src/comm"""
 time.Millisecond)
time.Minute)
log.Error(err)
func TestSend(t 
"port, 10"
"fmt.Printf(""%x"
"err = c.Send([]byte(""hello, world""))"
"assert.Nil(t, err)"
"{""t"":""message"",""m"":""hello, world""}"
"e, salt, err := crypt.New([]byte(""pass""), nil)"
import (
"b, err := Encode(e, m)"
func TestMessageNoPass(t 
"b, err := Encode(nil, m)"
"""crypto/rand"""
port)
"port := ""8801"""
"assert.NotNil(t, err)"
for {
log.Debug(salt)
"token := make([]byte, 40000000)"
"var TypeMessage Type = ""message"""
"""net"""
"""github.com/stretchr/testify/assert"""
"log.SetLevel(""debug"")"
"connection, err := server.Accept()"
", m.String())"
"data, err = c.Receive()"
"_, err = Encode([]byte(""0""), m)"
"log.Debugf(""starting TCP server on "" "
package message
"server, err := net.Listen(""tcp"", ""0.0.0.0:"""
func TestMessage(t 
"}(port, connection)"
"go func(_ string, connection net.Conn) {"
"data, err := c.Receive()"
defer server.Close()
"m2, err := Decode(e, b)"
"_, err = Decode([]byte(""not pass""), b)"
 port)
"""time"""
go func() {
c := comm.New(connection)
"assert.Equal(t, []byte(""hello, computer""), data)"
"assert.Equal(t, token, data)"
time.Sleep(800 
"assert.Equal(t, []byte{'"
"""testing"""
rand.Read(token)
"""fmt"""
"""github.com/schollz/croc/v10/src/crypt"""
if err != nil {
// spawn a new goroutine whenever a client connects
"log.Debugf(""client %s connected"", connection.RemoteAddr().String())"
"a, err := comm.NewConnection(""127.0.0.1:"""
"m := Message{Type: TypeMessage, Message: ""hello, world""}"
"assert.Nil(t, Send(a, e, m))"
"m2, err := Decode(nil, b)"
"x00'}, data)"
"n"", b)"
"assert.Equal(t, "
"err = fmt.Errorf(""need more than that for passphrase"")"
if usersalt == nil {
if len(encrypted) < 13 {
"err = fmt.Errorf(""incorrect passphrase"")"
"""crypto/aes"""
"1024, 4, 32))"
len(plaintext)
// Decrypt the message and check it wasn't tampered with.
package crypt
} else {
"if _, err := rand.Read(nonce)"
import (
"func Encrypt(plaintext []byte, key []byte) (encrypted []byte, err error) {"
"nonce, ciphertext := encryptedMsg[:aead.NonceSize()], encryptedMsg[aead.NonceSize():]"
"""crypto/rand"""
// Salt.
"""golang.org/x/crypto/chacha20poly1305"""
"""crypto/sha256"""
// generate a random iv each time
// NewArgon2 generates a new key based on a passphrase and salt
"""golang.org/x/crypto/argon2"""
if len(passphrase) < 1 {
return
"encrypted = aesgcm.Seal(nil, ivBytes, plaintext, nil)"
"""golang.org/x/crypto/pbkdf2"""
"func New(passphrase []byte, usersalt []byte) (key []byte, salt []byte, err error) {"
// https://pkg.go.dev/golang.org/x/crypto/argon2
// Encrypt the message and append the ciphertext to the nonce.
"encrypted = aead.Seal(nonce, nonce, plaintext, nil)"
"if _, err := rand.Read(salt)"
// https://pkg.go.dev/golang.org/x/crypto/chacha20poly1305
"func DecryptChaCha(encryptedMsg []byte, aead cipher.AEAD) (encrypted []byte, err error) {"
salt = usersalt
// DecryptChaCha will encrypt ChaCha20-Poly1305 using the pre-generated key
"encrypted, err = aead.Open(nil, nonce, ciphertext, nil)"
// using argon2
// New generates a new key based on a passphrase and salt
// Decrypt using the pre-generated key
// http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf
"aead, err = chacha20poly1305.NewX(argon2.IDKey(passphrase, salt, 1, 64"
"func Decrypt(encrypted []byte, key []byte) (plaintext []byte, err error) {"
"ivBytes := make([]byte, 12)"
// http://www.ietf.org/rfc/rfc2898.txt
"""log"""
"""crypto/cipher"""
"aesgcm, err := cipher.NewGCM(b)"
// Split nonce and ciphertext.
"key = pbkdf2.Key(passphrase, salt, 100, 32, sha256.New)"
"plaintext, err = aesgcm.Open(nil, encrypted[:12], encrypted[12:], nil)"
aead.Overhead())
"b, err := aes.NewCipher(key)"
"encrypted = append(ivBytes, encrypted...)"
// EncryptChaCha will encrypt ChaCha20-Poly1305 using the pre-generated key
if len(encryptedMsg) < aead.NonceSize() {
 err != nil {
"""fmt"""
// Encrypt will encrypt using the pre-generated key
"if _, err = rand.Read(salt)"
"nonce := make([]byte, aead.NonceSize(), aead.NonceSize()"
panic(err)
"log.Fatalf(""can't get random salt: %v"", err)"
if err != nil {
"err = fmt.Errorf(""ciphertext too short"")"
"func NewArgon2(passphrase []byte, usersalt []byte) (aead cipher.AEAD, salt []byte, err error) {"
// Section 8.2
"salt = make([]byte, 8)"
"func EncryptChaCha(plaintext []byte, aead cipher.AEAD) (encrypted []byte, err error) {"
"log.Fatalf(""can't initialize crypto: %v"", err)"
"if _, err = rand.Read(ivBytes)"
"key, _, _ := New([]byte(""password""), nil)"
// error with no password
"New([]byte(""password""), nil)"
"key2, _, _ := NewArgon2([]byte(""password""), salt)"
"_, _, err = New([]byte(""""), nil)"
func BenchmarkEncrypt(b 
func BenchmarkNewPbkdf2(b 
testing.T) {
"_, err = Decrypt([]byte(""""), key)"
testing.B) {
func TestEncryption(t 
package crypt
"bob, _, _ := New([]byte(""password""), nil)"
"assert.Nil(t, err)"
import (
"enc, err := Encrypt(msg, key)"
"key, salt, err := NewArgon2([]byte(""password""), nil)"
"dec, err := DecryptChaCha(enc, key)"
"_, err = DecryptChaCha([]byte(""""), key)"
"assert.NotNil(t, err)"
"""github.com/stretchr/testify/assert"""
"enc, _ := Encrypt(msg, key)"
"assert.NotEqual(t, msg, dec)"
"dec, err = Decrypt(enc, key2)"
func BenchmarkEncryptChaCha(b 
"dec, err := Decrypt(enc, key)"
func BenchmarkDecrypt(b 
// error with small password
b.ResetTimer()
"Decrypt(enc, key)"
"fmt.Printf(""key: %x"
"key2, _, _ := New([]byte(""password""), salt)"
"key, _, _ := NewArgon2([]byte(""password""), nil)"
"msg := []byte(""hello, world"")"
"DecryptChaCha(enc, key)"
"key2, _, _ = New([]byte(""wrong password""), salt)"
func TestEncryptionChaCha(t 
for i := 0
"""testing"""
"enc, err := EncryptChaCha(msg, key)"
func BenchmarkNewArgon2(b 
 i < b.N
// check reusing the salt
"""fmt"""
"dec, err = DecryptChaCha(enc, key2)"
"Encrypt([]byte(""hello, world""), bob)"
"bob, _, _ := NewArgon2([]byte(""password""), nil)"
"_, _, err = NewArgon2([]byte(""""), nil)"
"key, salt, err := New([]byte(""password""), nil)"
"n"", key)"
"NewArgon2([]byte(""password""), nil)"
"key2, _, _ = NewArgon2([]byte(""wrong password""), salt)"
"enc, _ := EncryptChaCha(msg, key)"
"EncryptChaCha([]byte(""hello, world""), bob)"
"assert.Equal(t, msg, dec)"
func BenchmarkDecryptChaCha(b 
func TestMD5HashFile(t 
func TestIMOHashFile(t 
"""path"""
" !intSliceSame(openPorts, []int{9014, 9015, 9016, 9017}) {"
func TestPublicIP(t 
defer os.Remove(tmpfile.Name()) // clean up
"XXHashFile(""bigfile.test"", false)"
"os.WriteFile(""missing.test"", bigBuff, 0o644)"
if len(a) != len(b) {
"8203 in '44e4b8ade696872e63736c6f75676c6173e2808b'"", err.Error())"
"b, err := IMOHashFile(""bigfile.test"")"
 block
"func intSliceSame(a, b []int) bool {"
"HighwayHashFile(""bigfile.test"", false)"
name := GetRandomName()
"MD5HashFile(""bigfile.test"", false)"
 block == 4 
"assert.Equal(t, []int64{0, 40, 50, 70, 80, 90}, chunks)"
"os.Remove(""missing.test"")"
func BenchmarkXXHash(b 
"chunkRanges := MissingChunks(""missing.test"", int64(fileSize), chunkSize)"
chunkSize))
// func Test1(t 
"assert.Equal(t, ""8304ff018e02baad0e3555bade29a405"", fmt.Sprintf(""%x"", b))"
log.Fatal(err)
chunkSize := 10
func TestGetRandomName(t 
"assert.True(t, IsLocalIP(""192.168.0.14:9009""))"
"f.WriteAt(empty, int64(block"
"assert.True(t, strings.Contains(ip, ""."") "
func TestSHA256(t 
fmt.Println(GetLocalIPs())
"t.Errorf(""openPorts: %v"", openPorts)"
"if _, err = tmpfile.Write(content)"
"os.WriteFile(""bigfile.test"", bytes.Repeat([]byte(""z""), bigFileSize), 0o666)"
"MissingChunks(""bigfile.test"", int64(bigFileSize), TCP_BUFFER_SIZE/2)"
func TestValidFileName(t 
"chunkRanges := MissingChunks(""../../m/bigfile.test"", int64(75000000), 1024"
"assert.Equal(t, []int64{10, 0, 1, 40, 2, 70, 3}, chunkRanges)"
if v != b[i] {
"for i, v := range a {"
fmt.Println(name)
64/2)
"chunkRanges = MissingChunks(tmpfile.Name(), int64(len(content)), chunkSize)"
"assert.Equal(t, ""3c32999529323ed66a67aeac5720c7bf1301dcc5dca87d8d46595e85ff990329"", fmt.Sprintf(""%x"", b))"
"""math/rand"""
testing.T) {
func TestFindOpenPorts(t 
"assert.Equal(t, ""12.4 MB"", ByteCountDecimal(13002343))"
"tmpfile, err := os.CreateTemp("""", ""example"")"
"assert.Equal(t, ""e66c561610ad51e2"", fmt.Sprintf(""%x"", hashed))"
func TestExists(t 
"assert.NotNil(t, err)"
"assert.Equal(t, ""non-graphical unicode: e2808b U"
func BenchmarkHighwayHash(b 
fmt.Println(ip)
"IMOHashFile(""bigfile.test"")"
 block == 5 
b.ResetTimer()
func TestLocalIP(t 
// contains invisible character
package utils
"""log"""
"""testing"""
"""os"""
"defer os.Remove(""bigfile.test"")"
func BenchmarkMissingChunks(b 
var bigFileSize = 75000000
"chunkRanges = MissingChunks(tmpfile.Name(), int64(len(content)"
f.Close()
if err != nil {
fmt.Println(chunkRanges)
"""bytes"""
"assert.Nil(t, ValidFileName(""[(something)].csl""))"
"_, err = XXHashFile(""nofile"", false)"
"assert.Equal(t, ""09ca7e4eaa6e8ae9c7d261167129184883644d07dfba7cbfbc4c8a2e08360d5b"", SHA256(""hello, world""))"
rand.Read(bigBuff)
"assert.False(t, Exists(""doesnotexist""))"
chunks := ChunkRangesToChunks(chunkRanges)
"assert.Equal(t, ""4918740eb5ccb6f7"", fmt.Sprintf(""%x"", b))"
testing.B) {
rand.Seed(1)
import (
".csl""))"
"assert.NotEmpty(t, name)"
if err := tmpfile.Close()
"empty := make([]byte, chunkSize)"
return true
func bigFile() {
func TestHighwayHashFile(t 
"content := []byte(""temporary file's content"")"
// }
"assert.Nil(t, ValidFileName(""[something].csl""))"
chunks = ChunkRangesToChunks(chunkRanges)
"assert.Nil(t, nil)"
func TestHashFile(t 
"_, err = MD5HashFile(""bigfile.test.nofile"", false)"
if block == 0 
" strings.Contains(ip, "":""))"
"assert.Empty(t, chunks)"
func TestIsLocalIP(t 
fileSize := 100
func TestXXHashFile(t 
"assert.Equal(t, ""10.0 kB"", ByteCountDecimal(10240))"
for i := 0
// contains regular characters
 i < b.N
"SHA256(""hello,world"")"
"""fmt"""
func BenchmarkMD5(b 
 block < fileSize/chunkSize
 err != nil {
"IMOHashFileFull(""bigfile.test"")"
"assert.Empty(t, chunkRanges)"
"assert.Equal(t, ""50 B"", ByteCountDecimal(50))"
"hashed, err := HashFile(tmpfile.Name(), ""xxhash"")"
"assert.NotNil(t, ValidFileName(""hi..txt""))"
bigFile()
"b, err := XXHashFile(""bigfile.test"", false)"
"ip, err := PublicIP()"
func BenchmarkImoHashFull(b 
"assert.True(t, Exists(""bigfile.test""))"
"assert.Nil(t, ValidFileName("""
"assert.Nil(t, err)"
const TCP_BUFFER_SIZE = 1024 
func BenchmarkImoHash(b 
func BenchmarkSha256(b 
"if _, err := tmpfile.Write(content)"
func TestMissingChunks(t 
chunkRanges = MissingChunks(tmpfile.Name()
"err := ValidFileName(""D"
"bigBuff := make([]byte, fileSize)"
"""github.com/stretchr/testify/assert"""
fmt.Println(ChunkRangesToChunks((chunkRanges)))
"openPorts := FindOpenPorts(""127.0.0.1"", 9009, 4)"
.cslouglas
"10), chunkSize)"
"""strings"""
"b, err := HighwayHashFile(""bigfile.test"", false)"
"assert.NotNil(t, ValidFileName(path.Join(string(os.PathSeparator), ""abs"", string(os.PathSeparator), ""hi.txt"")))"
"b, err := MD5HashFile(""bigfile.test"", false)"
"if !intSliceSame(openPorts, []int{9009, 9010, 9011, 9012}) "
if err = tmpfile.Close()
func TestByteCountDecimal(t 
"""ok"", int64(len(content)), chunkSize)"
"f, err := os.OpenFile(""missing.test"", os.O_RDWR, 0o644)"
return false
"assert.Equal(t, ""c0d1e12301e6c635f6d4a8ea5c897437"", fmt.Sprintf(""%x"", b))"
"_, err = HighwayHashFile(""bigfile.test.nofile"", false)"
panic(err)
for block := 0
 block >= 7 {
ip := LocalIP()
"""github.com/cespare/xxhash/v2"""
"""path"""
for i := 1
log.Error(err)
"return []byte(SHA256(target)), nil"
"if _, err := io.Copy(w1, f1)"
"zipPath := strings.ReplaceAll(path, source, strings.TrimSuffix(destination, "".zip""))"
fileInArchive.Close()
// by making sure it has no invisible characters
if fstats.Mode()
os.ModeSymlink != 0 {
"addrs, err := net.InterfaceAddrs()"
if doShowProgress {
"chunkRanges = []int64{int64(chunkSize), chunks[0]}"
dstFile.Close()
max := new(big.Int)
choice := strings.ToLower(GetInput(prompt))
"func XXHashFile(fname string, doShowProgress bool) (hash256 []byte, err error) {"
"homedir = path.Join(xdgConfigHome, ""croc"")"
if ip.IsLoopback() 
"log.Tracef(""Removed %s"", fname)"
func GetRandomName() string {
 isSet {
"// make sure the filepath does not have "".."""
"err = os.MkdirAll(homedir, 0o700)"
func SHA256(s string) string {
const NbBytesWords = 4
"""archive/zip"""
// no compression because croc does its compression on the fly
"buffer := make([]byte, chunkSize)"
"if _, err := io.Copy(dstFile, fileInArchive)"
1024)
chunks[chunkNum] = currentLocation
if b < unit {
// SHA256 hash of its target. Takes an argument to specify the algorithm to use.
"""encoding/hex"""
err = nil
// Get or create home directory
package utils
 port
"err = filepath.Walk(source, func(path string, info os.FileInfo, err error) error {"
"return nil, err"
"if _, err := os.Stat(name)"
"fmt.Fprintf(os.Stderr, ""Zipping %s to %s"
// MissingChunks returns the positions of missing chunks.
const NbPinNumbers = 4
if err != nil {
"return fmt.Sprintf(""%.1f %cB"", float64(b)/float64(div), ""kMGTPE""[exp])"
"if ipnet, ok := address.("
"""bytes"""
"progressbar.OptionFullWidth(),"
"case ""highway"":"
"if strings.Contains(filePath, "".."") {"
// GetLocalIPs returns all local ips
// read the file and remove all the files
// https://stackoverflow.com/questions/41240761/check-if-ip-address-is-in-private-network-space
"""bufio"""
"b, err := imopartial.SumFile(fname)"
"""net/http"""
"div, exp := int64(unit), 0"
"""crypto/rand"""
 ip.IsLinkLocalUnicast() 
"bs := make([]byte, NbBytesWords)"
"return fmt.Sprintf(""%d B"", b)"
"openPorts = append(openPorts, port)"
"""github.com/schollz/croc/v10/src/mnemonicode"""
// GetRandomName returns mnemonicoded random name
err = os.Remove(fname)
"= fmt.Sprintf(""%d"", v)"
"ips = append(ips, ipnet.IP.String())"
 err != nil {
// LocalIP returns local ip address
"case ""imohash"":"
var currentLocation int64
"bar := progressbar.NewOptions64(stat.Size(),"
"func RandomFileName() (fname string, err error) {"
chunkSize)
if chunkNum == 0 {
var result []string
"err = fmt.Errorf(""non-graphical unicode: %x U"
for {
"chunks := make([]int64, int64(math.Ceil(float64(fsize)/float64(chunkSize))))"
"key, err := hex.DecodeString(""1553c5383fb0b86578c3310da665b4f6e0521acf22eb58a99532ffed02a6b115"")"
if len(fnameShort) > 20 {
"s := """""
"""github.com/kalafut/imohash"""
"file, err := os.Create(destination)"
defer conn.Close()
nOverwrite '%s'
// by making http request
if os.IsNotExist(err) {
 ok 
"""fc00::/7"",       // IPv6 unique local addr"
if chunk-chunks[i-1] > int64(chunkSize) {
doShowProgress = showProgress[0]
"const crocRemovalFile = ""croc-marked-files.txt"""
"fileInArchive, err := f.Open()"
"chunkRanges = append(chunkRanges, chunk)"
var imopartial = imohash.NewCustom(16
"""math/big"""
func IsLocalIP(ipaddress string) bool {
"err = fmt.Errorf(""filename cannot be an absolute path: '%s'"", fname)"
"err = fmt.Errorf(""could not create highwayhash: %s"", err.Error())"
"h, err := highwayhash.New(key)"
"_, basename := filepath.Split(fname)"
// ByteCountDecimal converts bytes to human readable byte string
} else {
"err = fmt.Errorf(""basename cannot contain '..': '%s'"", basename)"
"log.Errorf(""%s file already exists!"
"archive, err := zip.OpenReader(source)"
return s
 n >= unit
"err = fmt.Errorf(""unspecified algorithm"")"
ip := net.ParseIP(host)
"stat, _ := f.Stat()"
"func HighwayHashFile(fname string, doShowProgress bool) (hashHighway []byte, err error) {"
buf.ReadFrom(resp.Body)
"func MD5HashFile(fname string, doShowProgress bool) (hash256 []byte, err error) {"
"""time"""
// HighwayHashFile returns highwayhash of a file
 i < len(chunkRanges)
"os.O_TRUNC, f.Mode())"
"""github.com/minio/highwayhash"""
"""10.0.0.0/8"",     // RFC1918"
"for i, chunk := range chunks {"
"""169.254.0.0/16"", // RFC3927 link-local"
defer writer.Close()
"log.Errorf(""Invalid file path %s"
"for _, block := range privateIPBlocks {"
"} else if xdgConfigHome, isSet := os.LookupEnv(""XDG_CONFIG_HOME"")"
"return MD5HashFile(fname, doShowProgress)"
 fstat.Size() != fsize {
"f, err := os.OpenFile(crocRemovalFile, os.O_APPEND"
"_, err = f.WriteString(fname "
break
func MarkFileForRemoval(fname string) {
"if envHomedir, isSet := os.LookupEnv(""CROC_CONFIG_DIR"")"
"fmt.Fprintf(os.Stderr, ""Skipping '%s'"
if i == 0 {
if conn != nil {
"w1, err := writer.Create(zipPath)"
"rAdding %s"", zipPath)"
"""os"""
if requireValidPath {
func GetInput(prompt string) string {
"if _, err = os.Stat(destination)"
fname := scanner.Text()
switch algorithm {
ip = strings.TrimSpace(buf.String())
"""crypto/sha256"""
"os.O_WRONLY, 0o600)"
"func MissingChunks(fname string, fsize int64, chunkSize int) (chunkRanges []int64) {"
return true
// Issue 
return nil
return localAddr.IP.String()
" (y/N) "", filePath)"
zipPath = filepath.ToSlash(zipPath)
"os.MkdirAll(filePath, os.ModePerm)"
"if _, err = io.Copy(h, f)"
net.UDPAddr)
"""crypto/md5"""
if len(openPorts) >= numPorts {
"""127.0.0.0/8"",    // IPv4 loopback"
"if strings.Contains(basename, string(os.PathSeparator)) {"
 err == nil {
"""compress/flate"""
timeout := 100 
"""::1/128"",        // IPv6 loopback"
"1024, 128"
// GetInput returns the input with a given prompt
func Exists(name string) bool {
"fstat, err := os.Stat(fname)"
chunkNum := 0
 port-portNumStart < 200
 !ipnet.IP.IsLoopback() {
 os.IsNotExist(err) {
if err != nil 
// and return the ip address
defer file.Close()
"""strings"""
defer f1.Close()
// IMOHashFileFull returns imohash of full file
" ""-"" "
"dstFile, err := os.OpenFile(filePath, os.O_WRONLY"
conn.Close()
"case ""md5"":"
localAddr := conn.LocalAddr().(
"_, block, err := net.ParseCIDR(cidr)"
"chunkRanges = append(chunkRanges, int64(curCount))"
var target string
for scanner.Scan() {
if ipnet.IP.To4() != nil {
// MD5HashFile returns MD5 hash
fname = f.Name()
"""192.168.0.0/16"", // RFC1918"
"host, _, _ := net.SplitHostPort(ipaddress)"
func ByteCountDecimal(b int64) string {
return
"return flate.NewWriter(out, flate.NoCompression)"
hashHighway = h.Sum(nil)
curCount = 0
"filePath := filepath.Join(destination, f.Name)"
"if _, err = io.Copy(io.MultiWriter(h, bar), f)"
"fmt.Fprintf(os.Stderr, """
chunks = chunks[:chunkNum]
if len(showProgress) > 0 {
// ValidFileName checks if a filename is valid
hash256 = h.Sum(nil)
"// make sure basename does not include "".."" or path separators"
defer f.Close()
"// If the file size is not the same as requested, it returns an empty chunk list (all chunks)."
"f, err := os.CreateTemp(""."", ""croc-stdin-"")"
"writer.RegisterCompressor(zip.Deflate, func(out io.Writer) (io.WriteCloser, error) {"
"// HashFile returns the hash of a file or, in case of a symlink, the"
// make sure the filename is not an absolute path
os.O_CREATE
// ChunkRangesToChunks converts chunk ranges to list
writer := zip.NewWriter(file)
"""fe80::/10"",      // IPv6 link-local"
os.Remove(crocRemovalFile)
"emptyBuffer := make([]byte, chunkSize)"
"homedir = path.Join(homedir, "".config"", ""croc"")"
currentLocation 
// ask ipv4.icanhazip.com for the public ip
"""172.16.0.0/12"",  // RFC1918"
"func IMOHashFile(fname string) (hash []byte, err error) {"
// XXHashFile returns the xxhash of a file
homedir = envHomedir
"prompt := fmt.Sprintf("""
// local ip determination
max.SetInt64(9)
if info.Mode().IsRegular() {
"rUnzipping file %s"", filePath)"
"""io"""
func GenerateRandomPin() string {
"""math"""
import (
"if strings.Contains(basename, "".."") {"
"func HashFile(fname string, algorithm string, showProgress ...bool) (hash256 []byte, err error) {"
if err == nil {
net.IPNet)
593 conceal path traversal vulnerability
return hex.EncodeToString(sha.Sum(nil))
"if bytes.Equal(buffer[:bytesread], emptyBuffer[:bytesread]) {"
"""unicode"""
func init() {
"if _, err := os.Stat(filePath)"
doShowProgress := false
"n"", destination)"
"progressbar.OptionSetWriter(os.Stderr),"
"f, err := os.Open(crocRemovalFile)"
"""fmt"""
reader := bufio.NewReader(os.Stdin)
"homedir, err = os.UserHomeDir()"
if !unicode.IsPrint(r) {
" strings.Join(result, ""-"")"
// Exists reports whether the named file or directory exists.
fnameShort := path.Base(fname)
// check the address type and if it is not a loopback the display it
var fstats os.FileInfo
"if strings.Contains(ipaddress, ""127.0.0.1"") {"
"n"", filePath)"
continue
hash = b[:]
"resp, err := http.Get(""http://ipv4.icanhazip.com"")"
func RemoveMarkedFiles() (err error) {
if !unicode.IsGraphic(r) {
" choice != ""yes"" {"
"""net"""
"return XXHashFile(fname, doShowProgress)"
chunkRanges = []int64{}
// check if file exists
"v, err := rand.Int(rand.Reader, max)"
// append the fname to the list of files to remove
openPorts = []int{}
"var imofull = imohash.NewCustom(0, 0)"
 ip.IsLinkLocalMulticast() {
= unit
"for _, r := range fname {"
return false
"privateIPBlocks = append(privateIPBlocks, block)"
"f, err := os.Open(fname)"
chunkNum
panic(err)
if block.Contains(ip) {
"progressbar.OptionClearOnFinish(),"
"func GetConfigDir(requireValidPath bool) (homedir string, err error) {"
"progressbar.OptionShowBytes(true),"
if filepath.IsAbs(fname) {
"""path/filepath"""
"fmt.Fprintf(os.Stderr, ""%s"", prompt)"
"""github.com/schollz/progressbar/v3"""
"func PublicIP() (ip string, err error) {"
chunkSize := chunkRanges[0]
func ChunkRangesToChunks(chunkRanges []int64) (chunks []int64) {
"f1, err := os.Open(path)"
"%d in '%x'"", string(r), r, fname)"
return IMOHashFile(fname)
"for _, cidr := range []string{"
 i < NbPinNumbers
return GenerateRandomPin() 
const unit = 1024
for j := int64(0)
scanner := bufio.NewScanner(f)
_ = f.Close()
defer resp.Body.Close()
= 2 {
} else if err != nil {
// read the body of the response
return strings.TrimSpace(text)
fnameShort = fnameShort[:20] 
" ""..."""
"fstats, err = os.Lstat(fname)"
"bytesread, err := f.Read(buffer)"
h := md5.New()
// PublicIP returns public ip address
"panic(fmt.Errorf(""parse error on %q: %v"", cidr, err))"
sha.Write([]byte(s))
"err = fmt.Errorf(""basename cannot contain path separators: '%s'"", basename)"
for n := b / unit
"033[2K"")"
div 
"n"", source, destination)"
curCount
rand.Read(bs)
defer archive.Close()
"return """""
// SHA256 returns sha256 sum
buf := new(bytes.Buffer)
ips = []string{}
"return HighwayHashFile(fname, doShowProgress)"
filePath = filepath.Clean(filePath)
h := xxhash.New()
for port := portNumStart
"progressbar.OptionSetDescription(fmt.Sprintf(""Hashing %s"", fnameShort)),"
"text, _ := reader.ReadString('"
if len(chunkRanges) == 0 {
"func GetLocalIPs() (ips []string, err error) {"
"b, err := imofull.SumFile(fname)"
for i := 0
"target, err = os.Readlink(fname)"
func ValidFileName(fname string) (err error) {
log.Debug(err)
"func FindOpenPorts(host string, portNumStart, numPorts int) (openPorts []int) {"
"if choice != ""y"" "
"log ""github.com/schollz/logger"""
"func IMOHashFileFull(fname string) (hash []byte, err error) {"
sha := sha256.New()
 n /= unit {
 j < (chunkRanges[i
// IMOHashFile returns imohash
"conn, err := net.DialTimeout(""tcp"", net.JoinHostPort(host, fmt.Sprint(port)), timeout)"
"// If file doesn't exist, it returns an empty chunk list (all chunks)."
curCount := 0
// make sure it doesn't contain unicode or invisible characters
"func ZipDirectory(destination string, source string) (err error) {"
var privateIPBlocks []
"func UnzipDirectory(destination string, source string) error {"
"if err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm)"
"chunkRanges = append(chunkRanges, int64(curCount"
"result = mnemonicode.EncodeWordList(result, bs)"
"err = fmt.Errorf(""non-printable unicode: %x U"
"if _, err = os.Stat(homedir)"
if !requireValidPath {
"for _, f := range archive.File {"
"chunks = append(chunks, chunkRanges[i]"
= int64(bytesread)
func LocalIP() string {
"homedir = """""
"for _, address := range addrs {"
 time.Millisecond
if f.FileInfo().IsDir() {
"case ""xxhash"":"
"// if the request fails, return nothing"
chunks = []int64{}
"conn, err := net.Dial(""udp"", ""8.8.8.8:80"")"
net.IPNet
// Used returns total bytes used in file system
"err := unix.Statfs(volumePath, "
type DiskUsage struct {
// Available return total available bytes on file system to an unprivileged user
// DiskUsage contains usage data and provides user-friendly access methods
DiskUsage{
return uint64(du.stat.Bavail) 
import (
// Usage returns percentage of use on the file system
func (du 
package diskusage
DiskUsage) Free() uint64 {
DiskUsage) Used() uint64 {
// Size returns total size of the file system
return du.Size() - du.Free()
return uint64(du.stat.Blocks) 
DiskUsage {
return uint64(du.stat.Bfree) 
return nil
"// or nil in case of error (invalid path, etc)"
DiskUsage) Available() uint64 {
stat}
func NewDiskUsage(volumePath string) 
 uint64(du.stat.Bsize)
DiskUsage) Usage() float32 {
// NewDiskUsage returns an object holding the disk usage of volumePath
DiskUsage) Size() uint64 {
//go:build !windows
unix.Statfs_t
"""golang.org/x/sys/unix"""
stat := unix.Statfs_t{}
stat)
return 
if err != nil {
build !windows
stat 
// Free returns total free bytes on file system
return float32(du.Used()) / float32(du.Size())
// Used returns total bytes used in file system
totalBytes int64
type DiskUsage struct {
DiskUsage{}
import (
// Usage returns percentage of use on the file system
func (du 
package diskusage
DiskUsage) Free() uint64 {
DiskUsage) Used() uint64 {
// Size returns total size of the file system
"c := h.MustFindProc(""GetDiskFreeSpaceExW"")"
return du.Size() - du.Free()
"""unsafe"""
"du.totalBytes)),"
// Available returns total available bytes on file system to an unprivileged user
uintptr(unsafe.Pointer(
DiskUsage {
"// or nil in case of error (invalid path, etc)"
DiskUsage) Available() uint64 {
func NewDiskUsage(volumePath string) 
DiskUsage) Usage() float32 {
"""golang.org/x/sys/windows"""
"du.freeBytes)),"
// NewDiskUsage returns an object holding the disk usage of volumePath
return uint64(du.availBytes)
return du
DiskUsage) Size() uint64 {
du := 
"uintptr(unsafe.Pointer(windows.StringToUTF16Ptr(volumePath))),"
return uint64(du.totalBytes)
"h := windows.MustLoadDLL(""kernel32.dll"")"
freeBytes  int64
du.availBytes)))
return uint64(du.freeBytes)
availBytes int64
c.Call(
// Free returns total free bytes on file system
return float32(du.Used()) / float32(du.Size())
func TestNewDiskUsage(t 
"100, ""%"")"
"""fmt"""
var KB = uint64(1024)
package diskusage
KB))
"fmt.Println(""Size:"", usage.Size()/(KB"
testing.T) {
"fmt.Println(""Available:"", usage.Available()/(KB"
"fmt.Println(""Usage:"", usage.Usage()"
"usage := NewDiskUsage(""."")"
"fmt.Println(""Used:"", usage.Used()/(KB"
"fmt.Println(""Free:"", usage.Free()/(KB"
"""testing"""
import (
"""encoding/json"""
"""path"""
Classic mode is currently ENABLED.
"cli.BoolFlag{Name: ""no-multi"", Usage: ""disable multiplexing""},"
log.Error(err)
app.Flags = []cli.Flag{
if !classicInsecureMode {
err = cr.Receive()
"cli.BoolFlag{Name: ""overwrite"", Usage: ""do not prompt to overwrite or resume""},"
"""strconv"""
" strings.Join(pake.AvailableCurves(), "", "") "
var nbCharacter = len(lastPartialWord)
"Action:   send,"
if portString == 0 {
"phrase = append(phrase, c.Args().First())"
"ThrottleUpload:   c.String(""throttleUpload""),"
"""errors"""
"Debug:            c.Bool(""debug""),"
totalNumberFolders = len(folderMap)
app.Version = Version
nClassic mode ENABLED.
classicFile := getClassicConfigFile(true)
crocOptions.SharedSecret = rememberedOptions.SharedSecret
"if c.String(""code"") == """" {"
"return strArray, nbCharacter"
crocOptions.RelayAddress = rememberedOptions.RelayAddress
"GitIgnore:        c.Bool(""git""),"
"// check if ""classic"" is set"
app.Commands = []
"cli.BoolFlag{Name: ""yes"", Usage: ""automatically agree to all prompts""},"
    or
"configFile, err := getReceiveConfigFile(doRemember)"
" os.Getenv(""CROC_SECRET"") != """" {"
"if !c.IsSet(""pass"") "
app.Action = func(c 
  croc send file.txt
"cli.BoolFlag{Name: ""ask"", Usage: ""make sure sender and recipient are prompted""},"
"On UNIX systems, to send with a custom code phrase, "
portParam = 9009
" rememberedOptions.RelayAddress6 != """" {"
" !c.Bool(""remember"") {"
"log.Debugf(""wrote %s"", configFile)"
"ZipFolder:        c.Bool(""zip""),"
app := cli.NewApp()
"cli.StringFlag{Name: ""ports"", Value: ""9009,9010,9011,9012,9013"", Usage: ""ports of the relay""},"
"Curve:            c.String(""curve""),"
"emptyFoldersToTransferInclude = append(emptyFoldersToTransferInclude, f)"
"if !c.IsSet(""yes"") {"
"RelayPassword:    determinePass(c),"
"cli.BoolFlag{Name: ""no-compress"", Usage: ""disable compression""},"
"if c.String(""out"") != """" {"
"cli.StringFlag{Name: ""relay"", Value: models.DEFAULT_RELAY, Usage: ""address of the relay"", EnvVars: []string{""CROC_RELAY""}},"
"app.Name = ""croc"""
"if !c.IsSet(""relay6"") "
"RelayPorts:       ports,"
if err != nil {
"func (t TabComplete) Do(line []rune, pos int) ([][]rune, int) {"
"func getReceiveConfigFile(requireValidPath bool) (string, error) {"
crocOptions.RelayAddress6 = rememberedOptions.RelayAddress6
"ports := make([]string, transfersParam"
"for _, f := range minimalFileInfosInclude {"
access the shared secret and receive the files instead of the intended
"cli.StringFlag{Name: ""host"", Usage: ""host of the relay""},"
"cli.BoolFlag{Name: ""stdout"", Usage: ""redirect file to stdout""},"
e := os.Remove(fnames[0])
"b, errOpen := os.ReadFile(configFile)"
"cli.StringFlag{Name: ""hash"", Value: ""xxhash"", Usage: ""hash algorithm (xxhash, imohash, md5)""},"
crocOptions.OnlyLocal = rememberedOptions.OnlyLocal
"""github.com/schollz/croc/v10/src/comm"""
"To send and receive, export the CROC_SECRET variable with the code phrase:"
app.HideHelp = false
"if !c.IsSet(""local"") {"
configFile := getSendConfigFile(true)
case 4:
app.UsageText = 
var completionCandidate = s[nbCharacter:]
"RelayAddress:     c.String(""relay""),"
"debugString := ""info"""
      croc send --code secret-code file.txt
"""github.com/schollz/croc/v10/src/mnemonicode"""
"""github.com/schollz/croc/v10/src/utils"""
var phrase []string
"for _, f := range emptyFoldersToTransfer {"
crocOptions.Curve = rememberedOptions.Curve
  Receive: CROC_SECRET=
"if crocOptions.SharedSecret == """" "
      croc send example-folder-name
 err != nil {
"transfersParam := c.Int(""transfers"")"
crocOptions := croc.Options{
"IsSender:         false,"
"MulticastAddress: c.String(""multicast""),"
"IgnoreStdin:      c.Bool(""ignore-stdin""),"
func relay(c 
app.Compiled = time.Now()
fmt.Printf(
"if c.Bool(""classic"") {"
classicInsecureMode := utils.Exists(getClassicConfigFile(true))
"minimalFileInfos, emptyFoldersToTransfer, totalNumberFolders, err := croc.GetFilesInfo(fnames, crocOptions.ZipFolder, crocOptions.GitIgnore, crocOptions.Exclude)"
"minimalFileInfosInclude = append(minimalFileInfosInclude, f)"
   Receive a file using code:
"Overwrite:        c.Bool(""overwrite""),"
 len(rememberedOptions.RelayPorts) > 0 {
if doRemember {
"if (!(runtime.GOOS == ""windows"") "
" rememberedOptions.RelayAddress != """" {"
// save the config
}(port)
ports[i] = strconv.Itoa(portString 
runtime.GOMAXPROCS(runtime.NumCPU())
      croc send file.txt
"crocOptions.SharedSecret = os.Getenv(""CROC_SECRET"")"
"HashAlgorithm:    c.String(""hash""),"
if ((stat.Mode() 
"debugString = ""debug"""
"for _, str := range strs {"
"log.SetLevel(""info"")"
fnames = []string{f.Name()}
// enable classic mode
os.Exit(0)
// load options here
"promptMessage := fmt.Sprintf(""Did you mean to send %s"
"cli.StringFlag{Name: ""relay6"", Value: models.DEFAULT_RELAY6, Usage: ""ipv6 address of the relay"", EnvVars: []string{""CROC_RELAY6""}},"
"saveConfig(c, crocOptions)"
emptyFoldersToTransferInclude := []croc.FileInfo{}
"if c.Bool(""remember"") {"
// update anything that isn't explicitly Globally set
} else {
exclude := false
"phrase = append(phrase, c.Args().Tail()...)"
"_, basename := filepath.Split(fpath)"
"Ask:              c.Bool(""ask""),"
if errOpen == nil 
"SharedSecret:     c.String(""code""),"
for i := range ports {
allStringsAreFiles := func(strs []string) bool {
crocOptions.HashAlgorithm = rememberedOptions.HashAlgorithm
excludeStrings := []string{}
"""time"""
"var words = strings.SplitAfter(string(line), ""-"")"
if len(words) == 1 
Or you can specify the code phrase when you run croc without
"cli.BoolFlag{Name: ""qrcode"", Aliases: []string{""qr""}, Usage: ""show receive code as a qrcode""},"
   Send multiple files:
  Send:    croc send --code 
fmt.Print(
"portParam := c.Int(""port"")"
"if !c.IsSet(""no-local"") {"
"Usage:       ""start your own relay (optional)"","
"for i, port := range ports {"
"} else if !(runtime.GOOS == ""windows"") "
crocOptions.NoPrompt = rememberedOptions.NoPrompt
"return [][]rune{[]rune(""-"")}, nbCharacter"
"return """", err"
} else if crocOptions.RelayAddress6 != models.DEFAULT_RELAY6 {
"Action:      relay,"
 !doRemember {
"excludeStrings = append(excludeStrings, v)"
"err = json.Unmarshal(b, "
var Version string
if len(crocOptions.Exclude) > 0 {
crocOptions.RelayPassword = rememberedOptions.RelayPassword
crocOptions.DisableLocal = rememberedOptions.DisableLocal
break
ports[i] = strconv.Itoa(portParam 
"Prompt:       ""Enter receive code: "","
if i == 0 {
var bConfig []byte
"IP:               c.String(""ip""),"
return err
if portParam == 0 {
 (y/N) 
"""os"""
exclude = true
"Usage:       ""send file(s), or folder (see options with croc send -h)"","
package cli
"OnlyLocal:        c.Bool(""local""),"
 nbCharacter == utils.NbPinNumbers {
      -git to respect your .gitignore
"Version = ""v10.2.1"""
"return errors.New(""must specify file: croc send [filename(s) or folder]"")"
"return path.Join(configFile, ""send.json"")"
portString = 9009
"cli.BoolFlag{Name: ""classic"", Usage: ""toggle between the classic mode (insecure due to local attack vector) and new mode (secure)""},"
if classicInsecureMode {
return app.Run(os.Args)
"SendingText:      c.String(""text"") != """","
"return path.Join(configFile, ""classic_enabled"")"
croc [GLOBAL OPTIONS] [COMMAND] [COMMAND OPTIONS] [filename(s) or folder]
if len(fnames) == 0 {
Do you wish to continue to DISABLE the classic mode
  croc 
"stat, _ := os.Stdin.Stat()"
"cli.IntFlag{Name: ""transfers"", Value: 5, Usage: ""number of ports to use for relay""},"
func Run() (err error) {
"if c.IsSet(""ports"") {"
"fnames = append(fnames, ""'"""
return true
" "")""},"
"cli.StringFlag{Name: ""socks5"", Value: """", Usage: ""add a socks5 proxy"", EnvVars: []string{""SOCKS5_PROXY""}},"
if len(words) <= mnemonicode.WordsRequired(utils.NbBytesWords) {
"log.Infof(""starting croc relay version %v"", Version)"
func send(c 
crocOptions.Overwrite = rememberedOptions.Overwrite
"Stdout:           c.Bool(""stdout""),"
"Exclude:          excludeStrings,"
func getClassicConfigFile(requireValidPath bool) string {
"cli.StringFlag{Name: ""text"", Aliases: []string{""t""}, Usage: ""send some text""},"
"AutoComplete: TabComplete{},"
// touch the file
      croc secret-code
func saveConfig(c 
choice := strings.ToLower(utils.GetInput(promptMessage))
declaring the secret on the command line:
"cli.BoolFlag{Name: ""git"", Usage: ""enable .gitignore respect / don't send ignored files""},"
"To send and receive, use the code phrase:"
Do you wish to continue to enable the classic mode
"pass = c.String(""pass"")"
      croc send file1.txt file2.txt file3.txt
you need to set the environmental variable CROC_SECRET:
cli.Context) (err error) {
"b, err := os.ReadFile(pass)"
cli.Context) error {
.jpg
minimalFileInfosInclude := []croc.FileInfo{}
crocOptions.SharedSecret = c.Args().First()
"return [][]rune{[]rune("""")}, 0"
type TabComplete struct{}
if err != nil 
// print the public IP address
"if err = os.Chdir(c.String(""out""))"
"cli.BoolFlag{Name: ""debug"", Usage: ""toggle debug mode""},"
func receive(c 
// Version specifies the version
"= ""-"""
"""strings"""
crocOptions.SharedSecret = utils.GetRandomName()
"cli.BoolFlag{Name: ""no-local"", Usage: ""disable local relay when sending""},"
   USAGE EXAMPLES:
"ports = strings.Split(c.String(""ports""), "","")"
"cli.StringFlag{Name: ""out"", Value: ""."", Usage: ""specify an output folder to receive the file""},"
" choice == ""y"" "
if e != nil {
err = f.Close()
if transfersString == 0 {
 !classicInsecureMode {
" choice == ""yes"" {"
"comm.Socks5Proxy = c.String(""socks5"")"
"crocOptions.RelayAddress6 = """""
"ports = make([]string, transfersString)"
 doRemember {
if nbCharacter == 0 {
"cli.BoolFlag{Name: ""local"", Usage: ""force to use only local connections""},"
"func getStdin() (fnames []string, err error) {"
var lastPartialWord = words[len(words)-1]
defer func() {
"""github.com/schollz/croc/v10/src/croc"""
"""github.com/schollz/croc/v10/src/tcp"""
return
"cli.BoolFlag{Name: ""ignore-stdin"", Usage: ""ignore piped stdin""},"
      croc send 
func getSendConfigFile(requireValidPath bool) string {
"portString := c.Int(""port"")"
"cli.BoolFlag{Name: ""zip"", Usage: ""zip folder before sending""},"
if crocOptions.RelayAddress != models.DEFAULT_RELAY {
"NoCompress:       c.Bool(""no-compress""),"
"func makeTempFileWithString(s string) (fnames []string, err error) {"
  CROC_SECRET=
"cli.StringFlag{Name: ""curve"", Value: ""p256"", Usage: ""choose an encryption curve ("" "
 croc 
"if Version == """" {"
 i <= transfersParam
"Description: ""send file(s), or folder, over the relay"","
emptyFoldersToTransfer = emptyFoldersToTransferInclude
basename
var strArray [][]rune
folderMap := make(map[string]bool)
"cli.IntFlag{Name: ""transfers"", Value: 4, Usage: ""number of ports to use for transfers""},"
"f, err := os.CreateTemp(""."", ""croc-stdin-"")"
os.Remove(classicFile)
Or you can go back to the classic croc behavior by enabling classic mode:
pass = strings.TrimSpace(string(b))
folderMap[f.FolderRemote] = true
on the host's process list when passed via the command line. On a
"""github.com/schollz/cli/v2"""
"cli.StringFlag{Name: ""pass"", Value: models.DEFAULT_PASSPHRASE, Usage: ""password for the relay"", EnvVars: []string{""CROC_PASS""}},"
"choice := strings.ToLower(utils.GetInput(""""))"
"for _, f := range minimalFileInfos {"
"if strings.HasPrefix(s, lastPartialWord) {"
  Send:    CROC_SECRET=
" !c.Bool(""ignore-stdin"") {"
"log.Debug(""debug mode on"")"
"b, errOpen := os.ReadFile(getSendConfigFile(false))"
" c.IsSet(""code"")) "
"configFile, err := utils.GetConfigDir(requireValidPath)"
transfersString = 4
switch c.Args().Len() {
"cli.BoolFlag{Name: ""testing"", Usage: ""flag for testing purposes""},"
 croc
" crocOptions.SharedSecret != """" "
"""io"""
utils.MarkFileForRemoval(fnames[0])
classicInsecureMode := utils.Exists(classicFile)
"tcpPorts := strings.Join(ports[1:], "","")"
"if strings.Contains(path.Join(strings.ToLower(f.FolderRemote), strings.ToLower(f.Name)), exclusion) {"
"bConfig, err = json.MarshalIndent(crocOptions, """", ""    "")"
"// if the code wasn't set, don't save it"
"doRemember := c.Bool(""remember"")"
import (
// use all of the processors
"fmt.Print("""
case 1:
fnames := []string{}
"} else if c.String(""text"") != """" {"
if err == nil {
"if !c.IsSet(""code"") {"
// classic mode not enabled
to set a code phrase using your environmental variables:
"cli.BoolFlag{Name: ""remember"", Usage: ""save these settings to reuse next time""},"
var fnames []string
"transfersString := c.Int(""transfers"")"
var ports []string
"for _, f := range emptyFoldersToTransferInclude {"
"""fmt"""
// Run will run the command line program
" (Y/n) "", strings.Join(fnames, "", ""))"
"if !c.IsSet(""git"") {"
"HelpName:    ""croc relay"","
"multi-user system, this could allow other local users to access the"
"if choice == """" "
  Enter receive code: 
"host := c.String(""host"")"
"Name:        ""relay"","
"""github.com/chzyer/readline"""
"strArray = append(strArray, []rune(completionCandidate))"
nClassic mode DISABLED.
Disabling this mode will prevent the shared secret from being visible
// generate code phrase
 file.txt
"""runtime"""
return receive(c)
v = strings.ToLower(strings.TrimSpace(v))
// Check if word is indeed a number
"crocOptions.SharedSecret = """""
"_, err := strconv.Atoi(lastPartialWord)"
"cli.StringFlag{Name: ""multicast"", Value: ""239.255.255.250"", Usage: ""multicast address to use for local discovery""},"
" rememberedOptions.RelayPassword != """" {"
continue
"for _, exclusion := range crocOptions.Exclude {"
"comm.HttpProxy = c.String(""connect"")"
"app.Usage = ""easily and securely transfer stuff from one computer to another"""
"multi-user system, this will help ensure that other local users cannot"
if !utils.Exists(str) {
return false
"if v != """" {"
panic(err)
"l, err := readline.NewEx("
"ip, err := utils.PublicIP()"
"return tcp.Run(debugString, host, ports[0], determinePass(c), tcpPorts)"
"crocOptions.RelayAddress = """""
app.EnableBashCompletion = true
"""path/filepath"""
"cli.StringFlag{Name: ""exclude"", Value: """", Usage: ""exclude files if they contain any of the comma separated strings""},"
   Send a file with a custom code:
var rememberedOptions croc.Options
"cr, err := croc.New(crocOptions)"
"return path.Join(configFile, ""receive.json""), nil"
"fnames, err = makeTempFileWithString(c.String(""text""))"
fallthrough
Or you can have the code phrase automatically generated:
"cli.StringFlag{Name: ""connect"", Value: """", Usage: ""add a http proxy"", EnvVars: []string{""HTTP_PROXY""}},"
func determinePass(c 
"ArgsUsage:   ""[filename(s) or folder]"","
"On UNIX systems, to receive with croc you either need "
"cli.StringFlag{Name: ""code"", Aliases: []string{""c""}, Usage: ""codephrase used to connect to relay""},"
"log.Debugf(""public IP address: %s"", ip)"
  croc --classic
"err := tcp.Run(debugString, host, portStr, determinePass(c))"
   Send a file:
"// if trying to send but forgot send, let the user know"
"ShowQrCode:       c.Bool(""qrcode""),"
crocOptions.GitIgnore = rememberedOptions.GitIgnore
"NoMultiplexing:   c.Bool(""no-multi""),"
func setDebugLevel(c 
"// if operating system is UNIX, then use environmental variable to set the code"
if len(crocOptions.SharedSecret) == 0 {
"for _, s := range mnemonicode.WordList {"
Flags: []cli.Flag{
" rememberedOptions.Curve != """" {"
"if !c.IsSet(""relay"") "
"_, err = io.Copy(f, os.Stdin)"
"IsSender:         true,"
app.HideVersion = false
"crocOptions.SharedSecret = strings.Join(phrase, ""-"")"
if !exclude {
Classic mode is currently DISABLED.
readline.Config{
"cli.StringFlag{Name: ""throttleUpload"", Value: """", Usage: ""Throttle the upload speed e.g. 500k""},"
transfersParam = 4
"cli.IntFlag{Name: ""port"", Value: 9009, Usage: ""base port for the relay""},"
"log.Debug(""saving config file"")"
"""'"")"
"if c.Bool(""debug"") {"
// No completion
recipient.
Please note that enabling this mode will make the shared secret visible
// update anything that isn't explicitly set
log.Error(e)
"err = os.WriteFile(configFile, bConfig, 0o644)"
"if !c.IsSet(""curve"") "
"""github.com/schollz/croc/v10/src/models"""
 allStringsAreFiles(c.Args().Slice()) {
"return """""
"bConfig, err := json.MarshalIndent(crocOptions, """", ""    "")"
return send(c)
if c.Args().Present() 
"DisableLocal:     c.Bool(""no-local""),"
"for _, v := range strings.Split(c.String(""exclude""), "","") {"
shared secret and receive the files instead of the intended recipient.
"Name:        ""send"","
totalNumberFolders = 0
"cli.Context, crocOptions croc.Options) {"
"crocOptions.SharedSecret, err = l.Readline()"
go func(portStr string) {
"for _, fpath := range c.Args().Slice() {"
"err = cr.Send(minimalFileInfos, emptyFoldersToTransfer, totalNumberFolders)"
"Description: ""start relay"","
"if choice == ""y"" "
 croc send file.txt
"os.WriteFile(classicFile, []byte(""enabled""), 0o644)"
"if crocOptions.SharedSecret == """" {"
if transfersParam == 0 {
"HelpName: ""croc send"","
for i := 0
cli.Command{
"fnames, err = getStdin()"
minimalFileInfos = minimalFileInfosInclude
"cli.StringFlag{Name: ""ip"", Value: """", Usage: ""set sender ip if known e.g. 10.0.0.1:9009, [::1]:9009""},"
log.Debug(err)
case 3:
"log ""github.com/schollz/logger"""
"RelayAddress6:    c.String(""relay6""),"
"cli.BoolFlag{Name: ""internal-dns"", Usage: ""use a built-in DNS stub resolver rather than the host operating system""},"
"if !c.IsSet(""ports"") "
completionCandidate 
cli.Context) {
"_, err = f.WriteString(s)"
"log.SetLevel(""debug"")"
"if !c.IsSet(""overwrite"") {"
setDebugLevel(c)
"""github.com/schollz/pake/v3"""
rememberedOptions)
"if !c.IsSet(""hash"") {"
  Receive: croc 
 os.ModeCharDevice) == 0) 
cli.Context) (pass string) {
"NoPrompt:         c.Bool(""yes""),"
"TestFlag:         c.Bool(""testing""),"
crocOptions.RelayPorts = rememberedOptions.RelayPorts
   Send everything in a folder:
fnames = c.Args().Slice()
" IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,"
// http://web.archive.org/web/20101031205747/http://www.tothink.com/mnemonic/
" LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,"
const base = 1626
x <<= 8
// is an extra one or two bytes they get an extra one or two words
 The above copyright notice and this permission notice shall be included in
" of this software and associated documentation files (the ""Software""), to deal"
 Copyright (c) 2000  Oren Tirosh <oren@hishome.net>
// There will be WordsRequired(len(src)) words appeneded.
// Every four bytes of input is encoded into three words. If there
// https://github.com/singpolyma/mnemonicode
 THE SOFTWARE.
result = dst
} else {
 i >= 0
= uint32(src[2]) << 16
x = 0
 WordsRequired(len(src))
"copy(result, dst)"
 i-- {
if len(src) == 3 {
" AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER"
// into three words with the last word being one of a small set of very
var x uint32
src = src[4:]
"result = make([]string, len(dst), n)"
if n := len(dst) 
for i := len(src) - 1
// data of length bytes using mnomonic encoding.
// The final wordlist is returned.
 all copies or substantial portions of the Software.
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
" copies of the Software, and to permit persons to whom the Software is"
i = int(x/base) % base
// WordsRequired returns the number of words required to encode input
 cap(dst) < n {
= uint32(src[3]) << 24
" THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR"
 int(x/base/base)%7
= uint32(src[1]) << 8
" Permission is hereby granted, free of charge, to any person obtaining a copy"
// EncodeWordList encodes src into mnemomic words which are appended to dst.
func WordsRequired(length int) int {
return result
"func EncodeWordList(dst []string, src []byte) (result []string) {"
" in the Software without restriction, including without limitation the rights"
return ((length 
x = uint32(src[0])
= uint32(src[i])
"// respectively. If there is an extra three bytes, they will be encoded"
i = base 
" to use, copy, modify, merge, publish, distribute, sublicense, and/or sell"
for len(src) >= 4 {
// short words (only needed to encode the last 3 bits).
i1 := int(x/base) % base
 1) 
// From GitHub version/fork maintained by Stephen Paul Weber available at:
i0 := int(x % base)
" furnished to do so, subject to the following conditions:"
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
package mnemonicode
 3) / 4
i2 := int(x/base/base) % base
i := int(x % base)
"result = append(result, WordList[i])"
if len(src) >= 2 {
if len(src) > 0 {
// Originally from:
"result = append(result, WordList[i0], WordList[i1], WordList[i2])"
"""common"", ""compare"", ""cool"", ""copper"", ""coral"", ""crater"","
"""enjoy"", ""enrico"", ""epoxy"", ""erosion"", ""except"", ""exile"","
"Permission is hereby granted, free of charge, to any person obtaining a copy"
"""betty"", ""between"", ""beyond"", ""billy"", ""bison"", ""blast"","
"of this software and associated documentation files (the ""Software""), to deal"
"""life"", ""light"", ""list"", ""locate"", ""lopez"", ""lorenzo"","
"""august"", ""austria"", ""axiom"", ""aztec"", ""balance"", ""ballad"","
"""cubic"", ""cupid"", ""cycle"", ""depend"", ""door"", ""dream"","
"""village"", ""vincent"", ""violet"", ""violin"", ""virtual"", ""virus"","
"""oscar"", ""oxford"", ""oxygen"", ""ozone"", ""pablo"", ""pacific"","
"""region"", ""remark"", ""rent"", ""reward"", ""rhino"", ""ribbon"","
"""initial"", ""isabel"", ""ivory"", ""jason"", ""jerome"", ""joel"","
"""correct"", ""cosmos"", ""couple"", ""courage"", ""cowboy"", ""craft"","
"""climax"", ""clinic"", ""clock"", ""club"", ""cobra"", ""coconut"","
"""forget"", ""forward"", ""freedom"", ""fresh"", ""friday"", ""fuji"","
"""celtic"", ""chariot"", ""chrome"", ""citrus"", ""civil"", ""cloud"","
"""quiz"", ""quota"", ""race"", ""rachel"", ""raja"", ""ranger"","
"""nice"", ""night"", ""nissan"", ""nitro"", ""nixon"", ""north"","
"for i, w := range WordList {"
"""capitan"", ""capsule"", ""career"", ""cartoon"", ""channel"", ""chapter"","
"""orca"", ""oval"", ""owner"", ""page"", ""paint"", ""palma"","
"""penguin"", ""pepper"", ""percent"", ""perfect"", ""perfume"", ""period"","
"""select"", ""seminar"", ""senator"", ""senior"", ""sensor"", ""serial"","
"""screen"", ""script"", ""second"", ""secret"", ""section"", ""segment"","
"""vampire"", ""vanilla"", ""vatican"", ""velvet"", ""ventura"", ""venus"","
"""chief"", ""china"", ""cigar"", ""cinema"", ""circus"", ""citizen"","
"""mother"", ""mystery"", ""native"", ""nectar"", ""nelson"", ""network"","
"""moses"", ""mouse"", ""nancy"", ""natasha"", ""nebula"", ""nickel"","
"""yellow"", ""young"", ""absent"", ""absorb"", ""accent"", ""alfonso"","
"""miller"", ""mimic"", ""mimosa"", ""mission"", ""monkey"", ""moral"","
all copies or substantial portions of the Software.
"""harvard"", ""havana"", ""hawaii"", ""helena"", ""hello"", ""henry"","
"""tarzan"", ""taxi"", ""telex"", ""tempo"", ""tennis"", ""texas"","
"""cola"", ""collect"", ""colombo"", ""colony"", ""color"", ""combat"","
"""bundle"", ""button"", ""buzzer"", ""byte"", ""caesar"", ""camilla"","
"""mayor"", ""milk"", ""monarch"", ""monday"", ""money"", ""morning"","
"""rabbit"", ""radical"", ""radius"", ""rainbow"", ""ralph"", ""ramirez"","
const longestWord = 7
"""waiter"", ""watch"", ""wave"", ""weather"", ""wedding"", ""wheel"","
"""bank"", ""basil"", ""begin"", ""biscuit"", ""blue"", ""bombay"","
"""panic"", ""paradox"", ""pardon"", ""paris"", ""parker"", ""parking"","
"""bamboo"", ""barbara"", ""basket"", ""bazaar"", ""benefit"", ""bicycle"","
"""zodiac"", ""zoom"", ""abraham"", ""action"", ""address"", ""alabama"","
"""cheese"", ""circle"", ""cobalt"", ""cockpit"", ""college"", ""compass"","
"""battery"", ""belgium"", ""berlin"", ""bermuda"", ""bernard"", ""bikini"","
"""tommy"", ""tower"", ""trivial"", ""tunnel"", ""turtle"", ""twin"","
"""glass"", ""goblin"", ""gopher"", ""grace"", ""gray"", ""gregory"","
"""icon"", ""idea"", ""igloo"", ""igor"", ""image"", ""impact"","
"""cliff"", ""clone"", ""conan"", ""conduct"", ""congo"", ""content"","
"""america"", ""amigo"", ""analog"", ""anatomy"", ""angel"", ""animal"","
"""memo"", ""mental"", ""mentor"", ""menu"", ""mercury"", ""message"","
"""tomato"", ""topic"", ""tornado"", ""toronto"", ""torpedo"", ""total"","
"var wordMap = make(map[string]int, len(WordList))"
"""mobile"", ""model"", ""modem"", ""modern"", ""modular"", ""moment"","
"""aladdin"", ""alarm"", ""alaska"", ""albert"", ""albino"", ""album"","
"""picasso"", ""picnic"", ""picture"", ""pigment"", ""pilgrim"", ""pilot"","
package mnemonicode
"""beach"", ""beast"", ""beatles"", ""beauty"", ""before"", ""benny"","
"""contour"", ""control"", ""convert"", ""copy"", ""corner"", ""corona"","
"""justin"", ""kansas"", ""karl"", ""kevin"", ""kiwi"", ""ladder"","
"const WordListVersion = ""0.7"""
"to use, copy, modify, merge, publish, distribute, sublicense, and/or sell"
"""vocal"", ""vodka"", ""volcano"", ""voltage"", ""volume"", ""voyage"","
"""avenue"", ""average"", ""bagel"", ""baker"", ""ballet"", ""bambino"","
"""subway"", ""sugar"", ""sulfur"", ""summer"", ""survive"", ""sweet"","
// http://web.archive.org/web/20101031205747/http://www.tothink.com/mnemonic/
THE SOFTWARE.
"""academy"", ""acrobat"", ""active"", ""actor"", ""adam"", ""admiral"","
wordMap[w] = i
"""panther"", ""papa"", ""patient"", ""pattern"", ""pedro"", ""pencil"","
"""salute"", ""samba"", ""sandra"", ""santana"", ""sardine"", ""school"","
"""golf"", ""gondola"", ""gong"", ""good"", ""gordon"", ""gorilla"","
"""decade"", ""decimal"", ""deliver"", ""delta"", ""deluxe"", ""demand"","
"""mambo"", ""manager"", ""mango"", ""manila"", ""marco"", ""marina"","
"""roman"", ""rondo"", ""sabrina"", ""salary"", ""salsa"", ""sample"","
"""demo"", ""denmark"", ""derby"", ""design"", ""detect"", ""develop"","
"""fluid"", ""flute"", ""focus"", ""ford"", ""forest"", ""formal"","
"""canoe"", ""cantina"", ""canvas"", ""canyon"", ""capital"", ""caramel"","
"""maestro"", ""magic"", ""magnet"", ""magnum"", ""major"", ""mama"","
"""uncle"", ""unicorn"", ""unique"", ""update"", ""valery"", ""vega"","
"""stock"", ""store"", ""sunday"", ""sunset"", ""support"", ""sweden"","
"""toyota"", ""trade"", ""tribune"", ""trinity"", ""triton"", ""truck"","
"""arcade"", ""aurora"", ""avalon"", ""baby"", ""baggage"", ""balloon"","
"""dolby"", ""domain"", ""domingo"", ""double"", ""drink"", ""driver"","
"""star"", ""storm"", ""story"", ""strange"", ""stretch"", ""stuart"","
"""archer"", ""ariel"", ""armor"", ""arrow"", ""austin"", ""avatar"","
"""cuba"", ""culture"", ""dallas"", ""dance"", ""daniel"", ""david"","
"""reserve"", ""reunion"", ""roof"", ""singer"", ""verbal"", ""amen"","
"""user"", ""value"", ""vendor"", ""venice"", ""verona"", ""vibrate"","
"""jimmy"", ""join"", ""joseph"", ""juice"", ""julius"", ""july"","
"""ultra"", ""uniform"", ""union"", ""uranium"", ""vacuum"", ""valid"","
"""next"", ""nikita"", ""nobel"", ""nobody"", ""nominal"", ""norway"","
"""rufus"", ""sabine"", ""saddle"", ""sailor"", ""saint"", ""salt"","
"""alfred"", ""almond"", ""ammonia"", ""analyze"", ""annual"", ""answer"","
"""satire"", ""scale"", ""scuba"", ""season"", ""secure"", ""shake"","
"""south"", ""speech"", ""spell"", ""spend"", ""spoon"", ""stage"","
"""fidel"", ""fiesta"", ""figure"", ""film"", ""filter"", ""final"","
"""format"", ""formula"", ""fortune"", ""forum"", ""fragile"", ""france"","
"AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER"
"LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,"
"""instant"", ""iris"", ""italian"", ""jacket"", ""jacob"", ""jaguar"","
"""social"", ""soda"", ""solar"", ""solid"", ""solo"", ""sonic"","
"""hippie"", ""hobby"", ""honey"", ""hope"", ""horse"", ""hostel"","
"""bishop"", ""blitz"", ""bonjour"", ""bottle"", ""bridge"", ""british"","
"""magenta"", ""mailbox"", ""manual"", ""marble"", ""mary"", ""maxwell"","
"""frame"", ""freddie"", ""front"", ""fuel"", ""gallop"", ""game"","
"""samuel"", ""saturn"", ""savage"", ""scarlet"", ""scoop"", ""scorpio"","
"""guitar"", ""guru"", ""hand"", ""happy"", ""harbor"", ""harmony"","
"""lake"", ""laura"", ""learn"", ""legacy"", ""legend"", ""lesson"","
"""oberon"", ""octavia"", ""ohio"", ""olga"", ""open"", ""opus"","
"""whiskey"", ""wisdom"", ""deal"", ""null"", ""nurse"", ""quebec"","
"""plate"", ""plato"", ""plume"", ""pogo"", ""point"", ""polite"","
"""yes"","
"""diet"", ""digital"", ""dilemma"", ""diploma"", ""direct"", ""disco"","
"""silver"", ""similar"", ""simon"", ""single"", ""siren"", ""slogan"","
"""comedy"", ""comet"", ""command"", ""compact"", ""company"", ""complex"","
"""axis"", ""baboon"", ""bahama"", ""bali"", ""balsa"", ""bazooka"","
"""olivia"", ""olympic"", ""omega"", ""opera"", ""optic"", ""optimal"","
"""laptop"", ""laser"", ""latin"", ""lava"", ""lecture"", ""left"","
"""george"", ""giant"", ""gilbert"", ""gossip"", ""gram"", ""greek"","
"""spain"", ""spark"", ""split"", ""spray"", ""square"", ""stadium"","
"""ship"", ""shoe"", ""sigma"", ""sister"", ""sleep"", ""smile"","
"""museum"", ""music"", ""mustang"", ""natural"", ""neon"", ""nepal"","
"""alamo"", ""alert"", ""almanac"", ""aloha"", ""andrea"", ""anita"","
// From GitHub version/fork maintained by Stephen Paul Weber available at:
"""kimono"", ""kinetic"", ""leonid"", ""lima"", ""maze"", ""medusa"","
"""version"", ""voodoo"", ""warning"", ""william"", ""wonder"", ""year"","
"""soviet"", ""special"", ""speed"", ""spiral"", ""spirit"", ""sport"","
"""textile"", ""theory"", ""thermos"", ""tiger"", ""titanic"", ""tokyo"","
"""plastic"", ""plaza"", ""pocket"", ""poem"", ""poetic"", ""poker"","
"""hamlet"", ""harlem"", ""helium"", ""holiday"", ""house"", ""hunter"","
"""brain"", ""brenda"", ""brigade"", ""cable"", ""carmen"", ""cello"","
"""neptune"", ""nerve"", ""neutral"", ""nevada"", ""news"", ""ninja"","
"""ibiza"", ""iceberg"", ""imagine"", ""infant"", ""isotope"", ""jackson"","
// Originally from:
"""scratch"", ""scroll"", ""sector"", ""serpent"", ""shadow"", ""shampoo"","
"""temple"", ""tibet"", ""ticket"", ""tina"", ""today"", ""toga"","
"""retro"", ""richard"", ""right"", ""risk"", ""river"", ""roger"","
"""bless"", ""bogart"", ""bonanza"", ""book"", ""border"", ""brave"","
"""simple"", ""slang"", ""smart"", ""smoke"", ""snake"", ""society"","
"""swing"", ""tape"", ""think"", ""thomas"", ""tictac"", ""time"","
"""option"", ""order"", ""outside"", ""package"", ""pancake"", ""pandora"","
"""cecilia"", ""cement"", ""center"", ""century"", ""ceramic"", ""chamber"","
"""proton"", ""public"", ""pulse"", ""puma"", ""pyramid"", ""queen"","
"""brother"", ""brush"", ""budget"", ""cabaret"", ""cadet"", ""candle"","
"""jamaica"", ""jasmine"", ""java"", ""jessica"", ""judo"", ""kitchen"","
"""invest"", ""invite"", ""iron"", ""ivan"", ""james"", ""jester"","
// WordListVersion is the version of compiled in word list.
"""toast"", ""tobacco"", ""tonight"", ""torch"", ""torso"", ""touch"","
"""janet"", ""japan"", ""jargon"", ""jazz"", ""jeep"", ""john"","
"""galileo"", ""garcia"", ""genesis"", ""gold"", ""gravity"", ""habitat"","
"""arizona"", ""arnold"", ""aroma"", ""arthur"", ""artist"", ""asia"","
"""cabinet"", ""cactus"", ""cafe"", ""cairo"", ""cake"", ""calypso"","
"""hair"", ""halt"", ""harris"", ""heart"", ""heavy"", ""herman"","
Copyright (c) 2000  Oren Tirosh <oren@hishome.net>
"""chance"", ""change"", ""chaos"", ""charlie"", ""charm"", ""charter"","
"""private"", ""product"", ""profile"", ""program"", ""project"", ""protect"","
"""travel"", ""tribal"", ""trick"", ""trident"", ""trilogy"", ""tripod"","
"""finance"", ""finish"", ""finland"", ""flash"", ""florida"", ""flower"","
"""jupiter"", ""karate"", ""karma"", ""kayak"", ""kermit"", ""kilo"","
"""ravioli"", ""raymond"", ""respect"", ""respond"", ""result"", ""resume"","
"""ego"", ""fax"", ""jet"", ""job"", ""rio"", ""ski"","
"furnished to do so, subject to the following conditions:"
"""chef"", ""chemist"", ""cherry"", ""chess"", ""chicago"", ""chicken"","
"""premium"", ""present"", ""price"", ""prince"", ""printer"", ""prism"","
"""garbo"", ""gate"", ""gibson"", ""ginger"", ""giraffe"", ""gizmo"","
"""nylon"", ""oasis"", ""object"", ""observe"", ""ocean"", ""octopus"","
"""legal"", ""lemon"", ""level"", ""lexicon"", ""liberal"", ""libra"","
"""alpha"", ""alpine"", ""amadeus"", ""amanda"", ""amazon"", ""amber"","
"""europe"", ""everest"", ""evident"", ""exact"", ""example"", ""exit"","
"""grille"", ""hammer"", ""harvest"", ""hazard"", ""heaven"", ""herbert"","
"""explore"", ""extreme"", ""ferrari"", ""first"", ""flag"", ""folio"","
"""repair"", ""reply"", ""rival"", ""riviera"", ""robin"", ""rose"","
"""bronze"", ""brown"", ""bruce"", ""bruno"", ""burger"", ""burma"","
"""swim"", ""table"", ""taboo"", ""target"", ""teacher"", ""telecom"","
"""costume"", ""cotton"", ""cover"", ""crack"", ""current"", ""danube"","
"""nato"", ""navy"", ""needle"", ""neuron"", ""never"", ""newton"","
"""joker"", ""jordan"", ""jumbo"", ""june"", ""jungle"", ""junior"","
"""monaco"", ""monica"", ""monitor"", ""mono"", ""monster"", ""montana"","
"""polaris"", ""police"", ""politic"", ""polo"", ""polygon"", ""pony"","
"""mask"", ""match"", ""mayday"", ""meaning"", ""mercy"", ""middle"","
"""polka"", ""poncho"", ""powder"", ""prague"", ""press"", ""presto"","
"""shallow"", ""shannon"", ""shave"", ""shelf"", ""sherman"", ""shine"","
"""grid"", ""griffin"", ""ground"", ""guest"", ""gustav"", ""gyro"","
"""morgan"", ""motel"", ""motif"", ""motor"", ""mozart"", ""multi"","
"""import"", ""index"", ""india"", ""indigo"", ""input"", ""insect"","
"""lunar"", ""machine"", ""macro"", ""madam"", ""madonna"", ""madrid"","
"""event"", ""evita"", ""exodus"", ""extend"", ""famous"", ""farmer"","
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
"""orange"", ""orbit"", ""organic"", ""orient"", ""origin"", ""orlando"","
"""boris"", ""boston"", ""boxer"", ""brandy"", ""bravo"", ""brazil"","
"""edward"", ""effect"", ""electra"", ""emerald"", ""emotion"", ""empire"","
func init() {
"""disney"", ""distant"", ""doctor"", ""dollar"", ""dominic"", ""domino"","
"""minute"", ""miracle"", ""mirage"", ""miranda"", ""mister"", ""mixer"","
"""static"", ""station"", ""status"", ""stereo"", ""stone"", ""stop"","
"""sultan"", ""super"", ""susan"", ""sushi"", ""suzuki"", ""switch"","
"""degree"", ""delete"", ""delphi"", ""denver"", ""desert"", ""divide"","
"""eagle"", ""earth"", ""echo"", ""eclipse"", ""editor"", ""educate"","
"""king"", ""koala"", ""korea"", ""labor"", ""lady"", ""lagoon"","
"""radar"", ""radio"", ""random"", ""rapid"", ""rebel"", ""record"","
"""perform"", ""phoenix"", ""phrase"", ""pierre"", ""pinball"", ""place"","
"""trust"", ""type"", ""under"", ""unit"", ""urban"", ""urgent"","
"""antenna"", ""antonio"", ""apollo"", ""april"", ""archive"", ""arctic"","
"""virgo"", ""visible"", ""vista"", ""vital"", ""voice"", ""vortex"","
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,"
"""grand"", ""granite"", ""graph"", ""green"", ""group"", ""guide"","
"""data"", ""decide"", ""desire"", ""detail"", ""dexter"", ""dinner"","
"""float"", ""flood"", ""floor"", ""forbid"", ""forever"", ""fractal"","
"""popcorn"", ""popular"", ""postage"", ""postal"", ""precise"", ""prefix"","
"""concept"", ""concert"", ""connect"", ""consul"", ""contact"", ""context"","
"""sonar"", ""sonata"", ""soprano"", ""source"", ""sparta"", ""sphere"","
"""spider"", ""sponsor"", ""spring"", ""acid"", ""adios"", ""agatha"","
"""aspect"", ""aspirin"", ""athena"", ""athlete"", ""atlas"", ""audio"","
"""pagoda"", ""palace"", ""pamela"", ""panama"", ""panda"", ""panel"","
"""binary"", ""bingo"", ""biology"", ""block"", ""blonde"", ""bonus"","
"""falcon"", ""family"", ""fantasy"", ""fashion"", ""fiber"", ""fiction"","
"""choice"", ""chris"", ""cipher"", ""clarion"", ""clark"", ""clever"","
"""water"", ""weekend"", ""welcome"", ""western"", ""window"", ""winter"","
"""alias"", ""ambient"", ""andy"", ""anvil"", ""appear"", ""apropos"","
"""city"", ""clara"", ""classic"", ""claudia"", ""clean"", ""client"","
"""stamp"", ""stand"", ""state"", ""stella"", ""stick"", ""sting"","
"""liter"", ""little"", ""llama"", ""lobby"", ""lobster"", ""local"","
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
"THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR"
"""report"", ""reptile"", ""reverse"", ""ricardo"", ""ringo"", ""ritual"","
"""nirvana"", ""normal"", ""nova"", ""novel"", ""nuclear"", ""numeric"","
"""miami"", ""micro"", ""million"", ""mineral"", ""minimum"", ""minus"","
"""donald"", ""dragon"", ""drama"", ""dublin"", ""duet"", ""dynamic"","
"""pirate"", ""pixel"", ""pizza"", ""planet"", ""plasma"", ""plaster"","
"""canary"", ""candid"", ""carrot"", ""cave"", ""chant"", ""child"","
"""explain"", ""fame"", ""fast"", ""father"", ""felix"", ""field"","
"copies of the Software, and to permit persons to whom the Software is"
"""apple"", ""arena"", ""armada"", ""arsenal"", ""atlanta"", ""atomic"","
"""joshua"", ""journal"", ""judge"", ""juliet"", ""jump"", ""justice"","
"""hilton"", ""history"", ""horizon"", ""hotel"", ""human"", ""humor"","
"""yogurt"", ""yoyo"", ""zebra"", ""zero"", ""zigzag"", ""zipper"","
"""parade"", ""parent"", ""parole"", ""paul"", ""peace"", ""pearl"","
"""general"", ""genetic"", ""genius"", ""germany"", ""global"", ""gloria"","
// https://github.com/singpolyma/mnemonicode
"""member"", ""memphis"", ""michael"", ""miguel"", ""milan"", ""mile"","
"""people"", ""phantom"", ""philips"", ""pioneer"", ""pluto"", ""podium"","
"""frank"", ""friend"", ""frozen"", ""future"", ""gabriel"", ""galaxy"","
var WordList = []string{
"""market"", ""mars"", ""martin"", ""marvin"", ""master"", ""matrix"","
"""metal"", ""meteor"", ""meter"", ""method"", ""metro"", ""mexico"","
"""lazarus"", ""letter"", ""license"", ""lithium"", ""loyal"", ""lucky"","
"""orion"", ""othello"", ""paper"", ""paprika"", ""prelude"", ""prepare"","
"""adrian"", ""africa"", ""agenda"", ""agent"", ""airline"", ""airport"","
"""symbol"", ""system"", ""tactic"", ""tahiti"", ""talent"", ""tango"","
"""pretend"", ""profit"", ""promise"", ""provide"", ""puzzle"", ""remote"","
"""dispute"", ""donor"", ""druid"", ""drum"", ""easy"", ""eddie"","
"""pretty"", ""prime"", ""promo"", ""quasi"", ""quest"", ""quick"","
"""bread"", ""break"", ""broken"", ""bucket"", ""buenos"", ""buffalo"","
"""sharon"", ""sharp"", ""short"", ""shrink"", ""silence"", ""silk"","
"""cartel"", ""casino"", ""castle"", ""castro"", ""catalog"", ""caviar"","
"""service"", ""sheriff"", ""shock"", ""sierra"", ""signal"", ""silicon"","
"""totem"", ""tourist"", ""tractor"", ""traffic"", ""transit"", ""trapeze"","
"""banana"", ""bandit"", ""banjo"", ""barcode"", ""baron"", ""basic"","
"""limbo"", ""limit"", ""linda"", ""linear"", ""lion"", ""liquid"","
"""rover"", ""rudolf"", ""saga"", ""sahara"", ""scholar"", ""shelter"","
"""elegant"", ""element"", ""elite"", ""elvis"", ""email"", ""energy"","
"""parody"", ""partner"", ""passage"", ""passive"", ""pasta"", ""pastel"","
"""exotic"", ""export"", ""express"", ""extra"", ""fabric"", ""factor"","
"""visa"", ""vision"", ""visitor"", ""visual"", ""vitamin"", ""viva"","
"""wizard"", ""wolf"", ""world"", ""xray"", ""yankee"", ""yoga"","
"""caravan"", ""carbon"", ""cargo"", ""carlo"", ""carol"", ""carpet"","
"""street"", ""strong"", ""student"", ""studio"", ""style"", ""subject"","
"""east"", ""ecology"", ""economy"", ""edgar"", ""egypt"", ""elastic"","
"""nina"", ""noise"", ""orchid"", ""oregano"", ""origami"", ""orinoco"","
"""fiona"", ""fire"", ""fish"", ""flame"", ""flex"", ""flipper"","
"""robert"", ""robot"", ""rocket"", ""rodeo"", ""romeo"", ""royal"","
"""pump"", ""pupil"", ""python"", ""quality"", ""quarter"", ""quiet"","
"""food"", ""fossil"", ""frog"", ""fruit"", ""geneva"", ""gentle"","
"""nothing"", ""number"", ""october"", ""office"", ""oliver"", ""opinion"","
"""shirt"", ""side"", ""sinatra"", ""sincere"", ""size"", ""slalom"","
"""engine"", ""english"", ""episode"", ""equator"", ""escort"", ""ethnic"","
"""logic"", ""logo"", ""lola"", ""london"", ""lotus"", ""lucas"","
"""maximum"", ""media"", ""medical"", ""mega"", ""melody"", ""melon"","
"""crash"", ""credit"", ""cricket"", ""critic"", ""crown"", ""crystal"","
The above copyright notice and this permission notice shall be included in
"""permit"", ""person"", ""peru"", ""phone"", ""photo"", ""piano"","
"""tropic"", ""trumpet"", ""tulip"", ""tuna"", ""turbo"", ""twist"","
"""comrade"", ""condor"", ""crimson"", ""cyclone"", ""darwin"", ""declare"","
"""portal"", ""potato"", ""prize"", ""process"", ""protein"", ""proxy"","
"""hydro"", ""imitate"", ""info"", ""ingrid"", ""inside"", ""invent"","
"""mike"", ""mirror"", ""modest"", ""morph"", ""morris"", ""nadia"","
"in the Software without restriction, including without limitation the rights"
"""love"", ""lunch"", ""malta"", ""mammal"", ""margo"", ""marion"","
"""rider"", ""road"", ""rodent"", ""round"", ""rubber"", ""ruby"","
"""diagram"", ""dialog"", ""diamond"", ""diana"", ""diego"", ""diesel"","
"""dynasty"", ""edison"", ""edition"", ""enigma"", ""equal"", ""eric"","
"""camel"", ""camera"", ""campus"", ""canada"", ""canal"", ""cannon"","
"""russian"", ""safari"", ""salad"", ""salami"", ""salmon"", ""salon"","
"""slow"", ""small"", ""snow"", ""sofia"", ""song"", ""sound"","
"""empty"", ""escape"", ""eternal"", ""evening"", ""exhibit"", ""expand"","
"""patent"", ""patriot"", ""patrol"", ""patron"", ""pegasus"", ""pelican"","
"""heroic"", ""hexagon"", ""husband"", ""immune"", ""inca"", ""inch"","
"""alcohol"", ""alex"", ""algebra"", ""alibi"", ""alice"", ""alien"","
"""recycle"", ""reflex"", ""reform"", ""regard"", ""regular"", ""relax"","
"""vertigo"", ""veteran"", ""victor"", ""video"", ""vienna"", ""viking"","
"""gallery"", ""gamma"", ""garage"", ""garden"", ""garlic"", ""gemini"","
"CompressWithOption(data, 9)"
"The frog sighed in frustration and sat to sulk in the rushes. Suddenly, he spotted two big eyes staring at him from the water. The giant log-shaped animal opened its mouth and asked him, ""What are you doing, Frog"
"The crocodile flopped his tail into the marshy mud and let the frog climb on, then he waddled out to the river. But he couldn't stick his tail into the water as a rudder because the frog was on it -- and if he put his tail in the water, the snakes would eat the frog. They clumsily floated downstream for a ways, until the crocodile said, ""Hop onto my back so I can steer straight with my tail."" The frog moved, and the journey smoothed out."
"""Oh no, I don't think so,"" Frog answered quickly. ""You'd eat me on the way over, or go underwater so the snakes could get me!"""
"The only thing that separated him from dry land was a swampy, muddy, swiftly flowing river. But the river was home to all sorts of slippery, slittering snakes that loved nothing better than a good, plump frog for dinner, so Frog didn't dare try to swim across."
"The frog considered his offer. He did want to get to dry ground very badly, and there didn't seem to be any other way across the river. He looked at the crocodile from his short, squat buggy eyes and wondered about the crocodile's motives. But if he rode on the tail, the croc couldn't eat him anyway. And he was right about the snakes--no self-respecting crocodile would give a meal to the snakes."
"data := make([]byte, 1000000)"
testing.T) {
testing.B) {
The Frog and the Crocodile
"From where he was sitting, the frog couldn't see much except the back of Crocodile's head. ""Why don't you hop up on my head so you can see everything around us"
compressedB = Compress(fable)
"n"", dataRateSavings)"
var fable = []byte(
"""Now why would I let the snakes get you"
import (
"compressedB = CompressWithOption(data, 9)"
b.Fatal(err)
"""crypto/rand"""
"CompressWithOption(fable, -2)"
"""github.com/stretchr/testify/assert"""
 (1.0 - float64(len(compressedB))/float64(len(fable)))
""" Crocodile invited. "
"fmt.Printf(""random, Level -2: %2.0f%% percent space savings"
dataRateSavings := 100 
t.Fatal(err)
"The snakes hissed and jeered at him, daring him to come closer, but he refused. Occasionally they would slither closer, jaws open to attack, but the frog always leaped out of the way. But no matter how far upstream he searched or how far downstream, the frog wasn't able to find a way across the water."
func BenchmarkCompressLevelMinusTwo(b 
"CompressWithOption(data, -2)"
"The crocodile harrumphed in agreement and sat, thinking, for a while. ""Well, if you're afraid of the snakes, I could give you a ride across,"" he suggested."
"compressedB := CompressWithOption(fable, 9)"
package compress
"""Okay, it sounds like a good plan to me. Turn around so I can hop on your tail."""
"fmt.Printf(""random, Level 9: %2.0f%% percent space savings"
func BenchmarkCompressLevelMinusTwoBinary(b 
" Surely there are enough flies right there for a meal."""
"fmt.Printf(""Level -2: %2.0f%% percent space savings"
"So for many days, the frog stayed put, hopping along the bank, trying to think of a way to get across."
"Once, there was a frog who lived in the middle of a swamp. His entire family had lived in that swamp for generations, but this particular frog decided that he had had quite enough wetness to last him a lifetime. He decided that he was going to find a dry place to live instead."
"assert.Equal(t, fable, Decompress(compressedB))"
"""testing"""
for i := 0
"compressedB = CompressWithOption(fable, -2)"
"data := make([]byte, 4096)"
"CompressWithOption(fable, 9)"
"compressedB = CompressWithOption(data, -2)"
 i < b.N
 err != nil {
"""fmt"""
func BenchmarkCompressLevelNineBinary(b 
" I think they're a terrible nuisance with all their hissing and slithering! The river would be much better off without them altogether! Anyway, if you're so worried that I might eat you, you can ride on my tail."""
func TestCompress(t 
"assert.True(t, len(compressedB) < len(fable))"
 (1.0 - float64(len(compressedB))/float64(len(data)))
"He had felt certain that there would be a bridge, or a place where the banks came together, yet all he found was more reeds and water. After a while, even the snakes stopped teasing him and went off in search of easier prey."
dataRateSavings = 100 
"fmt.Printf(""Level 9: %2.0f%% percent space savings"
func BenchmarkCompressLevelNine(b 
"The frog croaked in surprise and leaped away from the crocodile. That creature could swallow him whole in a moment without thinking about it! Once he was a satisfied that he was a safe distance away, he answered. ""I'm tired of living in swampy waters, and I want to travel to the other side of the river. But if I swim across, the snakes will eat me."""
"if _, err := rand.Read(data)"
"log ""github.com/schollz/logger"""
"log.Debugf(""error level data: %v"", err)"
return deCompressedData.Bytes()
decompressor := flate.NewReader(src)
import (
"compress(src, compressedData, -2)"
"log.Debugf(""error writing data: %v"", err)"
decompressor.Close()
// Compress returns a compressed byte slice.
"decompress(compressedData, deCompressedData)"
"if _, err := io.Copy(dest, decompressor)"
"compress(src, compressedData, level)"
return
// compress uses flate to decompress an io.Reader
// compress uses flate to compress a byte slice to a corresponding level
compressedData := new(bytes.Buffer)
compressor.Close()
func Decompress(src []byte) []byte {
"log.Debugf(""error copying data: %v"", err)"
"func compress(src []byte, dest io.Writer, level int) {"
deCompressedData := new(bytes.Buffer)
package compress
"func decompress(src io.Reader, dest io.Writer) {"
 err != nil {
// Decompress returns a decompressed byte slice.
// CompressWithOption returns compressed data using the specified level
func Compress(src []byte) []byte {
compressedData := bytes.NewBuffer(src)
"if _, err := compressor.Write(src)"
if err != nil {
"func CompressWithOption(src []byte, level int) []byte {"
"""bytes"""
"compressor, err := flate.NewWriter(dest, level)"
"""compress/flate"""
return compressedData.Bytes()
"""io"""
"connection, err = dialer.Dial(""tcp"", address)"
"log.Debugf(""connected to '%s'"", address)"
log.Debug(err.Error())
"if Socks5Proxy != """" "
"socks5ProxyURL, urlParseError := url.Parse(Socks5Proxy)"
"header := make([]byte, 4)"
"_, err = io.ReadFull(c.connection, buf)"
"if !strings.Contains(Socks5Proxy, "
// read until we get 4 bytes for the header
// Send a message
} else {
"log.Debugf(""dialing to %s with timelimit %s"", address, tlimit)"
return
"log.Debugf(""consecutive read error: %v"", err)"
// New returns a new comm
 Socks5Proxy
"""time"""
"log.Warnf(""error setting overall deadline: %v"", err)"
"b, _, _, err = c.Read()"
"err = fmt.Errorf(""binary.Read failed: %w"", err)"
// read until we get 4 bytes for the magic
rbuf := bytes.NewReader(header)
"Comm) Read() (buf []byte, numBytes int, bs []byte, err error) {"
"err = fmt.Errorf(""proxy failed: %w"", err)"
// Receive a message
// Comm is some basic TCP communication
if err := c.SetWriteDeadline(time.Now().Add(3 
 time.Hour))
"var Socks5Proxy = """""
Comm) Connection() net.Conn {
package comm
"fmt.Println(""binary.Write failed:"", err)"
tlimit = timelimit[0]
"_, err = io.ReadFull(c.connection, header)"
header := new(bytes.Buffer)
http://
"log.Debug(""dialing with dialer.Dial"")"
Socks5Proxy = 
comm := new(Comm)
"n, err = c.connection.Write(tmpCopy)"
var dialer proxy.Dialer
"func NewConnection(address string, timelimit ...time.Duration) (c "
c = New(connection)
"""github.com/magisterquis/connectproxy"""
var numBytesUint32 uint32
"var MAGIC_BYTES = []byte(""croc"")"
// prepend schema if no schema is given
// Connection returns the net.Conn connection
if err != nil {
Comm {
"""bytes"""
"err = fmt.Errorf(""comm.NewConnection failed: %w"", err)"
func New(c net.Conn) 
if err := c.SetReadDeadline(time.Now().Add(3 
"err = fmt.Errorf(""unable to parse http proxy url: %s"", urlParseError)"
"""io"""
"connection, err = net.DialTimeout(""tcp"", address, tlimit)"
// Close closes the connection
"log.Warnf(""error closing connection: %v"", err)"
// long read deadline in case waiting for file
if n != len(tmpCopy) {
import (
"tmpCopy := append(header.Bytes(), b...)"
HttpProxy = 
"log.Debugf(""initial read error: %v"", err)"
Comm) Close() {
// NewConnection gets a new comm to a tcp address
return c.connection
if err = c.connection.SetReadDeadline(time.Now().Add(10 
"""github.com/schollz/croc/v10/src/utils"""
"} else if HttpProxy != """" "
"Comm) Write(b []byte) (n int, err error) {"
// shorten the reading deadline in case getting weird data
connection net.Conn
"HttpProxyURL, urlParseError := url.Parse(HttpProxy)"
"tmpCopy = append(MAGIC_BYTES, tmpCopy...)"
// must clear the timeout setting
"""encoding/binary"""
"dialer, err = proxy.FromURL(socks5ProxyURL, proxy.Direct)"
"err = binary.Write(header, binary.LittleEndian, uint32(len(b)))"
 HttpProxy
 err != nil {
"buf = make([]byte, numBytes)"
"""fmt"""
"err = fmt.Errorf(""unable to parse socks proxy url: %s"", urlParseError)"
"Comm) Receive() (b []byte, err error) {"
"var HttpProxy = """""
"err = binary.Read(rbuf, binary.LittleEndian, "
"log.Warnf(""error setting read deadline: %v"", err)"
if len(timelimit) > 0 {
"log.Errorf(""error setting write deadline: %v"", err)"
"err = fmt.Errorf(""wanted to write %d but wrote %d"", len(b), n)"
if err = c.connection.SetReadDeadline(time.Now().Add(3 
defer c.connection.SetDeadline(time.Time{})
"if !bytes.Equal(header, MAGIC_BYTES) {"
log.Debug(err)
 time.Second))
if err := c.connection.Close()
"log ""github.com/schollz/logger"""
numBytesUint32)
if err := c.SetDeadline(time.Now().Add(3 
 time.Second
"err = fmt.Errorf(""connection.Write failed: %w"", err)"
tlimit := 30 
 !utils.IsLocalIP(address) {
Comm) Send(message []byte) (err error) {
"""net"""
"_, err = c.Write(message)"
"header = make([]byte, 4)"
func (c 
comm.connection = c
"Comm, err error) {"
var connection net.Conn
"""strings"""
"err = fmt.Errorf(""initial bytes are not magic: %x"", header)"
"""net/url"""
if urlParseError != nil {
type Comm struct {
"if !strings.Contains(HttpProxy, "
numBytes = int(numBytesUint32)
return comm
"""golang.org/x/net/proxy"""
"dialer, err = connectproxy.New(HttpProxyURL, proxy.Direct)"
socks5://
x00'}))
"log ""github.com/schollz/logger"""
testing.T) {
time.Minute)
"assert.NotNil(t, a.Send(token))"
log.Error(err)
"port, 10"
package comm
_ = a.Connection()
"err = c.Send([]byte(""hello, world""))"
"assert.Nil(t, err)"
port)
for {
import (
 time.Millisecond)
"""crypto/rand"""
"assert.NotNil(t, err)"
"""net"""
"""github.com/stretchr/testify/assert"""
"connection, err := server.Accept()"
time.Sleep(300 
a.Close()
"data, err = c.Receive()"
t.Error(err)
"log.Debugf(""starting TCP server on "" "
"server, err := net.Listen(""tcp"", ""0.0.0.0:"""
"}(port, connection)"
"assert.Nil(t, a.Send([]byte{'"
"go func(_ string, connection net.Conn) {"
"assert.Nil(t, a.Send([]byte(""hello, computer"")))"
"token := make([]byte, 3000)"
defer server.Close()
"data, err := c.Receive()"
"assert.Equal(t, []byte(""hello, computer""), data)"
 port)
func TestComm(t 
"""time"""
go func() {
"assert.Equal(t, token, data)"
"assert.Equal(t, []byte{'"
"""testing"""
"assert.Nil(t, a.Send(token))"
"data, err := a.Receive()"
 err != nil {
"port := ""8001"""
"a, err := NewConnection(""127.0.0.1:"""
c := New(connection)
"assert.Equal(t, []byte(""hello, world""), data)"
"if _, err := rand.Read(token)"
if err != nil {
// spawn a new goroutine whenever a client connects
"log.Debugf(""client %s connected"", connection.RemoteAddr().String())"
"x00'}, data)"
"_, err = a.Write(token)"
