		// But the position will actually be correct until we move, so"
		// For z/OS, the length of the name is a field"
		// So, if we are stopping at the end of a line, we"
		// This is not technically the Linux semantics for"
		// if len(flag.NoOptDefVal) == 0 {"
	//  darwin:"
	//  linux:"
	// However, the value of px_proto_oe is 0, so we can use"
	// If nil, EINVAL will be returned when the structure is used."
	// PersistentPreRun: children of this command will inherit and execute."
	// When doing completion of a flag name, as soon as an argument starts with"
	// position specifies the offset within the extended attribute. In the"
"//		Addr:    [6]byte{0x11, 0x22, 0x33, 0xaa, 0xbb, 0xcc}, // CC:BB:AA:33:22:11"
"//		Addr:    [6]uint8{0, 0, 0, 0, 0, 0}, // BDADDR_ANY or 00:00:00:00:00:00"
"//		Channel: 1,"
"//	    io.WriteString(hash, ""Hello, world."")"
"//	    n, err := f.Read(b)"
"//	    unix.Sendto(hashfd, b[:n], unix.MSG_MORE, addr)"
"//	Bind(fd, addr)"
"//	Gethostuuid(uuid *byte, timeout *Timespec) (err error)"
"//	Ptrace(req int, pid int, addr uintptr, data int) (ret uintptr, err error)"
"//	Read(fd, frame)"
"//	Read(nfd, buf)"
"//	Write(fd, []byte(`hello`))"
"//	_ = Connect(fd, &SockaddrRFCOMM{"
"//	_ = Listen(fd, 1)"
"//	_ = unix.Bind(fd, &unix.SockaddrRFCOMM{"
"//	addr := &unix.SockaddrALG{Type: ""hash"", Name: ""sha1""}"
"//	b := make([]byte, 20)"
"//	b := make([]byte, 4096)"
"//	defer term.Restore(int(os.Stdin.Fd()), oldState)"
"//	f, _ := os.Open(""/tmp/linux-4.10-rc7.tar.xz"")"
"//	fd, _ := Socket(AF_CAN, SOCK_RAW, CAN_RAW)"
"//	fd, _ := unix.Socket(unix.AF_ALG, unix.SOCK_SEQPACKET, 0)"
"//	fmt.Printf(""conn addr=%v fd=%d"", sa.(*unix.SockaddrRFCOMM).Addr, nfd)"
"//	frame := make([]byte, 16)"
"//	hash := os.NewFile(hashfd, ""sha1"")"
"//	hashfd, _, _ := unix.Syscall(unix.SYS_ACCEPT, uintptr(fd), 0, 0)"
"//	nfd, sa, _ := Accept(fd)"
"//	unix.Bind(fd, addr)"
"//
"// 	// Flag requires a value, so it can be suffixed with ="
"// 	completions = append(completions, fmt.Sprintf(""%s\t%s"", flagName, flag.Usage))"
"// 	flagName += ""="""
"//          const char *name,"
"//          const char *path,"
"//          const void *value,"
"//          size_t size,"
"//          u_int32_t position,"
"//          void *value,"
"//       optional, they are enclosed in brackets ([ ])."
"//     followed by double quote ("");"
"//    return []string{""themes""}, ShellCompDirectiveFilterDirs"
"//    return []string{""yaml"", ""json""}, ShellCompDirectiveFilterFileExt"
"//    return nil, ShellCompDirectiveFilterDirs"
"//   - Uint32/SetUint32: ifindex, metric, mtu"
"//   - every back slash (\) is doubled, but only if immediately"
"//   - every double quote ("") is escaped by back slash (\);"
"//   - finally, s is wrapped with double quotes (arg -> ""arg""),"
"//   --ss=""v1,v2"" --ss=""v3"""
"//   []string{""v1"", ""v2"", ""v3""}"
"//  - *TIPCServiceName: ""name"" variant in the C addr union"
"//  - *TIPCServiceRange: ""nameseq"" variant in the C addr union"
"//  - *TIPCSocketAddr: ""id"" variant in the C addr union"
"//  err := db.QueryRow(""SELECT name FROM foo WHERE id=?"", id).Scan(&u)"
"//  hit by a meteorite is estimated to be one chance in 17 billion, that"
"// """""
"// ""(unreachable)"" prefix, which can potentially be a valid relative"
"// ""*"""
"// ""+1"" means that no specific value was passed, so increment"
"// ""--"" terminates the flags"
"// ""--getUrl"" which may also be translated to ""geturl"" and everything will work."
"// ""> "")."
"// "">= 1.0""."
"// ""Abstract"" Unix domain socket."
"// ""Windows 7, Windows Server 2008 R2, Windows Vista, and Windows"
"// ""continued"" status is 0xFFFF, distinguishing itself"
"// ""key_or_keyring:<key>"", and ""key_or_keyring:<key>:chain""."
"// ""shorthands"" can be a series of shorthand letters of flags (e.g. ""-vvv"")."
"// ""{XXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}"" into a GUID."
"// #define roundup(x, y)   ((((x)+((y)-1))/(y))*(y))"
"// (CAN_TP16, CAN_TP20, CAN_MCNET, and CAN_ISOTP), they can be left with"
"// +build !aix,!darwin,!dragonfly,!freebsd,!linux,!netbsd,!openbsd,!zos,!windows,!solaris,!plan9"
"// +build !linux,!darwin,!freebsd,!dragonfly,!netbsd,!openbsd,!solaris"
"// +build !windows,!solaris,!aix"
"// +build ${GOARCH},${GOOS}"""
"// +build 386,freebsd"
"// +build 386,linux"
"// +build 386,netbsd"
"// +build 386,openbsd"
"// +build aix darwin,!race linux,!race freebsd,!race netbsd openbsd solaris dragonfly zos"
"// +build aix,ppc"
"// +build aix,ppc64"
"// +build aix,ppc64,gc"
"// +build aix,ppc64,gccgo"
"// +build amd64,darwin"
"// +build amd64,dragonfly"
"// +build amd64,freebsd"
"// +build amd64,illumos"
"// +build amd64,linux"
"// +build amd64,linux,gc"
"// +build amd64,netbsd"
"// +build amd64,openbsd"
"// +build amd64,solaris"
"// +build arm,freebsd"
"// +build arm,gc,linux"
"// +build arm,linux"
"// +build arm,netbsd"
"// +build arm,openbsd"
"// +build arm64,darwin"
"// +build arm64,freebsd"
"// +build arm64,linux"
"// +build arm64,netbsd"
"// +build arm64,openbsd"
"// +build darwin,!ios linux"
"// +build darwin,!ios"
"// +build darwin,amd64,go1.12"
"// +build darwin,amd64,go1.13"
"// +build darwin,arm64,go1.12"
"// +build darwin,arm64,go1.13"
"// +build darwin,go1.12"
"// +build darwin,go1.12,!go1.13"
"// +build darwin,go1.13"
"// +build darwin,race linux,race freebsd,race"
"// +build dragonfly,amd64"
"// +build freebsd,386"
"// +build freebsd,amd64"
"// +build freebsd,arm"
"// +build freebsd,arm64"
"// +build gccgo,!aix"
"// +build gccgo,linux,amd64"
"// +build illumos,amd64"
"// +build linux,386 linux,arm linux,mips linux,mipsle linux,ppc"
"// +build linux,386"
"// +build linux,amd64"
"// +build linux,arm"
"// +build linux,arm64"
"// +build linux,gc"
"// +build linux,gc,386"
"// +build linux,gccgo,386"
"// +build linux,gccgo,arm"
"// +build linux,loong64"
"// +build linux,mips"
"// +build linux,mips64"
"// +build linux,mips64le"
"// +build linux,mipsle"
"// +build linux,ppc"
"// +build linux,ppc64"
"// +build linux,ppc64le"
"// +build linux,riscv64"
"// +build linux,s390x"
"// +build linux,sparc64"
"// +build loong64,linux"
"// +build mips,linux"
"// +build mips64,linux"
"// +build mips64,openbsd"
"// +build mips64le,linux"
"// +build mipsle,linux"
"// +build netbsd,386"
"// +build netbsd,amd64"
"// +build netbsd,arm"
"// +build netbsd,arm64"
"// +build openbsd,386"
"// +build openbsd,amd64"
"// +build openbsd,arm"
"// +build openbsd,arm64"
"// +build openbsd,mips64"
"// +build plan9,!race"
"// +build plan9,386"
"// +build plan9,amd64"
"// +build plan9,arm"
"// +build plan9,race"
"// +build ppc,aix"
"// +build ppc,linux"
"// +build ppc64,aix"
"// +build ppc64,linux"
"// +build ppc64le,linux"
"// +build riscv64,linux"
"// +build s390x,linux"
"// +build solaris,amd64"
"// +build sparc64,linux"
"// +build windows,!race"
"// +build windows,go1.9"
"// +build windows,race"
"// +build zos,s390x"
"// , or """" if uuid is invalid."
"// - there are no local, non-persistent flags on the command-line or TraverseChildren is true"
"// - when a flag in a group is present, other flags in the group will be marked required"
"// - when a flag in a mutually exclusive group is present, other flags in the group will be marked as hidden"
"// 0x7F (stopped), or a signal number that caused an exit."
"// 1, 2, 3."
"// 1- the feature has been explicitly disabled by the program,"
"// 100-nanosecond intervals since January 1, 1601"
"// 2 for Family, Len; 1 for NUL"
"// 2- Even without completions, we need to print the directive"
"// 2- c has no subcommands (to avoid creating one),"
"// 32-bit dev_t, encoded as mmmM MMmm."
"// <sys/ioctl.h> is broken on powerpc64, as it fails to include definitions of"
"// A flag without a value, or with an `=` separated value"
"// A quick, efficient equality check"
"// AF_INET, an error is returned."
"// AIX wait4 may return with ERESTART errno, while the processus is still"
"// According to documentation, this function always succeeds."
"// According to netdevice(7), only AF_INET addresses are returned for numerous"
"// AddDllDirectory, RemoveDllDirectory, or SetDefaultDllDirectories"
"// Addr represents a bluetooth address, byte ordering is little-endian."
"// After this, the versions are properly sorted"
"// All functions get the same args, the arguments after the command name."
"// Alternatively, these transformations are done:"
"// Always complete ValidArgs, even if we are completing a subcommand name."
"// Always show help if requested, even if SilenceErrors is in"
"// An extra number (exit code, signal causing a stop)"
"// An ifreqData is an Ifreq which carries pointer data. To produce an ifreqData,"
"// As for ptracePeek, we need to align our accesses to deal"
"// As the last printout, print the completion directive for the completion script to parse."
"// Atim, Mtim and Ctim is changed from StTimespec to Timespec during"
"// AutoCompleteCallback, if non-null, is called for each keypress with"
"// BL R7, R6"
"// Because EpollWait mutates events, the caller is expected to coordinate"
"// Beginning in Go 1.7, duration zero values are ""0s"""
"// Believe it or not, this is the best we can do on Linux"
"// Bind and Accept must be used. Once the setup process is complete, input"
"// Bool defines a bool flag with specified name, default value, and usage string."
"// BoolP is like Bool, but accepts a shorthand letter that can be used after a single dash."
"// BoolSlice defines a []bool flag with specified name, default value, and usage string."
"// BoolSliceP is like BoolSlice, but accepts a shorthand letter that can be used after a single dash."
"// BoolSliceVar defines a []bool flag with specified name, default value, and usage string."
"// BoolSliceVar defines a boolSlice flag with specified name, default value, and usage string."
"// BoolSliceVarP is like BoolSliceVar, but accepts a shorthand letter that can be used after a single dash."
"// BoolVar defines a bool flag with specified name, default value, and usage string."
"// BoolVarP is like BoolVar, but accepts a shorthand letter that can be used after a single dash."
"// BuildSecurityDescriptor makes a new security descriptor using the input trustees, explicit access lists, and"
"// By default, the zero FlagSet uses an empty name and the"
"// ByteSliceToString returns a string form of the text represented by the slice s, with a terminating NUL and any"
"// BytesBase64 defines an []byte flag with specified name, default value, and usage string."
"// BytesBase64P is like BytesBase64, but accepts a shorthand letter that can be used after a single dash."
"// BytesBase64Var defines an []byte flag with specified name, default value, and usage string."
"// BytesBase64VarP is like BytesBase64Var, but accepts a shorthand letter that can be used after a single dash."
"// BytesHex defines an []byte flag with specified name, default value, and usage string."
"// BytesHexP is like BytesHex, but accepts a shorthand letter that can be used after a single dash."
"// BytesHexVar defines an []byte flag with specified name, default value, and usage string."
"// BytesHexVarP is like BytesHexVar, but accepts a shorthand letter that can be used after a single dash."
"// Call executes procedure p with arguments a. It will panic, if more than 15 arguments"
"// CallClassInstaller member calls the appropriate class installer, and any registered co-installers, with the specified installation request (DIF code)."
"// Channel is a designated bluetooth channel, only 1-30 are available for use."
"// Check if there are any local, non-persistent flags on the command-line"
"// CheckErr prints the msg with the prefix 'Error:' and exits with error code 1. If the msg is nil, it does nothing."
"// ClockSequence returns the current clock sequence, generating one if not"
"// Code generated by 'mkerrors.bash'; DO NOT EDIT."""
"// Code generated by 'mkknownfolderids.bash'; DO NOT EDIT."""
"// Code generated by linux/mkall.go generatePtracePair(""386"", ""amd64""). DO NOT EDIT."
"// Code generated by linux/mkall.go generatePtracePair(""arm"", ""arm64""). DO NOT EDIT."
"// Code generated by linux/mkall.go generatePtracePair(""mips"", ""mips64""). DO NOT EDIT."
"// Code generated by linux/mkall.go generatePtracePair(""mipsle"", ""mips64le""). DO NOT EDIT."
"// Code generated by linux/mkall.go generatePtraceRegSet(""arm64""). DO NOT EDIT."
"// Command is just that, a command for your application."
"// CommandLine is the default set of command-line flags, parsed from os.Args."
"// Commands similar to git, go tools and other modern CLI tools"
"// Compared to StringArray flags, StringSlice flags take comma-separated value as arguments and split them accordingly."
"// Comparison example. There is also GreaterThan, Equal, and just"
"// Complete subcommand names, including the help command"
"// ComposeCommandLine escapes and joins the given arguments suitable for use as a Windows command line,"
"// Constraint represents a single constraint for a version, such as"
"// Copyright 2009,2010 The Go Authors. All rights reserved."
"// Count defines a count flag with specified name, default value, and usage string."
"// CountVar defines a count flag with specified name, default value, and usage string."
"// Creates a SID for a well-known predefined alias, generally using the constants of the form"
"// Currently, database types that map to string and []byte are supported. Please"
"// DIREG specifies values for SetupDiCreateDevRegKey, SetupDiOpenDevRegKey, and SetupDiDeleteDevRegKey."
"// DLL preloading attacks. To safely load a system DLL, use LazyDLL"
"// DecomposeCommandLine breaks apart its argument command line into unescaped parts using CommandLineToArgv,"
"// Deprecated defines, if this command is deprecated and should print this string when used."
"// DevInstallParams is device installation parameters structure (associated with a particular device information element, or globally with a device information set)"
"// DeviceInfoListDetail method retrieves information associated with a device information set including the class GUID, remote computer handle, and remote computer name."
"// DisableAutoGenTag defines, if gen tag (""Auto generated by spf13/cobra..."")"
"// Do it the glibc way, add AT_NO_AUTOMOUNT."
"// DrvInfoData is driver information structure (member of a driver info list that may be associated with a particular device instance, or (globally) with a device information set)"
"// Duration defines a time.Duration flag with specified name, default value, and usage string."
"// DurationP is like Duration, but accepts a shorthand letter that can be used after a single dash."
"// DurationSlice defines a []time.Duration flag with specified name, default value, and usage string."
"// DurationSliceP is like DurationSlice, but accepts a shorthand letter that can be used after a single dash."
"// DurationSliceVar defines a durationSlice flag with specified name, default value, and usage string."
"// DurationSliceVar defines a duration[] flag with specified name, default value, and usage string."
"// DurationSliceVarP is like DurationSliceVar, but accepts a shorthand letter that can be used after a single dash."
"// DurationVar defines a time.Duration flag with specified name, default value, and usage string."
"// DurationVarP is like DurationVar, but accepts a shorthand letter that can be used after a single dash."
"// EnableCommandSorting controls sorting of the slice of commands, which is turned on by default."
"// ErrPasteIndicator may be returned from ReadLine as the error, in addition"
"// Error table\n"");"
"// Even though it is a mistake on the program's side, let's be nice when we can."
"// Even though we could support more than three segments, if we"
"// Every other win32 array API takes arguments as ""pointer, count"", except for this function. So we"
"// Ex: if the golang flag was -v, allow both -v and --v to work"
"// Exec calls execve(2), which replaces the calling executable in the process"
"// ExecuteContext is the same as Execute(), but sets the ctx on the command."
"// ExecuteContextC is the same as ExecuteC(), but sets the ctx on the command."
"// FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command."
"// Find(), if those Root commands don't have any sub-commands, they will accept arguments."
"// Flag not supported by this command, the interspersed option might be set so return the original args"
"// Float32 defines a float32 flag with specified name, default value, and usage string."
"// Float32P is like Float32, but accepts a shorthand letter that can be used after a single dash."
"// Float32Slice defines a []float32 flag with specified name, default value, and usage string."
"// Float32SliceP is like Float32Slice, but accepts a shorthand letter that can be used after a single dash."
"// Float32SliceVar defines a float32Slice flag with specified name, default value, and usage string."
"// Float32SliceVar defines a float32[] flag with specified name, default value, and usage string."
"// Float32SliceVarP is like Float32SliceVar, but accepts a shorthand letter that can be used after a single dash."
"// Float32Var defines a float32 flag with specified name, default value, and usage string."
"// Float32VarP is like Float32Var, but accepts a shorthand letter that can be used after a single dash."
"// Float64 defines a float64 flag with specified name, default value, and usage string."
"// Float64P is like Float64, but accepts a shorthand letter that can be used after a single dash."
"// Float64Slice defines a []float64 flag with specified name, default value, and usage string."
"// Float64SliceP is like Float64Slice, but accepts a shorthand letter that can be used after a single dash."
"// Float64SliceVar defines a float64Slice flag with specified name, default value, and usage string."
"// Float64SliceVar defines a float64[] flag with specified name, default value, and usage string."
"// Float64SliceVarP is like Float64SliceVar, but accepts a shorthand letter that can be used after a single dash."
"// Float64Var defines a float64 flag with specified name, default value, and usage string."
"// Float64VarP is like Float64Var, but accepts a shorthand letter that can be used after a single dash."
"// Flock_t type is SYS_FCNTL64, not SYS_FCNTL."
"// For Go 1.1, we might avoid the allocation of win32finddata1 here"
"// For Root commands that don't specify any value for their Args fields, when we call"
"// For Unix, get the pagesize from the runtime."
"// For Windows 9x compatibility, INF section names should be constrained to 32 characters."
"// For example, a sub-command without a description should not be completed"
"// For example, to complete only files of the form *.json or *.yaml:"
"// For example, with ""1.2.3+beta"", the metadata is ""beta""."
"// For flags, using Command.MarkFlagFilename() and Command.MarkPersistentFlagFilename()"
"// For flags, using MarkFlagDirname() is a shortcut to using this directive explicitly."
"// For flags, using MarkFlagFilename() and MarkPersistentFlagFilename()"
"// For more information on TIPC, see: http://tipc.sourceforge.net/."
"// For portability with other shells, it is recommended to instead use ValidArgsFunction"
"// For z/OS, only replace NUL with @ when the"
"// Fork, exec, wait, etc."
"// Format: a=1,b=2"
"// Get the highest specificity (hS), or if they're equal, just use segmentSelf length"
"// GetLinkedToken returns the linked token, which may be an elevated UAC token."
"// GetProcessPreferredUILanguages may return numLanguages==0 with ""\0\0"""
"// Getcwd returns the number of bytes written to buf, including the NUL."
"// Given ""a `name` to show"" it returns (""name"", ""a name to show"")."
"// GreaterThan, GreaterThanOrEqual or LessThanOrEqual methods."
"// Gt takes two types and checks whether the first type is greater than the second. In case of types Arrays, Chans,"
"// Guests have a unique CID, and hosts may have a well-known CID of:"
"// HAX// hax 1\n""), 0644); err != nil {"
"// Handle first line, which is indented by the caller (or the"
"// Hidden defines, if this command is hidden and should NOT show up in the list of available commands."
"// However, because we have added the __complete sub-command in the current code path, the"
"// I am scared that if we don't include the +2 here, the kernel"
"// IP defines an net.IP flag with specified name, default value, and usage string."
"// IP returns an IPv4 or IPv6 address, or nil if the underlying SocketAddress is neither."
"// IPMask defines an net.IPMask flag with specified name, default value, and usage string."
"// IPMaskP is like IP, but accepts a shorthand letter that can be used after a single dash."
"// IPMaskP is like IPMask, but accepts a shorthand letter that can be used after a single dash."
"// IPMaskVar defines an net.IPMask flag with specified name, default value, and usage string."
"// IPMaskVarP is like IPMaskVar, but accepts a shorthand letter that can be used after a single dash."
"// IPNet defines an net.IPNet flag with specified name, default value, and usage string."
"// IPNetP is like IPNet, but accepts a shorthand letter that can be used after a single dash."
"// IPNetVar defines an net.IPNet flag with specified name, default value, and usage string."
"// IPNetVarP is like IPNetVar, but accepts a shorthand letter that can be used after a single dash."
"// IPP is like IP, but accepts a shorthand letter that can be used after a single dash."
"// IPSlice defines a []net.IP flag with specified name, default value, and usage string."
"// IPSliceP is like IPSlice, but accepts a shorthand letter that can be used after a single dash."
"// IPSliceVar defines a []net.IP flag with specified name, default value, and usage string."
"// IPSliceVar defines a ipSlice flag with specified name, default value, and usage string."
"// IPSliceVarP is like IPSliceVar, but accepts a shorthand letter that can be used after a single dash."
"// IPVar defines an net.IP flag with specified name, default value, and usage string."
"// IPVarP is like IPVar, but accepts a shorthand letter that can be used after a single dash."
"// If DisableFlagParsing==false, we have completed the flags as known by Cobra;"
"// If DisableFlagParsing==true, Cobra may not be aware of all flags, so we"
"// If OpenBSD <= 5.9, pledge is not available."
"// If OpenBSD <= 6.2 and execpromises is not empty,"
"// If Set is called on a flag that already has a []bool assigned, the newly converted values will be appended."
"// If Set is called on a flag that already has a []net.IP assigned, the newly converted values will be appended."
"// If a flag doesn't exist, it wasn't changed...."
"// If a flag that is mutually exclusive to others is present, we hide the other"
"// If a flag that is part of a group is present, we make all the other flags"
"// If c already has a version flag, it will do nothing."
"// If c already has help command or c has no subcommands, it will do nothing."
"// If c already has help flag, it will do nothing."
"// If c.Version is empty, it will do nothing."
"// If c.parentsPflags == nil, it makes new."
"// If err is EINVAL, this returned ERROR_SUCCESS indicating a non-restricted token."
"// If found parse to a subcommand and then failed, talk about the subcommand"
"// If global normalization function exists, update all children"
"// If help is called, regardless of other flags, return we want help."
"// If multiple direntries are written, sometimes when we reach the final one,"
"// If n is zero then the immediately prior value is returned, if one, then the"
"// If name is """" then the first usable interface found will be used or a random"
"// If name is """" then the name and hardware address of one of the system's"
"// If newErr is nil, os.Stderr is used."
"// If newIn is nil, os.Stdin is used."
"// If newOut is nil, os.Stdout is used."
"// If no completions were found within commands or ValidArgs,"
"// If nothing has rejected the version by now, it's valid"
"// If output is nil, os.Stderr is used."
"// If root command has SilenceErrors flagged,"
"// If root command has SilenceUsage flagged,"
"// If the call fails due to other reasons, current fsgid will be returned."
"// If the call fails due to other reasons, current fsuid will be returned."
"// If the flag contains an = it means it has already been fully processed,"
"// If the flag is not already present, or if it can be specified multiple times (Array or Slice)"
"// If the flag is not already present, we suggest it as a completion"
"// If the flag.Value happens to also be a pflag.Value, just use it directly."
"// If the pointer is nil, it returns the empty string. It assumes that the UTF-16 sequence is terminated"
"// If the pointer is nil, it returns the empty string. It assumes that the text sequence is terminated"
"// If the segments are the same, we must compare on prerelease info"
"// If the shorthand of this flag is deprecated, this string is the new or now thing to use"
"// If the user wants to port_dissociate before the event has been processed,"
"// If the version being checked has less specificity than the constraint, then there"
"// If the version being checked is naturally less than the constraint, then there"
"// If there are ValidArgs specified (even if they don't match), we stop completion."
"// If there are no back quotes, the name is an educated guess of the"
"// If there is a single completion, the shell usually adds a space"
"// If there is nothing on current line and no prompt printed,"
"// If there were a new target with floating point type for it, we have"
"// If this flag is deprecated, this string is the new or now thing to use"
"// If tv is nil, the access and modification times are set to the current time."
"// If we don't have a clock sequence already, set one."
"// If we get here then we have a key that we don't recognise, or a"
"// If we have not found any required flags, only then can we show regular flags"
"// If we're running on OpenBSD > 6.2, pass execpromises to the syscall."
"// In NetBSD unlockpt() does nothing, so it isn't called here."
"// In addition to providing an interface, Cobra simultaneously provides a controller to organize your application code."
"// In case of error after this point, make sure we close the ptmx fd."
"// In case of error after this point, make sure we close the pts fd."
"// In epoll, Events is a 32-bit field, while poll uses 16 bits."
"// In order to only have Timespec structure, type of Stat_t's fields"
"// In order to use msghdr structure with Control, Controllen, nrecvmsg and nsendmsg must be used."
"// In some cases, Linux can return a path that starts with the"
"// In that case, there is no value following it, so we are not really doing flag completion."
"// Indicates that the shell should not add a space after the completion,"
"// Instead, when no other completion is specified, file completion is done by"
"// Int defines an int flag with specified name, default value, and usage string."
"// Int16 defines an int16 flag with specified name, default value, and usage string."
"// Int16P is like Int16, but accepts a shorthand letter that can be used after a single dash."
"// Int16Var defines an int16 flag with specified name, default value, and usage string."
"// Int16VarP is like Int16Var, but accepts a shorthand letter that can be used after a single dash."
"// Int32 defines an int32 flag with specified name, default value, and usage string."
"// Int32P is like Int32, but accepts a shorthand letter that can be used after a single dash."
"// Int32Slice defines a []int32 flag with specified name, default value, and usage string."
"// Int32SliceP is like Int32Slice, but accepts a shorthand letter that can be used after a single dash."
"// Int32SliceVar defines a int32Slice flag with specified name, default value, and usage string."
"// Int32SliceVar defines a int32[] flag with specified name, default value, and usage string."
"// Int32SliceVarP is like Int32SliceVar, but accepts a shorthand letter that can be used after a single dash."
"// Int32Var defines an int32 flag with specified name, default value, and usage string."
"// Int32VarP is like Int32Var, but accepts a shorthand letter that can be used after a single dash."
"// Int64 defines an int64 flag with specified name, default value, and usage string."
"// Int64P is like Int64, but accepts a shorthand letter that can be used after a single dash."
"// Int64Slice defines a []int64 flag with specified name, default value, and usage string."
"// Int64SliceP is like Int64Slice, but accepts a shorthand letter that can be used after a single dash."
"// Int64SliceVar defines a int64Slice flag with specified name, default value, and usage string."
"// Int64SliceVar defines a int64[] flag with specified name, default value, and usage string."
"// Int64SliceVarP is like Int64SliceVar, but accepts a shorthand letter that can be used after a single dash."
"// Int64Var defines an int64 flag with specified name, default value, and usage string."
"// Int64VarP is like Int64Var, but accepts a shorthand letter that can be used after a single dash."
"// Int8 defines an int8 flag with specified name, default value, and usage string."
"// Int8P is like Int8, but accepts a shorthand letter that can be used after a single dash."
"// Int8Var defines an int8 flag with specified name, default value, and usage string."
"// Int8VarP is like Int8Var, but accepts a shorthand letter that can be used after a single dash."
"// IntP is like Int, but accepts a shorthand letter that can be used after a single dash."
"// IntSlice defines a []int flag with specified name, default value, and usage string."
"// IntSliceP is like IntSlice, but accepts a shorthand letter that can be used after a single dash."
"// IntSliceVar defines a intSlice flag with specified name, default value, and usage string."
"// IntSliceVar defines a int[] flag with specified name, default value, and usage string."
"// IntSliceVarP is like IntSliceVar, but accepts a shorthand letter that can be used after a single dash."
"// IntVar defines an int flag with specified name, default value, and usage string."
"// IntVarP is like IntVar, but accepts a shorthand letter that can be used after a single dash."
"// It is used for ProcessVMReadv and ProcessVMWritev, where the pointer"
"// It panics, if len(name) > 1."
"// It visits all flags, even those not set."
"// It will always return ""0"" if the global environment variable COBRA_ACTIVE_HELP"
"// It won't handle assigning the results of lseek to *basep, or handle"
"// It's always a valid pointer, although the escape codes themselves"
"// It's not documented if this is necessary, but we're paranoid."
"// It's not the full required semantics, but should handle the case"
"// Just Dup'ing the file descriptor is not enough, as the"
"// KEYCTL_ASSUME_AUTHORITY, KEYCTL_SESSION_TO_PARENT, KEYCTL_REJECT,"
"// KEYCTL_INVALIDATE, and KEYCTL_GET_PERSISTENT."
"// KEYCTL_UNLINK, KEYCTL_NEGATE, KEYCTL_SET_REQKEY_KEYRING, KEYCTL_SET_TIMEOUT,"
"// KnownFolderPath returns a well-known folder path for the current user, specified by one of"
"// KnownFolderPath returns a well-known folder path for the user token, specified by one of"
"// Len returns the length, in bytes, of a valid security identifier SID."
"// Let the logic continue so as to add any ValidArgsFunction completions,"
"// Linux on s390x uses the old mmap interface, which requires arguments to be passed in a struct."
"// Linux watchdog API. For more information, see:"
"// Load will not try to load DLL, if it is already loaded into memory."
"// Look for a back-quoted name, but avoid the strings package."
"// Lookup returns the Flag structure of the named command-line flag,"
"// Lookup returns the Flag structure of the named flag, returning nil if none exists."
"// Magic sysctl: ""setting"" 0.3 to a string name"
"// Make this change to only the hardware profile specified by HwProfile. this flag only applies to root-enumerated devices. When Windows removes the device from the last hardware profile in which it was configured, Windows performs a global removal."
"// Maps and Slices, Gt will compare their lengths. Ints are compared directly while strings are first parsed as"
"// MarkFlagCustom adds the BashCompCustom annotation to the named flag, if it exists."
"// Mmap manager, for use by operating system-specific implementations."
"// Must is a helper that wraps a call to a function returning (*Version, error)"
"// NOTE: It seems like 64-bit Darwin, Illumos and Solaris"
"// NTStatus corresponds with NTSTATUS, error values returned by ntdll.dll and"
"// NTString is an ANSI string for NT native APIs, corresponding to STRING."
"// NTUnicodeString is a UTF-16 string for NT native APIs, corresponding to UNICODE_STRING."
"// NULL-style string interfaces, so this simple wrapper is provided."
"// NewFlagSet returns a new, empty flag set with the specified name,"
"// NewLazySystemDLL is like NewLazyDLL, but will only"
"// NewProcThreadAttributeList allocates a new ProcThreadAttributeListContainer, with the requested maximum number of attributes."
"// NodeID returns a slice of a copy of the current Node ID, setting the Node ID"
"// Not friendly to overwrite in place,"
"// Now that we know the size, get the actual nodes."
"// Null assigns special ""don't touch"" values to members of d to"
"// OK, except with the pessimistic operator"
"// On 32-bit Linux systems, the fcntl syscall that matches Go's"
"// On Linux, this is an in-kernel data structure accessed through a fd."
"// On linux Setuid and Setgid only affects the current thread, not the process."
"// On ppc64, Timespec.Nsec is an int64 while StTimespec.Nsec is an"
"// On s390x Linux, all the socket calls go through an extra indirection."
"// On sparc{,64}, the kernel defines struct termios2 itself which clashes with the"
"// On x86 Linux, all the socket calls go through an extra indirection,"
"// One of the flags of the group is set, mark the other ones as required"
"// One of the flags of the mutually exclusive group is set, mark the other ones as hidden"
"// One or more device property sheets have had changes made to them, and need to have a DIF_PROPERTYCHANGE occur."
"// Original returns the original parsed version as-is, including any"
"// Otherwis, rhs was > lhs, they're not equal"
"// Otherwise tv must contain exactly 2 elements, with access time as the first"
"// Package term provides support functions for dealing with terminals, as"
"// Package terminal provides support functions for dealing with terminals, as"
"// Parse parses flag definitions from the argument list, which should not"
"// ParseAll parses flag definitions from the argument list, which should not"
"// ParseBytes is like Parse, except it parses a byte slice instead of a string."
"// ParseDirent parses up to max directory entries in buf,"
"// Peeks returns the word in *data, not as the return value."
"// Prerelease returns any prerelease data that is part of the version,"
"// Print is a convenience method to Print to the defined output, fallback to Stderr if not set."
"// PrintDefaults prints, to standard error unless configured"
"// PrintErr is a convenience method to Print to the defined Err output, fallback to Stderr if not set."
"// PrintErrf is a convenience method to Printf to the defined Err output, fallback to Stderr if not set."
"// PrintErrln is a convenience method to Println to the defined Err output, fallback to Stderr if not set."
"// Printf is a convenience method to Printf to the defined output, fallback to Stderr if not set."
"// Printf works like fmt.Printf, but adds the option of using tags to apply colour or text formatting to the written text. For example ""<red>some red text</red>""."
"// Println is a convenience method to Println to the defined output, fallback to Stderr if not set."
"// Println works like fmt.Println, but adds the option of using tags to apply colour or text formatting to the written text. For example ""<red>some red text</red>""."
"// ProcThreadAttributeListContainer.Delete, and access the list itself using"
"// REG_NOTIFY_CHANGE_ATTRIBUTES notifies the caller of changes to the attributes of the key, such as the security descriptor information."
"// REG_NOTIFY_CHANGE_LAST_SET notifies the caller of changes to a value of the key. This can include adding or deleting a value, or changing an existing value."
"// ReadPassword temporarily changes the prompt and reads a password, without"
"// Regardless of what command execute is called on, run on Root only"
"// Reserved, Microsoft Corporation backward compatibility."
"// Reserved, NCS backward compatibility."
"// ResetCommands delete parent, subcommand and help command from c."
"// ResourceID represents a 16-bit resource identifier, traditionally created with the MAKEINTRESOURCE macro."
"// ResourceIDOrString must be either a ResourceID, to specify a resource or resource type by ID,"
"// Returns a default environment associated with the token, rather than the current"
"// RtlGetNtVersionNumbers returns the version of the underlying operating system,"
"// RtlGetVersion returns the version of the underlying operating system, ignoring"
"// SID into a valid, functional SID."
"// SP_MAX_MACHINENAME_LENGTH defines maximum length of a machine name in the format expected by ConfigMgr32 CM_Connect_Machine (i.e., ""\\\\MachineName\0"")."
"// SS_*, where x=SAVSTACK_ASYNC"
"// SYS_ALARM is not defined on arm or riscv, but is available for other GOARCH"
"// SYS___SYSCTL is used by syscall_bsd.go for all BSDs, but in modern versions"
"// Search config in home directory with name "".cobra"" (without extension)."
"// Security (R/W, binary form)"
"// Security (W, SDS form)"
"// Set converts, and assigns, the comma-separated IP argument string representation as the []net.IP value of this flag."
"// Set converts, and assigns, the comma-separated boolean argument string representation as the []bool value of this flag."
"// SetArgs sets arguments for the command. It is set to os.Args[1:] by default, if desired, can be overridden"
"// SetRand sets the random number generator to r, which implements io.Reader."
"// SetSelectedDriver method sets, or resets, the selected driver for a device information element or the selected class driver for a device information set."
"// SetupDiCallClassInstaller function calls the appropriate class installer, and any registered co-installers, with the specified installation request (DIF code)."
"// SetupDiGetDeviceInfoListDetail function retrieves information associated with a device information set including the class GUID, remote computer handle, and remote computer name."
"// ShorthandLookup returns the Flag structure of the short handed flag,"
"// Signal table\n"");"
"// SignalNum returns the syscall.Signal for signal named s,"
"// Since boolean flags and shortname flags don't show the = form, let's go that route and never show it."
"// SockaddrTIPC. It is only implemented by *TIPCSocketAddr, *TIPCServiceRange,"
"// Some BSDs include the trailing NUL in the length, whereas"
"// Sort values, so they can be tested/scripted against consistently."
"// SortFlags is used to indicate, if user wants to have sorted flags in"
"// Sprintf works like fmt.Sprintf, but adds the option of using tags to apply colour or text formatting to the written text. For example ""<red>some red text</red>""."
"// Start assigns a pseudo-terminal tty os.File to c.Stdin, c.Stdout,"
"// StartWithAttrs assigns a pseudo-terminal tty os.File to c.Stdin, c.Stdout,"
"// StartWithSize assigns a pseudo-terminal tty os.File to c.Stdin, c.Stdout,"
"// String converts SID to a string format suitable for display, storage, or transmission."
"// String defines a ""native"" format for this boolean slice flag value."
"// String defines a ""native"" format for this net.IP slice flag value."
"// String defines a string flag with specified name, default value, and usage string."
"// String returns the SDDL form of the security descriptor, with a function signature that can be"
"// String returns the canonical string form of the GUID,"
"// String returns the string form of uuid, xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
"// StringArray defines a string flag with specified name, default value, and usage string."
"// StringArrayP is like StringArray, but accepts a shorthand letter that can be used after a single dash."
"// StringArrayVar defines a string flag with specified name, default value, and usage string."
"// StringArrayVarP is like StringArrayVar, but accepts a shorthand letter that can be used after a single dash."
"// StringP is like String, but accepts a shorthand letter that can be used after a single dash."
"// StringSlice defines a string flag with specified name, default value, and usage string."
"// StringSliceP is like StringSlice, but accepts a shorthand letter that can be used after a single dash."
"// StringSliceVar defines a string flag with specified name, default value, and usage string."
"// StringSliceVarP is like StringSliceVar, but accepts a shorthand letter that can be used after a single dash."
"// StringToInt defines a string flag with specified name, default value, and usage string."
"// StringToInt64 defines a string flag with specified name, default value, and usage string."
"// StringToInt64P is like StringToInt64, but accepts a shorthand letter that can be used after a single dash."
"// StringToInt64Var defines a string flag with specified name, default value, and usage string."
"// StringToInt64VarP is like StringToInt64Var, but accepts a shorthand letter that can be used after a single dash."
"// StringToIntP is like StringToInt, but accepts a shorthand letter that can be used after a single dash."
"// StringToIntVar defines a string flag with specified name, default value, and usage string."
"// StringToIntVarP is like StringToIntVar, but accepts a shorthand letter that can be used after a single dash."
"// StringToString defines a string flag with specified name, default value, and usage string."
"// StringToStringP is like StringToString, but accepts a shorthand letter that can be used after a single dash."
"// StringToStringVar defines a string flag with specified name, default value, and usage string."
"// StringToStringVarP is like StringToStringVar, but accepts a shorthand letter that can be used after a single dash."
"// StringVar defines a string flag with specified name, default value, and usage string."
"// StringVarP is like StringVar, but accepts a shorthand letter that can be used after a single dash."
"// TODO(jsing): DragonFly has a ""bug"" (see issue 3349), which should be"
"// TODO(mdlayher): get/set methods for hardware address sockaddr, char array, etc."
"// TODO(neeilan): Commented this out to get sys/unix compiling on z/OS. Uncomment and fix. Error: ""undefined: clearsyscall"""
"// TODO(neeilan): When we make epfds and fds disjoint, detect epoll"
"// TODO: add more here, after collecting data on the common"
"// TODO: if we get the chance, remove the req parameter and"
"// TODO: if we get the chance, remove the req parameter."
"// TODO: this isn't quite right, we should really check ahead for 'true' or 'false'"
"// Tell SetupDiBuildDriverInfoList to do a ""published INF"" search"
"// The = form will still work, we just won't suggest it."
"// The code generator produces -0x1 for (~0), but an unsigned value is necessary"
"// The following constants are part of the epoll API, but represent"
"// The generated scripts require PowerShell v5.0+ (which comes Windows 10, but"
"// The kernel already special-cases its name, so it's always"
"// The last argument, which is not completely typed by the user,"
"// The peek requests are machine-size oriented, so we wrap it"
"// The signal name should start with ""SIG""."
"// The src is 1 element bigger than dst, but it must be NUL."
"// The system creates an access token when a user logs on, and every"
"// The token identifies the user, the user's groups, and the user's"
"// The usual level and opt are SOL_LOCAL and LOCAL_PEERCRED, respectively."
"// The version might have newlines or tabs in it, convert them to"
"// There are various irregularities.  For example, the"
"// There are various irregularities. For example, the"
"// There is no loss of expressivity here, because the final"
"// There is no way to create a custom fcntl and to keep //sys fcntl easily,"
"// Therefore, the programmer must call dup2 instead of fcntl in this case."
"// These are EBCDIC encoded by the kernel, but we still need to pad them"
"// These are not suggested to the user in the shell completion,"
"// These commands are KEYCTL_REVOKE, KEYCTL_CHOWN, KEYCTL_CLEAR, KEYCTL_LINK,"
"// These commands are KEYCTL_UPDATE, KEYCTL_READ, and KEYCTL_INSTANTIATE."
"// This field is deliberately big-endian, unlike the previous"
"// This file contains functions that wrap SetupAPI.dll and CfgMgr32.dll,"
"// This file is compiled as ordinary Go code,"
"// This function returns """" (2 double quotes) if s is empty."
"// This is important because if we are completing a flag value, we need to also"
"// This is likely due to a bug in xnu kernels,"
"// This remvoves the ""net"" dependency, because it is not used in the browser."
"// Timespec is an invented structure on Windows, but here for"
"// Timespec, it returns a zero Timespec and ERANGE."
"// To achieve file extension filtering, one can use ValidArgsFunction and"
"// To achieve the same behavior across all shells, one can use"
"// To avoid this, we first remove the __complete command to get back to having no sub-commands."
"// To disable sorting, set it to false."
"// To disable the mousetrap, just set MousetrapHelpText to blank string ("""")."
"// To disable the mousetrap, just set this variable to blank string ("""")."
"// Translate ""kern.hostname"" to []_C_int{0,1,2,3}."
"// Traverse the command tree to find the command, and parse args for"
"// Try first with a small buffer, assuming the handle will"
"// Try to avoid short orphan words on the final line, by"
"// URN returns the RFC 2141 URN form of uuid,"
"// UTF16ToString returns the UTF-8 encoding of the UTF-16 sequence s,"
"// Uint defines a uint flag with specified name, default value, and usage string."
"// Uint16 defines a uint flag with specified name, default value, and usage string."
"// Uint16P is like Uint16, but accepts a shorthand letter that can be used after a single dash."
"// Uint16Var defines a uint flag with specified name, default value, and usage string."
"// Uint16VarP is like Uint16Var, but accepts a shorthand letter that can be used after a single dash."
"// Uint32 defines a uint32 flag with specified name, default value, and usage string."
"// Uint32P is like Uint32, but accepts a shorthand letter that can be used after a single dash."
"// Uint32Var defines a uint32 flag with specified name, default value, and usage string."
"// Uint32VarP is like Uint32Var, but accepts a shorthand letter that can be used after a single dash."
"// Uint64 defines a uint64 flag with specified name, default value, and usage string."
"// Uint64P is like Uint64, but accepts a shorthand letter that can be used after a single dash."
"// Uint64Var defines a uint64 flag with specified name, default value, and usage string."
"// Uint64VarP is like Uint64Var, but accepts a shorthand letter that can be used after a single dash."
"// Uint8 defines a uint8 flag with specified name, default value, and usage string."
"// Uint8P is like Uint8, but accepts a shorthand letter that can be used after a single dash."
"// Uint8Var defines a uint8 flag with specified name, default value, and usage string."
"// Uint8VarP is like Uint8Var, but accepts a shorthand letter that can be used after a single dash."
"// UintP is like Uint, but accepts a shorthand letter that can be used after a single dash."
"// UintSlice defines a []uint flag with specified name, default value, and usage string."
"// UintSliceP is like UintSlice, but accepts a shorthand letter that can be used after a single dash."
"// UintSliceVar defines a uintSlice flag with specified name, default value, and usage string."
"// UintSliceVar defines a uint[] flag with specified name, default value, and usage string."
"// UintSliceVarP is like UintSliceVar, but accepts a shorthand letter that can be used after a single dash."
"// UintSliceVarP is like the UintSliceVar, but accepts a shorthand letter that can be used after a single dash."
"// UintVar defines a uint flag with specified name, default value, and usage string."
"// UintVarP is like UintVar, but accepts a shorthand letter that can be used after a single dash."
"// Unable to find the real command. E.g., <program> someInvalidCmd <TAB>"
"// Use fstatat, because Android's seccomp policy blocks stat."
"// Using a pessimistic constraint with a pre-release, restricts versions to pre-releases"
"// Using the ""net"" library inflates the size of the transpiled JS code by 673k bytes."
"// VarP is like Var, but accepts a shorthand letter that can be used after a single dash."
"// VarPF is like VarP, but returns the flag created"
"// Vmsplice splices user pages from a slice of Iovecs into a pipe specified by fd,"
"// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"// Wait status is 7 bits at bottom, either 0 (exited),"
"// We can't stuff the base back into a uintptr, so any"
"// We can't stuff the offset back into a uintptr, so any"
"// We need to use LoadLibrary and GetProcAddress from the Go runtime, because"
"// We'll use this more than once, so grab the length now so it's a little cleaner"
"// When child is stopped, free resources"
"// When doing completion of a flag name, as soon as an argument starts with"
"// Win*Sid, for the domain specified by the domainSid parameter."
"// Win*Sid, for the local machine."
"// Windows System directory, bypassing the normal DLL search"
"// Windows directory, which is typically, though not always, `C:\Windows`."
"// Windows uses \r as end of line. So, on Windows, readPasswordLine"
"// Workaround FAIL with ""go test -v"" or ""cobra.test -test.v"", see #155"
"// WriteStringAndCheck writes a string into a buffer, and checks if the error is not nil."
"// XXX should first attempt to get gid of DEFAULT_TTY_GROUP=""tty"""
"// Zero clears the set s, so that it contains no CPUs."
"// _IOR(167, 119, int)"
"// __readdir_r_a returns errno at the end of the directory stream, rather than 0."
"// a base name (like ""advapi32.dll"")."
"// a command with a context.Background, so a background context will be"
"// a dependency on the (relatively heavy) ""reflect"" package."
"// a file or socket, use Sendto with MSG_MORE to instruct the kernel to update"
"// a flag named ""getURL"" and have it translated to ""geturl"".  A user could then pass"
"// a line wrap, the position will be advanced two"
"// a local terminal, that terminal must first have been put into raw mode."
"// a simple Compare that returns an int allowing easy >=, <=, etc."
"// a symlink, it is not dereferenced and the timestamps are set on the symlink."
"// a win32finddata1, and then copy the results out."
"// access (PEEKUSER warns that it might), but if we don't"
"// accessed using the Ifreq's methods. To create an Ifreq, use the NewIfreq"
"// actual system call is getdirentries64, 64 is a good guess."
"// affects Linux Kernel 5.8 and later versions, and has been fixed in Linux 5.16.11, 5.15.25 and 5.10.102"
"// align our reads, we might straddle an unmapped page"
"// all registered device interfaces, live or not"
"// an error if search fails. Find will not search procedure,"
"// and c.Stderr, calls c.Start, and returns the File of the tty's"
"// appendIfNotPresent will append stringToAppend to the end of s, but only if it's not yet present in s."
"// arg is ignored and not a pointer, so ioctl is fine instead of ioctlPtr."
"// argsMinusFirstX removes only the first x from args.  Otherwise, commands that look like"
"// argument is called with a pointer to the integer value, rather than"
"// arguments are a buffer and its length, respectively."
"// as gathered from GetCommandLine, QUERY_SERVICE_CONFIG's BinaryPathName argument, or elsewhere that"
"// as the size. I don't know why the +2 is here, but the"
"// as windows.Handle and windows.Errno, and we intend to keep these the same."
"// associated with opened file descriptor fd, and returns a non-negative"
"// at a zero byte; if the zero byte is not present, the program may crash."
"// at a zero word; if the zero word is not present, the program may crash."
"// attempt to wrap them. For the former, repainting t.maxLine"
"// backward compatible with the Linux kernel, which for some architectures uses"
"// because the caller expects to retain control of it, but"
"// being checked, at any point, does not have the same values in each index of the"
"// bind(2) man page: If name is zero, everything bound or mounted upon old is unbound or unmounted."
"// boolean flags, or flags with no option default values"
"// buffer). If a nil buffer is passed in, this function returns the minimum"
"// but it is also input to mksyscall,"
"// but since we are not using libc or XPG4.2, we should not be"
"// by default, godoc will display OS-specific documentation for the current"
"// by default, godoc will display the OS-specific documentation for the current"
"// bytes consumed from buf, the number of entries added"
"// bytes, as an index into |line|). If it returns ok=false, the key"
"// bytesToKey tries to parse a key sequence from b. If successful, it returns"
"// can't declare it as a usual [] type, because mksyscall will use the opposite order. We therefore"
"// case, with all - replaced by _."
"// change starting time to January 1, 1601"
"// change starting time to the Epoch (00:00:00 UTC, January 1, 1970)"
"// checking, we need to account for a lopsided or jagged comparison"
"// cobra program that only consists of the root command, since this"
"// command is similar to KEYCTL_INSTANTIATE, except that the payload is a slice"
"// command limits the set of keys that can be linked to the keyring, regardless"
"// command or a parent, or it returns a function which returns the original"
"// commandsAreSorted defines, if command slice are sorted or not."
"// constraints segments, then it cannot be valid against the constraint."
"// contains a NUL byte at any location, it returns (nil, syscall.EINVAL)."
"// core system functions for managing hardware devices, drivers, and the PnP tree."
"// credentials in a Ucred structure. To receive such a message, the"
"// current implementation, only the resource fork extended attribute makes"
"// data can be written to the socket, processed by the kernel, and then read"
"// default encoding is MMMM Mmmm mmmM MMmm, where M is a hex digit of the major"
"// default usecase of semver, which is MAJOR.MINOR.PATCH at the minimum"
"// define a ""version"" flag, a ""version"" boolean flag will be added to the command and, if specified,"
"// definition in glibc. As only the error constants are needed here, include the"
"// derived.  The interface ""user"" is returned if the NodeID was set by"
"// directory, the returned completions should specify the directory within"
"// directory, which is typically, though not always, `C:\Windows\System32`."
"// directory, which is typically, though not always, `C:\Windows`. This may"
"// dissociate was successful, safe to delete the cookie"
"// distributed under the License is distributed on an ""AS IS"" BASIS,"
"// do not use NTString, and instead UTF16PtrFromString should be used for"
"// do not use NTUnicodeString, and instead UTF16PtrFromString should be used for"
"// does no translation, if not set previously."
"// dragonfly needs to check ABI version at runtime, see cmsgAlignOf in"
"// dummy, NWMIfRouteMtu is a candidate"
"// dynamically load additional symbols. Note that in the Go runtime, these"
"// e.g. even though '>0.1,>0.2' is logically equivalent"
"// echo, from the terminal."
"// empty UUID, all zeros"
"// errnoErr returns common boxed Errno values, to prevent"
"// executable name should also be the first argument in argv ([""ls"", ""-l""])."
"// existing KCM socket, returning a structure containing the file descriptor of"
"// fact that it is NOT runnable/hidden/deprecated, and has no sub commands that"
"// fcntl64Syscall is usually SYS_FCNTL, but is overridden on 32-bit Linux"
"// fdopendir. However, syscallPtr was only added in Go 1.13, so we fall"
"// fields: dwFileType, dwCreatorType, and wFinderFlags. However, those fields"
"// fileHandle C.struct_file_handle"" but that generated empty structs"
"// flags are available, use GetProcAddress to get the address of the"
"// flags can be used with LoadLibraryEx."""
"// folder, but LoadLibraryEx doesn't support"
"// for ""asymmetric"" include ""builtin_trusted"", ""builtin_and_secondary_trusted"","
"// for a version ""1.2.3-beta"", segments will return a slice of"
"// for back-compat, only add version flag behavior if version is defined"
"// for example, having this command would cause problems to a"
"// for mips64 and mips64le. Instead, hard code it for now (it's the"
"// for the last character in a line. However, when"
"// for those, IoctlRetInt should be used instead of this function."
"// format of the output and how to control it, see the documentation for PrintDefaults."
"// from fd, using the specified request number."
"// func svcCall(fnptr unsafe.Pointer, argv *unsafe.Pointer, dsa *uint64)"
"// func svcUnload(name *byte, fnptr unsafe.Pointer) int64"
"// function. If GetProcAddress succeeds, the LOAD_LIBRARY_SEARCH_*"
"// given, logical position in the text."
"// go run mksyscall.go -b32 -arm -tags linux,mips syscall_linux.go syscall_linux_mipsx.go syscall_linux_alarm.go"
"// go run mksyscall.go -b32 -tags linux,ppc syscall_linux.go syscall_linux_ppc.go syscall_linux_alarm.go"
"// go run mksyscall.go -dragonfly -tags dragonfly,amd64 syscall_bsd.go syscall_dragonfly.go syscall_dragonfly_amd64.go"
"// go run mksyscall.go -l32 -arm -tags freebsd,arm syscall_bsd.go syscall_freebsd.go syscall_freebsd_arm.go"
"// go run mksyscall.go -l32 -arm -tags linux,arm syscall_linux.go syscall_linux_arm.go"
"// go run mksyscall.go -l32 -arm -tags linux,mipsle syscall_linux.go syscall_linux_mipsx.go syscall_linux_alarm.go"
"// go run mksyscall.go -l32 -netbsd -arm -tags netbsd,arm syscall_bsd.go syscall_netbsd.go syscall_netbsd_arm.go"
"// go run mksyscall.go -l32 -netbsd -tags netbsd,386 syscall_bsd.go syscall_netbsd.go syscall_netbsd_386.go"
"// go run mksyscall.go -l32 -openbsd -arm -tags openbsd,arm syscall_bsd.go syscall_openbsd.go syscall_openbsd_arm.go"
"// go run mksyscall.go -l32 -openbsd -tags openbsd,386 syscall_bsd.go syscall_openbsd.go syscall_openbsd_386.go"
"// go run mksyscall.go -l32 -plan9 -tags plan9,386 syscall_plan9.go"
"// go run mksyscall.go -l32 -plan9 -tags plan9,amd64 syscall_plan9.go"
"// go run mksyscall.go -l32 -plan9 -tags plan9,arm syscall_plan9.go"
"// go run mksyscall.go -l32 -tags freebsd,386 syscall_bsd.go syscall_freebsd.go syscall_freebsd_386.go"
"// go run mksyscall.go -l32 -tags linux,386 syscall_linux.go syscall_linux_386.go syscall_linux_alarm.go"
"// go run mksyscall.go -netbsd -tags netbsd,amd64 syscall_bsd.go syscall_netbsd.go syscall_netbsd_amd64.go"
"// go run mksyscall.go -netbsd -tags netbsd,arm64 syscall_bsd.go syscall_netbsd.go syscall_netbsd_arm64.go"
"// go run mksyscall.go -openbsd -tags openbsd,amd64 syscall_bsd.go syscall_openbsd.go syscall_openbsd_amd64.go"
"// go run mksyscall.go -openbsd -tags openbsd,arm64 syscall_bsd.go syscall_openbsd.go syscall_openbsd_arm64.go"
"// go run mksyscall.go -openbsd -tags openbsd,mips64 syscall_bsd.go syscall_openbsd.go syscall_openbsd_mips64.go"
"// go run mksyscall.go -tags darwin,amd64,go1.12 syscall_bsd.go syscall_darwin.go syscall_darwin_amd64.go"
"// go run mksyscall.go -tags darwin,amd64,go1.13 syscall_darwin.1_13.go"
"// go run mksyscall.go -tags darwin,arm64,go1.12 syscall_bsd.go syscall_darwin.go syscall_darwin_arm64.go"
"// go run mksyscall.go -tags darwin,arm64,go1.13 syscall_darwin.1_13.go"
"// go run mksyscall.go -tags freebsd,amd64 syscall_bsd.go syscall_freebsd.go syscall_freebsd_amd64.go"
"// go run mksyscall.go -tags freebsd,arm64 syscall_bsd.go syscall_freebsd.go syscall_freebsd_arm64.go"
"// go run mksyscall.go -tags linux,amd64 syscall_linux.go syscall_linux_amd64.go syscall_linux_alarm.go"
"// go run mksyscall.go -tags linux,arm64 syscall_linux.go syscall_linux_arm64.go"
"// go run mksyscall.go -tags linux,loong64 syscall_linux.go syscall_linux_loong64.go"
"// go run mksyscall.go -tags linux,mips64 syscall_linux.go syscall_linux_mips64x.go syscall_linux_alarm.go"
"// go run mksyscall.go -tags linux,mips64le syscall_linux.go syscall_linux_mips64x.go"
"// go run mksyscall.go -tags linux,ppc64 syscall_linux.go syscall_linux_ppc64x.go syscall_linux_alarm.go"
"// go run mksyscall.go -tags linux,ppc64le syscall_linux.go syscall_linux_ppc64x.go syscall_linux_alarm.go"
"// go run mksyscall.go -tags linux,riscv64 syscall_linux.go syscall_linux_riscv64.go"
"// go run mksyscall.go -tags linux,s390x syscall_linux.go syscall_linux_s390x.go syscall_linux_alarm.go"
"// go run mksyscall.go -tags linux,sparc64 syscall_linux.go syscall_linux_sparc64.go syscall_linux_alarm.go"
"// go run mksyscall.go -tags zos,s390x syscall_zos_s390x.go"
"// go run mksyscall_aix_ppc.go -aix -tags aix,ppc syscall_aix.go syscall_aix_ppc.go"
"// go run mksyscall_aix_ppc64.go -aix -tags aix,ppc64 syscall_aix.go syscall_aix_ppc64.go"
"// go run mksyscall_solaris.go -illumos -tags illumos,amd64 syscall_illumos.go"
"// go run mksyscall_solaris.go -tags solaris,amd64 syscall_solaris.go syscall_solaris_amd64.go"
"// got less than three, pad it with 0s. This is to cover the basic"
"// got will be trustworthy with ETIME, but not any other error."
"// greater than the number of bytes in b, the boolean will be false."
"// groupStatus format is the list of flags as a unique ID,"
"// gstring reads a string from b, prefixed with a 16-bit length in little-endian order."
"// handleKey processes the given key and, optionally, returns a line of text"
"// helpCommand is command with usage 'help'. If it's not defined by user,"
"// historyIndex stores the currently accessed history entry, where zero"
"// if a DACL exists but is an ""empty DACL"", meaning fully permissive. If the DACL does not exist, err returns"
"// if a SACL exists but is an ""empty SACL"", meaning fully permissive. If the SACL does not exist, err returns"
"// if a command is runnable, deprecated, or hidden it is not a 'help' command"
"// if a part is empty, we use the other to decide"
"// if an empty UUID comes from a table, we return a null UUID"
"// if any non-help sub commands are found, the command is not a 'help' command"
"// if not, it means that Other has to be greater than Self"
"// if parts are equals, continue the loop"
"// if required packages aren't installed, we may be able to install them with package kit..."
"// if we got this far, they're equal"
"// implementation of removexattr, we do so for interoperability with the"
"// import ""golang.org/x/sys/plan9"""
"// import ""golang.org/x/sys/unix"""
"// import ""golang.org/x/sys/windows"""
"// in CreateProcess's CommandLine argument, CreateService/ChangeServiceConfig's BinaryPathName argument,"
"// in primordial order if f.SortFlags is false, calling fn for each."
"// in the form of ""{XXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}""."
"// in the structure. To be on the safe side, we"
"// in their user documentation, and users will be using them explicitly."
"// includes (linux/if_pppox.h includes linux/in.h, which conflicts"
"// information. Therefore, ambiguities in the version string such as"
"// inspired by go, go-Commander, gh and subcommand"
"// instead of the glibc-specific ""CALL 0x10(GS)""."
"// int32, so the fields' value must be modified."
"// integer value on fd, using the specified request number. The ioctl"
"// ioctl itself should not be exposed directly, but additional get/set functions"
"// ioctl itself should not be exposed directly, but additional get/set"
"// is accepted, but has no address."
"// is set to ""0""."
"// it in our own nicer implementation, either here or in"
"// it with ProcThreadAttributeListContainer.Update, free its memory using"
"// kernel32.dll is special, since it's where LoadLibraryEx comes from."
"// key handle permission mask as described in the ""keyctl setperm"" section of"
"// len(args) when a '--' was located when parsing, or -1 if no --"
"// length is family (uint16), name, NUL."
"// like C faccessat, we do the same."
"// linux implementation, we wrap around the system calls and pass in NULL when"
"// linux system call, specifically the position parameter:"
"// list from its existing class driver list, instead of the normal INF search."
"// location, it returns (nil, EINVAL)."
"// location, it returns (nil, syscall.EINVAL)."
"// lookup returns the Flag structure of the named flag, returning nil if none exists."
"// lowercase first letter: Bad -> bad, but STREAM -> STREAM."
"// makeAbsoluteSD is expected to fail, but it succeeds."
"// makeSelfRelativeSD is expected to fail, but it succeeds."
"// missing constants on FreeBSD-11.1-RELEASE, copied from old values in ztypes_freebsd_arm.go"
"// misuse, so pass the raw *ifreq directly."
"// mkerrors.sh' ""$@"""
"// more information, see:"
"// name of the type.  As this is generally unknown, we approximate that with"
"// next most recent, and so on. If such an element doesn't exist then ok is"
"// no subcommand, always take args"
"// of keyring permissions. The command requires the ""setattr"" permission."
"// of strings by giving the slice the methods of Value; in particular, Set would"
"// of values.  This allows full control over the value of list flags,"
"// on fd, using the specified request number."
"// on the purposes of the fields, check the official linux kernel documentation"
"// openshift admin policy add-role-to-user admin my-user, lose the admin argument (arg[4])."
"// or a parent, or it returns a default usage function."
"// or a parent, or it returns a function with default help behavior."
"// or a string, to specify a resource or resource type by name."
"// or larger than the other version, respectively."
"// originally tried to generate it via unix/linux/types.go with ""type"
"// otherwise, the default values of all defined flags in the set."
"// out of that file, it's cleaner to just define it by hand here."
"// own sysctl wrappers. Provide it here, even though direct syscalls are no"
"// pastes. Additionally, any lines that are completely pasted will be returned"
"// path. To work around that, return ENOENT if path is not absolute."
"// perform SHA1 hashing. The descriptor is not safe for concurrent use, but"
"// pipe2 on dragonfly takes an fds array as an argument, but still"
"// portable interface to the system, such as ""os"", ""time"" and ""net"".  Use"
"// potential whitespace, `v` prefix, etc."
"// prefixed zeroes (1.04.0 => 1.4.0), `v` prefix (v1.0.0 => 1.0.0), and"
"// previously set context will be returned. Otherwise, nil is returned."
"// primitives. OS details vary depending on the underlying system, and"
"// prior security descriptor to be merged, any of which can be nil, returning the self-relative security descriptor"
"// prioritize the named flag when performing completion,"
"// prioritize the named persistent flag when performing completion,"
"// process ([""USER=go"", ""PWD=/tmp""])."
"// process. If inheritExisting is true, then this environment also inherits the"
"// pstring copies the string s to b, prepending it with a 16-bit length in little-endian order, and"
"// refers to a location in a different process' address space, which"
"// registration, installation, and deletion."
"// releases predating 6.3, otherwise an error will be returned."
"// requested by ClockSequence, GetTime, or NewUUID.  (section 4.2.1.1)"
"// return syscall.Handle and syscall.Errno, but these are the same, in fact,"
"// returning (Constraints, error) and panics if error is non-nil."
"// returns -1, 0, or 1 if this version is smaller, equal,"
"// root command in upper case, with all - replaced by _."
"// root command with subcommands, do subcommand checking."
"// round x to the nearest multiple of y, larger or equal to x."
"// s, with a terminating NUL added. If s contains a NUL byte at any"
"// same unsafe pointer cast as above, because this value is not"
"// segments of the version, without prerelease or metadata."
"// sequence without knowing them all, but it seems that [a-zA-Z~] only"
"// sequence, and the current time.  If the NodeID has not been set by SetNodeID"
"// should specify a single directory name within which to search. For example,"
"// since Epoch (00:00:00 UTC, January 1, 1970)."
"// sizeof_field(struct hid_device, name)"
"// sizeof_field(struct hid_device, phys)"
"// sizeof_field(struct hid_device, uniq)"
"// sockaddr ioctls. For convenience, we expose these as Inet4Addr since the Port"
"// somehow Iovec.Base on illumos is (*int8), not (*byte)"
"// specified as the path for futimesat. However, Go doesn't like"
"// structure, taking into account any necessary alignment."
"// subtract leading Family, Len"
"// subtract leading Family, Len, terminating NUL."
"// supplied without ""=value"" text"
"// syscall needs to be called twice; however, this is unnecessary as"
"// system, set $GOOS and $GOARCH to the desired system. For example, if"
"// systems, hi will always be 0. On 32-bit systems, offs will be split in half."
"// that yet on their system, so emulate it."
"// the FOLDERID_ constants, and chosen and optionally created based on a KF_ flag."
"// the UTF-8 string s, with a terminating NUL added. If s"
"// the array.  Each time this function is called with the same array, the new"
"// the command either has no sub commands, or no available 'help' sub commands"
"// the command either has no sub commands, or no available (non deprecated/help/hidden)"
"// the command either has no sub commands, or no non-help sub commands"
"// the incomplete, initial line. That value is stored in"
"// the index, which must be less than sid.SubAuthorityCount()."
"// the last time a UUID was generated.  Unless SetClockSequence is used, a new"
"// the prerelease information is ""beta""."
"// the two paths are each one uint16 short. Use the correct struct,"
"// them an empty string of data, rather than NULL."
"// there are no interfaces) then """", nil is returned."
"// they use to decide if a flag should get ""true"" when no arg is given."
"// this index is less than the constraints segment at this index, then it cannot"
"// thus the otherwise seemingly extraneous ""cookies"" map"
"// tmpl executes the given template text on data, writing the result to w."
"// to complete directories within ""themes/"":"
"// to names, and the new names slice."
"// too long when shinking. Others, (e.g. gnome-terminal) will"
"// transparently. Currently, UUIDs map to strings. Please consult"
"// tree. argv0 should be the full path to an executable (""/bin/ls"") and the"
"// trying to load ""foo.dll"" out of the system"
"// type of the flag's value, or the empty string if the flag is boolean."
"// typically holds a user-defined implementation of Value. For instance, the"
"// uint16, if it is used, is supposed to be a NUL, and Go doesn't need that."
"// uint64, changed to prevent padding from being inserted"
"// unsafe.Pointer rules since the ""pointer-ness"" of data would not be"
"// up to the caller to provide a pointer to the appropriate type, cast"
"// urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx,  or """" if uuid is invalid."
"// usage calls the Usage method for the flag set, or the usage function if"
"// use GetFileType to check pipe, pipe can't do seek"
"// use is a no-op, but the compiler cannot see that it is."
"// use of this argument. For all others, position is reserved. We simply"
"// value of the flag are represented by the first argument, of type Value, which"
"// version (but before any metadata). For example, with ""1.2.3-beta"","
"// we can't download alpine, look at existing images and try to use those"
"// we should handle things gracefully. To do so, we need to keep an extra"
"// will print content of the ""Version"" variable. A shorthand ""v"" flag will also be added if the"
"// with ExecuteContext or the context was set with SetContext, the"
"// with System set to true, or use LoadLibraryEx directly."
"// with legacy systems where dev_t is 16 bits wide, encoded as MMmm. It is also"
"// with markers. Not all terminals support this but, if it is supported, then"
"// with the desired access instead, or use GetCurrentProcessToken for a"
"// works great, but that behaviour goes badly wrong in the case"
"// xterms to move upwards, which isn't great, but it avoids a"
"// you want to view documentation for freebsd/arm on linux/amd64, set $GOOS"
"// z/OS socket macros use [32-bit] sizeof(int) alignment,"
"// { caddr_t mmap(caddr_t addr, size_t len, int prot, int flags, int fd, int pad, off_t pos); }"
"// { caddr_t mmap(caddr_t addr, size_t len, int prot, int flags, int fd, off_t pos); }"
"// { caddr_t shmat(int shmid, const void *shmaddr, int shmflg); }"
"// { int __acl_aclcheck_fd(int filedes, acl_type_t type, struct acl *aclp); }"
"// { int __acl_aclcheck_file(const char *path, acl_type_t type, struct acl *aclp); }"
"// { int __acl_aclcheck_link(const char *path, acl_type_t type, struct acl *aclp); }"
"// { int __acl_delete_fd(int filedes, acl_type_t type); }"
"// { int __acl_delete_file(const char *path, acl_type_t type); }"
"// { int __acl_delete_link(const char *path, acl_type_t type); }"
"// { int __acl_get_fd(int filedes, acl_type_t type, struct acl *aclp); }"
"// { int __acl_get_file(const char *path, acl_type_t type, struct acl *aclp); }"
"// { int __acl_get_link(const char *path, acl_type_t type, struct acl *aclp); }"
"// { int __acl_set_fd(int filedes, acl_type_t type, struct acl *aclp); }"
"// { int __acl_set_file(const char *path, acl_type_t type, struct acl *aclp); }"
"// { int __acl_set_link(const char *path, acl_type_t type, struct acl *aclp); }"
"// { int __cap_rights_get(int version, int fd, cap_rights_t *rightsp); }"
"// { int __getcwd(char *buf, u_int buflen); }"
"// { int __getcwd(u_char *buf, u_int buflen); }"
"// { int __mac_execve(char *fname, char **argv, char **envv, struct mac *mac_p); }"
"// { int __mac_get_fd(int fd, struct mac *mac_p); }"
"// { int __mac_get_file(const char *path_p, struct mac *mac_p); }"
"// { int __mac_get_link(const char *path_p, struct mac *mac_p); }"
"// { int __mac_get_pid(pid_t pid, struct mac *mac_p); }"
"// { int __mac_set_fd(int fd, struct mac *mac_p); }"
"// { int __mac_set_file(const char *path_p, struct mac *mac_p); }"
"// { int __mac_set_link(const char *path_p, struct mac *mac_p); }"
"// { int __semctl(int semid, int semnum, int cmd, union semun *arg); }"
"// { int __sysctl(int *name, u_int namelen, void *old, size_t *oldlenp, void *new, size_t newlen); } __sysctl sysctl_args int"
"// { int _umtx_op(void *obj, int op, u_long val, void *uaddr1, void *uaddr2); }"
"// { int abort2(const char *why, int nargs, void **args); }"
"// { int accept(int s, caddr_t name, int *anamelen); }"
"// { int accept(int s, struct sockaddr * __restrict name, __socklen_t * __restrict anamelen); }"
"// { int accept4(int s, caddr_t name, int *anamelen, int flags); }"
"// { int accept4(int s, struct sockaddr * __restrict name, __socklen_t * __restrict anamelen, int flags); }"
"// { int access(char *path, int amode); }"
"// { int access(char *path, int flags); }"
"// { int adjtime(struct timeval *delta, struct timeval *olddelta); }"
"// { int aio_cancel(int fd, struct aiocb *aiocbp); }"
"// { int aio_fsync(int op, struct aiocb *aiocbp); }"
"// { int aio_suspend( struct aiocb * const * aiocbp, int nent, const struct timespec *timeout); }"
"// { int aio_suspend(struct aiocb * const * aiocbp, int nent, const struct timespec *timeout); }"
"// { int aio_waitcomplete(struct aiocb **aiocbp, struct timespec *timeout); }"
"// { int audit(const void *record, u_int length); }"
"// { int auditon(int cmd, void *data, u_int length); }"
"// { int bind(int s, caddr_t name, int namelen); }"
"// { int bindat(int fd, int s, caddr_t name, int namelen); }"
"// { int cap_fcntls_get(int fd, uint32_t *fcntlrightsp); }"
"// { int cap_fcntls_limit(int fd, uint32_t fcntlrights); }"
"// { int cap_ioctls_limit(int fd, const u_long *cmds, size_t ncmds); }"
"// { int cap_rights_limit(int fd, cap_rights_t *rightsp); }"
"// { int chflags(const char *path, u_long flags); }"
"// { int chflagsat(int fd, const char *path, u_long flags, int atflag); }"
"// { int chflagsat(int fd, const char *path, u_long flags, int atflags);}"
"// { int chmod(char *path, int mode); }"
"// { int chown(char *path, int uid, int gid); }"
"// { int clock_getcpuclockid2(id_t id,int which, clockid_t *clock_id); }"
"// { int clock_getres(clockid_t clock_id, struct timespec *tp); }"
"// { int clock_gettime(clockid_t clock_id, struct timespec *tp); }"
"// { int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *rqtp, struct timespec *rmtp); }"
"// { int clock_settime( clockid_t clock_id, const struct timespec *tp); }"
"// { int clock_settime(clockid_t clock_id, const struct timespec *tp); }"
"// { int connect(int s, caddr_t name, int namelen); }"
"// { int connectat(int fd, int s, caddr_t name, int namelen); }"
"// { int cpuset_getaffinity(cpulevel_t level, cpuwhich_t which, id_t id, size_t cpusetsize, cpuset_t *mask); }"
"// { int cpuset_getid(cpulevel_t level, cpuwhich_t which, id_t id, cpusetid_t *setid); }"
"// { int cpuset_setaffinity(cpulevel_t level, cpuwhich_t which, id_t id, size_t cpusetsize, const cpuset_t *mask); }"
"// { int cpuset_setid(cpuwhich_t which, id_t id, cpusetid_t setid); }"
"// { int dup2(int from, int to); }"
"// { int dup2(u_int from, u_int to); }"
"// { int eaccess(char *path, int amode); }"
"// { int eaccess(char *path, int flags); }"
"// { int execve(char *fname, char **argv, char **envv); }"
"// { int extaccept(int s, int flags, caddr_t name, int *anamelen); }"
"// { int extattr_delete_fd(int fd, int attrnamespace, const char *attrname); }"
"// { int extattr_delete_file(const char *path, int attrnamespace, const char *attrname); }"
"// { int extattr_delete_link( const char *path, int attrnamespace, const char *attrname); }"
"// { int extattr_get_file(const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes); }"
"// { int extattr_set_file(const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes); }"
"// { int extattrctl(const char *path, int cmd, const char *filename, int attrnamespace, const char *attrname); }"
"// { int extconnect(int s, int flags, caddr_t name, int namelen); }"
"// { int faccessat(int fd, char *path, int amode, int flag); }"
"// { int faccessat(int fd, char *path, int amode, int flags); }"
"// { int fchflags(int fd, u_long flags); }"
"// { int fchmod(int fd, int mode); }"
"// { int fchmodat(int fd, char *path, int mode, int flags); }"
"// { int fchmodat(int fd, char *path, mode_t mode, int flag); }"
"// { int fchown(int fd, int uid, int gid); }"
"// { int fchownat(int fd, char *path, int uid, int gid, int flags); }"
"// { int fchownat(int fd, char *path, uid_t uid, gid_t gid, int flag); }"
"// { int fcntl(int fd, int cmd, long arg); }"
"// { int fexecve(int fd, char **argv, char **envv); }"
"// { int fhopen(const struct fhandle *u_fhp, int flags); }"
"// { int fhstat(const struct fhandle *u_fhp, struct stat *sb); }"
"// { int fhstatfs(const struct fhandle *u_fhp, struct statfs *buf); }"
"// { int fhstatvfs(const struct fhandle *u_fhp, struct statvfs *buf); }"
"// { int flock(int fd, int how); }"
"// { int fpathconf(int fd, int name); }"
"// { int fstat(int fd, _Out_ struct stat *sb); }"
"// { int fstat(int fd, struct stat *sb); }"
"// { int fstatat(int fd, _In_z_ char *path, \"
"// { int fstatat(int fd, char *path, 	struct stat *sb, int flags); }"
"// { int fstatat(int fd, char *path, struct stat *buf, int flag); }"
"// { int fstatfs(int fd, \"
"// { int fstatfs(int fd, struct statfs *buf); }"
"// { int fstatvfs(int fd, struct statvfs *buf); }"
"// { int ftruncate(int fd, int pad, off_t length); }"
"// { int ftruncate(int fd, off_t length); }"
"// { int futimens(int fd, const struct timespec *ts); }"
"// { int futimens(int fd, struct timespec *times); }"
"// { int futimes(int fd, struct timeval *tptr); }"
"// { int futimesat(int fd, char *path, struct timeval *times); }"
"// { int get_tls_area(int which, struct tls_info *info, size_t infosize); }"
"// { int getaudit_addr( struct auditinfo_addr *auditinfo_addr, u_int length); }"
"// { int getcpuclockid(pid_t pid, lwpid_t lwp_id, clockid_t *clock_id); }"
"// { int getdents(int fd, char *buf, size_t count); }"
"// { int getdirentries(int fd, char *buf, u_int count, long *basep); }"
"// { int getfh(char *fname, struct fhandle *fhp); }"
"// { int getfsstat(struct statfs *buf, long bufsize, int flags); }"
"// { int getfsstat(struct statfs *buf, long bufsize, int mode); }"
"// { int getgroups(u_int gidsetsize, gid_t *gidset); }"
"// { int getitimer(u_int which, struct itimerval *itv); }"
"// { int getlogin(char *namebuf, size_t namelen); }"
"// { int getlogin(char *namebuf, u_int namelen); }"
"// { int getloginclass(char *namebuf, size_t namelen); }"
"// { int getpeername(int fdes, caddr_t asa, int *alen); }"
"// { int getpeername(int fdes, struct sockaddr * __restrict asa, __socklen_t * __restrict alen); }"
"// { int getpriority(int which, int who); }"
"// { int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid); }"
"// { int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid); }"
"// { int getrlimit(u_int which, struct rlimit *rlp); } getrlimit __getrlimit_args int"
"// { int getrusage(int who, struct rusage *rusage); }"
"// { int getsockname(int fdes, caddr_t asa, int *alen); }"
"// { int getsockname(int fdes, struct sockaddr * __restrict asa, __socklen_t * __restrict alen); }"
"// { int getsockopt(int s, int level, int name, caddr_t val, int *avalsize); }"
"// { int gettimeofday(struct timeval *tp, struct timezone *tzp); }"
"// { int getvfsstat(struct statfs *buf,          struct statvfs *vbuf, long vbufsize, int flags); }"
"// { int ioctl(int fd, u_long com, caddr_t data); }"
"// { int ioprio_get(int which, int who); }"
"// { int ioprio_set(int which, int who, int prio); }"
"// { int jail_get(struct iovec *iovp, unsigned int iovcnt, int flags); }"
"// { int jail_set(struct iovec *iovp, unsigned int iovcnt, int flags); }"
"// { int kenv(int what, const char *name, char *value, int len); }"
"// { int kevent(int fd, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout); }"
"// { int kevent(int fd, struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout); }"
"// { int kill(int pid, int signum); }"
"// { int kldstat(int fileid, struct kld_file_stat* stat); }"
"// { int kldsym(int fileid, int cmd, void *data); }"
"// { int kldunloadf(int fileid, int flags); }"
"// { int kmq_notify(int mqd,		const struct sigevent *sigev); }"
"// { int kmq_open(const char *path, int flags, mode_t mode, const struct mq_attr *attr); }"
"// { int kmq_setattr(int mqd,		const struct mq_attr *attr,		struct mq_attr *oattr); }"
"// { int kmq_timedreceive(int mqd,	char *msg_ptr, size_t msg_len,	unsigned *msg_prio,			const struct timespec *abs_timeout); }"
"// { int kmq_timedsend(int mqd,		const char *msg_ptr, size_t msg_len,unsigned msg_prio,			const struct timespec *abs_timeout);}"
"// { int ksem_getvalue(semid_t id, int *val); }"
"// { int ksem_init(semid_t *idp, unsigned int value); }"
"// { int ksem_open(semid_t *idp, const char *name, int oflag, mode_t mode, unsigned int value); }"
"// { int ksem_timedwait(semid_t id, const struct timespec *abstime); }"
"// { int ktimer_create(clockid_t clock_id, struct sigevent *evp, int *timerid); }"
"// { int ktimer_gettime(int timerid, struct itimerspec *value); }"
"// { int ktimer_settime(int timerid, int flags, const struct itimerspec *value, struct itimerspec *ovalue); }"
"// { int ktrace(const char *fname, int ops, int facs, int pid); }"
"// { int lchflags(const char *path, u_long flags); }"
"// { int lchmod(char *path, mode_t mode); }"
"// { int lchown(char *path, int uid, int gid); }"
"// { int lgetfh(char *fname, struct fhandle *fhp); }"
"// { int link(char *path, char *link); }"
"// { int linkat(int fd1, char *path1, int fd2, char *path2, int flag); }"
"// { int linkat(int fd1, char *path1, int fd2, char *path2, int flags); }"
"// { int lio_listio(int mode, struct aiocb * const *acb_list, int nent, struct sigevent *sig); }"
"// { int listen(int s, int backlog); }"
"// { int lpathconf(char *path, int name); }"
"// { int lstat(char *path, struct stat *ub); }"
"// { int lstat(const char *path, struct stat *ub); }"
"// { int lutimes(char *path, struct timeval *tptr); }"
"// { int lwp_create2(struct lwp_params *params, const cpumask_t *mask); }"
"// { int lwp_getaffinity(pid_t pid, lwpid_t tid, cpumask_t *mask); }"
"// { int lwp_getname(lwpid_t tid, char *name, size_t len); }"
"// { int lwp_kill(pid_t pid, lwpid_t tid, int signum); }"
"// { int lwp_rtprio(int function, pid_t pid, lwpid_t tid, struct rtprio *rtp); }"
"// { int lwp_setaffinity(pid_t pid, lwpid_t tid, const cpumask_t *mask); }"
"// { int lwp_setname(lwpid_t tid, const char *name); }"
"// { int mac_syscall(const char *policy, int call, void *arg); }"
"// { int madvise(void *addr, size_t len, int behav); }"
"// { int mcontrol(void *addr, size_t len, int behav, off_t value); }"
"// { int mincore(const void *addr, size_t len, char *vec); }"
"// { int minherit(void *addr, size_t len, int inherit); }"
"// { int mkdir(char *path, int mode); }"
"// { int mkdirat(int fd, char *path, mode_t mode); }"
"// { int mkfifo(char *path, int mode); }"
"// { int mkfifoat(int fd, char *path, mode_t mode); }"
"// { int mknod(char *path, int mode, int dev); }"
"// { int mknodat(int fd, _In_z_ char *path, \"
"// { int mknodat(int fd, char *path, mode_t mode, dev_t dev); }"
"// { int mlock(const void *addr, size_t len); }"
"// { int modstat(int modid, struct module_stat *stat); }"
"// { int modstat(int modid, struct module_stat* stat); }"
"// { int mount(char *type, char *path, int flags, caddr_t data); }"
"// { int mountctl(const char *path, int op, int fd, const void *ctl, int ctllen, void *buf, int buflen); }"
"// { int mprotect(const void *addr, size_t len, int prot); }"
"// { int mprotect(void *addr, size_t len, int prot); }"
"// { int mq_getattr(mqd_t mqdes, struct mq_attr *mqstat); }"
"// { int mq_notify(mqd_t mqdes, const struct sigevent *notification); }"
"// { int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio); }"
"// { int mq_setattr(mqd_t mqdes, const struct mq_attr *mqstat, struct mq_attr *omqstat); }"
"// { int mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio, const struct timespec *abs_timeout); }"
"// { int msgctl(int msqid, int cmd, struct msqid_ds *buf); }"
"// { int msgget(key_t key, int msgflg); }"
"// { int msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); }"
"// { int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); }"
"// { int msgsys(int which, int a2, int a3, int a4, int a5, int a6); }"
"// { int msync(void *addr, size_t len, int flags); }"
"// { int munlock(const void *addr, size_t len); }"
"// { int munmap(void *addr, size_t len); }"
"// { int nanosleep(const struct timespec *rqtp, struct timespec *rmtp); }"
"// { int nfssvc(int flag, caddr_t argp); }"
"// { int nfstat(int fd, struct nstat *sb); }"
"// { int nlm_syscall(int debug_level, int grace_period, int addr_count, char **addrs); }"
"// { int nlstat(char *path, struct nstat *ub); }"
"// { int nmount(struct iovec *iovp, unsigned int iovcnt, int flags); }"
"// { int nstat(char *path, struct nstat *ub); }"
"// { int numa_getaffinity(cpuwhich_t which, id_t id, struct vm_domain_policy_entry *policy); }"
"// { int numa_setaffinity(cpuwhich_t which, id_t id, const struct vm_domain_policy_entry *policy); }"
"// { int open(char *path, int flags, int mode); }"
"// { int openat(int fd, char *path, int flag, mode_t mode); }"
"// { int openat(int fd, char *path, int flags, int mode); }"
"// { int openbsd_poll(struct pollfd *fds, u_int nfds, int timeout); }"
"// { int pathconf(char *path, int name); }"
"// { int pdfork(int *fdp, int flags); }"
"// { int pdgetpid(int fd, pid_t *pidp); }"
"// { int pdkill(int fd, int signum); }"
"// { int pipe2(int *fildes, int flags); }"
"// { int poll(struct pollfd *fds, u_int nfds, int timeout); }"
"// { int posix_fadvise(int fd, off_t offset, off_t len, int advice); }"
"// { int posix_fallocate(int fd, off_t offset, off_t len); }"
"// { int ppoll(struct pollfd *fds, u_int nfds, const struct timespec *ts, const sigset_t *set); }"
"// { int ppoll(struct pollfd *fds, u_int nfds, const struct timespec *ts, const sigset_t *sigmask); }"
"// { int procctl(idtype_t idtype, id_t id, int cmd, void *data); }"
"// { int procctl(idtype_t idtype, id_t id, int com, void *data); }"
"// { int profil(caddr_t samples, size_t size, size_t offset, u_int scale); }"
"// { int profil(caddr_t samples, size_t size, u_long offset, u_int scale); }"
"// { int pselect(int nd, fd_set *in, fd_set *ou, fd_set *ex, const struct timespec *ts,    const sigset_t *sigmask); }"
"// { int pselect(int nd, fd_set *in, fd_set *ou, fd_set *ex, const struct timespec *ts, const sigset_t *sm); }"
"// { int ptrace(int req, pid_t pid, caddr_t addr, int data); }"
"// { int quotactl(char *path, int cmd, int uid, caddr_t arg); }"
"// { int rctl_add_rule(const void *inbufp, size_t inbuflen, void *outbufp, size_t outbuflen); }"
"// { int rctl_get_limits(const void *inbufp, size_t inbuflen, void *outbufp, size_t outbuflen); }"
"// { int rctl_get_racct(const void *inbufp, size_t inbuflen, void *outbufp, size_t outbuflen); }"
"// { int rctl_get_rules(const void *inbufp, size_t inbuflen, void *outbufp, size_t outbuflen); }"
"// { int rctl_remove_rule(const void *inbufp, size_t inbuflen, void *outbufp, size_t outbuflen); }"
"// { int readlink(char *path, char *buf, int count); }"
"// { int readlinkat(int fd, char *path, char *buf, size_t bufsize); }"
"// { int readv(int fd, struct iovec *iovp, u_int iovcnt); }"
"// { int recvfrom(int s, caddr_t buf, size_t len, int flags, caddr_t from, int *fromlenaddr); }"
"// { int recvfrom(int s, caddr_t buf, size_t len, int flags, struct sockaddr * __restrict from, __socklen_t * __restrict fromlenaddr); }"
"// { int recvmsg(int s, struct msghdr *msg, int flags); }"
"// { int rename(char *from, char *to); }"
"// { int renameat(int oldfd, char *old, int newfd, char *new); }"
"// { int rtprio(int function, pid_t pid, struct rtprio *rtp); }"
"// { int rtprio_thread(int function, lwpid_t lwpid, struct rtprio *rtp); }"
"// { int sched_getparam (pid_t pid, struct sched_param *param); }"
"// { int sched_rr_get_interval (pid_t pid, struct timespec *interval); }"
"// { int sched_setparam (pid_t pid, const struct sched_param *param); }"
"// { int sched_setscheduler (pid_t pid, int policy, const struct sched_param *param); }"
"// { int sctp_generic_recvmsg(int sd, struct iovec *iov, int iovlen, struct sockaddr * from, __socklen_t *fromlenaddr, struct sctp_sndrcvinfo *sinfo, int *msg_flags); }"
"// { int sctp_generic_sendmsg(int sd, caddr_t msg, int mlen, caddr_t to, __socklen_t tolen, struct sctp_sndrcvinfo *sinfo, int flags); }"
"// { int sctp_generic_sendmsg_iov(int sd, struct iovec *iov, int iovlen, caddr_t to, __socklen_t tolen, struct sctp_sndrcvinfo *sinfo, int flags); }"
"// { int sctp_peeloff(int sd, uint32_t name); }"
"// { int select(int nd, fd_set *in, fd_set *ou, fd_set *ex, struct timeval *tv); }"
"// { int semget(key_t key, int nsems, int semflg); }"
"// { int semop(int semid, struct sembuf *sops, size_t nsops); }"
"// { int semop(int semid, struct sembuf *sops, u_int nsops); }"
"// { int semsys(int which, int a2, int a3, int a4, int a5); }"
"// { int sendfile(int fd, int s, off_t offset, size_t nbytes, struct sf_hdtr *hdtr, off_t *sbytes, int flags); }"
"// { int sendmsg(int s, caddr_t msg, int flags); }"
"// { int sendmsg(int s, struct msghdr *msg, int flags); }"
"// { int sendto(int s, caddr_t buf, size_t len, int flags, caddr_t to, int tolen); }"
"// { int set_tls_area(int which, struct tls_info *info, size_t infosize); }"
"// { int setaudit_addr( struct auditinfo_addr *auditinfo_addr, u_int length); }"
"// { int setgroups(u_int gidsetsize, gid_t *gidset); }"
"// { int setitimer(u_int which, struct itimerval *itv, struct itimerval *oitv); }"
"// { int setpgid(int pid, int pgid); }"
"// { int setpriority(int which, int who, int prio); }"
"// { int setregid(int rgid, int egid); }"
"// { int setresgid(gid_t rgid, gid_t egid, gid_t sgid); }"
"// { int setresuid(uid_t ruid, uid_t euid, uid_t suid); }"
"// { int setreuid(int ruid, int euid); }"
"// { int setrlimit(u_int which, struct rlimit *rlp); } setrlimit __setrlimit_args int"
"// { int setsockopt(int s, int level, int name, caddr_t val, int valsize); }"
"// { int settimeofday(struct timeval *tv, struct timezone *tzp); }"
"// { int shm_open(const char *path, int flags, mode_t mode); }"
"// { int shmat(int shmid, const void *shmaddr, int shmflg); }"
"// { int shmctl(int shmid, int cmd, struct shmid_ds *buf); }"
"// { int shmget(key_t key, size_t size, int shmflg); }"
"// { int shmsys(int which, int a2, int a3, int a4); }"
"// { int shutdown(int s, int how); }"
"// { int sigaction(int sig, const struct sigaction *act, struct sigaction *oact); }"
"// { int sigaltstack(stack_t *ss, stack_t *oss); }"
"// { int sigprocmask(int how, const sigset_t *set, sigset_t *oset); }"
"// { int sigqueue(pid_t pid, int signum, void *value); }"
"// { int sigtimedwait(const sigset_t *set, siginfo_t *info, const struct timespec *timeout); }"
"// { int sigtimedwait(const sigset_t *set,siginfo_t *info, const struct timespec *timeout); }"
"// { int sigwait(const sigset_t *set, int *sig); }"
"// { int sigwaitinfo(const sigset_t *set, siginfo_t *info); }"
"// { int sigwaitinfo(const sigset_t *set,siginfo_t *info); }"
"// { int socket(int domain, int type, int protocol); }"
"// { int socketpair(int domain, int type, int protocol, int *rsv); }"
"// { int stat(char *path, struct stat *ub); }"
"// { int stat(const char *path, struct stat *ub); }"
"// { int statfs(_In_z_ char *path, \"
"// { int statfs(char *path, struct statfs *buf); }"
"// { int statvfs(const char *path, struct statvfs *buf); }"
"// { int swapcontext(struct __ucontext *oucp, const struct __ucontext *ucp); }"
"// { int symlink(char *path, char *link); }"
"// { int symlinkat(char *path1, int fd, char *path2); }"
"// { int sys___getcwd(char *buf, size_t len); }"
"// { int sys___realpath(const char *pathname, char *resolved); }"
"// { int sys___semctl(int semid, int semnum, int cmd, union semun *arg); }"
"// { int sys___tfork(const struct __tfork *param, size_t psize); }"
"// { int sys___thrsigdivert(sigset_t sigmask, siginfo_t *info, const struct timespec *timeout); }"
"// { int sys___thrsleep(const volatile void *ident, clockid_t clock_id, const struct timespec *tp, void *lock, const int *abort); }"
"// { int sys___thrwakeup(const volatile void *ident, int n); }"
"// { int sys_accept(int s, struct sockaddr *name, socklen_t *anamelen); }"
"// { int sys_accept4(int s, struct sockaddr *name, socklen_t *anamelen, int flags); }"
"// { int sys_access(const char *path, int amode); }"
"// { int sys_adjfreq(const int64_t *freq, int64_t *oldfreq); }"
"// { int sys_adjtime(const struct timeval *delta, struct timeval *olddelta); }"
"// { int sys_bind(int s, const struct sockaddr *name, socklen_t namelen); }"
"// { int sys_checkpoint(int type, int fd, pid_t pid, int retval); }"
"// { int sys_chflags(const char *path, u_int flags); }"
"// { int sys_chflagsat(int fd, const char *path, u_int flags, int atflags); }"
"// { int sys_chmod(const char *path, mode_t mode); }"
"// { int sys_chown(const char *path, uid_t uid, gid_t gid); }"
"// { int sys_clock_getres(clockid_t clock_id, struct timespec *tp); }"
"// { int sys_clock_gettime(clockid_t clock_id, struct timespec *tp); }"
"// { int sys_clock_settime(clockid_t clock_id, const struct timespec *tp); }"
"// { int sys_connect(int s, const struct sockaddr *name, socklen_t namelen); }"
"// { int sys_dup2(int from, int to); }"
"// { int sys_dup3(int from, int to, int flags); }"
"// { int sys_execve(const char *path, char * const *argp, char * const *envp); }"
"// { int sys_faccessat(int fd, const char *path, int amode, int flag); }"
"// { int sys_fchflags(int fd, u_int flags); }"
"// { int sys_fchmod(int fd, mode_t mode); }"
"// { int sys_fchmodat(int fd, const char *path, mode_t mode, int flag); }"
"// { int sys_fchown(int fd, uid_t uid, gid_t gid); }"
"// { int sys_fchownat(int fd, const char *path, uid_t uid, gid_t gid, int flag); }"
"// { int sys_fcntl(int fd, int cmd, ... void *arg); }"
"// { int sys_fhopen(const fhandle_t *fhp, int flags); }"
"// { int sys_fhstat(const fhandle_t *fhp, struct stat *sb); }"
"// { int sys_fhstatfs(const fhandle_t *fhp, struct statfs *buf); }"
"// { int sys_flock(int fd, int how); }"
"// { int sys_fstat(int fd, struct stat *sb); }"
"// { int sys_fstatat(int fd, const char *path, struct stat *buf, int flag); }"
"// { int sys_fstatfs(int fd, struct statfs *buf); }"
"// { int sys_ftruncate(int fd, int pad, off_t length); }"
"// { int sys_futex(uint32_t *f, int op, int val, const struct timespec *timeout, uint32_t *g); }"
"// { int sys_futimens(int fd, const struct timespec *times); }"
"// { int sys_futimes(int fd, const struct timeval *tptr); }"
"// { int sys_getdents(int fd, void *buf, size_t buflen); }"
"// { int sys_getentropy(void *buf, size_t nbyte); }"
"// { int sys_getfh(const char *fname, fhandle_t *fhp); }"
"// { int sys_getfsstat(struct statfs *buf, size_t bufsize, int flags); }"
"// { int sys_getgroups(int gidsetsize, gid_t *gidset); }"
"// { int sys_getitimer(int which, struct itimerval *itv); }"
"// { int sys_getlogin_r(char *namebuf, u_int namelen); }"
"// { int sys_getpeername(int fdes, struct sockaddr *asa, socklen_t *alen); }"
"// { int sys_getpriority(int which, id_t who); }"
"// { int sys_getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid); }"
"// { int sys_getresuid(uid_t *ruid, uid_t *euid, uid_t *suid); }"
"// { int sys_getrlimit(int which, struct rlimit *rlp); }"
"// { int sys_getrusage(int who, struct rusage *rusage); }"
"// { int sys_getsockname(int fdes, struct sockaddr *asa, socklen_t *alen); }"
"// { int sys_getsockopt(int s, int level, int name, void *val, socklen_t *avalsize); }"
"// { int sys_gettimeofday(struct timeval *tp, struct timezone *tzp); }"
"// { int sys_ioctl(int fd, u_long com, ... void *data); }"
"// { int sys_kbind(const struct __kbind *param, size_t psize, int64_t proc_cookie); }"
"// { int sys_kevent(int fd, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout); }"
"// { int sys_kill(int pid, int signum); }"
"// { int sys_ktrace(const char *fname, int ops, int facs, pid_t pid); }"
"// { int sys_lchown(const char *path, uid_t uid, gid_t gid); }"
"// { int sys_link(const char *path, const char *link); }"
"// { int sys_linkat(int fd1, const char *path1, int fd2, const char *path2, int flag); }"
"// { int sys_listen(int s, int backlog); }"
"// { int sys_lstat(const char *path, struct stat *ub); }"
"// { int sys_madvise(void *addr, size_t len, int behav); }"
"// { int sys_mincore(void *addr, size_t len, char *vec); }"
"// { int sys_minherit(void *addr, size_t len, int inherit); }"
"// { int sys_mkdir(const char *path, mode_t mode); }"
"// { int sys_mkdirat(int fd, const char *path, mode_t mode); }"
"// { int sys_mkfifo(const char *path, mode_t mode); }"
"// { int sys_mkfifoat(int fd, const char *path, mode_t mode); }"
"// { int sys_mknod(const char *path, mode_t mode, dev_t dev); }"
"// { int sys_mknodat(int fd, const char *path, mode_t mode, dev_t dev); }"
"// { int sys_mlock(const void *addr, size_t len); }"
"// { int sys_mount(const char *type, const char *path, int flags, void *data); }"
"// { int sys_mprotect(void *addr, size_t len, int prot); }"
"// { int sys_msgctl(int msqid, int cmd, struct msqid_ds *buf); }"
"// { int sys_msgget(key_t key, int msgflg); }"
"// { int sys_msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); }"
"// { int sys_msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); }"
"// { int sys_msync(void *addr, size_t len, int flags); }"
"// { int sys_msyscall(void *addr, size_t len); }"
"// { int sys_munlock(const void *addr, size_t len); }"
"// { int sys_munmap(void *addr, size_t len); }"
"// { int sys_nanosleep(const struct timespec *rqtp, struct timespec *rmtp); }"
"// { int sys_nfssvc(int flag, void *argp); }"
"// { int sys_open(const char *path, int flags, ... mode_t mode); }"
"// { int sys_openat(int fd, const char *path, int flags, ... mode_t mode); }"
"// { int sys_pipe2(int *fdp, int flags); }"
"// { int sys_pledge(const char *promises, const char *execpromises); }"
"// { int sys_poll(struct pollfd *fds, u_int nfds, int timeout); }"
"// { int sys_ppoll(struct pollfd *fds, u_int nfds, const struct timespec *ts, const sigset_t *mask); }"
"// { int sys_profil(caddr_t samples, size_t size, u_long offset, u_int scale); }"
"// { int sys_pselect(int nd, fd_set *in, fd_set *ou, fd_set *ex, const struct timespec *ts, const sigset_t *mask); }"
"// { int sys_ptrace(int req, pid_t pid, caddr_t addr, int data); }"
"// { int sys_quotactl(const char *path, int cmd, int uid, char *arg); }"
"// { int sys_rename(const char *from, const char *to); }"
"// { int sys_renameat(int fromfd, const char *from, int tofd, const char *to); }"
"// { int sys_select(int nd, fd_set *in, fd_set *ou, fd_set *ex, struct timeval *tv); }"
"// { int sys_semget(key_t key, int nsems, int semflg); }"
"// { int sys_semop(int semid, struct sembuf *sops, size_t nsops); }"
"// { int sys_sendsyslog(const char *buf, size_t nbyte, int flags); }"
"// { int sys_setgroups(int gidsetsize, const gid_t *gidset); }"
"// { int sys_setitimer(int which, const struct itimerval *itv, struct itimerval *oitv); }"
"// { int sys_setpgid(pid_t pid, pid_t pgid); }"
"// { int sys_setpriority(int which, id_t who, int prio); }"
"// { int sys_setregid(gid_t rgid, gid_t egid); }"
"// { int sys_setresgid(gid_t rgid, gid_t egid, gid_t sgid); }"
"// { int sys_setresuid(uid_t ruid, uid_t euid, uid_t suid); }"
"// { int sys_setreuid(uid_t ruid, uid_t euid); }"
"// { int sys_setrlimit(int which, const struct rlimit *rlp); }"
"// { int sys_setsockopt(int s, int level, int name, const void *val, socklen_t valsize); }"
"// { int sys_settimeofday(const struct timeval *tv, const struct timezone *tzp); }"
"// { int sys_shmctl(int shmid, int cmd, struct shmid_ds *buf); }"
"// { int sys_shmget(key_t key, size_t size, int shmflg); }"
"// { int sys_shutdown(int s, int how); }"
"// { int sys_sigaction(int signum, const struct sigaction *nsa, struct sigaction *osa); }"
"// { int sys_sigaltstack(const struct sigaltstack *nss, struct sigaltstack *oss); }"
"// { int sys_sigprocmask(int how, sigset_t mask); }"
"// { int sys_socket(int domain, int type, int protocol); }"
"// { int sys_socketpair(int domain, int type, int protocol, int *rsv); }"
"// { int sys_stat(const char *path, struct stat *ub); }"
"// { int sys_statfs(const char *path, struct statfs *buf); }"
"// { int sys_swapctl(int cmd, const void *arg, int misc); }"
"// { int sys_symlink(const char *path, const char *link); }"
"// { int sys_symlinkat(const char *path, int fd, const char *link); }"
"// { int sys_sysarch(int op, void *parms); }"
"// { int sys_sysctl(const int *name, u_int namelen, void *old, size_t *oldlenp, void *new, size_t newlen); }"
"// { int sys_thrkill(pid_t tid, int signum, void *tcb); }"
"// { int sys_truncate(const char *path, int pad, off_t length); }"
"// { int sys_unlinkat(int fd, const char *path, int flag); }"
"// { int sys_unmount(const char *path, int flags); }"
"// { int sys_unveil(const char *path, const char *permissions); }"
"// { int sys_utimensat(int fd, const char *path, const struct timespec *times, int flag); }"
"// { int sys_utimes(const char *path, const struct timeval *tptr); }"
"// { int sys_utrace(const char *label, const void *addr, size_t len); }"
"// { int sysarch(int op, char *parms); }"
"// { int thr_create(ucontext_t *ctx, long *id, int flags); }"
"// { int thr_kill(long id, int sig); }"
"// { int thr_kill2(pid_t pid, long id, int sig); }"
"// { int thr_new(struct thr_param *param, int param_size); }"
"// { int thr_set_name(long id, const char *name); }"
"// { int truncate(char *path, int pad, off_t length); }"
"// { int truncate(char *path, off_t length); }"
"// { int umtx_sleep(volatile const int *ptr, int value, int timeout); }"
"// { int umtx_wakeup(volatile const int *ptr, int count); }"
"// { int unlinkat(int fd, char *path, int flag); }"
"// { int unlinkat(int fd, char *path, int flags); }"
"// { int unmount(char *path, int flags); }"
"// { int usched_set(pid_t pid, int cmd, void *data, int bytes); }"
"// { int utimensat(int fd, char *path, struct timespec *times, int flag); }"
"// { int utimensat(int fd, const char *path, const struct timespec *ts, int flags); }"
"// { int utimes(char *path, struct timeval *tptr); }"
"// { int utrace(const void *addr, size_t len); }"
"// { int uuidgen(struct uuid *store, int count); }"
"// { int varsym_get(int mask, const char *wild, char *buf, int bufsize); }"
"// { int varsym_list(int level, char *buf, int maxsize, int *marker); }"
"// { int varsym_set(int level, const char *name, const char *data); }"
"// { int vmm_guest_ctl(int op, struct vmm_guest_options *options); }"
"// { int vmm_guest_sync_addr(long *dstaddr, long *srcaddr); }"
"// { int vmspace_create(void *id, int type, void *data); }"
"// { int vmspace_ctl(void *id, int cmd, 		struct trapframe *tframe,	struct vextframe *vframe); }"
"// { int vmspace_mcontrol(void *id, void *addr, 	size_t len, int behav, off_t value); }"
"// { int vmspace_mmap(void *id, void *addr, size_t len, int prot, int flags, int fd, off_t offset); }"
"// { int vmspace_munmap(void *id, void *addr,	size_t len); }"
"// { int vquotactl(const char *path, struct plistref *pref); }"
"// { int wait4(int pid, int *status, int options, struct rusage *rusage); } wait4 wait_args int"
"// { int wait4(int pid, int *status, int options, struct rusage *rusage); }"
"// { int wait6(idtype_t idtype, id_t id, int *status, int options, struct __wrusage *wrusage, siginfo_t *info); }"
"// { int writev(int fd, struct iovec *iovp, u_int iovcnt); }"
"// { int, short, short } in poll.h"
"// { int|sys|13|msync(void *addr, size_t len, int flags); }"
"// { int|sys|30|getdents(int fd, char *buf, size_t count); }"
"// { int|sys|30|getfh(const char *fname, void *fhp, size_t *fh_size); }"
"// { int|sys|30|socket(int domain, int type, int protocol); }"
"// { int|sys|50|__semctl(int semid, int semnum, int cmd, ... union __semun *arg); }"
"// { int|sys|50|__sigtimedwait(const sigset_t *set, siginfo_t *info, struct timespec *timeout); }"
"// { int|sys|50|_lwp_park(const struct timespec *ts, lwpid_t unpark, const void *hint, const void *unparkhint); }"
"// { int|sys|50|adjtime(const struct timeval *delta, struct timeval *olddelta); }"
"// { int|sys|50|clock_getres(clockid_t clock_id, struct timespec *tp); }"
"// { int|sys|50|clock_gettime(clockid_t clock_id, struct timespec *tp); }"
"// { int|sys|50|clock_settime(clockid_t clock_id, const struct timespec *tp); }"
"// { int|sys|50|fhstat(const void *fhp, size_t fh_size, struct stat *sb); }"
"// { int|sys|50|fstat(int fd, struct stat *sb); }"
"// { int|sys|50|futimes(int fd, const struct timeval *tptr); }"
"// { int|sys|50|getitimer(int which, struct itimerval *itv); }"
"// { int|sys|50|getrusage(int who, struct rusage *rusage); }"
"// { int|sys|50|gettimeofday(struct timeval *tp, void *tzp); }"
"// { int|sys|50|kevent(int fd, const struct kevent *changelist, size_t nchanges, struct kevent *eventlist, size_t nevents, const struct timespec *timeout); }"
"// { int|sys|50|lstat(const char *path, struct stat *ub); }"
"// { int|sys|50|lutimes(const char *path, const struct timeval *tptr); }"
"// { int|sys|50|mknod(const char *path, mode_t mode, dev_t dev); }"
"// { int|sys|50|mount(const char *type, const char *path, int flags, void *data, size_t data_len); }"
"// { int|sys|50|msgctl(int msqid, int cmd, struct msqid_ds *buf); }"
"// { int|sys|50|nanosleep(const struct timespec *rqtp, struct timespec *rmtp); }"
"// { int|sys|50|pollts(struct pollfd *fds, u_int nfds, const struct timespec *ts, const sigset_t *mask); }"
"// { int|sys|50|posix_fadvise(int fd, int PAD, off_t offset, off_t len, int advice); }"
"// { int|sys|50|pselect(int nd, fd_set *in, fd_set *ou, fd_set *ex, const struct timespec *ts, const sigset_t *mask); }"
"// { int|sys|50|select(int nd, fd_set *in, fd_set *ou, fd_set *ex, struct timeval *tv); }"
"// { int|sys|50|setitimer(int which, const struct itimerval *itv, struct itimerval *oitv); }"
"// { int|sys|50|settimeofday(const struct timeval *tv, const void *tzp); }"
"// { int|sys|50|shmctl(int shmid, int cmd, struct shmid_ds *buf); }"
"// { int|sys|50|stat(const char *path, struct stat *ub); }"
"// { int|sys|50|timer_gettime(timer_t timerid, struct itimerspec *value); }"
"// { int|sys|50|timer_settime(timer_t timerid, int flags, const struct itimerspec *value, struct itimerspec *ovalue); }"
"// { int|sys|50|utimes(const char *path, const struct timeval *tptr); }"
"// { int|sys|50|wait4(pid_t pid, int *status, int options, struct rusage *rusage); }"
"// { int|sys||__getcwd(char *bufp, size_t length); }"
"// { int|sys||__getlogin(char *namebuf, size_t namelen); }"
"// { int|sys||__posix_chown(const char *path, uid_t uid, gid_t gid); }"
"// { int|sys||__posix_fchown(int fd, uid_t uid, gid_t gid); }"
"// { int|sys||__posix_lchown(const char *path, uid_t uid, gid_t gid); }"
"// { int|sys||__posix_rename(const char *from, const char *to); }"
"// { int|sys||__quotactl(const char *path, struct quotactl_args *args); }"
"// { int|sys||__sigaction_sigtramp(int signum, const struct sigaction *nsa, struct sigaction *osa, const void *tramp, int vers); }"
"// { int|sys||__sysctl(const int *name, u_int namelen, void *old, size_t *oldlenp, const void *new, size_t newlen); }"
"// { int|sys||_lwp_create(const struct __ucontext *ucp, u_long flags, lwpid_t *new_lwp); }"
"// { int|sys||_lwp_ctl(int features, struct lwpctl **address); }"
"// { int|sys||_lwp_getname(lwpid_t target, char *name, size_t len); }"
"// { int|sys||_lwp_kill(lwpid_t target, int signo); }"
"// { int|sys||_lwp_setname(lwpid_t target, const char *name); }"
"// { int|sys||_lwp_unpark(lwpid_t target, const void *hint); }"
"// { int|sys||_lwp_wait(lwpid_t wait_for, lwpid_t *departed); }"
"// { int|sys||_pset_bind(idtype_t idtype, id_t first_id, id_t second_id, psetid_t psid, psetid_t *opsid); }"
"// { int|sys||_sched_getaffinity(pid_t pid, lwpid_t lid, size_t size, cpuset_t *cpuset); }"
"// { int|sys||_sched_getparam(pid_t pid, lwpid_t lid, int *policy, struct sched_param *params); }"
"// { int|sys||_sched_setaffinity(pid_t pid, lwpid_t lid, size_t size, const cpuset_t *cpuset); }"
"// { int|sys||_sched_setparam(pid_t pid, lwpid_t lid, int policy, const struct sched_param *params); }"
"// { int|sys||accept(int s, struct sockaddr *name, socklen_t *anamelen); }"
"// { int|sys||access(const char *path, int flags); }"
"// { int|sys||bind(int s, const struct sockaddr *name, socklen_t namelen); }"
"// { int|sys||chflags(const char *path, u_long flags); }"
"// { int|sys||chmod(const char *path, mode_t mode); }"
"// { int|sys||chown(const char *path, uid_t uid, gid_t gid); }"
"// { int|sys||connect(int s, const struct sockaddr *name, socklen_t namelen); }"
"// { int|sys||dup2(int from, int to); }"
"// { int|sys||dup3(int from, int to, int flags); }"
"// { int|sys||execve(const char *path, char * const *argp, char * const *envp); }"
"// { int|sys||extattr_delete_fd(int fd, int attrnamespace, const char *attrname); }"
"// { int|sys||extattr_delete_file(const char *path, int attrnamespace, const char *attrname); }"
"// { int|sys||extattr_delete_link(const char *path, int attrnamespace, const char *attrname); }"
"// { int|sys||extattr_set_fd(int fd, int attrnamespace, const char *attrname, const void *data, size_t nbytes); }"
"// { int|sys||extattr_set_file(const char *path, int attrnamespace, const char *attrname, const void *data, size_t nbytes); }"
"// { int|sys||extattr_set_link(const char *path, int attrnamespace, const char *attrname, const void *data, size_t nbytes); }"
"// { int|sys||extattrctl(const char *path, int cmd, const char *filename, int attrnamespace, const char *attrname); }"
"// { int|sys||faccessat(int fd, const char *path, int amode, int flag); }"
"// { int|sys||fchflags(int fd, u_long flags); }"
"// { int|sys||fchmod(int fd, mode_t mode); }"
"// { int|sys||fchmodat(int fd, const char *path, mode_t mode, int flag); }"
"// { int|sys||fchown(int fd, uid_t uid, gid_t gid); }"
"// { int|sys||fchownat(int fd, const char *path, uid_t owner, gid_t group, int flag); }"
"// { int|sys||fcntl(int fd, int cmd, ... void *arg); }"
"// { int|sys||fexecve(int fd, char * const *argp, char * const *envp); }"
"// { int|sys||fgetxattr(int fd, const char *name, void *value, size_t size); }"
"// { int|sys||fktrace(int fd, int ops, int facs, pid_t pid); }"
"// { int|sys||flistxattr(int fd, char *list, size_t size); }"
"// { int|sys||flock(int fd, int how); }"
"// { int|sys||fremovexattr(int fd, const char *name); }"
"// { int|sys||fsetxattr(int fd, const char *name, const void *value, size_t size, int flags); }"
"// { int|sys||fstatat(int fd, const char *path, struct stat *buf, int flag); }"
"// { int|sys||fstatvfs1(int fd, struct statvfs *buf, int flags); }"
"// { int|sys||fsync_range(int fd, int flags, off_t start, off_t length); }"
"// { int|sys||ftruncate(int fd, int PAD, off_t length); }"
"// { int|sys||futimens(int fd, const struct timespec *tptr); }"
"// { int|sys||getgroups(int gidsetsize, gid_t *gidset); }"
"// { int|sys||getpeername(int fdes, struct sockaddr *asa, socklen_t *alen); }"
"// { int|sys||getpriority(int which, id_t who); }"
"// { int|sys||getrlimit(int which, struct rlimit *rlp); }"
"// { int|sys||getsockname(int fdes, struct sockaddr *asa, socklen_t *alen); }"
"// { int|sys||getsockopt(int s, int level, int name, void *val, socklen_t *avalsize); }"
"// { int|sys||getvfsstat(struct statvfs *buf, size_t bufsize, int flags); }"
"// { int|sys||getxattr(const char *path, const char *name, void *value, size_t size); }"
"// { int|sys||ioctl(int fd, u_long com, ... void *data); }"
"// { int|sys||kill(pid_t pid, int signum); }"
"// { int|sys||ktrace(const char *fname, int ops, int facs, pid_t pid); }"
"// { int|sys||lchflags(const char *path, u_long flags); }"
"// { int|sys||lchmod(const char *path, mode_t mode); }"
"// { int|sys||lchown(const char *path, uid_t uid, gid_t gid); }"
"// { int|sys||lgetxattr(const char *path, const char *name, void *value, size_t size); }"
"// { int|sys||link(const char *path, const char *link); }"
"// { int|sys||linkat(int fd1, const char *name1, int fd2, const char *name2, int flags); }"
"// { int|sys||listen(int s, int backlog); }"
"// { int|sys||listxattr(const char *path, char *list, size_t size); }"
"// { int|sys||llistxattr(const char *path, char *list, size_t size); }"
"// { int|sys||lremovexattr(const char *path, const char *name); }"
"// { int|sys||lsetxattr(const char *path, const char *name, const void *value, size_t size, int flags); }"
"// { int|sys||madvise(void *addr, size_t len, int behav); }"
"// { int|sys||mincore(void *addr, size_t len, char *vec); }"
"// { int|sys||minherit(void *addr, size_t len, int inherit); }"
"// { int|sys||mkdir(const char *path, mode_t mode); }"
"// { int|sys||mkdirat(int fd, const char *path, mode_t mode); }"
"// { int|sys||mkfifo(const char *path, mode_t mode); }"
"// { int|sys||mkfifoat(int fd, const char *path, mode_t mode); }"
"// { int|sys||mknodat(int fd, const char *path, mode_t mode, uint32_t dev); }"
"// { int|sys||mlock(const void *addr, size_t len); }"
"// { int|sys||modctl(int cmd, void *arg); }"
"// { int|sys||mprotect(void *addr, size_t len, int prot); }"
"// { int|sys||msgget(key_t key, int msgflg); }"
"// { int|sys||msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); }"
"// { int|sys||munlock(const void *addr, size_t len); }"
"// { int|sys||munmap(void *addr, size_t len); }"
"// { int|sys||open(const char *path, int flags, ... mode_t mode); }"
"// { int|sys||openat(int fd, const char *path, int oflags, ... mode_t mode); }"
"// { int|sys||paccept(int s, struct sockaddr *name, socklen_t *anamelen, const sigset_t *mask, int flags); }"
"// { int|sys||pipe2(int *fildes, int flags); }"
"// { int|sys||pmc_control(int ctr, int op, void *args); }"
"// { int|sys||pmc_get_info(int ctr, int op, void *args); }"
"// { int|sys||poll(struct pollfd *fds, u_int nfds, int timeout); }"
"// { int|sys||posix_spawn(pid_t *pid, const char *path, const struct posix_spawn_file_actions *file_actions, const struct posix_spawnattr *attrp, char *const *argv, char *const *envp); }"
"// { int|sys||profil(char *samples, size_t size, u_long offset, u_int scale); }"
"// { int|sys||pset_assign(psetid_t psid, cpuid_t cpuid, psetid_t *opsid); }"
"// { int|sys||ptrace(int req, pid_t pid, void *addr, int data); }"
"// { int|sys||rasctl(void *addr, size_t len, int op); }"
"// { int|sys||readlinkat(int fd, const char *path, char *buf, size_t bufsize); }"
"// { int|sys||reboot(int opt, char *bootstr); }"
"// { int|sys||recvmmsg(int s, struct mmsghdr *mmsg, unsigned int vlen, unsigned int flags, struct timespec *timeout); }"
"// { int|sys||removexattr(const char *path, const char *name); }"
"// { int|sys||rename(const char *from, const char *to); }"
"// { int|sys||renameat(int fromfd, const char *from, int tofd, const char *to); }"
"// { int|sys||semget(key_t key, int nsems, int semflg); }"
"// { int|sys||semop(int semid, struct sembuf *sops, size_t nsops); }"
"// { int|sys||sendmmsg(int s, struct mmsghdr *mmsg, unsigned int vlen, unsigned int flags); }"
"// { int|sys||setgroups(int gidsetsize, const gid_t *gidset); }"
"// { int|sys||setpgid(pid_t pid, pid_t pgid); }"
"// { int|sys||setpriority(int which, id_t who, int prio); }"
"// { int|sys||setregid(gid_t rgid, gid_t egid); }"
"// { int|sys||setreuid(uid_t ruid, uid_t euid); }"
"// { int|sys||setrlimit(int which, const struct rlimit *rlp); }"
"// { int|sys||setsockopt(int s, int level, int name, const void *val, socklen_t valsize); }"
"// { int|sys||setxattr(const char *path, const char *name, const void *value, size_t size, int flags); }"
"// { int|sys||shmget(key_t key, size_t size, int shmflg); }"
"// { int|sys||shutdown(int s, int how); }"
"// { int|sys||sigqueueinfo(pid_t pid, const siginfo_t *info); }"
"// { int|sys||socketpair(int domain, int type, int protocol, int *rsv); }"
"// { int|sys||statvfs1(const char *path, struct statvfs *buf, int flags); }"
"// { int|sys||swapctl(int cmd, void *arg, int misc); }"
"// { int|sys||symlink(const char *path, const char *link); }"
"// { int|sys||symlinkat(const char *path1, int fd, const char *path2); }"
"// { int|sys||sysarch(int op, void *parms); }"
"// { int|sys||timer_create(clockid_t clock_id, struct sigevent *evp, timer_t *timerid); }"
"// { int|sys||truncate(const char *path, int PAD, off_t length); }"
"// { int|sys||unlinkat(int fd, const char *path, int flag); }"
"// { int|sys||unmount(const char *path, int flags); }"
"// { int|sys||utimensat(int fd, const char *path, const struct timespec *tptr, int flag); }"
"// { int|sys||utrace(const char *label, void *addr, size_t len); }"
"// { int|sys||uuidgen(struct uuid *store, int count); }"
"// { long sys_fpathconf(int fd, int name); }"
"// { long sys_pathconf(const char *path, int name); }"
"// { long|sys||fpathconf(int fd, int name); }"
"// { long|sys||pathconf(const char *path, int name); }"
"// { mqd_t mq_open(const char * name, int oflag, mode_t mode, struct mq_attr *attr); }"
"// { off_t lseek(int fd, int pad, off_t offset, int whence); }"
"// { off_t lseek(int fd, off_t offset, int whence); }"
"// { off_t sys_lseek(int fd, int pad, off_t offset, int whence); }"
"// { off_t|sys||lseek(int fd, int PAD, off_t offset, int whence); }"
"// { pid_t sys_wait4(pid_t pid, int *status, int options, struct rusage *rusage); }"
"// { pid_t|sys||__clone(int flags, void *stack); }"
"// { ssize_t __realpath(const char *path, char *buf, size_t len); }"
"// { ssize_t aio_waitcomplete( struct aiocb **aiocbp, struct timespec *timeout); }"
"// { ssize_t cap_ioctls_get(int fd, u_long *cmds, size_t maxcmds); }"
"// { ssize_t extattr_get_fd(int fd, int attrnamespace, const char *attrname, void *data, size_t nbytes); }"
"// { ssize_t extattr_get_file( const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes); }"
"// { ssize_t extattr_get_link( const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes); }"
"// { ssize_t extattr_list_fd(int fd, int attrnamespace, void *data, size_t nbytes); }"
"// { ssize_t extattr_list_file( const char *path, int attrnamespace, void *data, size_t nbytes); }"
"// { ssize_t extattr_list_link( const char *path, int attrnamespace, void *data, size_t nbytes); }"
"// { ssize_t extattr_set_fd(int fd, int attrnamespace, const char *attrname, void *data, size_t nbytes); }"
"// { ssize_t extattr_set_file( const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes); }"
"// { ssize_t extattr_set_link( const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes); }"
"// { ssize_t extpread(int fd, void *buf, size_t nbyte, int flags, off_t offset); }"
"// { ssize_t extpreadv(int fd, const struct iovec *iovp, int iovcnt, int flags, off_t offset); }"
"// { ssize_t extpwrite(int fd, const void *buf, size_t nbyte, int flags, off_t offset); }"
"// { ssize_t extpwritev(int fd, const struct iovec *iovp, int iovcnt, int flags, off_t offset); }"
"// { ssize_t getdirentries(int fd, \"
"// { ssize_t getrandom(void *buf, size_t len, unsigned flags); }"
"// { ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned *msg_prio); }"
"// { ssize_t mq_timedreceive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned *msg_prio, const struct timespec *abs_timeout); }"
"// { ssize_t pread(int fd, void *buf, size_t nbyte, off_t offset); }"
"// { ssize_t preadv(int fd, struct iovec *iovp, u_int iovcnt, off_t offset); }"
"// { ssize_t pwrite(int fd, const void *buf, size_t nbyte, off_t offset); }"
"// { ssize_t pwritev(int fd, struct iovec *iovp, u_int iovcnt, off_t offset); }"
"// { ssize_t read(int fd, void *buf, size_t nbyte); }"
"// { ssize_t readlink(char *path, char *buf, size_t count); }"
"// { ssize_t sys_pread(int fd, void *buf, size_t nbyte, int pad, off_t offset); }"
"// { ssize_t sys_preadv(int fd, const struct iovec *iovp, int iovcnt, int pad, off_t offset); }"
"// { ssize_t sys_pwrite(int fd, const void *buf, size_t nbyte, int pad, off_t offset); }"
"// { ssize_t sys_pwritev(int fd, const struct iovec *iovp, int iovcnt, int pad, off_t offset); }"
"// { ssize_t sys_read(int fd, void *buf, size_t nbyte); }"
"// { ssize_t sys_readlink(const char *path, char *buf, size_t count); }"
"// { ssize_t sys_readlinkat(int fd, const char *path, char *buf, size_t count); }"
"// { ssize_t sys_readv(int fd, const struct iovec *iovp, int iovcnt); }"
"// { ssize_t sys_recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlenaddr); }"
"// { ssize_t sys_recvmsg(int s, struct msghdr *msg, int flags); }"
"// { ssize_t sys_sendmsg(int s, const struct msghdr *msg, int flags); }"
"// { ssize_t sys_sendto(int s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen); }"
"// { ssize_t sys_write(int fd, const void *buf, size_t nbyte); }"
"// { ssize_t sys_writev(int fd, const struct iovec *iovp, int iovcnt); }"
"// { ssize_t vmspace_pread(void *id, void *buf, size_t nbyte, int flags, off_t offset); }"
"// { ssize_t vmspace_pwrite(void *id, const void *buf, size_t nbyte, int flags, off_t offset); }"
"// { ssize_t write(int fd, const void *buf, size_t nbyte); }"
"// { ssize_t|sys||_lwp_unpark_all(const lwpid_t *targets, size_t ntargets, const void *hint); }"
"// { ssize_t|sys||extattr_get_fd(int fd, int attrnamespace, const char *attrname, void *data, size_t nbytes); }"
"// { ssize_t|sys||extattr_get_file(const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes); }"
"// { ssize_t|sys||extattr_get_link(const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes); }"
"// { ssize_t|sys||extattr_list_fd(int fd, int attrnamespace, void *data, size_t nbytes); }"
"// { ssize_t|sys||extattr_list_file(const char *path, int attrnamespace, void *data, size_t nbytes); }"
"// { ssize_t|sys||extattr_list_link(const char *path, int attrnamespace, void *data, size_t nbytes); }"
"// { ssize_t|sys||msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); }"
"// { ssize_t|sys||pread(int fd, void *buf, size_t nbyte, int PAD, off_t offset); }"
"// { ssize_t|sys||preadv(int fd, const struct iovec *iovp, int iovcnt, int PAD, off_t offset); }"
"// { ssize_t|sys||pwrite(int fd, const void *buf, size_t nbyte, int PAD, off_t offset); }"
"// { ssize_t|sys||pwritev(int fd, const struct iovec *iovp, int iovcnt, int PAD, off_t offset); }"
"// { ssize_t|sys||read(int fd, void *buf, size_t nbyte); }"
"// { ssize_t|sys||readlink(const char *path, char *buf, size_t count); }"
"// { ssize_t|sys||readv(int fd, const struct iovec *iovp, int iovcnt); }"
"// { ssize_t|sys||recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlenaddr); }"
"// { ssize_t|sys||recvmsg(int s, struct msghdr *msg, int flags); }"
"// { ssize_t|sys||sendmsg(int s, const struct msghdr *msg, int flags); }"
"// { ssize_t|sys||sendto(int s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen); }"
"// { ssize_t|sys||write(int fd, const void *buf, size_t nbyte); }"
"// { ssize_t|sys||writev(int fd, const struct iovec *iovp, int iovcnt); }"
"// { void *sys_mmap(void *addr, size_t len, int prot, int flags, int fd, long pad, off_t pos); }"
"// { void *sys_mquery(void *addr, size_t len, int prot, int flags, int fd, long pad, off_t pos); }"
"// { void *sys_shmat(int shmid, const void *shmaddr, int shmflg); }"
"// { void *|sys||mmap(void *addr, size_t len, int prot, int flags, int fd, long PAD, off_t pos); }"
"// { void *|sys||mremap(void *old_address, size_t old_size, void *new_address, size_t new_size, int flags); }"
"// { void *|sys||shmat(int shmid, const void *shmaddr, int shmflg); }"
"// { void extexit(int how, int status, void *addr); }"
"// |t.pos| chars into the string, but there will be a gap at"
//	        break
//	        panic(err)
//	    fmt.Println(hex.EncodeToString(b))
//	    hash.Read(b)
//	    if err == io.EOF {
//	    }
//	// 2ae01472317d1935a84797ec1983ae243fc6aa28
//	// Assume hashfd and addr are already configured using the setup process."
//	// Assume hashfd is already configured using the setup process."
//	// Hash an input string and read the results. Each Write discards
//	// Hash the contents of a file.
//	// Note: unix.Accept does not work at this time; must invoke accept()
//	// Open a socket to perform SHA1 hashing."
//	// Output:
//	// Output: 85cdcad0c06eef66f805ecce353bec9accbeecc5
//	// Read one raw CAN frame"
//	// manually using unix.Syscall.
//	// previous hash state. Read always reads the current state.
//	Acct(name nil-string) (err error)
//	addr := &SockaddrCAN{Ifindex: index}
//	fd, _ := Socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM)"
//	fmt.Println(hex.EncodeToString(b))
//	for i := 0; i < 2; i++ {
//	for {
//	hash.Read(b)
//	if err != nil {
//	oldState, err := term.MakeRaw(int(os.Stdin.Fd()))"
//	}
//	})
//          int flags
//          int options
//       argument to the right of the separator. You cannot use both arguments in a single use of the command.
//      );
//      int setxattr(
//     // NULL value
//     // use u.UUID
//     but only if there is space or tab inside s.
//     https://docs.microsoft.com/en-us/windows-hardware/drivers/install/setupapi
//     https://docs.microsoft.com/en-us/windows/win32/devinst/cfgmgr32-
//    uuid.Must(uuid.NewRandom())"
//    uuid.New().String()"
//   (cat /proc/version || uname -a ) 2>/dev/null
//   * PersistentPostRun()
//   * PersistentPreRun()
//   * PostRun()
//   * PreRun()
//   * Run()
//   - Uint16/SetUint16: flags
//   ... indicates that you can specify multiple values for the previous argument.
//   [ ] identifies an optional argument. Arguments that are not enclosed in brackets are required.
//   lsb_release -a 2>/dev/null
//   { } delimits a set of mutually exclusive arguments when one of the arguments is required. If the arguments are
//   |   indicates mutually exclusive information. You can use the argument to the left of the separator or the
//  - VMADDR_CID_HOST: refers to other processes on the host.
//  - VMADDR_CID_HYPERVISOR: refers to the hypervisor process.
//  - VMADDR_CID_LOCAL: refers to local communication (loopback).
//  ...
//  NewDCESecurity(Group, uint32(os.Getgid()))"
//  NewDCESecurity(Person, uint32(os.Getuid()))"
//  NewHash(md5.New(), space, data, 3)"
//  NewHash(sha1.New(), space, data, 5)"
//  Randomly generated UUIDs have 122 random bits.  One's annual risk of being"
//  equivalent to the odds of creating a few tens of trillions of UUIDs in a
//  if u.Valid {
//  var u uuid.NullUUID"
//  year and having one duplicate.
//  }
//  } else {
// $COMMAND
// '--flag arg'
// '--flag' (arg was optional)
// '--flag' (arg was required)
// '--flag=arg'
// '-f arg'
// '-f' (arg was optional)
// '-f' (arg was required)
// '-f=arg arg ...'
// '-f=arg'
// '-farg'
// (16-bit uid calls are not always supported in newer kernels)
// (386 default is 32-bit file system and 16-bit uid).
// (Codes marked as read-only (R) may only be used for
// (The default value is represented as a string.)
// (This is the standard convention.)
// (Version 4) UUID generation. The pool contains random bytes read from
// (according to the semantics of the specific function being called) before consulting
// (and is what glibc does).
// (do the same as below)
// (section 4.1.6)
// (this includes all non deprecated/hidden commands).
// +build !aix
// +build !go1.12
// +build !go1.4
// +build !go1.5
// +build !js
// +build !ppc64
// +build !ppc64le
// +build !windows
// +build 386
// +build 386 amd64
// +build 386 amd64 amd64p32 alpha arm arm64 loong64 mipsle mips64le mips64p32le nios2 ppc64le riscv riscv64 sh
// +build 386 amd64 arm arm64
// +build 386 amd64 arm arm64 mips64
// +build 386 amd64 mips mipsle mips64 mipsle ppc64 ppc64le ppc s390x sparc64
// +build aix
// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris
// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris zos
// +build aix darwin freebsd linux netbsd openbsd solaris zos
// +build aix dragonfly freebsd linux netbsd openbsd
// +build aix linux solaris zos
// +build amd64
// +build arm
// +build arm arm64
// +build arm64
// +build armbe arm64be m68k mips mips64 mips64p32 ppc ppc64 s390 s390x shbe sparc sparc64
// +build darwin
// +build darwin dragonfly freebsd linux netbsd openbsd solaris
// +build darwin dragonfly freebsd netbsd openbsd
// +build darwin freebsd netbsd openbsd
// +build dragonfly
// +build dragonfly freebsd linux netbsd openbsd
// +build freebsd
// +build freebsd netbsd
// +build freebsd netbsd openbsd
// +build gc
// +build gccgo
// +build generate
// +build go1.12
// +build go1.13
// +build go1.4
// +build go1.5
// +build go1.9
// +build ios
// +build js
// +build linux
// +build loong64
// +build mips mips64
// +build mips mipsle
// +build mips mipsle mips64 mips64le
// +build mips64 mips64le
// +build mipsle mips64le
// +build netbsd
// +build openbsd
// +build plan9
// +build ppc64
// +build ppc64 ppc64le
// +build ppc64le
// +build ppc64le ppc64
// +build riscv riscv64
// +build riscv64
// +build s390x
// +build solaris
// +build windows
// +build zos
// - https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034
// - https://seclists.org/oss-sec/2022/q1/80
// - root commands with no subcommands can take arbitrary arguments
// - root commands with subcommands will do subcommand validity checking
// - subcommands will always accept arbitrary arguments
// - there are no arguments on the command-line and
// -- bool Value
// -- boolSlice Value
// -- count Value
// -- durationSlice Value
// -- float32 Value
// -- float32Slice Value
// -- float64 Value
// -- float64Slice Value
// -- int Value
// -- int16 Value
// -- int32 Value
// -- int32Slice Value
// -- int64 Value
// -- int64Slice Value
// -- int8 Value
// -- intSlice Value
// -- ipSlice Value
// -- net.IP value
// -- net.IPMask value
// -- string Value
// -- stringArray Value
// -- stringSlice Value
// -- stringToInt Value
// -- stringToInt64 Value
// -- stringToString Value
// -- time.Duration Value
// -- uint Value
// -- uint16 value
// -- uint32 value
// -- uint64 Value
// -- uint8 Value
// -- uintSlice Value
// --unknown=unknownval arg ...
// -1 causes a new sequence to be generated.
// 1 or more hardware profile-specific changes to follow (obsolete)
// 1 unit up can be expressed as ^[[A or ^[A
// 1- There could be some valid completions even though there was an error
// 1. The user calls port_dissociate before any events fire
// 100s of a nanoseconds between epochs
// 1582.
// 2. An event fires and we return it to the user
// 3- c already has a 'completion' command provided by the program.
// 32-bit aligned access to network subsystem.
// 32-bit aligned and some architectures don't allow unaligned
// 32-bit only
// 38 chars + terminator null
// 4122.
// 5 units up can be expressed as ^[[5A
// 64 bits should be enough. (32 bits isn't even on 386). Since the
// 64-bit Dragonfly before the September 2019 ABI changes still requires
// 64-bit file system and 32-bit uid calls
// 7 minutes and 10 seconds.
// ;;' | sh > _$i && gofmt < _$i > $i
// <PROGRAM>_ACTIVE_HELP where <PROGRAM> is the name of the root command in upper
// ===========================================================================
// A DLL implements access to a single DLL.
// A Dir contains the metadata for a file.
// A Domain represents a Version 2 domain
// A Flag represents the state of a flag.
// A FlagSet represents a set of defined flags.
// A LazyDLL implements access to a single DLL.
// A LazyProc implements access to a procedure inside a LazyDLL.
// A Note is a string describing a process note.
// A Proc implements access to a procedure inside a DLL.
// A Qid represents a 9P server's unique identification for a file.
// A Time represents a time as the number of 100's of nanoseconds since 15 Oct
// A UUID is a 128 bit (16 byte) Universal Unique IDentifier as defined in RFC
// A UUID is a 16 byte (128 bit) array.  UUIDs may be used as keys to"
// A Variant represents a UUID's variant.
// A Version represents a UUID's version.
// A completion command is already available
// A constraint with a pre-release can only match a pre-release version
// A constraint without a pre-release can only match a version without a
// A count flag will add 1 to its value every time it is found on the command line
// A count flag will add 1 to its value evey time it is found on the command line
// A description is following a tab character.
// A few ioctl requests use the return value as an output parameter;"
// A full list of tags is available here: https://github.com/liamg/tml
// A long flag with a space separated value
// A note about uniqueness derived from the UUID Wikipedia entry:"
// A pointer to a SID structure representing a group that will become
// A short flag with a space separated value
// A type separate from ifreq is required in order to comply with the
// A value which may be passed to the which parameter for Getitimer and
// ACLFromEntries returns a new ACL on the Go heap containing a list of explicit entries as well as those of another ACL.
// AF_LOCAL is an alias for AF_UNIX
// AIX doesn't have any flags for umount.
// APM aware driver
// APM aware enumerator
// Accept_nocancel
// Accepted socket has no address.
// Access rights for process.
// Access rights for thread.
// Access_extended
// Account for the additional NULL byte added by
// ActiveHelp line will be shown below the previous ones when completion is triggered.
// Actual maximum size of an INF string (including string substitutions).
// AddCommand adds one or more commands to this parent command.
// AddFlag will add the flag to the FlagSet
// AddFlagSet adds one FlagSet to another. If a flag is already present in f
// AddGoFlag will add the given *flag.Flag to the pflag.FlagSet
// AddGoFlagSet will add the given *flag.FlagSet to the pflag.FlagSet
// AddTemplateFunc adds a template function that's available to Usage and Help
// AddTemplateFuncs adds multiple template functions that are available to Usage and
// Add_profil
// Addr is the type of address used to manipulate a socket. Addr must be
// Addr returns the address of the procedure represented by p.
// Adds a special hidden command that can be used to request custom completions.
// AfsSyscall
// Aio_cancel
// Aio_error
// Aio_fsync
// Aio_read
// Aio_return
// Aio_suspend
// Aio_suspend_nocancel
// Aio_write
// Aix system calls.
// Aliases is an array of aliases that can be used instead of the first word in Use.
// All directives using iota should be above this one.
// AllGroups returns a slice that can be used to iterate over the groups in g.
// AllPrivileges returns a slice that can be used to iterate over the privileges in p.
// Also say we need help if the command isn't runnable.
// Always set IP family as ioctls would require it anyway.
// An Ifreq is a type-safe wrapper around the raw ifreq struct. An Ifreq
// An access token contains the security information for a logon session.
// An empty byte array is not sufficient. To maintain the same behaviour as the
// An empty string would cause a array with one (empty) string
// An empty string would cause a slice with one (empty) string
// An empty string would cause an empty map
// Analogous to epoll_event on Linux.
// Annotations are key/value pairs that can be used by applications to identify or
// Annotations for Bash completion.
// Append adds the specified value to the end of the flag value list.
// AppendActiveHelp adds the specified string to the specified array to be used as ActiveHelp.
// ArbitraryArgs never returns an error.
// ArchPrctl
// Arg returns the i'th argument.  Arg(0) is the first remaining argument
// Arg returns the i'th command-line argument.  Arg(0) is the first remaining argument
// ArgAliases is List of aliases for ValidArgs.
// Args returns the non-flag arguments.
// Args returns the non-flag command-line arguments.
// ArgsLenAtDash will return the length of c.Flags().Args at the moment
// ArgsLenAtDash will return the length of f.Args at the moment when a -- was
// As of Linux 4.12, only the ""asymmetric"" keyType defines type-specific"
// AssociateFd wraps calls to port_associate(3c) on file descriptors.
// AssociatePath wraps port_associate(3c) for a filesystem path including
// Assume caller wants to disable accounting.
// Assume path ends at NUL.
// At the moment rusage will not be touched.
// Atsocket
// Audit
// Auditctl
// Auditon
// Authorization Functions
// BSD system call wrappers shared by *BSD based systems
// BUG(brainman): The definition of Linger is not appropriate for direct use
// Base ContainerID (R)
// BashCompletionFunction is custom bash functions used by the legacy bash autocompletion generator.
// Because a constraint could have more/less specificity than the version it's
// Because people naturally expect syscall.Faccessat to act
// Best effort.
// BindToDevice binds the socket associated with fd to device.
// Bluetooth Protocols
// Bluetooth sockets and messages
// Both EnableRandPool and DisableRandPool are not thread-safe and should"
// Both explicitEntries and mergedACL are optional and can be nil.
// Both pointers must be nil.
// Branch to function
// Brk
// Bsdthread_create
// Bsdthread_register
// Bsdthread_terminate
// Build driver list based on alternate platform information specified in associated file queue
// BuildDriverInfoList method builds a list of drivers that is associated with a specific device or with the global class driver list for a device information set.
// BusNumber (R)
// BusTypeGUID (R)
// But we need to save the cookie
// By default it prints a simple header and calls PrintDefaults; for details about the
// BytePtrFromString in kexecFileLoad. The kexec_file_load
// BytePtrFromString returns a pointer to a NUL-terminated array of
// BytePtrToString takes a pointer to a sequence of text and returns the corresponding string.
// ByteSliceFromString returns a NUL-terminated slice of bytes
// BytesBase64 adapts []byte for use as a flag. Value of flag is Base64 encoded
// BytesHex adapts []byte for use as a flag. Value of flag is HEX encoded
// CID and Port specify a context ID and port address for a VM socket.
// CONFIGRET is a return value or error code from cfgmgr32 APIs
// CPU affinity functions
// CPUSet represents a CPU affinity mask.
// Call __errno function.
// Call function.
// Call syscall from C code because the gccgo support for calling from
// Call the registered completion function to get the completions.
// CalledAs returns the command name or alias that was used to invoke
// Callers must inspect the primary return value to decide whether an error occurred
// Callers should use ioctlPtr when the third argument is a pointer and ioctl
// Calling SetRand with nil sets the random number generator to the default"
// Calling use(p) ensures that p is kept live until that point.
// Can be defined by user by overriding HelpFunc.
// Can be defined by user by overriding UsageFunc.
// Can be disabled
// Can be removed
// CancelDriverInfoSearch method cancels a driver list search that is currently in progress in a different thread.
// Cannot safely interpret raw.Addr bytes as an IPv4 address.
// CapRightsClear clears the permissions in clearrights from rights.
// CapRightsGet returns a CapRights structure containing the operations permitted on fd.
// CapRightsInit returns a pointer to an initialised CapRights structure filled with rights.
// CapRightsIsSet checks whether all the permissions in setrights are present in rights.
// CapRightsLimit reduces the operations permitted on fd to at most those contained in rights.
// CapRightsSet sets the permissions in setrights in rights.
// Capabilities (R)
// Cause SetupDiBuildDriverInfoList to append a new driver list to an existing list.
// Certain constants are missing from the fs/crypto UAPI
// Certain file systems get rather angry and EINVAL if you give
// Changed returns true if the flag was explicitly set during Parse() and false
// Charspare
// Check SVC return code
// Check for error and sanity check group count. Newer versions of
// Check for useless names before allocating a string.
// Check if interspersed is false or -- was set on a previous arg.
// Check if last bit of entry point was set
// Check if the data was written
// Check if we are completing a flag value subject to annotations
// Check if we are doing flag value completion before parsing the flags.
// Check tests if a constraint is validated by the given version.
// Check tests if a version satisfies all the constraints.
// Check that EZBNMIF4 returned a nwmConnEntry
// Check that EZBNMIF4 returned a nwmRecHeader
// Check the last part of the segment in the constraint. If the version segment at
// Check the segments in the constraint against those in the version. If the version
// Check to see if the remaining segments in Other are all zeros
// Check to see if the remaining segments in Self are all zeros -
// Chmod_extended
// Class (R--tied to ClassGUID)
// Class/co-installer wants to get a DIF_FINISH_INSTALL action in client context.
// ClassGUID (R/W)
// ClassInstallHeader is the first member of any class install parameters structure. It contains the device installation request code that defines the format of the rest of the install parameters structure.
// ClassInstallParams method retrieves class installation parameters for a device information set or a particular device information element.
// Cleanup signals when done.
// Clear removes cpu from the set s.
// Clear removes fd from the set fds.
// Client example:"
// ClockNanosleep
// ClockSequence returns the clock sequence encoded in uuid.
// ClockSettime
// Clone
// Close closes the event port.
// Close method deletes a device information set and frees all associated memory.
// Close releases access to access token.
// Close_nocancel
// CmsgLen returns the value to store in the Len field of the Cmsghdr
// CmsgSpace returns the number of bytes an ancillary element with
// Code generated by 'go generate'; DO NOT EDIT.
// Code generated by 'mkerrors.bash'; DO NOT EDIT.
// Code generated by 'mkknownfolderids.bash'; DO NOT EDIT.
// Code generated by cmd/cgo -godefs; DO NOT EDIT.
// Code generated by mkmerge; DO NOT EDIT.
// Code generated by the command above; DO NOT EDIT.
// Code generated by the command above; DO NOT EDIT.'
// Code generated by the command above; see README.md. DO NOT EDIT.
// Code generated by the command above; see README.md. DO NOT EDIT.'
// Collection is a type that implements the sort.Interface interface
// Command.ExecuteContext or Command.ExecuteContextC
// CommandPath returns the full path to this command.
// CommandPathPadding return padding for the command path.
// Commands returns a sorted slice of child commands.
// CompDebug prints the specified string to the same file as where the
// CompDebugln prints the specified string with a newline at the end
// CompError prints the specified completion message to stderr.
// CompErrorln prints the specified completion message to stderr with a newline at the end.
// Compare Source against PORT_SOURCE_FILE or PORT_SOURCE_FD
// Compare compares this version to another version. This
// Compare the segments
// CompatibleIDs (R/W)
// Complete required flags even without the '-' prefix
// CompletionOptions are the options to control shell completion
// CompletionOptions is a set of options to control the handling of shell completion
// Concrete example: https://github.com/spf13/cobra/issues/393#issuecomment-282741924.
// ConfigFlags (R/W)
// Connect_nocancel
// Console related constants used for the mode parameter to SetConsoleMode. See
// Constants
// Constants for AceFlags and Inheritance fields
// Constants for LocalAlloc flags.
// Constants for MULTIPLE_TRUSTEE_OPERATION
// Constants for ObjectsPresent field
// Constants for TRUSTEE_FORM
// Constants for TRUSTEE_TYPE
// Constants for security attributes when opening named pipes.
// Constants for the ContextTrackingMode field of SECURITY_QUALITY_OF_SERVICE.
// Constants for the CreateNamedPipe-family of functions.
// Constants for the completion command
// Constants for type ACCESS_MASK
// Constants for type ACCESS_MODE
// Constants for type SECURITY_DESCRIPTOR_CONTROL
// Constants for type SECURITY_INFORMATION
// Constants for type SE_OBJECT_TYPE
// Constants returned by Variant.
// Constants that were deprecated or moved to enums in the FreeBSD headers. Keep
// Constraint functions
// Constraints example.
// Constraints is a slice of constraints. We make a custom type so that
// Context returns underlying command context. If command was executed
// ContinueOnError error handling policy.
// ContinueOnError will return an err from Parse() if an error is found
// Control returns the security descriptor control bits.
// Copied from linux/hid.h.
// Copied from linux/l2tp.h
// Copy creates a duplicate of security identifier SID.
// Copy data from the returned data structures into tcpInfo
// Copy entry into return buffer.
// Copy stdin to the pty and the pty to stdout.
// Copyfile
// Copyright 2009 The Go Authors. All rights reserved.
// Copyright 2010 The Go Authors. All rights reserved.
// Copyright 2011 The Go Authors. All rights reserved.
// Copyright 2012 The Go Authors. All rights reserved.
// Copyright 2013 The Go Authors. All rights reserved.
// Copyright 2014 The Go Authors. All rights reserved.
// Copyright 2015 The Go Authors. All rights reserved.
// Copyright 2016 Google Inc.  All rights reserved.
// Copyright 2016 The Go Authors. All rights reserved.
// Copyright 2017 Google Inc.  All rights reserved.
// Copyright 2017 The Go Authors. All rights reserved.
// Copyright 2018 Google Inc.  All rights reserved.
// Copyright 2018 The Go Authors. All rights reserved.
// Copyright 2019 The Go Authors. All rights reserved.
// Copyright 2020 The Go Authors. All rights reserved.
// Copyright 2021 Google Inc.  All rights reserved.
// Copyright 2021 The Go Authors. All rights reserved.
// Copyright 2022 The Go Authors. All rights reserved.
// Core returns a new version constructed from only the MAJOR.MINOR.PATCH
// Count returns the number of CPUs in the set s.
// CountP is like Count only takes a shorthand for the flag name.
// CountVar like CountVar only the flag is placed on the CommandLine instead of a given flag set
// CountVarP is like CountVar only take a shorthand for the flag name.
// Create arbitrary command.
// CreateDeviceInfo method creates a new device information element and adds it as a new member to the specified device information set.
// CreateDisposition flags for NtCreateFile and NtCreateNamedPipeFile.
// CreateOptions flags for NtCreateFile and NtCreateNamedPipeFile.
// Created by cgo -godefs - DO NOT EDIT
// Csops
// CurrentProcess returns the handle for the current process.
// CurrentThread returns the handle for the current thread.
// Currently all targets have either int32 or int64 for Timespec.Sec.
// DACL returns the security descriptor DACL and whether it was defaulted. The dacl return value may be nil
// DER encoded X.509 certificates signed by keys in another keyring. Restrictions
// DEVINST is a handle usually recognized by cfgmgr32 APIs
// DEVPROPGUID specifies a property category.
// DEVPROPID uniquely identifies the property within the property category.
// DEVPROPKEY represents a device property key for a device property in the
// DEVPROPTYPE represents the property-data-type identifier that specifies the
// DICD flags control SetupDiCreateDeviceInfo
// DICS_FLAG specifies the scope of a device property change
// DICS_STATE specifies values indicating a change in a device's state
// DIGCF flags control what is included in the device information set built by SetupDiGetClassDevs
// DI_FLAGS is SP_DEVINSTALL_PARAMS.Flags values
// DI_FLAGSEX is SP_DEVINSTALL_PARAMS.FlagsEx values
// DI_FUNCTION is function type for device installer
// DI_REMOVEDEVICE specifies the scope of the device removal
// DLLError describes reasons for DLL load failures.
// Darwin system calls.
// Days between epochs
// DebugFlags used to determine which flags have been assigned to which commands
// Defined in asm_solaris_amd64.s.
// Delegate to UUID Value function
// Delete
// Delete both driver and Device key
// Delete everything from the current cursor position to the
// Delete frees ProcThreadAttributeList's resources.
// Delete zero or more spaces and then one or more characters.
// Deprecated"
// Deprecated: Explicitly call OpenProcessToken(CurrentProcess(), ...)"
// Deprecated: Use SetOut and/or SetErr instead
// Deprecated: Use libSystem wrappers instead of direct syscalls.
// Deprecated: this package moved to golang.org/x/term."
// Deprecated: use CurrentProcess for the same Handle without the nil"
// Deprecated: use CurrentThread for the same Handle without the nil"
// Derive extattr namespace and attribute name
// Descriptions are not supported by bash completion.
// DestroyDriverInfoList method deletes a driver list.
// Determine which union variant is present in pp.Addr by checking
// DevInfo holds reference to device information set
// DevInfoData is a device information structure (references a device instance that is a member of a device information set)
// DevInfoListDetailData is a structure for detailed information on a device information set (used for SetupDiGetDeviceInfoListDetail which supersedes the functionality of SetupDiGetDeviceInfoListClass).
// DevInst is being removed
// Device Address (R)
// Device Characteristics (R/W)
// Device Install State (R)
// Device Location Paths (R)
// Device Power Data (R)
// Device Type (R/W)
// Device is actively engaged in a query-remove IRP
// Device is exclusive-access (R/W)
// Device is part of a set of related devices collectively pending query-removal
// DeviceDesc (R/W)
// DeviceInstallParams method retrieves device installation parameters for a device information set or a particular device information element.
// DeviceInstanceID method retrieves the instance ID of the device.
// DeviceRegistryProperty method retrieves a specified Plug and Play device property.
// Devnode can be the wakeup device
// Devnode need lock resume processing
// Did the Class Info List
// Did the Compat Info List
// Dir.Mode bits
// Directory completion
// Directory completion from within a directory
// DisableDefaultCmd prevents Cobra from creating a default 'completion' command
// DisableDescriptions turns off all completion descriptions for shells
// DisableFlagParsing disables the flag parsing.
// DisableFlagsInUseLine will disable the addition of [flags] to the usage
// DisableNoDescFlag prevents Cobra from creating the '--no-descriptions' flag
// DisableRandPool disables the randomness pool if it was previously
// DisableSuggestions disables the suggestions based on Levenshtein distance
// Discover the nodes and construct the MIB OID.
// DissociateFd wraps calls to port_dissociate(3c) on file descriptors.
// DissociatePath wraps port_dissociate(3c) for a filesystem path.
// Do Stuff Here
// Do the interface allocations only once for common
// Domain constants for DCE Security (Version 2) UUIDs.
// Domain returns the domain for a Version 2 UUID.  Domains are only defined
// Don't count trailing NUL for abstract address.
// Don't include old Internet drivers when building a driver list. Ignored on Windows Vista and later.
// Don't mark the flag that is already set as hidden because it may be an
// Don't remove identical driver nodes from the class list
// Don't run AddReg and DelReg for device's software (driver) key.
// Don't skip during rebalance
// Don't write HW & Compat IDs on install
// DragonFly BSD system calls.
// Driver (R/W)
// Driver came from Windows Update
// DriverInfoDetail method retrieves driver information detail for a device information set or a particular device information element in the device information set.
// DrvInfoDetailData is driver information details structure (provides detailed information about a particular driver information structure)
// Dummy function: there are no semantics for Madvise on z/OS
// Dummy value (not supported).
// E.g.  'go run ...' - 'run' is the command. Cobra requires
// EIO is allowed by getdirentries.
// EIO was allowed by getdirentries.
// EOT
// EPOLLET        = 0x80000000
// EPOLLEXCLUSIVE = 0x10000000 // Exclusive wake-up mode
// EPOLLONESHOT   = 0x40000000
// EPOLLRDHUP     = 0x2000     // Typically used with edge-triggered notis
// EPOLLWAKEUP    = 0x20000000 // Relies on Linux's BLOCK_SUSPEND capability
// EPOLL_CLOEXEC  = 0x80000
// ERROR_OBJECT_NOT_FOUND.
// Each time this is called is a single new entry; this allows it to be a member of multiple groups if needed.
// Empty string would cause a slice with one (empty) entry
// EnablePrefixMatching allows to set automatic prefix matching. Automatic prefix matching can be a dangerous thing
// EnableRandPool enables internal randomness pool used for Random
// Enforce flag groups before doing flag completions
// Enum generates hardware ID
// EnumDeviceInfo method returns a DevInfoData structure that specifies a device information element in a device information set.
// EnumDriverInfo method enumerates the members of a driver list.
// Enumerator Name (R)
// EpollCtlOld
// EpollPwait
// EpollWaitOld
// Eq takes two types and checks whether they are equal. Supported types are int and string. Unsupported types will panic.
// Equal tests if two versions are equal.
// Equals compares Constraints with other Constraints
// Equals compares two SIDs for equality.
// Erase the character under the current position.
// Erases the screen and moves the cursor to the home position.
// ErrHelp is the error returned if the flag -help is invoked but no such flag is defined.
// ErrOrStderr returns output to stderr
// ErrUnsupported is returned if a function is not
// Errno values.
// ErrnoName returns the error name for error number e.
// Error table
// Error while attempting to parse flags
// ErrorHandling defines how to handle flag parsing errors.
// Errors
// Errors'
// Escape contains a pointer to the escape codes for this terminal.
// EscapeArg rewrites command line argument s as prescribed
// EscapeCodes contains escape sequences that can be written to the terminal in
// Event Ports
// EventPort provides a safe abstraction on top of Solaris/illumos Event Ports.
// ExactArgs returns an error if there are not exactly n args.
// ExactValidArgs returns an error if
// Example is examples of how to use the command.
// Example: add [-F file | -D dir]... [-f format] profile
// Exclude the null terminator
// Execute executes the root command.
// Execute method is called.
// Execute uses the args (os.Args[1:] by default)
// ExecuteC executes the command.
// Execve
// Existing constants on linux
// ExitOnError will call os.Exit(2) if an error is found when parsing
// Expected Open from a variable.
// Expected arguments
// Expected unsafe pointer for Syscall call.
// FILE_INFO_BY_HANDLE_CLASS constants for SetFileInformationByHandle/GetFileInformationByHandleEx
// FIXME Eq is unused by cobra and should be removed in a version 2. It exists only for compatibility with users of cobra.
// FIXME Gt is unused by cobra and should be removed in a version 2. It exists only for compatibility with users of cobra.
// FIXME appendIfNotPresent is unused by cobra and should be removed in a version 2. It exists only for compatibility with users of cobra.
// FParseErrWhitelist configures Flag parse errors to be ignored
// FParseErrWhitelist flag parse errors to be ignored
// Failed to Load/Call class installer
// Fchmod_extended
// FcntlFstore performs a fcntl syscall for the F_PREALLOCATE command.
// FcntlInt performs a fcntl syscall on fd with the provided command and argument.
// Fcntl_nocancel
// FdIsWatched checks to see if fd is associated with this EventPort.
// Fgetxattr
// Fhopen
// Fields may not be an exact match. Some fields have no equivalent.
// File absent in directory.
// File completion filtered by extensions
// File system flags from GetVolumeInformation and GetVolumeInformationByHandle.
// FileHandle represents the C struct file_handle used by
// FileInformationClass for NtSetInformationFile
// Fill in parameter list.
// Final argument is (basep *uintptr) and the syscall doesn't take nil.
// Finally trim the completion.  This is especially important to get rid
// Find NUL terminator.
// Find home directory.
// Find nwmTCPStatsEntry in returned entries
// Find searches DLL for procedure named p.Name. It returns
// Find size.
// Find the base of the mapping.
// Find the completion function for the flag or command
// Find the real command for which completion must be performed
// Find the target command given the args and command tree
// FindProc searches DLL d for procedure named name and returns *Proc
// FindProcByOrdinal searches DLL d for procedure by ordinal and returns *Proc
// FindResource resolves a resource of the given name and resource type.
// First __DragonFly_version after September 2019 ABI changes
// First check for required flags
// First convert the short flag into a long flag
// FixedCompletions can be used to create a completion function which always
// Flag climbs up the command tree looking for matching flag.
// Flag for QueryFullProcessImageName.
// Flag has full name
// Flag indicates that device is disabled
// Flag is shorthand
// Flag that causes SetupDiBuildDriverInfoList to build a device's compatible driver
// Flag that prevents ConfigMgr from removing/re-enumerating devices during device
// Flag to indicate that only the the INF specified by SP_DEVINSTALL_PARAMS.DriverPath should be searched.
// Flag to indicate that the sorting from the INF file should be used.
// Flag to indicate the setting properties for this Device (or class) caused a change so the Dev Mgr UI probably needs to be updated.
// Flag with an =
// Flag without the =
// FlagErrorFunc returns either the function set by SetFlagErrorFunc for this
// FlagUsages returns a string containing the usage information for all flags in
// FlagUsagesWrapped returns a string containing the usage information
// Flags added to the FlagSet will be translated and then when anything tries to
// Flags for DefineDosDevice.
// Flags for Device/Class Properties
// Flags for FILE_CASE_SENSITIVE_INFORMATION
// Flags for FILE_DISPOSITION_INFORMATION_EX
// Flags for FILE_LINK_INFORMATION
// Flags for FILE_RENAME_INFORMATION
// Flags for LockFileEx.
// Flags for WSASocket
// Flags for choosing a device
// Flags for device installation
// Flags returned by DiInstallDevice to indicate need to reboot/restart
// Flags returns the complete FlagSet that applies
// Flags set by DiBuildDriverInfoList
// Flags used for GetModuleHandleEx
// Flistxattr
// For MessageBox()
// For a given domain/id pair the same token may be returned for up to"
// For details of the functions and data types in this package consult"
// For example:
// For hashing larger byte slices, or byte streams such as those read from"
// For internal use.
// For more information see pledge(2)."
// For more information see unveil(2).
// For more information, see: http://www.chronox.de/crypto-API/crypto/userspace-if.html."
// For testing: clients can set this flag to force
// Force files to be copied from install path
// Foreground colors
// Fork
// FreeBSD and NetBSD implement their own syscalls to handle extended attributes
// FreeBSD system calls.
// FreeBSD won't allow you to list xattrs from multiple namespaces
// Fremovexattr
// FriendlyName (R/W)
// FromBytes creates a new UUID from a byte slice. Returns an error if the slice
// Fsctl
// Fsetxattr
// Fstat64_extended
// Fstat_extended
// Fstypename
// Fsync_nocancel
// FullPath retrieves the full path of the specified file.
// Functions to access/create device major and minor numbers matching the
// Futex
// GUIDFromString parses a string in the form of
// GenBashCompletion generates bash completion file and writes to the passed writer.
// GenBashCompletionFile generates bash completion file.
// GenBashCompletionFileV2 generates Bash completion version 2.
// GenBashCompletionV2 generates Bash completion file version 2
// GenFishCompletion generates fish completion file and writes to the passed writer.
// GenFishCompletionFile generates fish completion file.
// GenPowerShellCompletion generates powershell completion file without descriptions
// GenPowerShellCompletionFile generates powershell completion file without descriptions.
// GenPowerShellCompletionFileWithDesc generates powershell completion file with descriptions.
// GenPowerShellCompletionWithDesc generates powershell completion file with descriptions
// GenZshCompletion generates zsh completion file including descriptions
// GenZshCompletionFile generates zsh completion file including descriptions.
// GenZshCompletionFileNoDesc generates zsh completion file without descriptions.
// GenZshCompletionNoDesc generates zsh completion file without descriptions
// GenerateGUID creates a new random GUID.
// GenericReparseBuffer
// Get CEECAATHDID
// Get __errno FuncDesc.
// Get a list of all sysctl nodes below the given MIB by performing
// Get function.
// Get jobname of current process
// Get library control area (LCA).
// Get wraps port_getn(3c) and fills a slice of PortEvent.
// GetActiveHelpConfig returns the value of the ActiveHelp environment variable
// GetBool return the bool value of a flag with the given name
// GetBoolSlice returns the []bool value of a flag with the given name.
// GetBytesBase64 return the []byte value of a flag with the given name
// GetBytesHex return the []byte value of a flag with the given name
// GetConnectionDetail EZBNMIF4 call
// GetCount return the int value of a flag with the given name
// GetCurrentProcess returns the handle for the current process.
// GetCurrentProcessToken returns the access token associated with
// GetCurrentThread returns the handle for the current thread.
// GetCurrentThreadEffectiveToken returns the effective access token
// GetCurrentThreadToken return the access token associated with
// GetDuration return the duration value of a flag with the given name
// GetDurationSlice returns the []time.Duration value of a flag with the given name
// GetFloat32 return the float32 value of a flag with the given name
// GetFloat32Slice return the []float32 value of a flag with the given name
// GetFloat64 return the float64 value of a flag with the given name
// GetFloat64Slice return the []float64 value of a flag with the given name
// GetGlobalStats EZBNMIF4 call
// GetIP return the net.IP value of a flag with the given name
// GetIPNet return the net.IPNet value of a flag with the given name
// GetIPSlice returns the []net.IP value of a flag with the given name
// GetIPv4Mask return the net.IPv4Mask value of a flag with the given name
// GetInt return the int value of a flag with the given name
// GetInt16 returns the int16 value of a flag with the given name
// GetInt32 return the int32 value of a flag with the given name
// GetInt32Slice return the []int32 value of a flag with the given name
// GetInt64 return the int64 value of a flag with the given name
// GetInt64Slice return the []int64 value of a flag with the given name
// GetInt8 return the int8 value of a flag with the given name
// GetIntSlice return the []int value of a flag with the given name
// GetKernelSyms
// GetMempolicy
// GetNamedSecurityInfo queries the security information for a given named object and returns the self-relative security
// GetNormalizeFunc returns the previously set NormalizeFunc of a function which
// GetOne wraps port_get(3c) and returns a single PortEvent.
// GetProcAddressByOrdinal retrieves the address of the exported
// GetProcessPreferredUILanguages retrieves the process preferred UI languages.
// GetRobustList
// GetSecurityInfo queries the security information for a given handle and returns the self-relative security
// GetSize returns the dimensions of the given terminal.
// GetSize returns the visible dimensions of the given terminal.
// GetSlice returns the flag value list as an array of strings.
// GetState returns the current state of a terminal which may be useful to
// GetString return the string value of a flag with the given name
// GetStringArray return the []string value of a flag with the given name
// GetStringSlice return the []string value of a flag with the given name
// GetStringToInt return the map[string]int value of a flag with the given name
// GetStringToInt64 return the map[string]int64 value of a flag with the given name
// GetStringToString return the map[string]string value of a flag with the given name
// GetSystemDirectory retrieves the path to current location of the system
// GetSystemPreferredUILanguages retrieves the system preferred UI languages.
// GetSystemWindowsDirectory retrieves the path to current location of the
// GetThreadArea
// GetThreadPreferredUILanguages retrieves the thread preferred UI languages for the current thread.
// GetTime returns the current Time (100s of nanoseconds since 15 Oct 1582) and
// GetTokenGroups retrieves group accounts associated with access token t.
// GetTokenPrimaryGroup retrieves access token t primary group information.
// GetTokenUser retrieves access token t user account information.
// GetUint return the uint value of a flag with the given name
// GetUint16 return the uint16 value of a flag with the given name
// GetUint32 return the uint32 value of a flag with the given name
// GetUint64 return the uint64 value of a flag with the given name
// GetUint8 return the uint8 value of a flag with the given name
// GetUintSlice returns the []uint value of a flag with the given name.
// GetUserPreferredUILanguages retrieves information about the user preferred UI languages.
// GetUserProfileDirectory retrieves path to the
// GetWindowsDirectory retrieves the path to current location of the Windows
// Getattrlist
// Getaudit
// Getaudit_addr
// Getauid
// Getcwd will return an error if it failed for any reason.
// Getdents
// Getdirentriesattr
// Getfh
// Getitimer wraps getitimer(2) to return the current value of the timer
// Getlogin
// Getpmsg
// Getrlimit prefers the prlimit64 system call. See issue 38604.
// Getsgroups
// Getsize returns the number of rows (lines) and cols (positions
// GetsizeFull returns the full terminal size description.
// GetsockoptString returns the string value of the socket option opt for the
// GetsockoptXucred is a getsockopt wrapper that returns an Xucred struct.
// Gettid
// Getwgroups
// Getxattr
// Global map of flag completion functions. Make sure to use flagCompletionMutex before you try to read and write from it.
// GlobalNormalizationFunc returns the global normalization function or nil if it doesn't exist.
// Go custom completion defined for this flag or command.
// Go implementation of C mostly found in /usr/src/sys/kern/subr_capability.c
// Go to C does not support varargs functions.
// GreaterThan tests if this version is greater than another version.
// GreaterThanOrEqual tests if this version is greater than or equal to another version.
// Group attributes inside of Tokengroups.Groups[i].Attributes
// Group returns the security descriptor group and whether it was defaulted.
// HSPFILEQ is type for setup file queue
// Had a problem during preassignment of boot log conf
// Hand edited based on zerrors_linux_s390x.go
// Hand edited based on ztypes_linux_s390x.go
// Handle pty size.
// Handle returns d's module handle.
// Happens only if flags are declared with identical names
// Hardware Removal Policy (R)
// HardwareID (R/W)
// Has Register_Device_Driver
// Has Register_Enumerator
// Has a private problem
// Has been moved
// Has received a config
// Has received a config enumerate
// HasAlias determines if a given string is an alias of the command.
// HasAvailableFlags checks if the command contains any flags (local plus persistent from the entire
// HasAvailableFlags returns a bool to indicate if the FlagSet has any flags
// HasAvailableInheritedFlags checks if the command has flags inherited from its parent command which are
// HasAvailableLocalFlags checks if the command has flags specifically declared locally which are not hidden
// HasAvailablePersistentFlags checks if the command contains persistent flags which are not hidden or deprecated.
// HasAvailableSubCommands determines if a command has available sub commands that
// HasExample determines if the command has example.
// HasFlags checks if the command contains any flags (local plus persistent from the entire structure).
// HasFlags returns a bool to indicate if the FlagSet has any flags defined.
// HasHelpSubCommands determines if a command has any available 'help' sub commands
// HasInheritedFlags checks if the command has flags inherited from its parent command.
// HasLocalFlags checks if the command has flags specifically declared locally.
// HasParent determines if the command is a child command.
// HasPersistentFlags checks if the command contains persistent flags.
// HasSubCommands determines if the command has children commands.
// Help puts out the help for the command.
// Help template generation.
// HelpFunc returns either the function set by SetHelpFunc for this command
// HelpTemplate return help template for the command.
// Helpers for dealing with ifreq since it contains a union and thus requires a
// Here is an example of using an AF_ALG socket with SHA1 hashing."
// HiddenDefaultCmd makes the default 'completion' command hidden
// I think because the 5-register system call interface can't handle
// ID returns the id for a Version 2 UUID. IDs are only defined for Version 2
// IFT_CARP is deprecated in FreeBSD 10
// INO64_FIRST from /usr/src/lib/libc/sys/compat-ino64.h
// IPNet adapts net.IPNet for use as a flag.
// IPV6_RECVORIGDSTADDR option must be enabled on the socket.
// IdentifierAuthority returns the identifier authority of the SID.
// Identitysvc
// If '--flag arg' then
// If '-f arg' then
// If TraverseChildren is true on the root command we don't check for
// If b is too small to hold a valid stat message, ErrShortStat is returned."
// If error type is flagCompError and we don't want flagCompletion we should ignore the error
// If name is not an absolute path, LoadLibraryEx searches for the DLL"
// If pid is 0 the calling thread is used.
// If r.Read returns an error when the package requests random data then
// If s contains a NUL byte this function panics instead of
// If still not enough space then don't even try to wrap.
// If the *flag.Flag.Name was a single character (ex: `v`) it will be accessiblei
// If the IPC_CREAT flag is specified a new segment is created.
// If the Itimerval argument is the zero value, the timer will be disarmed."
// If the path is no longer associated with this event port (ENOENT)
// If the stat message itself is invalid, ErrBadStat is returned."
// If the terminal expands then our position calculations will
// If the user set the value (or if left to default)
// If the width didn't change then nothing else needs to be
// If there isn't enough space in b for a stat message, ErrShortStat is returned."
// If this is true all flags will be passed to the command as arguments.
// If time has gone backwards with this clock sequence then we
// If you want boolean results, use the LessThan, Equal,"
// IfreqMTU is struct ifreq used to get or set a network device's MTU.
// Ignore errors; CommandLine is set for ExitOnError.
// Impersonation levels
// Implemented in assembly to avoid allocation.
// Implemented in assembly to import from runtime.
// Implemented in runtime/syscall_aix.go.
// Implemented in runtime/syscall_solaris.go.
// Implemented in the runtime package (runtime/sys_darwin.go)
// In most cases, New should be used."
// InOrStdin returns input to stdin
// Including linux/l2tp.h here causes conflicts between linux/in.h
// Indicates an error occurred and completions should be ignored.
// Indicates that only directory names should be provided in file completion.
// Indicates that the returned completions should be used as file extension filters.
// Indicates that the shell should not provide file completion even when
// Indicates that the shell will perform its default behavior after completions
// Inet4Addr returns the Ifreq union data from an embedded sockaddr as a C
// Information about these APIs can be found at:
// InheritSize applies the terminal size of pty to tty. This should be run
// InheritedFlags returns all flags which were inherited from parent commands.
// Init sets the name and error handling property for a flag set.
// InitDefaultHelpCmd adds default help command to c.
// InitDefaultHelpFlag adds default help flag to c.
// InitDefaultVersionFlag adds default version flag to c.
// Initgroups
// Initial resize.
// Installation is occurring during initial system setup.
// Interior.
// Invalid UUID
// Invented structures to support what package os expects.
// Invented values to support what package os expects.
// IoCancel
// IoDestroy
// IoGetevents
// IoSetup
// IoSubmit
// Ioctl
// IoctlFileClone performs an FICLONE ioctl operation to clone the entire file
// IoctlFileCloneRange performs an FICLONERANGE ioctl operation to clone the
// IoctlFileDedupeRange performs an FIDEDUPERANGE ioctl operation to share the
// IoctlGetEthtoolDrvinfo fetches ethtool driver information for the network
// IoctlGetEthtoolDrvinfo which use these APIs under the hood.
// IoctlGetIfreqMTU performs the SIOCGIFMTU ioctl operation on fd to get the MTU
// IoctlGetInt performs an ioctl operation which gets an integer value
// IoctlGetTermios performs an ioctl on fd with a *Termios.
// IoctlGetWatchdogInfo fetches information about a watchdog device from the
// IoctlIfreq performs an ioctl using an Ifreq structure for input and/or
// IoctlKCMAttach attaches a TCP socket and associated BPF program file
// IoctlKCMClone attaches a new file descriptor to a multiplexor by cloning an
// IoctlKCMUnattach unattaches a TCP socket file descriptor from a multiplexor.
// IoctlRetInt performs an ioctl operation specified by req on a device
// IoctlSetIfreqMTU performs the SIOCSIFMTU ioctl operation on fd to set the MTU
// IoctlSetInt performs an ioctl operation which sets an integer value
// IoctlSetPointerInt performs an ioctl operation which sets an
// IoctlSetTermios performs an ioctl on fd with a *Termios.
// IoctlSetWinsize performs an ioctl on fd with a *Winsize argument.
// IoctlWatchdogKeepalive issues a keepalive ioctl to a watchdog device. For
// Iopolicysys
// IoprioGet
// IoprioSet
// Is currently configured
// Is filtered
// IsAdditionalHelpTopicCommand determines if a command is an additional
// IsAvailableCommand determines if a command is available as a non-help command
// IsCompatible method tests if given hardware ID matches the driver or is listed on the compatible ID list.
// IsElevated returns whether the current token is elevated from a UAC perspective.
// IsInvalidLengthError is matcher function for custom error invalidLengthError
// IsMember reports whether the access token t is a member of the provided SID.
// IsNewer method returns true if DrvInfoData date and version is newer than supplied parameters.
// IsRestricted reports whether the access token t is a restricted token.
// IsSet reports whether cpu is in the set s.
// IsSet returns whether fd is in the set fds.
// IsTerminal returns whether the given file descriptor is a terminal.
// IsValid returns whether the SID has a valid revision and length.
// IsValid returns whether the security descriptor is valid.
// IsWellKnown determines whether the SID matches the well-known sidType.
// It cannot be used safely or portably and its representation may change in a later release.
// It delays the lookup until the Addr method is called.
// It does not guarantee that the program was run from a terminal. It only can tell you
// It implements the os.Signal interface.
// It is a dynamic version of using ValidArgs.
// It is a pseudo handle that does not need to be closed.
// It is called automatically by executing the c or by calling help and usage.
// It is called automatically by executing the c.
// It is conservative and returns false if any of the internal calls fail."
// It is not safe to use the slice after calling this function."
// It is possible we will add more fields to *Ifreq itself later to prevent
// It is recommended to instead use c.RegisterFlagCompletionFunc(...) which allows
// It returns the previous value of the timer.
// It returns the string with the remaining slice of b and a boolean. If the length is
// It simplifies safe initialization of global variables holding compiled UUIDs.
// It visits only those flags that have been set.
// It will block until either min events have been received
// It will delay the load of the DLL until the first
// It will panic if the procedure cannot be found.
// It's only when dest is set to NULL that the OS X implementations of
// JobObjectInformationClass
// Julian day of 1 Jan 1970
// Julian day of 15 Oct 1582
// Just jump to package syscall's implementation for all these functions.
// Kdebug_trace
// Keep going for multiple reasons:
// Keep in sync with the size of the referenced fields.
// KexecLoad
// Keyctl Commands (http://man7.org/linux/man-pages/man2/keyctl.2.html)
// Keyctl commands with special signatures.
// KeyctlBuffer calls keyctl commands in which the third and fourth
// KeyctlDHCompute implements the KEYCTL_DH_COMPUTE command. This command
// KeyctlGetKeyringID implements the KEYCTL_GET_KEYRING_ID command.
// KeyctlInstantiateIOV implements the KEYCTL_INSTANTIATE_IOV command. This
// KeyctlInt calls keyctl commands in which each argument is an int.
// KeyctlJoinSessionKeyring implements the KEYCTL_JOIN_SESSION_KEYRING command.
// KeyctlRestrictKeyring implements the KEYCTL_RESTRICT_KEYRING command. This
// KeyctlSearch implements the KEYCTL_SEARCH command.
// KeyctlSetperm implements the KEYCTL_SETPERM command. The perm value is the
// KeyctlString calls keyctl commands which return a string.
// Klogset wraps the sys_syslog system call; it sets console_loglevel to
// Kqueue_from_portset_np
// Kqueue_portset
// LazyProc's Addr method.
// Leading edge.
// Leading edge. PEEKTEXT/PEEKDATA don't require aligned
// Leave room for NUL byte terminator.
// Leave room for terminating NULL byte.
// Legacy arg validation has the following behaviour:
// LegacyBusType (R)
// Length returns the length of the security descriptor.
// LessThan tests if this version is less than another version.
// LessThanOrEqual tests if this version is less than or equal to another version.
// Let's be nice and avoid making users have to do that.
// Licensed under the Apache License, Version 2.0 (the ""License"");"
// Lied about can reconfig once
// Lifreq Helpers
// Linux fchmodat doesn't support the flags parameter. Mimick glibc's behavior
// Linux system calls.
// Lio_listio
// List returns the actual ProcThreadAttributeList to be passed to StartupInfoEx.
// Listxattr
// Load loads DLL file d.Name into memory. It returns an error if fails.
// LoadDLL loads DLL file into memory.
// LoadLibrary flags for determining from where to search for a DLL
// Local address
// Local port
// LocalFlags returns the local FlagSet specifically set in the current command.
// LocalNonPersistentFlags are flags specific to this command which will NOT persist to subcommands.
// LocationInformation (R/W)
// Long is the long message shown in the 'help <this-command>' output.
// Looks like golang flags don't set DefValue correctly  :-(
// LookupAccount retrieves the name of the account for this SID
// LookupDcookie
// LookupSID retrieves a security identifier SID for the account
// LowerFilters (R/W)
// Lstat64_extended
// Lstat_extended
// Lutimes sets the access and modification times tv on path. If path refers to
// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT
// MUI function flag values
// Major returns the major component of a Darwin device number.
// Major returns the major component of a DragonFlyBSD device number.
// Major returns the major component of a FreeBSD device number.
// Major returns the major component of a Linux device number.
// Major returns the major component of a NetBSD device number.
// Major returns the major component of a z/OS device number.
// Major returns the major component of an OpenBSD device number.
// Make a bigger buffer if needed
// Make sure the completion script calls the __*_go_custom_completion function for
// Make sure to close the pty at the end.
// Make sure we only write the first line to the output.
// Make this change in all hardware profiles. Remove information about the device from the registry.
// MakeItimerval creates an Itimerval from interval and value durations.
// MakeRaw puts the terminal connected to the given file descriptor into raw
// Manually installed
// Map the requested memory.
// MarkDeprecated indicated that a flag is deprecated in your program. It will
// MarkFlagDirname instructs the various shell completion implementations to
// MarkFlagFilename instructs the various shell completion implementations to
// MarkFlagRequired instructs the various shell completion implementations to
// MarkFlagsMutuallyExclusive marks the given flags with annotations so that Cobra errors
// MarkFlagsRequiredTogether marks the given flags with annotations so that Cobra errors
// MarkHidden sets a flag to 'hidden' in your program. It will continue to
// MarkPersistentFlagDirname instructs the various shell completion
// MarkPersistentFlagFilename instructs the various shell completion
// MarkPersistentFlagRequired instructs the various shell completion implementations to
// MarkShorthandDeprecated will mark the shorthand of a flag deprecated in your
// MarkZshCompPositionalArgumentFile only worked for zsh and its behavior was
// MarkZshCompPositionalArgumentWords only worked for zsh. It has therefore
// Marshal encodes a 9P stat message corresponding to d into b
// MarshalBinary implements encoding.BinaryMarshaler.
// MarshalJSON implements json.Marshaler.
// MarshalText implements encoding.TextMarshaler interface.
// MarshalText implements encoding.TextMarshaler.
// MatchAll allows combining several PositionalArgs to work in concert.
// Max lengths of commands' string lengths for use in padding.
// Maximum string length constants
// MaximumNArgs returns an error if there are more than N args.
// May need reenumeration
// Mbind
// Meant to be run on the highest node. Only searches down.
// Metadata is anything that comes after the ""+"" in the version."
// Metadata returns any metadata that was part of the version
// Mfg (R/W)
// Microsoft encoding {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx} and the raw hex
// MigratePages
// Mincore
// Minherit
// MinimumNArgs returns an error if there is not at least N args.
// Minor gives a cookie instead of an index since in order to avoid changing the"
// Minor returns the minor component of a Darwin device number.
// Minor returns the minor component of a DragonFlyBSD device number.
// Minor returns the minor component of a FreeBSD device number.
// Minor returns the minor component of a Linux device number.
// Minor returns the minor component of a NetBSD device number.
// Minor returns the minor component of a z/OS device number.
// Minor returns the minor component of an OpenBSD device number.
// Missing operator is treated as equal to '=', whitespaces"
// Mkdev returns a Darwin device number generated from the given major and minor
// Mkdev returns a DragonFlyBSD device number generated from the given major and
// Mkdev returns a FreeBSD device number generated from the given major and
// Mkdev returns a Linux device number generated from the given major and minor
// Mkdev returns a NetBSD device number generated from the given major and minor
// Mkdev returns a z/OS device number generated from the given major and minor
// Mkdev returns an OpenBSD device number generated from the given major and minor
// Mkdir_extended
// Mkfifo_extended
// Mntfromname
// Mntonname
// ModifyLdt
// Modwatch
// More invented values for signals
// Mount
// Mount and bind flags
// MountSetattr is a wrapper for mount_setattr(2).
// MousetrapDisplayDuration controls how long the MousetrapHelpText message is displayed on Windows
// MousetrapHelpText enables an information splash screen on Windows
// Move SVC args into registers
// Move SVC args into registers (entry point still in r0 from SVC 08)
// Move back to beginning.
// Move cursor to column zero at the start of the line.
// Move down a line
// Move function arguments into registers
// MovePages
// MqGetsetattr
// MqNotify
// MqOpen
// MqTimedreceive
// MqTimedsend
// MqUnlink
// Mremap
// Msgctl
// Msgget
// Msgrcv
// Msgrcv_nocancel
// Msgsnd
// Msgsnd_nocancel
// Msgsys
// Multi function child
// Multi function parent
// Must be > 0.
// Must be called while holding ep.mu
// Must print to stderr for this not to be read by the completion script.
// Must returns uuid if err is nil and panics otherwise.
// MustConstraints is a helper that wraps a call to a function
// MustFindProc is like FindProc but panics if search fails.
// MustFindProcByOrdinal is like FindProcByOrdinal but panics if search fails.
// MustLoadDLL is like LoadDLL but panics if load operation failes.
// MustParse is like Parse but panics if the string cannot be parsed.
// NArg is the number of arguments remaining after flags have been processed.
// NFlag returns the number of command-line flags that have been set.
// NFlag returns the number of flags that have been set.
// NOTE(brainman): work around ERROR_BROKEN_PIPE is returned on reading EOF from stdin
// NOTE(rsc): It seems strange to set the buffer to have
// NOTE(rsc): The Win32finddata struct is wrong for the system call:
// NOTE: Always call this function while holding the e.mu mutex
// NOTE: The goroutine will keep reading until the next keystroke before returning.
// NOTE: Usage is not just defaultUsage(CommandLine)
// NT APIs that work over the NTString type. Note that most Windows APIs
// NT APIs that work over the NTUnicodeString type. Note that most Windows APIs
// NT Native APIs
// Name returns the command's name: the first word in the use line.
// Name returns the interface name associated with the Ifreq.
// NameAndAliases returns a list of the command name and all aliases
// NamePadding returns padding for the name.
// NameToHandleAt wraps the name_to_handle_at system call; it obtains
// Nano returns the time stored in ts as nanoseconds.
// Nano returns the time stored in tv as nanoseconds.
// Nanoseconds returns Filetime ft in nanoseconds
// Need device installer
// Needed since <sys/param.h> refers to it...
// NetBSD aarch64 requires 128-bit alignment.
// NetBSD and OpenBSD armv7 require 64-bit alignment.
// NetBSD system calls.
// New creates a new random UUID or panics.  New is equivalent to
// NewCallback converts a Go function to a function pointer conforming to the stdcall calling convention.
// NewCallbackCDecl converts a Go function to a function pointer conforming to the cdecl calling convention.
// NewConstraint will parse one or more constraints from the given
// NewDCEGroup returns a DCE Security (Version 2) UUID in the group
// NewDCEPerson returns a DCE Security (Version 2) UUID in the person
// NewDCESecurity returns a DCE Security (Version 2) UUID.
// NewEventPort creates a new EventPort including the
// NewFileHandle constructs a FileHandle.
// NewHash returns a new UUID derived from the hash of space concatenated with
// NewIfreq creates an Ifreq with the input network interface name after
// NewLazyDLL creates new LazyDLL associated with DLL file.
// NewLine prints a new line to the terminal with no content
// NewMD5 and NewSHA1.
// NewMD5 returns a new MD5 (Version 3) UUID based on the
// NewNTString returns a new NTString structure for use with native
// NewNTUnicodeString returns a new NTUnicodeString structure for use with native
// NewParser creates a new parser that writes to w
// NewProc returns a LazyProc for accessing the named procedure in the DLL d.
// NewRandom returns a Random (Version 4) UUID.
// NewRandomFromReader returns a UUID based on bytes read from a given io.Reader.
// NewSHA1 returns a new SHA1 (Version 5) UUID based on the
// NewSecurityDescriptor creates and initializes a new absolute security descriptor.
// NewSemver parses the given version and returns a new
// NewString creates a new random UUID and returns it as a string or panics.
// NewString is equivalent to the expression
// NewTerminal runs a VT100 terminal on the given ReadWriter. If the ReadWriter is
// NewUUID returns a Version 1 UUID based on the current NodeID and clock
// NewVersion parses the given version and returns a new
// Nfsclnt
// Nfsservctl
// Nfssvc
// No Enable/Disable in General Props
// No UI for resources if possible
// No file Copy necessary
// No show in device manager
// No small icons in select device dialogs
// NoArgs returns an error if any args are included.
// NoFileCompletions can be used to disable file completion for commands that should
// Node ID is not set.
// Node ID will be generated.  If a named interface cannot be found then false
// NodeID returns the 6 byte node id encoded in uuid.  It returns nil if uuid is
// NodeInterface returns the name of the interface from which the NodeID was
// Non-racy version of:
// NonInheritedFlags returns all flags which were not inherited from parent commands.
// Normal flag completion
// NormalizedName is a flag name that has been normalized according to rules
// Normally terminals will advance the current position
// Not CM_Create_DevInst lately
// Not as efficient as it could be because Timespec and
// Not doing flag completion
// Not enough room. Return for now.
// Not enough space for sensible wrapping. Wrap as a block on
// Not exist on zOS
// Not implemented
// Note that SPDRP codes are zero based while CM_DRP codes are one based!"
// Note that completion printouts should never be on stdout as they would
// Note that on non-Unix systems os.Stdin.Fd() may not be 0."
// Note that sometimes we use a lowercase //sys name and
// Note that sometimes we use a lowercase //sys name and wrap
// Note that the special case of blocking further
// Note that we want to perform flagname completion even if finalCmd.DisableFlagParsing==true;
// Note: this strategy for suspending in the middle and
// Notice that a call to Execute and ExecuteC will replace a nil context of"
// Now wrap the rest
// NsecToTimespec converts a number of nanoseconds into a Timespec.
// NsecToTimeval converts a number of nanoseconds into a Timeval.
// NthPreviousEntry returns the value passed to the nth previous call to Add.
// NullUUID implements the SQL driver.Scanner interface so
// NullUUID represents a UUID that may be null.
// OK
// On a POSIX system the id should be the users UID for the Person
// On non-Windows platforms, it always returns false."
// On some 32-bit systems the range of valid Timespec values are smaller
// OnInitialize sets the passed functions to be run when each command's
// Once a file descriptor has been returned from Accept, it may be used to"
// One or more children have invalid IDs
// One or more drivers are blocked from loading for this Devnode
// Only addresses of at least 6 bytes are returned."
// Only consider the case where the flag does not contain an =.
// Only consider this flag group at all if all the flags are defined.
// Only create this special command if it is actually being called.
// Only errs if the flag isn't found.
// Only one back quote; use type name.
// Only one of ValidArgs and ValidArgsFunction can be used for a command.
// Only one of ValidArgs or ValidArgsFunction can be used for a single command.
// Only remove the fds entry if it exists and this cookie matches
// Only remove the paths entry if it exists and this cookie matches
// OnlyValidArgs returns an error if any args are not in the list of ValidArgs.
// Open a pty and its corresponding tty.
// Open modes
// Open/Create/Delete device key
// Open/Create/Delete driver key
// OpenBSD system calls.
// OpenByHandleAt wraps the open_by_handle_at system call; it opens a
// OpenByHandleAt).
// OpenCurrentProcessToken opens an access token associated with current
// OpenDevRegKey method opens a registry key for device-specific configuration information.
// Open_extended
// Open_nocancel
// Otherwise the shell scripts will interpret the other lines as new flags
// OutOrStderr returns output to stderr
// OutOrStdout returns output to stdout.
// Output
// Output from stderr must be ignored by the completion script.
// Ovadvise
// Override INF flags
// Owner returns the security descriptor owner and whether it was defaulted.
// PFlagFromGoFlag will return a *pflag.Flag given a *flag.Flag
// Package cobra is a commander providing a simple interface to create powerful modern CLI interfaces.
// Package plan9 contains an interface to the low-level operating system
// Package pty provides functions for working with Unix terminals.
// Package unix contains an interface to the low-level operating system
// Package unsafeheader contains header declarations for the Go runtime's
// Package uuid generates and inspects UUIDs.
// Package windows contains an interface to the low-level operating system
// Pad to the same size as ifreq.
// PanicOnError will panic() if an error is found when parsing flags
// Parameter constants for NtCreateNamedPipeFile.
// Parent returns a commands parent command.
// Parse converts the input string (containing TML tags) into a string containing ANSI escape code sequences for output to the terminal.
// Parse decodes s into a UUID or returns an error.  Both the standard UUID
// Parse nwmTriplets to get offsets of returned entries
// Parse parses the command-line flags from os.Args[1:].  Must be called
// Parse takes input from the reader and converts any provided tags to the relevant ANSI escape codes for output to parser's writer.
// Parse the flags early so we can check if required flags are set
// ParseAll parses the command-line flags from os.Args[1:] and called fn for each.
// ParseErrorsWhitelist defines the parsing errors that can be ignored
// ParseErrorsWhitelist is used to configure a whitelist of errors
// ParseFlags parses persistent flag tree and local flags.
// ParseIPv4Mask written in IP form (e.g. 255.255.255.0).
// ParseOrigDstAddr decodes a socket control message containing the original
// ParseSocketControlMessage parses b as an array of socket control
// ParseUnixCredentials decodes a socket control message that contains
// ParseUnixRights decodes a socket control message that contains an
// Parsed reports whether f.Parse has been called.
// Parsed returns true if the command-line flags have been parsed.
// Parser is used to parse a TML string into an output string containing ANSI escape codes
// PathIsWatched checks to see if path is associated with this EventPort.
// Pending wraps port_getn(3c) and returns how many events are pending.
// Per-process epoll implementation.
// PersistentFlags returns the persistent FlagSet specifically set in the current command.
// PersistentPostRun: children of this command will inherit and execute after PostRun.
// PersistentPostRunE: PersistentPostRun but returns an error.
// PersistentPreRunE: PersistentPreRun but returns an error.
// Personality
// PhysicalDeviceObjectName (R)
// PktInfo4 encodes Inet4Pktinfo into a socket control message of type IP_PKTINFO.
// PktInfo6 encodes Inet6Pktinfo into a socket control message of type IPV6_PKTINFO.
// Plan 9 Constants
// Plan 9 directory marshalling. See intro(5).
// Plan 9 environment variables.
// Plan 9 system calls.
// Plan 9 system messages. Invented to support
// Pledge implements the pledge syscall.
// PledgeExecpromises implements the pledge syscall.
// PledgePromises implements the pledge syscall.
// Pointer represents a pointer to an arbitrary Windows type.
// Pointer-typed fields may point to one of many different types. It's"
// Poll_nocancel
// PortEvent is an abstraction of the port_event C struct.
// Posix_spawn
// Possible which values for Getitimer and Setitimer.
// PostRun: run after the Run command.
// PostRunE: PostRun but returns an error.
// PrctlRetInt performs a prctl operation specified by option and further
// PreRun: children of this command will not inherit.
// PreRunE: PreRun but returns an error.
// Pread_nocancel
// Predefined domain-relative RIDs for local groups.
// Predefined names.
// Predefined resource names and types.
// Predefined types.
// Prerelease information is anything that comes after the ""-"" in the"
// Print each possible completion to stdout for the completion script to consume.
// Print some helpful info to stderr for the user to understand.
// Print warnings if they occurred (e.g. deprecated flag messages).
// PrintDefaults prints to standard error the default values of all defined command-line flags.
// Prints to the completion script debug file (if BASH_COMP_DEBUG_FILE
// Priority class.
// Privilege attributes
// ProcThreadAttributeList is a placeholder type to represent a PROC_THREAD_ATTRIBUTE_LIST.
// ProcThreadAttributeListContainer.List.
// Proc_info
// Process Status API (PSAPI)
// Process creation flags.
// ProcessEntry32 structure defined by the Win32 API
// ProcessInformationClasses for NtQueryInformationProcess and NtSetInformationProcess.
// Profil
// Prop provider added Driver page.
// PropChangeParams is a structure corresponding to a DIF_PROPERTYCHANGE install function.
// Pselect6
// Ptrace
// PtraceGetRegSetArm64 fetches the registers used by arm64 binaries.
// PtraceGetRegs386 fetches the registers used by 386 binaries.
// PtraceGetRegsAmd64 fetches the registers used by amd64 binaries.
// PtraceGetRegsArm fetches the registers used by arm binaries.
// PtraceGetRegsArm64 fetches the registers used by arm64 binaries.
// PtraceGetRegsMips fetches the registers used by mips binaries.
// PtraceGetRegsMips64 fetches the registers used by mips64 binaries.
// PtraceGetRegsMips64le fetches the registers used by mips64le binaries.
// PtraceGetRegsMipsle fetches the registers used by mipsle binaries.
// PtraceRegs386 is the registers used by 386 binaries.
// PtraceRegsAmd64 is the registers used by amd64 binaries.
// PtraceRegsArm is the registers used by arm binaries.
// PtraceRegsArm64 is the registers used by arm64 binaries.
// PtraceRegsMips is the registers used by mips binaries.
// PtraceRegsMips64 is the registers used by mips64 binaries.
// PtraceRegsMips64le is the registers used by mips64le binaries.
// PtraceRegsMipsle is the registers used by mipsle binaries.
// PtraceSetRegSetArm64 sets the registers used by arm64 binaries.
// PtraceSetRegs386 sets the registers used by 386 binaries.
// PtraceSetRegsAmd64 sets the registers used by amd64 binaries.
// PtraceSetRegsArm sets the registers used by arm binaries.
// PtraceSetRegsArm64 sets the registers used by arm64 binaries.
// PtraceSetRegsMips sets the registers used by mips binaries.
// PtraceSetRegsMips64 sets the registers used by mips64 binaries.
// PtraceSetRegsMips64le sets the registers used by mips64le binaries.
// PtraceSetRegsMipsle sets the registers used by mipsle binaries.
// Putpmsg
// Putting a terminal into raw mode is the most common requirement:"
// Pwrite_nocancel
// Qid.Type bits
// Quotactl
// REG_NOTIFY_CHANGE_NAME notifies the caller if a subkey is added or deleted.
// REG_NOTIFY_CHANGE_SECURITY notifies the caller of changes to the security descriptor of the key.
// REG_NOTIFY_THREAD_AGNOSTIC indicates that the lifetime of the registration must not be tied to the lifetime of the thread issuing the RegNotifyChangeKeyValue call. Note: This flag value is only supported in Windows 8 and later.
// RFC 4122 variant
// RMControl returns the security descriptor resource manager control bits.
// RUSAGE_THREAD unsupported on z/OS
// RangeArgs returns an error if the number of args is not within the expected range.
// RawSyscallNoError may be used instead of RawSyscall for syscalls that don't
// Read into buffer of that size.
// ReadDirent reads directory entries from fd and writes them into buf.
// ReadLine returns a line of input from the terminal.
// ReadPassword reads a line of input from a terminal without local echo.  This
// Read_nocancel
// Readahead
// Readlink returns the destination of the named symbolic link.
// Readv
// Readv_nocancel
// Reboot
// Reboot required to take effect
// Recommended syntax is as follow:
// Recursively find matching persistent flag.
// Recvfrom
// Recvfrom_nocancel
// Recvmsg not implemented on AIX
// Recvmsg_nocancel
// RegNotifyChangeKeyValue notifyFilter flags.
// Register mapping in m and return it.
// RegisterFlagCompletionFunc should be called to register a function to provide completion for a flag.
// Release unloads DLL d from memory.
// Remainder.
// RemapFilePages
// Remember the default value as a string; it won't change.
// RemoteIovec is Iovec with the pointer replaced with an integer.
// Removal Policy (R)
// Removal Policy Override (RW)
// Remove all activeHelp entries in this case
// Remove any description that may be included following a tab character.
// Remove any description that may be included in ValidArgs.
// Remove the uncompleted flag or else there could be an error created
// RemoveCommand removes one or more commands from a parent command.
// RemoveDeviceParams is a structure corresponding to a DIF_REMOVE install function.
// Removexattr
// Replace will fully overwrite any data currently in the flag value list.
// Requires kernel >= 5.12."
// Reserved for future definition.
// Reset all attributes
// Reset everything to do noun completion.
// Reset last bit of entry point to zero
// Reset r0 to 0
// ResetFlags deletes all flags from command.
// RestartSyscall
// Restore LE stack.
// Restore R0 to $0.
// Restore g and stack pointer
// Restore go stack pointer
// Restore restores the terminal connected to the given file descriptor to a
// Retrieve ctx by calling cmd.Context() inside your *Run lifecycle or ValidArgs
// Retrieve the size of the shared memory to enable slice creation
// Return 0 on failure
// Return SVC return code
// Return entry point returned by SVC
// Return value of SleepEx and other APC functions
// Return values for GetDriveType.
// Returns a string listing the different directive enabled in the specified parameter
// Returns the address of errno in R3.
// Returns the string format of the constraints
// Rewrite leading NUL as @ for textual display.
// Rfork flags
// Root can execute any file that anybody can execute.
// Root can read and write any file.
// Root finds root command.
// Root help command.
// Round the length of a raw sockaddr up to align it properly.
// RtSigaction
// RtSigpending
// RtSigprocmask
// RtSigqueueinfo
// RtSigreturn
// RtSigsuspend
// RtSigtimedwait
// Run: Typically the actual work function. Most commands will only implement this.
// RunE: Run but returns an error.
// Runnable determines if the command is itself runnable.
// SACL returns the security descriptor SACL and whether it was defaulted. The sacl return value may be nil
// SO_PASSCRED option must be enabled on the socket.
// SPARC includes this in /usr/include/sparc64-linux-gnu/bits/socket.h
// SPDIT flags to distinguish between class drivers and
// SPDRP specifies device registry property codes
// SUOI flags control SetupUninstallOEMInf
// SVC 08 LOAD
// SVC 09
// SVC 09 DELETE
// SYS_NOSYS = 0;  // { int nosys(void); } syscall nosys_args int
// SYS_NOSYS = 8;  // { int nosys(void); } __nosys nosys_args int
// Sanity check group count.  Max is 1<<16 on Linux.
// Sanity check group count. Max is 16 on BSD.
// Sanity check group count. Max is 1<<16 on Linux.
// Save SVC return code
// Save g and stack pointer
// Save go stack pointer
// Save return code from SVC
// Save stack pointer.
// Sbrk
// Scan implements sql.Scanner so UUIDs can be read from databases transparently.
// Scan implements the SQL driver.Scanner interface.
// SchedGetPriorityMax
// SchedGetPriorityMin
// SchedGetaffinity gets the CPU affinity mask of the thread specified by pid.
// SchedGetparam
// SchedGetscheduler
// SchedRrGetInterval
// SchedSetaffinity sets the CPU affinity mask of the thread specified by pid.
// SchedSetparam
// SchedYield
// Scope is the publication scopes when binding service/service range.
// Searched for class devices
// Searched for compatible devices
// Searchfs
// Security
// SecurityDescriptorFromString converts an SDDL string describing a security descriptor into a
// See ../runtime/sys_linux_386.s for the reason why we always use int 0x80
// See https://github.com/spf13/cobra/issues/1002
// See https://msdn.microsoft.com/en-us/library/windows/desktop/aa379649(v=vs.85).aspx
// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms684179(v=vs.85).aspx"
// See https://www.freebsd.org/doc/en_US.ISO8859-1/books/porters-handbook/versions.html.
// See man cap_rights_get(3) and rights(4).
// See man cap_rights_init(3) and rights(4).
// See man cap_rights_limit(2) and rights(4).
// See mksyscall.pl.
// See the License for the specific language governing permissions and
// See the full documentation at:
// See the full documentation at:"
// See version list in https://github.com/DragonFlyBSD/DragonFlyBSD/blob/master/sys/sys/param.h
// See: https://msdn.microsoft.com/en-us/library/ff919712%28VS.85%29.aspx
// Segments returns the numeric segments of the version as a slice of ints.
// Segments64 returns the numeric segments of the version as a slice of int64s.
// Select
// Select_nocancel
// SelectedDevice method retrieves the selected device information element in a device information set.
// SelectedDriver method retrieves the selected driver for a device information set or a particular device information element.
// Sem_close
// Sem_destroy
// Sem_getvalue
// Sem_init
// Sem_open
// Sem_post
// Sem_trywait
// Sem_unlink
// Sem_wait
// Sem_wait_nocancel
// Semctl
// Semget
// Semop
// Semsys
// Semtimedop
// SemverRegexpRaw requires a separator between version and prerelease
// SendmsgN not implemented on AIX
// Sendmsg_nocancel
// Sendto
// Sendto_nocancel
// Server 2008: The LOAD_LIBRARY_SEARCH_* flags are available on
// Server example:"
// Service (R/W)
// Services.
// Set adds cpu to the set s.
// Set adds fd to the set fds.
// Set if device disabled
// Set if multiple manufacturers in class driver list
// Set implements pflag.Value.Set.
// Set our variant
// Set sets the value of the named command-line flag.
// Set sets the value of the named flag.
// Set stdin in raw mode.
// Set the seek offset of the input fd to record
// Set this to true to enable it.
// SetAnnotation allows one to set arbitrary annotations on a flag in the FlagSet.
// SetBracketedPasteMode requests that the terminal bracket paste operations
// SetClassInstallParams method sets or clears class install parameters for a device information set or a particular device information element.
// SetClockSequence sets the clock sequence to the lower 14 bits of seq.  Setting to
// SetClockSequence then it will be set automatically.  If GetTime fails to
// SetContext sets context for the command. It is set to context.Background by default and will be overwritten by
// SetControl sets the security descriptor control bits.
// SetDACL sets the absolute security descriptor DACL.
// SetDeviceInstallParams member sets device installation parameters for a device information set or a particular device information element.
// SetDeviceRegistryProperty function sets a Plug and Play device property for a device.
// SetDeviceRegistryPropertyString method sets a Plug and Play device property string for a device.
// SetErr sets the destination for error messages.
// SetFlagErrorFunc sets a function to generate an error when flag parsing
// SetGlobalNormalizationFunc sets a normalization function to all flag sets and also to child commands.
// SetGroup sets the absolute security descriptor owner.
// SetHelpCommand sets help command.
// SetHelpFunc sets help function. Can be defined by Application.
// SetHelpTemplate sets help template to be used. Application can use it to set custom template.
// SetIn sets the source for input data
// SetInet4Addr sets a C in_addr/Go []byte (4-byte IPv4 address) value in an
// SetInterspersed sets whether to support interspersed option/non-option arguments.
// SetMempolicy
// SetNodeID sets the Node ID to be used for Version 1 UUIDs.  The first 6 bytes
// SetNodeID.
// SetNodeInterface never fails when name is """"."
// SetNodeInterface selects the hardware address to be used for Version 1 UUIDs.
// SetNormalizeFunc allows you to add a function which can translate flag names.
// SetOut sets the destination for usage messages.
// SetOutput sets the destination for usage and error messages.
// SetOwner sets the absolute security descriptor owner.
// SetPrompt sets the prompt to be used when reading subsequent lines.
// SetRMControl sets the security descriptor resource manager control bits.
// SetRobustList
// SetSACL sets the absolute security descriptor SACL.
// SetSelectedDevice method sets a device information element as the selected member of a device information set. This function is typically used by an installation wizard.
// SetThreadArea
// SetTidAddress
// SetUint16 sets a C short/Go uint16 value as the Ifreq's union data.
// SetUint32 sets a C int/Go uint32 value as the Ifreq's union data.
// SetUsageFunc sets usage function. Usage can be defined by application.
// SetUsageTemplate sets usage template. Can be defined by Application.
// SetVersionTemplate sets version template to be used. Application can use it to set custom template.
// Setattrlist
// Setaudit
// Setaudit_addr
// Setauid
// SetfsgidRetGid sets fsgid for current thread and returns previous fsgid set.
// SetfsuidRetUid sets fsuid for current thread and returns previous fsuid set.
// Setitimer
// Setitimer wraps setitimer(2) to arm or disarm the timer specified by which.
// Setitimer.
// Setlcid
// Setrlimit prefers the prlimit64 system call. See issue 38604.
// Setsgroups
// Setsid_with_pid
// Setsize resizes t to s.
// SetsockoptSockFprog attaches a classic BPF or an extended BPF program to a
// Settid
// Setting things back to normal
// Setup annotations for go completions for registered flags
// SetupDiClassGuidsFromNameEx function retrieves the GUIDs associated with the specified class name. This resulting list contains the classes currently installed on a local or remote computer.
// SetupDiClassNameFromGuidEx function retrieves the class name associated with a class GUID. The class can be installed on a local or remote computer.
// SetupDiCreateDeviceInfo function creates a new device information element and adds it as a new member to the specified device information set.
// SetupDiCreateDeviceInfoListEx function creates an empty device information set on a remote or a local computer and optionally associates the set with a device setup class.
// SetupDiDestroyDeviceInfoList function deletes a device information set and frees all associated memory.
// SetupDiEnumDeviceInfo function returns a DevInfoData structure that specifies a device information element in a device information set.
// SetupDiEnumDriverInfo function enumerates the members of a driver list.
// SetupDiGetClassDevsEx function returns a handle to a device information set that contains requested device information elements for a local or a remote computer.
// SetupDiGetClassInstallParams function retrieves class installation parameters for a device information set or a particular device information element.
// SetupDiGetDeviceInstallParams function retrieves device installation parameters for a device information set or a particular device information element.
// SetupDiGetDeviceInstanceId function retrieves the instance ID of the device.
// SetupDiGetDeviceProperty function retrieves a specified device instance property.
// SetupDiGetDeviceRegistryProperty function retrieves a specified Plug and Play device property.
// SetupDiGetDeviceRegistryProperty)
// SetupDiGetDriverInfoDetail function retrieves driver information detail for a device information set or a particular device information element in the device information set.
// SetupDiGetSelectedDevice function retrieves the selected device information element in a device information set.
// SetupDiGetSelectedDriver function retrieves the selected driver for a device information set or a particular device information element.
// SetupDiOpenDevRegKey function opens a registry key for device-specific configuration information.
// SetupDiSetClassInstallParams function sets or clears class install parameters for a device information set or a particular device information element.
// SetupDiSetDeviceRegistryProperty function sets a Plug and Play device property for a device.
// SetupDiSetSelectedDevice function sets a device information element as the selected member of a device information set. This function is typically used by an installation wizard.
// SetupUninstallOEMInf uninstalls the specified driver.
// Setwgroups
// Setxattr
// Shared_region_check_np
// Shared_region_map_np
// ShellCompDirective is a bit map representing the different behaviors the shell
// ShellCompDirectiveDefault indicates to let the shell perform its default
// ShellCompDirectiveError indicates an error occurred and completions should be ignored.
// ShellCompDirectiveFilterDirs indicates that only directory names should
// ShellCompDirectiveFilterFileExt indicates that the provided completions
// ShellCompDirectiveFilterFileExt.
// ShellCompDirectiveNoFileComp indicates that the shell should not provide
// ShellCompDirectiveNoSpace indicates that the shell should not add a space
// ShellCompNoDescRequestCmd is the name of the hidden command that is used to request
// ShellCompRequestCmd is the name of the hidden command that is used to request
// Shm_open
// Shm_unlink
// Shmat
// Shmctl
// Shmdt
// Shmget
// Shmsys
// Short is the short description shown in the 'help' output.
// Should be set to TIPC_CLUSTER_SCOPE or TIPC_NODE_SCOPE.
// ShowWindow constants
// Sigaction
// Sigaltstack
// Signal table
// SignalName returns the signal name for signal number s.
// Signals
// Signals'
// Sigpending
// Sigprocmask
// Sigreturn
// Sigsuspend
// Sigsuspend_nocancel
// SilenceErrors is an option to quiet errors down stream.
// SilenceUsage is an option to silence usage when an error occurs.
// Silent install
// Simulate Getdirentries using fdopendir/readdir_r/closedir.
// Since Linux 2.6.7 and further zero value is the first available channel.
// Since the pool is stored on the Go heap, this feature may be a bad fit"
// Single-word zero for use when we need a valid pointer to 0 bytes.
// Slice is the runtime representation of a slice.
// Slice memory layout
// Slice returns a byte slice that aliases the data in the NTString.
// Slice returns a uint16 slice that aliases the data in the NTUnicodeString.
// SliceValue is a secondary interface to all flags which hold a list
// Sockaddr represents a socket address.
// SockaddrALG enables userspace access to the Linux kernel's cryptography
// SockaddrALG implements the Sockaddr interface for AF_ALG type sockets.
// SockaddrCAN implements the Sockaddr interface for AF_CAN type sockets.
// SockaddrCANJ1939 implements the Sockaddr interface for AF_CAN using J1939
// SockaddrCtl implements the Sockaddr interface for AF_SYSTEM type sockets.
// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.
// SockaddrHCI implements the Sockaddr interface for AF_BLUETOOTH type sockets
// SockaddrIUCV implements the Sockaddr interface for AF_IUCV sockets.
// SockaddrInet4 implements the Sockaddr interface for AF_INET type sockets.
// SockaddrInet6 implements the Sockaddr interface for AF_INET6 type sockets.
// SockaddrL2 implements the Sockaddr interface for AF_BLUETOOTH type sockets
// SockaddrL2TPIP implements the Sockaddr interface for IPPROTO_L2TP/AF_INET sockets.
// SockaddrL2TPIP6 implements the Sockaddr interface for IPPROTO_L2TP/AF_INET6 sockets.
// SockaddrLinklayer implements the Sockaddr interface for AF_PACKET type sockets.
// SockaddrNetlink implements the Sockaddr interface for AF_NETLINK type sockets.
// SockaddrRFCOMM implements the Sockaddr interface for AF_BLUETOOTH type sockets
// SockaddrTIPC implements the Sockaddr interface for AF_TIPC type sockets.
// SockaddrUnix implements the Sockaddr interface for AF_UNIX type sockets.
// SockaddrVM implements the Sockaddr interface for AF_VSOCK type sockets.
// SockaddrVM provides access to Darwin VM sockets: a mechanism that enables
// SockaddrVM provides access to Linux VM sockets: a mechanism that enables
// Socket control messages
// Socket related.
// SocketControlMessage represents a socket control message.
// Socketoption Level
// Socketpair
// Solaris allow up to 1024 (NGROUPS_MAX).
// Solaris doesn't have an futimes function because it allows NULL to be
// Solaris system calls.
// Some external packages rely on SYS___SYSCTL being defined to implement their
// Some terminals (e.g. xterm) will truncate lines that were
// Some versions of AIX have a bug in getsockname (see IV78655).
// Sorts commands by their names.
// Source address
// Source port
// Spare
// Split name into components.
// Splits the string `s` on whitespace into an initial substring up to
// Sstk
// Stack_snapshot
// Start the command with a pty.
// StartedByExplorer returns true if the program was invoked by the user
// StartedByExplorer returns true if the program was invoked by the user double-clicking
// Starts the process in a new session and sets the controlling terminal.
// Starts the process in a new session and sets the controlling terminal."
// Stat64_extended
// Stat_extended
// State contains the state of a terminal.
// Stats from nwmConnEntry are specific to that connection.
// Stats from nwmTCPStatsEntry are global (to the interface?)
// Storing normal writers
// String implements pflag.Value.String.
// String is the runtime representation of a string.
// String returns the full version string included pre-release
// StringToSid converts a string-format security identifier
// StringToUTF16 is deprecated. Use UTF16FromString instead.
// StringToUTF16Ptr is deprecated. Use UTF16PtrFromString instead.
// Strioctl Helpers
// SubAuthority returns the sub-authority of the SID as specified by
// SubAuthorityCount returns the number of sub-authorities in the SID.
// Such logs are only printed when the user has set the environment
// Such strings will be processed by the completion script and will be shown as ActiveHelp
// SuggestFor is an array of command names for which this command will be suggested -
// SuggestionsFor provides suggestions for the typedName.
// SuggestionsMinimumDistance defines minimum levenshtein distance to display suggestions.
// Swapoff
// Swapon
// Switch back to Go stack.
// Switch to saved LE stack.
// SyscallNoError may be used instead of Syscall for syscalls that don't fail.
// Sysfs
// System call support for 386 BSD
// System call support for 386, Plan 9"
// System call support for AMD64 BSD
// System call support for ARM BSD
// System call support for ARM64 BSD
// System call support for amd64, Plan 9"
// System call support for mips64, OpenBSD"
// System call support for plan9 on arm
// System calls for 386, Linux"
// System calls for AMD64, Linux"
// System calls for amd64, Solaris are implemented in runtime/syscall_solaris.go"
// System calls for arm, Linux"
// System calls for linux/riscv64."
// System calls for mips, Linux"
// System calls for mips64, Linux"
// System calls for ppc64, AIX are implemented in runtime/syscall_aix.go"
// System calls for ppc64, Linux"
// System calls for s390x, Linux"
// System determines whether the DLL must be loaded from the
// System needs to be restarted for this Devnode to work properly
// System specify target computer to search for.
// System specify target computer to search.
// SystemInformationClasses for NtQuerySystemInformation and NtSetSystemInformation
// SysvShmAttach attaches the Sysv shared memory segment associated with the
// SysvShmCtl performs control operations on the shared memory segment
// SysvShmDetach unmaps the shared memory slice returned from SysvShmAttach.
// SysvShmGet returns the Sysv shared memory identifier associated with key.
// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
// TIPCAddr is implemented by types that can be used as an address for
// TODO
// TODO(aram): remove hack after I fix _nsec in the pc64 kernel.
// TODO(brainman): fix all needed for net
// TODO(brainman): fix all needed for os
// TODO(mattn): SockaddrGen is union of sockaddr/sockaddr_in/sockaddr_in6_old.
// TODO(mdlayher): export as IfreqData? For now we can provide helpers such as
// TODO(mdlayher): export if and when IfreqData is exported.
// TODO(mundaym): check pre-emption rules.
// TODO(mundaym): z/OS doesn't have wait4. I don't think getrusage does what we want.
// TODO(neeilan) : Remove this 0 ( added to get sys/unix compiling on z/OS )
// TODO(neeilan): Implement use of first param (fd)
// TODO(neeilan): Pad is because the Linux kernel expects a 96-bit struct. We never pass this to the kernel; remove?
// TODO(neeilan): Remove 0 arg added to get this compiling on z/OS
// TODO(neeilan): Remove 0 in call
// TODO(neeilan): We can eliminate these epToPoll / pToEpoll calls by using identical mask values for POLL/EPOLL
// TODO(rsc): Can we use a single global basep for all calls?
// TODO: auto-generate.
// TODO: convert to unsafe.Slice once we can assume Go 1.17
// TODO: some existing code incorrectly uses ioctl when it should use ioctlPtr."
// TODO: wrap
// TOKEN_QUERY token.
// Tell SetupDiBuildDriverInfoList to do a recursive search
// Terminal contains the state for running a VT100 terminal that is capable of
// The ""asymmetric"" keyType defines restrictions requiring key payloads to be"
// The *Run functions are executed in the following order:
// The 0x80 bit is whether there was a core dump.
// The EOF case when the line is empty is handled in
// The Linger struct is wrong but we only noticed after Go 1.
// The Linux kernel faccessat system call does not take any flags.
// The RxID and TxID fields are used for transport protocol addressing in
// The SockaddrCAN struct must be bound to the socket file descriptor"
// The `attrs` parameter overrides the one set in c.SysProcAttr.
// The actual call may return less than the original reported required
// The annotation requests simple file completion.  There is no reason to do
// The argument is expected to be a function with with one uintptr-sized result. The function must not have arguments with size larger than the size of uintptr.
// The argument p point64s to a map[string]int64 variable in which to store the value of the flag.
// The argument p point64s to a map[string]int64 variable in which to store the values of the multiple flags.
// The argument p points to a []bool variable in which to store the value of the flag.
// The argument p points to a []float32 variable in which to store the value of the flag.
// The argument p points to a []float64 variable in which to store the value of the flag.
// The argument p points to a []int variable in which to store the value of the flag.
// The argument p points to a []int32 variable in which to store the value of the flag.
// The argument p points to a []int64 variable in which to store the value of the flag.
// The argument p points to a []net.IP variable in which to store the value of the flag.
// The argument p points to a []string variable in which to store the value of the flag.
// The argument p points to a []string variable in which to store the values of the multiple flags.
// The argument p points to a []time.Duration variable in which to store the value of the flag.
// The argument p points to a []uint variable in which to store the value of the flag.
// The argument p points to a bool variable in which to store the value of the flag.
// The argument p points to a duration[] variable in which to store the value of the flag.
// The argument p points to a float32 variable in which to store the value of the flag.
// The argument p points to a float32[] variable in which to store the value of the flag.
// The argument p points to a float64 variable in which to store the value of the flag.
// The argument p points to a float64[] variable in which to store the value of the flag.
// The argument p points to a int32[] variable in which to store the value of the flag.
// The argument p points to a int64[] variable in which to store the value of the flag.
// The argument p points to a int[] variable in which to store the value of the flag.
// The argument p points to a map[string]int variable in which to store the value of the flag.
// The argument p points to a map[string]int variable in which to store the values of the multiple flags.
// The argument p points to a map[string]string variable in which to store the value of the flag.
// The argument p points to a map[string]string variable in which to store the values of the multiple flags.
// The argument p points to a string variable in which to store the value of the flag.
// The argument p points to a time.Duration variable in which to store the value of the flag.
// The argument p points to a uint  variable in which to store the value of the flag.
// The argument p points to a uint variable in which to store the value of the flag.
// The argument p points to a uint32  variable in which to store the value of the flag.
// The argument p points to a uint32 variable in which to store the value of the flag.
// The argument p points to a uint64 variable in which to store the value of the flag.
// The argument p points to a uint8 variable in which to store the value of the flag.
// The argument p points to a uint[] variable in which to store the value of the flag.
// The argument p points to an []byte variable in which to store the value of the flag.
// The argument p points to an int variable in which to store the value of the flag.
// The argument p points to an int16 variable in which to store the value of the flag.
// The argument p points to an int32 variable in which to store the value of the flag.
// The argument p points to an int64 variable in which to store the value of the flag.
// The argument p points to an int8 variable in which to store the value of the flag.
// The argument p points to an net.IP variable in which to store the value of the flag.
// The argument p points to an net.IPMask variable in which to store the value of the flag.
// The argument p points to an net.IPNet variable in which to store the value of the flag.
// The arguments for fn are flag and value. Must be called after all flags are
// The arguments to the underlying system call (SYS_SOCKETCALL) are the
// The array parameter should be the array that will contain the completions.
// The bash completion script will call the bash function f for the flag.
// The below values should not be changed: programs will be using them explicitly
// The capability rights on fd can never be increased by CapRightsLimit.
// The clock sequence is only well defined for version 1 and 2 UUIDs.
// The compiled regular expression used to test the validity of a version.
// The completion script expects :<directive>
// The counter will let us know where we should start up again.
// The device is being disabled.
// The device is being enabled.
// The device is being started (if the request is for the currently active hardware profile).
// The device is being stopped. The driver stack will be unloaded and the CSCONFIGFLAG_DO_NOT_START flag will be set for the device.
// The directive integer must be that last character following a single colon (:).
// The domain should be one of Person, Group or Org."
// The field is a function (not a method) that may be changed to point to
// The following errors do not correspond to any
// The following flag can be used to install a device disabled
// The freebsd12 syscall needs a 64-bit base. On 32-bit machines
// The full SocketCAN documentation can be found in the linux kernel"
// The function doesn't even check the validity of the
// The function driver for a device reported that the device is not connected.  Typically this means a wireless device is out of range.
// The function is a variable that may be changed to point to a custom function.
// The glibc faccessat implements the flags itself; see
// The help should be sent to stdout
// The information below is extracted and adapted from <sys/stat.h> macros."
// The information below is extracted and adapted from bits/sysmacros.h in the"
// The information below is extracted and adapted from sys/types.h:"
// The initial socket setup process is as follows:
// The key of this map is a pointer to the corresponding &fCookie.cookie
// The memory layout of IfreqData (type-safe) and ifreq (not type-safe) are
// The old syscall entries are smaller than the new. Use 1/4 of the original
// The parameters for the OS X implementation vary slightly compared to the
// The pledge syscall does not accept execpromises on OpenBSD releases"
// The primary use of this package is inside other packages that provide a more"
// The properties of the device have changed.
// The ptrace syscall differs from glibc's ptrace.
// The raw regular expression string used for testing the validity
// The req value is expected to be TCGETS"
// The req value is expected to be TCSETS, TCSETSW, or TCSETSF"
// The req value will usually be TCSETA or TIOCSETA."
// The return value can be passed to Syscall to run the procedure.
// The return value is the address of a []bool variable that stores the value of the flag.
// The return value is the address of a []float32 variable that stores the value of the flag.
// The return value is the address of a []float64 variable that stores the value of the flag.
// The return value is the address of a []int variable that stores the value of the flag.
// The return value is the address of a []int32 variable that stores the value of the flag.
// The return value is the address of a []int64 variable that stores the value of the flag.
// The return value is the address of a []net.IP variable that stores the value of that flag.
// The return value is the address of a []net.IP variable that stores the value of the flag.
// The return value is the address of a []string variable that stores the value of the flag.
// The return value is the address of a []time.Duration variable that stores the value of the flag.
// The return value is the address of a []uint variable that stores the value of the flag.
// The return value is the address of a bool variable that stores the value of the flag.
// The return value is the address of a float32 variable that stores the value of the flag.
// The return value is the address of a float64 variable that stores the value of the flag.
// The return value is the address of a map[string]int variable that stores the value of the flag.
// The return value is the address of a map[string]int64 variable that stores the value of the flag.
// The return value is the address of a map[string]string variable that stores the value of the flag.
// The return value is the address of a string variable that stores the value of the flag.
// The return value is the address of a time.Duration variable that stores the value of the flag.
// The return value is the address of a uint  variable that stores the value of the flag.
// The return value is the address of a uint32  variable that stores the value of the flag.
// The return value is the address of a uint64 variable that stores the value of the flag.
// The return value is the address of a uint8 variable that stores the value of the flag.
// The return value is the address of an []byte variable that stores the value of the flag.
// The return value is the address of an int variable that stores the value of the flag.
// The return value is the address of an int16 variable that stores the value of the flag.
// The return value is the address of an int32 variable that stores the value of the flag.
// The return value is the address of an int64 variable that stores the value of the flag.
// The return value is the address of an int8 variable that stores the value of the flag.
// The return value is the address of an net.IP variable that stores the value of the flag.
// The return value is the address of an net.IPMask variable that stores the value of the flag.
// The return value is the address of an net.IPNet variable that stores the value of the flag.
// The return value will be ErrHelp if -help was set but not defined.
// The returned error is always nil.
// The returned error is always non-nil, constructed from the result of GetLastError."
// The runtime may know about them.
// The security identifier (SID) structure is a variable-length
// The slice returned does not include the \n.
// The strength of the UUIDs is based on the strength of the crypto/rand"
// The sync_file_range and arm_sync_file_range syscalls differ only in the
// The sync_file_range and sync_file_range2 syscalls differ only in the
// The third argument to ioctl is often a pointer but sometimes an integer."
// The tricky situation is if the event has fired in the kernel but
// The user cookie presents an interesting challenge from a memory management perspective.
// The user should not have a cyclic dependency on commands.
// The uuid package does not use global static storage for the clock sequence or"
// The value for a flag
// The value of each argument will not try to be separated by comma
// The value of each argument will not try to be separated by comma. Use a StringSlice for that.
// The variant specified in RFC4122
// There are two paths by which we can discover that it is no longer in use:
// There is no alignment on AIX.
// Therefore to avoid false positives we clear errno before calling it.
// These calls return err == nil to indicate success; otherwise"
// These commands are KEYCTL_DESCRIBE and KEYCTL_GET_SECURITY.
// These dimensions don't include any scrollback buffer height."
// These values should cover the same set of registry properties"
// This allows the standard completion logic to behave appropriately for flag groups
// This also makes the list of suggested flags shorter as we avoid all the = forms.
// This attempts to replicate the behaviour documented for cfmakeraw in
// This changes the execpromises and leaves the promises untouched."
// This changes the promises and leaves the execpromises untouched."
// This constant mirrors the #define of PX_PROTO_OE in
// This device is using a legacy driver
// This devnode's is an NT driver
// This devnode's is an NT enumerator
// This devnode's log_confs do not have same resources
// This does not match what most callers expect so we must return an error
// This excludes any metadata or pre-release information. For example,"
// This file is here to allow bodyless functions with go:linkname for Go 1.11
// This file simulates epoll on z/OS using poll.
// This file simulates fstatfs on z/OS using fstatvfs and w_getmntent.
// This flag is set if the Class Install params should be used.
// This flag is set if the caller of DiCallClassInstaller does NOT want the internal default action performed if the Class installer returns ERROR_DI_DO_DEFAULT.
// This forces the user to *always* have to type either an = or a space after the flag name.
// This format should not be changed: users will be using it explicitly.
// This function can be called multiple times before and/or after completions are added to
// This function returns 1 byte BOOLEAN rather than the 4 byte BOOL.
// This function should really belong to the net package.
// This function will do nothing if any of the following is true:
// This is essentially a copy of cap_rights_is_vset()
// This is essentially a copy of cap_rights_vclear()
// This is essentially a copy of cap_rights_vset()
// This is for commands that have both subcommands and ValidArgs.
// This is for commands that have subcommands but also specify a ValidArgsFunction.
// This is important for commands which have requested to do their own flag completion.
// This is needed if a description contains a linebreak.
// This is not technically the Linux semantics for
// This is not technically the Solaris semantics for
// This is sometimes used by spf13/cobra programs which want to generate additional
// This is the actual system call structure.
// This is the easy case: there's nothing on the screen that we
// This is the version of CapRights this package understands. See C implementation for parallels.
// This is useful when interoperating with Windows code requiring callbacks.
// This means Self had the lower specificity
// This next field is in host-endian byte order. We can't use the
// This one must be last to avoid messing up the iota count.
// This package allows x/sys to use types equivalent to"
// This reduces possible side-effects of creating such a command;
// This should generally not be needed. Used in some edge cases where it is needed to create a pty"
// This special character will be replaced with spacing once the
// This struct is packed on z/OS so it can't be used directly.
// This type is the union inside of TRUSTEE and must be created using one of the TrusteeValueFrom* functions.
// This value is rebuilt according to the parsed segments and other"
// This variable holds the execpromises and is always nil.
// This variable holds the promises and is always nil.
// This variable will hold either a nil unsafe.Pointer or
// This will only work for bash completion."
// This will resize the pty to the specified size before starting the command if a size is provided."
// This will resize the pty to the specified size before starting the command."
// This works by counting the arguments. Normally -- is not counted as arg but
// Throw away terminating NUL.
// Time returns the time in 100s of nanoseconds since 15 Oct 1582 encoded in
// TimeToTimespec converts t into a Timespec.
// TimerCreate
// TimerDelete
// TimerGetoverrun
// TimerGettime
// TimerSettime
// TimespecToNSec returns the time stored in ts as nanoseconds.
// Timeval have different types in the different OSes
// TimevalToNsec returns the time stored in tv as nanoseconds.
// Tkill (obsolete)
// To change fd's window size, the req argument should be TIOCSWINSZ."
// To create a *ProcThreadAttributeList, use NewProcThreadAttributeList, update"
// To create a file descriptor that provides access to a hash or cipher, both"
// To implement this using libSystem we'd need syscall_syscallPtr for
// To request directory names within another directory, the returned completions"
// ToAbsolute converts a self-relative security descriptor into an absolute one.
// ToSelfRelative converts an absolute security descriptor into a self-relative one.
// Token types
// Trailing edge.
// Translate name to mib number.
// TranslateAccountName converts a directory service
// TraverseChildren parses flags on all parents before executing child command.
// Try to fill the buffer with data
// Tuxcall
// Type implements pflag.Value.Type.
// Type returns a string that uniquely represents this flag's type.
// UIRestrictionsClass
// UTF16FromString returns the UTF-16 encoding of the UTF-8 string
// UTF16PtrFromString returns pointer to the UTF-16 encoding of
// UTF16PtrToString takes a pointer to a UTF-16 sequence and returns the corresponding UTF-8 encoded string.
// UUID Version 4 generation function will be called concurrently.
// UUID will be the lower 4 bits of version.  NewHash is used to implement
// UUIDs are based on RFC 4122 and DCE 1.1: Authentication and Security"
// UUIDs.
// UiNumber (R)
// UiNumberDescFormat (R/W)
// Uint16 returns the Ifreq union data as a C short/Go uint16 value.
// Uint32 returns the Ifreq union data as a C int/Go uint32 value.
// Umask_extended
// Umount2
// Underlying system call writes to newoffset via pointer.
// Unix environment variables.
// Unix returns the time stored in ts as seconds plus nanoseconds.
// Unix returns the time stored in tv as seconds plus nanoseconds.
// UnixCredentials encodes credentials into a socket control message
// UnixRights encodes a set of open file descriptors into a socket
// UnixTime converts t the number of seconds and nanoseconds using the Unix
// UnknownFlags will ignore unknown flags errors and continue parsing rest of the flags
// Unless required by applicable law or agreed to in writing, software"
// Unmap the memory and update m.
// UnmarshalBinary implements encoding.BinaryUnmarshaler.
// UnmarshalDir decodes a single 9P stat message from b and returns the resulting Dir.
// UnmarshalJSON implements json.Unmarshaler.
// UnmarshalText implements encoding.TextUnmarshaler interface.
// UnmarshalText implements encoding.TextUnmarshaler.
// UnquoteUsage extracts a back-quoted name from the usage
// Unveil implements the unveil syscall.
// UnveilBlock blocks future unveil calls.
// Update modifies the ProcThreadAttributeList using UpdateProcThreadAttribute.
// Upper bound on ordinals
// UpperFilters (R/W)
// Usage is the function called when an error occurs while parsing flags.
// Usage prints to standard error a usage message documenting all defined command-line flags.
// Usage puts out the usage for the command.
// UsageFunc returns either the function set by SetUsageFunc for this command
// UsagePadding return padding for the usage.
// UsageString returns usage string.
// UsageTemplate returns usage template for the command.
// Use AllGroups() for iterating.
// Use AllPrivileges() for iterating.
// Use Class Installer Provided strings in the Select Device Dlg
// Use SetsockoptLinger instead.
// Use config file from the flag.
// Use is the one-line usage message.
// Use of this source code is governed by a BSD-style
// Use our stashed reference rather than using unsafe on what we got back
// Use the Name method to access the stored interface name. The union data"
// Use the device's class when building compat drv list. (Ignored if DI_COMPAT_FROM_CLASS flag is specified.)
// Use unsafe to convert addr into a []byte.
// Use unsafe to turn sl into a []byte.
// Use unsafeSizeOf method
// UseLine puts out the full usage for a given command (including parents).
// Used for flags.
// Used when a user calls help [command].
// Used when a user provides invalid input.
// Used with GetConsoleScreenBuffer to retrieve information about a console
// Uselib
// Uses the randomness pool if it was enabled with EnableRandPool."
// Utimensat
// Utsname members on Dragonfly are only 32 bytes and
// Valid is true if UUID is not NULL
// ValidArgs (for the first argument only) or ValidArgsFunction for
// ValidArgs are only for the first argument
// ValidArgs is list of all valid non-flag arguments that are accepted in shell completions
// ValidArgsFunction is an optional function that provides valid non-flag arguments for shell completion.
// Value implements sql.Valuer so that UUIDs can be written to databases
// Value implements the driver Valuer interface.
// Value is the interface to the dynamic value stored in a flag.
// Values for the Attributes member of OBJECT_ATTRIBUTES.
// Var defines a flag with the specified name and usage string. The type and
// Variables should not contain a '-' or ':' character
// Variant is 10
// Variant returns the variant encoded in uuid.
// Various types of pre-specified SIDs that can be synthesized and compared at runtime.
// Version 1
// Version 2
// Version 4
// Version APIs
// Version defines the version for this command. If this value is non-empty and the command does not
// Version represents a single version.
// Version returns the version of uuid.
// Version that adheres strictly to SemVer specs
// Version.
// VersionTemplate return version template for the command.
// Vfork
// Vhangup
// Visit visits the command-line flags in lexicographical order or
// Visit visits the flags in lexicographical order or
// VisitAll visits the command-line flags in lexicographical order or
// VisitAll visits the flags in lexicographical order or
// VisitParents visits all parents of the command and invokes fn on each parent.
// Volume Management Functions
// Vserver
// Wait4_nocancel
// Waitevent
// Waitid
// Waitid_nocancel
// Warning: using LoadDLL without an absolute path name is subject to"
// Was enumerated by ROOT
// Watchevent
// We are just copying the boolFlag interface out of goflag as that is what
// We assume that we are working on a terminal that wraps lines
// We can ignore err here since we've pre-parsed the values in segments
// We can't rely on sa.Len being set correctly.
// We can't use the gc-syntax .s files for gccgo. On the plus side
// We cannot use finalCmd.Flags() because we may not have called ParsedFlags() for commands
// We could allocate a large buffer here to reduce the chance that the
// We found no interfaces with a valid hardware address.  If name
// We had assumed dealing with a two-word flag but the flag is a boolean flag.
// We have a prompt and possibly user input on the screen. We
// We have to get the last shorthand flag name
// We have to pass global context to children command
// We keep some constants not supported in OpenBSD 5.5 and beyond for
// We must loop as the string data may change in between the syscalls.
// We need to duplicate the incoming file descriptor
// We only complete sub-commands if:
// We only do flag completion if we are allowed to parse flags
// We only remove the flags from the arguments if DisableFlagParsing is not set.
// We shouldn't need to resize more than once
// We store the number of entries to skip in the seek
// We use an internal buffer to guarantee alignment.
// We wrap around and explicitly zero out the options provided to the OS X
// Well known namespace IDs and UUIDs
// When called with an empty keyType the command locks the keyring, preventing"
// When hashing a small byte slice or string, a single Write and Read may"
// When navigating up and down the history it's possible to return to
// Where available, just jump to package syscall's implementation of"
// Why suggest both long forms: --flag and --flag= ?
// Win32finddata is what we committed to in Go 1.
// Windows 9x-compatible maximum for displayable strings coming from a device INF.
// Windows declares this with pshpack1.h
// Windows environment variables.
// Windows reserves errors >= 1<<29 for application use.
// Windows system calls.
// WindowsXP or unpatched Windows machine
// Winsize describes the terminal size.
// Winsize is a dummy struct to enable compilation on unsupported platforms.
// Workq_open
// Workq_ops
// Works only on Microsoft Windows.
// Wraps the string `s` to a maximum width `w` with leading indent
// Write_nocancel
// Writev
// Writev_nocancel
// XXX I_FIND is not returning an error when the module
// XXX without this we are at risk of the issue
// You may obtain a copy of the License at
// Zero clears the set fds.
// ^A
// ^B
// ^E
// ^F
// ^H
// ^K
// ^L
// ^N
// ^P
// ^W
// _Sysctl
// ____semctl13
// __clone
// __disable_threadsignal
// __fhopen40
// __fhstat40
// __fhstatvfs140
// __fstat30
// __getcwd
// __getfh30
// __getlogin
// __lstat30
// __mac_execve
// __mac_get_fd
// __mac_get_file
// __mac_get_lcid
// __mac_get_lctx
// __mac_get_link
// __mac_get_mount
// __mac_get_pid
// __mac_get_proc
// __mac_getfsstat
// __mac_mount
// __mac_set_fd
// __mac_set_file
// __mac_set_lctx
// __mac_set_link
// __mac_set_proc
// __mac_syscall
// __mount50
// __msgctl13
// __msync13
// __ntp_gettime30
// __posix_chown
// __posix_fchown
// __posix_lchown
// __posix_rename
// __pthread_canceled
// __pthread_chdir
// __pthread_cond_broadcast
// __pthread_cond_destroy
// __pthread_cond_init
// __pthread_cond_signal
// __pthread_cond_timedwait
// __pthread_cond_wait
// __pthread_fchdir
// __pthread_kill
// __pthread_markcancel
// __pthread_mutex_destroy
// __pthread_mutex_init
// __pthread_mutex_lock
// __pthread_mutex_trylock
// __pthread_mutex_unlock
// __pthread_sigmask
// __semctl
// __semwait_signal
// __semwait_signal_nocancel
// __setlogin
// __shmctl13
// __sigaction_sigtramp
// __sigaltstack14
// __sigpending14
// __sigprocmask14
// __sigsuspend14
// __sigtimedwait
// __sigwait
// __sigwait_nocancel
// __stat30
// __syscall
// __sysctl
// __vfork14
// _ksem_close
// _ksem_destroy
// _ksem_getvalue
// _ksem_init
// _ksem_open
// _ksem_post
// _ksem_trywait
// _ksem_unlink
// _ksem_wait
// _lwp_continue
// _lwp_create
// _lwp_ctl
// _lwp_detach
// _lwp_exit
// _lwp_getname
// _lwp_getprivate
// _lwp_kill
// _lwp_park
// _lwp_self
// _lwp_setname
// _lwp_setprivate
// _lwp_suspend
// _lwp_unpark
// _lwp_unpark_all
// _lwp_wait
// _lwp_wakeup
// _pset_bind
// _sched_getaffinity
// _sched_getparam
// _sched_setaffinity
// _sched_setparam
// `i` runes in length and the remainder. Will go `slop` over `i` if
// `i`. The first line is not indented (this is assumed to be done by
// a '-' we know it is a flag.  We cannot use isFlagArg() here as it requires
// a '-' we know it is a flag.  We cannot use isFlagArg() here as that function
// a custom error handler.
// a handle for a path name.
// a normal exit returns no message
// a padded or an unpadded string.
// a panic will be issued.
// a read. It aliases into inBuf.
// a sysctl for the given MIB with CTL_QUERY appended.
// a zero value.
// about the ordering.
// abstract Unix domain sockets -- they are supposed
// abstract Unix domain sockets--they are supposed
// access.
// accessed by the program. The return value will be ErrHelp if -help was set
// accessed with the up and down keys.
// acct
// active mappings; key is last byte in mapping
// active.
// activeHelpEnvVar returns the name of the program-specific ActiveHelp environment
// addKeyToLine inserts the given key at the current position in the current
// adjfreq
// adjusting the fields in the result directly.
// advanced to the next line.
// after all flags are defined and before flags are accessed by the program.
// after flags have been processed.
// after the completion even if there is a single completion provided.
// after the completion.  We don't want that if the flag ends with an =
// aggregating Txflag:1 deferred:1 rsvflags:14
// aio_cancel
// aio_error
// aio_fsync
// aio_read
// aio_return
// aio_suspend
// aio_write
// all subcommands should respect it
// all.bat?)
// allocations at runtime.
// allow interspersed option/non-option args
// allowing wrapN to go a bit over if that would fit in the
// already set.  The clock sequence is only used for Version 1 UUIDs.
// although there is no description).
// an unsafe.Pointer to a string (execpromises).
// and *TIPCServiceName.
// and a pointer to an array of uintptr. We hide the pointer in the
// and adds missing persistent flags of all parents.
// and adjust the cursor position based on every previous line
// and avoids complicated marshalling and unmarshalling to csv.
// and causes your command to report an error if invoked without the flag.
// and check the flags. Otherwise the mode would be applied to the symlink
// and could therefore provide a wrong completion.
// and earlier (see https://golang.org/issue/23311).
// and metadata information.
// and netinet/in.h included via net/route.h above.
// and panics if error is non-nil.
// and run through the command tree finding appropriate matches
// and the name of the domain on which the account was found.
// and the name of the first domain on which this SID is found.
// and the new cursor position.
// and we'll get memory corruption.
// and which persist.
// and writes it to the passed writer.
// and/or output. See the netdevice(7) man page for details.
// annotation can also be used to obtain the same behavior for flags.
// any argument (can include the first one also).
// any further keys from being linked to the keyring.
// app armor/selinux etc.
// appears at the end of a sequence.
// appending the names to names. It returns the number of
// arbitrary pointer data.
// archives at: https://www.kernel.org/doc/Documentation/networking/can.txt
// are defined and before flags are accessed by the program.
// are ignored and constraints are sorted before comaparison.
// are runnable/hidden/deprecated.
// are supplied.
// are supplied. It will also panic if the procedure cannot be found.
// args is actual args parsed from flags.
// arguments after flags
// arguments to the underlying system call are the number below
// array or slice flag and therefore must continue being suggested
// as defined by the CM_DRP codes in cfgmgr32.h.
// as shown in the parenthesized examples.
// as the cmd.Flag() search only accepts long flags
// associated with the current thread. It is a pseudo token that does
// associated with the file description srcFd to the file associated with the
// assumes a simple slice of bytes if 16 bytes
// asynchronous writes
// attempt to install these via packagekit if they're not installed
// attributes for ProcThreadAttributeList
// authentication.
// autogenerating through mkerrors.sh because including
// available here: https://www.kernel.org/doc/Documentation/networking/j1939.rst
// available on the current platform.
// avoid modifying them during plan9.Wstat.
// avoid need for single quotes below
// avoid short orphan words on the final line).
// await() returns '' for no error
// back as hash output or ciphertext.
// back to raw syscalls for this func on Go 1.12.
// based on the running OpenBSD version.
// bash completion information.
// basis by using ValidArgsFunction and ShellCompDirectiveNoFileComp.
// be a private user directory in the case that the application is running
// be provided in file completion.  To request directory names within another
// be set NewUUID returns nil.  If clock sequence has not been set by
// be used:
// be valid against the constraint
// be wrong in the future because we think the cursor is
// be wrongly interpreted as actual completion choices by the completion script.
// because it serves (via godoc flag Usage) as the example
// been disabled.
// before 6.3.
// before the -- and which came after.
// behavior after completions have been provided.
// being sent to the kernel if an ifreq is reused.
// bidirectional communication between a hypervisor and its guest virtual
// big enough for int64
// boolean flags
// boolean flags only
// boolean or flags where the 'no option default value' is set
// both class & compat list shown
// boundary and not get the bytes leading up to the page
// boundary.
// bounds check hint to compiler; see golang.org/issue/14808
// break
// bufToUTF16 function reinterprets []byte buffer as []uint16
// buffer length needed to store the appropriate data. Note that this differs
// buffer size rounded up to DIRBLKSIZ (see /usr/src/lib/libc/sys/getdirentries.c).
// build driver list from INF(s) retrieved from URL specified in SP_DEVINSTALL_PARAMS.DriverPath (empty string means Windows Update website)
// but accepted if entered manually.
// but it is already in bluetooth_linux.go
// but not defined.
// but the callers below don't care.
// by adding a final Bug [2]uint16 field to the struct and then
// bytes after the NUL removed.
// bytes containing the text of s. If s contains a NUL byte at any
// bytes.
// cached list of interfaces
// call to Find() -> legacyArgs() will return an error if there are any arguments.
// call to its Handle method or to one of its
// called after all flags in the FlagSet are defined and before flags are
// caller could create a flag that turns a comma-separated string into a slice
// caller). Pass `w` == 0 to do no wrapping
// can be downloaded separately for windows 7 or 8.1).
// can be executed
// can be instructed to have once completions have been provided.
// can't be accessed
// cf. http://support.microsoft.com/default.aspx?scid=kb;en-us;257460
// cgo -godefs -- -Wall -Werror -static -I/tmp/include -fsigned-char _const.go
// cgo -godefs -- -Wall -Werror -static -I/tmp/include -fsigned-char linux/types.go | go run mkpost.go
// cgo -godefs -- -Wall -Werror -static -I/tmp/include -m32 _const.go
// cgo -godefs -- -Wall -Werror -static -I/tmp/include -m32 linux/types.go | go run mkpost.go
// cgo -godefs -- -Wall -Werror -static -I/tmp/include -m64 _const.go
// cgo -godefs -- -Wall -Werror -static -I/tmp/include -m64 linux/types.go | go run mkpost.go
// cgo -godefs -- -Wall -Werror -static -I/tmp/include _const.go
// cgo -godefs -- -Wall -Werror -static -I/tmp/include linux/types.go | go run mkpost.go
// cgo -godefs -- -fsigned-char types_freebsd.go | go run mkpost.go
// cgo -godefs -- -fsigned-char types_openbsd.go | go run mkpost.go
// cgo -godefs -- -m32 _const.go
// cgo -godefs -- -m64 _const.go
// cgo -godefs -- -maix32 _const.go
// cgo -godefs -- -maix64 _const.go
// cgo -godefs -- -marm _const.go
// cgo -godefs -- _const.go
// cgo -godefs types.go
// cgo -godefs types_aix.go | go run mkpost.go
// cgo -godefs types_darwin.go | go run mkpost.go
// cgo -godefs types_dragonfly.go
// cgo -godefs types_dragonfly.go | go run mkpost.go
// cgo -godefs types_freebsd.go
// cgo -godefs types_freebsd.go | go run mkpost.go
// cgo -godefs types_illumos.go | go run mkpost.go
// cgo -godefs types_netbsd.go | go run mkpost.go
// cgo -godefs types_openbsd.go | go run mkpost.go
// cgo -godefs types_solaris.go | go run mkpost.go
// changes are private
// changes are shared
// character (ex: `verbose`) it will only be accessible via `--verbose`
// check existing backdoors
// check if input string is not a mountpoint but a filesystem name
// check if we need to traverse here to parse local flags on parent commands
// class installer added their own power page
// clear zeroes the ifreq's union field to prevent trailing garbage data from
// clearsyscall.Errno resets the errno value to 0.
// clen returns the index of the first NULL byte in n or len(n) if n contains no NULL byte.
// clock sequence
// clock sequence as well as adjusting the clock sequence as needed.  An error
// clock sequence for this run
// clock_getres
// clock_gettime
// clock_settime
// closefrom
// cobra uses default help command.
// command does not define one.
// command lines are passed around.
// command would cause the root command to suddenly have a subcommand.
// commandCalledAs is the name or alias value used to call this command.
// commands is the list of commands supported by this program.
// commonly found on UNIX systems.
// compare sorted slices
// compat_09_ogetdomainname
// compat_09_osetdomainname
// compat_09_ouname
// compat_10_omsgsys
// compat_10_osemsys
// compat_10_oshmsys
// compat_12_fstat12
// compat_12_getdirentries
// compat_12_lstat12
// compat_12_msync
// compat_12_oreboot
// compat_12_oswapon
// compat_12_stat12
// compat_13_sigaction13
// compat_13_sigaltstack13
// compat_13_sigpending13
// compat_13_sigprocmask13
// compat_13_sigreturn13
// compat_13_sigsuspend13
// compat_14___semctl
// compat_14_msgctl
// compat_14_shmctl
// compat_16___sigaction14
// compat_16___sigreturn14
// compat_20_fhstatfs
// compat_20_fstatfs
// compat_20_getfsstat
// compat_20_statfs
// compat_30___fhstat30
// compat_30___fstat13
// compat_30___lstat13
// compat_30___stat13
// compat_30_fhopen
// compat_30_fhstat
// compat_30_fhstatvfs1
// compat_30_getdents
// compat_30_getfh
// compat_30_ntp_gettime
// compat_30_socket
// compat_40_mount
// compat_43_fstat43
// compat_43_lstat43
// compat_43_oaccept
// compat_43_ocreat
// compat_43_oftruncate
// compat_43_ogetdirentries
// compat_43_ogetdtablesize
// compat_43_ogethostid
// compat_43_ogethostname
// compat_43_ogetkerninfo
// compat_43_ogetpagesize
// compat_43_ogetpeername
// compat_43_ogetrlimit
// compat_43_ogetsockname
// compat_43_okillpg
// compat_43_olseek
// compat_43_ommap
// compat_43_oquota
// compat_43_orecv
// compat_43_orecvfrom
// compat_43_orecvmsg
// compat_43_osend
// compat_43_osendmsg
// compat_43_osethostid
// compat_43_osethostname
// compat_43_osetrlimit
// compat_43_osigblock
// compat_43_osigsetmask
// compat_43_osigstack
// compat_43_osigvec
// compat_43_otruncate
// compat_43_owait
// compat_43_stat43
// completion results from the program.  It is used by the shell completion scripts.
// completion results without their description.  It is used by the shell completion scripts.
// completion script prints its logs.
// components.
// computes a Diffie-Hellman shared secret based on the provide params. The
// concurrent access if calling with the same epfd from multiple goroutines.
// concurrent processing of a key press and a Write() call.
// consistency with the corresponding package for other operating systems.
// constants where possible The lower 16 bits of epoll events (uint32) can fit any system poll event (int16).
// constraint string. The string must be a comma-separated list of
// constraints.
// consult database-specific driver documentation for matching types.
// containing a partial key sequence
// containing the text of s. If s contains a NUL byte at any
// contains an interface name and a union of arbitrary data which can be
// continue to function but will not show up in help or usage messages. Using
// control message for sending to another process.
// convert into 100-nanosecond
// convert into nanoseconds
// correct alignment is calculated
// corresponding pty.
// could fail due to an invalid value (incomplete) for the flag.
// countToLeftWord returns then number of characters from the cursor to the
// countToRightWord returns then number of characters from the cursor to the
// creating the necessary file_obj from the provided stat information.
// creation of IPv6 sockets to return EAFNOSUPPORT.
// cron
// currently unsupported functionality on z/OS.
// cursorX contains the current X value of the cursor where the left
// cut trailing : number.
// d.dll = dll
// data generated by h.  The hash should be at least 16 byte in length.  The
// data type of a device property value in the unified device property model.
// database-specific driver documentation for matching types.
// decompose the comma-separated string into the slice.
// default
// default for every argument. One can disable file completion on a per-argument
// default to setting it to zero.
// default value (as text); for usage message
// default value (as text); if the flag is on the command line without any options
// defaultIsZeroValue returns true if the default value for this flag represents
// defaultUsage is the default function to print a usage message.
// defined and before flags are accessed by the program.
// defined by the Win32 API
// defined in afunix.h
// definition to ensure usability.
// delete 'arg' from args or break the loop if len(args) <= 1.
// delete arg from args.
// deprecate a flag by specifying its name and a usage message
// deprecate a flag shorthand by specifying its flag name and a usage message
// descriptor destFd. See the ioctl_ficlonerange(2) man page for details.
// descriptor result on the Go heap.
// descriptor srcFd to the value.Info destinations. See the
// descriptor to a multiplexor.
// dest is empty.
// destination address. To receive such a message the IP_RECVORIGDSTADDR or
// destination which is not what the user expects.
// dev_t in glibc is 64-bit, with 32-bit major and minor numbers. glibc's"
// device drivers. (Passed in 'DriverType' parameter of
// device specified by ifname.
// devices that don't use them.
// difference here is the addition of the Type method that returns a string
// directory names.
// disks
// do it here after merging all flags and just before parse
// do it here rather than with fmt to avoid dependency
// do not reorder
// do not sort commands if it already sorted or sorting was disabled
// does not have a length of 16. The bytes are copied from the slice.
// does not specify a specific interface generate a random Node ID
// doing so.
// doing this allows for completion of persistent flag names even for commands that disable flag parsing.
// domain and the users GID for the Group.  The meaning of id for
// domain with the id returned by os.Getgid.
// domain with the id returned by os.Getuid.
// don't confuse the user with questions or excess info
// don't create a new copy queue--use caller-supplied FileQueue
// don't do flag completion (see above)
// done.
// double-clicking on the executable from explorer.exe
// double-pushing modules
// driver information list APIs)
// dummy
// e.g. `-asd` => d to provide the correct completion
// each parent.
// echo is true if local echo is enabled
// edge is 0. cursorY contains the row number where the first row of
// effect
// element and modification time as the second element.
// embedded sockaddr within the Ifreq's union data. v must be 4 bytes in length
// enabled with EnableRandPool.
// enabling this mode will stop any autocomplete callback from running due to
// encoding used AIX.
// encoding used by AIX.
// encoding used by the Linux kernel and glibc.
// encoding used by z/OS.
// encoding used in Darwin's sys/types.h header.
// encoding used in Dragonfly's sys/types.h header.
// encoding used in FreeBSD's sys/types.h header.
// encoding used in NetBSD's sys/types.h header.
// encoding used in OpenBSD's sys/types.h header.
// encoding/binary helpers to write the bytes without worrying
// encoding: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
// end of line.
// enforceFlagGroupsForCompletion will do the following:
// entries contains max elements.
// env vars
// environment of the current process.
// envv are the environment variables that should be passed to the new
// epToPollEvt converts epoll event field to poll equivalent.
// epoch of 1 Jan 1970.
// epoll impl for this process.
// equivalent to TCSADRAIN for tcsetattr
// equivalent to TCSAFLUSH for tcsetattr
// equivalent to TCSANOW for tcsetattr
// err represents an operating system error describing the failure and
// errWriter is a writer defined by the user that replaces stderr
// error handling property and SortFlags set to true.
// error values see on Windows. (perhaps when running
// error.
// even if there is a single completion provided.
// even if we already found sub-commands.
// eventPoll holds a set of file descriptors being watched by the process. A process can have multiple epoll instances.
// events were actually received along with any error information.
// every registered flag.  We need to do this here (and not when the flag was registered
// everyone uses this convention.
// execpromises must be empty when Pledge is called on OpenBSD"
// execve
// extattr_delete_fd
// extattr_delete_file
// extattr_delete_link
// extattr_get_fd
// extattr_get_file
// extattr_get_link
// extattr_list_fd
// extattr_list_file
// extattr_list_link
// extattr_set_fd
// extattr_set_file
// extattr_set_link
// extattrctl
// eye catcher
// fail.
// failf prints to standard error a formatted error and usage message and
// fails.
// false.
// family and len. The path is then scanned to see if a NUL
// fchroot
// fcntl must never be called with cmd=F_DUP2FD because it doesn't work on AIX
// fdatasync
// fdopendir expects to take control of its argument.
// fgetxattr
// fhopen
// fhstat
// fhstatfs
// field and other data is always empty.
// fields can be get and set using the following methods:
// fields...
// file completion even when no completion is provided.
// file data
// file descriptor destFd. See the ioctl_ficlone(2) man page for details.
// file length
// file via a handle as previously returned by NameToHandleAt.
// fileHandle is the argument to nameToHandleAt and openByHandleAt. We
// filters for ReadDirectoryChangesW and FindFirstChangeNotificationW
// first 16 bytes of the hash are used to form the UUID.  The version of the
// first error encountered.
// fktrace
// flag in InitDefaultHelpFlag()
// flagErrorBuf contains all error messages from pflag.
// flagErrorFunc is func defined by user and it's called when the parsing of
// flagValueWrapper implements pflag.Value around a flag.Value.  The main
// flags are unused on FreeBSD
// flags for CreateToolhelp32Snapshot
// flags for EnumProcessModulesEx
// flags for JOBOBJECT_BASIC_LIMIT_INFORMATION.LimitFlags
// flags for SetErrorMode
// flags inside DNSRecord.Dw
// flags is full set of flags.
// flags of that group so the shell completion does not suggest them
// flags returns an error.
// flistxattr
// for Linux compatibility -- no zos semantics
// for Unix  compatibility -- no zos semantics
// for Version 2 UUIDs.
// for all flags in the FlagSet. Wrapped to `cols` columns (0 for no
// for an invalid value for that flag
// for backwards compatibility because moved TIOCREMOTE to Kernel.framework after MacOSX12.0.sdk.
// for commands and then corresponding flags.
// for completion) so that we can know the root command name for the prefix
// for details.
// for equality. This may not represent logical equivalence
// for how to write your own usage function.
// for security sensitive applications.
// for sending to another process. This can be used for
// for shells that support completion descriptions
// for specific types are permissible. These are defined in ioctl.go and
// for testing
// for the FlagSet (e.g. making '-' and '_' equivalent).
// for the tipc_subscr timeout __u32 field.
// fork
// forms of xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx and
// found during arg parsing. This allows your program to know which args were
// found early NUL; assume Len included the NUL
// fremovexattr
// from /usr/include/sys/param.h Macros for counting and rounding."
// from <sys/ioccom.h>
// from KEYCTL_READ's behavior which always returns the requested payload size.
// from ReadLine with the error set to ErrPasteIndicator.
// from stopped via the core dump bit.
// fsetxattr
// fstatvfs1
// fsync_range
// func gettid() uint64
// func svcLoad(name *byte) unsafe.Pointer
// func to return a given type for a given flag name
// function but will not show up in help or usage messages.
// function from module by ordinal.
// function.
// functions for specific types are permissible.
// functions.
// futimens
// future calls would be suspect. Generate an error.
// gbit16 reads a 16-bit number in little-endian order from b and returns it with the remaining slice of b.
// gbit32 reads a 32-bit number in little-endian order from b and returns it with the remaining slice of b.
// gbit64 reads a 64-bit number in little-endian order from b and returns it with the remaining slice of b.
// gbit8 reads an 8-bit number from b and returns it with the remaining slice of b.
// generator.
// generic termibits.h (which is included by termbits.h on sparc).
// getHardwareInterface returns nil values for the JS version of the code.
// getHardwareInterface returns the name and hardware address of interface name.
// getInfo retrieves a specified type of information about an access token.
// getcontext
// getfh
// getgid
// getitimer
// getlogin
// getresgid
// getresuid
// getthrid
// getvfsstat
// getxattr
// getxattr() and listxattr() return the current sizes of the named attributes.
// glibc sources:
// globNormFunc is the global normalization function
// go run linux/mksysnum.go -Wall -Werror -static -I/tmp/include -fsigned-char /tmp/include/asm/unistd.h
// go run linux/mksysnum.go -Wall -Werror -static -I/tmp/include -m32 /tmp/include/asm/unistd.h
// go run linux/mksysnum.go -Wall -Werror -static -I/tmp/include -m64 /tmp/include/asm/unistd.h
// go run linux/mksysnum.go -Wall -Werror -static -I/tmp/include /tmp/include/asm/unistd.h
// go run mkasm_darwin.go amd64
// go run mkasm_darwin.go arm64
// go run mksysctl_openbsd.go
// go run mksysnum.go /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk/usr/include/sys/syscall.h
// go run mksysnum.go /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.1.sdk/usr/include/sys/syscall.h
// go run mksysnum.go http://cvsweb.netbsd.org/bsdweb.cgi/~checkout~/src/sys/kern/syscalls.master
// go run mksysnum.go https://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/sys/kern/syscalls.master
// go run mksysnum.go https://gitweb.dragonflybsd.org/dragonfly.git/blob_plain/HEAD:/sys/kern/syscalls.master
// go run mksysnum.go https://svn.freebsd.org/base/stable/11/sys/kern/syscalls.master
// group commands.
// group name
// hardcode TIOCSWINSZ.
// hardware for version 1 UUIDs
// hasNameOrAliasPrefix returns true if the Name or any of aliases start
// have been provided (this implies none of the other directives).
// have to clear it first.
// have to move out of the way.
// head contains the index of the element most recently added to the ring.
// help message
// help topic command; additional help topic command is determined by the
// help/usage messages.
// helpFunc is help func defined by user.
// helpTemplate is help template defined by user.
// here rather than letting the caller think that the call succeeded.
// hide a flag by specifying its name
// history contains previously entered commands so that they can be
// historyPending.
// holds a value of type syscall.Errno.
// holds a value of type syscall.ErrorString.
// hope we don't get to process files so large to overflow these size
// how many files we've already returned.
// http://blogs.msdn.com/b/drnick/archive/2007/12/19/windows-and-upn-format-credentials.aspx
// http://lists.dragonflybsd.org/pipermail/users/2019-September/358280.html
// http://man7.org/linux/man-pages/man1/keyctl.1.html.
// http://man7.org/linux/man-pages/man2/keyctl.2.html
// http://man7.org/linux/man-pages/man3/keyctl_dh_compute.3.html
// http://man7.org/linux/man-pages/man3/keyctl_get_keyring_ID.3.html
// http://man7.org/linux/man-pages/man3/keyctl_instantiate_iov.3.html
// http://man7.org/linux/man-pages/man3/keyctl_join_session_keyring.3.html
// http://man7.org/linux/man-pages/man3/keyctl_restrict_keyring.3.html
// http://man7.org/linux/man-pages/man3/keyctl_search.3.html
// http://man7.org/linux/man-pages/man3/keyctl_setperm.3.html
// http://www.apache.org/licenses/LICENSE-2.0
// https://docs.microsoft.com/en-us/windows/console/console-screen-buffer-info-str
// https://docs.microsoft.com/en-us/windows/console/setconsolemode for details.
// https://github.com/spf13/cobra/issues/1257
// https://man7.org/linux/man-pages/man2/mount_setattr.2.html
// https://msdn.microsoft.com/en-us/library/ms684179(v=vs.85).aspx says:
// https://semver.org/
// https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/faccessat.c;hb=HEAD
// https://www.illumos.org/issues/9042
// https://www.kernel.org/doc/html/latest/watchdog/watchdog-api.html.
// huge mess with gnome-terminal.
// identical so pass *IfreqData directly.
// identifier constants
// if -- was already set or interspersed is false and there is already one arg then
// if TraverseChildren is true we should allow to complete subcommands
// if context is present on the parent command.
// if d.dll != nil {
// if found. It returns an error if search fails.
// if it is already found and loaded into memory.
// if not already set.
// if p.proc == nil {
// if the CLI is started from explorer.exe.
// if the CLI is started from explorer.exe. Set to 0 to wait for the return key to be pressed.
// if the command is invoked with a subset (but not all) of the given flags.
// if the command is invoked with more than one flag from the given set of flags.
// ifaliasreq contains if_data
// iflags contains inherited flags.
// ignoring error from shmdt as there's nothing sensible to return here
// ignoring manifest semantics and the application compatibility layer.
// illumos system calls not present on Solaris.
// implementations to limit completions for the named persistent flag to
// implementations to limit completions for the named persistent flag to the
// in [rare] case of concurrent epollcreate + epollwait
// in a signal handler for syscall.SIGWINCH to automatically resize the tty when
// in a variety of automatic locations unless constrained by flags.
// in case the program also registered a completion function for this flag.
// in each line) in terminal t.
// in http://msdn.microsoft.com/en-us/library/ms880421.
// in the CAA
// in the LCA
// inReader is a reader defined by the user that replaces stdin
// in_addr/Go []byte (4-byte IPv4 address) value. If the sockaddr family is not
// include the command name.  Must be called after all flags in the FlagSet
// include the command name. The arguments for fn are flag and value. Must be
// including OS X (Darwin) and FreeBSD.  Like the other
// inclusive
// increment the clock sequence
// indirect
// initDefaultCompletionCmd adds a default 'completion' command to c.
// initialize completion at the last point to allow for user overriding
// initialize help and version flag at the last point possible to allow for user
// initialize help at the last point to allow for user overriding
// initialize the hidden command to be used for shell completion
// installed packages
// instead we pack it here.
// integer array of open file descriptors from another process.
// integer that is returned by the ioctl syscall.
// interfaces is returned.  If no interfaces are found (name does not exist or
// interpret pasted data more literally than typed data.
// ints and then compared.
// invalidate mappings
// ioctlIfreqData performs an ioctl using an ifreqData structure for input
// ioctl_fideduperange(2) man page for details.
// ioctl_linux.go.
// is a shortcut to using this directive explicitly.
// is a shortcut to using this directive explicitly.  The BashCompFilenameExt
// is already pushed even though truss reports a return
// is commonly used for inputting passwords and other sensitive data. The slice
// is in the high bits.
// is in the high bits.  At least that's the idea.
// is in the high bits. At least that's the idea.
// is longer.
// is no way for the version to be valid against the constraint
// is returned if the current time cannot be determined.
// is returned.
// is set to a file path) and optionally prints to stderr.
// is set to a file path) and to stderr.
// issue 1435.
// it can be used as a scan destination:
// it must be of the form  xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
// just do nothing
// kernel uses +2 for its own implementation of this function.
// kernels still require 32-bit aligned access to network
// ktrace
// last element of path
// last modifier name
// last read time
// last time we returned
// last write time
// lchflags
// lchmod
// ld compares two strings and returns the levenshtein distance between them.
// length is not zero.
// let the logic continue to see if ValidArgsFunction needs to be called.
// lets you read back the array of integers form.
// lflags contains local flags.
// lfs_bmapv
// lfs_markv
// lfs_segclean
// lfs_segwait
// lgetxattr
// license that can be found in the LICENSE file.
// limit completions for the named flag to directory names.
// limit completions for the named flag to the specified file extensions.
// limitations under the License.
// line is the current line being entered.
// line of a command when printing help or generating docs
// line.
// lines and generates system call stubs.
// linux variant.
// linux/if_pppox.h causes some declaration conflicts with other
// linux/if_pppox.h. We're defining this by hand here instead of
// lio_listio
// list current user + groups
// list users
// listxattr
// llistxattr
// loadLibraryEx wraps the Windows LoadLibraryEx function.
// loaded from system32.
// local flags because we can use a local flag on a parent command
// localNonPersistentFlags are used to stop the completion of subcommands when one is set
// lock for reading and writing from flagCompletionFunctions
// lock protects the terminal and the state in this object from
// longer supported on darwin.
// look up the flag that will also be translated. So it would be possible to create
// loop for parts to find the first difference
// loops here (instances watching each other) and return ELOOP.
// lot of unsafe.Pointer casts to use properly.
// lowercase; only we can define Sockaddrs
// lremovexattr
// lseek
// lsetxattr
// lutimes
// machines.
// madvise
// majmin returns major and minor version number for an OpenBSD system.
// make change in all hardware profiles
// make change in specified profile only
// make copies to retain order of the original slices
// make possible 'help' flag to be shown
// manifest semantics but is affected by the application compatibility layer.
// maps or compared directly.
// maxLine is the greatest value of cursorY so far.
// maxlen + 2 comes from + 1 for the \x00 and + 1 for the (deliberate) off-by-one in maxlen-sidx
// may be empty if the terminal doesn't support them.
// may be re-used repeatedly with subsequent Write and Read operations.
// may improve the UUID generation throughput significantly.
// meanings of bits 0-15 or wasting time and space shifting bits 16-31 for
// means the immediately previous entry.
// mergePersistentFlags merges c.PersistentFlags() to c.Flags()
// messages.
// messages. Using this flag will also print the given usageMessage.
// mincore
// minherit
// minor components.
// missing parts (1.0 => 1.0.0) will be made into a canonicalized form
// mixed
// mkerrors.sh
// mkerrors.sh -Wall -Werror -static -I/tmp/include
// mkerrors.sh -Wall -Werror -static -I/tmp/include -fsigned-char
// mkerrors.sh -Wall -Werror -static -I/tmp/include -m32
// mkerrors.sh -Wall -Werror -static -I/tmp/include -m64
// mkerrors.sh -m32
// mkerrors.sh -m64
// mkerrors.sh -maix32
// mkerrors.sh -maix64
// mkerrors.sh -marm
// mksysnum_plan9.sh /opt/plan9/sys/src/libc/9syscall/sys.h
// mmap - page can be read
// mmap varies by architecture; see syscall_linux_*.go.
// mmap2 also requires arguments to be passed in a struct; it is currently not exposed in <asm/unistd.h>.
// modctl
// mode and returns the previous state of the terminal so that it can be
// mount
// mountpoint is always a full path and starts with a '/'
// move left by a word.
// move right by a word.
// moveCursorToPos appends data to t.outBuf which will move the cursor to the
// mq_close
// mq_getattr
// mq_notify
// mq_open
// mq_receive
// mq_send
// mq_setattr
// mq_timedreceive
// mq_timedsend
// mq_unlink
// mquery
// mremap
// msgctl
// msgget
// msgrcv
// msgsnd
// msync - synchronous writes
// much of the functionality can be written directly in Go.
// mustFind is like Find but panics if search fails.
// mustLoad is like Load but panics if search fails.
// name as it appears on command line
// name of interface being used
// name_to_handle_at (see NameToHandleAt) and open_by_handle_at (see
// need to be shown in the usage/help default template under 'available commands'.
// need to write a newline so that our cursor can be
// net api calls
// net.IPMask.String() actually outputs things like ffffff00
// network
// new file descriptor referring to the same directory.
// new persistent flags of all parents.
// nfssvc
// nil means stderr; use out() accessor
// nnpfspioctl
// no Browse... in InsertDisk
// no completion is provided.
// nodeID with only 0's
// non nil once DLL is loaded
// non-boolean and flags without a 'no option default value'
// non-boolean flags
// non-inherited flags.
// non-negative integer that is returned by the prctl syscall.
// not consistent with Bash completion. It has therefore been disabled.
// not defined in ioctl.h -- zos golang only
// not hidden or deprecated.
// not need to be closed.
// not needed for binaries built for Windows.
// not pointer width.
// not trigger file completions.
// not used
// not valid.  The NodeID is only well defined for version 1 and 2 UUIDs.
// ntp_adjtime
// null implementation for js
// number and m is a hex digit of the minor number. This is backward compatible
// number below and a pointer to an array of uintptr.
// nwmConnEntry constants
// nwmFilter constants
// nwmHeader constants
// object name from one format to another.
// objects and to control the ability of the user to perform various
// obtain the same behavior but only for flags.
// of Iovec (each of which represents a buffer) instead of a single buffer.
// of OpenBSD the syscall is called sysctl instead of __sysctl.
// of __<prefix>_go_custom_completion
// of a trailing tab when there are no description following it.
// of a version.
// of bytes written (returning an error if there is insufficient space in the
// of calling Getdirentries or ReadDirent repeatedly.
// of compared constraints.
// of id are used.  If id is less than 6 bytes then false is returned and the
// of openbsd/386 the syscall is called sysctl instead of __sysctl.
// of openbsd/amd64 the syscall is called sysctl instead of __sysctl.
// of openbsd/arm the syscall is called sysctl instead of __sysctl.
// of that group required so that the shell completion suggests them automatically
// of the latter because they have doubled every full line.
// of the network device specified by ifname.
// of the network device specified by ifreq.Name.
// offs2lohi splits offs into its lower and upper unsigned long. On 64-bit
// offset of fd. See issue #31368.
// on the executable from explorer.exe
// one of:
// one-letter abbreviated flag
// one. The kernel expects SID to be in network byte order.
// only BTPROTO_L2CAP and BTPROTO_RFCOMM can accept connections
// only add the installed driver to the class or compat driver list.  Used in calls to SetupDiBuildDriverInfoList
// only be 32 bytes.
// only be called when there is no possibility that New or any other
// only currently 'live' device interfaces
// only include similar drivers in class list
// only on flags without a default value
// only restart the device drivers are being installed on as opposed to restarting all devices using those drivers.
// only valid with DIGCF_DEVICEINTERFACE
// optional arguments arg2 through arg5 depending on option. It returns a
// optional interface to indicate boolean flags that can be
// or 0 if a signal with such name is not found.
// or SetNodeInterface then it will be set automatically.  If the NodeID cannot
// or an error will be returned.
// or any program that uses CommandLineToArgv.
// or blank if there is no prerelease data.
// or deprecated.
// or the timeout has been exceeded. It will return how many
// or was overestimating.
// order of their arguments.
// order to achieve different styles of text.
// os info:
// osVersionInfoSize member. Disassembling ntdll.dll indicates
// other native functions.
// others do not. Work around this by subtracting the leading
// otherwise
// otherwise attempts to parse
// otherwise ignore \n
// otherwise ignore \r
// outBuf contains the terminal data to be sent.
// outWriter is a writer defined by the user that replaces stdout
// output. See the netdevice(7) man page for details.
// outputDesc field is filled by EZBNMIF4 on success
// overriding
// owner name
// p.proc = proc
// pToEpollEvt converts 16 bit poll event bitfields to 32-bit epoll event fields.
// package.
// pad
// pad to 8 byte boundary
// padding-register for alignment on ARM.
// page can be written
// parent is a parent command for this command.
// parentsPflags is all persistent flags of cmd's parents.
// parse boolean values into slice
// parse ip values into slice
// parsing cannot fail as the reader/writer are simply for local strings
// partial sequence. It's not clear how one should find the end of a
// particularly useful when testing.
// passing the integer value directly.
// passwordReader is an io.Reader that reads from a specific file descriptor.
// pasteActive is true iff there is a bracketed paste operation in
// path.
// payload of the passed data length occupies.
// pbit16 copies the 16-bit number v to b in little-endian order and returns the remaining slice of b.
// pbit32 copies the 32-bit number v to b in little-endian order and returns the remaining slice of b.
// pbit64 copies the 64-bit number v to b in little-endian order and returns the remaining slice of b.
// pbit8 copies the 8-bit number v to b and returns the remaining slice of b.
// peIntToExt converts a cgo portEvent struct into the friendlier PortEvent
// permissions
// pflags contains persistent flags.
// place exactly
// places.
// pledgeAvailable checks for availability of the pledge(2) syscall
// pmc_control
// pmc_get_info
// point
// pollts
// populate stat
// pos is the logical position of the cursor in line
// pp.Addrtype.
// pre-release.
// preadv
// preadv/pwritev chose this calling convention so they don't need to add a
// preserved if it were cast into the byte array of a raw ifreq.
// press is processed normally. Otherwise it returns a replacement line
// previous state.
// printers
// privileges. The system uses the token to control access to securable
// process executed on behalf of the user has a copy of the token.
// process with TOKEN_QUERY access. It is a real token that needs to be closed.
// processes
// profil
// program. It will continue to function but will not show up in help or usage
// progress.
// prompt is a string that is written at the start of each input line (i.e.
// protected with poolMu
// protocol (https://en.wikipedia.org/wiki/SAE_J1939). For more information
// pselect
// pset_assign
// pset_create
// pset_destroy
// ptrace
// pushing terminal driver STREAMS modules as per pts(7)
// pwritev
// queue appends data to the end of t.outBuf
// quotactl
// r1
// r2
// r2 is not used. Always set to 0
// race condition immediately after setting setuid?
// rand should never fail
// random clock sequence is generated the first time a clock sequence is
// random function
// randomBits completely fills slice b with random data.
// range of data conveyed in value from the file associated with the file
// range of data conveyed in value to the file associated with the file
// rasctl
// read flag arguments with CSV parser
// readInt returns the size-bytes unsigned integer in native byte order at offset off.
// readLine().
// readPasswordLine also ignores any \r it finds.
// readPasswordLine reads from reader until it finds \n or io.EOF.
// readdir_r
// reading lines of input.
// reads until it finds \r and ignores any \n it finds during processing.
// readv
// reboot
// receive at least one normal byte
// recompute all lengths
// reference to the cookie around until the event is processed
// reflect.SliceHeader and reflect.StringHeader without introducing
// reflection.
// release the shared memory if we can't find the size
// remainder contains the remainder of any partial key sequences after
// remainder of the line.
// remove all quote characters
// remove terminating null
// remove the flag name argument from the list of finalArgs or else the parsing
// removexattr
// renameat
// reported upstream.
// requires the flag name to be complete
// restarting is O(n^2) in the length of the directory. Oh well.
// restore the terminal after a signal.
// restored.
// restrictions.
// result on the Go heap.
// result shares underlying state. Use Openat to make a really
// return an error - execpromises is not available before 6.3
// return the current NewUUID returns nil and an error.
// return true on the first found available 'help' sub command
// return true on the first found available (non deprecated/help/hidden)
// returned by Context after one of these functions has been called.
// returned does not include the \n.
// returning an error.
// returning nil if none exists.
// returning the remaining slice of b..
// returns the error.
// returns the file descriptors.
// returns the same results.
// rfork
// root directory of the access token t user's profile.
// round up to microsecond
// rpad adds padding to the right of a string.
// rsrvd1
// rsrvd2
// rsrvd3
// rsrvd4
// rsrvd5
// s is now at least 36 bytes long
// sa_enable
// sa_preempt
// sa_register
// sa_setconcurrency
// sa_stacks
// sa_yield
// same code as pty_darwin.go
// same everywhere else) until the mips64 generator issue is fixed.
// sbrk
// sched_yield
// screen buffer. See
// search Windows System directory for the DLL if name is
// seconds between epochs
// secret is written to the provided buffer and the returned size is the number
// see /usr/include/sys/ptms.h
// see /usr/include/sys/stropts.h
// see /usr/include/sys/termios.h
// see Parse for required string format
// see if there are any ArgAliases that should be completed.
// see linux/net.h
// see:
// see: https://dirtypipe.cm4all.com/
// self-relative security descriptor object allocated on the Go heap.
// semconfig
// semget
// semop
// send at least one normal byte
// sendfile
// server subtype
// server type
// services
// setcontext
// setfsgid(2) will return a non-nil error only if its caller lacks CAP_SETUID capability
// setfsgid(2) will return a non-nil error only if its caller lacks CAP_SETUID capability.
// setgroups
// setitimer
// setsockopt
// setxattr
// shared memory identifier id.
// shmat
// shmctl
// shmdt
// shmget
// should be impossible to get here as we always declare a help
// should be used as file extension filters.
// should be used with a given socket.
// should not be part of the list of arguments
// show class list
// show compatibility list
// sic
// sigaction
// sigaltstack
// sigpending
// sigprocmask
// sigreturn
// sigsuspend
// similar to aliases but only suggests.
// size CTL_MAXNAME+2 but use only CTL_MAXNAME
// size contains the number of elements in the ring.
// size so ensure we deal with that.
// slice and string implementations.
// so that versions can be sorted.
// so we don't need to deal with it here.
// so write a horrible parser for that as well  :-(
// sockcmsg_dragonfly.go
// socket associated with fd at the given socket level.
// socket to filter incoming packets.  See 'man 7 socket' for usage information.
// socketcall assembly to avoid allocation on every system call.
// sortFlags returns the flags as a slice in lexicographical sorted order.
// source address is only specified if the socket is unconnected
// space between indent i and end of line width w into which
// spaces.
// special case above)
// specified by id.
// specified by which.
// specified file extensions.
// split both pre releases for analyse their parts
// split into high / low
// sstk
// stRingBuffer is a ring buffer of strings.
// start of the next word.
// start of the previous word.
// statvfs1
// streamsPush pushes STREAMS modules if not already done so.
// string for a flag and returns it and the un-quoted usage.
// string.
// struct flock is packed on z/OS. We can't emulate that in Go so
// structure used to uniquely identify users or groups.
// structure) which are not hidden or deprecated.
// sub command
// sub commands
// subsystem.
// subsystem. The Type and Name fields specify which type of hash or cipher
// sudo -l
// supplied name space and data.  It is the same as calling:
// support Other... button
// svc_EZBNMIF4
// swapctl
// sysLinger is the real system call structure.
// sysarch
// syscall
// syscall entry
// syscall expects a NULL-terminated string.
// syscall interface implementation for other packages
// syscall_*.go files it is compiled as Go code but also
// syscall_bsd.go or syscall_unix.go.
// syscall_solaris.go or syscall_unix.go.
// sysctlmib translates name to mib number and appends any additional args.
// system-modified data
// system-related operations on the local computer.
// system. If you want godoc to display OS documentation for another
// system. If you want godoc to display documentation for another
// system. If you want godoc to display syscall documentation for another
// systems by fcntl_linux_32bit.go to be SYS_FCNTL64.
// systems that have KB2533623 installed. To determine whether the
// t.lock must be held at this point
// t.remainder is a slice at the beginning of t.inBuf
// template generation.
// terminator still exists within the length.
// than that of time.Time values.  So if t is out of the valid range of
// that are not hidden.
// that encompasses the entire string (which allows the caller to
// that go along with 'unknown command' messages.
// that have set DisableFlagParsing; it is ParseFlags() that merges the inherited and
// that need to be shown in the usage/help default template under 'additional help
// that since it is the default behavior anyway.  Let's ignore this annotation
// that support them
// that the documentation is indeed correct about that.
// that the returned line consists only of pasted data. Programs may wish to
// that the user has entered.
// that we can use on every pflag set and children commands
// the 6-argument calls like sendto and recvfrom. Instead the
// the FlagSet
// the current line is 0.
// the current process. It is a pseudo token that does not need
// the current thread. It is a pseudo token that does not need
// the directory being edited underfoot.
// the domain Org or on non-POSIX systems is site defined.
// the end of any wrapped line.
// the error. The error will be guaranteed to contain windows.Errno.
// the expression
// the extra added -- is counted as arg.
// the file server's unique identification for the file
// the flag from newSet will be ignored.
// the flag name to be complete
// the flag set is CommandLine.
// the full input line and the current position of the cursor (in
// the hash digest instead of creating a new one for a given chunk and finalizing it.
// the key and the remainder of the input. Otherwise it returns utf8.RuneError.
// the manuals for the appropriate operating system.
// the more common *uint16 string type.
// the new socket.
// the next line instead.
// the path is not a symlink or junction but another type of reparse
// the performance loss is negligible.
// the primary group of any objects created by a process using this access token.
// the promise of compatibility.
// the pty receives a window size change notification.
// the random number generator on demand in batches. Enabling the pool
// the same pre release!
// the syscall returns ENOMEM in case the actual value
// the termios(3) manpage.
// the these symbols are loaded by the system linker and are required to
// the type of the file (plan9.QTDIR for example)
// the unsafe version would be (*fileObj)(unsafe.Pointer(uintptr(peInt.Object)))
// the user hasn't requested/received it yet.
// the value specified by arg and passes a dummy pointer to bufp.
// them here for backwards compatibility.
// then a map of each flag name and whether it is set or not.
// there are any positional args that are not in the `ValidArgs` field of `Command`
// there are not exactly N positional args OR
// these functions.
// these structures. We just include them copied from <bits/termios.h>.
// this command or an empty string if the command has not been called.
// this flag will also print the given usageMessage.
// this means Other had the lower specificity
// those packages rather than this one if you can.
// threxit
// thrsigdivert
// thrsleep
// thrwakeup
// timer_create
// timer_delete
// timer_getoverrun
// timer_gettime
// timer_settime
// to '>0.2' it is *NOT* treated as equal.
// to Pointer. The caller must obey the unsafe.Pointer rules while
// to automatically enable in CLI tools.
// to be closed.
// to be uninterpreted fixed-size binary blobs -- but
// to be uninterpreted fixed-size binary blobs--but
// to consider the rounding error.
// to freebsd and $GOARCH to arm.
// to register a Go function which will work across all shells.
// to retrieve arbitrary-length data.
// to see if Path or Fd was the event source. The other will be
// to the length provided in the structure.
// to the same file as where the completion script prints its logs.
// to the user.
// to this command (local and persistent declared here and by all parents).
// to valid line data. It indicates that bracketed paste mode is enabled and
// to write the later checks
// topics'.
// treat name as mountpoint
// trim terminating \r and \n
// trivially stub this ourselves.
// two different forks are versioned differently
// uint64
// undelete
// under a terminal server.
// underlying call to port_create(3c).
// unified device property model.
// uninitialized.
// union of sockaddr4 and sockaddr6
// unique id from server
// unveil calls is handled by UnveilBlock.
// update max lengths
// updateParentsPflags updates c.parentsPflags by adding
// urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
// urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx are decoded as well as the
// usageFunc is usage func defined by user.
// usageTemplate is usage template defined by user.
// use TIOCSPTLCK with a pointer to zero to clear the lock
// use the Ifreq.withData method.
// used as input to mksyscall which parses the //sys
// used by cobra.Command bash autocomple code
// used by cobra.Command to allow flags to be hidden from help/usage text
// used with %v formatting directives.
// using Bind before the CAN socket can be used.
// using the HCI protocol.
// using the L2CAP protocol.
// using the RFCOMM protocol.
// using the specified flags.
// utf16ToBuf function reinterprets []uint16 as []byte
// utrace
// uuid.  The time is only defined for version 1 and 2 UUIDs.
// uuidgen
// vadvise
// valid null UUID
// validateFlagGroups validates the mutuallyExclusive/requiredAsGroup logic and returns the
// validating the name does not exceed IFNAMSIZ-1 (trailing NULL required)
// value as set
// value of 1. A bug in the Go Solaris syscall interface?
// values.
// variable BASH_COMP_DEBUG_FILE to the path of some file to be used.
// variable.  It has the format <PROGRAM>_ACTIVE_HELP where <PROGRAM> is the name of the
// version number for given Path
// versionTemplate is the version template defined by user.
// vfork
// visualLength returns the number of visible glyphs in s.
// vuln was introduced in 0.105-26
// vuln was introduced in 0.113
// vuln was patched in 0.105-31
// vuln was patched in 0.113
// we can add methods to it.
// we can move back to the beginning and repaint everything.
// we can return what we found.
// we can't just use the basep passed in. See #32498.
// we do not want to lose arg in this case
// we may have cap of old less than size of dirent_freebsd11.
// we should delete it from our map. We can still return ENOENT to the caller.
// we should wrap the text.
// we still have some buffer to flush
// we suggest it as a completion
// weird race condition when running an image that was just built - sleeping for a second solves it
// what package os and others expect.
// when a -- was found during args parsing.
// when the third argument is an integer.
// when writing a character. But that doesn't happen
// where instead of ECONNABORTED error socket
// whether it was launched from explorer.exe
// which parses the //sys lines and generates system call stubs.
// which to search.  The BashCompSubdirsInDir annotation can be used to
// will be fixed to change variable type as suitable.
// will be printed by generating docs for this command.
// will result in
// will silently write 2 words farther than we specify
// will still scan the name for a NUL but only
// wincrypt.h
// windows api calls
// windows hook
// winuser.h
// with Setsockopt and Getsockopt.
// with a tab at the end (or else zsh will show a -- following it
// with a terminating NUL and any bytes after the NUL removed.
// with blanks. Initializing with blanks allows the caller to feed in either
// with both `-v` and `--v` in flags. If the golang flag was more than a single
// with netinet/in.h). Given that we only need a single zero constant
// with prefix
// with the possibility of straddling an invalid page.
// with the same base segments.
// withData produces an ifreqData with the pointer p set for ioctls which require
// without a controlling terminal.
// would confuse the Go garbage collector.
// wrap it in our own nicer implementation.
// wrapping and turning into two. This causes the prompt on
// wrapping)
// writeWithCRLF writes buf to w but replaces all occurrences of \n with \r\n.
// writev
// writing a character (except a new line) that causes
// ws_col: Number of columns (in cells)
// ws_row: Number of rows (in cells)
// ws_xpixel: Width in pixels
// ws_ypixel: Height in pixels
// xtob converts hex characters x1 and x2 into a byte.
// xvalues returns the value of a byte as a hexadecimal digit or 255.
// xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
// xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
// you may not use this file except in compliance with the License.
// you to define the usage and description as part of your command
// zero values for CAN_RAW and CAN_BCM sockets as they have no meaning.
// ztypes generation.
// { caddr_t sbrk(size_t incr); }
// { gid_t getegid(void); }
// { gid_t getgid(void); }
// { gid_t sys_getegid(void); }
// { gid_t sys_getgid(void); }
// { gid_t|sys||getegid(void); }
// { gid_t|sys||getgid_with_egid(void); }
// { int __mac_get_proc(struct mac *mac_p); }
// { int __mac_set_proc(struct mac *mac_p); }
// { int __setugid(int flag); }
// { int acct(char *path); }
// { int aio_error(struct aiocb *aiocbp); }
// { int aio_mlock(struct aiocb *aiocbp); }
// { int aio_read(struct aiocb *aiocbp); }
// { int aio_return(struct aiocb *aiocbp); }
// { int aio_write(struct aiocb *aiocbp); }
// { int auditctl(char *path); }
// { int cap_enter(void); }
// { int cap_getmode(u_int *modep); }
// { int chdir(char *path); }
// { int chroot(char *path); }
// { int chroot_kernel(char *path); }
// { int close(int fd); }
// { int closefrom(int fd); }
// { int closefrom(int lowfd); }
// { int cpuset(cpusetid_t *setid); }
// { int dup(int fd); }
// { int dup(u_int fd); }
// { int exec_sys_register(void *entry); }
// { int exec_sys_unregister(int id); }
// { int fchdir(int fd); }
// { int fdatasync(int fd); }
// { int ffclock_getcounter(ffcounter *ffcount); }
// { int ffclock_getestimate( struct ffclock_estimate *cest); }
// { int ffclock_setestimate( struct ffclock_estimate *cest); }
// { int fork(void); }
// { int fsync(int fd); }
// { int getaudit(struct auditinfo *auditinfo); }
// { int getauid(uid_t *auid); }
// { int getcontext(struct __ucontext *ucp); }
// { int getdtablesize(void); }
// { int getfsstat( \
// { int getpgid(pid_t pid); }
// { int getpgrp(void); }
// { int getsid(pid_t pid); }
// { int gssd_syscall(char *path); }
// { int issetugid(void); }
// { int jail(struct jail *jail); }
// { int jail_attach(int jid); }
// { int jail_remove(int jid); }
// { int kldfind(const char *file); }
// { int kldfirstmod(int fileid); }
// { int kldload(const char *file); }
// { int kldnext(int fileid); }
// { int kldunload(int fileid); }
// { int kmq_unlink(const char *path); }
// { int kqueue(void); }
// { int ksem_close(semid_t id); }
// { int ksem_destroy(semid_t id); }
// { int ksem_post(semid_t id); }
// { int ksem_trywait(semid_t id); }
// { int ksem_unlink(const char *name); }
// { int ksem_wait(semid_t id); }
// { int ktimer_delete(int timerid); }
// { int ktimer_getoverrun(int timerid); }
// { int lwp_create(struct lwp_params *params); }
// { int mlockall(int how); }
// { int modfind(const char *name); }
// { int modfnext(int modid); }
// { int modnext(int modid); }
// { int mq_close(mqd_t mqdes); }
// { int mq_unlink(const char *name); }
// { int munlockall(void); }
// { int ntp_adjtime(struct timex *tp); }
// { int ntp_gettime(struct ntptimeval *ntvp); }
// { int obreak(char *nsize); } break obreak_args int
// { int ovadvise(int anom); } vadvise ovadvise_args int
// { int pipe(void); }
// { int posix_openpt(int flags); }
// { int reboot(int opt); }
// { int revoke(char *path); }
// { int rfork(int flags); }
// { int rmdir(char *path); }
// { int sbrk(int incr); }
// { int sched_get_priority_max (int policy); }
// { int sched_get_priority_min (int policy); }
// { int sched_getscheduler (pid_t pid); }
// { int sched_yield (void); }
// { int setaudit(struct auditinfo *auditinfo); }
// { int setauid(uid_t *auid); }
// { int setcontext( const struct __ucontext *ucp); }
// { int setegid(gid_t egid); }
// { int seteuid(uid_t euid); }
// { int setfib(int fibnum); }
// { int setgid(gid_t gid); }
// { int setlogin(char *namebuf); }
// { int setloginclass(const char *namebuf); }
// { int setsid(void); }
// { int setuid(uid_t uid); }
// { int shm_unlink(const char *path); }
// { int shmdt(const void *shmaddr); }
// { int sigpending(sigset_t *set); }
// { int sigreturn( const struct __ucontext *sigcntxp); }
// { int sigreturn(ucontext_t *sigcntxp); }
// { int sigsuspend(const sigset_t *sigmask); }
// { int sstk(int incr); }
// { int sstk(size_t incr); }
// { int swapoff(char *name); }
// { int swapoff(const char *name); }
// { int swapon(char *name); }
// { int sync(void); }
// { int sys___tmpfd(int flags); }
// { int sys_acct(const char *path); }
// { int sys_chdir(const char *path); }
// { int sys_chroot(const char *path); }
// { int sys_close(int fd); }
// { int sys_closefrom(int fd); }
// { int sys_dup(int fd); }
// { int sys_fchdir(int fd); }
// { int sys_fork(void); }
// { int sys_fsync(int fd); }
// { int sys_getdtablecount(void); }
// { int sys_getpgrp(void); }
// { int sys_getrtable(void); }
// { int sys_issetugid(void); }
// { int sys_kqueue(void); }
// { int sys_mlockall(int flags); }
// { int sys_munlockall(void); }
// { int sys_obreak(char *nsize); } break
// { int sys_pipe(int *fdp); }
// { int sys_reboot(int opt); }
// { int sys_revoke(const char *path); }
// { int sys_rmdir(const char *path); }
// { int sys_sched_yield(void); }
// { int sys_setegid(gid_t egid); }
// { int sys_seteuid(uid_t euid); }
// { int sys_setgid(gid_t gid); }
// { int sys_setlogin(const char *namebuf); }
// { int sys_setrtable(int rtableid); }
// { int sys_setsid(void); }
// { int sys_setuid(uid_t uid); }
// { int sys_shmdt(const void *shmaddr); }
// { int sys_sigpending(void); }
// { int sys_sigreturn(struct sigcontext *sigcntxp); }
// { int sys_sigsuspend(int mask); }
// { int sys_unlink(const char *path); }
// { int sys_vfork(void); }
// { int thr_self(long *id); }
// { int thr_suspend( const struct timespec *timeout); }
// { int thr_wake(long id); }
// { int umask(int newmask); } umask umask_args int
// { int undelete(char *path); }
// { int unlink(char *path); }
// { int vfork(void); }
// { int vmspace_destroy(void *id); }
// { int yield(void); }
// { int|sys|50|ntp_gettime(struct ntptimeval *ntvp); }
// { int|sys||__setlogin(const char *namebuf); }
// { int|sys||_lwp_continue(lwpid_t target); }
// { int|sys||_lwp_detach(lwpid_t target); }
// { int|sys||_lwp_exit(void); }
// { int|sys||_lwp_suspend(lwpid_t target); }
// { int|sys||_lwp_wakeup(lwpid_t target); }
// { int|sys||acct(const char *path); }
// { int|sys||chdir(const char *path); }
// { int|sys||chroot(const char *path); }
// { int|sys||close(int fd); }
// { int|sys||dup(int fd); }
// { int|sys||fchdir(int fd); }
// { int|sys||fchroot(int fd); }
// { int|sys||fdatasync(int fd); }
// { int|sys||fork(void); }
// { int|sys||fsync(int fd); }
// { int|sys||getcontext(struct __ucontext *ucp); }
// { int|sys||getpgrp(void); }
// { int|sys||issetugid(void); }
// { int|sys||kqueue(void); }
// { int|sys||kqueue1(int flags); }
// { int|sys||mlockall(int flags); }
// { int|sys||munlockall(void); }
// { int|sys||ntp_adjtime(struct timex *tp); }
// { int|sys||obreak(char *nsize); }
// { int|sys||ovadvise(int anom); }
// { int|sys||pipe(void); }
// { int|sys||pset_create(psetid_t *psid); }
// { int|sys||pset_destroy(psetid_t psid); }
// { int|sys||revoke(const char *path); }
// { int|sys||rmdir(const char *path); }
// { int|sys||sbrk(intptr_t incr); }
// { int|sys||sched_yield(void); }
// { int|sys||semconfig(int flag); }
// { int|sys||setcontext(const struct __ucontext *ucp); }
// { int|sys||setegid(gid_t egid); }
// { int|sys||seteuid(uid_t euid); }
// { int|sys||setgid(gid_t gid); }
// { int|sys||setsid(void); }
// { int|sys||setuid(uid_t uid); }
// { int|sys||shmdt(const void *shmaddr); }
// { int|sys||sstk(int incr); }
// { int|sys||timer_delete(timer_t timerid); }
// { int|sys||timer_getoverrun(timer_t timerid); }
// { int|sys||undelete(const char *path); }
// { int|sys||unlink(const char *path); }
// { int|sys||vfork(void); }
// { lwpid_t lwp_gettid(void); }
// { lwpid_t|sys||_lwp_self(void); }
// { mode_t sys_umask(mode_t newmask); }
// { mode_t|sys||umask(mode_t newmask); }
// { pid_t getpid(void); }
// { pid_t getppid(void); }
// { pid_t sys_getpgid(pid_t pid); }
// { pid_t sys_getpid(void); }
// { pid_t sys_getppid(void); }
// { pid_t sys_getsid(pid_t pid); }
// { pid_t sys_getthrid(void); }
// { pid_t vfork(void); }
// { pid_t|sys||getpgid(pid_t pid); }
// { pid_t|sys||getpid_with_ppid(void); }
// { pid_t|sys||getppid(void); }
// { pid_t|sys||getsid(pid_t pid); }
// { ssize_t aio_return(struct aiocb *aiocbp); }
// { uid_t geteuid(void); }
// { uid_t getuid(void); }
// { uid_t sys_geteuid(void); }
// { uid_t sys_getuid(void); }
// { uid_t|sys||geteuid(void); }
// { uid_t|sys||getuid_with_euid(void); }
// { void *sys___get_tcb(void); }
// { void *|sys||_lwp_getprivate(void); }
// { void exit(int rval); }
// { void sys___set_tcb(void *tcb); }
// { void sys___threxit(pid_t *notdead); }
// { void sys_exit(int rval); }
// { void sys_exit(int rval); } exit sys_exit_args void
// { void sys_sync(void); }
// { void thr_exit(long *state); }
// { void|sys||_lwp_setprivate(void *ptr); }
// { void|sys||exit(int rval); }
// { void|sys||sync(void); }
// {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
// }
//go:build 386 || amd64 || amd64p32 || alpha || arm || arm64 || loong64 || mipsle || mips64le || mips64p32le || nios2 || ppc64le || riscv || riscv64 || sh"
//go:build armbe || arm64be || m68k || mips || mips64 || mips64p32 || ppc || ppc64 || s390 || s390x || shbe || sparc || sparc64"
//go:noescape"
ShellCompDirectiveFilterDirs"
ShellCompDirectiveFilterFileExt"
type NullUUID struct {"
