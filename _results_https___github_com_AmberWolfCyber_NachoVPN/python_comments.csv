                    # Delegate HTTP processing to PluginManager
                    # No plugin handled the request, send 404"
                    # Process TCP messages"
                    # parse the packet                    "
                # Calculate hashes"
                # Calculate progress"
                # Create a new context for this connection"
                # Handle raw VPN data
                # Parse the HTTP request line and headers
                # Set the new context"
                # Skip headers
                # TODO: restore original IP and TCP ports"
                # We got an EAP packet which we need to parse
                # build a table of hashes for the script files"
                # iterate over the script_hashes and calculate the hash for each file"
                # send IF-T/TLS version: 2
                #dest_ip = socket.inet_ntoa(dest_ip_bytes)
                #dest_ip_bytes = packet.message_value[0x10:0x14]
            # Add AVPs"
            # Add CustomAction"
            # Add cabinet as a stream"
            # Add cabinet file to MSI"
            # Add new Media entry"
            # Add patches"
            # Add the AVP data"
            # Add the custom action to the MSI"
            # Add the property file to the MSI"
            # Add the sequence to the MSI"
            # Add to Component table"
            # Add to FeatureComponents table"
            # Add to File table"
            # Add to sequence"
            # Append to output buffer"
            # Auth response (ok)"
            # Build IFT packet"
            # Build the AVP data dynamically using the AVP class"
            # Construct EAP packet"
            # Copy default MSI file to payload directory
            # Create a new cabinet file"
            # Create a property to store the source"
            # Create the EAP data from AVP"
            # Create the EAP data"
            # EXPANDED_JUNIPER struct"
            # EXPANDED_JUNIPER structures"
            # End of configuration packet"
            # Final packet - send the license ID"
            # For some reason the property file needs to be added twice like this
            # Get the highest existing sequence number from the File table"
            # IFT-T/TLS Parser
            # Just keep reading from the client forever"
            # Not an SSL-VPN packet
            # Pass handling to data handler
            # Query the Feature table to get the Feature key"
            # Rebuild MSI with modified tables"
            # Remove existing signed file"
            # Send headers
            # Start the tunnel
            # append to list as a dict so we can reconstruct later"
            # attempt to compile the default payload from source
            # but it doesn't really matter for our use case
            # config packet, wrapped with IF-T"
            # first EXPANDED_JUNIPER struct"
            # now send the ESP config"
            # padding"
            # process attribute"
            # second EXPANDED_JUNIPER struct"
            # the sonicwallconnectagent:// URI handler must use the external IP address and NOT the DNS name
            # transition to IF-T/TLS"
        # Add additional routes specific to this plugin"
        # Add new Media entry"
        # Add to Component table"
        # Add to FeatureComponents table"
        # Add to File table"
        # Allow reuse of the address"
        # Build CA certificate"
        # Build server certificate signed by CA"
        # CONNECT tunnel is not currently supported
        # Calculate routes length"
        # Call the parent class's route setup
        # Certificate paths"
        # Check if CA cert already exists"
        # Check if MSI files are present"
        # Common plugin kwargs"
        # Config"
        # Convert certificate and key to PEM format"
        # Convert to pkcs12 and save to codesign.pfx"
        # Create Apple signing certificate"
        # Create a new CustomAction record"
        # Create a new cabinet file"
        # Create a property to store the source"
        # Create the code signing certificate"
        # Define Flask routes within the class
        # Download both MSI files"
        # EAP Packet: Vendor=0xa4c01, Code=2, Identifier=0x1, Length=14, Data=01616e6f6e796d6f7573"
        # EAP Packet: Vendor=0xa4c01, Code=2, Identifier=0x2, Length=296, Data=fe000a4c0000000100000d4980000010000005830000000400000d61 .."
        # EAP Packet: Vendor=0xa4c01, Code=2, Identifier=0x3, Length=56, Data=fe000a4c0000000100000d6d8000001000000583616161610000004f4000001a02000012fe000a4c000000020202056161610583"
        # EAP Packet: Vendor=0xa4c01, Code=2, Identifier=0x4, Length=28, Data=fe000a4c0000000100000d6b800000100000058300000010"
        # Final attributes"
        # Flags are stored in the most significant byte of the length field
        # Gateway config"
        # Generate CA private key
        # Generate a Windows code signing certificate"
        # Generate a private key for the code signing certificate"
        # Generate a private key"
        # Generate an Apple code signing certificate
        # Generate server private key"
        # Generate the final routes section"
        # Generate the macOS pkg payload (GlobalProtect.pkg)"
        # Get CA cert
        # Get a unique NAT port for this connection"
        # Get latest MSI version"
        # Get the highest existing sequence number from the File table"
        # Header
        # If the payload already exists and is validly signed, skip compilation/signing"
        # Initialize database"
        # Just send a KEEPALIVE packet back to the client
        # Load default certificate (IP cert)"
        # Load the CA certificate into the gateway config"
        # Modify packet for NAT"
        # New line after progress bar"
        # Parse the tunelled packet"
        # Patch the Windows MSI files and sign them"
        # Patch the msi files
        # Payload options"
        # Payload storage"
        # Process the TCP message data as needed
        # Query the Feature table to get the Feature key"
        # Re-calculate length for display purposes
        # Re-calculate length to ensure it's current
        # Recalculate checksums"
        # Recalculate length
        # Register plugins"
        # Routing info"
        # Run bootstrap"
        # Save CA cert and key"
        # Save the new certificate to a file"
        # Save the private key"
        # Schedule the CustomAction in the appropriate sequence"
        # Send a DPD-RESP packet back to the client
        # Send the Flask response back to the client
        # Send the packet out"
        # Set the SNI callback"
        # Set up Jinja2 environment if template_dir is provided"
        # Set version in gateway config"
        # Setup certificates"
        # Setup plugin manager with cert hash"
        # Sign the MSI files"
        # Sign the certificate with the CA private key"
        # TODO: log the client provided AVP data
        # Update the lengths"
        # Use Flask's test_client to handle the request"
        # Verify downloads"
        # Verify that the MSI files are signed by our current CA
        # Verify that the payload is signed by our current CA
        # Version marker + attribute"
        # allow overriding the thumbprint for fronting scenarios"
        # and attach any additional data from the DPD-REQ packet
        # but for now we'll just extract the password
        # check if the first AVP is 0xD49"
        # check if the issuer Common Name matches our self-signed CA"
        # check if the second AVP is 0xD61"
        # get required certificates"
        # increment the offset by the size of the signature data"
        # list of EKUs"
        # list of SANs"
        # now populate the TOC entry"
        # parse routing info"
        # provide the templates directory relative to this plugin
        # read the rest of the AVPs"
        # remove any padding"
        # seems to be: EXPANDED_JUNIPER + 0x01 + AVP(0xd6d)
        # server thumbprint is a dictionary with sha1 and md5 hashes of the DNS cert"
        # setup Flask app"
        # sign NACAgent.exe"
        # skip certificate validation if we're overriding the thumbprint or retrieving it dynamically from the server"
        # skip on Windows for now (we can use signtool if needed)
        # the next bytes *should* be 0x4f in big endian"
        # the user can provide their own sonicwall.pfx file in the certs directory"
        # there are some other fields/headers here we should maybe check"
        # this allows us to keep serving our origin certificate while advertising the proxy thumbprint
        # this certificate may be volume mounted (e.g. when using certbot outside of the container)
        # this helps to identify stale certificates when the CA certificate has been re-generated
        # this is needed for certain proxies which require the origin has a valid certificate
        #logging.debug('config header:')"
        #logging.debug('final attributes:')"
        #logging.debug('routing info:')"
        #logging.debug('version marker + attribute >= 9.1R14:')"
        #logging.debug('version marker + attribute >= 9.1R16:')"
        #self.hexdump(data)
        #self.hexdump(data[offset:])
    # Check if MSI files exist or if force download is enabled"
    # Section 2.5: The Keepalive and Dead Peer Detection Protocols"
    # figure out some offsets .."
    #logging.debug(toc_xml)"
"
"                    # No data available, continue"
"                # Add fake layer 2 data to the packet, if missing"
"                #self.logger.info('Got tunnelled IP packet with destination IP:', dest_ip)"
"            # TODO: we may wish to check that the cert chains to a trusted root CA in the future,"
"            # if the cert wasn't issued by our CA, then it's probably been signed by a public CA,"
"            # such as Let's Encrypt, and we should not re-generate it."
"            #x509.NameAttribute(NameOID.ORGANIZATION_NAME, self.ca_common_name),"
"        # Calculate the initial length (8 bytes for the header, optionally 4 bytes for the vendor, plus the value length)"
"        # fwiw, openconnect seems to differ here"
"        # if not, a new signing certificate will be generated and self-signed by the CA"
"        # if the issuer name matches, but the cert is not validly signed by the current CA, return False"
"        # if we didn't do this, the cert manager would detect a mismatch and re-generate the certificate"
"        # this contains OS info, user-agent, etc."
"    # {'type': ROUTE_SPLIT_EXCLUDE, 'route': '10.0.0.0/255.0.0.0'}"
"""""""Calculate the certificate thumbprint"""""""
"""""""Check if the certificate is valid"""""""
"""""""Check if this plugin can handle the given data"""""""
"""""""Close the database connection."""""""
"""""""Create SSL context with SNI support and proper TLS configuration"""""""
"""""""Determine if this plugin can handle the HTTP request"""""""
"""""""Generate a server certificate"""""""
"""""""Generate an Apple code signing certificate"""""""
"""""""Get the certificate thumbprint from a server"""""""
"""""""Handle raw VPN data"""""""
"""""""Helper method to log credentials to the database."""""""
"""""""Initialize the database connection and create tables if they don't exist."""""""
"""""""Load or generate a certificate for the server's DNS name"""""""
"""""""Load or generate a certificate for the server's external IP address"""""""
"""""""Load or generate the CA certificate"""""""
"""""""Log credentials using prepared statements."""""""
"""""""Register a plugin"""""""
"""""""Render a template with the given context"""""""
"""""""Setup the certificates and load the SSL context"""""""
"""""""Try each plugin to handle HTTP requests"""""""
"""""""Try each plugin to handle raw VPN data"""""""
"#00000030  03 00 00 00 40 25 00 01 01 2c 00 00 0d 03 00 00   |....@%...,......|"
#
# 0xfe000a4c"
# <signature-creation-time>461137009.8</signature-creation-time>"
# Example packet:"
# SSL-VPN packet types"
# https://datatracker.ietf.org/doc/html/draft-mavrogiannopoulos-openconnect-02"
#!/usr/bin/env python3
#00000000  00 00 0a 4c 00 00 00 01 00 00 01 60 00 00 01 fb   |...L.......`....|
#00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   |................|
#00000020  2e 20 f0 00 00 00 00 00 00 00 01 50 2e 00 00 0d   |. .........P....|
#00000040  00 40 26 00 01 01 2e 00 00 18 00 00 00 01 07 00   |.@&.............|
#00000050  00 10 00 00 ff ff 00 00 00 00 ff ff ff ff 00 00   |................|
#00000060  00 00 01 02 03 00 00 00 40 00 00 01 00 40 01 00   |........@....@..|
#00000070  01 00 40 1f 00 01 00 40 20 00 01 00 40 21 00 01   |..@....@ ...@!..|
#00000080  00 40 05 00 04 00 00 05 78 00 03 00 04 01 01 01   |.@......x.......|
#00000090  01 40 06 00 0d 6e 61 63 68 6f 76 70 6e 2e 6c 6f   |.@...nachovpn.lo|
#000000a0  6c 00 40 07 00 04 00 00 00 01 00 04 00 04 01 01   |l.@.............|
#000000b0  01 01 40 19 00 01 01 40 1a 00 01 00 40 24 00 01   |..@....@....@$..|
#000000c0  01 40 0f 00 02 00 00 40 10 00 02 00 05 40 11 00   |.@.....@.....@..|
#000000d0  02 00 03 40 12 00 04 00 00 04 b0 40 13 00 04 00   |...@.......@....|
#000000e0  00 00 00 40 14 00 04 00 00 00 01 40 15 00 04 00   |...@.......@....|
#000000f0  00 00 00 40 16 00 02 11 94 40 17 00 04 00 00 00   |...@.....@......|
#00000100  0f 40 18 00 04 00 00 00 3c 00 01 00 04 0a 0a 01   |.@......<.......|
#00000110  01 00 02 00 04 ff ff ff ff 40 0b 00 04 0a c8 c8   |.........@......|
#00000120  c8 40 0c 00 1d 43 3a 5c 57 69 6e 64 6f 77 73 5c   |.@...C:\Windows\|
#00000130  53 79 73 74 65 6d 33 32 5c 63 61 6c 63 2e 65 78   |System32\calc.ex|
#00000140  65 00 40 0d 00 01 00 40 0e 00 01 00 40 1b 00 01   |e.@....@....@...|
#00000150  00 40 1c 00 01 00 00 13 00 01 00 00 14 00 01 00   |.@..............|
